(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["RxPlayer"] = factory();
	else
		root["RxPlayer"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 195);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./src/utils/noop.ts
var noop = __webpack_require__(33);

// CONCATENATED MODULE: ./src/utils/logger.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var DEFAULT_LOG_LEVEL = "NONE";
/**
 * Logger implementation.
 * @class Logger
 */

var logger_Logger = /*#__PURE__*/function () {
  function Logger() {
    this.error = noop["a" /* default */];
    this.warn = noop["a" /* default */];
    this.info = noop["a" /* default */];
    this.debug = noop["a" /* default */];
    this.LEVELS = {
      NONE: 0,
      ERROR: 1,
      WARNING: 2,
      INFO: 3,
      DEBUG: 4
    };
    this.currentLevel = DEFAULT_LOG_LEVEL;
  }
  /**
   * @param {string} levelStr
   */


  var _proto = Logger.prototype;

  _proto.setLevel = function setLevel(levelStr) {
    var level;
    var foundLevel = this.LEVELS[levelStr];

    if (typeof foundLevel === "number") {
      level = foundLevel;
      this.currentLevel = levelStr;
    } else {
      // not found
      level = 0;
      this.currentLevel = "NONE";
    }
    /* tslint:disable no-invalid-this */

    /* tslint:disable no-console */


    this.error = level >= this.LEVELS.ERROR ? console.error.bind(console) : noop["a" /* default */];
    this.warn = level >= this.LEVELS.WARNING ? console.warn.bind(console) : noop["a" /* default */];
    this.info = level >= this.LEVELS.INFO ? console.info.bind(console) : noop["a" /* default */];
    this.debug = level >= this.LEVELS.DEBUG ? console.log.bind(console) : noop["a" /* default */];
    /* tslint:enable no-console */

    /* tslint:enable no-invalid-this */
  }
  /**
   * @returns {string}
   */
  ;

  _proto.getLevel = function getLevel() {
    return this.currentLevel;
  };

  return Logger;
}();


// CONCATENATED MODULE: ./src/log.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 // create a logger specifically for the RxPlayer.

var logger = new logger_Logger();
/* harmony default export */ var log = __webpack_exports__["a"] = (logger);

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return strToBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return bytesToStr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return bytesToUTF16Str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return hexToBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return bytesToHex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return concat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return be2toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return be3toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return be4toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return be8toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return le2toi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return le4toi; });
/* unused harmony export le8toi */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return itobe2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return itobe4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return itobe8; });
/* unused harmony export itole2 */
/* unused harmony export itole4 */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return guidToUuid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return isABEqualBytes; });
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Convert a simple string to an Uint8Array containing the corresponding
 * UTF-8 code units.
 * /!\ its implementation favors simplicity and performance over accuracy.
 * Each character having a code unit higher than 255 in UTF-16 will be
 * truncated (real value % 256).
 * Please take that into consideration when calling this function.
 * @param {string} str
 * @returns {Uint8Array}
 */

function strToBytes(str) {
  var len = str.length;
  var arr = new Uint8Array(len);

  for (var i = 0; i < len; i++) {
    arr[i] = str.charCodeAt(i) & 0xFF;
  }

  return arr;
}
/**
 * construct string from the code units given
 * @param {Uint16Array|Uint8Array} bytes
 * @returns {string}
 */


function bytesToStr(bytes) {
  // NOTE: ugly I know, but TS is problematic here (you can try)
  return String.fromCharCode.apply(null, bytes);
}
/**
 * construct string from the code units given.
 * Only use every other byte for each UTF-16 character.
 * @param {Uint8Array} bytes
 * @returns {string}
 */


function bytesToUTF16Str(bytes) {
  var str = "";
  var len = bytes.length;

  for (var i = 0; i < len; i += 2) {
    str += String.fromCharCode(bytes[i]);
  }

  return str;
}
/**
 * Convert hex codes in a string form into the corresponding bytes.
 * @param {string} str
 * @returns {Uint8Array}
 * @throws TypeError - str.length is odd
 */


function hexToBytes(str) {
  var len = str.length;
  var arr = new Uint8Array(len / 2);

  for (var i = 0, j = 0; i < len; i += 2, j++) {
    arr[j] = parseInt(str.substring(i, i + 2), 16) & 0xFF;
  }

  return arr;
}
/**
 * Convert bytes into the corresponding hex string, with the possibility
 * to add a separator.
 * @param {Uint8Array} bytes
 * @param {string} [sep=""] - separator. Separate each two hex character.
 * @returns {string}
 */


function bytesToHex(bytes, sep) {
  if (sep === void 0) {
    sep = "";
  }

  var hex = "";

  for (var i = 0; i < bytes.byteLength; i++) {
    hex += (bytes[i] >>> 4).toString(16);
    hex += (bytes[i] & 0xF).toString(16);

    if (sep.length > 0 && i < bytes.byteLength - 1) {
      hex += sep;
    }
  }

  return hex;
}
/**
 * Returns a Uint8Array from the arguments given, in order:
 *   - if the next argument given is a number N set the N next bytes to 0.
 *   - else set the next bytes to the argument given.
 * @param {...(Number|Uint8Array)} args
 * @returns {Uint8Array}
 */


function concat() {
  var l = arguments.length;
  var i = -1;
  var len = 0;
  var arg;

  while (++i < l) {
    arg = i < 0 || arguments.length <= i ? undefined : arguments[i];
    len += typeof arg === "number" ? arg : arg.length;
  }

  var arr = new Uint8Array(len);
  var offset = 0;
  i = -1;

  while (++i < l) {
    arg = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (typeof arg === "number") {
      offset += arg;
    } else if (arg.length > 0) {
      arr.set(arg, offset);
      offset += arg.length;
    }
  }

  return arr;
}
/**
 * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function be2toi(bytes, offset) {
  return (bytes[offset + 0] << 8) + (bytes[offset + 1] << 0);
}
/**
 * Translate groups of 3 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function be3toi(bytes, offset) {
  return bytes[offset + 0] * 0x0010000 + bytes[offset + 1] * 0x0000100 + bytes[offset + 2];
}
/**
 * Translate groups of 4 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function be4toi(bytes, offset) {
  return bytes[offset + 0] * 0x1000000 + bytes[offset + 1] * 0x0010000 + bytes[offset + 2] * 0x0000100 + bytes[offset + 3];
}
/**
 * Translate groups of 8 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function be8toi(bytes, offset) {
  return (bytes[offset + 0] * 0x1000000 + bytes[offset + 1] * 0x0010000 + bytes[offset + 2] * 0x0000100 + bytes[offset + 3]) * 0x100000000 + bytes[offset + 4] * 0x1000000 + bytes[offset + 5] * 0x0010000 + bytes[offset + 6] * 0x0000100 + bytes[offset + 7];
}
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding big-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */


function itobe2(num) {
  return new Uint8Array([num >>> 8 & 0xFF, num & 0xFF]);
}
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian
 * bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */


function itobe4(num) {
  return new Uint8Array([num >>> 24 & 0xFF, num >>> 16 & 0xFF, num >>> 8 & 0xFF, num & 0xFF]);
}
/**
 * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian
 * bytes.
 * /!\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus
 * leading to a "bad" value.
 * @param {Number} num
 * @returns {Uint8Array}
 */


function itobe8(num) {
  var l = num % 0x100000000;
  var h = (num - l) / 0x100000000;
  return new Uint8Array([h >>> 24 & 0xFF, h >>> 16 & 0xFF, h >>> 8 & 0xFF, h & 0xFF, l >>> 24 & 0xFF, l >>> 16 & 0xFF, l >>> 8 & 0xFF, l & 0xFF]);
}
/**
 * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function le2toi(bytes, offset) {
  return (bytes[offset + 0] << 0) + (bytes[offset + 1] << 8);
}
/**
 * Translate groups of 4 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function le4toi(bytes, offset) {
  return bytes[offset + 0] + bytes[offset + 1] * 0x0000100 + bytes[offset + 2] * 0x0010000 + bytes[offset + 3] * 0x1000000;
}
/**
 * Translate groups of 8 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */


function le8toi(bytes, offset) {
  return bytes[offset + 0] + bytes[offset + 1] * 0x0000100 + bytes[offset + 2] * 0x0010000 + bytes[offset + 3] * 0x1000000 + (bytes[offset + 4] + bytes[offset + 5] * 0x0000100 + bytes[offset + 6] * 0x0010000 + bytes[offset + 7] * 0x1000000) * 0x100000000;
}
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */


function itole2(num) {
  return new Uint8Array([num & 0xFF, num >>> 8 & 0xFF]);
}
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding
 * little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */


function itole4(num) {
  return new Uint8Array([num & 0xFF, num >>> 8 & 0xFF, num >>> 16 & 0xFF, num >>> 24 & 0xFF]);
}
/**
 * @param {string} uuid
 * @returns {string}
 * @throws AssertionError - The uuid length is not 16
 */


function guidToUuid(uuid) {
  Object(_assert__WEBPACK_IMPORTED_MODULE_0__[/* default */ "b"])(uuid.length === 16, "UUID length should be 16");
  var buf = strToBytes(uuid);
  var p1A = buf[0];
  var p1B = buf[1];
  var p1C = buf[2];
  var p1D = buf[3];
  var p2A = buf[4];
  var p2B = buf[5];
  var p3A = buf[6];
  var p3B = buf[7];
  var p4 = buf.subarray(8, 10);
  var p5 = buf.subarray(10, 16);
  var ord = new Uint8Array(16);
  ord[0] = p1D;
  ord[1] = p1C;
  ord[2] = p1B;
  ord[3] = p1A; // swap32 BE -> LE

  ord[4] = p2B;
  ord[5] = p2A; // swap16 BE -> LE

  ord[6] = p3B;
  ord[7] = p3A; // swap16 BE -> LE

  ord.set(p4, 8);
  ord.set(p5, 10);
  return bytesToHex(ord);
}
/**
 * Check if an ArrayBuffer is equal to the bytes given.
 * @param {ArrayBuffer} buffer
 * @param {Uint8Array} bytes
 * @returns {Boolean}
 */


function isABEqualBytes(buffer, bytes) {
  var view = new DataView(buffer);
  var len = view.byteLength;

  if (len !== bytes.length) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    if (view.getUint8(i) !== bytes[i]) {
      return false;
    }
  }

  return true;
}



/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isNonEmptyString; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {*} x
 * @returns {string}
 */
function isNonEmptyString(x) {
  return typeof x === "string" && x.length > 0;
}

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Configuration file for the whole player.
 * Feel free to tweak those values if you know what you're doing.
 *
 * Please not that you will need to re-build the whole project to take these
 * modifications into account.
 *
 * @type {Object}
 */
/* harmony default export */ __webpack_exports__["a"] = ({
  /**
   * Volume set on unMute if the volume is set to 0 and either:
   *   - mute has never been called before
   *   - mute has last been called while the volume was already set to 0 (either
   *     via setVolume, or a previous mute call)
   * @type {Number}
   */
  DEFAULT_UNMUTED_VOLUME: 0.1,

  /**
   * Default time interval after which a request will timeout, in ms.
   * @type {Number}
   */
  DEFAULT_REQUEST_TIMEOUT: 30 * 1000,

  /**
   * Can be either:
   *   - "native": Subtitles are all displayed in a <track> element
   *   - "html": Subtitles are all displayed in a <div> separated from the video
   *     element. Can be useful to display richer TTML subtitles, for example.
   * @type {Object|null}
   */
  DEFAULT_TEXT_TRACK_MODE: "native",

  /**
   * Strategy to adopt when manually setting the current bitrate.
   * Can be either:
   *   - "seamless": transitions are very smooth but not immediate.
   *   - "direct": the quality switch happens immediately but to achieve that,
   *     the player will need to set a new MediaSource on the media element in
   *     some cases. This often leads to a black screen + unavailable APIs
   *     during a short moment.
   * @type {string}
   */
  DEFAULT_MANUAL_BITRATE_SWITCHING_MODE: "seamless",

  /**
   * If set to true, video through loadVideo will auto play by default
   * @type {Boolean}
   */
  DEFAULT_AUTO_PLAY: false,

  /**
   * If set to false, "native" subtitles (in a <track> element) will be hidden
   * by default.
   * @type {Boolean}
   */
  DEFAULT_SHOW_NATIVE_SUBTITLE: true,

  /**
   * If set to true, the player will by default stop immediately and unload the
   * content on reaching the end of the media.
   *
   * If set to false, it will not unload nor stop by default, leaving the user
   * free to seek in the already-loaded content.
   *
   * Set to `true` for legacy reasons.
   * @type {Boolean}
   */
  DEFAULT_STOP_AT_END: true,

  /**
   * Default buffer goal in seconds.
   * Once enough content has been downloaded to fill the buffer up to
   * ``current position + DEFAULT_WANTED_BUFFER_AHEAD", we will stop downloading
   * content.
   * @type {Number}
   */
  DEFAULT_WANTED_BUFFER_AHEAD: 30,

  /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _after_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
  DEFAULT_MAX_BUFFER_AHEAD: Infinity,

  /**
   * Default max buffer size ahead of the current position in seconds.
   * The buffer _before_ this limit will be garbage collected.
   * Set to Infinity for no limit.
   * @type {Number}
   */
  DEFAULT_MAX_BUFFER_BEHIND: Infinity,

  /* tslint:disable no-object-literal-type-assertion */

  /**
   * Maximum possible buffer ahead for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
  MAXIMUM_MAX_BUFFER_AHEAD: {
    text: 5 * 60 * 60
  },

  /* tslint:enable no-object-literal-type-assertion */

  /* tslint:disable no-object-literal-type-assertion */

  /**
   * Maximum possible buffer behind for each type of buffer, to avoid too much
   * memory usage when playing for a long time.
   * Equal to Infinity if not defined here.
   * @type {Object}
   */
  MAXIMUM_MAX_BUFFER_BEHIND: {
    text: 5 * 60 * 60
  },

  /* tslint:enable no-object-literal-type-assertion */

  /**
   * Default bitrate ceils initially set as the first content begins.
   *
   * If no track is found with a bitrate inferior or equal to the
   * bitrate there, the one with the lowest bitrate will be taken instead.
   *
   * Set to 0 for the lowest bitrate, Infinity for the highest.
   *
   * These values are only useful for the first content played, as consecutive
   * play will always take the last set one.
   * @type {Object}
   */
  DEFAULT_INITIAL_BITRATES: {
    audio: 0,
    video: 0,
    other: 0
  },

  /* tslint:disable no-object-literal-type-assertion */

  /**
   * Default bitrate ceil initially set to dictate the maximum bitrate the
   * ABR manager can automatically switch to.
   *
   * If no track is found with a quality inferior or equal to the
   * bitrate there, the lowest bitrate will be taken instead.
   *
   * Set to Infinity to discard any limit in the ABR strategy.
   * @type {Object}
   */
  DEFAULT_MAX_BITRATES: {
    audio: Infinity,
    video: Infinity,
    other: Infinity
  },

  /* tslint:enable no-object-literal-type-assertion */

  /**
   * Delay after which, if the page is hidden, the user is considered inactive
   * on the current video.
   *
   * Allow to enforce specific optimizations when the page is not shown.
   * @see DEFAULT_THROTTLE_WHEN_HIDDEN
   * @type {Number}
   */
  INACTIVITY_DELAY: 60 * 1000,

  /**
   * If true, if the player is in a "hidden" state for a delay specified by the
   * INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
  DEFAULT_THROTTLE_WHEN_HIDDEN: false,

  /**
   * If true, if the video is considered in a "hidden" state for a delay specified by
   * the INACTIVITY DELAY config property, we throttle automatically to the video
   * representation with the lowest bitrate.
   * @type {Boolean}
   */
  DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN: false,

  /**
   * If true, the video representations you can switch to in adaptive mode
   * are limited by the video element's width.
   *
   * Basically in that case, we won't switch to a video Representation with
   * a width higher than the current width of the video HTMLElement.
   * @type {Boolean}
   */
  DEFAULT_LIMIT_VIDEO_WIDTH: false,

  /**
   * Default initial live gap considered if no presentation delay has been
   * suggested, in seconds.
   * @type {Number}
   */
  DEFAULT_LIVE_GAP: {
    DEFAULT: 10,
    LOW_LATENCY: 3
  },

  /**
   * Maximum time, in seconds, the player should automatically skip when stalled
   * because of a discontinuity in the downloaded range.
   * @type {Number}
   */
  BUFFER_DISCONTINUITY_THRESHOLD: 1,

  /**
   * Ratio used to know if an already loaded segment should be re-buffered.
   * We re-load the given segment if the current one times that ratio is
   * inferior to the new one.
   * @type {Number}
   */
  BITRATE_REBUFFERING_RATIO: 1.5,

  /**
   * Those are used when a "QuotaExceededError" error is received after
   * appending a new segment in the SourceBuffer.
   *
   * This error can arise when the browser's buffer is considered full.
   * In this case, the player goes into manual garbage collection (GC) mode.
   * @type {Object}
   */
  BUFFER_GC_GAPS: {
    /**
     * _Low_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received.
     * In seconds.
     * @type {Number}
     */
    CALM: 240,

    /**
     * _High_ gap (from current position) from which the buffer will be _garbage
     * collected_ (read removed from the buffer) when a QuotaExceededError is
     * received, if the low one does not clean up any buffer.
     * In seconds.
     * @type {Number}
     */
    BEEFY: 30
  },

  /**
   * The default number of times a manifest request will be re-performed
   * when loaded/refreshed if the request finishes on an error which
   * justify an retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE).
   * @type Number
   */
  DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,

  /**
   * The default number of times a segment request will be re-performed when
   * on error which justify a retry.
   *
   * Note that some errors do not use this counter:
   *   - if the error is not due to the xhr, no retry will be peformed
   *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
   *     retry will be performed.
   *   - if it has a high chance of being due to the user being offline, a
   *     separate counter is used (see DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE).
   * @type Number
   */
  DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR: 4,

  /**
   * Under some circonstances, we're able to tell that the user is offline (see
   * the compat files).
   * When this happens, and xhr requests fails due to an error event (you might
   * still be able to perform xhr offline, e.g. on localhost), you might want to
   * retry indefinitely or with a higher number of retry than if the error is
   * due to a CDN problem.
   *
   * A capped exponential backoff will still be used (like for an error code).
   * @type {Number}
   */
  DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE: Infinity,

  /**
   * Initial backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * This delay will then grow exponentally by power of twos (200, 400, 800
   * etc.)
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
  INITIAL_BACKOFF_DELAY_BASE: {
    REGULAR: 200,
    LOW_LATENCY: 50
  },

  /**
   * Maximum backoff delay when a segment / manifest download fails, in
   * milliseconds.
   *
   * Please note that this delay is not exact, as it will be fuzzed.
   * @type {Number}
   */
  MAX_BACKOFF_DELAY_BASE: {
    REGULAR: 3000,
    LOW_LATENCY: 1000
  },

  /**
   * Minimum interval at which timeupdate events will be "constructed". This
   * variable is for the "regular" mediasource strategy (that is, not for the
   * directfile API.
   *
   * Those events are the base of various important mechanisms in the player:
   *   - set the clock for the buffer.
   *   - set the clock for the ABR strategy.
   *   - used to trigger positionUpdate events.
   *
   * This common logic is for performance reasons, as we call multiple browser's
   * APIs which are useful for most of these.
   *
   * Keep in mind this is the minimum interval. This logic will also be
   * triggered when various events of the media element are received.
   * @type {Number}
   */
  SAMPLING_INTERVAL_MEDIASOURCE: 1000,

  /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for lowLatency mode.
   * @type {Number}
   */
  SAMPLING_INTERVAL_LOW_LATENCY: 250,

  /**
   * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
   * @type {Number}
   */
  SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,

  /**
   * Minimum number of bytes sampled before we trust the estimate.
   * If we have not sampled much data, our estimate may not be accurate
   * enough to trust.
   * If the total of bytes sampled is less than this value, we use a
   * default estimate.
   * This specific value is based on experimentations.
   * @type {Number}
   */
  ABR_MINIMUM_TOTAL_BYTES: 150e3,

  /**
   * Minimum number of bytes, under which samples are discarded.
   * Our models do not include latency information, so connection startup time
   * (time to first byte) is considered part of the download time.
   * Because of this, we should ignore very small downloads which would cause
   * our estimate to be too low.
   * This specific value is based on experimentation.
   * @type {Number}
   */
  ABR_MINIMUM_CHUNK_SIZE: 16e3,

  /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is in
   * starvation mode.
   * @type {Object}
   */
  ABR_STARVATION_FACTOR: {
    DEFAULT: 0.72,
    LOW_LATENCY: 0.64
  },

  /**
   * Factor with which is multiplied the bandwidth estimate when the ABR is not
   * in starvation mode.
   * @type {Object}
   */
  ABR_REGULAR_FACTOR: {
    DEFAULT: 0.9,
    LOW_LATENCY: 0.9
  },

  /**
   * If a SourceBuffer has less than ABR_STARVATION_GAP in seconds ahead of the
   * current position in its buffer, the ABR manager will go into starvation
   * mode.
   *
   * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
   * reached.
   *
   * Under this starvation mode:
   *
   *   - the bandwidth considered will be a little lower than the one estimated
   *
   *   - the time the next important request take will be checked
   *     multiple times to detect when/if it takes too much time.
   *     If the request is considered too long, the bitrate will be hastily
   *     re-calculated from this single request.
   *
   * @type {Object}
   */
  ABR_STARVATION_GAP: {
    DEFAULT: 5,
    LOW_LATENCY: 5
  },
  OUT_OF_STARVATION_GAP: {
    DEFAULT: 7,
    LOW_LATENCY: 7
  },

  /**
   * This is a security to avoid going into starvation mode when the content is
   * ending (@see ABR_STARVATION_GAP).
   * Basically, we subtract that value from the global duration of the content
   * and we never enter "starvation mode" if the currently available buffer
   * (which equals to the current position + the available buffer ahead of it)
   * is equal or higher than this value.
   * @type {Number}
   */
  ABR_STARVATION_DURATION_DELTA: 0.1,

  /**
   * Half-life, in seconds for a fastly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic will react to the bandwidth
   * falling quickly.
   * Should be kept to a lower number than ABR_SLOW_EMA for coherency reasons.
   * @type {Number}
   */
  ABR_FAST_EMA: 2,

  /**
   * Half-life, in seconds for a slowly-evolving exponential weighted moving
   * average.
   * The lower it is, the faster the ABR logic is going to react to recent
   * bandwidth variation, on the higher and on the lower side.
   * Should be kept to a higher number than ABR_FAST_EMA for coherency reasons.
   * @type {Number}
   */
  ABR_SLOW_EMA: 10,

  /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * seeking on an unbuffered part of the content.
   * @type {Number}
   */
  RESUME_GAP_AFTER_SEEKING: {
    DEFAULT: 1.5,
    LOW_LATENCY: 0.5
  },

  /**
   * Number of seconds ahead in the buffer after which playback will resume when
   * the player was stalled due to a low readyState.
   * @type {Number}
   */
  RESUME_GAP_AFTER_NOT_ENOUGH_DATA: {
    DEFAULT: 0.5,
    LOW_LATENCY: 0.5
  },

  /**
   * Number of seconds ahead in the buffer after which playback will resume
   * after the player went through a buffering step.
   * @type {Number}
   */
  RESUME_GAP_AFTER_BUFFERING: {
    DEFAULT: 5,
    LOW_LATENCY: 0.5
  },

  /**
   * Maximum number of seconds in the buffer based on which a "stalling"
   * strategy will be considered:
   * The player will pause playback to get enough time building a sufficient
   * buffer. This mostly happen when seeking in an unbuffered part or when
   * buffering.
   * @type {Number}
   */
  STALL_GAP: {
    DEFAULT: 0.5,
    LOW_LATENCY: 0.2
  },

  /**
   * Maximum authorized difference between what we calculated to be the
   * beginning or end of the segment in the SourceBuffer and what we
   * actually are noticing now.
   *
   * If the segment seems to have removed more than this size in seconds, we
   * will infer that the segment has been garbage collected and we might try to
   * re-download it.
   * @type {Number}
   */
  MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: 0.15,

  /**
   * The maximum authorized difference, in seconds, between the real buffered
   * time of a given chunk and what the segment information of the Manifest
   * tells us.
   *
   * Setting a value too high can lead to parts of the SourceBuffer being
   * linked to the wrong segments and to segments wrongly believed to be still
   * complete (instead of garbage collected).
   *
   * Setting a value too low can lead to parts of the SourceBuffer not being
   * linked to the concerned segment and to segments wrongly believed to be
   * partly garbage collected (instead of complete segments).
   * @type {Number}
   */
  MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE: 0.4,

  /**
   * The maximum authorized difference, in seconds, between the duration a
   * segment should have according to the Manifest and the actual duration it
   * seems to have once pushed to the SourceBuffer.
   *
   * Setting a value too high can lead to parts of the SourceBuffer being
   * linked to the wrong segments and to segments wrongly believed to be still
   * complete (instead of garbage collected).
   *
   * Setting a value too low can lead to parts of the SourceBuffer not being
   * linked to the concerned segment and to segments wrongly believed to be
   * partly garbage collected (instead of complete segments). This last point
   * could lead to unnecessary segment re-downloading.
   * @type {Number}
   */
  MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE: 0.3,

  /**
   * Minimum duration in seconds a segment should be into a buffered range to be
   * considered as part of that range.
   * Segments which have less than this amount of time "linked" to a buffered
   * range will be deleted.
   *
   * Setting a value too low can lead in worst-case scenarios to segments being
   * wrongly linked to the next or previous range it is truly linked too (if
   * those ranges are too close).
   *
   * Setting a value too high can lead to part of the buffer not being assigned
   * any segment. It also limits the minimum duration a segment can be.
   *
   * TODO As of now, this limits the minimum size a complete segment can be. A
   * better logic would be to also consider the duration of a segment. Though
   * this logic could lead to bugs with the current code.
   * @type {Number}
   */
  MINIMUM_SEGMENT_SIZE: 0.005,

  /**
   * Append windows allow to filter media data from segments if they are outside
   * a given limit.
   * Coded frames with presentation timestamp within this range are allowed to
   * be appended to the SourceBuffer while coded frames outside this range are
   * filtered out.
   *
   * Those are often set to be the start and end of the "Period" the segment is
   * in.
   * However, we noticed that some browsers were too aggressive when the exact
   * limits were set: more data than needed was removed, often leading to
   * discontinuities.
   *
   * Those securities are added to the set windows (substracted from the window
   * start and added to the window end) to avoid those problems.
   * @type {Object}
   */
  APPEND_WINDOW_SECURITIES: {
    START: 0.2,
    END: 0.1
  },

  /**
   * Maximum interval at which text tracks are refreshed in an "html"
   * textTrackMode.
   *
   * The text tracks are also refreshed on various video events, this interval
   * will only trigger a refresh if none of those events was received during
   * that timespan.
   *
   * Note that if the TextTrack cue did not change between two intervals or
   * events, the DOM won't be refreshed.
   * The TextTrack cues structure is also optimized for fast retrieval.
   * We should thus not have much of a performance impact here if we set a low
   * interval.
   *
   * @type {Number}
   */
  MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,

  /**
   * On browsers with no ResizeObserver API, this will be the interval in
   * milliseconds at which we should check if the text track element has
   * changed its size, and updates proportional text-track data accordingly
   * (like a proportional font-size).
   *
   * This is only used:
   *   - in an "html" textTrackMode
   *   - when some styling is proportional in the text track data
   *
   * Putting a value too low will render faster but might use to much proc time.
   * Putting a value too high might provoke a re-render too late after the user
   * changed the element's size (e.g. when going to fullscreen mode).
   *
   * @type {Number}
   */
  TEXT_TRACK_SIZE_CHECKS_INTERVAL: 250,

  /**
   * The Buffer padding is a time offset from the current time that affects
   * the buffer.
   *
   * Basically, from a given time, if the current buffer gap number (time
   * between the current time and the end of the downloaded buffer) is above
   * the padding described here (of the corresponding type), we won't
   * reschedule segments for that range.
   *
   * This is to avoid excessive re-buffering.
   *
   * Keeping the padding too low would increase the risk of re-bufferings.
   *
   * Keeping the padding too high would delay visible quality increase.
   *
   * @type {Object}
   */
  BUFFER_PADDING: {
    audio: 1,
    video: 3,
    other: 1
  },

  /**
   * Segments of different types are downloaded by steps:
   *
   *   - first the audio/video/text Segments which are immediately needed
   *
   *   - then once every of those Segments have been downloaded, less-needed
   *     Segments
   *
   *   - then once every of those less-needed Segments have been downloaded,
   *     even less-needed Segments
   *
   *   - etc.
   *
   * This stepped download strategy allows to make a better use of network
   * ressources.
   *
   * For example, if more than sufficient audio buffer has been downloaded but
   * the immediately-needed video Segment is still pending its request, we might
   * be in a situation of rebuffering.
   * In that case, a better strategy would be to make sure every network
   * ressource is allocated for this video Segment before rebuffering happens.
   *
   * This is where those steps become useful.
   *
   * --
   *
   * The numbers defined in this Array describe what the steps are.
   *
   * Each number is linked to a distance from the current playing position, in
   * seconds.
   * Distances which will be used as limit points, from which a new step is
   * reached (see example).
   *
   * Note: You can set an empty array to deactivate the steps feature (every
   * Segments have the same priority).
   *
   * @example
   *
   * let's imagine the following SEGMENT_PRIORITIES_STEPS array:
   * [5, 11, 17, 25]
   *
   * To link each Segments to a corresponding priority (and thus to a specific
   * step), we have to consider the distance d between the current position and
   * the start time of the Segment.
   *
   * We have in our example 5 groups, which correspond to the following possible
   * d values:
   *   1. inferior to 5
   *   2. between 5 and 11
   *   3. between 11 and 17
   *   4. between 17 and 25
   *   5. superior to 25
   *
   * Segments corresponding to a lower-step will need to all be downloaded
   * before Segments of a newer step begin.
   *
   * @type {Array.<Number>}
   */
  SEGMENT_PRIORITIES_STEPS: [6, 14],

  /**
   * Robustnesses used in the {audio,video}Capabilities of the
   * MediaKeySystemConfiguration (EME).
   *
   * Only used for widevine keysystems.
   *
   * Defined in order of importance (first will be tested first etc.)
   * @type {Array.<string>}
   */
  EME_DEFAULT_WIDEVINE_ROBUSTNESSES: ["HW_SECURE_ALL", "HW_SECURE_DECODE", "HW_SECURE_CRYPTO", "SW_SECURE_DECODE", "SW_SECURE_CRYPTO"],

  /**
   * Link canonical key systems names to their respective reverse domain name,
   * used in the EME APIs.
   * This allows to have a simpler API, where users just need to set "widevine"
   * or "playready" as a keySystem.
   * @type {Object}
   */

  /* tslint:disable no-object-literal-type-assertion */
  EME_KEY_SYSTEMS: {
    clearkey: ["webkit-org.w3.clearkey", "org.w3.clearkey"],
    widevine: ["com.widevine.alpha"],
    playready: ["com.microsoft.playready", "com.chromecast.playready", "com.youtube.playready"]
  },

  /* tslint:enable no-object-literal-type-assertion */

  /**
   * When we detect that the local Manifest might be out-of-sync with the
   * server's one, we schedule a Manifest refresh.
   * However, as this "unsynchronization" is only a theory and as we do not want
   * to send too many Manifest requests, we keep a delay between the last
   * Manifest refresh done and that one.
   * This value indicates which delay we want. Note that the Manifest could
   * still be refreshed before this delay for other reasons.
   * @type {Number}
   */
  OUT_OF_SYNC_MANIFEST_REFRESH_DELAY: 3000,

  /**
   * When a partial Manifest update (that is an update with a partial sub-set
   * of the Manifest) fails, we will perform an update with the whole Manifest
   * instead.
   * To not overload the client - as parsing a Manifest can be resource heavy -
   * we set a minimum delay to wait before doing the corresponding request.
   * @type {Number}
   */
  FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY: 3000,

  /**
   * DASH Manifest based on a SegmentTimeline should normally have an
   * MPD@minimumUpdatePeriod attribute which should be sufficient to
   * know when to refresh it.
   * However, there is a specific case, for when it is equal to 0.
   * As of DASH-IF IOP (valid in v4.3), when a DASH's MPD set a
   * MPD@minimumUpdatePeriod to `0`, a client should not refresh the MPD
   * unless told to do so through inband events, in the stream.
   * In reality however, we found it to not always be the case (even with
   * DASH-IF own streams) and moreover to not always be the best thing to do.
   * We prefer to refresh in average at a regular interval when we do not have
   * this information.
   * /!\ This value is expressed in seconds.
   */
  DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0: 3,

  /**
   * Max simultaneous MediaKeySessions that will be kept as a cache to avoid
   * doing superfluous license requests.
   * If this number is reached, any new session creation will close the oldest
   * one.
   * @type {Number}
   */
  EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 50,

  /**
   * The player relies on browser events and properties to update its status to
   * "ENDED".
   *
   * Sadly in some cases, like in Chrome 54, this event is never triggered on
   * some contents probably due to a browser bug.
   *
   * This threshold resolves this issue by forcing the status to "ENDED" when:
   *   1. the player is stalling
   *   2. the absolute difference between current playback time and duration is
   *      under this value
   *
   * If set to null, this workaround is disabled and the player only relies on
   * browser events.
   *
   * @type {Number|null}
   */
  FORCED_ENDED_THRESHOLD: 0.001,

  /**
   * Maximum duration from the current position we will let in the buffer when
   * switching an Adaptation of a given type.
   *
   * For example, if we have ``text: { before: 1, after: 4 }``, it means that
   * when switching subtitles, we will let 1 second before and 4 second after
   * the current position in the previous language (until the new segments
   * overwrite it).
   * This is to allow smooth transitions and avoid de-synchronization that
   * can happen when removing the content being decoded.
   * @type {Object}
   */
  ADAPTATION_SWITCH_BUFFER_PADDINGS: {
    video: {
      before: 0.5,
      after: 1
    },
    audio: {
      before: 0.5,
      after: 2
    },
    text: {
      before: 0,
      after: 0
    },
    image: {
      before: 0,
      after: 0
    }
  },

  /**
   * Interval, in milliseconds, at which we should manually flush
   * SourceBuffers.
   * Some browsers (happened with firefox 66) sometimes "forget" to send us
   * `update` or `updateend` events.
   * In that case, we're completely unable to continue the queue here and
   * stay locked in a waiting state.
   * This interval is here to check at regular intervals if the underlying
   * SourceBuffer is currently updating.
   * @type {Number}
   */
  SOURCE_BUFFER_FLUSHING_INTERVAL: 2000,

  /**
   * Padding under which we should not buffer from the current time, on
   * Safari. To avoid some buffer appending issues on it, we decide not
   * to load a segment if it may be pushed during playback time.
   * @type {Number} - in seconds
   */
  CONTENT_REPLACEMENT_PADDING: 2
});

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __extends; });
/* unused harmony export __assign */
/* unused harmony export __rest */
/* unused harmony export __decorate */
/* unused harmony export __param */
/* unused harmony export __metadata */
/* unused harmony export __awaiter */
/* unused harmony export __generator */
/* unused harmony export __exportStar */
/* unused harmony export __values */
/* unused harmony export __read */
/* unused harmony export __spread */
/* unused harmony export __spreadArrays */
/* unused harmony export __await */
/* unused harmony export __asyncGenerator */
/* unused harmony export __asyncDelegator */
/* unused harmony export __asyncValues */
/* unused harmony export __makeTemplateObject */
/* unused harmony export __importStar */
/* unused harmony export __importDefault */
/* unused harmony export __classPrivateFieldGet */
/* unused harmony export __classPrivateFieldSet */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result.default = mod;
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
}

function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
}


/***/ }),
/* 5 */,
/* 6 */,
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function objectAssign(target) {
  if (target === null || target === undefined) {
    throw new TypeError("Cannot convert undefined or null to object");
  }

  var to = Object(target);

  for (var i = 0; i < (arguments.length <= 1 ? 0 : arguments.length - 1); i++) {
    var source = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        /* tslint:disable no-unnecessary-type-assertion */
        to[key] = source[key];
        /* tslint:enable no-unnecessary-type-assertion */
      }
    }
  }

  return to;
}
/* tslint:disable no-unbound-method */


/* harmony default export */ __webpack_exports__["a"] = (typeof Object.assign === "function" ? Object.assign :
/* tslint:enable no-unbound-method */
objectAssign);

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ event_listeners; });

// UNUSED EXPORTS: addClassName, addTextTrack, canPatchISOBMFFSegment, clearElementSrc, createSession, CustomMediaKeySystemAccess, exitFullscreen, generateKeyRequest, getInitData, hasEMEAPIs, isCodecSupported, isFullscreen, isOffline, isPlaybackStuck, isVTTCue, makeVTTCue, MediaSource_, onHeightWidthChange, play$, requestFullscreen, requestMediaKeySystemAccess, setElementSrc$, setMediaKeys, shouldReloadMediaSourceOnDecipherabilityUpdate, shouldRenewMediaKeys, shouldUnsetMediaKeys, shouldValidateMetadata, shouldWaitForDataBeforeLoaded, tryToChangeSourceBufferType, VTTCue_, whenLoadedMetadata$, whenMediaSourceOpen$

// EXTERNAL MODULE: ./src/compat/event_listeners.ts + 4 modules
var event_listeners = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/next-tick/index.js
var next_tick = __webpack_require__(73);
var next_tick_default = /*#__PURE__*/__webpack_require__.n(next_tick);

// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(25);

// EXTERNAL MODULE: ./src/compat/is_node.ts
var is_node = __webpack_require__(31);

// CONCATENATED MODULE: ./src/compat/patch_webkit_source_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


 // TODO This is the last ugly side-effect here.
// Either remove it or find the best way to implement that

function patchWebkitSourceBuffer() {
  // old WebKit SourceBuffer implementation,
  // where a synchronous append is used instead of appendBuffer

  /* tslint:disable no-unsafe-any */
  if (!is_node["a" /* default */] && window.WebKitSourceBuffer != null && !window.WebKitSourceBuffer.prototype.addEventListener) {
    var sourceBufferWebkitRef = window.WebKitSourceBuffer;
    var sourceBufferWebkitProto = sourceBufferWebkitRef.prototype;
    /* tslint:enable no-unsafe-any */

    for (var fnName in event_emitter["a" /* default */].prototype) {
      if (event_emitter["a" /* default */].prototype.hasOwnProperty(fnName)) {
        /* tslint:disable no-unsafe-any */
        sourceBufferWebkitProto[fnName] = event_emitter["a" /* default */].prototype[fnName];
        /* tslint:enable no-unsafe-any */
      }
    }
    /* tslint:disable no-unsafe-any */


    sourceBufferWebkitProto._listeners = [];

    sourceBufferWebkitProto.__emitUpdate = function (eventName, val) {
      var _this = this;

      next_tick_default()(function () {
        /* tslint:disable no-invalid-this */
        _this.trigger(eventName, val);

        _this.updating = false;

        _this.trigger("updateend");
        /* tslint:enable no-invalid-this */

      });
    };

    sourceBufferWebkitProto.appendBuffer = function (data) {
      /* tslint:disable no-invalid-this */
      if (this.updating) {
        throw new Error("updating");
      }

      this.trigger("updatestart");
      this.updating = true;

      try {
        this.append(data);
      } catch (error) {
        this.__emitUpdate("error", error);

        return;
      }

      this.__emitUpdate("update");
      /* tslint:enable no-invalid-this */

    };
    /* tslint:enable no-unsafe-any */

  }
}
// CONCATENATED MODULE: ./src/compat/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

























 // TODO TO REMOVE

patchWebkitSourceBuffer();


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isNullOrUndefined; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if... the argument given is neither null or undefined.
 * This function was added to have a clearer alternative to `== null` which is
 * not always understood by newcomers on the code, and which can be misused when
 * one of the two case is needed.
 * @param {*} x
 * @returns {*}
 */
function isNullOrUndefined(x) {
  return x === null || x === undefined;
}

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arrayIncludes; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Array.prototype.includes ponyfill.
 * Returns ``true`` if the given array ``arr`` contains the element
 * ``searchElement``. false ``otherwise``.
 *
 * Inspired from MDN polyfill, but ponyfilled instead
 *
 * @example
 * ```js
 * arrayIncludes([1, 2, 3], 3);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 7);
 * // => false
 *
 * const obj = { a: 4 };
 * arrayIncludes([obj, { b: 7 }, { a: 3 }], obj);
 * // => true
 *
 * // does not perform deep equality
 * arrayIncludes([{ a: 4 }, { b: 7 }, { a: 3 }], { a: 4 });
 * // => false
 *
 * // the third argument state the starting index. 0 if not set.
 *
 * arrayIncludes([1, 2, 3], 2, 1);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 2, 2);
 * // => false
 * ```
 *
 * @param {Array} arr
 * @param {*} searchElement
 * @param {number} [fromIndex]
 * @returns {boolean}
 */
function arrayIncludes(arr, searchElement, fromIndex) {
  /* tslint:disable no-unbound-method */
  if (typeof Array.prototype.includes === "function") {
    /* tslint:enable no-unbound-method */

    /* tslint:disable ban */
    return arr.includes(searchElement, fromIndex);
    /* tslint:enable ban */
  }

  var len = arr.length >>> 0;

  if (len === 0) {
    return false;
  }

  var n = fromIndex | 0;
  var k = n >= 0 ? Math.min(n, len - 1) : Math.max(len + n, 0);

  var areTheSame = function areTheSame(x, y) {
    return x === y || // Viva las JavaScriptas!
    typeof x === "number" && typeof y === "number" && isNaN(x) && isNaN(y);
  };

  while (k < len) {
    if (areTheSame(arr[k], searchElement)) {
      return true;
    }

    k++;
  }

  return false;
}

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * File allowing feature-switching.
 *
 * Every optional feature is included here.
 * They all should subsequently be accessed in the code through the exported
 * `features` object.
 *
 * The then exported features object will be used dynamically to know which
 * features are activated.
 *
 * This also lazy-feature loading, where this exported object can be updated
 * at runtime, to allow some new features even if the player instance has
 * already have been instanciated.
 */

/**
 * Initial features object, with no feature activated by default.
 * @type {Object}
 */

var features = {
  directfile: null,
  emeManager: null,
  htmlTextTracksBuffer: null,
  htmlTextTracksParsers: {},
  imageBuffer: null,
  imageParser: null,
  nativeTextTracksBuffer: null,
  nativeTextTracksParsers: {},
  transports: {}
};
/* harmony default export */ __webpack_exports__["a"] = (features);


/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Observable_Observable; });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(13);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/canReportError.js
/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */

function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber["a" /* Subscriber */]) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
//# sourceMappingURL=canReportError.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
var rxSubscriber = __webpack_require__(74);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observer.js
var Observer = __webpack_require__(87);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/toSubscriber.js
/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */



function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber["a" /* Subscriber */]) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber["a" /* rxSubscriber */]]) {
            return nextOrObserver[rxSubscriber["a" /* rxSubscriber */]]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber["a" /* Subscriber */](Observer["a" /* empty */]);
    }
    return new Subscriber["a" /* Subscriber */](nextOrObserver, error, complete);
}
//# sourceMappingURL=toSubscriber.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
var observable = __webpack_require__(54);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/noop.js
var noop = __webpack_require__(45);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/pipe.js
/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */

function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (!fns) {
        return noop["a" /* noop */];
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
//# sourceMappingURL=pipe.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/config.js
var config = __webpack_require__(41);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js
/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */





var Observable_Observable = /*@__PURE__*/ (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config["a" /* config */].useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config["a" /* config */].useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config["a" /* config */].useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable["a" /* observable */]] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());

function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config["a" /* config */].Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}
//# sourceMappingURL=Observable.js.map


/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Subscriber; });
/* unused harmony export SafeSubscriber */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(60);
/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(87);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22);
/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(74);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(41);
/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(64);
/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */







var Subscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__[/* empty */ "a"];
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__[/* empty */ "a"];
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__[/* rxSubscriber */ "a"]] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(_Subscription__WEBPACK_IMPORTED_MODULE_3__[/* Subscription */ "a"]));

var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__[/* isFunction */ "a"])(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_2__[/* empty */ "a"]) {
                context = Object.create(observerOrNext);
                if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__[/* isFunction */ "a"])(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ "a"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__[/* config */ "a"].useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__[/* hostReportError */ "a"])(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__[/* hostReportError */ "a"])(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ "a"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ "a"].useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__[/* hostReportError */ "a"])(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ "a"].useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (_config__WEBPACK_IMPORTED_MODULE_5__[/* config */ "a"].useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__[/* hostReportError */ "a"])(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

//# sourceMappingURL=Subscriber.js.map


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arrayFind; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */
function arrayFind(arr, predicate, thisArg) {
  if (typeof Array.prototype.find === "function") {
    /* tslint:disable no-unsafe-any */

    /* tslint:disable ban */
    return arr.find(predicate, thisArg);
    /* tslint:enable ban */

    /* tslint:enable no-unsafe-any */
  }

  var len = arr.length >>> 0;

  for (var i = 0; i < len; i++) {
    var val = arr[i];

    if (predicate.call(thisArg, val, i, arr)) {
      return val;
    }
  }

  return undefined;
}

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return REGXP_4_HEX_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return REGXP_8_HEX_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return REGXP_RGB_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return REGXP_RGBA_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return REGXP_LENGTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return REGXP_PERCENT_VALUES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return REGXP_TIME_COLON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return REGXP_TIME_COLON_FRAMES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return REGXP_TIME_COLON_MS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return REGXP_TIME_FRAMES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return REGXP_TIME_HMS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return REGXP_TIME_TICK; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
var REGXP_TIME_COLON_FRAMES = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/; // examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)

var REGXP_TIME_COLON = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/; // examples: 01:02:43.0345555 or 02:43.03

var REGXP_TIME_COLON_MS = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/; // examples: 75f or 75.5f

var REGXP_TIME_FRAMES = /^(\d*\.?\d*)f$/; // examples: 50t or 50.5t

var REGXP_TIME_TICK = /^(\d*\.?\d*)t$/; // examples: 3.45h, 3m or 4.20s

var REGXP_TIME_HMS = /^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/; // examples: 50% 10%

var REGXP_PERCENT_VALUES = /^(\d{1,2}|100)% (\d{1,2}|100)%$/;
var REGXP_LENGTH = /^((?:\+|\-)?\d*(?:\.\d+)?)(px|em|c|%|rh|rw)$/;
var REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/;
var REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;
var REGXP_RGB_COLOR = /^rgb\( *(\d+) *, *(\d+) *, *(\d+) *\)/;
var REGXP_RGBA_COLOR = /^rgba\( *(\d+) *, *(\d+) *, *(\d+) *, *(\d+) *\)/;


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return takeFirstSet; });
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function takeFirstSet() {
  var i = 0;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var len = args.length;

  while (i < len) {
    var arg = args[i];

    if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(arg)) {
      return arg;
    }

    i++;
  }
}

/***/ }),
/* 17 */,
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return calculateRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getIndexSegmentEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return toIndexTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fromIndexTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getTimescaledRange; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// byte-range

/**
 * Calculate the number of times a timeline element repeats based on the next
 * element.
 * @param {Object} element
 * @param {Object} nextElement
 * @param {number} maxPosition
 * @returns {Number}
 */
function calculateRepeat(element, nextElement, maxPosition) {
  var repeatCount = element.repeatCount;

  if (repeatCount >= 0) {
    return repeatCount;
  } // A negative value of the @r attribute of the S element indicates
  // that the duration indicated in @d attribute repeats until the
  // start of the next S element, the end of the Period or until the
  // next MPD update.


  var segmentEnd;

  if (nextElement != null) {
    segmentEnd = nextElement.start;
  } else if (maxPosition != null) {
    segmentEnd = maxPosition;
  } else {
    segmentEnd = Number.MAX_VALUE;
  }

  return Math.ceil((segmentEnd - element.start) / element.duration) - 1;
}
/**
 * Returns end of the segment given, in index time.
 * @param {Object} segment
 * @param {Object|null} [nextSegment]
 * @param {number} maxPosition
 * @returns {Number}
 */

function getIndexSegmentEnd(segment, nextSegment, maxPosition) {
  var start = segment.start,
      duration = segment.duration;

  if (duration <= 0) {
    return start;
  }

  var repeat = calculateRepeat(segment, nextSegment, maxPosition);
  return start + (repeat + 1) * duration;
}
/**
 * Convert from `presentationTime`, the time of the segment at the moment it
 * is decoded to `mediaTime`, the original time the segments point at.
 * @param {number} time
 * @param {Object} indexOptions
 * @returns {number}
 */

function toIndexTime(time, indexOptions) {
  return time * indexOptions.timescale + indexOptions.indexTimeOffset;
}
/**
 * Convert from `mediaTime`, the original time the segments point at to
 * `presentationTime`, the time of the segment at the moment it is decoded.
 * @param {number} time
 * @param {Object} indexOptions
 * @returns {number}
 */

function fromIndexTime(time, indexOptions) {
  return (time - indexOptions.indexTimeOffset) / indexOptions.timescale;
}
/**
 * @param {Number} start
 * @param {Number} duration
 * @param {Number} timescale
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */

function getTimescaledRange(start, duration, timescale) {
  return [start * timescale, (start + duration) * timescale];
}

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return convertToRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return excludeFromRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getInnerAndOuterTimeRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getLeftSizeOfRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getNextRangeGap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getPlayedSizeOfRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getSizeOfRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return insertInto; });
/* unused harmony export isAfter */
/* unused harmony export isBefore */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return isTimeInRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return isTimeInRanges; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return keepRangeIntersection; });
/* unused harmony export mergeContiguousRanges */
/* unused harmony export removeEmptyRanges */
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file contains functions helping with TimeRanges management.
 *
 * For simplicity/performance reasons, many of those work with a simplified
 * "Range" object, which is an object with two keys:
 *   - start {Number}
 *   - end {Number}
 *
 * Those two corresponds to what is returned by the start and end methods of a
 * TimeRanges Object.
 *
 * You can convert from TimeRanges to Range object(s) with the getRange/
 * convertToRanges methods.
 */
// Factor for rounding errors
var EPSILON = 1 / 60;
/**
 * Check equality with a tolerance of EPSILON.
 * Used for various functions with this sort of tolerance regarding the
 * start/end of contiguous ranges.
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */

function nearlyEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
}
/**
 * Construct a new range which will have, as start/end, the min/max
 * of both the range given, and the given bitrate.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Object}
 */


function createRangeUnion(range1, range2) {
  var start = Math.min(range1.start, range2.start);
  var end = Math.max(range1.end, range2.end);
  return {
    start: start,
    end: end
  };
}
/**
 * Clean array ranges from "empty" ranges.
 * That is, range objects which have their start equal to their end.
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */


function removeEmptyRanges(ranges) {
  for (var index = 0; index < ranges.length; index++) {
    var range = ranges[index];

    if (range.start === range.end) {
      ranges.splice(index++, 1);
    }
  }

  return ranges;
}
/**
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */


function mergeContiguousRanges(ranges) {
  for (var index = 1; index < ranges.length; index++) {
    var prevRange = ranges[index - 1];
    var currRange = ranges[index];

    if (areRangesNearlyContiguous(prevRange, currRange)) {
      var unionRange = createRangeUnion(prevRange, currRange);
      ranges.splice(--index, 2, unionRange);
    }
  }

  return ranges;
}
/**
 * True if range1 is considered _after_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */


function isAfter(range1, range2) {
  return range1.start >= range2.end;
}
/**
 * True if range1 is considered _before_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */


function isBefore(range1, range2) {
  return range1.end <= range2.start;
}
/**
 * Returns true if the time given can be considered as part of any of the given
 * ranges.
 * @param {Array.<Object>} ranges
 * @param {number} time
 * @returns {boolean}
 */


function isTimeInRanges(ranges, time) {
  for (var i = 0; i < ranges.length; i++) {
    if (isTimeInRange(ranges[i], time)) {
      return true;
    }
  }

  return false;
}
/**
 * Returns true if the time given can be considered as part of the given range.
 * @param {Object} range1
 * @param {Number} Time
 * @returns {Boolean}
 */


function isTimeInRange(_ref, time) {
  var start = _ref.start,
      end = _ref.end;
  return start <= time && time < end;
}
/**
 * Returns true if the two ranges given are overlapping.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */


function areRangesOverlapping(range1, range2) {
  return isTimeInRange(range1, range2.start) || range1.start < range2.end && range2.end < range1.end || isTimeInRange(range2, range1.start);
}
/**
 * Returns true if the two ranges given can be considered contiguous.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */


function areRangesNearlyContiguous(range1, range2) {
  return nearlyEqual(range2.start, range1.end) || nearlyEqual(range2.end, range1.start);
}
/**
 * Convert from a TimeRanges object to an array of Ranges.
 * @param {TimeRanges} timeRanges
 * @returns {Array.<Object>}
 */


function convertToRanges(timeRanges) {
  var ranges = [];

  for (var i = 0; i < timeRanges.length; i++) {
    ranges.push({
      start: timeRanges.start(i),
      end: timeRanges.end(i)
    });
  }

  return ranges;
}
/**
 * Get range object of a specific time in a TimeRanges object.
 * @param {TimeRanges} timeRanges
 * @returns {Object}
 */


function getRange(timeRanges, time) {
  for (var i = timeRanges.length - 1; i >= 0; i--) {
    var start = timeRanges.start(i);

    if (time >= start) {
      var end = timeRanges.end(i);

      if (time < end) {
        return {
          start: start,
          end: end
        };
      }
    }
  }

  return null;
}
/**
 * Get gap from a specific time until the start of the next Range.
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Number}
 */


function getNextRangeGap(timeRanges, time) {
  var len = timeRanges.length;

  for (var i = 0; i < len; i++) {
    var start = timeRanges.start(i);

    if (time < start) {
      return start - time;
    }
  }

  return Infinity;
}
/**
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Object} - Object with two properties:
 *   - outerRanges {Array.<Object>}: every ranges which does not contain the
 *     given time.
 *   - innerRange {Object|null}: the range which contain the given time.
 */


function getInnerAndOuterTimeRanges(timeRanges, time) {
  var innerRange = null;
  var outerRanges = [];

  for (var i = 0; i < timeRanges.length; i++) {
    var start = timeRanges.start(i);
    var end = timeRanges.end(i);

    if (time < start || time >= end) {
      outerRanges.push({
        start: start,
        end: end
      });
    } else {
      innerRange = {
        start: start,
        end: end
      };
    }
  }

  return {
    outerRanges: outerRanges,
    innerRange: innerRange
  };
}
/**
 * Get "size" (difference between end and start) of the range containing the
 * given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */


function getSizeOfRange(timeRanges, currentTime) {
  var range = getRange(timeRanges, currentTime);
  return range !== null ? range.end - range.start : 0;
}
/**
 * Get "currently played" (difference between time given and start) of the
 * range containing the given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */


function getPlayedSizeOfRange(timeRanges, currentTime) {
  var range = getRange(timeRanges, currentTime);
  return range !== null ? currentTime - range.start : 0;
}
/**
 * Get "left to play" (difference between end and time given) of the range
 * containing the given time. Infinity if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */


function getLeftSizeOfRange(timeRanges, currentTime) {
  var range = getRange(timeRanges, currentTime);
  return range !== null ? range.end - currentTime : Infinity;
}
/**
 * Insert a range object into an array of ranges objects, at the right place.
 * /!\ Mutate the array of ranges.
 * @param {Array.<Object>} ranges
 * @param {Object} rangeToAddArg
 * @returns {Array.<Object>}
 */


function insertInto(ranges, rangeToAddArg) {
  if (rangeToAddArg.start === rangeToAddArg.end) {
    return ranges;
  }

  var rangeToAdd = rangeToAddArg; // For each present range check if we need to:
  // - In case we are overlapping or contiguous:
  //   - if added range has the same bitrate as the overlapped or
  //     contiguous one, we can merge themcurrentRange
  //   - if added range has a different bitrate we need to insert it
  //     in place
  // - Need to insert in place, we we are completely, not overlapping
  //   and not contiguous in between two ranges.

  var index = 0;

  for (; index < ranges.length; index++) {
    var range = ranges[index];
    var overlapping = areRangesOverlapping(rangeToAdd, range);
    var contiguous = areRangesNearlyContiguous(rangeToAdd, range); // We assume ranges are ordered and two ranges can not be
    // completely overlapping.

    if (overlapping || contiguous) {
      rangeToAdd = createRangeUnion(rangeToAdd, range);
      ranges.splice(index--, 1);
    } else {
      // Check the case for which there is no more to do
      if (index === 0) {
        if (isBefore(rangeToAdd, ranges[0])) {
          // First index, and we are completely before that range (and
          // not contiguous, nor overlapping). We just need to be
          // inserted here.
          break;
        }
      } else {
        if (isBefore(ranges[index - 1], rangeToAdd) && isBefore(rangeToAdd, range)) {
          // We are exactly after the current previous range, and
          // before the current range, while not overlapping with none
          // of them. Insert here.
          break;
        }
      }
    }
  } // Now that we are sure we don't overlap with any range, just add it.


  ranges.splice(index, 0, rangeToAdd);
  return mergeContiguousRanges(removeEmptyRanges(ranges));
}
/**
 * Returns range, from a range objects array overlapping with a range given
 * in argument. null if none is found.
 * @param {Object} range
 * @param {Array.<Object>} ranges
 * @returns {Array.<Object>}
 */


function findOverlappingRanges(range, ranges) {
  var resultingRanges = [];

  for (var i = 0; i < ranges.length; i++) {
    if (areRangesOverlapping(range, ranges[i])) {
      resultingRanges.push(ranges[i]);
    }
  }

  return resultingRanges;
}
/**
 * Returns only the intersection between the two ranges, from the first
 * ranges argument given.
 * @param {Array.<Range>} ranges1
 * @param {Array.<Range>} ranges2
 * @returns {Array.<Range>}
 */


function keepRangeIntersection(ranges1, ranges2) {
  var result = [];

  for (var i = 0; i < ranges1.length; i++) {
    var range = ranges1[i];
    var overlappingRanges = findOverlappingRanges(range, ranges2);

    if (overlappingRanges.length > 0) {
      for (var j = 0; j < overlappingRanges.length; j++) {
        var overlappingRange = overlappingRanges[j];
        result.push({
          start: Math.max(range.start, overlappingRange.start),
          end: Math.min(range.end, overlappingRange.end)
        });
      }
    }
  }

  return result;
}
/**
 * Exclude from the `baseRanges` everything that is in `rangesToExclude`.
 * Example:
 *
 * Let's say we have the following base ranges:
 *       |==========|        |===============| |======|    |==========|
 *
 * From which we want to "exclude" the following ranges:
 *          |=========| |==|        |===|  |=====|
 *
 * We will obtain the first ranges from which we remove the second ranges:
 * -----------------------------------------------------------------------
 *       |==========|        |===============| |======|    |==========|
 *          |=========| |==|        |===|  |=====|
 * _______________________________________________________________________
 *                                     |
 *                                     |
 *                                     V
 * -----------------------------------------------------------------------
 *       |==|                |======|   |==|     |====|    |==========|
 * -----------------------------------------------------------------------
 *
 * @param {Array.<Object} baseRanges
 * @param {Array.<Object} rangesToExclude
 * @return {Array.<Object>}
 */


function excludeFromRanges(baseRanges, rangesToExclude) {
  var result = []; // For every range in `baseRanges`, find overlapping ranges with
  // `rangesToExclude` and remove them.

  for (var i = 0; i < baseRanges.length; i++) {
    var range = baseRanges[i];
    var intersections = [];
    var overlappingRanges = findOverlappingRanges(range, rangesToExclude);

    if (overlappingRanges.length > 0) {
      for (var j = 0; j < overlappingRanges.length; j++) {
        var overlappingRange = overlappingRanges[j];
        intersections.push({
          start: Math.max(range.start, overlappingRange.start),
          end: Math.min(range.end, overlappingRange.end)
        });
      }
    }

    if (intersections.length === 0) {
      result.push(range);
    } else {
      var lastStart = range.start;

      for (var _j = 0; _j < intersections.length; _j++) {
        if (intersections[_j].start > lastStart) {
          result.push({
            start: lastStart,
            end: intersections[_j].start
          });
        }

        lastStart = intersections[_j].end;
      }

      if (lastStart < range.end) {
        result.push({
          start: lastStart,
          end: range.end
        });
      }
    }
  }

  return result;
}



/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return warnOnce; });
/* harmony import */ var _array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var WARNED_MESSAGES = [];
/**
 * Perform a console.warn only once in the application lifetime.
 *
 * Useful for deprecated messages, for example.
 *
 * @param {string} message
 */

function warnOnce(message) {
  if (!Object(_array_includes__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(WARNED_MESSAGES, message)) {
    /* tslint:disable no-console */
    console.warn(message);
    /* tslint:enable no-console */

    WARNED_MESSAGES.push(message);
  }
}

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isIE11; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isIEOrEdge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isFirefox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isSafari; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return isSafariMobile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return isSamsungBrowser; });
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a;

 // true on IE11
// false on Edge and other IEs/browsers.

var isIE11 = !_is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] && !!window.MSInputMethodContext && !!document.documentMode; // true for IE / Edge

var isIEOrEdge = _is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] ? false : navigator.appName === "Microsoft Internet Explorer" || navigator.appName === "Netscape" && /(Trident|Edge)\//.test(navigator.userAgent);
var isFirefox = !_is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] && navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
var isSamsungBrowser = !_is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] && /SamsungBrowser/.test(navigator.userAgent);
var isSafari = !_is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] && (
/* tslint:disable ban */
Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") >= 0 ||
/* tslint:enable ban */

/* tslint:disable no-unsafe-any */
((_a = window.safari) === null || _a === void 0 ? void 0 : _a.pushNotification.toString()) === "[object SafariRemoteNotification]"
/* tslint:enable no-unsafe-any */
);
var isSafariMobile = !_is_node__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] && typeof navigator.platform === "string" && /iPad|iPhone|iPod/.test(navigator.platform);


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Subscription_Subscription; });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js
var isArray = __webpack_require__(53);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isObject.js
var isObject = __webpack_require__(98);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isFunction.js
var isFunction = __webpack_require__(60);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
var UnsubscriptionError = UnsubscriptionErrorImpl;
//# sourceMappingURL=UnsubscriptionError.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js
/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */




var Subscription_Subscription = /*@__PURE__*/ (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (Object(isFunction["a" /* isFunction */])(_unsubscribe)) {
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (Object(isArray["a" /* isArray */])(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (Object(isObject["a" /* isObject */])(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());

function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
}
//# sourceMappingURL=Subscription.js.map


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



function castToObservable(value) {
  if (value instanceof rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"]) {
    return value;
  }
  /* tslint:disable no-unsafe-any */


  if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(value) && typeof value.subscribe === "function") {
    /* tslint:enable no-unsafe-any */
    var valObsLike = value;
    return new rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (obs) {
      var sub = valObsLike.subscribe(function (val) {
        obs.next(val);
      }, function (err) {
        obs.error(err);
      }, function () {
        obs.complete();
      });
      return function () {
        if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(sub) && typeof sub.dispose === "function") {
          sub.dispose();
        } else if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(sub) && typeof sub.unsubscribe === "function") {
          sub.unsubscribe();
        }
      };
    });
  }
  /* tslint:disable no-unsafe-any */


  if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(value) && typeof value.then === "function") {
    /* tslint:enable no-unsafe-any */
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* from */ "a"])(value);
  }

  return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* of */ "a"])(value);
}

/* harmony default export */ __webpack_exports__["a"] = (castToObservable);

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: fetchIsSupported, fetchRequest, xhr

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(3);

// EXTERNAL MODULE: ./src/errors/request_error.ts
var request_error = __webpack_require__(139);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(9);

// CONCATENATED MODULE: ./src/utils/request/xhr.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var DEFAULT_REQUEST_TIMEOUT = config["a" /* default */].DEFAULT_REQUEST_TIMEOUT;
var DEFAULT_RESPONSE_TYPE = "json";
/**
 * @param {string} data
 * @returns {Object|null}
 */

function toJSONForIE(data) {
  try {
    return JSON.parse(data);
  } catch (e) {
    return null;
  }
}

function request(options) {
  var requestOptions = {
    url: options.url,
    headers: options.headers,
    responseType: Object(is_null_or_undefined["a" /* default */])(options.responseType) ? DEFAULT_RESPONSE_TYPE : options.responseType,
    timeout: Object(is_null_or_undefined["a" /* default */])(options.timeout) ? DEFAULT_REQUEST_TIMEOUT : options.timeout
  };
  return new Observable["a" /* Observable */](function (obs) {
    var url = requestOptions.url,
        headers = requestOptions.headers,
        responseType = requestOptions.responseType,
        timeout = requestOptions.timeout;
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);

    if (timeout >= 0) {
      xhr.timeout = timeout;
    }

    xhr.responseType = responseType;

    if (xhr.responseType === "document") {
      xhr.overrideMimeType("text/xml");
    }

    if (!Object(is_null_or_undefined["a" /* default */])(headers)) {
      var _headers = headers;

      for (var key in _headers) {
        if (_headers.hasOwnProperty(key)) {
          xhr.setRequestHeader(key, _headers[key]);
        }
      }
    }

    var sendingTime = performance.now();

    xhr.onerror = function onXHRError() {
      obs.error(new request_error["a" /* default */](url, xhr.status, "ERROR_EVENT", xhr));
    };

    xhr.ontimeout = function onXHRTimeout() {
      obs.error(new request_error["a" /* default */](url, xhr.status, "TIMEOUT", xhr));
    };

    if (options.sendProgressEvents === true) {
      xhr.onprogress = function onXHRProgress(event) {
        var currentTime = performance.now();
        obs.next({
          type: "progress",
          value: {
            url: url,
            duration: currentTime - sendingTime,
            sendingTime: sendingTime,
            currentTime: currentTime,
            size: event.loaded,
            totalSize: event.total
          }
        });
      };
    }

    xhr.onload = function onXHRLoad(event) {
      if (xhr.readyState === 4) {
        if (xhr.status >= 200 && xhr.status < 300) {
          var receivedTime = performance.now();
          var totalSize = xhr.response instanceof ArrayBuffer ? xhr.response.byteLength : event.total;
          var status = xhr.status;
          var loadedResponseType = xhr.responseType;

          var _url = Object(is_non_empty_string["a" /* default */])(xhr.responseURL) ? xhr.responseURL : url;

          var responseData;

          if (loadedResponseType === "json") {
            // IE bug where response is string with responseType json
            responseData = typeof xhr.response === "object" ?
            /* tslint:disable no-unsafe-any */
            xhr.response :
            /* tslint:enable no-unsafe-any */
            toJSONForIE(xhr.responseText);
          } else {
            /* tslint:disable no-unsafe-any */
            responseData = xhr.response;
            /* tslint:enable no-unsafe-any */
          }

          if (Object(is_null_or_undefined["a" /* default */])(responseData)) {
            obs.error(new request_error["a" /* default */](url, xhr.status, "PARSE_ERROR", xhr));
            return;
          }

          obs.next({
            type: "data-loaded",
            value: {
              status: status,
              url: _url,
              responseType: loadedResponseType,
              sendingTime: sendingTime,
              receivedTime: receivedTime,
              duration: receivedTime - sendingTime,
              size: totalSize,
              responseData: responseData
            }
          });
          obs.complete();
        } else {
          obs.error(new request_error["a" /* default */](url, xhr.status, "ERROR_HTTP_CODE", xhr));
        }
      }
    };

    xhr.send();
    return function () {
      if (!Object(is_null_or_undefined["a" /* default */])(xhr) && xhr.readyState !== 4) {
        xhr.abort();
      }
    };
  });
}

/* harmony default export */ var request_xhr = (request);
// CONCATENATED MODULE: ./src/utils/request/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ var utils_request = __webpack_exports__["a"] = (request_xhr);


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EventEmitter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fromEvent; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Simple but fully type-safe EventEmitter implementation.
 * @class EventEmitter
 */

var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    this._listeners = {};
  }
  /**
   * Register a new callback for an event.
   *
   * @param {string} evt - The event to register a callback to
   * @param {Function} fn - The callback to call as that event is triggered.
   * The callback will take as argument the eventual payload of the event
   * (single argument).
   */


  var _proto = EventEmitter.prototype;

  _proto.addEventListener = function addEventListener(evt, fn) {
    var listeners = this._listeners[evt];

    if (!Array.isArray(listeners)) {
      this._listeners[evt] = [fn];
    } else {
      listeners.push(fn);
    }
  }
  /**
   * Unregister callbacks linked to events.
   * @param {string} [evt] - The event for which the callback[s] should be
   * unregistered. Set it to null or undefined to remove all callbacks
   * currently registered (for any event).
   * @param {Function} [fn] - The callback to unregister. If set to null
   * or undefined while the evt argument is set, all callbacks linked to that
   * event will be unregistered.
   */
  ;

  _proto.removeEventListener = function removeEventListener(evt, fn) {
    if (Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(evt)) {
      this._listeners = {};
      return;
    }

    var listeners = this._listeners[evt];

    if (!Array.isArray(listeners)) {
      return;
    }

    if (Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(fn)) {
      delete this._listeners[evt];
      return;
    }

    var index = listeners.indexOf(fn);

    if (index !== -1) {
      listeners.splice(index, 1);
    }

    if (listeners.length === 0) {
      delete this._listeners[evt];
    }
  }
  /**
   * Trigger every registered callbacks for a given event
   * @param {string} evt - The event to trigger
   * @param {*} arg - The eventual payload for that event. All triggered
   * callbacks will recieve this payload as argument.
   */
  ;

  _proto.trigger = function trigger(evt, arg) {
    var listeners = this._listeners[evt];

    if (!Array.isArray(listeners)) {
      return;
    }

    listeners.slice().forEach(function (listener) {
      try {
        listener(arg);
      } catch (e) {
        _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].error(e, e instanceof Error ? e.stack : null);
      }
    });
  };

  return EventEmitter;
}();
/**
 * Simple redefinition of the fromEvent from rxjs to also work on our
 * implementation of EventEmitter with type-checked strings
 * @param {Object} target
 * @param {string} eventName
 * @returns {Observable}
 */



function fromEvent(target, eventName) {
  return new rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (obs) {
    function handler(event) {
      obs.next(event);
    }

    target.addEventListener(eventName, handler);
    return function () {
      target.removeEventListener(eventName, handler);
    };
  });
}

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HTMLElement_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return MediaKeys_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return MediaSource_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return READY_STATES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return VTTCue_; });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var _should_use_webkit_media_keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(99);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var win = _is_node__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"] ? {} : window;
/* tslint:disable no-unsafe-any */

var HTMLElement_ = win.HTMLElement;
var VTTCue_ = win.VTTCue != null ? win.VTTCue : win.TextTrackCue;
/* tslint:enable no-unsafe-any */

/* tslint:disable no-unsafe-any */

var MediaSource_ = win.MediaSource != null ? win.MediaSource : win.MozMediaSource != null ? win.MozMediaSource : win.WebKitMediaSource != null ? win.WebKitMediaSource : win.MSMediaSource;
/* tslint:enable no-unsafe-any */

var MediaKeys_ = function () {
  /* tslint:disable no-unsafe-any */
  if (Object(_should_use_webkit_media_keys__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])()) {
    return win.WebKitMediaKeys;
  }

  return win.MediaKeys != null ? win.MediaKeys : win.MSMediaKeys != null ? win.MSMediaKeys : win.MozMediaKeys != null ? win.MozMediaKeys : win.WebKitMediaKeys != null ? win.WebKitMediaKeys : /*#__PURE__*/function () {
    function _class() {
      var noMediaKeys = function noMediaKeys() {
        throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("MEDIA_KEYS_NOT_SUPPORTED", "No `MediaKeys` implementation found " + "in the current browser.");
      };

      this.create = noMediaKeys;
      this.createSession = noMediaKeys;
      this.isTypeSupported = noMediaKeys;
      this.setServerCertificate = noMediaKeys;
    }

    return _class;
  }();
  /* tslint:enable no-unsafe-any */
}();

var READY_STATES = {
  HAVE_NOTHING: 0,
  HAVE_METADATA: 1,
  HAVE_CURRENT_DATA: 2,
  HAVE_FUTURE_DATA: 3,
  HAVE_ENOUGH_DATA: 4
};


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return of; });
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);
/* harmony import */ var _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80);
/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */



function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__[/* isScheduler */ "a"])(scheduler)) {
        args.pop();
        return Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__[/* scheduleArray */ "a"])(args, scheduler);
    }
    else {
        return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__[/* fromArray */ "a"])(args);
    }
}
//# sourceMappingURL=of.js.map


/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return subscribeToResult; });
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);
/* harmony import */ var _subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(130);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12);
/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */



function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
    if (destination === void 0) {
        destination = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__[/* InnerSubscriber */ "a"](outerSubscriber, outerValue, outerIndex);
    }
    if (destination.closed) {
        return undefined;
    }
    if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_2__[/* Observable */ "a"]) {
        return result.subscribe(destination);
    }
    return Object(_subscribeTo__WEBPACK_IMPORTED_MODULE_1__[/* subscribeTo */ "a"])(result)(destination);
}
//# sourceMappingURL=subscribeToResult.js.map


/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OuterSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


var OuterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));

//# sourceMappingURL=OuterSubscriber.js.map


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Construct a "loaded" event.
 * @returns {Object}
 */
function loaded(sourceBuffersStore) {
  return {
    type: "loaded",
    value: {
      sourceBuffersStore: sourceBuffersStore
    }
  };
}
/**
 * Construct a "stalled" event.
 * @param {Object|null} stalling
 * @returns {Object}
 */


function stalled(stalling) {
  return {
    type: "stalled",
    value: stalling
  };
}
/**
 * Construct a "decipherabilityUpdate" event.
 * @param {Array.<Object>} arg
 * @returns {Object}
 */


function decipherabilityUpdate(arg) {
  return {
    type: "decipherabilityUpdate",
    value: arg
  };
}
/**
 * Construct a "manifestReady" event.
 * @param {Object} manifest
 * @returns {Object}
 */


function manifestReady(manifest) {
  return {
    type: "manifestReady",
    value: {
      manifest: manifest
    }
  };
}
/**
 * Construct a "manifestUpdate" event.
 * @returns {Object}
 */


function manifestUpdate() {
  return {
    type: "manifestUpdate",
    value: null
  };
}
/**
 * Construct a "speedChanged" event.
 * @param {Number} speed
 * @returns {Object}
 */


function speedChanged(speed) {
  return {
    type: "speedChanged",
    value: speed
  };
}
/**
 * Construct a "representationChange" event.
 * @param {string} type
 * @param {Object} period
 * @returns {Object}
 */


function nullRepresentation(type, period) {
  return {
    type: "representationChange",
    value: {
      type: type,
      representation: null,
      period: period
    }
  };
}
/**
 * construct a "warning" event.
 * @param {error} value
 * @returns {object}
 */


function warning(value) {
  return {
    type: "warning",
    value: value
  };
}
/**
 * construct a "reloading-media-source" event.
 * @returns {object}
 */


function reloadingMediaSource() {
  return {
    type: "reloading-media-source",
    value: undefined
  };
}

var INIT_EVENTS = {
  loaded: loaded,
  decipherabilityUpdate: decipherabilityUpdate,
  manifestReady: manifestReady,
  manifestUpdate: manifestUpdate,
  nullRepresentation: nullRepresentation,
  reloadingMediaSource: reloadingMediaSource,
  speedChanged: speedChanged,
  stalled: stalled,
  warning: warning
};
/* harmony default export */ __webpack_exports__["a"] = (INIT_EVENTS);

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var isNode = typeof window === "undefined";
/* harmony default export */ __webpack_exports__["a"] = (isNode);

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return map; });
/* unused harmony export MapOperator */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());

var MapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=map.js.map


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Do nothing (but do it well).
 *
 * Having this definition here allow to use the same reference each time a noop
 * is needed.
 * Also, it allows to avoid telling tslint to ignore empty blocks everywhere.
 */

/* tslint:disable:no-empty */
/* harmony default export */ __webpack_exports__["a"] = (function () {});
/* tslint:enable:no-empty */

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var pinkie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(170);
/* harmony import */ var pinkie__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pinkie__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ __webpack_exports__["a"] = (typeof Promise === "function" ? Promise : pinkie__WEBPACK_IMPORTED_MODULE_0___default.a);

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ getStylingAttributes; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ getStylingFromElement; });

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(14);

// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(10);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/utils/starts_with.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * String.prototype.startsWith ponyfill.
 * Indicates Whether a string starts with another substring.
 *
 * Inspired from MDN polyfill, but ponyfilled instead.
 * @param {string} completeString
 * @param {string} searchString
 * @param {number} [position]
 * @returns {boolean}
 */
function startsWith(completeString, searchString, position) {
  /* tslint:disable no-unbound-method */
  if (typeof String.prototype.startsWith === "function") {
    /* tslint:enable no-unbound-method */

    /* tslint:disable ban */
    return completeString.startsWith(searchString, position);
    /* tslint:enable ban */
  }

  var initialPosition = typeof position === "number" ? Math.max(position, 0) : 0;
  return completeString.substring(initialPosition, initialPosition + searchString.length) === searchString;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/get_styling.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Retrieve the attributes given in arguments in the given nodes and their
 * associated style(s)/region.
 * The first notion of the attribute encountered will be taken (by looping
 * through the given nodes in order).
 *
 * TODO manage IDREFS (plural) for styles and regions, that is, multiple one
 * @param {Array.<string>} attributes
 * @param {Array.<Node>} nodes
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @returns {Object}
 */

function getStylingAttributes(attributes, nodes, styles, regions) {
  var currentStyle = {};
  var leftAttributes = attributes.slice();

  for (var i = 0; i <= nodes.length - 1; i++) {
    var node = nodes[i];

    if (node !== undefined) {
      var _ret = function () {
        var styleID = void 0;
        var regionID = void 0; // 1. the style is directly set on a "tts:" attribute

        if (node.nodeType === Node.ELEMENT_NODE) {
          var element = node;

          for (var j = 0; j <= element.attributes.length - 1; j++) {
            var attribute = element.attributes[j];
            var name = attribute.name;

            if (name === "style") {
              styleID = attribute.value;
            } else if (name === "region") {
              regionID = attribute.value;
            } else {
              var nameWithoutTTS = name.substring(4);

              if (Object(array_includes["a" /* default */])(leftAttributes, nameWithoutTTS)) {
                currentStyle[nameWithoutTTS] = attribute.value;
                leftAttributes.splice(j, 1);

                if (leftAttributes.length === 0) {
                  return {
                    v: currentStyle
                  };
                }
              }
            }
          }
        } // 2. the style is referenced on a "style" attribute


        if (Object(is_non_empty_string["a" /* default */])(styleID)) {
          var style = Object(array_find["a" /* default */])(styles, function (x) {
            return x.id === styleID;
          });

          if (style !== undefined) {
            for (var _j = 0; _j <= leftAttributes.length - 1; _j++) {
              var _attribute = leftAttributes[_j];

              if (!Object(is_non_empty_string["a" /* default */])(currentStyle[_attribute])) {
                if (Object(is_non_empty_string["a" /* default */])(style.style[_attribute])) {
                  currentStyle[_attribute] = style.style[_attribute];
                  leftAttributes.splice(_j, 1);

                  if (leftAttributes.length === 0) {
                    return {
                      v: currentStyle
                    };
                  }

                  _j--;
                }
              }
            }
          }
        } // 3. the node reference a region (which can have a value for the
        //    corresponding style)


        if (Object(is_non_empty_string["a" /* default */])(regionID)) {
          var region = Object(array_find["a" /* default */])(regions, function (x) {
            return x.id === regionID;
          });

          if (region !== undefined) {
            for (var _j2 = 0; _j2 <= leftAttributes.length - 1; _j2++) {
              var _attribute2 = leftAttributes[_j2];

              if (!Object(is_non_empty_string["a" /* default */])(currentStyle[_attribute2])) {
                if (Object(is_non_empty_string["a" /* default */])(region.style[_attribute2])) {
                  currentStyle[_attribute2] = region.style[_attribute2];
                  leftAttributes.splice(_j2, 1);

                  if (leftAttributes.length === 0) {
                    return {
                      v: currentStyle
                    };
                  }

                  _j2--;
                }
              }
            }
          }
        }
      }();

      if (typeof _ret === "object") return _ret.v;
    }
  }

  return currentStyle;
}
/**
 * Returns the styling directly linked to an element.
 * @param {Node} node
 * @returns {Object}
 */

function getStylingFromElement(node) {
  if (node.nodeType !== Node.ELEMENT_NODE) {
    return {};
  }

  var element = node;
  var currentStyle = {};

  for (var i = 0; i <= element.attributes.length - 1; i++) {
    var styleAttribute = element.attributes[i];

    if (startsWith(styleAttribute.name, "tts")) {
      var nameWithoutTTS = styleAttribute.name.substring(4);
      currentStyle[nameWithoutTTS] = styleAttribute.value;
    }
  }

  return currentStyle;
}

/***/ }),
/* 36 */,
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return tryCatch; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Function} func - A function you want to execute
 * @param {*} args - The function's argument
 * @returns {*} - If it fails, returns a throwing Observable, else the
 * function's result (which should be, in most cases, an Observable).
 */

function tryCatch(func, args) {
  try {
    return func(args);
  } catch (e) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* throwError */ "a"])(e);
  }
}

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ErrorTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return NetworkErrorTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ErrorCodes; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ErrorTypes = {
  NETWORK_ERROR: "NETWORK_ERROR",
  MEDIA_ERROR: "MEDIA_ERROR",
  ENCRYPTED_MEDIA_ERROR: "ENCRYPTED_MEDIA_ERROR",
  OTHER_ERROR: "OTHER_ERROR"
};
var NetworkErrorTypes = {
  TIMEOUT: "TIMEOUT",
  ERROR_EVENT: "ERROR_EVENT",
  ERROR_HTTP_CODE: "ERROR_HTTP_CODE",
  PARSE_ERROR: "PARSE_ERROR"
};
var ErrorCodes = {
  PIPELINE_LOAD_ERROR: "PIPELINE_LOAD_ERROR",
  PIPELINE_PARSE_ERROR: "PIPELINE_PARSE_ERROR",
  INTEGRITY_ERROR: "INTEGRITY_ERROR",
  MANIFEST_PARSE_ERROR: "MANIFEST_PARSE_ERROR",
  MANIFEST_INCOMPATIBLE_CODECS_ERROR: "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
  MANIFEST_UPDATE_ERROR: "MANIFEST_UPDATE_ERROR",
  MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE",
  MEDIA_STARTING_TIME_NOT_FOUND: "MEDIA_STARTING_TIME_NOT_FOUND",
  MEDIA_TIME_BEFORE_MANIFEST: "MEDIA_TIME_BEFORE_MANIFEST",
  MEDIA_TIME_AFTER_MANIFEST: "MEDIA_TIME_AFTER_MANIFEST",
  MEDIA_TIME_NOT_FOUND: "MEDIA_TIME_NOT_FOUND",
  NO_PLAYABLE_REPRESENTATION: "NO_PLAYABLE_REPRESENTATION",
  MEDIA_IS_ENCRYPTED_ERROR: "MEDIA_IS_ENCRYPTED_ERROR",
  CREATE_MEDIA_KEYS_ERROR: "CREATE_MEDIA_KEYS_ERROR",
  KEY_ERROR: "KEY_ERROR",
  KEY_STATUS_CHANGE_ERROR: "KEY_STATUS_CHANGE_ERROR",
  KEY_UPDATE_ERROR: "KEY_UPDATE_ERROR",
  KEY_LOAD_ERROR: "KEY_LOAD_ERROR",
  KEY_LOAD_TIMEOUT: "KEY_LOAD_TIMEOUT",
  KEY_GENERATE_REQUEST_ERROR: "KEY_GENERATE_REQUEST_ERROR",
  INCOMPATIBLE_KEYSYSTEMS: "INCOMPATIBLE_KEYSYSTEMS",
  INVALID_ENCRYPTED_EVENT: "INVALID_ENCRYPTED_EVENT",
  INVALID_KEY_SYSTEM: "INVALID_KEY_SYSTEM",
  LICENSE_SERVER_CERTIFICATE_ERROR: "LICENSE_SERVER_CERTIFICATE_ERROR",
  MULTIPLE_SESSIONS_SAME_INIT_DATA: "MULTIPLE_SESSIONS_SAME_INIT_DATA",
  BUFFER_APPEND_ERROR: "BUFFER_APPEND_ERROR",
  BUFFER_FULL_ERROR: "BUFFER_FULL_ERROR",
  BUFFER_TYPE_UNKNOWN: "BUFFER_TYPE_UNKNOWN",
  MEDIA_ERR_BLOCKED_AUTOPLAY: "MEDIA_ERR_BLOCKED_AUTOPLAY",
  MEDIA_ERR_PLAY_NOT_ALLOWED: "MEDIA_ERR_PLAY_NOT_ALLOWED",
  MEDIA_ERR_NOT_LOADED_METADATA: "MEDIA_ERR_NOT_LOADED_METADATA",
  MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
  MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
  MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
  MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
  MEDIA_ERR_UNKNOWN: "MEDIA_ERR_UNKNOWN",
  MEDIA_SOURCE_NOT_SUPPORTED: "MEDIA_SOURCE_NOT_SUPPORTED",
  MEDIA_KEYS_NOT_SUPPORTED: "MEDIA_KEYS_NOT_SUPPORTED",
  NONE: "NONE"
};


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return hashBuffer; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Convert given buffer to a 32bit integer hash
 * @param {Array.<number>|TypedArray} buffer
 * @returns {number}
 */
function hashBuffer(buffer) {
  var hash = 0;

  var _char;

  for (var i = 0; i < buffer.length; i++) {
    _char = buffer[i];
    hash = (hash << 5) - hash + _char;
    hash = hash & hash; // Convert to 32bit integer
  }

  return hash;
}

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Store the MediaKeys infos attached to a media element.
var currentMediaState = new WeakMap();
/* harmony default export */ __webpack_exports__["a"] = ({
  /**
   * Update MediaKeys infos set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   * @param {Object} state
   */
  setState: function setState(mediaElement, state) {
    currentMediaState.set(mediaElement, state);
  },

  /**
   * Get MediaKeys infos currently set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   * @returns {Object}
   */
  getState: function getState(mediaElement) {
    var currentState = currentMediaState.get(mediaElement);
    return currentState == null ? null : currentState;
  },

  /**
   * Remove MediaKeys infos currently set on a HMTLMediaElement
   * @param {HTMLMediaElement} mediaElement
   */
  clearState: function clearState(mediaElement) {
    currentMediaState.set(mediaElement, null);
  }
});

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return config; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};
//# sourceMappingURL=config.js.map


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return async; });
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(86);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(85);
/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */


var async = /*@__PURE__*/ new _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__[/* AsyncScheduler */ "a"](_AsyncAction__WEBPACK_IMPORTED_MODULE_0__[/* AsyncAction */ "a"]);
//# sourceMappingURL=async.js.map


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return SubjectSubscriber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Subject; });
/* unused harmony export AnonymousSubject */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(58);
/* harmony import */ var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(105);
/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(74);
/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */







var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_2__[/* Subscriber */ "a"]));

var Subject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__[/* rxSubscriber */ "a"]] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ "a"]();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ "a"]();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ "a"]();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ "a"]();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__[/* ObjectUnsubscribedError */ "a"]();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__[/* Subscription */ "a"].EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__[/* Subscription */ "a"].EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__[/* SubjectSubscription */ "a"](this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new _Observable__WEBPACK_IMPORTED_MODULE_1__[/* Observable */ "a"]();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(_Observable__WEBPACK_IMPORTED_MODULE_1__[/* Observable */ "a"]));

var AnonymousSubject = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return _Subscription__WEBPACK_IMPORTED_MODULE_3__[/* Subscription */ "a"].EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));

//# sourceMappingURL=Subject.js.map


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return byteRange; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns text-formatted byteRange (`bytes=$start-$end?)`
 * @param {Array.<string|Number>} arr
 * @returns {string}
 */
function byteRange(_ref) {
  var start = _ref[0],
      end = _ref[1];
  return end === Infinity ? "bytes=" + start + "-" : "bytes=" + start + "-" + end;
}

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return noop; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() { }
//# sourceMappingURL=noop.js.map


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return arrayFindIndex; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */
function arrayFindIndex(arr, predicate, thisArg) {
  if (typeof Array.prototype.findIndex === "function") {
    /* tslint:disable no-unsafe-any */

    /* tslint:disable ban */
    return arr.findIndex(predicate, thisArg);
    /* tslint:enable ban */

    /* tslint:enable no-unsafe-any */
  }

  var len = arr.length >>> 0;

  for (var i = 0; i < len; i++) {
    if (predicate.call(thisArg, arr[i], i, arr)) {
      return i;
    }
  }

  return -1;
}

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return mergeMap; });
/* unused harmony export MergeMapOperator */
/* unused harmony export MergeMapSubscriber */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(29);
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(63);
/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */






function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return Object(_observable_from__WEBPACK_IMPORTED_MODULE_5__[/* from */ "a"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_4__[/* map */ "a"])(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
var MergeMapOperator = /*@__PURE__*/ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());

var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__[/* InnerSubscriber */ "a"](this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__[/* subscribeToResult */ "a"])(this, ish, value, index, innerSubscriber);
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__[/* OuterSubscriber */ "a"]));

//# sourceMappingURL=mergeMap.js.map


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return assert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assertInterface; });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(208);
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Throw an AssertionError if the given assertion is false.
 * @param {boolean} assertion
 * @param {string} [message] - Optional message property for the AssertionError.
 * @throws AssertionError - Throws if the assertion given is false
 */

function assert(assertion, message) {
  if (!assertion) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](message === undefined ? "invalid assertion" : message);
  }
}
/**
 * Throws if the given Object does not respect the interface.
 * @param {Object} o
 * @param {Object} iface - Contains the checked keynames of o and link them
 * to their types (obtained through the typeof operator).
 * @param {string} [name="object"] - name of the _interface_
 * @throws AssertionError - The argument o given is not an object
 * @throws AssertionError - The _interface_ is not respected.
 */

function assertInterface(o, iface, name) {
  if (name === void 0) {
    name = "object";
  }

  assert(!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(o), name + " should be an object");

  for (var k in iface) {
    if (iface.hasOwnProperty(k)) {
      /* tslint:disable:max-line-length */
      assert(typeof o[k] === iface[k], name + " should have property " + k + " as a " + iface[k]);
      /* tslint:enable:max-line-length */
    }
  }
}

/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isScheduler; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
//# sourceMappingURL=isScheduler.js.map


/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ __webpack_exports__["a"] = (_normalize__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);


/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "onPictureInPictureEvent$", function() { return /* binding */ onPictureInPictureEvent$; });
__webpack_require__.d(__webpack_exports__, "isActive", function() { return /* binding */ isActive; });
__webpack_require__.d(__webpack_exports__, "isVideoVisible", function() { return /* binding */ isVideoVisible; });
__webpack_require__.d(__webpack_exports__, "videoWidth$", function() { return /* binding */ videoWidth$; });
__webpack_require__.d(__webpack_exports__, "onPlayPause$", function() { return /* binding */ event_listeners_onPlayPause$; });
__webpack_require__.d(__webpack_exports__, "onTextTrackChanges$", function() { return /* binding */ event_listeners_onTextTrackChanges$; });
__webpack_require__.d(__webpack_exports__, "onLoadedMetadata$", function() { return /* binding */ onLoadedMetadata$; });
__webpack_require__.d(__webpack_exports__, "onSeeking$", function() { return /* binding */ onSeeking$; });
__webpack_require__.d(__webpack_exports__, "onSeeked$", function() { return /* binding */ onSeeked$; });
__webpack_require__.d(__webpack_exports__, "onEnded$", function() { return /* binding */ onEnded$; });
__webpack_require__.d(__webpack_exports__, "onTimeUpdate$", function() { return /* binding */ onTimeUpdate$; });
__webpack_require__.d(__webpack_exports__, "onFullscreenChange$", function() { return /* binding */ onFullscreenChange$; });
__webpack_require__.d(__webpack_exports__, "onSourceOpen$", function() { return /* binding */ onSourceOpen$; });
__webpack_require__.d(__webpack_exports__, "onUpdate$", function() { return /* binding */ onUpdate$; });
__webpack_require__.d(__webpack_exports__, "onRemoveSourceBuffers$", function() { return /* binding */ onRemoveSourceBuffers$; });
__webpack_require__.d(__webpack_exports__, "onEncrypted$", function() { return /* binding */ onEncrypted$; });
__webpack_require__.d(__webpack_exports__, "onKeyMessage$", function() { return /* binding */ onKeyMessage$; });
__webpack_require__.d(__webpack_exports__, "onKeyAdded$", function() { return /* binding */ onKeyAdded$; });
__webpack_require__.d(__webpack_exports__, "onKeyError$", function() { return /* binding */ onKeyError$; });
__webpack_require__.d(__webpack_exports__, "onKeyStatusesChange$", function() { return /* binding */ onKeyStatusesChange$; });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(206);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/noop.js
var noop = __webpack_require__(45);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/never.js
/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */


var NEVER = /*@__PURE__*/ new Observable["a" /* Observable */](noop["a" /* noop */]);
function never() {
    return NEVER;
}
//# sourceMappingURL=never.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(88);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(79);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(215);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
var interval = __webpack_require__(207);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
var startWith = __webpack_require__(175);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(149);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMap.js
var switchMap = __webpack_require__(136);

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/async.js
var scheduler_async = __webpack_require__(42);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isDate.js
var isDate = __webpack_require__(104);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Notification.js
var Notification = __webpack_require__(77);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/delay.js
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */





function delay_delay(delay, scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async["a" /* async */];
    }
    var absoluteDelay = Object(isDate["a" /* isDate */])(delay);
    var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
    return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
}
var DelayOperator = /*@__PURE__*/ (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new delay_DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var delay_DelaySubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification["a" /* Notification */].createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification["a" /* Notification */].createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(Subscriber["a" /* Subscriber */]));
var DelayMessage = /*@__PURE__*/ (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());
//# sourceMappingURL=delay.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(176);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/OuterSubscriber.js
var OuterSubscriber = __webpack_require__(29);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
var subscribeToResult = __webpack_require__(28);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/throttle.js
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



var defaultThrottleConfig = {
    leading: true,
    trailing: false
};
function throttle(durationSelector, config) {
    if (config === void 0) {
        config = defaultThrottleConfig;
    }
    return function (source) { return source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing)); };
}
var ThrottleOperator = /*@__PURE__*/ (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new throttle_ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var throttle_ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = null;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = Object(subscribeToResult["a" /* subscribeToResult */])(this, duration));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = null;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(OuterSubscriber["a" /* OuterSubscriber */]));
//# sourceMappingURL=throttle.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/throttleTime.js
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */




function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) {
        scheduler = scheduler_async["a" /* async */];
    }
    if (config === void 0) {
        config = defaultThrottleConfig;
    }
    return function (source) { return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing)); };
}
var ThrottleTimeOperator = /*@__PURE__*/ (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new throttleTime_ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var throttleTime_ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
            else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber["a" /* Subscriber */]));
function dispatchNext(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}
//# sourceMappingURL=throttleTime.js.map

// EXTERNAL MODULE: ./src/config.ts
var src_config = __webpack_require__(3);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
var browser_compatibility_types = __webpack_require__(26);

// EXTERNAL MODULE: ./src/compat/is_node.ts
var is_node = __webpack_require__(31);

// CONCATENATED MODULE: ./src/compat/event_listeners.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file provides browser-agnostic event listeners under the form of
 * RxJS Observables
 */







var BROWSER_PREFIXES = ["", "webkit", "moz", "ms"];
var INACTIVITY_DELAY = src_config["a" /* default */].INACTIVITY_DELAY;
var pixelRatio = is_node["a" /* default */] || window.devicePixelRatio == null || window.devicePixelRatio === 0 ? 1 : window.devicePixelRatio;
/**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {string} eventNameSuffix
 * @returns {Boolean}
 */

function isEventSupported(element, eventNameSuffix) {
  var clone = document.createElement(element.tagName);
  var eventName = "on" + eventNameSuffix;

  if (eventName in clone) {
    return true;
  } else {
    clone.setAttribute(eventName, "return;");
    return typeof clone[eventName] === "function";
  }
}
/**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {Array.<string>} eventNames
 * @returns {string|undefined}
 */


function findSupportedEvent(element, eventNames) {
  return eventNames.filter(function (name) {
    return isEventSupported(element, name);
  })[0];
}
/**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Array.<string>}
 */


function eventPrefixed(eventNames, prefixes) {
  return eventNames.reduce(function (parent, name) {
    return parent.concat((prefixes == null ? BROWSER_PREFIXES : prefixes).map(function (p) {
      return p + name;
    }));
  }, []);
}
/**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Observable}
 */


function compatibleListener(eventNames, prefixes) {
  var mem;
  var prefixedEvents = eventPrefixed(eventNames, prefixes);
  return function (element) {
    // if the element is a HTMLElement we can detect
    // the supported event, and memoize it in `mem`
    if (element instanceof browser_compatibility_types["a" /* HTMLElement_ */]) {
      if (typeof mem === "undefined") {
        mem = findSupportedEvent(element, prefixedEvents);
      }

      if (Object(is_non_empty_string["a" /* default */])(mem)) {
        return Object(fromEvent["a" /* fromEvent */])(element, mem);
      } else {
        if (false) {}

        return NEVER;
      }
    } // otherwise, we need to listen to all the events
    // and merge them into one observable sequence


    return merge["a" /* merge */].apply(void 0, prefixedEvents.map(function (eventName) {
      return Object(fromEvent["a" /* fromEvent */])(element, eventName);
    }));
  };
}
/**
 * Returns an observable:
 *   - emitting true when the document is visible
 *   - emitting false when the document is hidden
 * @returns {Observable}
 */


function visibilityChange() {
  var prefix;
  var doc = document;

  if (doc.hidden != null) {
    prefix = "";
  } else if (doc.mozHidden != null) {
    prefix = "moz";
  } else if (doc.msHidden != null) {
    prefix = "ms";
  } else if (doc.webkitHidden != null) {
    prefix = "webkit";
  }

  var hidden = Object(is_non_empty_string["a" /* default */])(prefix) ? prefix + "Hidden" : "hidden";
  var visibilityChangeEvent = Object(is_non_empty_string["a" /* default */])(prefix) ? prefix + "visibilitychange" : "visibilitychange";
  return Object(defer["a" /* defer */])(function () {
    var isHidden = document[hidden];
    return Object(fromEvent["a" /* fromEvent */])(document, visibilityChangeEvent).pipe(Object(map["a" /* map */])(function () {
      return !document[hidden];
    }), Object(startWith["a" /* startWith */])(!isHidden), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
  });
}
/**
 * @returns {Observable}
 */


function videoSizeChange() {
  return Object(fromEvent["a" /* fromEvent */])(window, "resize");
}
/**
 * Emit `true` if the page is considered active.
 * `false` when considered inactive.
 * Emit the original value on subscription.
 * @returns {Observable}
 */


function isActive() {
  return visibilityChange().pipe(Object(switchMap["a" /* switchMap */])(function (x) {
    if (!x) {
      return Object(of["a" /* of */])(x).pipe(delay_delay(INACTIVITY_DELAY));
    }

    return Object(of["a" /* of */])(x);
  }));
}
/**
 * Get video width from Picture-in-Picture window
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} pipWindow
 * @returns {number}
 */


function getVideoWidthFromPIPWindow(mediaElement, pipWindow) {
  var width = pipWindow.width,
      height = pipWindow.height;
  var videoRatio = mediaElement.clientHeight / mediaElement.clientWidth;
  var calcWidth = height / videoRatio;
  return Math.min(width, calcWidth);
}
/**
 * Emit when video enters and leaves Picture-In-Picture mode.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function onPictureInPictureEvent$(mediaElement) {
  return Object(defer["a" /* defer */])(function () {
    if (mediaElement.webkitSupportsPresentationMode && typeof mediaElement.webkitSetPresentationMode === "function") {
      var isWebKitPIPEnabled = mediaElement.webkitPresentationMode === "picture-in-picture";
      return Object(fromEvent["a" /* fromEvent */])(mediaElement, "webkitpresentationmodechanged").pipe(Object(map["a" /* map */])(function () {
        return {
          isEnabled: mediaElement.webkitPresentationMode === "picture-in-picture",
          pipWindow: null
        };
      }), Object(startWith["a" /* startWith */])({
        isEnabled: isWebKitPIPEnabled,
        pipWindow: null
      }));
    }

    var isPIPEnabled = document.pictureInPictureElement && document.pictureInPictureElement === mediaElement;
    var initialState = {
      isEnabled: isPIPEnabled,
      pipWindow: null
    };
    return Object(merge["a" /* merge */])(Object(fromEvent["a" /* fromEvent */])(mediaElement, "enterpictureinpicture").pipe(Object(map["a" /* map */])(function (evt) {
      return {
        isEnabled: true,

        /* tslint:disable no-unsafe-any */
        pipWindow: evt.pictureInPictureWindow
      };
    })),
    /* tslint:enable no-unsafe-any */
    Object(fromEvent["a" /* fromEvent */])(mediaElement, "leavepictureinpicture").pipe(Object(mapTo["a" /* mapTo */])({
      isEnabled: false,
      pipWindow: null
    }))).pipe(Object(startWith["a" /* startWith */])(initialState));
  });
}
/**
 * Returns `true` when video is considered as visible (the page is visible and/or
 * the Picture-In-Picture is activated). Returns `false` otherwise.
 * @param {Observable} pip$
 * @returns {Observable}
 */

function isVideoVisible(pip$) {
  return Object(combineLatest["a" /* combineLatest */])([visibilityChange(), pip$]).pipe(Object(switchMap["a" /* switchMap */])(function (_ref) {
    var isVisible = _ref[0],
        pip = _ref[1];

    if (pip.isEnabled || isVisible) {
      return Object(of["a" /* of */])(true);
    }

    return Object(of["a" /* of */])(false).pipe(delay_delay(INACTIVITY_DELAY));
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
}
/**
 * Get video width from HTML video element, or video estimated dimensions
 * when Picture-in-Picture is activated.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function videoWidth$(mediaElement, pip$) {
  return Object(combineLatest["a" /* combineLatest */])([pip$, Object(interval["a" /* interval */])(20000).pipe(Object(startWith["a" /* startWith */])(null)), videoSizeChange().pipe(throttleTime(500), Object(startWith["a" /* startWith */])(null))]).pipe(Object(switchMap["a" /* switchMap */])(function (_ref2) {
    var pip = _ref2[0];

    if (!pip.isEnabled) {
      return Object(of["a" /* of */])(mediaElement.clientWidth * pixelRatio);
    } else if (pip.pipWindow != null) {
      var pipWindow = pip.pipWindow;
      var firstWidth = getVideoWidthFromPIPWindow(mediaElement, pipWindow); // RxJS typing issue (for the "as any")

      return Object(fromEvent["a" /* fromEvent */])(pipWindow, "resize").pipe(Object(startWith["a" /* startWith */])(firstWidth * pixelRatio), Object(map["a" /* map */])(function () {
        return getVideoWidthFromPIPWindow(mediaElement, pipWindow) * pixelRatio;
      }));
    } else {
      return Object(of["a" /* of */])(Infinity);
    }
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
}
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


var onLoadedMetadata$ = compatibleListener(["loadedmetadata"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onSeeking$ = compatibleListener(["seeking"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onSeeked$ = compatibleListener(["seeked"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onEnded$ = compatibleListener(["ended"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onTimeUpdate$ = compatibleListener(["timeupdate"]);
/**
 * @param {HTMLElement} element
 * @returns {Observable}
 */

var onFullscreenChange$ = compatibleListener(["fullscreenchange", "FullscreenChange"], // On IE11, fullscreen change events is called MSFullscreenChange
BROWSER_PREFIXES.concat("MS"));
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var event_listeners_onPlayPause$ = function onPlayPause$(mediaElement) {
  return Object(merge["a" /* merge */])(compatibleListener(["play"])(mediaElement), compatibleListener(["pause"])(mediaElement));
};
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


var event_listeners_onTextTrackChanges$ = function onTextTrackChanges$(textTrackList) {
  return Object(merge["a" /* merge */])(compatibleListener(["addtrack"])(textTrackList), compatibleListener(["removetrack"])(textTrackList));
};
/**
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */


var onSourceOpen$ = compatibleListener(["sourceopen", "webkitsourceopen"]);
/**
 * @param {SourceBuffer} sourceBuffer
 * @returns {Observable}
 */

var onUpdate$ = compatibleListener(["update"]);
/**
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */

var onRemoveSourceBuffers$ = compatibleListener(["onremovesourcebuffer"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

var onEncrypted$ = compatibleListener(["encrypted", "needkey"]);
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */

var onKeyMessage$ = compatibleListener(["keymessage", "message"]);
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */

var onKeyAdded$ = compatibleListener(["keyadded", "ready"]);
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */

var onKeyError$ = compatibleListener(["keyerror", "error"]);
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */

var onKeyStatusesChange$ = compatibleListener(["keystatuseschange"]);


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MediaError; });
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Error linked to the media Playback.
 *
 * @class MediaError
 * @extends Error
 */

var MediaError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(MediaError, _Error);

  /**
   * @param {string} code
   * @param {string} reason
   * @param {Boolean} fatal
   */
  function MediaError(code, reason) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), MediaError.prototype);
    _this.name = "MediaError";
    _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__[/* ErrorTypes */ "b"].MEDIA_ERROR;
    _this.code = code;
    _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_this.name, _this.code, reason);
    _this.fatal = false;
    return _this;
  }

  return MediaError;
}( /*#__PURE__*/_wrapNativeSuper(Error));



/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isArray; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();
//# sourceMappingURL=isArray.js.map


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return observable; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();
//# sourceMappingURL=observable.js.map


/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return InnerSubscriber; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


var InnerSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));

//# sourceMappingURL=InnerSubscriber.js.map


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EMPTY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return empty; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

var EMPTY = /*@__PURE__*/ new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}
//# sourceMappingURL=empty.js.map


/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return idGenerator; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Creates an ID generator which generates an ID each time you call it.
 * @returns {Function}
 */
function idGenerator() {
  var prefix = "";
  var currId = -1;
  return function generateNewId() {
    currId++;

    if (currId >= Number.MAX_SAFE_INTEGER) {
      prefix += "0";
      currId = 0;
    }

    return prefix + String(currId);
  };
}

/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ObjectUnsubscribedError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
//# sourceMappingURL=ObjectUnsubscribedError.js.map


/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getBodyNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getStyleNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getRegionNodes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getTextNodes; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Element} tt
 * @returns {Element}
 */
function getBodyNode(tt) {
  return tt.getElementsByTagName("body")[0];
}
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */


function getStyleNodes(tt) {
  return tt.getElementsByTagName("style");
}
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */


function getRegionNodes(tt) {
  return tt.getElementsByTagName("region");
}
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */


function getTextNodes(tt) {
  return tt.getElementsByTagName("p");
}



/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isFunction; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
    return typeof x === 'function';
}
//# sourceMappingURL=isFunction.js.map


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return resolveURL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return normalizeBaseURL; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Scheme part of an url (e.g. "http://").
var schemeRe = /^(?:[a-z]+:)?\/\//i; // Captures "/../" or "/./".

var selfDirRe = /\/\.{1,2}\//;
/**
 * Resolve self directory and previous directory references to obtain a
 * "normalized" url.
 * @example "https://foo.bar/baz/booz/../biz" => "https://foo.bar/baz/biz"
 * @param {string} url
 * @returns {string}
 */

function _normalizeUrl(url) {
  // fast path if no ./ or ../ are present in the url
  if (!selfDirRe.test(url)) {
    return url;
  }

  var newUrl = [];
  var oldUrl = url.split("/");

  for (var i = 0, l = oldUrl.length; i < l; i++) {
    if (oldUrl[i] === "..") {
      newUrl.pop();
    } else if (oldUrl[i] === ".") {
      continue;
    } else {
      newUrl.push(oldUrl[i]);
    }
  }

  return newUrl.join("/");
}
/**
 * Construct an url from the arguments given.
 * Basically:
 *   - The last arguments that contains a scheme (e.g. "http://") is the base
 *     of the url.
 *   - every subsequent string arguments are concatened to it.
 * @param {...string|undefined} args
 * @returns {string}
 */


function resolveURL() {
  var len = arguments.length;

  if (len === 0) {
    return "";
  }

  var base = "";

  for (var i = 0; i < len; i++) {
    var part = i < 0 || arguments.length <= i ? undefined : arguments[i];

    if (typeof part !== "string" || part === "") {
      continue;
    }

    if (schemeRe.test(part)) {
      base = part;
    } else {
      // trim if begins with "/"
      if (part[0] === "/") {
        part = part.substring(1);
      } // trim if ends with "/"


      if (base[base.length - 1] === "/") {
        base = base.substring(0, base.length - 1);
      }

      base = base + "/" + part;
    }
  }

  return _normalizeUrl(base);
}
/**
 * Remove string after the last '/'.
 * @param {string} url
 * @returns {string}
 */

function normalizeBaseURL(url) {
  var indexOfLastSlash = url.lastIndexOf("/");

  if (indexOfLastSlash < 0) {
    return url;
  }

  if (schemeRe.test(url)) {
    var firstSlashIndex = url.indexOf("/");

    if (firstSlashIndex >= 0 && indexOfLastSlash === firstSlashIndex + 1) {
      // The "/" detected is actually the one from the protocol part of the URL
      // ("https://")
      return url;
    }
  }

  var indexOfQuestionMark = url.indexOf("?");

  if (indexOfQuestionMark >= 0 && indexOfQuestionMark < indexOfLastSlash) {
    // There are query parameters. Let's ignore them and re-run the logic
    // without
    return normalizeBaseURL(url.substring(0, indexOfQuestionMark));
  }

  return url.substring(0, indexOfLastSlash + 1);
}



/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getFirstLineAfterHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return isStartOfCueBlock; });
/* unused harmony export isStartOfNoteBlock */
/* unused harmony export isStartOfRegionBlock */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return isStartOfStyleBlock; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return findEndOfCueBlock; });
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns first line after the WEBVTT header.
 * That is, the line after the first blank line after the first line!
 * @param {Array.<string>} linified
 * @returns {Number}
 */

function getFirstLineAfterHeader(linified) {
  var i = 0;

  while (i < linified.length) {
    if (linified[i] === "") {
      return i + 1;
    }

    i++;
  }

  return i;
}
/**
 * Returns true if the given line looks like the beginning of a Style block.
 * @param {string} text
 * @returns {Boolean}
 */


function isStartOfStyleBlock(lines, index) {
  return typeof lines[index] === "string" && /^STYLE( .*)?$/g.test(lines[index]) && ( // A cue identifer can also contain "STYLE". Check that we have no timings
  // on the second line
  lines[index + 1] === undefined || lines[index + 1].indexOf("-->") < 0);
}
/**
 * Returns true if the given line looks like the beginning of a comment block.
 * @param {string} text
 * @returns {Boolean}
 */


function isStartOfNoteBlock(lines, index) {
  return typeof lines[index] === "string" && /^NOTE( .*)?$/g.test(lines[index]) && ( // A cue identifer can also contain "NOTE". Check that we have no timings
  // on the second line
  lines[index + 1] === undefined || lines[index + 1].indexOf("-->") < 0);
}
/**
 * Returns true if the given line looks like the beginning of a region block.
 * @param {string} text
 * @returns {Boolean}
 */


function isStartOfRegionBlock(lines, index) {
  return typeof lines[index] === "string" && /^REGION( .*)?$/g.test(lines[index]) && ( // A cue identifer can also contain "REGION". Check that we have no timings
  // on the second line
  lines[index + 1] === undefined || lines[index + 1].indexOf("-->") < 0);
}
/**
 * Returns true if the line given looks like the beginning of a cue.
 * You should provide to this function only lines following "empty" lines.
 * @param {Array.<string>} lines
 * @param {number} index
 * @returns {Boolean}
 */


function isStartOfCueBlock(lines, index) {
  // checked cases:
  //   - empty lines
  //   - start of a comment
  //   - start of a region
  //   - start of a style
  // Anything else whose first or second line is a timestamp line is a cue.
  var firstLine = lines[index];

  if (firstLine === undefined || firstLine === "" || isStartOfStyleBlock(lines, index) || isStartOfRegionBlock(lines, index) || isStartOfNoteBlock(lines, index)) {
    return false;
  }

  if (firstLine.indexOf("-->") >= 0) {
    return true;
  }

  var secondLine = lines[index + 1];
  return secondLine !== undefined && secondLine.indexOf("-->") >= 0;
}
/**
 * Find end of current WebVTT cue block.
 * @param {Array<string>} linified
 * @param {number} startOfCueBlock
 * @returns {number}
 */


function findEndOfCueBlock(linified, startOfCueBlock) {
  var firstEmptyLineIndex = startOfCueBlock + 1; // continue incrementing i until either:
  //   - empty line
  //   - end

  while (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(linified[firstEmptyLineIndex])) {
    firstEmptyLineIndex++;
  }

  return firstEmptyLineIndex;
}



/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ from; });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js + 3 modules
var subscribeTo = __webpack_require__(130);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
var symbol_observable = __webpack_require__(54);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */



function scheduleObservable(input, scheduler) {
    return new Observable["a" /* Observable */](function (subscriber) {
        var sub = new Subscription["a" /* Subscription */]();
        sub.add(scheduler.schedule(function () {
            var observable = input[symbol_observable["a" /* observable */]]();
            sub.add(observable.subscribe({
                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
            }));
        }));
        return sub;
    });
}
//# sourceMappingURL=scheduleObservable.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function schedulePromise(input, scheduler) {
    return new Observable["a" /* Observable */](function (subscriber) {
        var sub = new Subscription["a" /* Subscription */]();
        sub.add(scheduler.schedule(function () {
            return input.then(function (value) {
                sub.add(scheduler.schedule(function () {
                    subscriber.next(value);
                    sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                }));
            }, function (err) {
                sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
            });
        }));
        return sub;
    });
}
//# sourceMappingURL=schedulePromise.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js
var scheduleArray = __webpack_require__(80);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/iterator.js
var symbol_iterator = __webpack_require__(69);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */



function scheduleIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable["a" /* Observable */](function (subscriber) {
        var sub = new Subscription["a" /* Subscription */]();
        var iterator;
        sub.add(function () {
            if (iterator && typeof iterator.return === 'function') {
                iterator.return();
            }
        });
        sub.add(scheduler.schedule(function () {
            iterator = input[symbol_iterator["a" /* iterator */]]();
            sub.add(scheduler.schedule(function () {
                if (subscriber.closed) {
                    return;
                }
                var value;
                var done;
                try {
                    var result = iterator.next();
                    value = result.value;
                    done = result.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}
//# sourceMappingURL=scheduleIterable.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

function isInteropObservable(input) {
    return input && typeof input[symbol_observable["a" /* observable */]] === 'function';
}
//# sourceMappingURL=isInteropObservable.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isPromise.js
var isPromise = __webpack_require__(103);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArrayLike.js
var isArrayLike = __webpack_require__(101);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isIterable.js
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

function isIterable(input) {
    return input && typeof input[symbol_iterator["a" /* iterator */]] === 'function';
}
//# sourceMappingURL=isIterable.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduled.js
/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */








function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable(input)) {
            return scheduleObservable(input, scheduler);
        }
        else if (Object(isPromise["a" /* isPromise */])(input)) {
            return schedulePromise(input, scheduler);
        }
        else if (Object(isArrayLike["a" /* isArrayLike */])(input)) {
            return Object(scheduleArray["a" /* scheduleArray */])(input, scheduler);
        }
        else if (isIterable(input) || typeof input === 'string') {
            return scheduleIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
//# sourceMappingURL=scheduled.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js
/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */



function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable["a" /* Observable */]) {
            return input;
        }
        return new Observable["a" /* Observable */](Object(subscribeTo["a" /* subscribeTo */])(input));
    }
    else {
        return scheduled(input, scheduler);
    }
}
//# sourceMappingURL=from.js.map


/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return hostReportError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}
//# sourceMappingURL=hostReportError.js.map


/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return throwError; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function throwError(error, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}
//# sourceMappingURL=throwError.js.map


/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// UNUSED EXPORTS: areSameContent, Period, Adaptation, Representation, StaticRepresentationIndex, SUPPORTED_ADAPTATIONS_TYPE

// EXTERNAL MODULE: ./src/utils/are_arrays_of_numbers_equal.ts
var are_arrays_of_numbers_equal = __webpack_require__(81);

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(14);

// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(1);

// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(25);

// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(57);

// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(20);

// EXTERNAL MODULE: ./src/manifest/adaptation.ts + 2 modules
var manifest_adaptation = __webpack_require__(67);

// EXTERNAL MODULE: ./src/errors/is_known_error.ts
var is_known_error = __webpack_require__(173);

// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(52);

// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(82);

// CONCATENATED MODULE: ./src/manifest/period.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Class representing the tracks and qualities available from a given time
 * period in the the Manifest.
 * @class Period
 */

var period_Period = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Object} args
   * @param {function|undefined} [representationFilter]
   */
  function Period(args, representationFilter) {
    var _this = this;

    this.parsingErrors = [];
    this.id = args.id;
    this.adaptations = Object.keys(args.adaptations).reduce(function (acc, type) {
      var adaptationsForType = args.adaptations[type];

      if (adaptationsForType == null) {
        return acc;
      }

      var filteredAdaptations = adaptationsForType.map(function (adaptation) {
        var _this$parsingErrors;

        var newAdaptation = null;

        try {
          newAdaptation = new manifest_adaptation["b" /* default */](adaptation, {
            representationFilter: representationFilter
          });
        } catch (err) {
          if (Object(is_known_error["a" /* default */])(err) && err.code === "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE") {
            _this.parsingErrors.push(err);

            return null;
          }

          throw err;
        }

        (_this$parsingErrors = _this.parsingErrors).push.apply(_this$parsingErrors, newAdaptation.parsingErrors);

        return newAdaptation;
      }).filter(function (adaptation) {
        return adaptation != null && adaptation.representations.length > 0;
      });

      if (filteredAdaptations.length === 0 && adaptationsForType.length > 0 && (type === "video" || type === "audio")) {
        throw new media_error["a" /* default */]("MANIFEST_PARSE_ERROR", "No supported " + type + " adaptations");
      }

      if (filteredAdaptations.length > 0) {
        acc[type] = filteredAdaptations;
      }

      return acc;
    }, {});

    if (!Array.isArray(this.adaptations.video) && !Array.isArray(this.adaptations.audio)) {
      throw new media_error["a" /* default */]("MANIFEST_PARSE_ERROR", "No supported audio and video tracks.");
    }

    this.duration = args.duration;
    this.start = args.start;

    if (this.duration != null && this.start != null) {
      this.end = this.start + this.duration;
    }
  }
  /**
   * Returns every `Adaptations` (or `tracks`) linked to that Period, in an
   * Array.
   * @returns {Array.<Object>}
   */


  var _proto = Period.prototype;

  _proto.getAdaptations = function getAdaptations() {
    var adaptationsByType = this.adaptations;
    return Object(object_values["a" /* default */])(adaptationsByType).reduce(function (acc, adaptations) {
      return (// Note: the second case cannot happen. TS is just being dumb here
        adaptations != null ? acc.concat(adaptations) : acc
      );
    }, []);
  }
  /**
   * Returns every `Adaptations` (or `tracks`) linked to that Period for a
   * given type.
   * @param {string} adaptationType
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
    var adaptationsForType = this.adaptations[adaptationType];
    return adaptationsForType == null ? [] : adaptationsForType;
  }
  /**
   * Returns the Adaptation linked to the given ID.
   * @param {number|string} wantedId
   * @returns {Object|undefined}
   */
  ;

  _proto.getAdaptation = function getAdaptation(wantedId) {
    return Object(array_find["a" /* default */])(this.getAdaptations(), function (_ref) {
      var id = _ref.id;
      return wantedId === id;
    });
  };

  return Period;
}();


// EXTERNAL MODULE: ./src/manifest/representation_index/static.ts
var representation_index_static = __webpack_require__(220);

// CONCATENATED MODULE: ./src/manifest/types.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Enumerate the different ways a Manifest update can be done. */
var MANIFEST_UPDATE_TYPE;

(function (MANIFEST_UPDATE_TYPE) {
  /** The full version of the Manifest has been re-downloaded. */
  MANIFEST_UPDATE_TYPE[MANIFEST_UPDATE_TYPE["Full"] = 0] = "Full";
  /** Only a shortened version of the Manifest has been downloaded. */

  MANIFEST_UPDATE_TYPE[MANIFEST_UPDATE_TYPE["Partial"] = 1] = "Partial";
})(MANIFEST_UPDATE_TYPE || (MANIFEST_UPDATE_TYPE = {}));
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/utils/array_find_index.ts
var array_find_index = __webpack_require__(46);

// CONCATENATED MODULE: ./src/manifest/update_period_in_place.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Update oldPeriod attributes with the one from newPeriod (e.g. when updating
 * the Manifest).
 * @param {Object} oldPeriod
 * @param {Object} newPeriod
 */

function updatePeriodInPlace(oldPeriod, newPeriod, updateType) {
  oldPeriod.start = newPeriod.start;
  oldPeriod.end = newPeriod.end;
  oldPeriod.duration = newPeriod.duration;
  var oldAdaptations = oldPeriod.getAdaptations();
  var newAdaptations = newPeriod.getAdaptations();

  var _loop = function _loop(j) {
    var oldAdaptation = oldAdaptations[j];
    var newAdaptation = Object(array_find["a" /* default */])(newAdaptations, function (a) {
      return a.id === oldAdaptation.id;
    });

    if (newAdaptation === undefined) {
      log["a" /* default */].warn("Manifest: Adaptation \"" + oldAdaptations[j].id + "\" not found when merging.");
    } else {
      var oldRepresentations = oldAdaptations[j].representations;
      var newRepresentations = newAdaptation.representations;

      var _loop2 = function _loop2(k) {
        var oldRepresentation = oldRepresentations[k];
        var newRepresentation = Object(array_find["a" /* default */])(newRepresentations, function (representation) {
          return representation.id === oldRepresentation.id;
        });

        if (newRepresentation === undefined) {
          log["a" /* default */].warn("Manifest: Representation \"" + oldRepresentations[k].id + "\" " + "not found when merging.");
        } else {
          if (updateType === MANIFEST_UPDATE_TYPE.Full) {
            oldRepresentation.index._replace(newRepresentation.index);
          } else {
            oldRepresentation.index._update(newRepresentation.index);
          }
        }
      };

      for (var k = 0; k < oldRepresentations.length; k++) {
        _loop2(k);
      }
    }
  };

  for (var j = 0; j < oldAdaptations.length; j++) {
    _loop(j);
  }
}
// CONCATENATED MODULE: ./src/manifest/update_periods.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Update old periods by adding new periods and removing
 * not available ones.
 * @param {Array.<Object>} oldPeriods
 * @param {Array.<Object>} newPeriods
 */

function replacePeriods(oldPeriods, newPeriods) {
  var firstUnhandledPeriodIdx = 0;

  for (var i = 0; i < newPeriods.length; i++) {
    var newPeriod = newPeriods[i];
    var j = firstUnhandledPeriodIdx;
    var oldPeriod = oldPeriods[j];

    while (oldPeriod != null && oldPeriod.id !== newPeriod.id) {
      j++;
      oldPeriod = oldPeriods[j];
    }

    if (oldPeriod != null) {
      updatePeriodInPlace(oldPeriod, newPeriod, MANIFEST_UPDATE_TYPE.Full);
      var periodsToInclude = newPeriods.slice(firstUnhandledPeriodIdx, i);
      var nbrOfPeriodsToRemove = j - firstUnhandledPeriodIdx;
      oldPeriods.splice.apply(oldPeriods, [firstUnhandledPeriodIdx, nbrOfPeriodsToRemove].concat(periodsToInclude));
      firstUnhandledPeriodIdx = i + 1;
    }
  }

  if (firstUnhandledPeriodIdx > oldPeriods.length) {
    log["a" /* default */].error("Manifest: error when updating Periods");
    return;
  }

  if (firstUnhandledPeriodIdx < oldPeriods.length) {
    oldPeriods.splice(firstUnhandledPeriodIdx, oldPeriods.length - firstUnhandledPeriodIdx);
  }

  var remainingNewPeriods = newPeriods.slice(firstUnhandledPeriodIdx, newPeriods.length);

  if (remainingNewPeriods.length > 0) {
    oldPeriods.push.apply(oldPeriods, remainingNewPeriods);
  }
}
/**
 * Update old periods by adding new periods and removing
 * not available ones.
 * @param {Array.<Object>} oldPeriods
 * @param {Array.<Object>} newPeriods
 */

function updatePeriods(oldPeriods, newPeriods) {
  if (oldPeriods.length === 0) {
    oldPeriods.splice.apply(oldPeriods, [0, oldPeriods.length].concat(newPeriods));
    return;
  }

  if (newPeriods.length === 0) {
    return;
  }

  var oldLastPeriod = oldPeriods[oldPeriods.length - 1];

  if (oldLastPeriod.start < newPeriods[0].start) {
    if (oldLastPeriod.end !== newPeriods[0].start) {
      throw new media_error["a" /* default */]("MANIFEST_UPDATE_ERROR", "Cannot perform partial update: not enough data");
    }

    oldPeriods.push.apply(oldPeriods, newPeriods);
    return;
  }

  var indexOfNewFirstPeriod = Object(array_find_index["a" /* default */])(oldPeriods, function (_ref) {
    var id = _ref.id;
    return id === newPeriods[0].id;
  });

  if (indexOfNewFirstPeriod < 0) {
    throw new media_error["a" /* default */]("MANIFEST_UPDATE_ERROR", "Cannot perform partial update: incoherent data");
  } // The first updated Period can only be a partial part


  updatePeriodInPlace(oldPeriods[indexOfNewFirstPeriod], newPeriods[0], MANIFEST_UPDATE_TYPE.Partial);
  var prevIndexOfNewPeriod = indexOfNewFirstPeriod + 1;

  for (var i = 1; i < newPeriods.length; i++) {
    var newPeriod = newPeriods[i];
    var indexOfNewPeriod = -1;

    for (var j = prevIndexOfNewPeriod; j < oldPeriods.length; j++) {
      if (newPeriod.id === oldPeriods[j].id) {
        indexOfNewPeriod = j;
        break; // end the loop
      }
    }

    if (indexOfNewPeriod < 0) {
      oldPeriods.splice.apply(oldPeriods, [prevIndexOfNewPeriod, oldPeriods.length - prevIndexOfNewPeriod].concat(newPeriods.slice(i, newPeriods.length)));
      return;
    }

    if (indexOfNewPeriod > prevIndexOfNewPeriod) {
      oldPeriods.splice(prevIndexOfNewPeriod, indexOfNewPeriod - prevIndexOfNewPeriod);
      indexOfNewPeriod = prevIndexOfNewPeriod;
    } // Later Periods can be fully replaced


    updatePeriodInPlace(oldPeriods[indexOfNewPeriod], newPeriod, MANIFEST_UPDATE_TYPE.Full);
    prevIndexOfNewPeriod++;
  }

  if (prevIndexOfNewPeriod < oldPeriods.length) {
    oldPeriods.splice(prevIndexOfNewPeriod, oldPeriods.length - prevIndexOfNewPeriod);
  }
}
// CONCATENATED MODULE: ./src/manifest/manifest.ts
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











var generateSupplementaryTrackID = Object(id_generator["a" /* default */])();
var generateNewManifestId = Object(id_generator["a" /* default */])();
/**
 * Normalized Manifest structure.
 *
 * Details the current content being played:
 *   - the duration of the content
 *   - the available tracks
 *   - the available qualities
 *   - the segments defined in those qualities
 *   - ...
 * while staying agnostic of the transport protocol used (Smooth, DASH etc.).
 *
 * The Manifest and its contained information can evolve over time (like when
 * updating a dynamic manifest or when right management forbid some tracks from
 * being played).
 * To perform actions on those changes, any module using this Manifest can
 * listen to its sent events and react accordingly.
 *
 * @class Manifest
 */

var manifest_Manifest = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(Manifest, _EventEmitter);

  /**
   * Construct a Manifest instance from a parsed Manifest object (as returned by
   * Manifest parsers) and options.
   *
   * Some minor errors can arise during that construction. `this.parsingErrors`
   * will contain all such errors, in the order they have been encountered.
   * @param {Object} parsedManifest
   * @param {Object} options
   */
  function Manifest(parsedManifest, options) {
    var _this;

    var _a;

    _this = _EventEmitter.call(this) || this;
    var _options$supplementar = options.supplementaryTextTracks,
        supplementaryTextTracks = _options$supplementar === void 0 ? [] : _options$supplementar,
        _options$supplementar2 = options.supplementaryImageTracks,
        supplementaryImageTracks = _options$supplementar2 === void 0 ? [] : _options$supplementar2,
        representationFilter = options.representationFilter;
    _this.parsingErrors = [];
    _this.id = generateNewManifestId();
    _this.expired = (_a = parsedManifest.expired) !== null && _a !== void 0 ? _a : null;
    _this.transport = parsedManifest.transportType;
    _this.clockOffset = parsedManifest.clockOffset;
    _this.periods = parsedManifest.periods.map(function (parsedPeriod) {
      var _this$parsingErrors;

      var period = new period_Period(parsedPeriod, representationFilter);

      (_this$parsingErrors = _this.parsingErrors).push.apply(_this$parsingErrors, period.parsingErrors);

      return period;
    }).sort(function (a, b) {
      return a.start - b.start;
    });
    /**
     * @deprecated It is here to ensure compatibility with the way the
     * v3.x.x manages adaptations at the Manifest level
     */

    /* tslint:disable:deprecation */

    _this.adaptations = _this.periods[0] === undefined ? {} : _this.periods[0].adaptations;
    /* tslint:enable:deprecation */

    _this.minimumTime = parsedManifest.minimumTime;
    _this.isDynamic = parsedManifest.isDynamic;
    _this.isLive = parsedManifest.isLive;
    _this.uris = parsedManifest.uris === undefined ? [] : parsedManifest.uris;
    _this.lifetime = parsedManifest.lifetime;
    _this.suggestedPresentationDelay = parsedManifest.suggestedPresentationDelay;
    _this.availabilityStartTime = parsedManifest.availabilityStartTime;
    _this.maximumTime = parsedManifest.maximumTime;

    if (supplementaryImageTracks.length > 0) {
      _this.addSupplementaryImageAdaptations(supplementaryImageTracks);
    }

    if (supplementaryTextTracks.length > 0) {
      _this.addSupplementaryTextAdaptations(supplementaryTextTracks);
    }

    return _this;
  }
  /**
   * Returns the Period corresponding to the given `id`.
   * Returns `undefined` if there is none.
   * @param {string} id
   * @returns {Object|undefined}
   */


  var _proto = Manifest.prototype;

  _proto.getPeriod = function getPeriod(id) {
    return Object(array_find["a" /* default */])(this.periods, function (period) {
      return id === period.id;
    });
  }
  /**
   * Returns the Period encountered at the given time.
   * Returns `undefined` if there is no Period exactly at the given time.
   * @param {number} time
   * @returns {Object|undefined}
   */
  ;

  _proto.getPeriodForTime = function getPeriodForTime(time) {
    return Object(array_find["a" /* default */])(this.periods, function (period) {
      return time >= period.start && (period.end === undefined || period.end > time);
    });
  }
  /**
   * Returns the Period coming chronologically just after another given Period.
   * Returns `undefined` if not found.
   * @param {Object} period
   * @returns {Object|null}
   */
  ;

  _proto.getPeriodAfter = function getPeriodAfter(period) {
    var endOfPeriod = period.end;

    if (endOfPeriod === undefined) {
      return null;
    }

    var nextPeriod = Object(array_find["a" /* default */])(this.periods, function (_period) {
      return _period.end === undefined || endOfPeriod < _period.end;
    });
    return nextPeriod === undefined ? null : nextPeriod;
  }
  /**
   * Returns the most important URL from which the Manifest can be refreshed.
   * `undefined` if no URL is found.
   * @returns {string|undefined}
   */
  ;

  _proto.getUrl = function getUrl() {
    return this.uris[0];
  }
  /**
   * Update the current Manifest properties by giving a new updated version.
   * This instance will be updated with the new information coming from it.
   * @param {Object} newManifest
   */
  ;

  _proto.replace = function replace(newManifest) {
    this._performUpdate(newManifest, MANIFEST_UPDATE_TYPE.Full);
  }
  /**
   * Update the current Manifest properties by giving a new but shorter version
   * of it.
   * This instance will add the new information coming from it and will
   * automatically clean old Periods that shouldn't be available anymore.
   *
   * /!\ Throws if the given Manifest cannot be used or is not sufficient to
   * update the Manifest.
   * @param {Object} newManifest
   */
  ;

  _proto.update = function update(newManifest) {
    this._performUpdate(newManifest, MANIFEST_UPDATE_TYPE.Partial);
  }
  /**
   * Get the minimum position currently defined by the Manifest, in seconds.
   * @returns {number}
   */
  ;

  _proto.getMinimumPosition = function getMinimumPosition() {
    var minimumTime = this.minimumTime;

    if (minimumTime === undefined) {
      return 0;
    }

    if (!minimumTime.isContinuous) {
      return minimumTime.value;
    }

    var timeDiff = performance.now() - minimumTime.time;
    return minimumTime.value + timeDiff / 1000;
  }
  /**
   * Get the maximum position currently defined by the Manifest, in seconds.
   * @returns {number}
   */
  ;

  _proto.getMaximumPosition = function getMaximumPosition() {
    var maximumTime = this.maximumTime;

    if (maximumTime === undefined) {
      if (this.isLive) {
        var ast = this.availabilityStartTime !== undefined ? this.availabilityStartTime : 0;

        if (this.clockOffset === undefined) {
          // server's time not known, rely on user's clock
          return Date.now() / 1000 - ast;
        }

        var serverTime = performance.now() + this.clockOffset;
        return serverTime / 1000 - ast;
      }

      return Infinity;
    }

    if (!maximumTime.isContinuous) {
      return maximumTime.value;
    }

    var timeDiff = performance.now() - maximumTime.time;
    return maximumTime.value + timeDiff / 1000;
  }
  /**
   * Look in the Manifest for Representations linked to the given key ID,
   * and mark them as being impossible to decrypt.
   * Then trigger a "blacklist-update" event to notify everyone of the changes
   * performed.
   * @param {Array.<ArrayBuffer>} keyIDs
   */
  ;

  _proto.addUndecipherableKIDs = function addUndecipherableKIDs(keyIDs) {
    var updates = updateDeciperability(this, function (representation) {
      if (representation.decipherable === false || representation.contentProtections === undefined) {
        return true;
      }

      var contentKIDs = representation.contentProtections.keyIds;

      for (var i = 0; i < contentKIDs.length; i++) {
        var elt = contentKIDs[i];

        for (var j = 0; j < keyIDs.length; j++) {
          if (Object(byte_parsing["k" /* isABEqualBytes */])(keyIDs[j], elt.keyId)) {
            return false;
          }
        }
      }

      return true;
    });

    if (updates.length > 0) {
      this.trigger("decipherabilityUpdate", updates);
    }
  }
  /**
   * Look in the Manifest for Representations linked to the given content
   * protection initialization data and mark them as being impossible to
   * decrypt.
   * Then trigger a "blacklist-update" event to notify everyone of the changes
   * performed.
   * @param {Array.<ArrayBuffer>} keyIDs
   */
  ;

  _proto.addUndecipherableProtectionData = function addUndecipherableProtectionData(initDataType, initData) {
    var updates = updateDeciperability(this, function (representation) {
      if (representation.decipherable === false) {
        return true;
      }

      var segmentProtections = representation.getProtectionsInitializationData();

      for (var i = 0; i < segmentProtections.length; i++) {
        if (segmentProtections[i].type === initDataType) {
          if (Object(are_arrays_of_numbers_equal["a" /* default */])(initData, segmentProtections[i].data)) {
            return false;
          }
        }
      }

      return true;
    });

    if (updates.length > 0) {
      this.trigger("decipherabilityUpdate", updates);
    }
  }
  /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAdaptations = function getAdaptations() {
    Object(warn_once["a" /* default */])("manifest.getAdaptations() is deprecated." + " Please use manifest.period[].getAdaptations() instead");
    var firstPeriod = this.periods[0];

    if (firstPeriod === undefined) {
      return [];
    }

    var adaptationsByType = firstPeriod.adaptations;
    var adaptationsList = [];

    for (var adaptationType in adaptationsByType) {
      if (adaptationsByType.hasOwnProperty(adaptationType)) {
        var adaptations = adaptationsByType[adaptationType];
        adaptationsList.push.apply(adaptationsList, adaptations);
      }
    }

    return adaptationsList;
  }
  /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAdaptationsForType = function getAdaptationsForType(adaptationType) {
    Object(warn_once["a" /* default */])("manifest.getAdaptationsForType(type) is deprecated." + " Please use manifest.period[].getAdaptationsForType(type) instead");
    var firstPeriod = this.periods[0];

    if (firstPeriod === undefined) {
      return [];
    }

    var adaptationsForType = firstPeriod.adaptations[adaptationType];
    return adaptationsForType === undefined ? [] : adaptationsForType;
  }
  /**
   * @deprecated only returns adaptations for the first period
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAdaptation = function getAdaptation(wantedId) {
    Object(warn_once["a" /* default */])("manifest.getAdaptation(id) is deprecated." + " Please use manifest.period[].getAdaptation(id) instead");
    /* tslint:disable:deprecation */

    return Object(array_find["a" /* default */])(this.getAdaptations(), function (_ref) {
      var id = _ref.id;
      return wantedId === id;
    });
    /* tslint:enable:deprecation */
  }
  /**
   * Add supplementary image Adaptation(s) to the manifest.
   * @private
   * @param {Object|Array.<Object>} imageTracks
   */
  ;

  _proto.addSupplementaryImageAdaptations = function addSupplementaryImageAdaptations(
  /* tslint:disable deprecation */
  imageTracks
  /* tslint:enable deprecated */
  ) {
    var _this2 = this;

    var _imageTracks = Array.isArray(imageTracks) ? imageTracks : [imageTracks];

    var newImageTracks = _imageTracks.map(function (_ref2) {
      var _this2$parsingErrors;

      var mimeType = _ref2.mimeType,
          url = _ref2.url;
      var adaptationID = "gen-image-ada-" + generateSupplementaryTrackID();
      var representationID = "gen-image-rep-" + generateSupplementaryTrackID();
      var newAdaptation = new manifest_adaptation["b" /* default */]({
        id: adaptationID,
        type: "image",
        representations: [{
          bitrate: 0,
          id: representationID,
          mimeType: mimeType,
          index: new representation_index_static["a" /* default */]({
            media: url
          })
        }]
      }, {
        isManuallyAdded: true
      });

      (_this2$parsingErrors = _this2.parsingErrors).push.apply(_this2$parsingErrors, newAdaptation.parsingErrors);

      return newAdaptation;
    });

    if (newImageTracks.length > 0 && this.periods.length > 0) {
      var adaptations = this.periods[0].adaptations;
      adaptations.image = adaptations.image != null ? adaptations.image.concat(newImageTracks) : newImageTracks;
    }
  }
  /**
   * Add supplementary text Adaptation(s) to the manifest.
   * @private
   * @param {Object|Array.<Object>} textTracks
   */
  ;

  _proto.addSupplementaryTextAdaptations = function addSupplementaryTextAdaptations(
  /* tslint:disable deprecation */
  textTracks
  /* tslint:enable deprecation */
  ) {
    var _this3 = this;

    var _textTracks = Array.isArray(textTracks) ? textTracks : [textTracks];

    var newTextAdaptations = _textTracks.reduce(function (allSubs, _ref3) {
      var mimeType = _ref3.mimeType,
          codecs = _ref3.codecs,
          url = _ref3.url,
          language = _ref3.language,
          languages = _ref3.languages,
          closedCaption = _ref3.closedCaption;
      var langsToMapOn = language != null ? [language] : languages != null ? languages : [];
      return allSubs.concat(langsToMapOn.map(function (_language) {
        var _this3$parsingErrors;

        var adaptationID = "gen-text-ada-" + generateSupplementaryTrackID();
        var representationID = "gen-text-rep-" + generateSupplementaryTrackID();
        var newAdaptation = new manifest_adaptation["b" /* default */]({
          id: adaptationID,
          type: "text",
          language: _language,
          closedCaption: closedCaption,
          representations: [{
            bitrate: 0,
            id: representationID,
            mimeType: mimeType,
            codecs: codecs,
            index: new representation_index_static["a" /* default */]({
              media: url
            })
          }]
        }, {
          isManuallyAdded: true
        });

        (_this3$parsingErrors = _this3.parsingErrors).push.apply(_this3$parsingErrors, newAdaptation.parsingErrors);

        return newAdaptation;
      }));
    }, []);

    if (newTextAdaptations.length > 0 && this.periods.length > 0) {
      var adaptations = this.periods[0].adaptations;
      adaptations.text = adaptations.text != null ? adaptations.text.concat(newTextAdaptations) : newTextAdaptations;
    }
  }
  /**
   * @param {Object} newManifest
   * @param {number} type
   */
  ;

  _proto._performUpdate = function _performUpdate(newManifest, updateType) {
    this.availabilityStartTime = newManifest.availabilityStartTime;
    this.isDynamic = newManifest.isDynamic;
    this.isLive = newManifest.isLive;
    this.lifetime = newManifest.lifetime;
    this.maximumTime = newManifest.maximumTime;

    if (updateType === MANIFEST_UPDATE_TYPE.Full) {
      this.minimumTime = newManifest.minimumTime;
    }

    this.parsingErrors = newManifest.parsingErrors;
    this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay;
    this.transport = newManifest.transport;
    this.uris = newManifest.uris;

    if (updateType === MANIFEST_UPDATE_TYPE.Full) {
      replacePeriods(this.periods, newManifest.periods);
    } else {
      updatePeriods(this.periods, newManifest.periods);
    } // Re-set this.adaptations for retro-compatibility in v3.x.x

    /* tslint:disable:deprecation */


    this.adaptations = this.periods[0] === undefined ? {} : this.periods[0].adaptations;
    /* tslint:enable:deprecation */

    if (updateType === MANIFEST_UPDATE_TYPE.Partial) {
      // Partial updates do not remove old Periods.
      // This can become a memory problem when playing a content long enough.
      // Let's clean manually Periods behind the minimum possible position.
      var min = this.getMinimumPosition();

      while (this.periods.length > 0) {
        var period = this.periods[0];

        if (period.end === undefined || period.end > min) {
          break;
        }

        this.periods.splice(0);
      }
    } // Let's trigger events at the end, as those can trigger side-effects.
    // We do not want the current Manifest object to be incomplete when those
    // happen.


    this.trigger("manifestUpdate", null);
  };

  return Manifest;
}(event_emitter["a" /* default */]);
/**
 * Update decipherability based on a predicate given.
 * Do nothing for a Representation when the predicate returns false, mark as
 * undecipherable when the predicate returns false. Returns every updates in
 * an array.
 * @param {Manifest} manifest
 * @param {Function} predicate
 * @returns {Array.<Object>}
 */




function updateDeciperability(manifest, predicate) {
  var updates = [];

  for (var i = 0; i < manifest.periods.length; i++) {
    var period = manifest.periods[i];
    var adaptations = period.getAdaptations();

    for (var j = 0; j < adaptations.length; j++) {
      var adaptation = adaptations[j];
      var representations = adaptation.representations;

      for (var k = 0; k < representations.length; k++) {
        var representation = representations[k];

        if (!predicate(representation)) {
          updates.push({
            manifest: manifest,
            period: period,
            adaptation: adaptation,
            representation: representation
          });
          representation.decipherable = false;
        }
      }
    }
  }

  return updates;
}
// CONCATENATED MODULE: ./src/manifest/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/* harmony default export */ var manifest = __webpack_exports__["a"] = (manifest_Manifest);


/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ SUPPORTED_ADAPTATIONS_TYPE; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ adaptation_Adaptation; });

// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(52);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(14);

// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(10);

// EXTERNAL MODULE: ./src/utils/languages/index.ts
var languages = __webpack_require__(50);

// CONCATENATED MODULE: ./src/utils/uniq.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Uniq implementation by combining a filter and an indexOf.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
function uniqFromFilter(arr) {
  return arr.filter(function (val, i, self) {
    return self.indexOf(val) === i;
  });
}
/**
 * Uniq implementation by using the Set browser API.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */


function uniqFromSet(arr) {
  return Array.from(new Set(arr));
}
/**
 * Returns the input array without duplicates values.
 * All values are unique.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */


/* harmony default export */ var uniq = (typeof window !== "undefined" && typeof window.Set === "function" ? uniqFromSet : uniqFromFilter);

// EXTERNAL MODULE: ./src/compat/is_codec_supported.ts
var is_codec_supported = __webpack_require__(157);

// CONCATENATED MODULE: ./src/manifest/filter_supported_representations.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Only keep Representations for which the codec is currently supported.
 * @param {string} adaptationType
 * @param {Array.<Object>} representations
 * @returns {Array.<Object>}
 */

function filterSupportedRepresentations(adaptationType, representations) {
  if (adaptationType === "audio" || adaptationType === "video") {
    return representations.filter(function (representation) {
      return Object(is_codec_supported["a" /* default */])(getCodec(representation));
    });
  }

  return representations; // TODO for the other types?
}
/**
 * Construct the codec string from given codecs and mimetype.
 * @param {Object} representation
 * @returns {string}
 */

function getCodec(representation) {
  var _representation$codec = representation.codecs,
      codecs = _representation$codec === void 0 ? "" : _representation$codec,
      _representation$mimeT = representation.mimeType,
      mimeType = _representation$mimeT === void 0 ? "" : _representation$mimeT;
  return mimeType + ";codecs=\"" + codecs + "\"";
}
// EXTERNAL MODULE: ./src/manifest/representation.ts
var manifest_representation = __webpack_require__(96);

// CONCATENATED MODULE: ./src/manifest/adaptation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/** List in an array every possible value for the Adaptation's `type` property. */

var SUPPORTED_ADAPTATIONS_TYPE = ["audio", "video", "text", "image"];
/**
 * Returns true if the given Adaptation's `type` is a valid `type` property.
 * @param {string} adaptationType
 * @returns {boolean}
 */

function isSupportedAdaptationType(adaptationType) {
  return Object(array_includes["a" /* default */])(SUPPORTED_ADAPTATIONS_TYPE, adaptationType);
}
/**
 * Normalized Adaptation structure.
 * An Adaptation describes a single `Track`. For example a specific audio
 * track (in a given language) or a specific video track.
 * It istelf can be represented in different qualities, which we call here
 * `Representation`.
 * @class Adaptation
 */


var adaptation_Adaptation = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {Object} parsedAdaptation
   * @param {Object|undefined} [options]
   */
  function Adaptation(parsedAdaptation, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    var _options = options,
        representationFilter = _options.representationFilter,
        isManuallyAdded = _options.isManuallyAdded;
    this.parsingErrors = [];
    this.id = parsedAdaptation.id;

    if (!isSupportedAdaptationType(parsedAdaptation.type)) {
      log["a" /* default */].info("Manifest: Not supported adaptation type", parsedAdaptation.type);
      throw new media_error["a" /* default */]("MANIFEST_UNSUPPORTED_ADAPTATION_TYPE", "\"" + parsedAdaptation.type + "\" is not a valid " + "Adaptation type.");
    }

    this.type = parsedAdaptation.type;
    var hadRepresentations = parsedAdaptation.representations.length !== 0;
    var argsRepresentations = filterSupportedRepresentations(parsedAdaptation.type, parsedAdaptation.representations);

    if (hadRepresentations && argsRepresentations.length === 0) {
      log["a" /* default */].warn("Incompatible codecs for adaptation", parsedAdaptation);
      var error = new media_error["a" /* default */]("MANIFEST_INCOMPATIBLE_CODECS_ERROR", "An Adaptation contains only incompatible codecs.");
      this.parsingErrors.push(error);
    }

    if (parsedAdaptation.language !== undefined) {
      this.language = parsedAdaptation.language;
      this.normalizedLanguage = Object(languages["a" /* default */])(parsedAdaptation.language);
    }

    if (parsedAdaptation.closedCaption !== undefined) {
      this.isClosedCaption = parsedAdaptation.closedCaption;
    }

    if (parsedAdaptation.audioDescription !== undefined) {
      this.isAudioDescription = parsedAdaptation.audioDescription;
    }

    if (parsedAdaptation.isDub !== undefined) {
      this.isDub = parsedAdaptation.isDub;
    }

    this.representations = argsRepresentations.map(function (representation) {
      return new manifest_representation["a" /* default */](representation);
    }).sort(function (a, b) {
      return a.bitrate - b.bitrate;
    }).filter(function (representation) {
      if (representationFilter == null) {
        return true;
      }

      return representationFilter(representation, {
        bufferType: _this.type,
        language: _this.language,
        normalizedLanguage: _this.normalizedLanguage,
        isClosedCaption: _this.isClosedCaption,
        isDub: _this.isDub,
        isAudioDescription: _this.isAudioDescription
      });
    }); // for manuallyAdded adaptations (not in the manifest)

    this.manuallyAdded = isManuallyAdded === true;
  }
  /**
   * Returns unique bitrate for every Representation in this Adaptation.
   * @returns {Array.<Number>}
   */


  var _proto = Adaptation.prototype;

  _proto.getAvailableBitrates = function getAvailableBitrates() {
    var bitrates = [];

    for (var i = 0; i < this.representations.length; i++) {
      var representation = this.representations[i];

      if (representation.decipherable !== false) {
        bitrates.push(representation.bitrate);
      }
    }

    return uniq(bitrates);
  }
  /**
   * Returns the Representation linked to the given ID.
   * @param {number|string} wantedId
   * @returns {Object|undefined}
   */
  ;

  _proto.getRepresentation = function getRepresentation(wantedId) {
    return Object(array_find["a" /* default */])(this.representations, function (_ref) {
      var id = _ref.id;
      return wantedId === id;
    });
  };

  return Adaptation;
}();



/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return errorMessage; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generate a normalized error message.
 * @param {string} name
 * @param {string} code
 * @param {Error|string|Event|null} [reason]
 * @returns {string}
 */
function errorMessage(name, code, reason) {
  return name + " (" + code + ") " + reason;
}

/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export getSymbolIterator */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return iterator; });
/* unused harmony export $$iterator */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = /*@__PURE__*/ getSymbolIterator();
var $$iterator = iterator;
//# sourceMappingURL=iterator.js.map


/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return fromArray; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(102);
/* harmony import */ var _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80);
/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */



function fromArray(input, scheduler) {
    if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__[/* subscribeToArray */ "a"])(input));
    }
    else {
        return Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__[/* scheduleArray */ "a"])(input, scheduler);
    }
}
//# sourceMappingURL=fromArray.js.map


/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OtherError; });
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @class OtherError
 * @extends Error
 */

var OtherError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(OtherError, _Error);

  /**
   * @param {string} code
   * @param {string} reason
   * @param {Boolean} fatal
   */
  function OtherError(code, reason) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), OtherError.prototype);
    _this.name = "OtherError";
    _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__[/* ErrorTypes */ "b"].OTHER_ERROR;
    _this.code = code;
    _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_this.name, _this.code, reason);
    _this.fatal = false;
    return _this;
  }

  return OtherError;
}( /*#__PURE__*/_wrapNativeSuper(Error));



/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return findCompleteBox; });
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Find the offset for the first declaration of the given box in an isobmff.
 * Returns -1 if not found or if incomplete.
 *
 * This function does not throw or log in case of partial segments.
 * @param {Uint8Array} buf - the isobmff
 * @param {Number} wantedName
 * @returns {Number} - Offset where the box begins. -1 if not found.
 */

function findCompleteBox(buf, wantedName) {
  var len = buf.length;
  var i = 0;

  while (i + 8 < len) {
    var size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(buf, i);

    if (size <= 0) {
      return -1;
    }

    var name = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(buf, i + 4);

    if (name === wantedName) {
      if (i + size <= len) {
        return i;
      }

      return -1;
    }

    i += size;
  }

  return -1;
}

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ensureCallable = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};

var byObserver = function (Observer) {
	var node = document.createTextNode(''), queue, currentQueue, i = 0;
	new Observer(function () {
		var callback;
		if (!queue) {
			if (!currentQueue) return;
			queue = currentQueue;
		} else if (currentQueue) {
			queue = currentQueue.concat(queue);
		}
		currentQueue = queue;
		queue = null;
		if (typeof currentQueue === 'function') {
			callback = currentQueue;
			currentQueue = null;
			callback();
			return;
		}
		node.data = (i = ++i % 2); // Invoke other batch, to handle leftover callbacks in case of crash
		while (currentQueue) {
			callback = currentQueue.shift();
			if (!currentQueue.length) currentQueue = null;
			callback();
		}
	}).observe(node, { characterData: true });
	return function (fn) {
		ensureCallable(fn);
		if (queue) {
			if (typeof queue === 'function') queue = [queue, fn];
			else queue.push(fn);
			return;
		}
		queue = fn;
		node.data = (i = ++i % 2);
	};
};

module.exports = (function () {
	// Node.js
	if ((typeof process === 'object') && process && (typeof process.nextTick === 'function')) {
		return process.nextTick;
	}

	// queueMicrotask
	if (typeof queueMicrotask === "function") {
		return function (cb) { queueMicrotask(ensureCallable(cb)); };
	}

	// MutationObserver
	if ((typeof document === 'object') && document) {
		if (typeof MutationObserver === 'function') return byObserver(MutationObserver);
		if (typeof WebKitMutationObserver === 'function') return byObserver(WebKitMutationObserver);
	}

	// W3C Draft
	// http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
	if (typeof setImmediate === 'function') {
		return function (cb) { setImmediate(ensureCallable(cb)); };
	}

	// Wide available standard
	if ((typeof setTimeout === 'function') || (typeof setTimeout === 'object')) {
		return function (cb) { setTimeout(ensureCallable(cb), 0); };
	}

	return null;
}());


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return rxSubscriber; });
/* unused harmony export $$rxSubscriber */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = /*@__PURE__*/ (function () {
    return typeof Symbol === 'function'
        ? /*@__PURE__*/ Symbol('rxSubscriber')
        : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();
})();
var $$rxSubscriber = rxSubscriber;
//# sourceMappingURL=rxSubscriber.js.map


/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isNumeric; });
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53);
/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */

function isNumeric(val) {
    return !Object(_isArray__WEBPACK_IMPORTED_MODULE_0__[/* isArray */ "a"])(val) && (val - parseFloat(val) + 1) >= 0;
}
//# sourceMappingURL=isNumeric.js.map


/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return checkISOBMFFIntegrity; });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71);
/* harmony import */ var _find_complete_box__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(72);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Uint8Array} buffer
 * @param {boolean} isInit
 * @returns {Array}
 */

function checkISOBMFFIntegrity(buffer, isInit) {
  if (isInit) {
    var ftypIndex = Object(_find_complete_box__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(buffer, 0x66747970
    /* ftyp */
    );

    if (ftypIndex < 0) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("INTEGRITY_ERROR", "Incomplete `ftyp` box");
    }

    var moovIndex = Object(_find_complete_box__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(buffer, 0x6D6F6F76
    /* moov */
    );

    if (moovIndex < 0) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("INTEGRITY_ERROR", "Incomplete `moov` box");
    }
  } else {
    var moofIndex = Object(_find_complete_box__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(buffer, 0x6D6F6F66
    /* moof */
    );

    if (moofIndex < 0) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("INTEGRITY_ERROR", "Incomplete `moof` box");
    }

    var mdatIndex = Object(_find_complete_box__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(buffer, 0x6D646174
    /* mdat */
    );

    if (mdatIndex < 0) {
      throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("INTEGRITY_ERROR", "Incomplete `mdat` box");
    }
  }
}

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export NotificationKind */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Notification; });
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/* harmony import */ var _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);
/* harmony import */ var _observable_throwError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65);
/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */



var NotificationKind;
/*@__PURE__*/ (function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = /*@__PURE__*/ (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return Object(_observable_of__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])(this.value);
            case 'E':
                return Object(_observable_throwError__WEBPACK_IMPORTED_MODULE_2__[/* throwError */ "a"])(this.error);
            case 'C':
                return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_0__[/* empty */ "b"])();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());

//# sourceMappingURL=Notification.js.map


/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getBoxContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getBoxOffsets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getUuidContent; });
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the content of a box based on its name.
 * `null` if not found.
 * /!\ does not work with UUID boxes
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box (e.g. 'sidx' or
 * 'moov'), hexa encoded
 * @returns {UInt8Array|null}
 */

function getBoxContent(buf, boxName) {
  var offsets = getBoxOffsets(buf, boxName);
  return offsets !== null ? buf.subarray(offsets[0] + 8, offsets[1]) : null;
}
/**
 * Returns an ISOBMFF box based on its name.
 * `null` if not found.
 * /!\ does not work with UUID boxes
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box (e.g. 'sidx' or
 * 'moov'), hexa encoded
 * @returns {UInt8Array|null}
 */


function getBox(buf, boxName) {
  var offsets = getBoxOffsets(buf, boxName);
  return offsets !== null ? buf.subarray(offsets[0], offsets[1]) : null;
}
/**
 * Returns start and end offset for a given box.
 * `null` if not found.
 * /!\ does not work with UUID boxes
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box (e.g. 'sidx' or
 * 'moov'), hexa encoded
 * @returns {Array.<number>|null}
 */


function getBoxOffsets(buf, boxName) {
  var l = buf.length;
  var i = 0;
  var name;
  var size = 0;

  while (i + 8 < l) {
    size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(buf, i);
    name = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(buf, i + 4);

    if (size <= 0) {
      throw new Error("ISOBMFF: Size out of range");
    }

    if (name === boxName) {
      break;
    } else {
      i += size;
    }
  }

  if (i < l) {
    return [i, i + size];
  } else {
    return null;
  }
}
/**
 * Gives the content of a specific UUID with its attached ID
 * @param {Uint8Array} buf
 * @param {Number} id1
 * @param {Number} id2
 * @param {Number} id3
 * @param {Number} id4
 * @returns {Uint8Array|undefined}
 */


function getUuidContent(buf, id1, id2, id3, id4) {
  var len;
  var l = buf.length;

  for (var i = 0; i < l; i += len) {
    len = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(buf, i);

    if (Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(buf, i + 4) === 0x75756964
    /* === "uuid" */
    && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(buf, i + 8) === id1 && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(buf, i + 12) === id2 && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(buf, i + 16) === id3 && Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(buf, i + 20) === id4) {
      return buf.subarray(i + 24, i + len);
    }
  }
}



/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return defer; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56);
/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */



function defer(observableFactory) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? Object(_from__WEBPACK_IMPORTED_MODULE_1__[/* from */ "a"])(input) : Object(_empty__WEBPACK_IMPORTED_MODULE_2__[/* empty */ "b"])();
        return source.subscribe(subscriber);
    });
}
//# sourceMappingURL=defer.js.map


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return scheduleArray; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function scheduleArray(input, scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) {
        var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__[/* Subscription */ "a"]();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}
//# sourceMappingURL=scheduleArray.js.map


/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return areArraysOfNumbersEqual; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Check if two two arrays containing only numbers are equal.
 * @param {Array.<number>|TypedArray} arr1
 * @param {Array.<number>|TypedArray} arr2
 * @returns {Boolean}
 */
function areArraysOfNumbersEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (var i = arr1.length - 1; i >= 0; i--) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}

/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export objectValues */
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Object|Array} o
 * @returns {Array.<*>}
 */
function objectValues(o) {
  return Object.keys(o).map(function (k) {
    return o[k];
  });
}
/* tslint:disable no-unbound-method */


/* harmony default export */ __webpack_exports__["a"] = (typeof Object.values === "function" ? Object.values : objectValues);
/* tslint:enable no-unbound-method */



/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getParentElementsByTagName; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the parent elements which have the given tagName, by order of
 * closeness relative to our element.
 * @param {Element|Node} element
 * @param {string} tagName
 * @returns {Array.<Element>}
 */
function getParentElementsByTagName(element, tagName) {
  if (!(element.parentNode instanceof Element)) {
    return [];
  }

  function constructArray(_element) {
    var elements = [];

    if (_element.tagName.toLowerCase() === tagName.toLowerCase()) {
      elements.push(_element);
    }

    var parentNode = _element.parentNode;

    if (parentNode instanceof Element) {
      elements.push.apply(elements, constructArray(parentNode));
    }

    return elements;
  }

  return constructArray(element.parentNode);
}

/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ abstract_source_buffer_AbstractSourceBuffer; });

// EXTERNAL MODULE: ./node_modules/next-tick/index.js
var next_tick = __webpack_require__(73);
var next_tick_default = /*#__PURE__*/__webpack_require__.n(next_tick);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(27);

// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(25);

// EXTERNAL MODULE: ./src/utils/rx-try_catch.ts
var rx_try_catch = __webpack_require__(37);

// EXTERNAL MODULE: ./src/utils/ranges.ts
var ranges = __webpack_require__(19);

// CONCATENATED MODULE: ./src/custom_source_buffers/time_ranges.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Simulate TimeRanges as returned by SourceBuffer.prototype.buffered.
 * Add an "insert" and "remove" methods to manually update it.
 * @class ManualTimeRanges
 */

var time_ranges_ManualTimeRanges = /*#__PURE__*/function () {
  function ManualTimeRanges() {
    this._ranges = [];
    this.length = 0;
  }

  var _proto = ManualTimeRanges.prototype;

  _proto.insert = function insert(start, end) {
    if (false) {}

    Object(ranges["i" /* insertInto */])(this._ranges, {
      start: start,
      end: end
    });
    this.length = this._ranges.length;
  };

  _proto.remove = function remove(start, end) {
    if (false) {}

    var rangesToIntersect = [];

    if (start > 0) {
      rangesToIntersect.push({
        start: 0,
        end: start
      });
    }

    if (end < Infinity) {
      rangesToIntersect.push({
        start: end,
        end: Infinity
      });
    }

    this._ranges = Object(ranges["l" /* keepRangeIntersection */])(this._ranges, rangesToIntersect);
    this.length = this._ranges.length;
  };

  _proto.start = function start(index) {
    if (index >= this._ranges.length) {
      throw new Error("INDEX_SIZE_ERROR");
    }

    return this._ranges[index].start;
  };

  _proto.end = function end(index) {
    if (index >= this._ranges.length) {
      throw new Error("INDEX_SIZE_ERROR");
    }

    return this._ranges[index].end;
  };

  return ManualTimeRanges;
}();


// CONCATENATED MODULE: ./src/custom_source_buffers/abstract_source_buffer.ts
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Abstract class for a custom SourceBuffer implementation.
 * @class AbstractSourceBuffer
 * @extends EventEmitter
 */

var abstract_source_buffer_AbstractSourceBuffer = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(AbstractSourceBuffer, _EventEmitter);

  function AbstractSourceBuffer() {
    var _this;

    _this = _EventEmitter.call(this) || this;
    _this.updating = false;
    _this.readyState = "opened";
    _this.buffered = new time_ranges_ManualTimeRanges();
    _this.timestampOffset = 0;
    _this.appendWindowStart = 0;
    _this.appendWindowEnd = Infinity;
    return _this;
  }
  /**
   * Mimic the SourceBuffer _appendBuffer_ method: Append a segment to the
   * buffer.
   * @param {*} data
   */


  var _proto = AbstractSourceBuffer.prototype;

  _proto.appendBuffer = function appendBuffer(data) {
    var _this2 = this;

    this._lock(function () {
      return _this2._append(data);
    });
  }
  /**
   * Mimic the SourceBuffer _remove_ method: remove buffered segments.
   * @param {Number} from
   * @param {Number} to
   */
  ;

  _proto.remove = function remove(from, to) {
    var _this3 = this;

    this._lock(function () {
      return _this3._remove(from, to);
    });
  }
  /**
   * Call `appendBuffer` synchronously (do not wait for nextTick).
   * @param {*} data
   */
  ;

  _proto.appendBufferSync = function appendBufferSync(data) {
    var _this4 = this;

    this._lockSync(function () {
      return _this4._append(data);
    });
  }
  /**
   * Call `remove` synchronously (do not wait for nextTick).
   * @param {Number} from
   * @param {Number} to
   */
  ;

  _proto.removeSync = function removeSync(from, to) {
    var _this5 = this;

    this._lockSync(function () {
      return _this5._remove(from, to);
    });
  }
  /**
   * Mimic the SourceBuffer _abort_ method.
   */
  ;

  _proto.abort = function abort() {
    this.updating = false;
    this.readyState = "closed";

    this._abort();
  }
  /**
   * Active a lock, execute the given function, unlock when finished (on
   * nextTick).
   * Throws if multiple lock are active at the same time.
   * Also triggers the right events on start, error and end
   * @param {Function} func
   */
  ;

  _proto._lock = function _lock(func) {
    var _this6 = this;

    if (this.updating) {
      throw new Error("SourceBuffer: SourceBuffer already updating.");
    }

    this.updating = true;
    this.trigger("updatestart", undefined);
    var result = Object(rx_try_catch["a" /* default */])(function () {
      func();
      return Object(of["a" /* of */])(undefined);
    }, undefined);
    result.subscribe(function () {
      return next_tick_default()(function () {
        _this6.updating = false;

        _this6.trigger("update", undefined);

        _this6.trigger("updateend", undefined);
      });
    }, function (e) {
      return next_tick_default()(function () {
        _this6.updating = false;

        _this6.trigger("error", e);

        _this6.trigger("updateend", undefined);
      });
    });
  }
  /**
   * Call SourceBuffer function but throw errors and emit events synchronously.
   * Throws if another function is already active.
   * Also triggers the right events on start, error and end
   * @param {Function} func
   * @param {*} data
   */
  ;

  _proto._lockSync = function _lockSync(func) {
    if (this.updating) {
      throw new Error("SourceBuffer: SourceBuffer already updating.");
    }

    this.updating = true;
    this.trigger("updatestart", undefined);

    try {
      func();
    } catch (e) {
      this.updating = false;
      this.trigger("error", e);
      this.trigger("updateend", undefined);
      throw e;
    }

    this.updating = false;
    this.trigger("update", undefined);
    this.trigger("updateend", undefined);
  };

  return AbstractSourceBuffer;
}(event_emitter["a" /* default */]);



/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ AsyncScheduler_AsyncScheduler; });

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(4);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Scheduler.js
var Scheduler = /*@__PURE__*/ (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());

//# sourceMappingURL=Scheduler.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */


var AsyncScheduler_AsyncScheduler = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler));

//# sourceMappingURL=AsyncScheduler.js.map


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ AsyncAction_AsyncAction; });

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(22);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/Action.js
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */


var Action_Action = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription["a" /* Subscription */]));

//# sourceMappingURL=Action.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */


var AsyncAction_AsyncAction = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_Action));

//# sourceMappingURL=AsyncAction.js.map


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return empty; });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);
/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64);
/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */


var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (_config__WEBPACK_IMPORTED_MODULE_0__[/* config */ "a"].useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__[/* hostReportError */ "a"])(err);
        }
    },
    complete: function () { }
};
//# sourceMappingURL=Observer.js.map


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return merge; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
/* harmony import */ var _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(100);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(70);
/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */




function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__[/* isScheduler */ "a"])(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"]) {
        return observables[0];
    }
    return Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__[/* mergeAll */ "a"])(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__[/* fromArray */ "a"])(observables, scheduler));
}
//# sourceMappingURL=merge.js.map


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return fetchIsSupported; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(139);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(38);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/*
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var DEFAULT_REQUEST_TIMEOUT = _config__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].DEFAULT_REQUEST_TIMEOUT;

var _Headers = typeof Headers === "function" ? Headers : null;

var _AbortController = typeof AbortController === "function" ? AbortController : null;

function fetchRequest(options) {
  var headers;

  if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(options.headers)) {
    if (Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(_Headers)) {
      headers = options.headers;
    } else {
      headers = new _Headers();
      var headerNames = Object.keys(options.headers);

      for (var i = 0; i < headerNames.length; i++) {
        var headerName = headerNames[i];
        headers.append(headerName, options.headers[headerName]);
      }
    }
  }

  return new rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (obs) {
    _log__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].debug("Fetch: Called with URL", options.url);
    var hasAborted = false;
    var timeouted = false;
    var isDone = false;
    var sendingTime = performance.now();
    var abortController = !Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(_AbortController) ? new _AbortController() : null;
    /**
     * Abort current fetchRequest by triggering AbortController signal.
     * @returns {void}
     */

    function abortRequest() {
      if (!isDone) {
        if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(abortController)) {
          return abortController.abort();
        }

        _log__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].warn("Fetch: AbortController API not available.");
      }
    }

    var requestTimeout = Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(options.timeout) ? DEFAULT_REQUEST_TIMEOUT : options.timeout;
    var timeout = window.setTimeout(function () {
      timeouted = true;
      abortRequest();
    }, requestTimeout);
    fetch(options.url, {
      headers: headers,
      method: "GET",
      signal: !Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(abortController) ? abortController.signal : undefined
    }).then(function (response) {
      if (!Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(timeout)) {
        clearTimeout(timeout);
      }

      if (response.status >= 300) {
        _log__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].warn("Fetch: Request HTTP Error", response);
        obs.error(new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](response.url, response.status, _errors__WEBPACK_IMPORTED_MODULE_3__[/* NetworkErrorTypes */ "c"].ERROR_HTTP_CODE));
        return undefined;
      }

      if (Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(response.body)) {
        obs.error(new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](response.url, response.status, _errors__WEBPACK_IMPORTED_MODULE_3__[/* NetworkErrorTypes */ "c"].PARSE_ERROR));
        return undefined;
      }

      var contentLengthHeader = response.headers.get("Content-Length");
      var contentLength = !Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(contentLengthHeader) && !isNaN(+contentLengthHeader) ? +contentLengthHeader : undefined;
      var reader = response.body.getReader();
      var size = 0;
      return readBufferAndSendEvents();

      function readBufferAndSendEvents() {
        return _readBufferAndSendEvents.apply(this, arguments);
      }

      function _readBufferAndSendEvents() {
        _readBufferAndSendEvents = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
          var data, currentTime, dataChunk, receivedTime, duration;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return reader.read();

                case 2:
                  data = _context.sent;

                  if (!(!data.done && !Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(data.value))) {
                    _context.next = 11;
                    break;
                  }

                  size += data.value.byteLength;
                  currentTime = performance.now();
                  dataChunk = {
                    type: "data-chunk",
                    value: {
                      url: response.url,
                      currentTime: currentTime,
                      duration: currentTime - sendingTime,
                      sendingTime: sendingTime,
                      chunkSize: data.value.byteLength,
                      chunk: data.value.buffer,
                      size: size,
                      totalSize: contentLength
                    }
                  };
                  obs.next(dataChunk);
                  return _context.abrupt("return", readBufferAndSendEvents());

                case 11:
                  if (data.done) {
                    receivedTime = performance.now();
                    duration = receivedTime - sendingTime;
                    isDone = true;
                    obs.next({
                      type: "data-complete",
                      value: {
                        duration: duration,
                        receivedTime: receivedTime,
                        sendingTime: sendingTime,
                        size: size,
                        status: response.status,
                        url: response.url
                      }
                    });
                    obs.complete();
                  }

                case 12:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return _readBufferAndSendEvents.apply(this, arguments);
      }
    })["catch"](function (err) {
      if (hasAborted) {
        _log__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].debug("Fetch: Request aborted.");
        return;
      }

      if (timeouted) {
        _log__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].warn("Fetch: Request timeouted.");
        obs.error(new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](options.url, 0, _errors__WEBPACK_IMPORTED_MODULE_3__[/* NetworkErrorTypes */ "c"].TIMEOUT));
        return;
      }

      _log__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].warn("Fetch: Request Error", err instanceof Error ? err.toString() : "");
      obs.error(new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](options.url, 0, _errors__WEBPACK_IMPORTED_MODULE_3__[/* NetworkErrorTypes */ "c"].ERROR_EVENT));
      return;
    });
    return function () {
      hasAborted = true;
      abortRequest();
    };
  });
}
/**
 * Returns true if fetch should be supported in the current browser.
 * @return {boolean}
 */


function fetchIsSupported() {
  return typeof window.fetch === "function" && !Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(_AbortController) && !Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"])(_Headers);
}
/* harmony default export */ __webpack_exports__["a"] = (fetchRequest); // function fetchRequest(options : IRequestOptions< undefined | null | "" | "text",
//                                             false | undefined>)
//                      : Observable<IRequestResponse< string, "text" >>;
// function fetchRequest(options : IRequestOptions< undefined | null | "" | "text",
//                                             true >)
//                      : Observable<IRequestResponse< string, "text" > |
//                                   IRequestProgress< string > >;
// function fetchRequest(options : IRequestOptions< "arraybuffer",
//                                             false | undefined>)
//                      : Observable<IRequestResponse< ArrayBuffer, "arraybuffer" >>;
// function fetchRequest(options : IRequestOptions<"arraybuffer", true>)
//                      : Observable<IRequestResponse< ArrayBuffer, "arraybuffer" > |
//                                   IRequestProgress < ArrayBuffer > >;
//                                   // IRequestProgress |
//                                   // IRequestDataChunk< ArrayBuffer, "arraybuffer" >>;
// function fetchRequest(options : IRequestOptions< "document",
//                                             false | undefined >)
//                 : Observable<IRequestResponse< Document, "document" >>;
// function fetchRequest(options : IRequestOptions< "document",
//                                             true >)
//                 : Observable<IRequestResponse< Document, "document" > |
//                              IRequestProgress< undefined > >;
// function fetchRequest(options : IRequestOptions< "json",
//                                             false | undefined >)
//                 : Observable<IRequestResponse< object, "json" >>;
// function fetchRequest(options : IRequestOptions< "json", true >)
//                 : Observable<IRequestResponse< object, "json" > |
//                              IRequestProgress< undefined > >;
// function fetchRequest(options : IRequestOptions< "blob",
//                                             false|undefined >)
//                 : Observable<IRequestResponse< Blob, "blob" >>;
// function fetchRequest(options : IRequestOptions<"blob", true>)
//                 : Observable<IRequestResponse< Blob, "blob" > |
//                              IRequestProgress< Blob > >;
// function fetchRequest<T>(
//   options : IRequestOptions< XMLHttpRequestResponseType | null | undefined,
//                              false | undefined >)
//   : Observable<IRequestResponse< T, XMLHttpRequestResponseType >>;
// function fetchRequest<T>(
//   options : IRequestOptions< XMLHttpRequestResponseType | null | undefined,
//                             true >)
//   : Observable<IRequestResponse< T, XMLHttpRequestResponseType > |
//                IRequestProgress< T | undefined >
// >;
// function fetchRequest<T>(
//   options : IRequestOptions< XMLHttpRequestResponseType | null | undefined,
//                             boolean | undefined >
// ) : Observable<IRequestResponse< T, XMLHttpRequestResponseType > |
//                IRequestProgress< T | undefined >
// > {
// const responseType = !options.responseType ||
//                      options.responseType === "document" ? "text" :
//                                                            options.responseType;
// return (() => {
//   switch (responseType) {
//     case "arraybuffer":
//       return response.arrayBuffer();
//     case "json":
//       return response.json();
//     case "blob":
//       return response.blob();
//     case "text":
//       return response.text();
//   }
// })().then((responseData) => {
//   isDone = true;
//   const receivedTime = performance.now();
//   obs.next({ type: "response" as const,
//              value: { responseType,
//                       status: response.status,
//                       url: response.url,
//                       sendingTime,
//                       receivedTime,
//                duration: receivedTime - sendingTime,
//                       size: responseData instanceof ArrayBuffer ?
//                               responseData.byteLength :
//                               0,
//                       responseData } });
// }).catch((err) => {
//   log.warn("Fetch: Request Parsing Error", err && err.toString());
//   if (hasAborted) { // is that even possible?
//     return;
//   }
//   obs.error(new RequestError(null,
//                              response.url,
//                              response.status,
//                              NetworkErrorTypes.PARSE_ERROR));
//   return;
// });

/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return clearElementSrc; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Clear element's src attribute.
 * @param {HTMLMediaElement} element
 */

function clearElementSrc(element) {
  // On Firefox, we also have to make sure the textTracks elements are both
  // disabled and removed from the DOM.
  // If we do not do that, we may be left with displayed text tracks on the
  // screen
  if (_browser_detection__WEBPACK_IMPORTED_MODULE_1__[/* isFirefox */ "a"]) {
    var textTracks = element.textTracks;

    for (var i = 0; i < textTracks.length; i++) {
      textTracks[i].mode = "disabled";
    }

    if (element.hasChildNodes()) {
      var childNodes = element.childNodes;

      for (var j = childNodes.length - 1; j >= 0; j--) {
        if (childNodes[j].nodeName === "track") {
          try {
            element.removeChild(childNodes[j]);
          } catch (err) {
            _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: Could not remove text track child from element.");
          }
        }
      }
    }
  }

  element.src = ""; // On IE11, element.src = "" is not sufficient as it
  // does not clear properly the current MediaKey Session.
  // Microsoft recommended to use element.removeAttr("src").

  element.removeAttribute("src");
}

/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return flatMap; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Map each element using a mapping function, then flat the result into
 * a new array.
 * @param {Array.<*>} originalArray
 * @param {Function} fn
 */
function flatMap(originalArray, fn) {
  /* tslint:disable no-unbound-method */
  if (typeof Array.prototype.flatMap === "function") {
    /* tslint:enable no-unbound-method */

    /* tslint:disable no-unsafe-any */
    return originalArray.flatMap(fn);
    /* tslint:enable no-unsafe-any */
  }

  return originalArray.reduce(function (acc, arg) {
    var r = fn(arg);

    if (Array.isArray(r)) {
      return [].concat(acc, r);
    }

    return [].concat(acc, [r]);
  }, []);
}

/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ multicast; });

// UNUSED EXPORTS: MulticastOperator

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/refCount.js
var refCount = __webpack_require__(125);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js
/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */






var ConnectableObservable_ConnectableObservable = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription["a" /* Subscription */]();
            connection.add(this.source
                .subscribe(new ConnectableObservable_ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription["a" /* Subscription */].EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return Object(refCount["a" /* refCount */])()(this);
    };
    return ConnectableObservable;
}(Observable["a" /* Observable */]));

var connectableObservableDescriptor = /*@__PURE__*/ (function () {
    var connectableProto = ConnectableObservable_ConnectableObservable.prototype;
    return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
})();
var ConnectableObservable_ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject["b" /* SubjectSubscriber */]));
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new ConnectableObservable_RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var ConnectableObservable_RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber["a" /* Subscriber */]));
//# sourceMappingURL=ConnectableObservable.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/multicast.js
/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */

function multicast(subjectOrSubjectFactory, selector) {
    return function multicastOperatorFunction(source) {
        var subjectFactory;
        if (typeof subjectOrSubjectFactory === 'function') {
            subjectFactory = subjectOrSubjectFactory;
        }
        else {
            subjectFactory = function subjectFactory() {
                return subjectOrSubjectFactory;
            };
        }
        if (typeof selector === 'function') {
            return source.lift(new MulticastOperator(subjectFactory, selector));
        }
        var connectable = Object.create(source, connectableObservableDescriptor);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
    };
}
var MulticastOperator = /*@__PURE__*/ (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());

//# sourceMappingURL=multicast.js.map


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EncryptedMediaError; });
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Error linked to the encryption of the media.
 *
 * @class EncryptedMediaError
 * @extends Error
 */

var EncryptedMediaError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(EncryptedMediaError, _Error);

  /**
   * @param {string} code
   * @param {string} reason
   * @Param {Boolean} fatal
   */
  function EncryptedMediaError(code, reason) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), EncryptedMediaError.prototype);
    _this.name = "EncryptedMediaError";
    _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__[/* ErrorTypes */ "b"].ENCRYPTED_MEDIA_ERROR;
    _this.code = code;
    _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_this.name, _this.code, reason);
    _this.fatal = false;
    return _this;
  }

  return EncryptedMediaError;
}( /*#__PURE__*/_wrapNativeSuper(Error));



/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ asap; });

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(4);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/Immediate.js
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var tasksByHandle = {};
function runIfPresent(handle) {
    var cb = tasksByHandle[handle];
    if (cb) {
        cb();
    }
}
var Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        tasksByHandle[handle] = cb;
        Promise.resolve().then(function () { return runIfPresent(handle); });
        return handle;
    },
    clearImmediate: function (handle) {
        delete tasksByHandle[handle];
    },
};
//# sourceMappingURL=Immediate.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js + 1 modules
var AsyncAction = __webpack_require__(86);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js
/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */



var AsapAction_AsapAction = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction["a" /* AsyncAction */]));

//# sourceMappingURL=AsapAction.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js + 1 modules
var AsyncScheduler = __webpack_require__(85);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var AsapScheduler_AsapScheduler = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler["a" /* AsyncScheduler */]));

//# sourceMappingURL=AsapScheduler.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/asap.js
/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */


var asap = /*@__PURE__*/ new AsapScheduler_AsapScheduler(AsapAction_AsapAction);
//# sourceMappingURL=asap.js.map


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return requestFullscreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return exitFullscreen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return isFullscreen; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Request fullScreen action on a given element.
 * @param {HTMLElement} elt
 * rs-detect)
 */
function requestFullscreen(element) {
  if (!isFullscreen()) {
    var elt = element;
    /* tslint:disable no-unbound-method */

    if (typeof elt.requestFullscreen === "function") {
      /* tslint:enable no-unbound-method */

      /* tslint:disable no-floating-promises */
      elt.requestFullscreen();
      /* tslint:enable no-floating-promises */
    } else if (typeof elt.msRequestFullscreen === "function") {
      elt.msRequestFullscreen();
    } else if (typeof elt.mozRequestFullScreen === "function") {
      elt.mozRequestFullScreen();
    } else if (typeof elt.webkitRequestFullscreen === "function") {
      elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    }
  }
}
/**
 * Exit fullscreen if an element is currently in fullscreen.
 */


function exitFullscreen() {
  if (isFullscreen()) {
    var doc = document;
    /* tslint:disable no-unbound-method */

    if (typeof doc.exitFullscreen === "function") {
      /* tslint:enable no-unbound-method */

      /* tslint:disable no-floating-promises */
      doc.exitFullscreen();
      /* tslint:enable no-floating-promises */
    } else if (typeof doc.msExitFullscreen === "function") {
      doc.msExitFullscreen();
    } else if (typeof doc.mozCancelFullScreen === "function") {
      doc.mozCancelFullScreen();
    } else if (typeof doc.webkitExitFullscreen === "function") {
      doc.webkitExitFullscreen();
    }
  }
}
/**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */


function isFullscreen() {
  var doc = document;
  return doc.fullscreenElement != null || doc.mozFullScreenElement != null || doc.webkitFullscreenElement != null || doc.msFullscreenElement != null;
}



/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _utils_are_arrays_of_numbers_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Normalized Representation structure.
 * @class Representation
 */

var Representation = /*#__PURE__*/function () {
  /**
   * @param {Object} args
   */
  function Representation(args) {
    this.id = args.id;
    this.bitrate = args.bitrate;
    this.codec = args.codecs;

    if (args.height != null) {
      this.height = args.height;
    }

    if (args.width != null) {
      this.width = args.width;
    }

    if (args.mimeType != null) {
      this.mimeType = args.mimeType;
    }

    if (args.contentProtections !== undefined) {
      this.contentProtections = args.contentProtections;
    }

    if (args.frameRate != null) {
      this.frameRate = args.frameRate;
    }

    this.index = args.index;
  }
  /**
   * Returns "mime-type string" which includes both the mime-type and the codec,
   * which is often needed when interacting with the browser's APIs.
   * @returns {string}
   */


  var _proto = Representation.prototype;

  _proto.getMimeTypeString = function getMimeTypeString() {
    return this.mimeType + ";codecs=\"" + this.codec + "\"";
  }
  /**
   * Returns every protection initialization data concatenated.
   * This data can then be used through the usual EME APIs.
   * `null` if this Representation has no detected protection initialization
   * data.
   * @returns {Array.<Object>|null}
   */
  ;

  _proto.getProtectionsInitializationData = function getProtectionsInitializationData() {
    var contentProtections = this.contentProtections;

    if (contentProtections === undefined) {
      return [];
    }

    return Object.keys(contentProtections.initData).reduce(function (acc, initDataType) {
      var initDataArr = contentProtections.initData[initDataType];

      if (initDataArr === undefined || initDataArr.length === 0) {
        return acc;
      }

      var initData = _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* concat */ "h"].apply(void 0, initDataArr.map(function (_ref) {
        var data = _ref.data;
        return data;
      }));
      acc.push({
        type: initDataType,
        data: initData
      });
      return acc;
    }, []);
  }
  /**
   * Add protection data to the Representation to be able to properly blacklist
   * it if that data is.
   * /!\ Mutates the current Representation
   * @param {string} initDataArr
   * @param {string} systemId
   * @param {Uint8Array} data
   */
  ;

  _proto._addProtectionData = function _addProtectionData(initDataType, systemId, data) {
    var newElement = {
      systemId: systemId,
      data: data
    };

    if (this.contentProtections === undefined) {
      var _initData;

      this.contentProtections = {
        keyIds: [],
        initData: (_initData = {}, _initData[initDataType] = [newElement], _initData)
      };
      return;
    }

    var initDataArr = this.contentProtections.initData[initDataType];

    if (initDataArr === undefined) {
      this.contentProtections.initData[initDataType] = [newElement];
      return;
    }

    for (var i = initDataArr.length - 1; i >= 0; i--) {
      if (initDataArr[i].systemId === systemId) {
        if (Object(_utils_are_arrays_of_numbers_equal__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(initDataArr[i].data, data)) {
          return;
        }

        _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Manifest: Two PSSH for the same system ID");
      }
    }

    initDataArr.push(newElement);
  };

  return Representation;
}();

/* harmony default export */ __webpack_exports__["a"] = (Representation);

/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ normalizeAudioTrack; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* binding */ normalizeTextTrack; });

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(9);

// CONCATENATED MODULE: ./src/utils/languages/ISO_639-1_to_ISO_639-3.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Translate ISO 639-1 language codes into ISO 639-3 ones.
 */
var ISO_MAP_1_TO_3 = {
  aa: "aar",
  ab: "abk",
  ae: "ave",
  af: "afr",
  ak: "aka",
  am: "amh",
  an: "arg",
  ar: "ara",
  as: "asm",
  av: "ava",
  ay: "aym",
  az: "aze",
  ba: "bak",
  be: "bel",
  bg: "bul",
  bi: "bis",
  bm: "bam",
  bn: "ben",
  bo: "bod",
  br: "bre",
  bs: "bos",
  ca: "cat",
  ce: "che",
  ch: "cha",
  co: "cos",
  cr: "cre",
  cs: "ces",
  cu: "chu",
  // Old Slavonic, Old Bulgarian
  cv: "chv",
  cy: "cym",
  da: "dan",
  de: "deu",
  dv: "div",
  dz: "dzo",
  ee: "ewe",
  el: "ell",
  en: "eng",
  eo: "epo",
  es: "spa",
  et: "est",
  eu: "eus",
  fa: "fas",
  ff: "ful",
  fi: "fin",
  fj: "fij",
  fo: "fao",
  fr: "fra",
  fy: "fry",
  ga: "gle",
  gd: "gla",
  gl: "glg",
  gn: "grn",
  gu: "guj",
  gv: "glv",
  ha: "hau",
  he: "heb",
  hi: "hin",
  ho: "hmo",
  hr: "hrv",
  ht: "hat",
  hu: "hun",
  hy: "hye",
  hz: "her",
  ia: "ina",
  id: "ind",
  ie: "ile",
  ig: "ibo",
  ii: "iii",
  ik: "ipk",
  io: "ido",
  is: "isl",
  it: "ita",
  iu: "iku",
  ja: "jpn",
  jv: "jav",
  ka: "kat",
  kg: "kon",
  ki: "kik",
  kj: "kua",
  kk: "kaz",
  kl: "kal",
  km: "khm",
  kn: "kan",
  ko: "kor",
  kr: "kau",
  ks: "kas",
  ku: "kur",
  kv: "kom",
  kw: "cor",
  ky: "kir",
  la: "lat",
  lb: "ltz",
  lg: "lug",
  li: "lim",
  ln: "lin",
  lo: "lao",
  lt: "lit",
  lu: "lub",
  lv: "lav",
  mg: "mlg",
  mh: "mah",
  mi: "mri",
  mk: "mkd",
  ml: "mal",
  mn: "mon",
  mr: "mar",
  ms: "msa",
  mt: "mlt",
  my: "mya",
  na: "nau",
  nb: "nob",
  nd: "nde",
  ne: "nep",
  ng: "ndo",
  nl: "nld",
  nn: "nno",
  no: "nor",
  nr: "nbl",
  nv: "nav",
  ny: "nya",
  oc: "oci",
  oj: "oji",
  om: "orm",
  or: "ori",
  os: "oss",
  pa: "pan",
  pi: "pli",
  pl: "pol",
  ps: "pus",
  pt: "por",
  qu: "que",
  rm: "roh",
  rn: "run",
  ro: "ron",
  ru: "rus",
  rw: "kin",
  sa: "san",
  sc: "srd",
  sd: "snd",
  se: "sme",
  sg: "sag",
  si: "sin",
  sk: "slk",
  sl: "slv",
  sm: "smo",
  sn: "sna",
  so: "som",
  sq: "sqi",
  sr: "srp",
  ss: "ssw",
  st: "sot",
  su: "sun",
  sv: "swe",
  sw: "swa",
  ta: "tam",
  te: "tel",
  tg: "tgk",
  th: "tha",
  ti: "tir",
  tk: "tuk",
  tl: "tgl",
  tn: "tsn",
  to: "ton",
  tr: "tur",
  ts: "tso",
  tt: "tat",
  tw: "twi",
  ty: "tah",
  ug: "uig",
  uk: "ukr",
  ur: "urd",
  uz: "uzb",
  ve: "ven",
  vi: "vie",
  vo: "vol",
  wa: "wln",
  wo: "wol",
  xh: "xho",
  yi: "yid",
  yo: "yor",
  za: "zha",
  zh: "zho",
  zu: "zul"
};
/* harmony default export */ var ISO_639_1_to_ISO_639_3 = (ISO_MAP_1_TO_3);
// CONCATENATED MODULE: ./src/utils/languages/ISO_639-2_to_ISO_639-3.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Translate ISO 639-2 synonyms to their ISO 639-3 counterparts.
 */
var ISO_MAP_2_TO_3 = {
  alb: "sqi",
  arm: "hye",
  baq: "eus",
  bur: "mya",
  chi: "zho",
  cze: "ces",
  dut: "nld",
  fre: "fra",
  geo: "kat",
  ger: "deu",
  gre: "ell",
  ice: "isl",
  mac: "mkd",
  mao: "mri",
  may: "msa",
  per: "fas",
  slo: "slk",
  rum: "ron",
  tib: "bod",
  wel: "cym"
};
/* harmony default export */ var ISO_639_2_to_ISO_639_3 = (ISO_MAP_2_TO_3);
// CONCATENATED MODULE: ./src/utils/languages/normalize.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Normalize language given.
 * Basically:
 *   - converts it to lowercase.
 *   - normalize "base" (what is before the possible first "-") to an ISO639-3
 *     compatible string.
 * @param {string} _language
 * @returns {string}
 */

function normalizeLanguage(_language) {
  if (Object(is_null_or_undefined["a" /* default */])(_language) || _language === "") {
    return "";
  }

  var fields = ("" + _language).toLowerCase().split("-");

  var base = fields[0];
  var normalizedBase = normalizeBase(base);

  if (Object(is_non_empty_string["a" /* default */])(normalizedBase)) {
    return normalizedBase;
  }

  return _language;
}
/**
 * Normalize language into an ISO639-3 format.
 * Returns undefined if it failed to do so
 * @param {string} base
 * @returns {string}
 */


function normalizeBase(base) {
  var result;

  switch (base.length) {
    case 2:
      result = ISO_639_1_to_ISO_639_3[base];
      break;

    case 3:
      result = ISO_639_2_to_ISO_639_3[base];
      break;
  }

  return result;
}
/**
 * Normalize text track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - closedCaption {Boolean}: Whether the track is a closed caption track
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */


function normalizeTextTrack(_language) {
  if (!Object(is_null_or_undefined["a" /* default */])(_language)) {
    var language;
    var closedCaption = false;

    if (typeof _language === "string") {
      language = _language;
    } else {
      language = _language.language;

      if (_language.closedCaption === true) {
        closedCaption = true;
      }
    }

    return {
      language: language,
      closedCaption: closedCaption,
      normalized: normalizeLanguage(language)
    };
  }

  return _language;
}
/**
 * Normalize audio track from a user given input into an object
 * with the following properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - audioDescription {Boolean}: Whether the track is a closed caption track
 *   - isDub {Boolean|undefined}: if true, this is a dub.
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */


function normalizeAudioTrack(_language) {
  if (Object(is_null_or_undefined["a" /* default */])(_language)) {
    return _language;
  }

  if (typeof _language === "string") {
    return {
      language: _language,
      audioDescription: false,
      normalized: normalizeLanguage(_language)
    };
  }

  var normalized = {
    language: _language.language,
    audioDescription: _language.audioDescription === true,
    normalized: normalizeLanguage(normalizeLanguage(_language.language))
  };

  if (_language.isDub === true) {
    normalized.isDub = true;
  }

  return normalized;
}

/* harmony default export */ var normalize = __webpack_exports__["a"] = (normalizeLanguage);


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isObject; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
    return x !== null && typeof x === 'object';
}
//# sourceMappingURL=isObject.js.map


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shouldUseWebKitMediaKeys; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 // On Safari 12.1, it seems that since fairplay CDM implementation
// within the browser is not standard with EME w3c current spec, the
// requestMediaKeySystemAccess API doesn't resolve positively, even
// if the drm (fairplay in most cases) is supported.

function shouldUseWebKitMediaKeys() {
  return _browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isSafari */ "d"] && window.WebKitMediaKeys != null;
}

/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return mergeAll; });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(168);
/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */


function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__[/* mergeMap */ "a"])(_util_identity__WEBPACK_IMPORTED_MODULE_1__[/* identity */ "a"], concurrent);
}
//# sourceMappingURL=mergeAll.js.map


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isArrayLike; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });
//# sourceMappingURL=isArrayLike.js.map


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return subscribeToArray; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
    return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        subscriber.complete();
    };
};
//# sourceMappingURL=subscribeToArray.js.map


/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isPromise; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
//# sourceMappingURL=isPromise.js.map


/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isDate; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isDate(value) {
    return value instanceof Date && !isNaN(+value);
}
//# sourceMappingURL=isDate.js.map


/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SubjectSubscription; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22);
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */


var SubjectSubscription = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__[/* Subscription */ "a"]));

//# sourceMappingURL=SubjectSubscription.js.map


/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ArgumentOutOfRangeError; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ArgumentOutOfRangeErrorImpl = /*@__PURE__*/ (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
//# sourceMappingURL=ArgumentOutOfRangeError.js.map


/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SimpleSet; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Simple hash-based set.
 * @class SimpleSet
 */
var SimpleSet = /*#__PURE__*/function () {
  function SimpleSet() {
    this._hashes = {};
  }
  /**
   * Add a new hash entry in the set.
   * Do not have any effect on already-added hashes
   * @param {string|number} x
   */


  var _proto = SimpleSet.prototype;

  _proto.add = function add(x) {
    this._hashes[x] = true;
  }
  /**
   * Remove an hash entry from the set.
   * Do not have any effect on already-removed or inexistant hashes
   * @param {string|number} x
   */
  ;

  _proto.remove = function remove(x) {
    delete this._hashes[x];
  }
  /**
   * Test if the given hash has an entry in the set.
   * @param {string|number} x
   * @returns {boolean}
   */
  ;

  _proto.test = function test(x) {
    return this._hashes.hasOwnProperty(x);
  }
  /**
   * Returns true if there's currently no hash in this set.
   * @returns {boolean}
   */
  ;

  _proto.isEmpty = function isEmpty() {
    return Object.keys(this._hashes).length === 0;
  };

  return SimpleSet;
}();



/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PSSH_TO_INTEGER; });
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 // The way "pssh" will be written in ISOBMFF files

var PSSH_TO_INTEGER = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* be4toi */ "c"])(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* strToBytes */ "q"])("pssh"), 0);

/***/ }),
/* 109 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getFuzzedDelay; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var FUZZ_FACTOR = 0.3;
/**
 * Perform "fuzzing" on the delay given.
 * @param {Number} retryDelay
 * @returns {Number}
 */

function getFuzzedDelay(retryDelay) {
  var fuzzingFactor = (Math.random() * 2 - 1) * FUZZ_FACTOR;
  return retryDelay * (fuzzingFactor + 1); // Max 1.3 Min 0.7
}

/***/ }),
/* 110 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return disposeMediaKeys; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(180);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(210);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(0);
/* harmony import */ var _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(40);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */

function disposeMediaKeys(mediaElement) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* defer */ "a"])(function () {
    var currentState = _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].getState(mediaElement);

    if (currentState === null) {
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])(null);
    }

    _log__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].debug("EME: Disposing of the current MediaKeys");
    var sessionsStore = currentState.sessionsStore;
    _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].clearState(mediaElement);
    return sessionsStore.closeAllSessions().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* mergeMapTo */ "a"])(Object(_compat__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(mediaElement, null)));
  });
}

/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isSegmentStillAvailable; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if a Segment returned by the corresponding index is still
 * considered available.
 * Returns false if it is not available anymore.
 * Returns undefined if we cannot know whether it is still available or not.
 * /!\ We do not check the mediaURLs of the segment.
 * @param {Object} segment
 * @param {Array.<Object>} timescale
 * @param {number} timeline
 * @returns {Boolean|undefined}
 */
function isSegmentStillAvailable(segment, timeline, timescale, indexTimeOffset) {
  if (timescale !== segment.timescale) {
    // weird case (update?)
    // In any case, it would be over-engineering to do time scaling here.
    return undefined;
  }

  for (var i = 0; i < timeline.length; i++) {
    var tSegment = timeline[i];
    var tSegmentTime = tSegment.start - indexTimeOffset;

    if (tSegmentTime > segment.time) {
      return false;
    } else if (tSegmentTime === segment.time) {
      // there should be only one here
      if (tSegment.duration !== segment.duration) {
        return false;
      }

      if (tSegment.range == null) {
        return segment.range == null;
      }

      return segment.range != null && tSegment.range[0] === segment.range[0] && tSegment.range[1] === segment.range[1];
    } else {
      // tSegment.start < segment.time
      if (tSegment.repeatCount >= 0 && tSegment.duration != null) {
        var timeDiff = tSegmentTime - tSegment.start;
        var repeat = timeDiff / tSegment.duration - 1;
        return repeat % 1 === 0 && repeat <= tSegment.repeatCount;
      }
    }
  }

  return false;
}

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return updateSegmentTimeline; });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _index_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(18);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Update a complete array of segments in a given timeline with a [generally]
 * smaller but [generally] newer set of segments.
 * @param {Array.<Object>} oldTimeline
 * @param {Array.<Object>} newTimeline
 */

function updateSegmentTimeline(oldTimeline, newTimeline) {
  var prevTimelineLength = oldTimeline.length;

  if (oldTimeline.length === 0) {
    oldTimeline.splice.apply(oldTimeline, [0, prevTimelineLength].concat(newTimeline));
    return;
  }

  if (newTimeline.length === 0) {
    return;
  }

  var newIndexStart = newTimeline[0].start;
  var oldLastElt = oldTimeline[prevTimelineLength - 1];
  var oldIndexEnd = Object(_index_helpers__WEBPACK_IMPORTED_MODULE_2__[/* getIndexSegmentEnd */ "c"])(oldLastElt, newTimeline[0]);

  if (oldIndexEnd < newIndexStart) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]("MANIFEST_UPDATE_ERROR", "Cannot perform partial update: not enough data");
  }

  for (var i = prevTimelineLength - 1; i >= 0; i--) {
    var currStart = oldTimeline[i].start;

    if (currStart === newIndexStart) {
      // replace that one and those after it
      oldTimeline.splice.apply(oldTimeline, [i, prevTimelineLength - i].concat(newTimeline));
      return;
    } else if (currStart < newIndexStart) {
      // first to be before
      var currElt = oldTimeline[i];

      if (currElt.start + currElt.duration > newIndexStart) {
        // the new Manifest overlaps a previous segment (weird). Remove the latter.
        _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("RepresentationIndex: Manifest update removed previous segments");
        oldTimeline.splice.apply(oldTimeline, [i, prevTimelineLength - i].concat(newTimeline));
        return;
      } else if (currElt.repeatCount === undefined || currElt.repeatCount <= 0) {
        if (currElt.repeatCount < 0) {
          currElt.repeatCount = Math.floor((newIndexStart - currElt.start) / currElt.duration) - 1;
        }

        oldTimeline.splice.apply(oldTimeline, [i + 1, prevTimelineLength - (i + 1)].concat(newTimeline));
        return;
      } // else, there is a positive repeat we might want to update


      var eltLastTime = currElt.start + currElt.duration * (currElt.repeatCount + 1);

      if (eltLastTime <= newIndexStart) {
        // our new index comes directly after
        // put it after this one
        oldTimeline.splice.apply(oldTimeline, [i + 1, prevTimelineLength - (i + 1)].concat(newTimeline));
        return;
      }

      var newCurrRepeat = (newIndexStart - currElt.start) / currElt.duration - 1;

      if (newCurrRepeat % 1 === 0 && currElt.duration === newTimeline[0].duration) {
        var newRepeatCount = newTimeline[0].repeatCount < 0 ? -1 : // === maximum possible repeat
        newTimeline[0].repeatCount + newCurrRepeat + 1; // replace that one and those after it

        oldTimeline.splice.apply(oldTimeline, [i, prevTimelineLength - i].concat(newTimeline));
        oldTimeline[i].start = currElt.start;
        oldTimeline[i].repeatCount = newRepeatCount;
        return;
      }

      _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("RepresentationIndex: Manifest update removed previous segments");
      oldTimeline[i].repeatCount = Math.floor(newCurrRepeat); // put it after this one

      oldTimeline.splice.apply(oldTimeline, [i + 1, prevTimelineLength - (i + 1)].concat(newTimeline));
      return;
    }
  } // if we got here, it means that every segments in the previous manifest are
  // after the new one. This is unusual.
  // Either the new one has more depth or it's an older one.


  var prevLastElt = oldTimeline[oldTimeline.length - 1];
  var newLastElt = newTimeline[newTimeline.length - 1];

  if (prevLastElt.repeatCount !== undefined && prevLastElt.repeatCount < 0) {
    if (prevLastElt.start > newLastElt.start) {
      _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("RepresentationIndex: The new index is older than the previous one");
      return; // the old comes after
    } else {
      // the new has more depth
      _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("RepresentationIndex: The new index is \"bigger\" than the previous one");
      oldTimeline.splice.apply(oldTimeline, [0, prevTimelineLength].concat(newTimeline));
      return;
    }
  }

  var prevLastTime = prevLastElt.start + prevLastElt.duration * (prevLastElt.repeatCount + 1);
  var newLastTime = newLastElt.start + newLastElt.duration * (newLastElt.repeatCount + 1);

  if (prevLastTime >= newLastTime) {
    _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("RepresentationIndex: The new index is older than the previous one");
    return; // the old comes after
  } // the new one has more depth. full update


  _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("RepresentationIndex: The new index is \"bigger\" than the previous one");
  oldTimeline.splice.apply(oldTimeline, [0, prevTimelineLength].concat(newTimeline));
  return;
}

/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return clearTimelineFromPosition; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Remove segments which starts before the given `firstAvailablePosition` from
 * the timeline. `firstAvailablePosition` has to be time scaled.
 * @param {Array.<Object>}
 * @returns {number}
 */
function clearTimelineFromPosition(timeline, firstAvailablePosition) {
  while (timeline.length > 0) {
    var firstElt = timeline[0];

    if (firstElt.start >= firstAvailablePosition) {
      return; // all clear
    }

    if (firstElt.repeatCount <= 0) {
      timeline.shift();
    } else {
      // we have a segment repetition
      var nextElt = timeline[1];

      if (nextElt != null && nextElt.start <= firstAvailablePosition) {
        timeline.shift();
      } else {
        // no next segment or next segment is available
        if (firstElt.duration <= 0) {
          return;
        }

        var nextStart = firstElt.start + firstElt.duration;
        var nextRepeat = 1;

        while (nextStart < firstAvailablePosition && nextRepeat <= firstElt.repeatCount) {
          nextStart += firstElt.duration;
          nextRepeat++;
        }

        if (nextRepeat > firstElt.repeatCount) {
          // every start is before
          timeline.shift();
        } else {
          // some repetitions start after and some before
          var newRepeat = firstElt.repeatCount - nextRepeat;
          firstElt.start = nextStart;
          firstElt.repeatCount = newRepeat;
          return;
        }
      }
    }
  }
}

/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return checkManifestIDs; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _utils_array_includes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Ensure that no two periods, adaptations from the same period and
 * representations from the same adaptation, have the same ID.
 *
 * Log and mutate their ID if not until this is verified.
 *
 * @param {Object} manifest
 */

function checkManifestIDs(manifest) {
  var periodIDS = [];
  manifest.periods.forEach(function (period) {
    var periodID = period.id;

    if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(periodIDS, periodID)) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Two periods with the same ID found. Updating.");
      var newID = periodID + "-dup";
      period.id = newID;
      checkManifestIDs(manifest);
      periodIDS.push(newID);
    } else {
      periodIDS.push(periodID);
    }

    var adaptations = period.adaptations;
    var adaptationIDs = [];
    Object.keys(adaptations).forEach(function (type) {
      var adaptationsForType = adaptations[type];

      if (adaptationsForType === undefined) {
        return;
      }

      adaptationsForType.forEach(function (adaptation) {
        var adaptationID = adaptation.id;

        if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(adaptationIDs, adaptationID)) {
          _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Two adaptations with the same ID found. Updating.", adaptationID);

          var _newID = adaptationID + "-dup";

          adaptation.id = _newID;
          checkManifestIDs(manifest);
          adaptationIDs.push(_newID);
        } else {
          adaptationIDs.push(adaptationID);
        }

        var representationIDs = [];
        adaptation.representations.forEach(function (representation) {
          var representationID = representation.id;

          if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(representationIDs, representationID)) {
            _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Two representations with the same ID found. Updating.", representationID);

            var _newID2 = representationID + "-dup";

            representation.id = _newID2;
            checkManifestIDs(manifest);
            representationIDs.push(_newID2);
          } else {
            representationIDs.push(representationID);
          }
        });
      });
    });
  });
}

/***/ }),
/* 115 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return generateManifestLoader; });
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _utils_request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(24);
/* harmony import */ var _call_custom_manifest_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(116);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 * @returns {Observable}
 */

function regularManifestLoader(_ref) {
  var url = _ref.url;

  if (url === undefined) {
    throw new Error("Cannot perform HTTP(s) request. URL not known");
  }

  return Object(_utils_request__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])({
    url: url,
    responseType: "document"
  });
}
/**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */


function generateManifestLoader(_ref2) {
  var customManifestLoader = _ref2.customManifestLoader;

  if (Object(_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(customManifestLoader)) {
    return regularManifestLoader;
  }

  return Object(_call_custom_manifest_loader__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(customManifestLoader, regularManifestLoader);
}

/***/ }),
/* 116 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return callCustomManifestLoader; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function callCustomManifestLoader(customManifestLoader, fallbackManifestLoader) {
  return function (args) {
    return new rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (obs) {
      var url = args.url;
      var timeAPIsDelta = Date.now() - performance.now();
      var hasFinished = false;
      var hasFallbacked = false;
      /**
       * Callback triggered when the custom manifest loader has a response.
       * @param {Object} args
       */

      var resolve = function resolve(_args) {
        if (!hasFallbacked) {
          hasFinished = true;
          var receivedTime = _args.receivingTime !== undefined ? _args.receivingTime - timeAPIsDelta : undefined;
          var sendingTime = _args.sendingTime !== undefined ? _args.sendingTime - timeAPIsDelta : undefined;
          obs.next({
            type: "data-loaded",
            value: {
              responseData: _args.data,
              size: _args.size,
              duration: _args.duration,
              url: _args.url,
              receivedTime: receivedTime,
              sendingTime: sendingTime
            }
          });
          obs.complete();
        }
      };
      /**
       * Callback triggered when the custom manifest loader fails
       * @param {*} err - The corresponding error encountered
       */


      var reject = function reject(err) {
        if (!hasFallbacked) {
          hasFinished = true;
          obs.error(err);
        }
      };
      /**
       * Callback triggered when the custom manifest loader wants to fallback to
       * the "regular" implementation
       */


      var fallback = function fallback() {
        hasFallbacked = true;
        fallbackManifestLoader(args).subscribe(obs);
      };

      var callbacks = {
        reject: reject,
        resolve: resolve,
        fallback: fallback
      };
      var abort = customManifestLoader(url, callbacks);
      return function () {
        if (!hasFinished && !hasFallbacked && typeof abort === "function") {
          abort();
        }
      };
    });
  };
}

/***/ }),
/* 117 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return stringFromUTF8; });
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Creates a new string from the given array of char codes.
 *
 * @param {Uint8Array} args
 * @returns {string}
 */

function stringFromCharCode(args) {
  var max = 16000;
  var ret = "";

  for (var i = 0; i < args.length; i += max) {
    var subArray = args.subarray(i, i + max); // NOTE: ugly I know, but TS is problematic here (you can try)

    ret += String.fromCharCode.apply(null, subArray);
  }

  return ret;
}
/**
 * Creates a string from the given buffer as UTF-8 encoding.
 * @param {BufferSource} [data]
 * @returns {string}
 * @throws {Error}
 * @export
 */


function stringFromUTF8(data) {
  if (Object(_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(data)) {
    return "";
  }

  var uint8 = new Uint8Array(data); // If present, strip off the UTF-8 BOM.

  if (uint8[0] === 0xEF && uint8[1] === 0xBB && uint8[2] === 0xBF) {
    uint8 = uint8.subarray(3);
  } // http://stackoverflow.com/a/13691499


  var utf8 = stringFromCharCode(uint8); // This converts each character in the string to an escape sequence.  If the
  // character is in the ASCII range, it is not converted; otherwise it is
  // converted to a URI escape sequence.
  // Example: "\x67\x35\xe3\x82\xac" -> "g#%E3%82%AC"
  // TODO "escape" is deprecated, provide a ponyfill?

  var escaped = escape(utf8); // Decode the escaped sequence.  This will interpret UTF-8 sequences into the
  // correct character.
  // Example: "g#%E3%82%AC" -> "g#€"

  return decodeURIComponent(escaped);
}

/***/ }),
/* 118 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getCueBlocks; });
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(62);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */

function getCueBlocks(linified, headerOffset) {
  var cueBlocks = [];

  for (var i = headerOffset; i < linified.length; i++) {
    if (Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* isStartOfCueBlock */ "c"])(linified, i)) {
      var endOfCue = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[/* findEndOfCueBlock */ "a"])(linified, i);
      cueBlocks.push(linified.slice(i, endOfCue));
      i = endOfCue;
    } else if (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(linified[i])) {
      // continue incrementing i until either:
      //   - empty line
      //   - end
      while (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(linified[i])) {
        i++;
      }
    }
  }

  return cueBlocks;
}

/***/ }),
/* 119 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return makeCue; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Creates a cue using the best platform-specific interface available.
 *
 * @param {Number} startTime
 * @param {Number} endTime
 * @param {string} payload
 * @returns {VTTCue|TextTrackCue|null} Text track cue or null if the parameters
 * were invalid.
 */

function makeCue(startTime, endTime, payload) {
  if (_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_1__[/* VTTCue_ */ "e"] == null) {
    throw new Error("VTT cues not supported in your target");
  }

  if (startTime >= endTime) {
    // IE/Edge will throw in this case.
    // See issue #501
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: Invalid cue times: " + startTime + " - " + endTime);
    return null;
  }

  return new _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_1__[/* VTTCue_ */ "e"](startTime, endTime, payload);
}

/***/ }),
/* 120 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getParameters; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var CELL_RESOLUTION_REGEXP = /(\d+) (\d+)/;
/**
 * Returns global parameters from a TTML Document
 * @param {Element} tt - <tt> node
 * @throws Error - Throws if the spacing style is invalid.
 * @returns {Object}
 */

function getParameters(tt) {
  var parsedFrameRate = tt.getAttribute("ttp:frameRate");
  var parsedSubFrameRate = tt.getAttribute("ttp:subFramRate");
  var parsedTickRate = tt.getAttribute("ttp:tickRate");
  var parsedFrameRateMultiplier = tt.getAttribute("ttp:frameRateMultiplier");
  var parsedSpaceStyle = tt.getAttribute("xml:space");
  var parsedCellResolution = tt.getAttribute("ttp:cellResolution");
  var cellResolution = {
    columns: 32,
    rows: 15
  };

  if (parsedCellResolution !== null) {
    var extractedData = CELL_RESOLUTION_REGEXP.exec(parsedCellResolution);

    if (extractedData === null || extractedData.length < 3) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("TTML Parser: Invalid cellResolution");
    } else {
      var columns = parseInt(extractedData[1], 10);
      var rows = parseInt(extractedData[2], 10);

      if (isNaN(columns) || isNaN(rows)) {
        _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("TTML Parser: Invalid cellResolution");
      } else {
        cellResolution = {
          columns: columns,
          rows: rows
        };
      }
    }
  }

  if (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(parsedSpaceStyle) && parsedSpaceStyle !== "default" && parsedSpaceStyle !== "preserve") {
    throw new Error("Invalid spacing style");
  }

  var nbFrameRate = Number(parsedFrameRate);

  if (isNaN(nbFrameRate) || nbFrameRate <= 0) {
    nbFrameRate = 30;
  }

  var nbSubFrameRate = Number(parsedSubFrameRate);

  if (isNaN(nbSubFrameRate) || nbSubFrameRate <= 0) {
    nbSubFrameRate = 1;
  }

  var nbTickRate = Number(parsedTickRate);

  if (isNaN(nbTickRate) || nbTickRate <= 0) {
    nbTickRate = undefined;
  }

  var frameRate = nbFrameRate;
  var subFrameRate = nbSubFrameRate != null ? nbSubFrameRate : 1;
  var spaceStyle = parsedSpaceStyle !== null ? parsedSpaceStyle : "default";
  var tickRate = nbTickRate !== undefined ? nbTickRate : nbFrameRate * nbSubFrameRate;

  if (parsedFrameRateMultiplier !== null) {
    var multiplierResults = /^(\d+) (\d+)$/g.exec(parsedFrameRateMultiplier);

    if (multiplierResults !== null) {
      var numerator = Number(multiplierResults[1]);
      var denominator = Number(multiplierResults[2]);
      var multiplierNum = numerator / denominator;
      frameRate = nbFrameRate * multiplierNum;
    }
  }

  return {
    cellResolution: cellResolution,
    tickRate: tickRate,
    frameRate: frameRate,
    subFrameRate: subFrameRate,
    spaceStyle: spaceStyle
  };
}

/***/ }),
/* 121 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return resolveStylesInheritance; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _utils_array_find_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(46);
/* harmony import */ var _utils_array_includes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _utils_object_assign__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Transform all styles inheriting from other styles to the same styles but with
 * the inheritance removed (by resolving those inheritance here).
 *
 * Note that the original style object is directly mutated with every
 * inheritance they had resolved and removed.
 *
 * To make a pseudo-code analogy this would be equivalent to transform those
 * two classes:
 * ```
 * class A {
 *   methodA() {}
 * }
 *
 * class B extends A {
 *   method B() {}
 * }
 * ```
 * into the same two classes without inheritance:
 * ```
 * class A {
 *   methodA() {}
 * }
 * class B {
 *   methodA() {} // inherited from class A
 *   methodB() {}
 * }
 * ```
 *
 * Doing this here allows to simplify further treatment of those styles.
 * @param {Array.<Object>} styles
 */

function resolveStylesInheritance(styles) {
  // keep track of all the indexes parsed to avoid infinite loops
  var recursivelyBrowsedIndexes = [];

  function resolveStyleInheritance(styleElt, index) {
    recursivelyBrowsedIndexes.push(index);

    var _loop = function _loop(j) {
      var extendedStyleID = styleElt.extendsStyles[j];
      var extendedStyleIndex = Object(_utils_array_find_index__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(styles, function (x) {
        return x.id === extendedStyleID;
      });

      if (extendedStyleIndex < 0) {
        _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("TTML Parser: unknown style inheritance: " + extendedStyleID);
      } else {
        var extendedStyle = styles[extendedStyleIndex];

        if (Object(_utils_array_includes__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(recursivelyBrowsedIndexes, extendedStyleIndex)) {
          _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("TTML Parser: infinite style inheritance loop avoided");
        } else {
          resolveStyleInheritance(extendedStyle, extendedStyleIndex);
        }

        styleElt.style = Object(_utils_object_assign__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])({}, extendedStyle.style, styleElt.style);
      }
    };

    for (var j = 0; j < styleElt.extendsStyles.length; j++) {
      _loop(j);
    }

    styleElt.extendsStyles.length = 0;
  }

  for (var i = 0; i < styles.length; i++) {
    resolveStyleInheritance(styles[i], i);
    recursivelyBrowsedIndexes.length = 0; // reset
  }
}

/***/ }),
/* 122 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return seekAndLoadOnMediaEvents; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(179);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(138);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(176);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(209);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(151);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(178);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(47);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(143);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(123);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(144);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(145);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(0);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Emit once a "can-play" message as soon as the clock$ anounce that the content
 * can begin to be played.
 *
 * Warn you if the metadata is not yet loaded metadata by emitting a
 * "not-loaded-metadata" message first.
 * @param {Observable} clock$
 * @returns {Observable}
 */

function canPlay(clock$, mediaElement, isDirectfile) {
  var isLoaded$ = clock$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* filter */ "a"])(function (tick) {
    var seeking = tick.seeking,
        stalled = tick.stalled,
        readyState = tick.readyState,
        currentRange = tick.currentRange;

    if (seeking || stalled !== null) {
      return false;
    }

    if (!Object(_compat__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"])(isDirectfile, mediaElement.hasAttribute("playsinline"))) {
      return readyState >= 1 && mediaElement.duration > 0;
    }

    if (readyState >= 4 || readyState === 3 && currentRange !== null) {
      return Object(_compat__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"])() ? mediaElement.duration > 0 : true;
    }

    return false;
  }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[/* take */ "a"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* mapTo */ "a"])("can-play"));

  if (Object(_compat__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"])() && mediaElement.duration === 0) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* concat */ "a"])(Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])("not-loaded-metadata"), isLoaded$);
  }

  return isLoaded$;
}
/**
 * Try to play content then handle autoplay errors.
 * @param {HTMLMediaElement} - mediaElement
 * @returns {Observable}
 */


function autoPlay$(mediaElement) {
  return Object(_compat__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"])(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* mapTo */ "a"])("autoplay"), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[/* catchError */ "a"])(function (error) {
    if (error instanceof Error && error.name === "NotAllowedError") {
      // auto-play was probably prevented.
      _log__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].warn("Init: Media element can't play." + " It may be due to browser auto-play policies.");
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])("autoplay-blocked");
    } else {
      throw error;
    }
  }));
}
/**
 * Returns two Observables:
 *
 *   - seek$: when subscribed, will seek to the wanted started time as soon as
 *     it can. Emit and complete when done.
 *
 *   - load$: when subscribed, will play if and only if the `mustAutoPlay`
 *     option is set as soon as it can. Emit and complete when done.
 *     When this observable emits, it also means that the content is `loaded`
 *     and can begin to play the current content.
 *
 * @param {Object} args
 * @returns {Object}
 */


function seekAndLoadOnMediaEvents(_ref) {
  var clock$ = _ref.clock$,
      mediaElement = _ref.mediaElement,
      startTime = _ref.startTime,
      mustAutoPlay = _ref.mustAutoPlay,
      isDirectfile = _ref.isDirectfile;
  var seek$ = Object(_compat__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[/* take */ "a"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__[/* tap */ "a"])(function () {
    _log__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].info("Init: Set initial time", startTime);
    mediaElement.currentTime = typeof startTime === "function" ? startTime() : startTime;
  }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__[/* shareReplay */ "a"])({
    refCount: true
  }));
  var load$ = seek$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__[/* mergeMap */ "a"])(function () {
    return canPlay(clock$, mediaElement, isDirectfile).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__[/* tap */ "a"])(function () {
      return _log__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].info("Init: Can begin to play content");
    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__[/* mergeMap */ "a"])(function (evt) {
      if (evt === "can-play") {
        if (!mustAutoPlay) {
          return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])("loaded");
        }

        return autoPlay$(mediaElement);
      }

      return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])(evt);
    }));
  }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__[/* shareReplay */ "a"])({
    refCount: true
  }));
  return {
    seek$: seek$,
    load$: load$
  };
}

/***/ }),
/* 123 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shouldValidateMetadata; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the metadata received after a "loadedmetadata" event has
 * to be validated in the current browser (which means that we do not trust
 * this event on these browsers).
 * @returns {boolean}
 */

function shouldValidateMetadata() {
  return _browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isSamsungBrowser */ "f"];
}

/***/ }),
/* 124 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createEMEManager; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(88);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _compat___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);
/* harmony import */ var _compat___WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(146);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(93);
/* harmony import */ var _features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(11);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var onEncrypted$ = _compat___WEBPACK_IMPORTED_MODULE_3__[/* events */ "a"].onEncrypted$;
/**
 * Create EMEManager if possible (has the APIs and configuration).
 * Else, return an Observable throwing at the next encrypted event encountered.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems
 * @param {Observable<Object>} contentProtections$
 * @returns {Observable}
 */

function createEMEManager(mediaElement, keySystems, contentProtections$) {
  if (_features__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].emeManager == null) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* merge */ "a"])(onEncrypted$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* map */ "a"])(function () {
      _log__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].error("Init: Encrypted event but EME feature not activated");
      throw new _errors__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]("MEDIA_IS_ENCRYPTED_ERROR", "EME feature not activated.");
    })), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])({
      type: "eme-disabled"
    }));
  }

  if (keySystems.length === 0) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* merge */ "a"])(onEncrypted$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* map */ "a"])(function () {
      _log__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].error("Init: Ciphered media and no keySystem passed");
      throw new _errors__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]("MEDIA_IS_ENCRYPTED_ERROR", "Media is encrypted and no `keySystems` given");
    })), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])({
      type: "eme-disabled"
    }));
  }

  if (!Object(_compat___WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])()) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* merge */ "a"])(onEncrypted$(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* map */ "a"])(function () {
      _log__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].error("Init: Encrypted event but no EME API available");
      throw new _errors__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]("MEDIA_IS_ENCRYPTED_ERROR", "Encryption APIs not found.");
    })), Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* of */ "a"])({
      type: "eme-disabled"
    }));
  }

  _log__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].debug("Init: Creating EMEManager");
  return _features__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].emeManager(mediaElement, keySystems, contentProtections$);
}

/***/ }),
/* 125 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return refCount; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=refCount.js.map


/***/ }),
/* 126 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return throwOnMediaError; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(206);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Returns an observable which throws the right MediaError as soon an "error"
 * event is received through the media element.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

function throwOnMediaError(mediaElement) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* fromEvent */ "a"])(mediaElement, "error").pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__[/* mergeMap */ "a"])(function () {
    var errorCode = mediaElement.error == null ? 0 : mediaElement.error.code;

    switch (errorCode) {
      case 1:
        throw new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]("MEDIA_ERR_ABORTED", "The fetching of the associated resource was aborted " + "by the user's request.");

      case 2:
        throw new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]("MEDIA_ERR_NETWORK", "A network error occurred which prevented the media " + "from being successfully fetched");

      case 3:
        throw new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]("MEDIA_ERR_DECODE", "An error occurred while trying to decode the media " + "resource");

      case 4:
        throw new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]("MEDIA_ERR_SRC_NOT_SUPPORTED", "The media resource has been found to be unsuitable.");

      default:
        throw new _errors__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]("MEDIA_ERR_UNKNOWN", "The HTMLMediaElement errored due to an unknown reason.");
    }
  }));
}

/***/ }),
/* 127 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return updatePlaybackRate; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(175);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(149);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(136);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(151);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(0);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Manage playback speed.
 * Set playback rate set by the user, pause playback when the player appear to
 * stall and restore the speed once it appears to un-stall.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Observable} speed$ - emit speed set by the user
 * @param {Observable} clock$ - Current playback conditions
 * @param {Object} options - Contains the following properties:
 *   - pauseWhenStalled {Boolean|undefined} - true if the player
 *     stalling should lead to a pause until it un-stalls. True by default.
 * @returns {Observable}
 */

function updatePlaybackRate(mediaElement, speed$, clock$, _ref) {
  var _ref$pauseWhenStalled = _ref.pauseWhenStalled,
      pauseWhenStalled = _ref$pauseWhenStalled === void 0 ? true : _ref$pauseWhenStalled;
  var forcePause$;

  if (!pauseWhenStalled) {
    forcePause$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* of */ "a"])(false);
  } else {
    forcePause$ = clock$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* map */ "a"])(function (timing) {
      return timing.stalled !== null;
    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[/* startWith */ "a"])(false), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* distinctUntilChanged */ "a"])());
  }

  return forcePause$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[/* switchMap */ "a"])(function (shouldForcePause) {
    if (shouldForcePause) {
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* defer */ "a"])(function () {
        _log__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].info("Init: Pause playback to build buffer");
        mediaElement.playbackRate = 0;
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* of */ "a"])(0);
      });
    }

    return speed$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__[/* tap */ "a"])(function (speed) {
      _log__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].info("Init: Resume playback speed", speed);
      mediaElement.playbackRate = speed;
    }));
  }));
}

/***/ }),
/* 128 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getStalledEvents; });
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(181);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(149);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Receive "stalling" events from the clock, try to get out of it, and re-emit
 * them for the player if the stalling status changed.
 * @param {Observable} clock$
 * @returns {Observable}
 */

function getStalledEvents(clock$) {
  return clock$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_0__[/* share */ "a"])(), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__[/* map */ "a"])(function (tick) {
    return tick.stalled;
  }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* distinctUntilChanged */ "a"])(function (wasStalled, isStalled) {
    return wasStalled === null && isStalled === null || wasStalled !== null && isStalled !== null && wasStalled.reason === isStalled.reason;
  }));
}

/***/ }),
/* 129 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isEMEReadyEvent; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the received EME-related event indicate that we can begin to
 * load the content.
 * @param {Object} emeEvent
 * @returns {Boolean}
 */
function isEMEReadyEvent(emeEvent) {
  return emeEvent.type === "eme-disabled" || emeEvent.type === "attached-media-keys" || emeEvent.type === "created-media-keys" && emeEvent.value.keySystemOptions.disableMediaKeysAttachmentLock === true;
}

/***/ }),
/* 130 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ subscribeTo; });

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
var subscribeToArray = __webpack_require__(102);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/hostReportError.js
var hostReportError = __webpack_require__(64);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js
/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */

var subscribeToPromise = function (promise) {
    return function (subscriber) {
        promise.then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, hostReportError["a" /* hostReportError */]);
        return subscriber;
    };
};
//# sourceMappingURL=subscribeToPromise.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/iterator.js
var symbol_iterator = __webpack_require__(69);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

var subscribeToIterable = function (iterable) {
    return function (subscriber) {
        var iterator = iterable[symbol_iterator["a" /* iterator */]]();
        do {
            var item = iterator.next();
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) {
                break;
            }
        } while (true);
        if (typeof iterator.return === 'function') {
            subscriber.add(function () {
                if (iterator.return) {
                    iterator.return();
                }
            });
        }
        return subscriber;
    };
};
//# sourceMappingURL=subscribeToIterable.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
var observable = __webpack_require__(54);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

var subscribeToObservable = function (obj) {
    return function (subscriber) {
        var obs = obj[observable["a" /* observable */]]();
        if (typeof obs.subscribe !== 'function') {
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        }
        else {
            return obs.subscribe(subscriber);
        }
    };
};
//# sourceMappingURL=subscribeToObservable.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArrayLike.js
var isArrayLike = __webpack_require__(101);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isPromise.js
var isPromise = __webpack_require__(103);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isObject.js
var isObject = __webpack_require__(98);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js
/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */









var subscribeTo = function (result) {
    if (!!result && typeof result[observable["a" /* observable */]] === 'function') {
        return subscribeToObservable(result);
    }
    else if (Object(isArrayLike["a" /* isArrayLike */])(result)) {
        return Object(subscribeToArray["a" /* subscribeToArray */])(result);
    }
    else if (Object(isPromise["a" /* isPromise */])(result)) {
        return subscribeToPromise(result);
    }
    else if (!!result && typeof result[symbol_iterator["a" /* iterator */]] === 'function') {
        return subscribeToIterable(result);
    }
    else {
        var value = Object(isObject["a" /* isObject */])(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};
//# sourceMappingURL=subscribeTo.js.map


/***/ }),
/* 131 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ getCueBlocks; });

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/parsers/texttracks/srt/find_end_of_cue_block.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the first line that is not apart of the given cue block.
 * The index given can be anywhere in a known cue block.
 *
 * This function is extra-resilient due to observed real-life malformed
 * subtitles.
 * Basically, it allows some deviation from the specification as long as the
 * intent is pretty clear.
 * @param {Array<string>} linified - Whole srt. Line by line.
 * @param {number} startIndex - Index in `linified` of the first line within the
 * block.
 * @returns {number}
 */

function findEndOfCueBlock(linified, startIndex) {
  var firstEmptyLineIndex = startIndex + 1; // continue incrementing i until either:
  //   - an empty line
  //   - the end

  while (Object(is_non_empty_string["a" /* default */])(linified[firstEmptyLineIndex])) {
    firstEmptyLineIndex++;
  }

  return firstEmptyLineIndex;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/srt/get_cue_blocks.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get cue blocks from a srt file.
 * @param {Array.<string>} linified - Whole srt file. Each new element in this
 * array is a new line.
 * @returns {Array.<Array.<string>>}
 */

function getCueBlocks(linified) {
  var cueBlocks = [];

  for (var i = 0; i < linified.length; i++) {
    if (Object(is_non_empty_string["a" /* default */])(linified[i])) {
      var endOfCue = findEndOfCueBlock(linified, i);
      var cueBlockCandidate = linified.slice(i, endOfCue);

      if (cueBlockCandidate.length > 0) {
        if (cueBlockCandidate.length === 1) {
          if (cueBlockCandidate[0].indexOf("-->") >= 0) {
            cueBlocks.push(cueBlockCandidate);
          }
        } else {
          if (cueBlockCandidate[1].indexOf("-->") >= 0 || cueBlockCandidate[0].indexOf("-->") >= 0) {
            cueBlocks.push(cueBlockCandidate);
          }
        }
      }

      i = endOfCue;
    }
  }

  return cueBlocks;
}

/***/ }),
/* 132 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ parseCueBlock; });

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/parsers/texttracks/srt/parse_timestamp.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a single srt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */

function parseTimestamp(timestampString) {
  var splittedTS = timestampString.split(":");

  if (Object(is_non_empty_string["a" /* default */])(splittedTS[2])) {
    var hours = parseInt(splittedTS[0], 10);
    var minutes = parseInt(splittedTS[1], 10);
    var seconds = parseFloat(splittedTS[2].replace(",", "."));

    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
      return undefined;
    }

    return hours * 60 * 60 + minutes * 60 + seconds;
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/srt/parse_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */

function parseCueBlock(cueLines, timeOffset) {
  if (cueLines.length === 0) {
    return null;
  }

  var startTimeString;
  var endTimeString;
  var payload = []; // normally in srt, the timing is at second position.
  // We still authorize to put it in the first position for resilience

  if (Object(is_non_empty_string["a" /* default */])(cueLines[1]) && cueLines[1].indexOf("-->") !== -1) {
    var _cueLines$1$split$map = cueLines[1].split("-->").map(function (s) {
      return s.trim();
    });

    startTimeString = _cueLines$1$split$map[0];
    endTimeString = _cueLines$1$split$map[1];
    payload = cueLines.slice(2, cueLines.length);
  }

  if (!Object(is_non_empty_string["a" /* default */])(startTimeString) || !Object(is_non_empty_string["a" /* default */])(endTimeString)) {
    // Try to see if we find them in the first position
    var _cueLines$0$split$map = cueLines[0].split("-->").map(function (s) {
      return s.trim();
    });

    startTimeString = _cueLines$0$split$map[0];
    endTimeString = _cueLines$0$split$map[1];
    payload = cueLines.slice(1, cueLines.length);
  }

  if (!Object(is_non_empty_string["a" /* default */])(startTimeString) || !Object(is_non_empty_string["a" /* default */])(endTimeString)) {
    // if the time is still not found, exit
    return null;
  }

  var start = parseTimestamp(startTimeString);
  var end = parseTimestamp(endTimeString);

  if (start === undefined || end === undefined) {
    return null;
  }

  return {
    start: start + timeOffset,
    end: end + timeOffset,
    payload: payload
  };
}

/***/ }),
/* 133 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ parseCueBlock; });

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parse_timestamp.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a single webvtt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */

function parseTimestamp(timestampString) {
  var splittedTS = timestampString.split(":").reverse();

  if (Object(is_non_empty_string["a" /* default */])(splittedTS[2]) || Object(is_non_empty_string["a" /* default */])(splittedTS[1])) {
    var hours = Object(is_non_empty_string["a" /* default */])(splittedTS[2]) ? parseInt(splittedTS[2], 10) : 0;
    var minutes = parseInt(splittedTS[1], 10);
    var seconds = parseFloat(splittedTS[0].replace(",", "."));

    if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
      return undefined;
    }

    return hours * 60 * 60 + minutes * 60 + seconds;
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse the settings part of a cue, into key-value object.
 * @param {string} settingsString
 * @returns {Object}
 */

function parseSettings(settingsString) {
  var splittedSettings = settingsString.split(/ |\t/);
  return splittedSettings.reduce(function (acc, setting) {
    var splittedSetting = setting.split(":");

    if (splittedSetting.length === 2) {
      acc[splittedSetting[0]] = splittedSetting[1];
    }

    return acc;
  }, {});
}
/**
 * Parse the line containing the timestamp and settings in a cue.
 * The returned object has the following properties:
 *   - start {Number}: start of the cue, in seconds
 *   - end {Number}: end of the cue, in seconds
 *   - settings {Object}: settings for the cue as a key-value object.
 * @param {string} timeString
 * @returns {Object|null}
 */


function parseTimeAndSettings(timeString) {
  // RegExp for the timestamps + settings line.
  // Capture groups:
  //   1 -> start timestamp
  //   2 -> end timestamp
  //   3 - settings
  var lineRegex = /^([\d:.]+)[ |\t]+-->[ |\t]+([\d:.]+)[ |\t]*(.*)$/;
  var matches = timeString.match(lineRegex);

  if (matches === null) {
    return null;
  }

  var start = parseTimestamp(matches[1]);
  var end = parseTimestamp(matches[2]);

  if (start == null || end == null) {
    return null;
  }

  var settings = parseSettings(matches[3]);
  return {
    start: start,
    end: end,
    settings: settings
  };
}
/**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - header {string|undefined}: The optional cue identifier
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */


function parseCueBlock(cueLines, timeOffset) {
  var timingRegexp = /-->/;
  var timeString;
  var payload;
  var header;

  if (!timingRegexp.test(cueLines[0])) {
    if (!timingRegexp.test(cueLines[1])) {
      // not a cue
      return null;
    }

    header = cueLines[0];
    timeString = cueLines[1];
    payload = cueLines.slice(2, cueLines.length);
  } else {
    timeString = cueLines[0];
    payload = cueLines.slice(1, cueLines.length);
  }

  var timeAndSettings = parseTimeAndSettings(timeString);

  if (timeAndSettings === null) {
    return null;
  }

  var start = timeAndSettings.start,
      end = timeAndSettings.end,
      settings = timeAndSettings.settings;
  return {
    start: start + timeOffset,
    end: end + timeOffset,
    settings: settings,
    payload: payload,
    header: header
  };
}

/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ getTimeDelimiters; });

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
var regexps = __webpack_require__(15);

// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/time_parsing.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parses a TTML time into seconds.
 * @param {string} text
 * @param {Object} ttParams
 * @returns {Number|undefined}
 */

function parseTime(text, ttParams) {
  if (regexps["h" /* REGXP_TIME_COLON_FRAMES */].test(text)) {
    return parseColonTimeWithFrames(ttParams, text);
  } else if (regexps["g" /* REGXP_TIME_COLON */].test(text)) {
    return parseTimeFromRegExp(regexps["g" /* REGXP_TIME_COLON */], text);
  } else if (regexps["i" /* REGXP_TIME_COLON_MS */].test(text)) {
    return parseTimeFromRegExp(regexps["i" /* REGXP_TIME_COLON_MS */], text);
  } else if (regexps["j" /* REGXP_TIME_FRAMES */].test(text)) {
    return parseFramesTime(ttParams, text);
  } else if (regexps["l" /* REGXP_TIME_TICK */].test(text)) {
    return parseTickTime(ttParams, text);
  } else if (regexps["k" /* REGXP_TIME_HMS */].test(text)) {
    return parseTimeFromRegExp(regexps["k" /* REGXP_TIME_HMS */], text);
  }
}
/**
 * Parses a TTML time in frame format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */


function parseFramesTime(ttParams, text) {
  // 75f or 75.5f
  // (We cast as we're sure the regexp is respected here)
  var results = regexps["j" /* REGXP_TIME_FRAMES */].exec(text);
  var frames = Number(results[1]);
  return frames / ttParams.frameRate;
}
/**
 * Parses a TTML time in tick format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */


function parseTickTime(ttParams, text) {
  // 50t or 50.5t
  // (We cast as we're sure the regexp is respected here)
  var results = regexps["l" /* REGXP_TIME_TICK */].exec(text);
  var ticks = Number(results[1]);
  return ticks / ttParams.tickRate;
}
/**
 * Parses a TTML colon formatted time containing frames
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */


function parseColonTimeWithFrames(ttParams, text) {
  // 01:02:43:07 ("07" is frames) or 01:02:43:07.1 (subframes)
  // (We cast as we're sure the regexp is respected here)
  var results = regexps["h" /* REGXP_TIME_COLON_FRAMES */].exec(text);
  var hours = Number(results[1]);
  var minutes = Number(results[2]);
  var seconds = Number(results[3]);
  var frames = Number(results[4]);
  var subframes = Number(results[5]);

  if (isNaN(subframes)) {
    subframes = 0;
  }

  frames += subframes / ttParams.subFrameRate;
  seconds += frames / ttParams.frameRate;
  return seconds + minutes * 60 + hours * 3600;
}
/**
 * Parses a TTML time with a given regex. Expects regex to be some
 * sort of a time-matcher to match hours, minutes, seconds and milliseconds
 *
 * @param {RegExp} regex
 * @param {string} text
 * @returns {number|null}
 */


function parseTimeFromRegExp(regex, text) {
  var results = regex.exec(text);

  if (results === null || results[0] === "") {
    return null;
  } // This capture is optional, but will still be in the array as undefined,
  // default to 0.


  var hours = Number(results[1]);

  if (isNaN(hours)) {
    hours = 0;
  }

  var minutes = Number(results[2]);

  if (isNaN(minutes)) {
    minutes = 0;
  }

  var seconds = Number(results[3]);

  if (isNaN(seconds)) {
    seconds = 0;
  }

  var milliseconds = Number(results[4]);

  if (isNaN(milliseconds)) {
    milliseconds = 0;
  }

  return milliseconds / 1000 + seconds + minutes * 60 + hours * 3600;
}

/* harmony default export */ var time_parsing = (parseTime);
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get start and end time of an element.
 * @param {Element} element
 * @param {Object} ttParams
 * @returns {Object}
 */

function getTimeDelimiters(element, ttParams) {
  var beginAttr = element.getAttribute("begin");
  var durationAttr = element.getAttribute("dur");
  var endAttr = element.getAttribute("end");
  var start = Object(is_non_empty_string["a" /* default */])(beginAttr) ? time_parsing(beginAttr, ttParams) : null;
  var duration = Object(is_non_empty_string["a" /* default */])(durationAttr) ? time_parsing(durationAttr, ttParams) : null;
  var parsedEnd = Object(is_non_empty_string["a" /* default */])(endAttr) ? time_parsing(endAttr, ttParams) : null;

  if (start == null || parsedEnd == null && duration == null) {
    throw new Error("Invalid text cue");
  } // Huh? Is TypeScript that dumb here?


  var end = parsedEnd == null ? start + duration : parsedEnd;
  return {
    start: start,
    end: end
  };
}

/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return concat; });
/* harmony import */ var _of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var _operators_concatAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(169);
/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */


function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return Object(_operators_concatAll__WEBPACK_IMPORTED_MODULE_1__[/* concatAll */ "a"])()(_of__WEBPACK_IMPORTED_MODULE_0__[/* of */ "a"].apply(void 0, observables));
}
//# sourceMappingURL=concat.js.map


/***/ }),
/* 136 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return switchMap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(63);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */






function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return Object(_observable_from__WEBPACK_IMPORTED_MODULE_5__[/* from */ "a"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_4__[/* map */ "a"])(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
var SwitchMapOperator = /*@__PURE__*/ (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__[/* InnerSubscriber */ "a"](this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__[/* subscribeToResult */ "a"])(this, result, value, index, innerSubscriber);
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__[/* OuterSubscriber */ "a"]));
//# sourceMappingURL=switchMap.js.map


/***/ }),
/* 137 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getTRAF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getMDAT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getMDIA; });
/* harmony import */ var _get_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(78);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns TRAF Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */

function getTRAF(buffer) {
  var moof = Object(_get_box__WEBPACK_IMPORTED_MODULE_0__[/* getBoxContent */ "b"])(buffer, 0x6D6F6F66
  /* moof */
  );

  if (moof === null) {
    return null;
  }

  return Object(_get_box__WEBPACK_IMPORTED_MODULE_0__[/* getBoxContent */ "b"])(moof, 0x74726166
  /* traf */
  );
}
/**
 * Returns MDAT Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */


function getMDAT(buf) {
  return Object(_get_box__WEBPACK_IMPORTED_MODULE_0__[/* getBoxContent */ "b"])(buf, 0x6D646174
  /* "mdat" */
  );
}
/**
 * Returns MDIA Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */


function getMDIA(buf) {
  var moov = Object(_get_box__WEBPACK_IMPORTED_MODULE_0__[/* getBoxContent */ "b"])(buf, 0x6D6F6F76
  /* moov */
  );

  if (moov === null) {
    return null;
  }

  var trak = Object(_get_box__WEBPACK_IMPORTED_MODULE_0__[/* getBoxContent */ "b"])(moov, 0x7472616B
  /* "trak" */
  );

  if (trak === null) {
    return null;
  }

  return Object(_get_box__WEBPACK_IMPORTED_MODULE_0__[/* getBoxContent */ "b"])(trak, 0x6D646961
  /* "mdia" */
  );
}



/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return take; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(106);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function take(count) {
    return function (source) {
        if (count === 0) {
            return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_3__[/* empty */ "b"])();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
var TakeOperator = /*@__PURE__*/ (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_2__[/* ArgumentOutOfRangeError */ "a"];
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=take.js.map


/***/ }),
/* 139 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RequestError; });
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Errors linked to the XHR implentation done in the RxPlayer.
 *
 * @class RequestError
 * @extends Error
 */
var RequestError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(RequestError, _Error);

  /**
   * @param {XMLHttpRequest} xhr
   * @param {string} url
   * @param {string} type
   */
  function RequestError(url, status, type, xhr) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), RequestError.prototype);
    _this.name = "RequestError";
    _this.url = url;
    _this.xhr = xhr;
    _this.status = status;
    _this.type = type;
    _this.message = type;
    return _this;
  }

  return RequestError;
}( /*#__PURE__*/_wrapNativeSuper(Error));



/***/ }),
/* 140 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "clearEMESession", function() { return /* reexport */ clear_eme_session["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "disposeEME", function() { return /* reexport */ dispose_eme["a" /* default */]; });
__webpack_require__.d(__webpack_exports__, "getCurrentKeySystem", function() { return /* reexport */ get_current_key_system["a" /* default */]; });

// EXTERNAL MODULE: ./src/core/eme/clear_eme_session.ts
var clear_eme_session = __webpack_require__(154);

// EXTERNAL MODULE: ./src/core/eme/dispose_eme.ts
var dispose_eme = __webpack_require__(155);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js
var empty = __webpack_require__(56);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(88);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/throwError.js
var throwError = __webpack_require__(65);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(135);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(178);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(179);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/take.js
var take = __webpack_require__(138);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(151);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(47);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/catchError.js
var catchError = __webpack_require__(209);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
var ignoreElements = __webpack_require__(150);

// EXTERNAL MODULE: ./src/compat/index.ts + 1 modules
var compat = __webpack_require__(8);

// EXTERNAL MODULE: ./src/compat/eme/get_init_data.ts
var get_init_data = __webpack_require__(218);

// EXTERNAL MODULE: ./src/compat/eme/generate_key_request.ts
var generate_key_request = __webpack_require__(219);

// EXTERNAL MODULE: ./src/errors/encrypted_media_error.ts
var encrypted_media_error = __webpack_require__(93);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(79);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(3);

// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(10);

// EXTERNAL MODULE: ./src/utils/cast_to_observable.ts
var cast_to_observable = __webpack_require__(23);

// CONCATENATED MODULE: ./src/core/eme/utils/is_session_usable.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * If all key statuses attached to session are valid (either not
 * "expired" or "internal-error"), return true.
 * If not, return false.
 * @param {Uint8Array} initData
 * @param {MediaKeySession} loadedSession
 * @returns {MediaKeySession}
 */

function isSessionUsable(loadedSession) {
  if (loadedSession.sessionId === "") {
    return false;
  }

  var keyStatusesMap = loadedSession.keyStatuses;
  var keyStatuses = [];
  keyStatusesMap.forEach(function (keyStatus) {
    keyStatuses.push(keyStatus);
  });

  if (keyStatuses.length > 0 && !Object(array_includes["a" /* default */])(keyStatuses, "expired") && !Object(array_includes["a" /* default */])(keyStatuses, "internal-error")) {
    log["a" /* default */].debug("EME: Reuse loaded session", loadedSession.sessionId);
    return true;
  }

  return false;
}
// CONCATENATED MODULE: ./src/core/eme/create_session.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * If session creating fails, retry once session creation/loading.
 * Emit true, if it has succeeded to load, false if there is no data for the
 * given sessionId.
 * @param {string} sessionId
 * @param {MediaKeySession} session
 * @returns {Observable}
 */

function loadPersistentSession(sessionId, session) {
  return Object(defer["a" /* defer */])(function () {
    log["a" /* default */].debug("EME: Load persisted session", sessionId);
    return Object(cast_to_observable["a" /* default */])(session.load(sessionId));
  });
}
/**
 * Create a new Session on the given MediaKeys, corresponding to the given
 * initializationData.
 * If session creating fails, remove the oldest MediaKeySession loaded and
 * retry.
 *
 * /!\ This only creates new sessions.
 * It will fail if sessionsStore already has a MediaKeySession with
 * the given initializationData.
 * @param {Uint8Array} initData
 * @param {string|undefined} initDataType
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */


function create_session_createSession(initData, initDataType, mediaKeysInfos) {
  return Object(defer["a" /* defer */])(function () {
    var keySystemOptions = mediaKeysInfos.keySystemOptions,
        mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess,
        sessionsStore = mediaKeysInfos.sessionsStore,
        sessionStorage = mediaKeysInfos.sessionStorage;
    var mksConfig = mediaKeySystemAccess.getConfiguration();
    var sessionTypes = mksConfig.sessionTypes;
    var hasPersistence = sessionTypes != null && Object(array_includes["a" /* default */])(sessionTypes, "persistent-license");
    var sessionType = hasPersistence && sessionStorage != null && keySystemOptions.persistentLicense === true ? "persistent-license" : "temporary";
    log["a" /* default */].debug("EME: Create a new " + sessionType + " session");
    var session = sessionsStore.createSession(initData, initDataType, sessionType); // Re-check for Dumb typescript. Equivalent to `sessionType === "temporary"`.

    if (!hasPersistence || sessionStorage == null || keySystemOptions.persistentLicense !== true) {
      return Object(of["a" /* of */])({
        type: "created-session",
        value: {
          mediaKeySession: session,
          sessionType: sessionType
        }
      });
    }

    var storedEntry = sessionStorage.get(initData, initDataType);

    if (storedEntry === null) {
      return Object(of["a" /* of */])({
        type: "created-session",
        value: {
          mediaKeySession: session,
          sessionType: sessionType
        }
      });
    }
    /**
     * Helper function to close and restart the current persistent session
     * considered, and re-create it from scratch.
     * @returns {Observable}
     */


    var recreatePersistentSession = function recreatePersistentSession() {
      log["a" /* default */].info("EME: Removing previous persistent session.");

      if (sessionStorage.get(initData, initDataType) !== null) {
        sessionStorage["delete"](initData, initDataType);
      }

      return sessionsStore.deleteAndCloseSession(session).pipe(Object(map["a" /* map */])(function () {
        var newSession = sessionsStore.createSession(initData, initDataType, sessionType);
        return {
          type: "created-session",
          value: {
            mediaKeySession: newSession,
            sessionType: sessionType
          }
        };
      }));
    };

    return loadPersistentSession(storedEntry.sessionId, session).pipe(Object(mergeMap["a" /* mergeMap */])(function (hasLoadedSession) {
      if (!hasLoadedSession) {
        log["a" /* default */].warn("EME: No data stored for the loaded session");
        sessionStorage["delete"](initData, initDataType);
        return Object(of["a" /* of */])({
          type: "created-session",
          value: {
            mediaKeySession: session,
            sessionType: sessionType
          }
        });
      }

      if (hasLoadedSession && isSessionUsable(session)) {
        sessionStorage.add(initData, initDataType, session);
        log["a" /* default */].info("EME: Succeeded to load persistent session.");
        return Object(of["a" /* of */])({
          type: "loaded-persistent-session",
          value: {
            mediaKeySession: session,
            sessionType: sessionType
          }
        });
      } // Unusable persistent session: recreate a new session from scratch.


      log["a" /* default */].warn("EME: Previous persistent session not usable anymore.");
      return recreatePersistentSession();
    }), Object(catchError["a" /* catchError */])(function () {
      log["a" /* default */].warn("EME: Unable to load persistent session.");
      return recreatePersistentSession();
    }));
  });
}
// CONCATENATED MODULE: ./src/core/eme/get_session.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var MAX_SESSIONS = config["a" /* default */].EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS;
/**
 * Handle MediaEncryptedEvents sent by a HTMLMediaElement:
 * Either create a session, recuperate a previous session and returns it or load
 * a persistent session.
 * @param {Event} encryptedEvent
 * @param {Object} handledInitData
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */

function getSession(encryptedEvent, mediaKeysInfos) {
  return Object(defer["a" /* defer */])(function () {
    var initDataType = encryptedEvent.type,
        initData = encryptedEvent.data; // possible previous loaded session with the same initialization data

    var previousLoadedSession = null;
    var sessionsStore = mediaKeysInfos.sessionsStore;
    var entry = sessionsStore.get(initData, initDataType);

    if (entry != null) {
      previousLoadedSession = entry.session;

      if (isSessionUsable(previousLoadedSession)) {
        log["a" /* default */].debug("EME: Reuse loaded session", previousLoadedSession.sessionId);
        return Object(of["a" /* of */])({
          type: "loaded-open-session",
          value: {
            mediaKeySession: previousLoadedSession,
            sessionType: entry.sessionType,
            initData: initData,
            initDataType: initDataType
          }
        });
      } else if (mediaKeysInfos.sessionStorage != null) {
        mediaKeysInfos.sessionStorage["delete"](new Uint8Array(initData), initDataType);
      }
    }

    return (previousLoadedSession != null ? sessionsStore.deleteAndCloseSession(previousLoadedSession) : Object(of["a" /* of */])(null)).pipe(Object(mergeMap["a" /* mergeMap */])(function () {
      var cleaningOldSessions$ = [];
      var entries = sessionsStore.getAll().slice();

      if (MAX_SESSIONS > 0 && MAX_SESSIONS <= entries.length) {
        for (var i = 0; i < MAX_SESSIONS - entries.length + 1; i++) {
          cleaningOldSessions$.push(sessionsStore.deleteAndCloseSession(entries[i].session));
        }
      }

      return Object(concat["a" /* concat */])(merge["a" /* merge */].apply(void 0, cleaningOldSessions$).pipe(Object(ignoreElements["a" /* ignoreElements */])()), create_session_createSession(initData, initDataType, mediaKeysInfos).pipe(Object(map["a" /* map */])(function (evt) {
        return {
          type: evt.type,
          value: {
            mediaKeySession: evt.value.mediaKeySession,
            sessionType: evt.value.sessionType,
            initData: initData,
            initDataType: initDataType
          }
        };
      })));
    }));
  });
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(176);

// EXTERNAL MODULE: ./src/compat/eme/set_media_keys.ts
var set_media_keys = __webpack_require__(210);

// EXTERNAL MODULE: ./src/core/eme/media_keys_infos_store.ts
var media_keys_infos_store = __webpack_require__(40);

// CONCATENATED MODULE: ./src/core/eme/attach_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Set the MediaKeys object on the HTMLMediaElement if it is not already on the
 * element.
 * If a MediaKeys was already set on it, dispose of it before setting the new
 * one.
 *
 * /!\ Mutates heavily MediaKeysInfosStore
 * @param {Object} mediaKeysInfos
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

function attachMediaKeys(mediaKeysInfos, mediaElement) {
  return Object(defer["a" /* defer */])(function () {
    var keySystemOptions = mediaKeysInfos.keySystemOptions,
        mediaKeySystemAccess = mediaKeysInfos.mediaKeySystemAccess,
        mediaKeys = mediaKeysInfos.mediaKeys,
        sessionsStore = mediaKeysInfos.sessionsStore;
    var previousState = media_keys_infos_store["a" /* default */].getState(mediaElement);
    media_keys_infos_store["a" /* default */].setState(mediaElement, {
      keySystemOptions: keySystemOptions,
      mediaKeySystemAccess: mediaKeySystemAccess,
      mediaKeys: mediaKeys,
      sessionsStore: sessionsStore
    });
    return (previousState != null && previousState.sessionsStore !== sessionsStore ? previousState.sessionsStore.closeAllSessions() : Object(of["a" /* of */])(null)).pipe(Object(mergeMap["a" /* mergeMap */])(function () {
      if (mediaElement.mediaKeys === mediaKeys) {
        return Object(of["a" /* of */])(null);
      }

      log["a" /* default */].debug("EME: Setting MediaKeys");
      return Object(set_media_keys["a" /* default */])(mediaElement, mediaKeys);
    }));
  });
}
// EXTERNAL MODULE: ./src/utils/rx-try_catch.ts
var rx_try_catch = __webpack_require__(37);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./src/compat/should_renew_media_keys.ts
var should_renew_media_keys = __webpack_require__(153);

// EXTERNAL MODULE: ./src/compat/eme/custom_media_keys.ts
var custom_media_keys = __webpack_require__(147);

// EXTERNAL MODULE: ./src/utils/flat_map.ts
var flat_map = __webpack_require__(91);

// CONCATENATED MODULE: ./src/core/eme/find_key_system.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








var EME_DEFAULT_WIDEVINE_ROBUSTNESSES = config["a" /* default */].EME_DEFAULT_WIDEVINE_ROBUSTNESSES,
    EME_KEY_SYSTEMS = config["a" /* default */].EME_KEY_SYSTEMS;
/**
 * @param {Array.<Object>} keySystems
 * @param {MediaKeySystemAccess} currentKeySystemAccess
 * @param {Object} currentKeySystemOptions
 * @returns {null|Object}
 */

function checkCachedMediaKeySystemAccess(keySystems, currentKeySystemAccess, currentKeySystemOptions) {
  var mksConfiguration = currentKeySystemAccess.getConfiguration();

  if (Object(should_renew_media_keys["a" /* default */])() || mksConfiguration == null) {
    return null;
  }

  var firstCompatibleOption = keySystems.filter(function (ks) {
    // TODO Do it with MediaKeySystemAccess.prototype.keySystem instead
    if (ks.type !== currentKeySystemOptions.type) {
      return false;
    }

    if (ks.persistentLicense === true && mksConfiguration.persistentState !== "required") {
      return false;
    }

    if (ks.distinctiveIdentifierRequired === true && mksConfiguration.distinctiveIdentifier !== "required") {
      return false;
    }

    return true;
  })[0];

  if (firstCompatibleOption != null) {
    return {
      keySystemOptions: firstCompatibleOption,
      keySystemAccess: currentKeySystemAccess
    };
  }

  return null;
}
/**
 * Find key system canonical name from key system type.
 * @param {string} ksType - Obtained via inversion
 * @returns {string|undefined} - Either the canonical name, or undefined.
 */


function findKeySystemCanonicalName(ksType) {
  for (var _i = 0, _Object$keys = Object.keys(EME_KEY_SYSTEMS); _i < _Object$keys.length; _i++) {
    var ksName = _Object$keys[_i];

    if (Object(array_includes["a" /* default */])(EME_KEY_SYSTEMS[ksName], ksType)) {
      return ksName;
    }
  }

  return undefined;
}
/**
 * Build configuration for the requestMediaKeySystemAccess EME API, based
 * on the current keySystem object.
 * @param {string} [ksName] - Generic name for the key system. e.g. "clearkey",
 * "widevine", "playready". Can be used to make exceptions depending on it.
 * @param {Object} keySystem
 * @returns {Array.<Object>} - Configuration to give to the
 * requestMediaKeySystemAccess API.
 */


function buildKeySystemConfigurations(ksName, keySystem) {
  var sessionTypes = ["temporary"];
  var persistentState = "optional";
  var distinctiveIdentifier = "optional";

  if (keySystem.persistentLicense === true) {
    persistentState = "required";
    sessionTypes.push("persistent-license");
  }

  if (keySystem.persistentStateRequired === true) {
    persistentState = "required";
  }

  if (keySystem.distinctiveIdentifierRequired === true) {
    distinctiveIdentifier = "required";
  } // Set robustness, in order of consideration:
  //   1. the user specified its own robustnesses
  //   2. a "widevine" key system is used, in that case set the default widevine
  //      robustnesses as defined in the config
  //   3. set an undefined robustness


  var videoRobustnesses = keySystem.videoRobustnesses != null ? keySystem.videoRobustnesses : ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : [];
  var audioRobustnesses = keySystem.audioRobustnesses != null ? keySystem.audioRobustnesses : ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES : [];

  if (videoRobustnesses.length === 0) {
    videoRobustnesses.push(undefined);
  }

  if (audioRobustnesses.length === 0) {
    audioRobustnesses.push(undefined);
  } // From the W3 EME spec, we have to provide videoCapabilities and
  // audioCapabilities.
  // These capabilities must specify a codec (even though you can use a
  // completely different codec afterward).
  // It is also strongly recommended to specify the required security
  // robustness. As we do not want to forbide any security level, we specify
  // every existing security level from highest to lowest so that the best
  // security level is selected.
  // More details here:
  // https://storage.googleapis.com/wvdocs/Chrome_EME_Changes_and_Best_Practices.pdf
  // https://www.w3.org/TR/encrypted-media/#get-supported-configuration-and-consent


  var videoCapabilities = Object(flat_map["a" /* default */])(videoRobustnesses, function (robustness) {
    return [{
      contentType: "video/mp4;codecs=\"avc1.4d401e\"",
      robustness: robustness
    }, {
      contentType: "video/mp4;codecs=\"avc1.42e01e\"",
      robustness: robustness
    }, {
      contentType: "video/webm;codecs=\"vp8\"",
      robustness: robustness
    }];
  });
  var audioCapabilities = Object(flat_map["a" /* default */])(audioRobustnesses, function (robustness) {
    return [{
      contentType: "audio/mp4;codecs=\"mp4a.40.2\"",
      robustness: robustness
    }, {
      contentType: "audio/webm;codecs=opus",
      robustness: robustness
    }];
  }); // TODO Re-test with a set contentType but an undefined robustness on the
  // STBs on which this problem was found.
  //
  // add another with no {audio,video}Capabilities for some legacy browsers.
  // As of today's spec, this should return NotSupported but the first
  // candidate configuration should be good, so we should have no downside
  // doing that.
  // initDataTypes: ["cenc"],
  // videoCapabilities: undefined,
  // audioCapabilities: undefined,
  // distinctiveIdentifier,
  // persistentState,
  // sessionTypes,

  return [{
    initDataTypes: ["cenc"],
    videoCapabilities: videoCapabilities,
    audioCapabilities: audioCapabilities,
    distinctiveIdentifier: distinctiveIdentifier,
    persistentState: persistentState,
    sessionTypes: sessionTypes
  }];
}
/**
 * Try to find a compatible key system from the keySystems array given.
 *
 * Returns an Observable which, when subscribed to, will request a
 * MediaKeySystemAccess based on the various keySystems provided. This
 * Observable will:
 *   - emit the MediaKeySystemAccess and the keySystems as an object, when
 *     found. The object is under this form:
 *     {
 *       keySystemAccess {MediaKeySystemAccess}
 *       keySystem {Object}
 *     }
 *   - complete immediately after emitting.
 *   - throw if no  compatible key system has been found.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems - The keySystems you want to test.
 * @returns {Observable}
 */


function getMediaKeySystemAccess(mediaElement, keySystemsConfigs) {
  return Object(defer["a" /* defer */])(function () {
    var currentState = media_keys_infos_store["a" /* default */].getState(mediaElement);

    if (currentState != null) {
      // Fast way to find a compatible keySystem if the currently loaded
      // one as exactly the same compatibility options.
      var cachedKeySystemAccess = checkCachedMediaKeySystemAccess(keySystemsConfigs, currentState.mediaKeySystemAccess, currentState.keySystemOptions);

      if (cachedKeySystemAccess !== null) {
        log["a" /* default */].debug("EME: Found cached compatible keySystem", cachedKeySystemAccess);
        return Object(of["a" /* of */])({
          type: "reuse-media-key-system-access",
          value: {
            mediaKeySystemAccess: cachedKeySystemAccess.keySystemAccess,
            options: cachedKeySystemAccess.keySystemOptions
          }
        });
      }
    }
    /**
     * Array of set keySystems for this content.
     * Each item of this array is an object containing the following keys:
     *   - keyName {string}: keySystem canonical name (e.g. "widevine")
     *   - keyType {string}: keySystem type (e.g. "com.widevine.alpha")
     *   - keySystem {Object}: the original keySystem object
     * @type {Array.<Object>}
     */


    var keySystemsType = keySystemsConfigs.reduce(function (arr, keySystemOptions) {
      var managedRDNs = EME_KEY_SYSTEMS[keySystemOptions.type];
      var ksType;

      if (managedRDNs != null) {
        ksType = managedRDNs.map(function (keyType) {
          var keyName = keySystemOptions.type;
          return {
            keyName: keyName,
            keyType: keyType,
            keySystemOptions: keySystemOptions
          };
        });
      } else {
        var keyName = findKeySystemCanonicalName(keySystemOptions.type);
        var keyType = keySystemOptions.type;
        ksType = [{
          keyName: keyName,
          keyType: keyType,
          keySystemOptions: keySystemOptions
        }];
      }

      return arr.concat(ksType);
    }, []);
    return new Observable["a" /* Observable */](function (obs) {
      var disposed = false;
      var sub;
      /**
       * Test the key system as defined in keySystemsType[index].
       * @param {Number} index
       */

      function testKeySystem(index) {
        // completely quit the loop if unsubscribed
        if (disposed) {
          return;
        } // if we iterated over the whole keySystemsType Array, quit on error


        if (index >= keySystemsType.length) {
          obs.error(new encrypted_media_error["a" /* default */]("INCOMPATIBLE_KEYSYSTEMS", "No key system compatible with your " + "wanted configuration has been found " + "in the current browser."));
          return;
        }

        var _keySystemsType$index = keySystemsType[index],
            keyName = _keySystemsType$index.keyName,
            keyType = _keySystemsType$index.keyType,
            keySystemOptions = _keySystemsType$index.keySystemOptions;
        var keySystemConfigurations = buildKeySystemConfigurations(keyName, keySystemOptions);
        log["a" /* default */].debug("EME: Request keysystem access " + keyType + "," + (index + 1 + " of " + keySystemsType.length), keySystemConfigurations);

        if (custom_media_keys["c" /* requestMediaKeySystemAccess */] == null) {
          throw new Error("requestMediaKeySystemAccess is not " + "implemented in your browser.");
        }

        sub = Object(custom_media_keys["c" /* requestMediaKeySystemAccess */])(keyType, keySystemConfigurations).subscribe(function (keySystemAccess) {
          log["a" /* default */].info("EME: Found compatible keysystem", keyType, keySystemConfigurations);
          obs.next({
            type: "create-media-key-system-access",
            value: {
              options: keySystemOptions,
              mediaKeySystemAccess: keySystemAccess
            }
          });
          obs.complete();
        }, function () {
          log["a" /* default */].debug("EME: Rejected access to keysystem", keyType, keySystemConfigurations);
          sub = null;
          testKeySystem(index + 1);
        });
      }

      testKeySystem(0);
      return function () {
        disposed = true;

        if (sub != null) {
          sub.unsubscribe();
        }
      };
    });
  });
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/race.js
var race = __webpack_require__(216);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/timer.js
var timer = __webpack_require__(217);

// CONCATENATED MODULE: ./src/compat/eme/close_session.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Close session and returns and observable that emits when
 * the session is closed.
 * @param {MediaKeySession|Object} session
 * @returns {Observable}
 */

function closeSession$(session) {
  return Object(race["a" /* race */])(Object(cast_to_observable["a" /* default */])(session.close()), // If the session is not closed after 1000ms, try
  // to call another method on session to guess if
  // session is closed or not.
  Object(timer["a" /* timer */])(1000).pipe(Object(mergeMap["a" /* mergeMap */])(function () {
    var tryToUpdateSession$ = Object(cast_to_observable["a" /* default */])(session.update(new Uint8Array(1)));
    return tryToUpdateSession$.pipe( // Update has resolved, so we can't know if session is closed
    Object(map["a" /* map */])(function () {
      throw new Error("Compat: Couldn't know if session is " + "closed");
    }), Object(catchError["a" /* catchError */])(function (err) {
      // The caught error can tell if session is closed
      // (Chrome may throw this error)
      if (err instanceof Error && err.message === "The session is already closed.") {
        return Object(of["a" /* of */])(null);
      } // The `closed` promise may resolve, even if `close()` result has not
      // (it may happen on Firefox). Wait for it and timeout after 1 second.


      var sessionIsClosed$ = Object(cast_to_observable["a" /* default */])(session.closed);
      return Object(race["a" /* race */])(sessionIsClosed$, Object(timer["a" /* timer */])(1000).pipe(Object(map["a" /* map */])(function () {
        throw new Error("Compat: Couldn't know if session is " + "closed");
      })));
    }));
  })));
}
// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(14);

// EXTERNAL MODULE: ./src/utils/hash_buffer.ts
var hash_buffer = __webpack_require__(39);

// CONCATENATED MODULE: ./src/core/eme/utils/open_sessions_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Create and store MediaKeySessions linked to a single MediaKeys
 * instance.
 *
 * Keep track of sessionTypes and of the initialization data each
 * MediaKeySession is created for.
 * @class MediaKeySessionsStore
 */

var open_sessions_store_MediaKeySessionsStore = /*#__PURE__*/function () {
  function MediaKeySessionsStore(mediaKeys) {
    this._mediaKeys = mediaKeys;
    this._entries = [];
  }
  /**
   * @returns {Array.<Object>}
   */


  var _proto = MediaKeySessionsStore.prototype;

  _proto.getAll = function getAll() {
    return this._entries.map(function (entry) {
      return {
        session: entry.session,
        sessionType: entry.sessionType
      };
    });
  }
  /**
   * Returns an entry in this cache with the initData and initDataType given.
   * null if no such session is stored.
   *
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */
  ;

  _proto.get = function get(initData, initDataType) {
    var initDataHash = Object(hash_buffer["a" /* default */])(initData);
    var foundEntry = Object(array_find["a" /* default */])(this._entries, function (entry) {
      return entry.initData === initDataHash && entry.initDataType === initDataType;
    });

    if (foundEntry != null) {
      var session = foundEntry.session,
          sessionType = foundEntry.sessionType;
      return {
        session: session,
        sessionType: sessionType
      };
    }

    return null;
  }
  /**
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @param {string} sessionType
   * @returns {MediaKeySession}
   * @throws {EncryptedMediaError}
   */
  ;

  _proto.createSession = function createSession(initData, initDataType, sessionType) {
    var _this = this;

    if (this.get(initData, initDataType) != null) {
      throw new encrypted_media_error["a" /* default */]("MULTIPLE_SESSIONS_SAME_INIT_DATA", "This initialization data was already stored.");
    }

    var session = Object(custom_media_keys["a" /* createSession */])(this._mediaKeys, sessionType);

    var entry = {
      session: session,
      sessionType: sessionType,
      initData: Object(hash_buffer["a" /* default */])(initData),
      initDataType: initDataType
    };

    if (session.closed !== null) {
      session.closed.then(function () {
        _this._delete(session);
      })["catch"](function (e) {
        log["a" /* default */].warn("EME-MKSS: session.closed rejected: " + e);
      });
    }

    log["a" /* default */].debug("EME-MKSS: Add session", entry);

    this._entries.push(entry);

    return session;
  }
  /**
   * Close a MediaKeySession and remove its entry if it's found in the store.
   * @param {MediaKeySession} session
   * @returns {Observable}
   */
  ;

  _proto.deleteAndCloseSession = function deleteAndCloseSession(session) {
    var _this2 = this;

    return Object(defer["a" /* defer */])(function () {
      _this2._delete(session);

      log["a" /* default */].debug("EME-MKSS: Close session", session);
      return closeSession$(session).pipe(Object(catchError["a" /* catchError */])(function (err) {
        log["a" /* default */].error(err);
        return Object(of["a" /* of */])(null);
      }));
    });
  }
  /**
   * Close all sessions in this store.
   * Emit null when done
   * @returns {Observable}
   */
  ;

  _proto.closeAllSessions = function closeAllSessions() {
    var _this3 = this;

    return Object(defer["a" /* defer */])(function () {
      var previousEntries = _this3._entries;
      _this3._entries = []; // clean completely the cache first

      var disposed = previousEntries.map(function (entry) {
        return _this3.deleteAndCloseSession(entry.session);
      });
      return Object(concat["a" /* concat */])(merge["a" /* merge */].apply(void 0, disposed).pipe(Object(ignoreElements["a" /* ignoreElements */])()), Object(of["a" /* of */])(null));
    });
  }
  /**
   * Remove a MediaKeySession from the Cache, without closing it.
   * Returns the entry if found, null otherwise.
   * @param {MediaKeySession} session
   * @returns {number} - index of the session in the cache. -1 of not found.
   */
  ;

  _proto._delete = function _delete(session) {
    var entry = Object(array_find["a" /* default */])(this._entries, function (e) {
      return e.session === session;
    });

    if (entry == null) {
      return -1;
    }

    log["a" /* default */].debug("EME-MKSS: delete session", entry);

    var idx = this._entries.indexOf(entry);

    this._entries.splice(idx, 1);

    return idx;
  };

  return MediaKeySessionsStore;
}();


// EXTERNAL MODULE: ./src/utils/assert.ts
var assert = __webpack_require__(48);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/core/eme/utils/persisted_session_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






function checkStorage(storage) {
  Object(assert["a" /* assertInterface */])(storage, {
    save: "function",
    load: "function"
  }, "licenseStorage");
}
/**
 * Set representing persisted licenses. Depends on a simple local-
 * storage implementation with a `save`/`load` synchronous interface
 * to persist information on persisted sessions.
 *
 * This set is used only for a cdm/keysystem with license persistency
 * supported.
 * @class PersistedSessionsStore
 */


var persisted_session_store_PersistedSessionsStore = /*#__PURE__*/function () {
  /**
   * @param {Object} storage
   */
  function PersistedSessionsStore(storage) {
    checkStorage(storage);
    this._entries = [];
    this._storage = storage;

    try {
      this._entries = this._storage.load();

      if (!Array.isArray(this._entries)) {
        this._entries = [];
      }
    } catch (e) {
      log["a" /* default */].warn("EME-PSS: Could not get entries from license storage", e);
      this.dispose();
    }
  }
  /**
   * Retrieve entry (sessionId + initData) based on its initData.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @returns {Object|null}
   */


  var _proto = PersistedSessionsStore.prototype;

  _proto.get = function get(initData, initDataType) {
    var hash = Object(hash_buffer["a" /* default */])(initData);
    var entry = Object(array_find["a" /* default */])(this._entries, function (e) {
      return e.initData === hash && e.initDataType === initDataType;
    });
    return entry == null ? null : entry;
  }
  /**
   * Add a new entry in the storage.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   * @param {MediaKeySession} session
   */
  ;

  _proto.add = function add(initData, initDataType, session) {
    if (session == null || !Object(is_non_empty_string["a" /* default */])(session.sessionId)) {
      return;
    }

    var sessionId = session.sessionId;
    var currentEntry = this.get(initData, initDataType);

    if (currentEntry != null && currentEntry.sessionId === sessionId) {
      return;
    } else if (currentEntry != null) {
      // currentEntry has a different sessionId
      this["delete"](initData, initDataType);
    }

    log["a" /* default */].info("EME-PSS: Add new session", sessionId, session);

    this._entries.push({
      sessionId: sessionId,
      initData: Object(hash_buffer["a" /* default */])(initData),
      initDataType: initDataType
    });

    this._save();
  }
  /**
   * Delete entry (sessionId + initData) based on its initData.
   * @param {Uint8Array}  initData
   * @param {string|undefined} initDataType
   */
  ;

  _proto["delete"] = function _delete(initData, initDataType) {
    var hash = Object(hash_buffer["a" /* default */])(initData);
    var entry = Object(array_find["a" /* default */])(this._entries, function (e) {
      return e.initData === hash && e.initDataType === initDataType;
    });

    if (entry != null) {
      log["a" /* default */].warn("EME-PSS: Delete session from store", entry);

      var idx = this._entries.indexOf(entry);

      this._entries.splice(idx, 1);

      this._save();
    }
  }
  /**
   * Delete all saved entries.
   */
  ;

  _proto.dispose = function dispose() {
    this._entries = [];

    this._save();
  }
  /**
   * Use the given storage to store the current entries.
   */
  ;

  _proto._save = function _save() {
    try {
      this._storage.save(this._entries);
    } catch (e) {
      log["a" /* default */].warn("EME-PSS: Could not save licenses in localStorage");
    }
  };

  return PersistedSessionsStore;
}();


// CONCATENATED MODULE: ./src/core/eme/get_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










/**
 * @throws {EncryptedMediaError}
 * @param {Object} keySystemOptions
 * @returns {Object|null}
 */

function createSessionStorage(keySystemOptions) {
  if (keySystemOptions.persistentLicense !== true) {
    return null;
  }

  var licenseStorage = keySystemOptions.licenseStorage;

  if (licenseStorage == null) {
    throw new encrypted_media_error["a" /* default */]("INVALID_KEY_SYSTEM", "No license storage found for persistent license.");
  }

  log["a" /* default */].info("EME: Set the given license storage");
  return new persisted_session_store_PersistedSessionsStore(licenseStorage);
}
/**
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs
 * @returns {Observable}
 */


function getMediaKeysInfos(mediaElement, keySystemsConfigs) {
  return getMediaKeySystemAccess(mediaElement, keySystemsConfigs).pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
    var _evt$value = evt.value,
        options = _evt$value.options,
        mediaKeySystemAccess = _evt$value.mediaKeySystemAccess;
    var currentState = media_keys_infos_store["a" /* default */].getState(mediaElement);
    var sessionStorage = createSessionStorage(options);

    if (currentState != null && evt.type === "reuse-media-key-system-access") {
      var mediaKeys = currentState.mediaKeys,
          sessionsStore = currentState.sessionsStore;
      return Object(of["a" /* of */])({
        mediaKeys: mediaKeys,
        sessionsStore: sessionsStore,
        mediaKeySystemAccess: mediaKeySystemAccess,
        keySystemOptions: options,
        sessionStorage: sessionStorage
      });
    }

    log["a" /* default */].debug("EME: Calling createMediaKeys on the MediaKeySystemAccess");
    return Object(rx_try_catch["a" /* default */])(function () {
      return Object(cast_to_observable["a" /* default */])(mediaKeySystemAccess.createMediaKeys());
    }, undefined).pipe(Object(catchError["a" /* catchError */])(function (error) {
      var message = error instanceof Error ? error.message : "Unknown error when creating MediaKeys.";
      throw new encrypted_media_error["a" /* default */]("CREATE_MEDIA_KEYS_ERROR", message);
    }), Object(map["a" /* map */])(function (mediaKeys) {
      return {
        mediaKeys: mediaKeys,
        sessionsStore: new open_sessions_store_MediaKeySessionsStore(mediaKeys),
        mediaKeySystemAccess: mediaKeySystemAccess,
        keySystemOptions: options,
        sessionStorage: sessionStorage
      };
    }));
  }));
}
// CONCATENATED MODULE: ./src/core/eme/init_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Get media keys infos from key system configs then attach media keys to media element.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs
 * @returns {Observable}
 */

function initMediaKeys(mediaElement, keySystemsConfigs) {
  return getMediaKeysInfos(mediaElement, keySystemsConfigs).pipe(Object(mergeMap["a" /* mergeMap */])(function (mediaKeysInfos) {
    return Object(concat["a" /* concat */])(Object(of["a" /* of */])({
      type: "created-media-keys",
      value: mediaKeysInfos
    }), attachMediaKeys(mediaKeysInfos, mediaElement).pipe(Object(mapTo["a" /* mapTo */])({
      type: "attached-media-keys",
      value: mediaKeysInfos
    })));
  }));
}
// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/TimeoutError.js
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var TimeoutErrorImpl = /*@__PURE__*/ (function () {
    function TimeoutErrorImpl() {
        Error.call(this);
        this.message = 'Timeout has occurred';
        this.name = 'TimeoutError';
        return this;
    }
    TimeoutErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return TimeoutErrorImpl;
})();
var TimeoutError = TimeoutErrorImpl;
//# sourceMappingURL=TimeoutError.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/identity.js
var identity = __webpack_require__(168);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/async.js
var scheduler_async = __webpack_require__(42);

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isDate.js
var isDate = __webpack_require__(104);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/OuterSubscriber.js
var OuterSubscriber = __webpack_require__(29);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
var subscribeToResult = __webpack_require__(28);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function timeoutWith(due, withObservable, scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async["a" /* async */];
    }
    return function (source) {
        var absoluteTimeout = Object(isDate["a" /* isDate */])(due);
        var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
    };
}
var TimeoutWithOperator = /*@__PURE__*/ (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new timeoutWith_TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var timeoutWith_TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.action = null;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(Object(subscribeToResult["a" /* subscribeToResult */])(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber["a" /* OuterSubscriber */]));
//# sourceMappingURL=timeoutWith.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeout.js
/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */




function timeout(due, scheduler) {
    if (scheduler === void 0) {
        scheduler = scheduler_async["a" /* async */];
    }
    return timeoutWith(due, Object(throwError["a" /* throwError */])(new TimeoutError()), scheduler);
}
//# sourceMappingURL=timeout.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
var startWith = __webpack_require__(175);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatMap.js
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function concatMap(project, resultSelector) {
    return Object(mergeMap["a" /* mergeMap */])(project, resultSelector, 1);
}
//# sourceMappingURL=concatMap.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(177);

// EXTERNAL MODULE: ./src/utils/get_fuzzed_delay.ts
var get_fuzzed_delay = __webpack_require__(109);

// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(9);

// CONCATENATED MODULE: ./src/utils/rx-retry_with_backoff.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Retry the given observable (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Observable} obs$
 * @param {Object} options - Configuration object.
 * This object contains the following properties:
 *
 *   - retryDelay {Number} - The initial delay, in ms.
 *     This delay will be fuzzed to fall under the range +-30% each time a new
 *     retry is done.
 *     Then, this delay will be multiplied by 2^(n-1), n being the counter of
 *     retry we performed (beginning at 1 for the first retry).
 *
 *   - totalRetry {Number} - The amount of time we should retry. 0
 *     means no retry, 1 means a single retry, Infinity means infinite retry
 *     etc.
 *     If the observable still fails after this number of retry, the error will
 *     be throwed through this observable.
 *
 *   - shouldRetry {Function|undefined} -  Function which will receive the
 *     observable error each time it fails, and should return a boolean. If this
 *     boolean is false, the error will be directly thrown (without anymore
 *     retry).
 *
 *   - onRetry {Function|undefined} - Function which will be triggered at
 *     each retry. Will receive two arguments:
 *       1. The observable error
 *       2. The current retry count, beginning at 1 for the first retry
 *
 * @returns {Observable}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */

function retryObsWithBackoff(obs$, options) {
  var baseDelay = options.baseDelay,
      maxDelay = options.maxDelay,
      totalRetry = options.totalRetry,
      shouldRetry = options.shouldRetry,
      onRetry = options.onRetry;
  var retryCount = 0;
  return obs$.pipe(Object(catchError["a" /* catchError */])(function (error, source) {
    if (!Object(is_null_or_undefined["a" /* default */])(shouldRetry) && !shouldRetry(error) || retryCount++ >= totalRetry) {
      throw error;
    }

    if (typeof onRetry === "function") {
      onRetry(error, retryCount);
    }

    var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);
    var fuzzedDelay = Object(get_fuzzed_delay["a" /* default */])(delay);
    return Object(timer["a" /* timer */])(fuzzedDelay).pipe(Object(mergeMap["a" /* mergeMap */])(function () {
      return source;
    }));
  }));
}
// CONCATENATED MODULE: ./src/core/eme/check_key_statuses.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var KEY_STATUSES = {
  EXPIRED: "expired",
  INTERNAL_ERROR: "internal-error",
  OUTPUT_RESTRICTED: "output-restricted"
};
/**
 * Look at the current key statuses in the sessions and construct the
 * appropriate warnings and blacklisted key ids.
 *
 * Throws if one of the keyID is on an error.
 * @param {MediaKeySession} session - The MediaKeySession from which the keys
 * will be checked.
 * @param {Object} keySystem - Configuration. Used to known on which situations
 * we can fallback.
 * @returns {Array} - Warnings to send and blacklisted key ids.
 */

function checkKeyStatuses(session, keySystem) {
  var warnings = [];
  var blacklistedKeyIDs = [];
  var _keySystem$fallbackOn = keySystem.fallbackOn,
      fallbackOn = _keySystem$fallbackOn === void 0 ? {} : _keySystem$fallbackOn;
  /* tslint:disable no-unsafe-any */

  session.keyStatuses.forEach(function (_arg1, _arg2) {
    /* tslint:enable no-unsafe-any */
    // Hack present because the order of the arguments has changed in spec
    // and is not the same between some versions of Edge and Chrome.
    var _ref = function () {
      return typeof _arg1 === "string" ? [_arg1, _arg2] : [_arg2, _arg1];
    }(),
        keyStatus = _ref[0],
        keyId = _ref[1];

    switch (keyStatus) {
      case KEY_STATUSES.EXPIRED:
        {
          var error = new encrypted_media_error["a" /* default */]("KEY_STATUS_CHANGE_ERROR", "A decryption key expired");

          if (keySystem.throwOnLicenseExpiration !== false) {
            throw error;
          }

          warnings.push({
            type: "warning",
            value: error
          });
          break;
        }

      case KEY_STATUSES.INTERNAL_ERROR:
        {
          var _error = new encrypted_media_error["a" /* default */]("KEY_STATUS_CHANGE_ERROR", "An invalid key status has been " + "encountered: " + keyStatus);

          if (fallbackOn.keyInternalError !== true) {
            throw _error;
          }

          warnings.push({
            type: "warning",
            value: _error
          });
          blacklistedKeyIDs.push(keyId);
        }

      case KEY_STATUSES.OUTPUT_RESTRICTED:
        {
          var _error2 = new encrypted_media_error["a" /* default */]("KEY_STATUS_CHANGE_ERROR", "An invalid key status has been " + "encountered: " + keyStatus);

          if (fallbackOn.keyOutputRestricted !== true) {
            throw _error2;
          }

          warnings.push({
            type: "warning",
            value: _error2
          });
          blacklistedKeyIDs.push(keyId);
        }
    }
  });
  return [warnings, blacklistedKeyIDs];
}
// CONCATENATED MODULE: ./src/core/eme/session_events_listener.ts
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










var onKeyError$ = compat["a" /* events */].onKeyError$,
    onKeyMessage$ = compat["a" /* events */].onKeyMessage$,
    onKeyStatusesChange$ = compat["a" /* events */].onKeyStatusesChange$;
/**
 * Error thrown when the MediaKeySession is blacklisted.
 * Such MediaKeySession should not be re-used but other MediaKeySession for the
 * same content can still be used.
 * @class BlacklistedSessionError
 * @extends Error
 */

var BlacklistedSessionError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(BlacklistedSessionError, _Error);

  function BlacklistedSessionError(sessionError) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), BlacklistedSessionError.prototype);
    _this.sessionError = sessionError;
    return _this;
  }

  return BlacklistedSessionError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * @param {Error|Object} error
 * @returns {Error|Object}
 */

function formatGetLicenseError(error) {
  if (error instanceof TimeoutError) {
    return new encrypted_media_error["a" /* default */]("KEY_LOAD_TIMEOUT", "The license server took too much time to " + "respond.");
  }

  var err = new encrypted_media_error["a" /* default */]("KEY_LOAD_ERROR", "An error occured when calling `getLicense`.");

  if (error != null && Object(is_non_empty_string["a" /* default */])(error.message)) {
    err.message = error.message;
  }

  return err;
}
/**
 * @param {MediaKeySession} session - The MediaKeySession concerned.
 * @param {Object} keySystem - The key system configuration.
 * @returns {Observable}
 */


function getKeyStatusesEvents(session, keySystem) {
  var _checkKeyStatuses = checkKeyStatuses(session, keySystem),
      warnings = _checkKeyStatuses[0],
      blacklistedKeyIDs = _checkKeyStatuses[1];

  var warnings$ = warnings.length > 0 ? of["a" /* of */].apply(void 0, warnings) : empty["a" /* EMPTY */];
  var blackListUpdate$ = blacklistedKeyIDs.length > 0 ? Object(of["a" /* of */])({
    type: "blacklist-keys",
    value: blacklistedKeyIDs
  }) : empty["a" /* EMPTY */];
  return Object(concat["a" /* concat */])(warnings$, blackListUpdate$);
}
/**
 * listen to various events from a MediaKeySession and react accordingly
 * depending on the configuration given.
 * @param {MediaKeySession} session - The MediaKeySession concerned.
 * @param {Object} keySystem - The key system configuration.
 * @param {Object} initDataInfo - The initialization data linked to that
 * session.
 * @returns {Observable}
 */


function SessionEventsListener(session, keySystem, _ref) {
  var initData = _ref.initData,
      initDataType = _ref.initDataType;

  var _a;

  log["a" /* default */].debug("EME: Binding session events", session);
  var sessionWarningSubject$ = new Subject["a" /* Subject */]();
  var _keySystem$getLicense = keySystem.getLicenseConfig,
      getLicenseConfig = _keySystem$getLicense === void 0 ? {} : _keySystem$getLicense;
  var getLicenseRetryOptions = {
    totalRetry: (_a = getLicenseConfig.retry) !== null && _a !== void 0 ? _a : 2,
    baseDelay: 200,
    maxDelay: 3000,
    shouldRetry: function shouldRetry(error) {
      return error instanceof TimeoutError || error === undefined || error === null || error.noRetry !== true;
    },
    onRetry: function onRetry(error) {
      return sessionWarningSubject$.next({
        type: "warning",
        value: formatGetLicenseError(error)
      });
    }
  };
  var keyErrors = onKeyError$(session).pipe(Object(map["a" /* map */])(function (error) {
    throw new encrypted_media_error["a" /* default */]("KEY_ERROR", error.type);
  }));
  var keyStatusesChanges = onKeyStatusesChange$(session).pipe(Object(mergeMap["a" /* mergeMap */])(function (keyStatusesEvent) {
    log["a" /* default */].debug("EME: keystatuseschange event", session, keyStatusesEvent);
    var keyStatusesEvents$ = getKeyStatusesEvents(session, keySystem);
    var handledKeyStatusesChange$ = Object(rx_try_catch["a" /* default */])(function () {
      return typeof keySystem.onKeyStatusesChange === "function" ? Object(cast_to_observable["a" /* default */])(keySystem.onKeyStatusesChange(keyStatusesEvent, session)) : empty["a" /* EMPTY */];
    }, undefined).pipe(Object(map["a" /* map */])(function (licenseObject) {
      return {
        type: "key-status-change-handled",
        value: {
          session: session,
          license: licenseObject
        }
      };
    }), Object(catchError["a" /* catchError */])(function (error) {
      var err = new encrypted_media_error["a" /* default */]("KEY_STATUS_CHANGE_ERROR", "Unknown `onKeyStatusesChange` error");

      if (error != null && Object(is_non_empty_string["a" /* default */])(error.message)) {
        err.message = error.message;
      }

      throw err;
    }));
    return Object(concat["a" /* concat */])(keyStatusesEvents$, handledKeyStatusesChange$);
  }));
  var keyMessages$ = onKeyMessage$(session).pipe(Object(mergeMap["a" /* mergeMap */])(function (messageEvent) {
    var message = new Uint8Array(messageEvent.message);
    var messageType = Object(is_non_empty_string["a" /* default */])(messageEvent.messageType) ? messageEvent.messageType : "license-request";
    log["a" /* default */].debug("EME: Event message type " + messageType, session, messageEvent);
    var getLicense$ = Object(defer["a" /* defer */])(function () {
      var getLicense = keySystem.getLicense(message, messageType);
      var getLicenseTimeout = getLicenseConfig.timeout != null ? getLicenseConfig.timeout : 10 * 1000;
      return Object(cast_to_observable["a" /* default */])(getLicense).pipe(getLicenseTimeout >= 0 ? timeout(getLicenseTimeout) : identity["a" /* identity */]
      /* noop */
      );
    });
    return retryObsWithBackoff(getLicense$, getLicenseRetryOptions).pipe(Object(map["a" /* map */])(function (licenseObject) {
      return {
        type: "key-message-handled",
        value: {
          session: session,
          license: licenseObject
        }
      };
    }), Object(catchError["a" /* catchError */])(function (err) {
      var formattedError = formatGetLicenseError(err);

      if (err != null) {
        var fallbackOnLastTry = err.fallbackOnLastTry;

        if (fallbackOnLastTry === true) {
          log["a" /* default */].warn("EME: Last `getLicense` attempt failed. " + "Blacklisting the current session.");
          throw new BlacklistedSessionError(formattedError);
        }
      }

      throw formattedError;
    }), Object(startWith["a" /* startWith */])({
      type: "session-message",
      value: {
        messageType: messageType,
        initData: initData,
        initDataType: initDataType
      }
    }));
  }));
  var sessionUpdates = Object(merge["a" /* merge */])(keyMessages$, keyStatusesChanges).pipe(concatMap(function (evt) {
    switch (evt.type) {
      case "warning":
      case "blacklist-keys":
      case "session-message":
        return Object(of["a" /* of */])(evt);
    }

    var license = evt.value.license;

    if (license == null) {
      log["a" /* default */].info("EME: No license given, skipping session.update");
      return Object(of["a" /* of */])({
        type: "no-update",
        value: {
          initData: initData,
          initDataType: initDataType
        }
      });
    }

    log["a" /* default */].debug("EME: Update session", evt);
    return Object(cast_to_observable["a" /* default */])(session.update(license)).pipe(Object(catchError["a" /* catchError */])(function (error) {
      var reason = error instanceof Error ? error.toString() : "`session.update` failed";
      throw new encrypted_media_error["a" /* default */]("KEY_UPDATE_ERROR", reason);
    }), Object(mapTo["a" /* mapTo */])({
      type: "session-updated",
      value: {
        session: session,
        license: license,
        initData: initData,
        initDataType: initDataType
      }
    }));
  }));
  var sessionEvents = Object(merge["a" /* merge */])(getKeyStatusesEvents(session, keySystem), sessionUpdates, keyErrors, sessionWarningSubject$);
  return session.closed != null ? sessionEvents.pipe(Object(takeUntil["a" /* takeUntil */])(Object(cast_to_observable["a" /* default */])(session.closed))) : sessionEvents;
}
// CONCATENATED MODULE: ./src/core/eme/set_server_certificate.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Call the setServerCertificate API with the given certificate.
 * Complete when worked, throw when failed.
 *
 * TODO Manage success?
 * From the spec:
 *   - setServerCertificate resolves with true if everything worked
 *   - it resolves with false if the CDM does not support server
 *     certificates.
 *
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */

function setServerCertificate(mediaKeys, serverCertificate) {
  return Object(defer["a" /* defer */])(function () {
    return Object(cast_to_observable["a" /* default */])(mediaKeys.setServerCertificate(serverCertificate)).pipe(Object(catchError["a" /* catchError */])(function (error) {
      log["a" /* default */].warn("EME: mediaKeys.setServerCertificate returned an error", error);
      var reason = error instanceof Error ? error.toString() : "`setServerCertificate` error";
      throw new encrypted_media_error["a" /* default */]("LICENSE_SERVER_CERTIFICATE_ERROR", reason);
    }));
  });
}
/**
 * Call the setCertificate API. If it fails just emit the error as warning
 * and complete.
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */


function trySettingServerCertificate(mediaKeys, serverCertificate) {
  if (typeof mediaKeys.setServerCertificate === "function") {
    log["a" /* default */].debug("EME: Setting server certificate on the MediaKeys");
    return setServerCertificate(mediaKeys, serverCertificate).pipe(Object(ignoreElements["a" /* ignoreElements */])(), Object(catchError["a" /* catchError */])(function (error) {
      return Object(of["a" /* of */])({
        type: "warning",
        value: error
      });
    }));
  }

  log["a" /* default */].warn("EME: Could not set the server certificate." + " mediaKeys.setServerCertificate is not a function");
  return empty["a" /* EMPTY */];
}

// CONCATENATED MODULE: ./src/core/eme/utils/init_data_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Map initialization data to another property.
 * @class InitDataStore
 */

var init_data_store_InitDataStore = /*#__PURE__*/function () {
  function InitDataStore() {
    this._namedTypeData = {};
    this._unnamedTypeData = {};
  }
  /**
   * Returns true if this instance has the given initData stored.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {boolean}
   */


  var _proto = InitDataStore.prototype;

  _proto.get = function get(initDataType, initData) {
    if (!Object(is_non_empty_string["a" /* default */])(initDataType)) {
      return this._unnamedTypeData[Object(hash_buffer["a" /* default */])(initData)];
    }

    var forDataType = this._namedTypeData[initDataType];

    if (forDataType == null) {
      return undefined;
    }

    return forDataType[Object(hash_buffer["a" /* default */])(initData)];
  }
  /**
   * Add initialization data to this memory.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   */
  ;

  _proto.set = function set(initDataType, initData, data) {
    var hashed = Object(hash_buffer["a" /* default */])(initData);

    if (!Object(is_non_empty_string["a" /* default */])(initDataType)) {
      this._unnamedTypeData[hashed] = data;
      return;
    }

    var forDataType = this._namedTypeData[initDataType];

    if (forDataType == null) {
      var _this$_namedTypeData$;

      this._namedTypeData[initDataType] = (_this$_namedTypeData$ = {}, _this$_namedTypeData$[hashed] = data, _this$_namedTypeData$);
    } else {
      forDataType[hashed] = data;
    }
  }
  /**
   * Remove the initialization data from this memory.
   * Returns true if this instance had the given initData stored.
   * @param {Uint8Array} initData
   * @param {string|undefined} initDataType
   * @returns {boolean}
   */
  ;

  _proto.remove = function remove(initDataType, initData) {
    if (!Object(is_non_empty_string["a" /* default */])(initDataType)) {
      var hashed = Object(hash_buffer["a" /* default */])(initData);

      if (this._unnamedTypeData.hasOwnProperty(hashed)) {
        delete this._unnamedTypeData[hashed];
        return true;
      }

      return false;
    } else {
      if (!this._namedTypeData.hasOwnProperty(initDataType)) {
        return false;
      }

      var dataForType = this._namedTypeData[initDataType];

      var _hashed = Object(hash_buffer["a" /* default */])(initData);

      if (dataForType.hasOwnProperty(_hashed)) {
        delete dataForType[_hashed];
        return true;
      }

      return false;
    }
  };

  return InitDataStore;
}();


// CONCATENATED MODULE: ./src/core/eme/eme_manager.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










var onEncrypted$ = compat["a" /* events */].onEncrypted$;
/**
 * EME abstraction and event handler used to communicate with the Content-
 * Description-Module (CDM).
 *
 * The EME handler can be given one or multiple systems and will choose the
 * appropriate one supported by the user's browser.
 * @param {HTMLMediaElement} mediaElement - The MediaElement which will be
 * associated to a MediaKeys object
 * @param {Array.<Object>} keySystems - key system configuration
 * @param {Observable} contentProtections$ - Observable emitting external
 * initialization data.
 * @returns {Observable}
 */

function EMEManager(mediaElement, keySystemsConfigs, contentProtections$) {
  log["a" /* default */].debug("EME: Starting EMEManager logic."); // Keep track of all initialization data handled here.
  // This is to avoid handling multiple times the same encrypted events.

  var handledInitData = new init_data_store_InitDataStore(); // Keep track of the blacklisted init data with the corresponding session
  // error.
  // If a new event emit data which has already been blacklisted, we can
  // directly send the corresponding event.

  var blacklistedInitData = new init_data_store_InitDataStore(); // store the mediaKeys when ready

  var mediaKeysInfos$ = initMediaKeys(mediaElement, keySystemsConfigs).pipe(Object(shareReplay["a" /* shareReplay */])()); // cache success

  var attachedMediaKeys$ = mediaKeysInfos$.pipe(Object(filter["a" /* filter */])(function (evt) {
    return evt.type === "attached-media-keys";
  }), Object(take["a" /* take */])(1));
  var mediaEncryptedEvents$ = onEncrypted$(mediaElement).pipe(Object(tap["a" /* tap */])(function (evt) {
    log["a" /* default */].debug("EME: Encrypted event received from media element.", evt);
  }), Object(mergeMap["a" /* mergeMap */])(function (evt) {
    var _getInitData = Object(get_init_data["a" /* default */])(evt),
        initData = _getInitData.initData,
        initDataType = _getInitData.initDataType;

    if (initData == null) {
      return empty["a" /* EMPTY */];
    }

    return Object(of["a" /* of */])({
      type: initDataType,
      data: initData
    });
  }), Object(shareReplay["a" /* shareReplay */])({
    refCount: true
  })); // multiple Observables listen to that one
  // as soon as the EMEManager is subscribed

  var externalEvents$ = contentProtections$.pipe(Object(tap["a" /* tap */])(function (evt) {
    log["a" /* default */].debug("EME: Encrypted event received from Player", evt);
  })); // Merge all encrypted events

  var encryptedEvents$ = Object(merge["a" /* merge */])(externalEvents$, mediaEncryptedEvents$);
  var bindSession$ = encryptedEvents$.pipe( // Add attached MediaKeys info once available
  Object(mergeMap["a" /* mergeMap */])(function (encryptedEvt) {
    return attachedMediaKeys$.pipe(Object(map["a" /* map */])(function (mediaKeysEvt) {
      return [encryptedEvt, mediaKeysEvt];
    }));
  }),
  /* Attach server certificate and create/reuse MediaKeySession */
  Object(mergeMap["a" /* mergeMap */])(function (_ref, i) {
    var encryptedEvent = _ref[0],
        mediaKeysEvent = _ref[1];
    var mediaKeysInfos = mediaKeysEvent.value;
    var keySystemOptions = mediaKeysInfos.keySystemOptions,
        mediaKeys = mediaKeysInfos.mediaKeys;
    var serverCertificate = keySystemOptions.serverCertificate;
    var initDataType = encryptedEvent.type,
        initData = encryptedEvent.data;
    var blacklistError = blacklistedInitData.get(initDataType, initData);

    if (blacklistError != null) {
      if (initDataType == null) {
        log["a" /* default */].error("EME: The current session has already been blacklisted " + "but the current content is not known. Throwing.");
        var sessionError = blacklistError.sessionError;
        sessionError.fatal = true;
        return Object(throwError["a" /* throwError */])(sessionError);
      }

      log["a" /* default */].warn("EME: The current session has already been blacklisted. " + "Blacklisting content.");
      return Object(of["a" /* of */])({
        type: "blacklist-protection-data",
        value: {
          type: initDataType,
          data: initData
        }
      });
    }

    if (handledInitData.get(initDataType, initData) === true) {
      log["a" /* default */].debug("EME: Init data already received. Skipping it.");
      return Object(of["a" /* of */])({
        type: "init-data-ignored",
        value: {
          type: initDataType,
          data: initData
        }
      });
    }

    handledInitData.set(initDataType, initData, true);
    var session$ = getSession(encryptedEvent, mediaKeysInfos).pipe(Object(map["a" /* map */])(function (evt) {
      return {
        type: evt.type,
        value: {
          initData: evt.value.initData,
          initDataType: evt.value.initDataType,
          mediaKeySession: evt.value.mediaKeySession,
          sessionType: evt.value.sessionType,
          keySystemOptions: mediaKeysInfos.keySystemOptions,
          sessionStorage: mediaKeysInfos.sessionStorage
        }
      };
    }));

    if (i === 0) {
      // first encrypted event for the current content
      return Object(merge["a" /* merge */])(serverCertificate != null ? Object(concat["a" /* concat */])(trySettingServerCertificate(mediaKeys, serverCertificate), session$) : session$);
    }

    return session$;
  }),
  /* Trigger license request and manage MediaKeySession events */
  Object(mergeMap["a" /* mergeMap */])(function (sessionInfosEvt) {
    switch (sessionInfosEvt.type) {
      case "warning":
      case "blacklist-protection-data":
      case "init-data-ignored":
        return Object(of["a" /* of */])(sessionInfosEvt);
    }

    var _sessionInfosEvt$valu = sessionInfosEvt.value,
        initData = _sessionInfosEvt$valu.initData,
        initDataType = _sessionInfosEvt$valu.initDataType,
        mediaKeySession = _sessionInfosEvt$valu.mediaKeySession,
        sessionType = _sessionInfosEvt$valu.sessionType,
        keySystemOptions = _sessionInfosEvt$valu.keySystemOptions,
        sessionStorage = _sessionInfosEvt$valu.sessionStorage;
    var generateRequest$ = sessionInfosEvt.type !== "created-session" ? empty["a" /* EMPTY */] : Object(generate_key_request["a" /* default */])(mediaKeySession, initData, initDataType).pipe(Object(tap["a" /* tap */])(function () {
      if (sessionType === "persistent-license" && sessionStorage != null) {
        sessionStorage.add(initData, initDataType, mediaKeySession);
      }
    }), Object(catchError["a" /* catchError */])(function (error) {
      throw new encrypted_media_error["a" /* default */]("KEY_GENERATE_REQUEST_ERROR", error instanceof Error ? error.toString() : "Unknown error");
    }), Object(ignoreElements["a" /* ignoreElements */])());
    return Object(merge["a" /* merge */])(SessionEventsListener(mediaKeySession, keySystemOptions, {
      initData: initData,
      initDataType: initDataType
    }), generateRequest$).pipe(Object(catchError["a" /* catchError */])(function (err) {
      if (!(err instanceof BlacklistedSessionError)) {
        throw err;
      }

      blacklistedInitData.set(initDataType, initData, err);
      var sessionError = err.sessionError;

      if (initDataType == null) {
        log["a" /* default */].error("EME: Current session blacklisted and content not known. " + "Throwing.");
        sessionError.fatal = true;
        throw sessionError;
      }

      log["a" /* default */].warn("EME: Current session blacklisted. Blacklisting content.");
      return Object(of["a" /* of */])({
        type: "warning",
        value: sessionError
      }, {
        type: "blacklist-protection-data",
        value: {
          type: initDataType,
          data: initData
        }
      });
    }));
  }));
  return Object(merge["a" /* merge */])(mediaKeysInfos$, mediaEncryptedEvents$.pipe(Object(map["a" /* map */])(function (evt) {
    return {
      type: "encrypted-event-received",
      value: evt
    };
  })), bindSession$);
}
// EXTERNAL MODULE: ./src/core/eme/get_current_key_system.ts
var get_current_key_system = __webpack_require__(156);

// CONCATENATED MODULE: ./src/core/eme/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */




/* harmony default export */ var eme = __webpack_exports__["default"] = (EMEManager);


/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shouldUnsetMediaKeys; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the mediakeys associated to a media element should be
 * unset once the content is stopped.
 * Depends on the target.
 * @returns {Boolean}
 */

function shouldUnsetMediaKeys() {
  return _browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isIE11 */ "b"];
}

/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return setElementSrc$; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _clear_element_src__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(90);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Set an URL to the element's src.
 * Emit ``undefined`` when done.
 * Unlink src on unsubscription.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {string} url
 * @returns {Observable}
 */

function setElementSrc$(mediaElement, url) {
  return new rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (observer) {
    _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].info("Setting URL to Element", url, mediaElement);
    mediaElement.src = url;
    observer.next(undefined);
    return function () {
      Object(_clear_element_src__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(mediaElement);
    };
  });
}

/***/ }),
/* 143 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shouldWaitForDataBeforeLoaded; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * On some browsers, the ready state might never go above `1` when autoplay is
 * blocked. On these cases, for now, we just advertise the content as "loaded".
 * We might go into BUFFERING just after that state, but that's a small price to
 * pay.
 * @param {Boolean} isDirectfile
 * @returns {Boolean}
 */

function shouldWaitForDataBeforeLoaded(isDirectfile, mustPlayInline) {
  if (isDirectfile && _browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isSafariMobile */ "e"]) {
    return mustPlayInline;
  }

  return true;
}

/***/ }),
/* 144 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return play$; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);
/* harmony import */ var _utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _utils_rx_try_catch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Call play on the media element on subscription and return the response as an
 * observable.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

function play$(mediaElement) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* defer */ "a"])(function () {
    return (// mediaElement.play is not always a Promise. In the improbable case it
      // throws, I prefer still to catch to return the error wrapped in an
      // Observable
      Object(_utils_rx_try_catch__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(function () {
        return Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(mediaElement.play());
      }, undefined)
    );
  });
}

/***/ }),
/* 145 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return whenLoadedMetadata$; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(138);
/* harmony import */ var _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _event_listeners__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(51);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Returns an observable emitting a single time, as soon as a seek is possible
 * (the metadata are loaded).
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

function whenLoadedMetadata$(mediaElement) {
  if (mediaElement.readyState >= _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_2__[/* READY_STATES */ "d"].HAVE_METADATA) {
    return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* of */ "a"])(null);
  } else {
    return Object(_event_listeners__WEBPACK_IMPORTED_MODULE_3__["onLoadedMetadata$"])(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__[/* take */ "a"])(1));
  }
}

/***/ }),
/* 146 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return hasEMEAPIs; });
/* harmony import */ var _eme__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(147);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the browser has the minimum needed EME APIs to decrypt a
 * content.
 * @returns {Boolean}
 */

function hasEMEAPIs() {
  return typeof _eme__WEBPACK_IMPORTED_MODULE_0__[/* requestMediaKeySystemAccess */ "c"] === "function";
}

/***/ }),
/* 147 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createSession; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return requestMediaKeySystemAccess; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(88);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(177);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1);
/* harmony import */ var _utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(23);
/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(25);
/* harmony import */ var _utils_promise__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(34);
/* harmony import */ var _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(26);
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(21);
/* harmony import */ var _event_listeners__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(51);
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(31);
/* harmony import */ var _should_use_webkit_media_keys__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(99);
/* harmony import */ var _custom_key_system_access__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(148);
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












var requestMediaKeySystemAccess = null;

function createMediaKeysSession(mediaKeys, sessionType) {
  return mediaKeys.createSession(sessionType);
}

var createSession = createMediaKeysSession; // Default CustomMediaKeys implementation

var CustomMediaKeys = /*#__PURE__*/function () {
  function CustomMediaKeys() {}

  var _proto = CustomMediaKeys.prototype;

  _proto._setVideo = function _setVideo() {
    throw new Error("MediaKeys is not implemented in your browser");
  };

  _proto.createSession = function createSession() {
    throw new Error("MediaKeys is not implemented in your browser");
  };

  _proto.setServerCertificate = function setServerCertificate() {
    throw new Error("MediaKeys is not implemented in your browser");
  };

  return CustomMediaKeys;
}();
/**
 * Since Safari 12.1, EME APIs are available without webkit prefix.
 * However, it seems that since fairplay CDM implementation within the browser is not
 * standard with EME w3c current spec, the requestMediaKeySystemAccess API doesn't resolve
 * positively, even if the drm (fairplay in most cases) is supported.
 *
 * Therefore, we prefer not to use requestMediaKeySystemAccess on Safari when webkit API
 * is available.
 */


if (_is_node__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"] || navigator.requestMediaKeySystemAccess != null && !Object(_should_use_webkit_media_keys__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])()) {
  requestMediaKeySystemAccess = function requestMediaKeySystemAccess(a, b) {
    return Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"])(navigator.requestMediaKeySystemAccess(a, b));
  };
} else {
  // Wrap "MediaKeys.prototype.update" form an event based system to a
  // Promise based function.
  var wrapUpdate = function wrapUpdate(memUpdate) {
    return function (license, sessionId) {
      var _this = this;

      return new _utils_promise__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](function (resolve, reject) {
        try {
          memUpdate.call(_this, license, sessionId == null ? "" : sessionId);
          resolve();
        } catch (e) {
          reject(e);
        }
      });
    };
  };
  /**
   * Returns true if the given media element has old webkit methods
   * corresponding to the IOldWebkitHTMLMediaElement interface.
   * @param {HTMLMediaElement} element
   * @returns {Boolean}
   */


  var isOldWebkitMediaElement = function isOldWebkitMediaElement(element) {
    return typeof element.webkitGenerateKeyRequest === "function";
  }; // This is for Chrome with unprefixed EME api


  if (isOldWebkitMediaElement(HTMLVideoElement.prototype)) {
    var WebkitMediaKeySession = /*#__PURE__*/function (_EventEmitter) {
      _inheritsLoose(WebkitMediaKeySession, _EventEmitter);

      function WebkitMediaKeySession(mediaElement, keySystem) {
        var _this2;

        _this2 = _EventEmitter.call(this) || this;
        _this2._closeSession$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Subject */ "a"]();
        _this2._vid = mediaElement;
        _this2._key = keySystem;
        _this2.sessionId = "";
        _this2.closed = new _utils_promise__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](function (resolve) {
          _this2._closeSession$.subscribe(resolve);
        });
        _this2.keyStatuses = new Map();
        _this2.expiration = NaN;
        Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* merge */ "a"])(_event_listeners__WEBPACK_IMPORTED_MODULE_11__["onKeyMessage$"](mediaElement), _event_listeners__WEBPACK_IMPORTED_MODULE_11__["onKeyAdded$"](mediaElement), _event_listeners__WEBPACK_IMPORTED_MODULE_11__["onKeyError$"](mediaElement)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* takeUntil */ "a"])(_this2._closeSession$)).subscribe(function (evt) {
          return _this2.trigger(evt.type, evt);
        });
        _this2.update = wrapUpdate(function (license, sessionId) {
          if (!isOldWebkitMediaElement(_this2._vid)) {
            throw new Error("impossible to add a new key");
          }

          if (_this2._key.indexOf("clearkey") >= 0) {
            var licenseTypedArray = license instanceof ArrayBuffer ? new Uint8Array(license) : license;
            /* tslint:disable no-unsafe-any */

            var json = JSON.parse(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_5__[/* bytesToStr */ "f"])(licenseTypedArray));
            var key = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_5__[/* strToBytes */ "q"])(atob(json.keys[0].k));
            var kid = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_5__[/* strToBytes */ "q"])(atob(json.keys[0].kid));
            /* tslint:enable no-unsafe-any */

            _this2._vid.webkitAddKey(_this2._key, key, kid, sessionId);
          } else {
            _this2._vid.webkitAddKey(_this2._key, license, null, sessionId);
          }

          _this2.sessionId = sessionId;
        });
        return _this2;
      }

      var _proto2 = WebkitMediaKeySession.prototype;

      _proto2.generateRequest = function generateRequest(_initDataType, initData) {
        var _this3 = this;

        return new _utils_promise__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](function (resolve) {
          if (!isOldWebkitMediaElement(_this3._vid)) {
            throw new Error("impossible to generate a key request");
          }

          _this3._vid.webkitGenerateKeyRequest(_this3._key, initData);

          resolve();
        });
      };

      _proto2.close = function close() {
        var _this4 = this;

        return new _utils_promise__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](function (resolve) {
          _this4._closeSession$.next();

          _this4._closeSession$.complete();

          resolve();
        });
      };

      _proto2.load = function load() {
        return _utils_promise__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].resolve(false);
      };

      _proto2.remove = function remove() {
        return _utils_promise__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].resolve();
      };

      return WebkitMediaKeySession;
    }(_utils_event_emitter__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]);

    CustomMediaKeys = /*#__PURE__*/function () {
      function CustomMediaKeys(keySystem) {
        this.ks_ = keySystem;
      }

      var _proto3 = CustomMediaKeys.prototype;

      _proto3._setVideo = function _setVideo(vid) {
        this._vid = vid;
      };

      _proto3.createSession = function createSession()
      /* sessionType */
      {
        if (this._vid == null) {
          throw new Error("Video not attached to the MediaKeys");
        }

        return new WebkitMediaKeySession(this._vid, this.ks_);
      };

      _proto3.setServerCertificate = function setServerCertificate() {
        throw new Error("Server certificate is not implemented in your browser");
      };

      return CustomMediaKeys;
    }();

    var isTypeSupported = function isTypeSupported(keyType) {
      // get any <video> element from the DOM or create one
      // and try the `canPlayType` method
      var videoElement = document.querySelector("video");

      if (videoElement == null) {
        videoElement = document.createElement("video");
      }
      /* tslint:disable no-unsafe-any */

      /* tslint:disable no-unbound-method */


      if (videoElement != null && typeof videoElement.canPlayType === "function") {
        /* tslint:enable no-unbound-method */
        return !!videoElement.canPlayType("video/mp4", keyType);
        /* tslint:enable no-unsafe-any */
      } else {
        return false;
      }
    };

    requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
      if (!isTypeSupported(keyType)) {
        return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* throwError */ "a"])(undefined);
      }

      for (var i = 0; i < keySystemConfigurations.length; i++) {
        var keySystemConfiguration = keySystemConfigurations[i];
        var videoCapabilities = keySystemConfiguration.videoCapabilities,
            audioCapabilities = keySystemConfiguration.audioCapabilities,
            initDataTypes = keySystemConfiguration.initDataTypes,
            sessionTypes = keySystemConfiguration.sessionTypes,
            distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier,
            persistentState = keySystemConfiguration.persistentState;
        var supported = true;
        supported = supported && (initDataTypes == null || initDataTypes.some(function (initDataType) {
          return initDataType === "cenc";
        }));
        supported = supported && (sessionTypes == null || sessionTypes.filter(function (sessionType) {
          return sessionType === "temporary";
        }).length === sessionTypes.length);
        supported = supported && distinctiveIdentifier !== "required";
        supported = supported && persistentState !== "required";

        if (supported) {
          var keySystemConfigurationResponse = {
            videoCapabilities: videoCapabilities,
            audioCapabilities: audioCapabilities,
            initDataTypes: ["cenc"],
            sessionTypes: ["temporary"],
            distinctiveIdentifier: "not-allowed",
            persistentState: "not-allowed"
          };
          return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__[/* of */ "a"])(new _custom_key_system_access__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"](keyType, new CustomMediaKeys(keyType), keySystemConfigurationResponse));
        }
      }

      return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* throwError */ "a"])(undefined);
    };
  } else if (_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__[/* MediaKeys_ */ "b"] != null && _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__[/* MediaKeys_ */ "b"].prototype != null &&
  /* tslint:disable no-unsafe-any */
  typeof _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__[/* MediaKeys_ */ "b"].isTypeSupported === "function"
  /* tslint:enable no-unsafe-any */
  ) {
      requestMediaKeySystemAccess = function requestMediaKeySystemAccess(keyType, keySystemConfigurations) {
        // TODO Why TS Do not understand that isTypeSupported exists here?

        /* tslint:disable no-unsafe-any */
        if (!_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__[/* MediaKeys_ */ "b"].isTypeSupported(keyType)) {
          /* tslint:enable no-unsafe-any */
          return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* throwError */ "a"])(undefined);
        }

        for (var i = 0; i < keySystemConfigurations.length; i++) {
          var keySystemConfiguration = keySystemConfigurations[i];
          var videoCapabilities = keySystemConfiguration.videoCapabilities,
              audioCapabilities = keySystemConfiguration.audioCapabilities,
              initDataTypes = keySystemConfiguration.initDataTypes,
              distinctiveIdentifier = keySystemConfiguration.distinctiveIdentifier;
          var supported = true;
          supported = supported && (initDataTypes == null || initDataTypes.some(function (idt) {
            return idt === "cenc";
          }));
          supported = supported && distinctiveIdentifier !== "required";

          if (supported) {
            var keySystemConfigurationResponse = {
              videoCapabilities: videoCapabilities,
              audioCapabilities: audioCapabilities,
              initDataTypes: ["cenc"],
              distinctiveIdentifier: "not-allowed",
              persistentState: "required",
              sessionTypes: ["temporary", "persistent-license"]
            };
            return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__[/* of */ "a"])(new _custom_key_system_access__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"](keyType,
            /* tslint:disable no-unsafe-any */
            new _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__[/* MediaKeys_ */ "b"](keyType),
            /* tslint:enable no-unsafe-any */
            keySystemConfigurationResponse));
          }
        }

        return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* throwError */ "a"])(undefined);
      };

      if (_browser_detection__WEBPACK_IMPORTED_MODULE_10__[/* isIE11 */ "b"] &&
      /* tslint:disable no-unsafe-any */
      typeof _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_9__[/* MediaKeys_ */ "b"].prototype.createSession === "function")
        /* tslint:enable no-unsafe-any */
        {
          var IE11MediaKeySession = /*#__PURE__*/function (_EventEmitter2) {
            _inheritsLoose(IE11MediaKeySession, _EventEmitter2);

            function IE11MediaKeySession(mk) {
              var _this5;

              _this5 = _EventEmitter2.call(this) || this;
              _this5.sessionId = "";
              _this5.expiration = NaN;
              _this5.keyStatuses = new Map();
              _this5._mk = mk;
              _this5._closeSession$ = new rxjs__WEBPACK_IMPORTED_MODULE_0__[/* Subject */ "a"]();
              _this5.closed = new _utils_promise__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](function (resolve) {
                _this5._closeSession$.subscribe(resolve);
              });
              _this5.update = wrapUpdate(function (license, sessionId) {
                if (_this5._ss == null) {
                  throw new Error("MediaKeySession not set");
                }
                /* tslint:disable no-unsafe-any */


                _this5._ss.update(license, sessionId);
                /* tslint:enable no-unsafe-any */


                _this5.sessionId = sessionId;
              });
              return _this5;
            }

            var _proto4 = IE11MediaKeySession.prototype;

            _proto4.generateRequest = function generateRequest(_initDataType, initData) {
              var _this6 = this;

              return new _utils_promise__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](function (resolve) {
                /* tslint:disable no-unsafe-any */
                _this6._ss = _this6._mk.createSession("video/mp4", initData);
                /* tslint:enable no-unsafe-any */

                Object(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* merge */ "a"])(_event_listeners__WEBPACK_IMPORTED_MODULE_11__["onKeyMessage$"](_this6._ss), _event_listeners__WEBPACK_IMPORTED_MODULE_11__["onKeyAdded$"](_this6._ss), _event_listeners__WEBPACK_IMPORTED_MODULE_11__["onKeyError$"](_this6._ss)).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* takeUntil */ "a"])(_this6._closeSession$)).subscribe(function (evt) {
                  return _this6.trigger(evt.type, evt);
                });
                resolve();
              });
            };

            _proto4.close = function close() {
              var _this7 = this;

              return new _utils_promise__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](function (resolve) {
                if (_this7._ss != null) {
                  /* tslint:disable no-floating-promises */
                  _this7._ss.close();
                  /* tslint:enable no-floating-promises */


                  _this7._ss = undefined;
                }

                _this7._closeSession$.next();

                _this7._closeSession$.complete();

                resolve();
              });
            };

            _proto4.load = function load() {
              return _utils_promise__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].resolve(false);
            };

            _proto4.remove = function remove() {
              return _utils_promise__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].resolve();
            };

            return IE11MediaKeySession;
          }(_utils_event_emitter__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]);

          createSession = function createIE11MediaKeySession(mediaKeys) {
            return new IE11MediaKeySession(mediaKeys);
          };
        }
    }
}

/* harmony default export */ __webpack_exports__["b"] = (CustomMediaKeys);


/***/ }),
/* 148 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CustomMediaKeySystemAccess; });
/* harmony import */ var _utils_promise__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34);
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Simple implementation of the MediaKeySystemAccess EME API.
 *
 * All needed arguments are given to the constructor
 * @class CustomMediaKeySystemAccess
 */

var CustomMediaKeySystemAccess = /*#__PURE__*/function () {
  /**
   * @param {string} _keyType - type of key system (e.g. "widevine" or
   * "com.widevine.alpha").
   * @param {Object} _mediaKeys - MediaKeys implementation
   * @param {Object} _configuration - Configuration accepted for this
   * MediaKeySystemAccess.
   */
  function CustomMediaKeySystemAccess(_keyType, _mediaKeys, _configuration) {
    this._keyType = _keyType;
    this._mediaKeys = _mediaKeys;
    this._configuration = _configuration;
  }
  /**
   * @returns {string} - current key system type (e.g. "widevine" or
   * "com.widevine.alpha").
   */


  var _proto = CustomMediaKeySystemAccess.prototype;

  /**
   * @returns {Promise.<Object>} - Promise wrapping the MediaKeys for this
   * MediaKeySystemAccess. Never rejects.
   */
  _proto.createMediaKeys = function createMediaKeys() {
    var _this = this;

    return new _utils_promise__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"](function (res) {
      return res(_this._mediaKeys);
    });
  }
  /**
   * @returns {Object} - Configuration accepted for this MediaKeySystemAccess.
   */
  ;

  _proto.getConfiguration = function getConfiguration() {
    return this._configuration;
  };

  _createClass(CustomMediaKeySystemAccess, [{
    key: "keySystem",
    get: function get() {
      return this._keyType;
    }
  }]);

  return CustomMediaKeySystemAccess;
}();



/***/ }),
/* 149 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return distinctUntilChanged; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function distinctUntilChanged(compare, keySelector) {
    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
}
var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var key;
        try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
        }
        catch (err) {
            return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
            try {
                var compare = this.compare;
                result = compare(this.key, key);
            }
            catch (err) {
                return this.destination.error(err);
            }
        }
        else {
            this.hasKey = true;
        }
        if (!result) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=distinctUntilChanged.js.map


/***/ }),
/* 150 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ignoreElements; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function ignoreElements() {
    return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
    };
}
var IgnoreElementsOperator = /*@__PURE__*/ (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=ignoreElements.js.map


/***/ }),
/* 151 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return tap; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(60);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */




function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
var DoOperator = /*@__PURE__*/ (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
        _this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
        _this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
        _this._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
        _this._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_3__[/* isFunction */ "a"])(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
            _this._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
            _this._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_2__[/* noop */ "a"];
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=tap.js.map


/***/ }),
/* 152 */,
/* 153 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shouldRenewMediaKeys; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the current target require the media keys to be renewed on
 * each content.
 * @returns {Boolean}
 */

function shouldRenewMediaKeys() {
  return _browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isIE11 */ "b"];
}

/***/ }),
/* 154 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return clearEMESession; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(150);
/* harmony import */ var _compat___WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(141);
/* harmony import */ var _dispose_media_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(110);
/* harmony import */ var _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(40);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Clear EME ressources that should be cleared when the current content stops
 * its playback.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */

function clearEMESession(mediaElement) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* defer */ "a"])(function () {
    if (Object(_compat___WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])()) {
      return Object(_dispose_media_keys__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"])(mediaElement).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* ignoreElements */ "a"])());
    }

    var currentState = _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].getState(mediaElement);

    if (currentState != null && currentState.keySystemOptions.closeSessionsOnStop === true) {
      return currentState.sessionsStore.closeAllSessions().pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_2__[/* ignoreElements */ "a"])());
    }

    return rxjs__WEBPACK_IMPORTED_MODULE_1__[/* EMPTY */ "a"];
  });
}

/***/ }),
/* 155 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return disposeEME; });
/* harmony import */ var _utils_noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(33);
/* harmony import */ var _dispose_media_keys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(110);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Free up all ressources taken by the EME management.
 */

function disposeEME(mediaElement) {
  Object(_dispose_media_keys__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(mediaElement).subscribe(_utils_noop__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);
}

/***/ }),
/* 156 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getCurrentKeySystem; });
/* harmony import */ var _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the name of the current key system used.
 * @param {HTMLMediaElement} mediaElement
 * @returns {string|null}
 */

function getCurrentKeySystem(mediaElement) {
  var currentState = _media_keys_infos_store__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getState(mediaElement);
  return currentState == null ? null : currentState.keySystemOptions.type;
}

/***/ }),
/* 157 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isCodecSupported; });
/* harmony import */ var _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the given codec is supported by the browser's MediaSource
 * implementation.
 * @returns {Boolean}
 */

function isCodecSupported(codec) {
  if (_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__[/* MediaSource_ */ "c"] == null) {
    return false;
  }
  /* tslint:disable no-unbound-method */


  if (typeof _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__[/* MediaSource_ */ "c"].isTypeSupported === "function") {
    /* tslint:enable no-unbound-method */
    return _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__[/* MediaSource_ */ "c"].isTypeSupported(codec);
  }

  return true;
}

/***/ }),
/* 158 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return canPatchISOBMFFSegment; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe
 * try to put free atom inside traf children
 *
 * Returns true if the current target is tolerant enough for us to
 * simply be able to "patch" an ISOBMFF segment or if we have to create a
 * new one from scratch instead.
 * @returns {Boolean}
 */

function canPatchISOBMFFSegment() {
  return !_browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isIEOrEdge */ "c"];
}

/***/ }),
/* 159 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addTextTrack; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Add text track to the given media element.
 * Returns an object with the following properties:
 *   - track {TextTrack}: the added text track
 *   - trackElement {HTMLElement|undefined}: the added <track> element.
 *     undefined if no trackElement was added.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Boolean} hidden
 * @returns {Object}
 */

function addTextTrack(mediaElement, hidden) {
  var track;
  var trackElement;
  var kind = "subtitles";

  if (_browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isIEOrEdge */ "c"]) {
    var tracksLength = mediaElement.textTracks.length;
    track = tracksLength > 0 ? mediaElement.textTracks[tracksLength - 1] : mediaElement.addTextTrack(kind);
    track.mode = hidden ? track.HIDDEN : track.SHOWING;
  } else {
    trackElement = document.createElement("track");
    mediaElement.appendChild(trackElement);
    track = trackElement.track;
    trackElement.kind = kind;
    track.mode = hidden ? "hidden" : "showing";
  }

  return {
    track: track,
    trackElement: trackElement
  };
}

/***/ }),
/* 160 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isVTTCue; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the given cue is an instance of a VTTCue.
 * @param {*} cue
 * @returns {boolean}
 */
function isVTTCue(cue) {
  /* tslint:disable no-unsafe-any */
  return typeof window.VTTCue === "function" && cue instanceof window.VTTCue;
  /* tslint:enable no-unsafe-any */
}

/***/ }),
/* 161 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return onHeightWidthChange; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(207);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(175);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(32);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(149);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(0);
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(31);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var _ResizeObserver = _is_node__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"] ? undefined : window.ResizeObserver;
/* tslint:enable no-unsafe-any */

/**
 * Emit the current height and width of the given `element` on subscribtion
 * and each time it changes.
 *
 * On some browsers, we might not be able to rely on a native API to know when
 * it changes, the `interval` argument allow us to provide us an inverval in
 * milliseconds at which we should query that element's size.
 * @param {HTMLElement} element
 * @param {number} interval
 * @returns {Observable}
 */


function onHeightWidthChange(element, interval) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* defer */ "a"])(function () {
    if (_ResizeObserver !== undefined) {
      var lastHeight = -1;
      var lastWidth = -1;
      return new rxjs__WEBPACK_IMPORTED_MODULE_1__[/* Observable */ "a"](function (obs) {
        var resizeObserver = new _ResizeObserver(function (entries) {
          if (entries.length === 0) {
            _log__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].error("Compat: Resized but no observed element.");
            return;
          }

          var entry = entries[0];
          var _entry$contentRect = entry.contentRect,
              height = _entry$contentRect.height,
              width = _entry$contentRect.width;

          if (height !== lastHeight || width !== lastWidth) {
            lastHeight = height;
            lastWidth = width;
            obs.next({
              height: height,
              width: width
            });
          }
        });
        resizeObserver.observe(element);
        return function () {
          resizeObserver.disconnect();
        };
      });
    }

    return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* interval */ "a"])(interval).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_3__[/* startWith */ "a"])(null), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* map */ "a"])(function () {
      var _element$getBoundingC = element.getBoundingClientRect(),
          height = _element$getBoundingC.height,
          width = _element$getBoundingC.width;

      return {
        height: height,
        width: width
      };
    }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[/* distinctUntilChanged */ "a"])(function (o, n) {
      return o.height === n.height && o.width === n.width;
    }));
  });
}

/***/ }),
/* 162 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return addClassName; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var hasClassList;
/**
 * Add className to an HTMLElement. Do nothing if the className was already
 * added.
 * @param {HTMLElement} elt
 * @param {string} className
 */

function addClassName(elt, className) {
  if (hasClassList === undefined) {
    hasClassList = elt.classList !== undefined &&
    /* tslint:disable no-unbound-method */
    typeof elt.classList.add === "function";
    /* tslint:enable no-unbound-method */
  }

  if (hasClassList) {
    elt.classList.add(className);
  } else {
    var classNamesWithSpaces = " " + elt.className + " ";

    if (classNamesWithSpaces.indexOf(" " + className + " ") < 0) {
      elt.className += " " + className;
    }
  }
}

/***/ }),
/* 163 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isOffline; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Some browsers have a builtin API to know if it's connected at least to a
 * LAN network, at most to the internet.
 *
 * /!\ This feature can be dangerous as you can both have false positives and
 * false negatives.
 *
 * False positives:
 *   - you can still play local contents (on localhost) if isOffline == true
 *   - on some browsers isOffline might be true even if we're connected to a LAN
 *     or a router (it would mean we're just not able to connect to the
 *     Internet). So we can eventually play LAN contents if isOffline == true
 *
 * False negatives:
 *   - in some cases, we even might have isOffline at false when we do not have
 *     any connection:
 *       - in browsers that do not support the feature
 *       - in browsers running in some virtualization softwares where the
 *         network adapters are always connected.
 *
 * Use with these cases in mind.
 * @returns {Boolean}
 */
function isOffline() {
  /* tslint:disable no-boolean-literal-compare */
  return navigator.onLine === false;
  /* tslint:enable no-boolean-literal-compare */
}

/***/ }),
/* 164 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return areSameContent; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Check if two contents are the same
 * @param {Object} content1
 * @param {Object} content2
 * @returns {boolean}
 */
function areSameContent(content1, content2) {
  return content1.segment.id === content2.segment.id && content1.representation.id === content2.representation.id && content1.adaptation.id === content2.adaptation.id && content1.period.id === content2.period.id;
}

/***/ }),
/* 165 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return tryToChangeSourceBufferType; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * If the changeType MSE API is implemented, update the current codec of the
 * SourceBuffer and return true if it succeeded.
 * In any other cases, return false.
 * @param {Object} sourceBuffer
 * @param {string} codec
 * @returns {boolean}
 */

function tryToChangeSourceBufferType(sourceBuffer, codec) {
  if (typeof sourceBuffer.changeType === "function") {
    try {
      sourceBuffer.changeType(codec);
    } catch (e) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Could not call 'changeType' on the given SourceBuffer:", e);
      return false;
    }

    return true;
  }

  return false;
}

/***/ }),
/* 166 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isPlaybackStuck; });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(21);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * firefox fix: sometimes playback can be stalled, even if we are in a buffer.
 * TODO This seems to be about an old Firefox version. Delete it?
 * @param {number} time
 * @param {Object|null} currentRange
 * @param {string} state
 * @param {Boolean} isStalled
 * @returns {Boolean}
 */

function isPlaybackStuck(time, currentRange, state, isStalled) {
  var FREEZE_THRESHOLD = 10; // freeze threshold in seconds

  return _browser_detection__WEBPACK_IMPORTED_MODULE_0__[/* isFirefox */ "a"] && isStalled && state === "timeupdate" && currentRange != null && currentRange.end - time > FREEZE_THRESHOLD;
}

/***/ }),
/* 167 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shouldReloadMediaSourceOnDecipherabilityUpdate; });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if we have to reload the MediaSource due to an update in the
 * decipherability status of some segments based on the current key sytem.
 *
 * We found that on all Widevine targets tested, a simple seek is sufficient.
 * As widevine clients make a good chunk of users, we can make a difference
 * between them and others as it is for the better.
 * @param {string|null} currentKeySystem
 * @returns {Boolean}
 */
function shouldReloadMediaSourceOnDecipherabilityUpdate(currentKeySystem) {
  return currentKeySystem === null || currentKeySystem.indexOf("widevine") < 0;
}

/***/ }),
/* 168 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return identity; });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
    return x;
}
//# sourceMappingURL=identity.js.map


/***/ }),
/* 169 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return concatAll; });
/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);
/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */

function concatAll() {
    return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__[/* mergeAll */ "a"])(1);
}
//# sourceMappingURL=concatAll.js.map


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {

var PENDING = 'pending';
var SETTLED = 'settled';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';
var NOOP = function () {};
var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';

var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;

function asyncFlush() {
	// run promise callbacks
	for (var i = 0; i < asyncQueue.length; i++) {
		asyncQueue[i][0](asyncQueue[i][1]);
	}

	// reset async asyncQueue
	asyncQueue = [];
	asyncTimer = false;
}

function asyncCall(callback, arg) {
	asyncQueue.push([callback, arg]);

	if (!asyncTimer) {
		asyncTimer = true;
		asyncSetTimer(asyncFlush, 0);
	}
}

function invokeResolver(resolver, promise) {
	function resolvePromise(value) {
		resolve(promise, value);
	}

	function rejectPromise(reason) {
		reject(promise, reason);
	}

	try {
		resolver(resolvePromise, rejectPromise);
	} catch (e) {
		rejectPromise(e);
	}
}

function invokeCallback(subscriber) {
	var owner = subscriber.owner;
	var settled = owner._state;
	var value = owner._data;
	var callback = subscriber[settled];
	var promise = subscriber.then;

	if (typeof callback === 'function') {
		settled = FULFILLED;
		try {
			value = callback(value);
		} catch (e) {
			reject(promise, e);
		}
	}

	if (!handleThenable(promise, value)) {
		if (settled === FULFILLED) {
			resolve(promise, value);
		}

		if (settled === REJECTED) {
			reject(promise, value);
		}
	}
}

function handleThenable(promise, value) {
	var resolved;

	try {
		if (promise === value) {
			throw new TypeError('A promises callback cannot return that same promise.');
		}

		if (value && (typeof value === 'function' || typeof value === 'object')) {
			// then should be retrieved only once
			var then = value.then;

			if (typeof then === 'function') {
				then.call(value, function (val) {
					if (!resolved) {
						resolved = true;

						if (value === val) {
							fulfill(promise, val);
						} else {
							resolve(promise, val);
						}
					}
				}, function (reason) {
					if (!resolved) {
						resolved = true;

						reject(promise, reason);
					}
				});

				return true;
			}
		}
	} catch (e) {
		if (!resolved) {
			reject(promise, e);
		}

		return true;
	}

	return false;
}

function resolve(promise, value) {
	if (promise === value || !handleThenable(promise, value)) {
		fulfill(promise, value);
	}
}

function fulfill(promise, value) {
	if (promise._state === PENDING) {
		promise._state = SETTLED;
		promise._data = value;

		asyncCall(publishFulfillment, promise);
	}
}

function reject(promise, reason) {
	if (promise._state === PENDING) {
		promise._state = SETTLED;
		promise._data = reason;

		asyncCall(publishRejection, promise);
	}
}

function publish(promise) {
	promise._then = promise._then.forEach(invokeCallback);
}

function publishFulfillment(promise) {
	promise._state = FULFILLED;
	publish(promise);
}

function publishRejection(promise) {
	promise._state = REJECTED;
	publish(promise);
	if (!promise._handled && isNode) {
		global.process.emit('unhandledRejection', promise._data, promise);
	}
}

function notifyRejectionHandled(promise) {
	global.process.emit('rejectionHandled', promise);
}

/**
 * @class
 */
function Promise(resolver) {
	if (typeof resolver !== 'function') {
		throw new TypeError('Promise resolver ' + resolver + ' is not a function');
	}

	if (this instanceof Promise === false) {
		throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
	}

	this._then = [];

	invokeResolver(resolver, this);
}

Promise.prototype = {
	constructor: Promise,

	_state: PENDING,
	_then: null,
	_data: undefined,
	_handled: false,

	then: function (onFulfillment, onRejection) {
		var subscriber = {
			owner: this,
			then: new this.constructor(NOOP),
			fulfilled: onFulfillment,
			rejected: onRejection
		};

		if ((onRejection || onFulfillment) && !this._handled) {
			this._handled = true;
			if (this._state === REJECTED && isNode) {
				asyncCall(notifyRejectionHandled, this);
			}
		}

		if (this._state === FULFILLED || this._state === REJECTED) {
			// already resolved, call callback async
			asyncCall(invokeCallback, subscriber);
		} else {
			// subscribe
			this._then.push(subscriber);
		}

		return subscriber.then;
	},

	catch: function (onRejection) {
		return this.then(null, onRejection);
	}
};

Promise.all = function (promises) {
	if (!Array.isArray(promises)) {
		throw new TypeError('You must pass an array to Promise.all().');
	}

	return new Promise(function (resolve, reject) {
		var results = [];
		var remaining = 0;

		function resolver(index) {
			remaining++;
			return function (value) {
				results[index] = value;
				if (!--remaining) {
					resolve(results);
				}
			};
		}

		for (var i = 0, promise; i < promises.length; i++) {
			promise = promises[i];

			if (promise && typeof promise.then === 'function') {
				promise.then(resolver(i), reject);
			} else {
				results[i] = promise;
			}
		}

		if (!remaining) {
			resolve(results);
		}
	});
};

Promise.race = function (promises) {
	if (!Array.isArray(promises)) {
		throw new TypeError('You must pass an array to Promise.race().');
	}

	return new Promise(function (resolve, reject) {
		for (var i = 0, promise; i < promises.length; i++) {
			promise = promises[i];

			if (promise && typeof promise.then === 'function') {
				promise.then(resolve, reject);
			} else {
				resolve(promise);
			}
		}
	});
};

Promise.resolve = function (value) {
	if (value && typeof value === 'object' && value.constructor === Promise) {
		return value;
	}

	return new Promise(function (resolve) {
		resolve(value);
	});
};

Promise.reject = function (reason) {
	return new Promise(function (resolve, reject) {
		reject(reason);
	});
};

module.exports = Promise;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(186)))

/***/ }),
/* 171 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NetworkError; });
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68);
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Error linked to network interactions (requests).
 *
 * @class NetworkError
 * @extends Error
 */

var NetworkError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(NetworkError, _Error);

  /**
   * @param {string} code
   * @param {Error} options
   * @param {Boolean} fatal
   */
  function NetworkError(code, options) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), NetworkError.prototype);
    _this.name = "NetworkError";
    _this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__[/* ErrorTypes */ "b"].NETWORK_ERROR;
    _this.xhr = options.xhr === undefined ? null : options.xhr;
    _this.url = options.url;
    _this.status = options.status;
    _this.errorType = options.type;
    _this.code = code;
    _this.message = Object(_error_message__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_this.name, _this.code, options.message);
    _this.fatal = false;
    return _this;
  }
  /**
   * Returns true if the NetworkError is due to the given http error code
   * @param {number} httpErrorCode
   * @returns {Boolean}
   */


  var _proto = NetworkError.prototype;

  _proto.isHttpError = function isHttpError(httpErrorCode) {
    return this.errorType === _error_codes__WEBPACK_IMPORTED_MODULE_0__[/* NetworkErrorTypes */ "c"].ERROR_HTTP_CODE && this.status === httpErrorCode;
  };

  return NetworkError;
}( /*#__PURE__*/_wrapNativeSuper(Error));



/***/ }),
/* 172 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createBoxWithChildren; });
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Speed up string to bytes conversion by memorizing the result
 *
 * The keys here are ISOBMFF box names. The values are the corresponding
 * bytes conversion for putting as an ISOBMFF boxes.
 *
 * Used by the boxName method.
 * @type {Object}
 */

var boxNamesMem = {};
/**
 * Convert the string name of an ISOBMFF box into the corresponding bytes.
 * Has a memorization mechanism to speed-up if you want to translate the
 * same string multiple times.
 * @param {string} str
 * @returns {Uint8Array}
 */

function boxName(str) {
  if (boxNamesMem[str] != null) {
    return boxNamesMem[str];
  }

  var nameInBytes = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* strToBytes */ "q"])(str);
  boxNamesMem[str] = nameInBytes;
  return nameInBytes;
}
/**
 * Create a new ISOBMFF "box" with the given name.
 * @param {string} name - name of the box you want to create, must always
 * be 4 characters (uuid boxes not supported)
 * @param {Uint8Array} buff - content of the box
 * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)
 */


function createBox(name, buff) {
  var len = buff.length + 8;
  return Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* concat */ "h"])(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* itobe4 */ "m"])(len), boxName(name), buff);
}
/**
 * @param {string} name
 * @param {Array.<Uint8Array>} children
 * @returns {Uint8Array}
 */


function createBoxWithChildren(name, children) {
  return createBox(name, _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* concat */ "h"].apply(void 0, children));
}



/***/ }),
/* 173 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return isKnownError; });
/* harmony import */ var _encrypted_media_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93);
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _media_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);
/* harmony import */ var _network_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(171);
/* harmony import */ var _other_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(71);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Whether the error given is a ICustomError.
 * @param {Error} error
 * @returns {Boolean}
 */

function isKnownError(error) {
  return (error instanceof _encrypted_media_error__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] || error instanceof _media_error__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"] || error instanceof _other_error__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"] || error instanceof _network_error__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]) && Object.keys(_error_codes__WEBPACK_IMPORTED_MODULE_1__[/* ErrorTypes */ "b"]).indexOf(error.type) >= 0;
}

/***/ }),
/* 174 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ ReplaySubject_ReplaySubject; });

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js + 1 modules
var AsyncAction = __webpack_require__(86);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js
/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */


var QueueAction_QueueAction = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction["a" /* AsyncAction */]));

//# sourceMappingURL=QueueAction.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js + 1 modules
var AsyncScheduler = __webpack_require__(85);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */


var QueueScheduler_QueueScheduler = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler["a" /* AsyncScheduler */]));

//# sourceMappingURL=QueueScheduler.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/queue.js
/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */


var queue = /*@__PURE__*/ new QueueScheduler_QueueScheduler(QueueAction_QueueAction);
//# sourceMappingURL=queue.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Notification.js
var Notification = __webpack_require__(77);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/observeOn.js
/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */



function observeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
var ObserveOnOperator = /*@__PURE__*/ (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new observeOn_ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());

var observeOn_ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification["a" /* Notification */].createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification["a" /* Notification */].createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification["a" /* Notification */].createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber["a" /* Subscriber */]));

var ObserveOnMessage = /*@__PURE__*/ (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());

//# sourceMappingURL=observeOn.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = __webpack_require__(58);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/SubjectSubscription.js
var SubjectSubscription = __webpack_require__(105);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js
/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */







var ReplaySubject_ReplaySubject = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError["a" /* ObjectUnsubscribedError */]();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription["a" /* Subscription */].EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription["a" /* SubjectSubscription */](this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject["a" /* Subject */]));

var ReplayEvent = /*@__PURE__*/ (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());
//# sourceMappingURL=ReplaySubject.js.map


/***/ }),
/* 175 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return startWith; });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
/** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */


function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__[/* isScheduler */ "a"])(scheduler)) {
        array.pop();
        return function (source) { return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__[/* concat */ "a"])(array, source, scheduler); };
    }
    else {
        return function (source) { return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__[/* concat */ "a"])(array, source); };
    }
}
//# sourceMappingURL=startWith.js.map


/***/ }),
/* 176 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return mapTo; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function mapTo(value) {
    return function (source) { return source.lift(new MapToOperator(value)); };
}
var MapToOperator = /*@__PURE__*/ (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=mapTo.js.map


/***/ }),
/* 177 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return takeUntil; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function takeUntil(notifier) {
    return function (source) { return source.lift(new TakeUntilOperator(notifier)); };
}
var TakeUntilOperator = /*@__PURE__*/ (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__[/* subscribeToResult */ "a"])(takeUntilSubscriber, this.notifier);
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__[/* OuterSubscriber */ "a"]));
//# sourceMappingURL=takeUntil.js.map


/***/ }),
/* 178 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return shareReplay; });
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(174);
/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */

function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var config;
    if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
    }
    else {
        config = {
            bufferSize: configOrBufferSize,
            windowTime: windowTime,
            refCount: false,
            scheduler: scheduler
        };
    }
    return function (source) { return source.lift(shareReplayOperator(config)); };
}
function shareReplayOperator(_a) {
    var _b = _a.bufferSize, bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b, _c = _a.windowTime, windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c, useRefCount = _a.refCount, scheduler = _a.scheduler;
    var subject;
    var refCount = 0;
    var subscription;
    var hasError = false;
    var isComplete = false;
    return function shareReplayOperation(source) {
        refCount++;
        if (!subject || hasError) {
            hasError = false;
            subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__[/* ReplaySubject */ "a"](bufferSize, windowTime, scheduler);
            subscription = source.subscribe({
                next: function (value) { subject.next(value); },
                error: function (err) {
                    hasError = true;
                    subject.error(err);
                },
                complete: function () {
                    isComplete = true;
                    subject.complete();
                },
            });
        }
        var innerSub = subject.subscribe(this);
        this.add(function () {
            refCount--;
            innerSub.unsubscribe();
            if (subscription && !isComplete && useRefCount && refCount === 0) {
                subscription.unsubscribe();
                subscription = undefined;
                subject = undefined;
            }
        });
    };
}
//# sourceMappingURL=shareReplay.js.map


/***/ }),
/* 179 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return filter; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=filter.js.map


/***/ }),
/* 180 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return mergeMapTo; });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function mergeMapTo(innerObservable, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__[/* mergeMap */ "a"])(function () { return innerObservable; }, resultSelector, concurrent);
    }
    if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__[/* mergeMap */ "a"])(function () { return innerObservable; }, concurrent);
}
//# sourceMappingURL=mergeMapTo.js.map


/***/ }),
/* 181 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return share; });
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(92);
/* harmony import */ var _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(125);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43);
/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */



function shareSubjectFactory() {
    return new _Subject__WEBPACK_IMPORTED_MODULE_2__[/* Subject */ "a"]();
}
function share() {
    return function (source) { return Object(_refCount__WEBPACK_IMPORTED_MODULE_1__[/* refCount */ "a"])()(Object(_multicast__WEBPACK_IMPORTED_MODULE_0__[/* multicast */ "a"])(shareSubjectFactory)(source)); };
}
//# sourceMappingURL=share.js.map


/***/ }),
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 187 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/**
 * @param {UInt8Array} buf
 * @returns {Object}
 */

function parseBif(buf) {
  var pos = 0;
  var length = buf.length;
  var fileFormat = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* bytesToStr */ "f"])(buf.subarray(pos, pos + 8));
  pos += 8;

  if (fileFormat !== "\x89BIF\r\n\x1A\n") {
    throw new Error("Invalid BIF file");
  }

  var minorVersion = buf[pos];
  pos += 1;
  var majorVersion = buf[pos];
  pos += 1;
  var patchVersion = buf[pos];
  pos += 1;
  var increVersion = buf[pos];
  pos += 1;
  var version = [minorVersion, majorVersion, patchVersion, increVersion].join(".");

  if (majorVersion > 0) {
    throw new Error("Unhandled version: " + majorVersion);
  }

  var imageCount = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le4toi */ "p"])(buf, pos);
  pos += 4;
  var framewiseSeparation = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le4toi */ "p"])(buf, pos);
  pos += 4;
  var format = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* bytesToStr */ "f"])(buf.subarray(pos, pos + 4));
  pos += 4;
  var width = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le2toi */ "o"])(buf, pos);
  pos += 2;
  var height = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le2toi */ "o"])(buf, pos);
  pos += 2;
  var aspectRatio = [buf[pos], buf[pos + 1]].join(":");
  pos += 2;
  var isVod = buf[pos] === 1;
  pos += 1; // bytes 0x1F to 0x40 is unused data for now

  pos = 0x40;
  var thumbs = [];

  if (imageCount === 0) {
    throw new Error("bif: no images to parse");
  }

  var index = 0;
  var previousImageInfo = null;

  while (pos < length) {
    var currentImageTimestamp = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le4toi */ "p"])(buf, pos);
    pos += 4;
    var currentImageOffset = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le4toi */ "p"])(buf, pos);
    pos += 4;

    if (previousImageInfo !== null) {
      // calculate for index-1
      var ts = previousImageInfo.timestamp * framewiseSeparation;
      var duration = framewiseSeparation;
      var data = buf.slice(previousImageInfo.offset, currentImageOffset);
      thumbs.push({
        index: index,
        duration: duration,
        ts: ts,
        data: data
      });
      index++;
    }

    if (currentImageTimestamp === 0xFFFFFFFF) {
      break;
    }

    previousImageInfo = {
      timestamp: currentImageTimestamp,
      offset: currentImageOffset
    };
  }

  return {
    fileFormat: "BIF",
    version: version,
    imageCount: imageCount,
    timescale: 1000,
    format: format,
    width: width,
    height: height,
    aspectRatio: aspectRatio,
    isVod: isVod,
    thumbs: thumbs
  };
}

/* harmony default export */ __webpack_exports__["default"] = (parseBif);

/***/ }),
/* 188 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getPlayReadyKIDFromPrivateData; });
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse PlayReady privateData to get its Hexa-coded KeyID.
 * @param {Uint8Array} privateData
 * @returns {string}
 */

function getPlayReadyKIDFromPrivateData(data) {
  var xmlLength = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* le2toi */ "o"])(data, 8);
  var xml = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* bytesToUTF16Str */ "g"])(data.subarray(10, xmlLength + 10));
  var doc = new DOMParser().parseFromString(xml, "application/xml");
  var kidElement = doc.querySelector("KID");

  if (kidElement === null) {
    throw new Error("Cannot parse PlayReady private data: invalid XML");
  }

  var kid = kidElement.textContent === null ? "" : kidElement.textContent;
  return Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__[/* guidToUuid */ "i"])(atob(kid)).toLowerCase();
}

/***/ }),
/* 189 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119);
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */


var HTML_ENTITIES = /&#([0-9]+);/g;
var BR = /<br>/gi;
var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
var PARAG = /\s*<p (?:class=([^>]+))?>(.*)/i;
var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
/**
 * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.
 * @param {Array.<Object>} cuesArray - Objects containing the start, end and
 * text.
 * @returns {Array.<VTTCue>}
 */

function createCuesFromArray(cuesArray) {
  var nativeCues = [];

  for (var i = 0; i < cuesArray.length; i++) {
    var _cuesArray$i = cuesArray[i],
        start = _cuesArray$i.start,
        end = _cuesArray$i.end,
        text = _cuesArray$i.text;

    if (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(text) && end != null) {
      var cue = Object(_compat__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(start, end, text);

      if (cue != null) {
        nativeCues.push(cue);
      }
    }
  }

  return nativeCues;
}
/**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */


function getClassNameByLang(str) {
  var ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
  var langs = {};
  var m = ruleRe.exec(str);

  while (Array.isArray(m)) {
    var name = m[1];
    var lang = getCSSProperty(m[2], "lang");

    if (name != null && lang != null) {
      langs[lang] = name;
    }

    m = ruleRe.exec(str);
  }

  return langs;
}
/**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */


function getCSSProperty(str, name) {
  var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
  return Array.isArray(matches) ? matches[1] : null;
}
/**
 * Decode HMTL formatting into a string.
 * @param {string} text
 * @returns {string}
 */


function decodeEntities(text) {
  return text.replace(BR, "\n")
  /* tslint:disable no-unsafe-any */
  .replace(HTML_ENTITIES, function (_, $1) {
    return String.fromCharCode($1);
  });
  /* tslint:enable no-unsafe-any */
}
/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 * @returns {Array.<VTTCue|TextTrackCue>}
 */


function parseSami(smi, timeOffset, lang) {
  var syncOpen = /<sync[ >]/ig;
  var syncClose = /<sync[ >]|<\/body>/ig;
  var subs = [];
  var styleMatches = smi.match(STYLE);
  var css = styleMatches !== null ? styleMatches[1] : "";
  var up;
  var to; // FIXME Is that wanted?
  // previously written as let to = SyncClose.exec(smi); but never used

  syncClose.exec(smi);
  var langs = getClassNameByLang(css);
  var klass;

  if (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(lang)) {
    klass = langs[lang];

    if (klass === undefined) {
      throw new Error("sami: could not find lang " + lang + " in CSS");
    }
  }

  while (true) {
    up = syncOpen.exec(smi);
    to = syncClose.exec(smi);

    if (up === null && to === null) {
      break;
    }

    if (up === null || to === null || up.index >= to.index) {
      throw new Error("parse error");
    }

    var str = smi.slice(up.index, to.index);
    var tim = str.match(START);

    if (tim === null) {
      throw new Error("parse error (sync time attribute)");
    }

    var start = +tim[1];

    if (isNaN(start)) {
      throw new Error("parse error (sync time attribute NaN)");
    }

    appendToSubs(str.split("\n"), start / 1000);
  }

  return createCuesFromArray(subs);

  function appendToSubs(lines, start) {
    var i = lines.length;
    var m;

    while (--i >= 0) {
      m = lines[i].match(PARAG);

      if (m === null) {
        continue;
      }

      var _m = m,
          kl = _m[1],
          txt = _m[2];

      if (klass !== kl) {
        continue;
      }

      if (txt === "&nbsp;") {
        subs[subs.length - 1].end = start;
      } else {
        subs.push({
          text: decodeEntities(txt),
          start: start + timeOffset
        });
      }
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (parseSami);

/***/ }),
/* 190 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseSRTStringToVTTCues; });
/* harmony import */ var _compat_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(119);
/* harmony import */ var _get_cue_blocks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(131);
/* harmony import */ var _parse_cue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(132);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
// srt to VTTCue parser, Done for fun.
// Heavily inspired from the WebVTT implementation



/**
 * Parse whole srt file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */

function parseSRTStringToVTTCues(srtStr, timeOffset) {
  // Even if srt only authorize CRLF, we will also take LF or CR as line
  // terminators for resilience
  var lines = srtStr.split(/\r\n|\n|\r/);
  var cueBlocks = Object(_get_cue_blocks__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(lines);
  var cues = [];

  for (var i = 0; i < cueBlocks.length; i++) {
    var cueObject = Object(_parse_cue__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(cueBlocks[i], timeOffset);

    if (cueObject !== null) {
      var nativeCue = toNativeCue(cueObject);

      if (nativeCue !== null) {
        cues.push(nativeCue);
      }
    }
  }

  return cues;
}
/**
 * @param {Object} cue Object
 * @returns {TextTrackCue|VTTCue|null}
 */

function toNativeCue(cueObj) {
  var start = cueObj.start,
      end = cueObj.end,
      payload = cueObj.payload;
  var text = payload.join("\n");
  return Object(_compat_index__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(start, end, text);
}

/***/ }),
/* 191 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:
//   - the text, start and end times are correctly parsed.
//   - only text for the given language is parsed.
//   - only the CSS style associated to the P element is set.
//   - we should be safe for any XSS.
// The language indicated to the parser should be present in the CSS and the
// corresponding Class should be on the P elements. If we fail to find the
// language in a "lang" property of a CSS class, the parser will throw.

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

var HTML_ENTITIES = /&#([0-9]+);/g;
var BR = /<br>/gi;
var STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
var PARAG = /\s*<p (?:class=([^>]+))?>(.*)/i;
var START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
/**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */

function getClassNameByLang(str) {
  var ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
  var langs = {};
  var m = ruleRe.exec(str);

  while (m !== null) {
    var name = m[1];
    var lang = getCSSProperty(m[2], "lang");

    if (name != null && lang != null) {
      langs[lang] = name;
    }

    m = ruleRe.exec(str);
  }

  return langs;
}
/**
 * Returns the rules defined for the P element.
 * Empty string if not found.
 * @param {string} str - The entire styling part.
 * @returns {string}
 */


function getPCSSRules(str) {
  var pRuleRegex = /p\s*{([^}]*)}/gi;
  var rule = pRuleRegex.exec(str);

  if (rule === null) {
    return "";
  }

  return rule[1];
}
/**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */


function getCSSProperty(str, name) {
  var matches = str.match(new RegExp("\\s*" + name + ":\\s*(\\S+);", "i"));
  return Array.isArray(matches) ? matches[1] : null;
}
/**
 * @param {string} text
 * @returns {string}
 */


function decodeEntities(text) {
  return text
  /* tslint:disable no-unsafe-any */
  .replace(HTML_ENTITIES, function (_, $1) {
    return String.fromCharCode($1);
  });
  /* tslint:enable no-unsafe-any */
}
/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 */


function parseSami(smi, timeOffset, lang) {
  var syncOpen = /<sync[ >]/ig;
  var syncClose = /<sync[ >]|<\/body>/ig;
  var subs = [];
  var styleMatches = smi.match(STYLE);
  var css = Array.isArray(styleMatches) ? styleMatches[1] : "";
  var up;
  var to; // FIXME Is that wanted?
  // previously written as let to = SyncClose.exec(smi); but never used

  syncClose.exec(smi);
  var langs = getClassNameByLang(css);
  var pCSS = getPCSSRules(css);
  var klass;

  if (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(lang)) {
    klass = langs[lang];

    if (klass === undefined) {
      throw new Error("sami: could not find lang " + lang + " in CSS");
    }
  }

  while (true) {
    up = syncOpen.exec(smi);
    to = syncClose.exec(smi);

    if (up === null && to === null) {
      break;
    }

    if (up === null || to === null || up.index >= to.index) {
      throw new Error("parse error");
    }

    var str = smi.slice(up.index, to.index);
    var tim = str.match(START);

    if (!Array.isArray(tim)) {
      throw new Error("parse error (sync time attribute)");
    }

    var start = +tim[1];

    if (isNaN(start)) {
      throw new Error("parse error (sync time attribute NaN)");
    }

    appendToSubs(str.split("\n"), start / 1000);
  }

  return subs;

  function appendToSubs(lines, start) {
    var i = lines.length;

    while (--i >= 0) {
      var paragraphInfos = lines[i].match(PARAG);

      if (!Array.isArray(paragraphInfos)) {
        continue;
      }

      var className = paragraphInfos[1],
          txt = paragraphInfos[2];

      if (klass !== className) {
        continue;
      }

      if (txt === "&nbsp;") {
        subs[subs.length - 1].end = start;
      } else {
        var wrapperEl = document.createElement("DIV");
        wrapperEl.className = "rxp-texttrack-region";
        var divEl = document.createElement("DIV");
        divEl.className = "rxp-texttrack-div";
        divEl.style.position = "absolute";
        divEl.style.bottom = "0";
        divEl.style.width = "100%";
        divEl.style.color = "#fff";
        divEl.style.textShadow = "-1px -1px 0 #000," + "1px -1px 0 #000," + "-1px 1px 0 #000," + "1px 1px 0 #000";
        var pEl = document.createElement("div");
        pEl.className = "rxp-texttrack-p";

        if (Object(_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(pCSS)) {
          pEl.style.cssText = pCSS;
        }

        var textEls = txt.split(BR);

        for (var j = 0; j < textEls.length; j++) {
          if (j !== 0) {
            pEl.appendChild(document.createElement("BR"));
          }

          var spanEl = document.createElement("SPAN");
          spanEl.className = "rxp-texttrack-span";
          spanEl.textContent = decodeEntities(textEls[j]);
          pEl.appendChild(spanEl);
        }

        divEl.appendChild(pEl);
        wrapperEl.appendChild(divEl);
        subs.push({
          element: wrapperEl,
          start: start + timeOffset,
          end: -1
        });
      }
    }
  }
}

/* harmony default export */ __webpack_exports__["default"] = (parseSami);

/***/ }),
/* 192 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseSRTStringToHTML; });
/* harmony import */ var _get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(131);
/* harmony import */ var _parse_cue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(132);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
// Parse SRT subtitles into HTML.
// Done for fun. Understand <b>, <i>, <u> and <font color="#ff0000" /> type
// of tags.


/**
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */

function parseSRTStringToHTML(srtStr, timeOffset) {
  // Even if srt only authorize CRLF, we will also take LF or CR as line
  // terminators for resilience
  var lines = srtStr.split(/\r\n|\n|\r/);
  var cueBlocks = Object(_get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(lines);
  var cues = [];

  for (var i = 0; i < cueBlocks.length; i++) {
    var cueObject = Object(_parse_cue__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(cueBlocks[i], timeOffset);

    if (cueObject != null) {
      var htmlCue = toHTML(cueObject);

      if (htmlCue != null) {
        cues.push(htmlCue);
      }
    }
  }

  return cues;
}
/**
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object|null}
 */

function toHTML(cueObj) {
  var start = cueObj.start,
      end = cueObj.end,
      payload = cueObj.payload;
  var pEl = document.createElement("div");
  pEl.className = "rxp-texttrack-p";
  pEl.style.fontSize = "28px";
  pEl.style.position = "absolute";
  pEl.style.bottom = "5%";
  pEl.style.width = "100%";
  pEl.style.textAlign = "center";
  pEl.style.color = "#fff";
  pEl.style.textShadow = "-1px -1px 2px #000," + "1px -1px 2px #000," + "-1px 1px 2px #000," + "1px 1px 2px #000";

  for (var i = 0; i < payload.length; i++) {
    if (i !== 0) {
      pEl.appendChild(document.createElement("br"));
    }

    var span = generateSpansFromSRTText(payload[i]);
    pEl.appendChild(span);
  }

  return {
    start: start,
    end: end,
    element: pEl
  };
}
/**
 * Take a single srt line and convert it into a span with the right style while
 * avoiding XSS.
 * What we do is set a whitelist of authorized tags, and recreate the
 * corresponding tag from scratch.
 * Supported tags:
 *   - <b>: make content bold
 *   - <i>: make content italic
 *   - <u>: draw underline on content
 *   - <font color="x">: add color x to the content
 * @param {string} text
 * @returns {HTMLElement}
 */


function generateSpansFromSRTText(text) {
  var secureDiv = document.createElement("div");
  secureDiv.innerHTML = text;

  var _loop = function _loop(node) {
    var childNodes = node.childNodes;
    var span = document.createElement("span");
    span.className = "rxp-texttrack-span";

    for (var i = 0; i < childNodes.length; i++) {
      var currentNode = childNodes[i];

      if (currentNode.nodeName === "#text") {
        var linifiedText = currentNode.wholeText.split("\n");

        for (var line = 0; line < linifiedText.length; line++) {
          if (line !== 0) {
            span.appendChild(document.createElement("br"));
          }

          if (linifiedText[line].length > 0) {
            var textNode = document.createTextNode(linifiedText[line]);
            span.appendChild(textNode);
          }
        }
      } else if (currentNode.nodeName === "B") {
        var spanChild = _loop(currentNode);

        spanChild.style.fontWeight = "bold";
        span.appendChild(spanChild);
      } else if (currentNode.nodeName === "I") {
        var _spanChild = _loop(currentNode);

        _spanChild.style.fontStyle = "italic";
        span.appendChild(_spanChild);
      } else if (currentNode.nodeName === "U") {
        var _spanChild2 = _loop(currentNode);

        _spanChild2.style.textDecoration = "underline";
        span.appendChild(_spanChild2);
      } else if (currentNode.nodeName === "FONT" && currentNode.color != null) {
        // TODO loop through attributes to find color?
        var _spanChild3 = _loop(currentNode);
        /* tslint:disable no-unsafe-any */


        _spanChild3.style.color = currentNode.color;
        /* tslint:enable no-unsafe-any */

        span.appendChild(_spanChild3);
      } else {
        var _spanChild4 = _loop(currentNode);

        span.appendChild(_spanChild4);
      }
    }

    return span;
  };

  return _loop(secureDiv);
}

/***/ }),
/* 193 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return initializeDirectfileContent; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(94);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(88);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(47);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(211);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(181);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(32);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(179);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(138);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(180);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(150);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(90);
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(142);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(52);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(0);
/* harmony import */ var _create_eme_manager__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(124);
/* harmony import */ var _events_generators__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(30);
/* harmony import */ var _get_stalled_events__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(128);
/* harmony import */ var _initial_seek_and_play__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(122);
/* harmony import */ var _is_eme_ready__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(129);
/* harmony import */ var _throw_on_media_error__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(126);
/* harmony import */ var _update_playback_rate__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(127);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */












/**
 * calculate initial time as a position in seconds.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object|undefined} startAt
 * @returns {number}
 */

function getDirectFileInitialTime(mediaElement, startAt) {
  if (startAt == null) {
    return 0;
  }

  if (startAt.position != null) {
    return startAt.position;
  } else if (startAt.wallClockTime != null) {
    return startAt.wallClockTime;
  } else if (startAt.fromFirstPosition != null) {
    return startAt.fromFirstPosition;
  }

  var duration = mediaElement.duration;

  if (duration == null || !isFinite(duration)) {
    _log__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].warn("startAt.fromLastPosition set but no known duration, " + "beginning at 0.");
    return 0;
  }

  if (typeof startAt.fromLastPosition === "number") {
    return Math.max(0, duration + startAt.fromLastPosition);
  } else if (startAt.percentage != null) {
    var percentage = startAt.percentage;

    if (percentage >= 100) {
      return duration;
    } else if (percentage <= 0) {
      return 0;
    }

    var ratio = +percentage / 100;
    return duration * ratio;
  }

  return 0;
}
/**
 * Launch a content in "Directfile mode".
 * @param {Object} directfileOptions
 * @returns {Observable}
 */


function initializeDirectfileContent(_ref) {
  var autoPlay = _ref.autoPlay,
      clock$ = _ref.clock$,
      keySystems = _ref.keySystems,
      mediaElement = _ref.mediaElement,
      speed$ = _ref.speed$,
      startAt = _ref.startAt,
      url = _ref.url;
  Object(_compat__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"])(mediaElement);

  if (url == null) {
    throw new Error("No URL for a DirectFile content");
  } // Start everything! (Just put the URL in the element's src).


  var linkURL$ = Object(_compat__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"])(mediaElement, url);
  _log__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].debug("Init: Calculating initial time");

  var initialTime = function initialTime() {
    return getDirectFileInitialTime(mediaElement, startAt);
  };

  _log__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].debug("Init: Initial time calculated:", initialTime);

  var _seekAndLoadOnMediaEv = Object(_initial_seek_and_play__WEBPACK_IMPORTED_MODULE_19__[/* default */ "a"])({
    clock$: clock$,
    mediaElement: mediaElement,
    startTime: initialTime,
    mustAutoPlay: autoPlay,
    isDirectfile: true
  }),
      seek$ = _seekAndLoadOnMediaEv.seek$,
      load$ = _seekAndLoadOnMediaEv.load$; // Create EME Manager, an observable which will manage every EME-related
  // issue.


  var emeManager$ = linkURL$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* mergeMap */ "a"])(function () {
    return Object(_create_eme_manager__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"])(mediaElement, keySystems, rxjs__WEBPACK_IMPORTED_MODULE_0__[/* EMPTY */ "a"]);
  }), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_5__[/* subscribeOn */ "a"])(rxjs__WEBPACK_IMPORTED_MODULE_1__[/* asap */ "a"]), // multiple Observables here are based on this one
  Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_6__[/* share */ "a"])()); // Translate errors coming from the media element into RxPlayer errors
  // through a throwing Observable.

  var mediaError$ = Object(_throw_on_media_error__WEBPACK_IMPORTED_MODULE_21__[/* default */ "a"])(mediaElement); // Set the speed set by the user on the media element while pausing a
  // little longer while the buffer is empty.

  var playbackRate$ = Object(_update_playback_rate__WEBPACK_IMPORTED_MODULE_22__[/* default */ "a"])(mediaElement, speed$, clock$, {
    pauseWhenStalled: true
  }).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__[/* map */ "a"])(_events_generators__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"].speedChanged)); // Create Stalling Manager, an observable which will try to get out of
  // various infinite stalling issues

  var stalled$ = Object(_get_stalled_events__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(clock$).pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_7__[/* map */ "a"])(_events_generators__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"].stalled)); // Manage "loaded" event and warn if autoplay is blocked on the current browser

  var loadedEvent$ = emeManager$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__[/* filter */ "a"])(_is_eme_ready__WEBPACK_IMPORTED_MODULE_20__[/* default */ "a"]), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__[/* take */ "a"])(1), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_10__[/* mergeMapTo */ "a"])(load$), Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__[/* mergeMap */ "a"])(function (evt) {
    if (evt === "autoplay-blocked") {
      var error = new _errors__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"]("MEDIA_ERR_BLOCKED_AUTOPLAY", "Cannot trigger auto-play automatically: " + "your browser does not allow it.");
      return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* of */ "a"])(_events_generators__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"].warning(error), _events_generators__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"].loaded(null));
    } else if (evt === "not-loaded-metadata") {
      var _error = new _errors__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"]("MEDIA_ERR_NOT_LOADED_METADATA", "Cannot load automatically: your browser " + "falsely announced having loaded the content.");

      return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* of */ "a"])(_events_generators__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"].warning(_error));
    }

    return Object(rxjs__WEBPACK_IMPORTED_MODULE_2__[/* of */ "a"])(_events_generators__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"].loaded(null));
  }));
  var initialSeek$ = seek$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_11__[/* ignoreElements */ "a"])());
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_3__[/* merge */ "a"])(loadedEvent$, initialSeek$, emeManager$, mediaError$, playbackRate$, stalled$);
}

/***/ }),
/* 194 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MediaElementTrackChoiceManager; });
/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _utils_languages__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50);
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Check if track array is different from an other one
 * @param {Array.<Object>} oldTrackArray
 * @param {Array.<Object>} newTrackArray
 * @returns {boolean}
 */

function areTrackArraysDifferent(oldTrackArray, newTrackArray) {
  var _a;

  if (newTrackArray.length !== oldTrackArray.length) {
    return true;
  }

  for (var i = 0; i < newTrackArray.length; i++) {
    if (newTrackArray[i].nativeTrack !== ((_a = oldTrackArray[i]) === null || _a === void 0 ? void 0 : _a.nativeTrack)) {
      return true;
    }
  }

  return false;
}
/**
 * Create audio tracks from native audio tracks.
 * @param {AudioTrackList} audioTracks
 * @returns {Array.<Object>}
 */


function createAudioTracks(audioTracks) {
  var _a;

  var newAudioTracks = [];
  var languagesOccurences = {};

  for (var i = 0; i < audioTracks.length; i++) {
    var audioTrack = audioTracks[i];
    var language = audioTrack.language === "" ? "nolang" : audioTrack.language;
    var occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;
    var id = "gen_audio_" + language + "_" + occurences.toString();
    languagesOccurences[language] = occurences + 1;
    var track = {
      language: audioTrack.language,
      id: id,
      normalized: Object(_utils_languages__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(audioTrack.language),
      audioDescription: false
    };
    newAudioTracks.push({
      track: track,
      nativeTrack: audioTrack
    });
  }

  return newAudioTracks;
}
/**
 * Create text tracks from native text tracks.
 * @param {TextTrackList} textTracks
 * @returns {Array.<Object>}
 */


function createTextTracks(textTracks) {
  var _a;

  var newTextTracks = [];
  var languagesOccurences = {};

  for (var i = 0; i < textTracks.length; i++) {
    var textTrack = textTracks[i];
    var language = textTrack.language === "" ? "nolang" : textTrack.language;
    var occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;
    var id = "gen_text_" + language + "_" + occurences.toString();
    languagesOccurences[language] = occurences + 1;
    var track = {
      language: textTrack.language,
      id: id,
      normalized: Object(_utils_languages__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(textTrack.language),
      closedCaption: textTrack.kind === "captions"
    };
    newTextTracks.push({
      track: track,
      nativeTrack: textTrack
    });
  }

  return newTextTracks;
}
/**
 * Create video tracks from native video tracks.
 * @param {VideoTrackList} videoTracks
 * @returns {Array.<Object>}
 */


function createVideoTracks(videoTracks) {
  var _a;

  var newVideoTracks = [];
  var languagesOccurences = {};

  for (var i = 0; i < videoTracks.length; i++) {
    var videoTrack = videoTracks[i];
    var language = videoTrack.language === "" ? "nolang" : videoTrack.language;
    var occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;
    var id = "gen_video_" + language + "_" + occurences.toString();
    languagesOccurences[language] = occurences + 1;
    newVideoTracks.push({
      track: {
        id: id,
        representations: []
      },
      nativeTrack: videoTrack
    });
  }

  return newVideoTracks;
}
/**
 * Manage video, audio and text tracks for current direct file content.
 * @class MediaElementTrackChoiceManager
 */


var MediaElementTrackChoiceManager = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(MediaElementTrackChoiceManager, _EventEmitter);

  function MediaElementTrackChoiceManager(defaults, mediaElement) {
    var _this;

    var _a, _b, _c;

    _this = _EventEmitter.call(this) || this;
    var preferredAudioTracks = defaults.preferredAudioTracks,
        preferredTextTracks = defaults.preferredTextTracks;
    _this._preferredAudioTracks = preferredAudioTracks;
    _this._preferredTextTracks = preferredTextTracks; // TODO In practice, the audio/video/text tracks API are not always implemented on
    // the media element, although Typescript HTMLMediaElement types tend to mean
    // that can't be undefined.

    _this._nativeAudioTracks = mediaElement.audioTracks;
    _this._nativeVideoTracks = mediaElement.videoTracks;
    _this._nativeTextTracks = mediaElement.textTracks;
    _this._audioTracks = _this._nativeAudioTracks !== undefined ? createAudioTracks(_this._nativeAudioTracks) : [];
    _this._videoTracks = _this._nativeVideoTracks !== undefined ? createVideoTracks(_this._nativeVideoTracks) : [];
    _this._textTracks = _this._nativeTextTracks !== undefined ? createTextTracks(_this._nativeTextTracks) : [];
    _this._lastEmittedNativeAudioTrack = (_a = _this._getPrivateChosenAudioTrack()) === null || _a === void 0 ? void 0 : _a.nativeTrack;
    _this._lastEmittedNativeVideoTrack = (_b = _this._getPrivateChosenVideoTrack()) === null || _b === void 0 ? void 0 : _b.nativeTrack;
    _this._lastEmittedNativeTextTrack = (_c = _this._getPrivateChosenTextTrack()) === null || _c === void 0 ? void 0 : _c.nativeTrack;

    _this._handleNativeTracksCallbacks();

    return _this;
  }
  /**
   * Update the currently active audio track by setting the wanted audio track's
   * ID property.
   * Throws if the wanted audio track is not found.
   * @param {string|number|undefined} id
   */


  var _proto = MediaElementTrackChoiceManager.prototype;

  _proto.setAudioTrackById = function setAudioTrackById(id) {
    for (var i = 0; i < this._audioTracks.length; i++) {
      var _this$_audioTracks$i = this._audioTracks[i],
          track = _this$_audioTracks$i.track,
          nativeTrack = _this$_audioTracks$i.nativeTrack;

      if (track.id === id) {
        nativeTrack.enabled = true;
        return;
      }
    }

    throw new Error("Audio track not found.");
  }
  /**
   * Disable the currently-active text track, if one.
   */
  ;

  _proto.disableTextTrack = function disableTextTrack() {
    for (var i = 0; i < this._textTracks.length; i++) {
      var nativeTrack = this._textTracks[i].nativeTrack;
      nativeTrack.mode = "disabled";
    }
  }
  /**
   * Update the currently active text track by setting the wanted text track's
   * ID property.
   * Throws if the wanted text track is not found.
   * @param {string|number|undefined} id
   */
  ;

  _proto.setTextTrackById = function setTextTrackById(id) {
    var hasSetTrack = false;

    for (var i = 0; i < this._textTracks.length; i++) {
      var _this$_textTracks$i = this._textTracks[i],
          track = _this$_textTracks$i.track,
          nativeTrack = _this$_textTracks$i.nativeTrack;

      if (track.id === id) {
        nativeTrack.mode = "showing";
        hasSetTrack = true;
      } else if (nativeTrack.mode === "showing" || nativeTrack.mode === "hidden") {
        nativeTrack.mode = "disabled";
      }
    }

    if (!hasSetTrack) {
      throw new Error("Text track not found.");
    }
  }
  /**
   * Update the currently active video track by setting the wanted video track's
   * ID property.
   * Throws if the wanted video track is not found.
   * @param {string|number|undefined} id
   */
  ;

  _proto.setVideoTrackById = function setVideoTrackById(id) {
    for (var i = 0; i < this._videoTracks.length; i++) {
      var _this$_videoTracks$i = this._videoTracks[i],
          track = _this$_videoTracks$i.track,
          nativeTrack = _this$_videoTracks$i.nativeTrack;

      if (track.id === id) {
        nativeTrack.selected = true;
        return;
      }
    }

    throw new Error("Video track not found.");
  }
  /**
   * Returns the currently active audio track.
   * Returns `null` if no audio track is active.
   * Returns `undefined` if we cannot know which audio track is active.
   * @returns {Object|null|undefined}
   */
  ;

  _proto.getChosenAudioTrack = function getChosenAudioTrack() {
    var chosenPrivateAudioTrack = this._getPrivateChosenAudioTrack();

    if (chosenPrivateAudioTrack != null) {
      return chosenPrivateAudioTrack.track;
    }

    return chosenPrivateAudioTrack;
  }
  /**
   * Returns the currently active text track.
   * Returns `null` if no text track is active.
   * Returns `undefined` if we cannot know which text track is active.
   * @returns {Object|null|undefined}
   */
  ;

  _proto.getChosenTextTrack = function getChosenTextTrack() {
    var chosenPrivateTextTrack = this._getPrivateChosenTextTrack();

    if (chosenPrivateTextTrack != null) {
      return chosenPrivateTextTrack.track;
    }

    return chosenPrivateTextTrack;
  }
  /**
   * Returns the currently active video track.
   * Returns `null` if no video track is active.
   * Returns `undefined` if we cannot know which video track is active.
   * @returns {Object|null|undefined}
   */
  ;

  _proto.getChosenVideoTrack = function getChosenVideoTrack() {
    var chosenPrivateVideoTrack = this._getPrivateChosenVideoTrack();

    if (chosenPrivateVideoTrack != null) {
      return chosenPrivateVideoTrack.track;
    }

    return chosenPrivateVideoTrack;
  }
  /**
   * Returns a description of every available audio tracks.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAvailableAudioTracks = function getAvailableAudioTracks() {
    return this._audioTracks.map(function (_ref) {
      var track = _ref.track,
          nativeTrack = _ref.nativeTrack;
      return {
        id: track.id,
        language: track.language,
        normalized: track.normalized,
        audioDescription: track.audioDescription,
        active: nativeTrack.enabled
      };
    });
  }
  /**
   * Returns a description of every available text tracks.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAvailableTextTracks = function getAvailableTextTracks() {
    return this._textTracks.map(function (_ref2) {
      var track = _ref2.track,
          nativeTrack = _ref2.nativeTrack;
      return {
        id: track.id,
        language: track.language,
        normalized: track.normalized,
        closedCaption: track.closedCaption,
        active: nativeTrack.mode === "showing"
      };
    });
  }
  /**
   * Returns a description of every available video tracks.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAvailableVideoTracks = function getAvailableVideoTracks() {
    return this._videoTracks.map(function (_ref3) {
      var track = _ref3.track,
          nativeTrack = _ref3.nativeTrack;
      return {
        id: track.id,
        representations: track.representations,
        active: nativeTrack.selected
      };
    });
  }
  /**
   * Free the resources used by the MediaElementTrackChoiceManager.
   */
  ;

  _proto.dispose = function dispose() {
    if (this._nativeVideoTracks !== undefined) {
      this._nativeVideoTracks.onchange = null;
      this._nativeVideoTracks.onaddtrack = null;
      this._nativeVideoTracks.onremovetrack = null;
    }

    if (this._nativeAudioTracks !== undefined) {
      this._nativeAudioTracks.onchange = null;
      this._nativeAudioTracks.onaddtrack = null;
      this._nativeAudioTracks.onremovetrack = null;
    }

    if (this._nativeTextTracks !== undefined) {
      this._nativeTextTracks.onchange = null;
      this._nativeTextTracks.onaddtrack = null;
      this._nativeTextTracks.onremovetrack = null;
    }

    this.removeEventListener();
  }
  /**
   * Get information about the currently chosen audio track.
   * `undefined` if we cannot know it.
   * `null` if no audio track is chosen.
   * @returns {Object|undefined|null}
   */
  ;

  _proto._getPrivateChosenAudioTrack = function _getPrivateChosenAudioTrack() {
    if (this._nativeAudioTracks === undefined) {
      return undefined;
    }

    for (var i = 0; i < this._audioTracks.length; i++) {
      var audioTrack = this._audioTracks[i];

      if (audioTrack.nativeTrack.enabled) {
        return audioTrack;
      }
    }

    return null;
  }
  /**
   * Get information about the currently chosen video track.
   * `undefined` if we cannot know it.
   * `null` if no video track is chosen.
   * @returns {Object|undefined|null}
   */
  ;

  _proto._getPrivateChosenVideoTrack = function _getPrivateChosenVideoTrack() {
    if (this._nativeVideoTracks === undefined) {
      return undefined;
    }

    for (var i = 0; i < this._videoTracks.length; i++) {
      var videoTrack = this._videoTracks[i];

      if (videoTrack.nativeTrack.selected) {
        return videoTrack;
      }
    }

    return null;
  }
  /**
   * Get information about the currently chosen text track.
   * `undefined` if we cannot know it.
   * `null` if no text track is chosen.
   * @returns {Object|undefined|null}
   */
  ;

  _proto._getPrivateChosenTextTrack = function _getPrivateChosenTextTrack() {
    if (this._nativeTextTracks === undefined) {
      return undefined;
    }

    for (var i = 0; i < this._textTracks.length; i++) {
      var textTrack = this._textTracks[i];

      if (textTrack.nativeTrack.mode === "showing") {
        return textTrack;
      }
    }

    return null;
  }
  /**
   * Iterate over every available audio tracks on the media element and over
   * every set audio track preferences to activate the preferred audio track
   * on the media element.
   */
  ;

  _proto._setPreferredAudioTrack = function _setPreferredAudioTrack() {
    var preferredAudioTracks = this._preferredAudioTracks.getValue();

    var normalizedTracks = preferredAudioTracks.filter(function (audioTrack) {
      return audioTrack !== null;
    }).map(function (_ref4) {
      var language = _ref4.language,
          audioDescription = _ref4.audioDescription;
      var normalized = Object(_utils_languages__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(language);
      return {
        normalized: normalized,
        audioDescription: audioDescription
      };
    });

    for (var i = 0; i < normalizedTracks.length; i++) {
      var track = normalizedTracks[i];

      for (var j = 0; j < this._audioTracks.length; j++) {
        var audioTrack = this._audioTracks[j];

        if (audioTrack.track.normalized === track.normalized && audioTrack.track.audioDescription === track.audioDescription) {
          this.setAudioTrackById(audioTrack.track.id);
          return;
        }
      }
    }
  }
  /**
   * Iterate over every available text tracks on the media element and over
   * every set text track preferences to activate the preferred text track
   * on the media element.
   */
  ;

  _proto._setPreferredTextTrack = function _setPreferredTextTrack() {
    var preferredTextTracks = this._preferredTextTracks.getValue();

    var normalizedTracks = preferredTextTracks.filter(function (textTrack) {
      return textTrack !== null;
    }).map(function (_ref5) {
      var language = _ref5.language,
          closedCaption = _ref5.closedCaption;
      var normalized = Object(_utils_languages__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(language);
      return {
        normalized: normalized,
        closedCaption: closedCaption
      };
    });

    for (var i = 0; i < normalizedTracks.length; i++) {
      var track = normalizedTracks[i];

      for (var j = 0; j < this._textTracks.length; j++) {
        var textTrack = this._textTracks[j];

        if (textTrack.track.normalized === track.normalized && textTrack.track.closedCaption === track.closedCaption) {
          this.setTextTrackById(textTrack.track.id);
          return;
        }
      }
    }
  }
  /**
   * Monitor native tracks add, remove and change callback and trigger the
   * change events.
   */
  ;

  _proto._handleNativeTracksCallbacks = function _handleNativeTracksCallbacks() {
    var _this2 = this;

    if (this._nativeAudioTracks !== undefined) {
      this._nativeAudioTracks.onaddtrack = function () {
        var _a, _b;

        if (_this2._nativeAudioTracks !== undefined) {
          var newAudioTracks = createAudioTracks(_this2._nativeAudioTracks);

          if (areTrackArraysDifferent(_this2._audioTracks, newAudioTracks)) {
            _this2._audioTracks = newAudioTracks;

            _this2._setPreferredAudioTrack();

            _this2.trigger("availableAudioTracksChange", _this2.getAvailableAudioTracks());

            var chosenAudioTrack = _this2._getPrivateChosenAudioTrack();

            if ((chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== _this2._lastEmittedNativeAudioTrack) {
              _this2.trigger("audioTrackChange", (_a = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.track) !== null && _a !== void 0 ? _a : null);

              _this2._lastEmittedNativeAudioTrack = (_b = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };

      this._nativeAudioTracks.onremovetrack = function () {
        var _a, _b;

        if (_this2._nativeAudioTracks !== undefined) {
          var newAudioTracks = createAudioTracks(_this2._nativeAudioTracks);

          if (areTrackArraysDifferent(_this2._audioTracks, newAudioTracks)) {
            _this2._audioTracks = newAudioTracks;

            _this2._setPreferredAudioTrack();

            _this2.trigger("availableAudioTracksChange", _this2.getAvailableAudioTracks());

            var chosenAudioTrack = _this2._getPrivateChosenAudioTrack();

            if ((chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== _this2._lastEmittedNativeAudioTrack) {
              _this2.trigger("audioTrackChange", (_a = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.track) !== null && _a !== void 0 ? _a : null);

              _this2._lastEmittedNativeAudioTrack = (_b = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };

      this._nativeAudioTracks.onchange = function () {
        if (_this2._audioTracks !== undefined) {
          for (var i = 0; i < _this2._audioTracks.length; i++) {
            var _this2$_audioTracks$i = _this2._audioTracks[i],
                track = _this2$_audioTracks$i.track,
                nativeTrack = _this2$_audioTracks$i.nativeTrack;

            if (nativeTrack.enabled) {
              if (nativeTrack !== _this2._lastEmittedNativeAudioTrack) {
                _this2.trigger("audioTrackChange", track);

                _this2._lastEmittedNativeAudioTrack = nativeTrack;
              }

              return;
            }
          }
        }

        if (_this2._lastEmittedNativeAudioTrack !== null) {
          _this2.trigger("audioTrackChange", null);

          _this2._lastEmittedNativeAudioTrack = null;
        }

        return;
      };
    }

    if (this._nativeTextTracks !== undefined) {
      this._nativeTextTracks.onaddtrack = function () {
        var _a, _b;

        if (_this2._nativeTextTracks !== undefined) {
          var newTextTracks = createTextTracks(_this2._nativeTextTracks);

          if (areTrackArraysDifferent(_this2._textTracks, newTextTracks)) {
            _this2._textTracks = newTextTracks;

            _this2._setPreferredTextTrack();

            _this2.trigger("availableTextTracksChange", _this2.getAvailableTextTracks());

            var chosenTextTrack = _this2._getPrivateChosenTextTrack();

            if ((chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== _this2._lastEmittedNativeTextTrack) {
              _this2.trigger("textTrackChange", (_a = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.track) !== null && _a !== void 0 ? _a : null);

              _this2._lastEmittedNativeTextTrack = (_b = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };

      this._nativeTextTracks.onremovetrack = function () {
        var _a, _b;

        if (_this2._nativeTextTracks !== undefined) {
          var newTextTracks = createTextTracks(_this2._nativeTextTracks);

          if (areTrackArraysDifferent(_this2._textTracks, newTextTracks)) {
            _this2._textTracks = newTextTracks;

            _this2._setPreferredTextTrack();

            _this2.trigger("availableTextTracksChange", _this2.getAvailableTextTracks());

            var chosenTextTrack = _this2._getPrivateChosenTextTrack();

            if ((chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== _this2._lastEmittedNativeTextTrack) {
              _this2.trigger("textTrackChange", (_a = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.track) !== null && _a !== void 0 ? _a : null);

              _this2._lastEmittedNativeTextTrack = (_b = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };

      this._nativeTextTracks.onchange = function () {
        if (_this2._textTracks !== undefined) {
          for (var i = 0; i < _this2._textTracks.length; i++) {
            var _this2$_textTracks$i = _this2._textTracks[i],
                track = _this2$_textTracks$i.track,
                nativeTrack = _this2$_textTracks$i.nativeTrack;

            if (nativeTrack.mode === "showing") {
              if (nativeTrack !== _this2._lastEmittedNativeTextTrack) {
                _this2.trigger("textTrackChange", track);

                _this2._lastEmittedNativeTextTrack = nativeTrack;
              }

              return;
            }
          }
        }

        if (_this2._lastEmittedNativeTextTrack !== null) {
          _this2.trigger("textTrackChange", null);

          _this2._lastEmittedNativeTextTrack = null;
        }

        return;
      };
    }

    if (this._nativeVideoTracks !== undefined) {
      this._nativeVideoTracks.onaddtrack = function () {
        var _a, _b;

        if (_this2._nativeVideoTracks !== undefined) {
          var newVideoTracks = createVideoTracks(_this2._nativeVideoTracks);

          if (areTrackArraysDifferent(_this2._videoTracks, newVideoTracks)) {
            _this2._videoTracks = newVideoTracks;

            _this2.trigger("availableVideoTracksChange", _this2.getAvailableVideoTracks());

            var chosenVideoTrack = _this2._getPrivateChosenVideoTrack();

            if ((chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== _this2._lastEmittedNativeVideoTrack) {
              _this2.trigger("videoTrackChange", (_a = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.track) !== null && _a !== void 0 ? _a : null);

              _this2._lastEmittedNativeVideoTrack = (_b = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };

      this._nativeVideoTracks.onremovetrack = function () {
        var _a, _b;

        if (_this2._nativeVideoTracks !== undefined) {
          var newVideoTracks = createVideoTracks(_this2._nativeVideoTracks);

          if (areTrackArraysDifferent(_this2._videoTracks, newVideoTracks)) {
            _this2._videoTracks = newVideoTracks;

            _this2.trigger("availableVideoTracksChange", _this2.getAvailableVideoTracks());

            var chosenVideoTrack = _this2._getPrivateChosenVideoTrack();

            if ((chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== _this2._lastEmittedNativeVideoTrack) {
              _this2.trigger("videoTrackChange", (_a = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.track) !== null && _a !== void 0 ? _a : null);

              _this2._lastEmittedNativeVideoTrack = (_b = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
            }
          }
        }
      };

      this._nativeVideoTracks.onchange = function () {
        if (_this2._videoTracks !== undefined) {
          for (var i = 0; i < _this2._videoTracks.length; i++) {
            var _this2$_videoTracks$i = _this2._videoTracks[i],
                track = _this2$_videoTracks$i.track,
                nativeTrack = _this2$_videoTracks$i.nativeTrack;

            if (nativeTrack.selected) {
              if (nativeTrack !== _this2._lastEmittedNativeVideoTrack) {
                _this2.trigger("videoTrackChange", track);

                _this2._lastEmittedNativeVideoTrack = nativeTrack;
              }

              return;
            }
          }
        }

        if (_this2._lastEmittedNativeVideoTrack !== null) {
          _this2.trigger("videoTrackChange", null);

          _this2._lastEmittedNativeVideoTrack = null;
        }

        return;
      };
    }
  };

  return MediaElementTrackChoiceManager;
}(_utils_event_emitter__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"]);



/***/ }),
/* 195 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js + 4 modules
var ReplaySubject = __webpack_require__(174);

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = __webpack_require__(58);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/BehaviorSubject.js
/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */



var BehaviorSubject_BehaviorSubject = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError["a" /* ObjectUnsubscribedError */]();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject["a" /* Subject */]));

//# sourceMappingURL=BehaviorSubject.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(88);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js
var empty = __webpack_require__(56);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(215);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(135);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(177);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(149);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/take.js
var take = __webpack_require__(138);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/multicast.js + 1 modules
var multicast = __webpack_require__(92);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/publish.js
/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */


function publish(selector) {
    return selector ?
        Object(multicast["a" /* multicast */])(function () { return new Subject["a" /* Subject */](); }, selector) :
        Object(multicast["a" /* multicast */])(new Subject["a" /* Subject */]());
}
//# sourceMappingURL=publish.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(179);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/share.js
var share = __webpack_require__(181);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
var startWith = __webpack_require__(175);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(176);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(13);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/skipWhile.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function skipWhile(predicate) {
    return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
}
var SkipWhileOperator = /*@__PURE__*/ (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new skipWhile_SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var skipWhile_SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber["a" /* Subscriber */]));
//# sourceMappingURL=skipWhile.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
var switchMapTo = __webpack_require__(223);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js
var mergeMapTo = __webpack_require__(180);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/catchError.js
var catchError = __webpack_require__(209);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(3);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/utils/are_arrays_of_numbers_equal.ts
var are_arrays_of_numbers_equal = __webpack_require__(81);

// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(25);

// EXTERNAL MODULE: ./src/utils/noop.ts
var noop = __webpack_require__(33);

// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(7);

// EXTERNAL MODULE: ./src/utils/promise.ts
var promise = __webpack_require__(34);

// EXTERNAL MODULE: ./src/utils/ranges.ts
var ranges = __webpack_require__(19);

// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(20);

// EXTERNAL MODULE: ./src/compat/index.ts + 1 modules
var compat = __webpack_require__(8);

// EXTERNAL MODULE: ./src/compat/fullscreen.ts
var fullscreen = __webpack_require__(95);

// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(52);

// EXTERNAL MODULE: ./src/errors/is_known_error.ts
var is_known_error = __webpack_require__(173);

// EXTERNAL MODULE: ./src/errors/other_error.ts
var other_error = __webpack_require__(71);

// CONCATENATED MODULE: ./src/errors/format_error.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Format an unknown error into an API-defined error.
 * @param {*} error
 * @returns {Error}
 */

function formatError(error, _ref) {
  var defaultCode = _ref.defaultCode,
      defaultReason = _ref.defaultReason;

  if (Object(is_known_error["a" /* default */])(error)) {
    return error;
  }

  var reason = error instanceof Error ? error.toString() : defaultReason;
  return new other_error["a" /* default */](defaultCode, reason);
}
// EXTERNAL MODULE: ./src/errors/error_codes.ts
var error_codes = __webpack_require__(38);

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(11);

// EXTERNAL MODULE: ./src/core/eme/dispose_eme.ts
var dispose_eme = __webpack_require__(155);

// EXTERNAL MODULE: ./src/core/eme/get_current_key_system.ts
var get_current_key_system = __webpack_require__(156);

// EXTERNAL MODULE: ./src/core/eme/clear_eme_session.ts
var clear_eme_session = __webpack_require__(154);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/asap.js + 3 modules
var asap = __webpack_require__(94);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(47);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/subscribeOn.js + 1 modules
var subscribeOn = __webpack_require__(211);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(151);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(22);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/finalize.js
/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */



function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
var FinallyOperator = /*@__PURE__*/ (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new finalize_FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var finalize_FinallySubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription["a" /* Subscription */](callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber["a" /* Subscriber */]));
//# sourceMappingURL=finalize.js.map

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMap.js
var switchMap = __webpack_require__(136);

// EXTERNAL MODULE: ./src/compat/should_reload_media_source_on_decipherability_update.ts
var should_reload_media_source_on_decipherability_update = __webpack_require__(167);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// CONCATENATED MODULE: ./src/utils/rx-throttle.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function throttle(func) {
  var isPending = false;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return new Observable["a" /* Observable */](function (obs) {
      if (isPending) {
        obs.complete();
        return undefined;
      }

      isPending = true;
      var funcSubscription = func.apply(void 0, args).subscribe(function (i) {
        obs.next(i);
      }, function (e) {
        isPending = false;
        obs.error(e);
      }, function () {
        isPending = false;
        obs.complete();
      });
      return function () {
        funcSubscription.unsubscribe();
        isPending = false;
      };
    });
  };
}
// EXTERNAL MODULE: ./src/utils/take_first_set.ts
var take_first_set = __webpack_require__(16);

// CONCATENATED MODULE: ./src/core/abr/ewma.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Tweaked implementation of an exponential weighted Moving Average.
 * Heavily "inspired" from the shaka-player one (Ewma).
 * @class EWMA
 */
var EWMA = /*#__PURE__*/function () {
  /**
   * @param {number} halfLife
   */
  function EWMA(halfLife) {
    // (half-life = log(1/2) / log(Decay Factor)
    this._alpha = Math.exp(Math.log(0.5) / halfLife);
    this._lastEstimate = 0;
    this._totalWeight = 0;
  }
  /**
   * @param {number} weight
   * @param {number} value
   */


  var _proto = EWMA.prototype;

  _proto.addSample = function addSample(weight, value) {
    var adjAlpha = Math.pow(this._alpha, weight);
    var newEstimate = value * (1 - adjAlpha) + adjAlpha * this._lastEstimate;

    if (!isNaN(newEstimate)) {
      this._lastEstimate = newEstimate;
      this._totalWeight += weight;
    }
  }
  /**
   * @returns {number} value
   */
  ;

  _proto.getEstimate = function getEstimate() {
    var zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);
    return this._lastEstimate / zeroFactor;
  };

  return EWMA;
}();


// CONCATENATED MODULE: ./src/core/abr/bandwidth_estimator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var ABR_MINIMUM_TOTAL_BYTES = config["a" /* default */].ABR_MINIMUM_TOTAL_BYTES,
    ABR_MINIMUM_CHUNK_SIZE = config["a" /* default */].ABR_MINIMUM_CHUNK_SIZE,
    ABR_FAST_EMA = config["a" /* default */].ABR_FAST_EMA,
    ABR_SLOW_EMA = config["a" /* default */].ABR_SLOW_EMA;
/**
 * Calculate a mean bandwidth based on the bytes downloaded and the amount
 * of time needed to do so.
 *
 * Heavily "inspired" from the Shaka-Player's "ewma bandwidth estimator".
 * @class BandwidthEstimator
 */

var bandwidth_estimator_BandwidthEstimator = /*#__PURE__*/function () {
  function BandwidthEstimator() {
    /**
     * A fast-moving average.
     * @private
     */
    this._fastEWMA = new EWMA(ABR_FAST_EMA);
    /**
     * A slow-moving average.
     * @private
     */

    this._slowEWMA = new EWMA(ABR_SLOW_EMA);
    /**
     * Number of bytes sampled.
     * @private
     */

    this._bytesSampled = 0;
  }
  /**
   * Takes a bandwidth sample.
   * @param {number} durationMs - The amount of time, in milliseconds, for a
   *   particular request.
   * @param {number} numBytes - The total number of bytes transferred in that
   *   request.
   */


  var _proto = BandwidthEstimator.prototype;

  _proto.addSample = function addSample(durationInMs, numberOfBytes) {
    if (numberOfBytes < ABR_MINIMUM_CHUNK_SIZE) {
      return;
    }

    var bandwidth = numberOfBytes * 8000 / durationInMs;
    var weight = durationInMs / 1000;
    this._bytesSampled += numberOfBytes;

    this._fastEWMA.addSample(weight, bandwidth);

    this._slowEWMA.addSample(weight, bandwidth);
  }
  /**
   * Get estimate of the bandwidth, in bits per seconds.
   * @returns {Number|undefined}
   */
  ;

  _proto.getEstimate = function getEstimate() {
    if (this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES) {
      return undefined;
    } // Take the minimum of these two estimates.  This should have the effect of
    // adapting down quickly, but up more slowly.


    return Math.min(this._fastEWMA.getEstimate(), this._slowEWMA.getEstimate());
  }
  /**
   * Reset the bandwidth estimation.
   */
  ;

  _proto.reset = function reset() {
    this._fastEWMA = new EWMA(ABR_FAST_EMA);
    this._slowEWMA = new EWMA(ABR_SLOW_EMA);
    this._bytesSampled = 0;
  };

  return BandwidthEstimator;
}();


// CONCATENATED MODULE: ./src/core/abr/create_filters.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Create Observable that merge several throttling Observables into one.
 * @param {Observable} limitWidth$ - Emit the width at which the chosen
 * Representation should be limited.
 * @param {Observable} throttleBitrate$ - Emit the maximum bitrate authorized.
 * @param {Observable} throttle$ - Also emit the maximum bitrate authorized.
 * Here for legacy reasons.
 * @returns {Observable}
 */

function createFilters(limitWidth$, throttleBitrate$, throttle$) {
  var deviceEventsArray = [];

  if (limitWidth$ != null) {
    deviceEventsArray.push(limitWidth$.pipe(Object(map["a" /* map */])(function (width) {
      return {
        width: width
      };
    })));
  }

  if (throttle$ != null) {
    deviceEventsArray.push(throttle$.pipe(Object(map["a" /* map */])(function (bitrate) {
      return {
        bitrate: bitrate
      };
    })));
  }

  if (throttleBitrate$ != null) {
    deviceEventsArray.push(throttleBitrate$.pipe(Object(map["a" /* map */])(function (bitrate) {
      return {
        bitrate: bitrate
      };
    })));
  } // Emit restrictions on the pools of available representations to choose
  // from.


  return deviceEventsArray.length > 0 ? Object(combineLatest["a" /* combineLatest */])(deviceEventsArray).pipe(Object(map["a" /* map */])(function (args) {
    return object_assign["a" /* default */].apply(void 0, [{}].concat(args));
  })) : Object(of["a" /* of */])({});
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(79);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
var ignoreElements = __webpack_require__(150);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/OuterSubscriber.js
var OuterSubscriber = __webpack_require__(29);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
var subscribeToResult = __webpack_require__(28);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function withLatestFrom() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return function (source) {
        var project;
        if (typeof args[args.length - 1] === 'function') {
            project = args.pop();
        }
        var observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
    };
}
var WithLatestFromOperator = /*@__PURE__*/ (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new withLatestFrom_WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var withLatestFrom_WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(Object(subscribeToResult["a" /* subscribeToResult */])(_this, observable, observable, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber["a" /* OuterSubscriber */]));
//# sourceMappingURL=withLatestFrom.js.map

// CONCATENATED MODULE: ./src/core/abr/get_buffer_levels.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Return "Buffer Levels" which are steps of available buffers from which we
 * are normally able switch safely to the next available bitrate.
 * (Following an algorithm close to BOLA)
 * @param {Array.<number>} bitrates - All available bitrates, __sorted__ in
 * ascending order.
 * @returns {Array.<number>}
 */
function getBufferLevels(bitrates) {
  var logs = bitrates.map(function (b) {
    return Math.log(b / bitrates[0]);
  });
  var utilities = logs.map(function (l) {
    return l - logs[0] + 1;
  }); // normalize

  var gp = (utilities[utilities.length - 1] - 1) / (bitrates.length * 2 + 10);
  var Vp = 1 / gp;
  return bitrates.map(function (_, i) {
    return minBufferLevelForBitrate(i);
  });
  /**
   * Get minimum buffer we should keep ahead to pick this bitrate.
   * @param {number} index
   * @returns {number}
   */

  function minBufferLevelForBitrate(index) {
    if (index === 0) {
      return 0;
    }

    var boundedIndex = Math.min(Math.max(1, index), bitrates.length - 1);
    return Vp * (gp + (bitrates[boundedIndex] * utilities[boundedIndex - 1] - bitrates[boundedIndex - 1] * utilities[boundedIndex]) / (bitrates[boundedIndex] - bitrates[boundedIndex - 1])) + 4;
  }
}
// EXTERNAL MODULE: ./src/utils/array_find_index.ts
var array_find_index = __webpack_require__(46);

// CONCATENATED MODULE: ./src/core/abr/get_estimate_from_buffer_levels.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * From the buffer gap, choose a representation.
 * @param {Object} clockTick
 * @param {Array.<Number>} bitrates
 * @param {Array.<Number>} bufferLevels
 * @returns {Object|undefined}
 */

function getEstimateFromBufferLevels(clockTick, bitrates, bufferLevels) {
  var bufferGap = clockTick.bufferGap,
      currentBitrate = clockTick.currentBitrate,
      currentScore = clockTick.currentScore,
      speed = clockTick.speed;

  if (currentBitrate == null) {
    return bitrates[0];
  }

  var currentBitrateIndex = Object(array_find_index["a" /* default */])(bitrates, function (b) {
    return b === currentBitrate;
  });

  if (currentBitrateIndex < 0 || bitrates.length !== bufferLevels.length) {
    log["a" /* default */].error("ABR: Current Bitrate not found in the calculated levels");
    return bitrates[0];
  }

  var scaledScore;

  if (currentScore != null) {
    scaledScore = speed === 0 ? currentScore : currentScore / speed;
  }

  if (scaledScore != null && scaledScore > 1) {
    var currentBufferLevel = bufferLevels[currentBitrateIndex];

    var nextIndex = function () {
      for (var i = currentBitrateIndex + 1; i < bufferLevels.length; i++) {
        if (bufferLevels[i] > currentBufferLevel) {
          return i;
        }
      }
    }();

    if (nextIndex != null) {
      var nextBufferLevel = bufferLevels[nextIndex];

      if (bufferGap >= nextBufferLevel) {
        return bitrates[nextIndex];
      }
    }
  }

  if (scaledScore == null || scaledScore < 1.15) {
    var _currentBufferLevel = bufferLevels[currentBitrateIndex];

    if (bufferGap < _currentBufferLevel) {
      for (var i = currentBitrateIndex - 1; i >= 0; i--) {
        if (bitrates[i] < currentBitrate) {
          return bitrates[i];
        }
      }

      return currentBitrate;
    }
  }

  return currentBitrate;
}
// CONCATENATED MODULE: ./src/core/abr/buffer_based_chooser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Choose a bitrate based on the currently available buffer.
 *
 * This algorithm is based on the deviation of the BOLA algorithm.
 * It is a hybrid solution that also relies on a given bitrate's
 * "maintainability".
 * Each time a chunk is downloaded, from the ratio between the chunk duration
 * and chunk's request time, we can assume that the representation is
 * "maintanable" or not.
 * If so, we may switch to a better quality, or conversely to a worse quality.
 *
 * @param {Observable} update$
 * @param {Array.<number>} bitrates
 * @returns {Observable}
 */

function BufferBasedChooser(update$, bitrates) {
  var levelsMap = getBufferLevels(bitrates);
  log["a" /* default */].debug("ABR: Steps for buffer based chooser.", levelsMap.map(function (l, i) {
    return {
      bufferLevel: l,
      bitrate: bitrates[i]
    };
  }));
  return update$.pipe(Object(map["a" /* map */])(function (clockTick) {
    return getEstimateFromBufferLevels(clockTick, bitrates, levelsMap);
  }));
}
// CONCATENATED MODULE: ./src/core/abr/filter_by_bitrate.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Get only representations lower than a given bitrate.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Array.<Object>}
 */

function filterByBitrate(representations, bitrate) {
  var firstSuperiorBitrate = Object(array_find_index["a" /* default */])(representations, function (representation) {
    return representation.bitrate > bitrate;
  });

  if (firstSuperiorBitrate === -1) {
    return representations; // All representations have a lower bitrates.
  }

  return representations.slice(0, firstSuperiorBitrate);
}
// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(14);

// CONCATENATED MODULE: ./src/core/abr/filter_by_width.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Filter representations based on their width:
 *   - the highest width considered will be the one linked to the first
 *     representation which has a superior width to the one given.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} width
 * @returns {Array.<Object>}
 */

function filterByWidth(representations, width) {
  var sortedRepsByWidth = representations.slice() // clone
  .sort(function (a, b) {
    return Object(take_first_set["a" /* default */])(a.width, 0) - Object(take_first_set["a" /* default */])(b.width, 0);
  });
  var repWithMaxWidth = Object(array_find["a" /* default */])(sortedRepsByWidth, function (representation) {
    return typeof representation.width === "number" && representation.width >= width;
  });

  if (repWithMaxWidth !== undefined) {
    var maxWidth = typeof repWithMaxWidth.width === "number" ? repWithMaxWidth.width : 0;
    return representations.filter(function (representation) {
      return typeof representation.width === "number" ? representation.width <= maxWidth : true;
    });
  }

  return representations;
}
// CONCATENATED MODULE: ./src/core/abr/from_bitrate_ceil.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Array.<Representation>} representations - The representations array
 * @param {Number} bitrate
 * @returns {Representation|undefined}
 */

function fromBitrateCeil(representations, bitrate) {
  var tooHighIndex = Object(array_find_index["a" /* default */])(representations, function (representation) {
    return representation.bitrate > bitrate;
  });

  if (tooHighIndex === -1) {
    return representations[representations.length - 1];
  }

  return representations[tooHighIndex - 1];
}
// CONCATENATED MODULE: ./src/core/abr/network_analyzer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var ABR_REGULAR_FACTOR = config["a" /* default */].ABR_REGULAR_FACTOR,
    ABR_STARVATION_DURATION_DELTA = config["a" /* default */].ABR_STARVATION_DURATION_DELTA,
    ABR_STARVATION_FACTOR = config["a" /* default */].ABR_STARVATION_FACTOR,
    ABR_STARVATION_GAP = config["a" /* default */].ABR_STARVATION_GAP,
    OUT_OF_STARVATION_GAP = config["a" /* default */].OUT_OF_STARVATION_GAP;
/**
 * Get the pending request starting with the asked segment position.
 * @param {Object} requests
 * @param {number} position
 * @returns {IRequestInfo|undefined}
 */

function getConcernedRequest(requests, neededPosition) {
  for (var i = 0; i < requests.length; i++) {
    var request = requests[i];

    if (request.duration > 0) {
      var segmentEnd = request.time + request.duration;

      if (segmentEnd > neededPosition && neededPosition - request.time > -0.3) {
        return request;
      }
    }
  }
}
/**
 * Estimate the __VERY__ recent bandwidth based on a single unfinished request.
 * Useful when the current bandwidth seemed to have fallen quickly.
 *
 * @param {Object} request
 * @returns {number|undefined}
 */


function estimateRequestBandwidth(request) {
  if (request.progress.length < 2) {
    return undefined;
  } // try to infer quickly the current bitrate based on the
  // progress events


  var ewma1 = new EWMA(2);
  var progress = request.progress;

  for (var i = 1; i < progress.length; i++) {
    var bytesDownloaded = progress[i].size - progress[i - 1].size;
    var timeElapsed = progress[i].timestamp - progress[i - 1].timestamp;
    var reqBitrate = bytesDownloaded * 8 / (timeElapsed / 1000);
    ewma1.addSample(timeElapsed / 1000, reqBitrate);
  }

  return ewma1.getEstimate();
}
/**
 * Estimate remaining time for a pending request from a progress event.
 * @param {Object} lastProgressEvent
 * @param {number} bandwidthEstimate
 * @returns {number}
 */


function estimateRemainingTime(lastProgressEvent, bandwidthEstimate) {
  var remainingData = (lastProgressEvent.totalSize - lastProgressEvent.size) * 8;
  return Math.max(remainingData / bandwidthEstimate, 0);
}
/**
 * Check if the request for the most needed segment is too slow.
 * If that's the case, re-calculate the bandwidth urgently based on
 * this single request.
 * @param {Object} pendingRequests - Current pending requests.
 * @param {Object} clock - Information on the current playback.
 * @param {Number} lastEstimatedBitrate - Last bitrate estimation emitted.
 * @returns {Number|undefined}
 */


function estimateStarvationModeBitrate(pendingRequests, clock, currentRepresentation, lastEstimatedBitrate) {
  var nextNeededPosition = clock.currentTime + clock.bufferGap;
  var concernedRequest = getConcernedRequest(pendingRequests, nextNeededPosition);

  if (concernedRequest === undefined) {
    return undefined;
  }

  var chunkDuration = concernedRequest.duration;
  var now = performance.now();
  var lastProgressEvent = concernedRequest.progress.length > 0 ? concernedRequest.progress[concernedRequest.progress.length - 1] : null; // first, try to do a quick estimate from progress events

  var bandwidthEstimate = estimateRequestBandwidth(concernedRequest);

  if (lastProgressEvent != null && bandwidthEstimate != null) {
    var remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate) * 1.2; // if this remaining time is reliable and is not enough to avoid buffering

    if ((now - lastProgressEvent.timestamp) / 1000 <= remainingTime && remainingTime > clock.bufferGap / clock.speed) {
      return bandwidthEstimate;
    }
  }

  var requestElapsedTime = (now - concernedRequest.requestTimestamp) / 1000;
  var reasonableElapsedTime = requestElapsedTime <= (chunkDuration * 1.5 + 1) / clock.speed;

  if (currentRepresentation == null || reasonableElapsedTime) {
    return undefined;
  } // calculate a reduced bitrate from the current one


  var factor = chunkDuration / requestElapsedTime;
  var reducedBitrate = currentRepresentation.bitrate * Math.min(0.7, factor);

  if (lastEstimatedBitrate == null || reducedBitrate < lastEstimatedBitrate) {
    return reducedBitrate;
  }
}
/**
 * Returns true if, based on the current requests, it seems that the ABR should
 * switch immediately if a lower bitrate is more adapted.
 * Returns false if it estimates that you have time before switching to a lower
 * bitrate.
 * @param {Object} clock
 * @param {Object} requests - Every requests pending, in a chronological
 * order in terms of segment time.
 * @returns {boolean}
 */


function shouldDirectlySwitchToLowBitrate(clock, requests, abrStarvationGap) {
  var nextNeededPosition = clock.currentTime + clock.bufferGap;
  var nextNeededRequest = Object(array_find["a" /* default */])(requests, function (r) {
    return r.time + r.duration > nextNeededPosition;
  });

  if (nextNeededRequest === undefined) {
    return true;
  }

  var now = performance.now();
  var lastProgressEvent = nextNeededRequest.progress.length > 0 ? nextNeededRequest.progress[nextNeededRequest.progress.length - 1] : null; // first, try to do a quick estimate from progress events

  var bandwidthEstimate = estimateRequestBandwidth(nextNeededRequest);

  if (lastProgressEvent == null || bandwidthEstimate == null) {
    return true;
  }

  var remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);

  if ((now - lastProgressEvent.timestamp) / 1000 <= remainingTime * 1.2 && remainingTime < clock.bufferGap / clock.speed + abrStarvationGap) {
    return false;
  }

  return true;
}
/**
 * Analyze the current network conditions and give a bandwidth estimate as well
 * as a maximum bitrate a Representation should be.
 * @class NetworkAnalyzer
 */


var network_analyzer_NetworkAnalyzer = /*#__PURE__*/function () {
  function NetworkAnalyzer(initialBitrate, lowLatencyMode) {
    this._initialBitrate = initialBitrate;
    this._inStarvationMode = false;

    if (lowLatencyMode) {
      this._config = {
        starvationGap: ABR_STARVATION_GAP.LOW_LATENCY,
        outOfStarvationGap: OUT_OF_STARVATION_GAP.LOW_LATENCY,
        starvationBitrateFactor: ABR_STARVATION_FACTOR.LOW_LATENCY,
        regularBitrateFactor: ABR_REGULAR_FACTOR.LOW_LATENCY
      };
    } else {
      this._config = {
        starvationGap: ABR_STARVATION_GAP.DEFAULT,
        outOfStarvationGap: OUT_OF_STARVATION_GAP.DEFAULT,
        starvationBitrateFactor: ABR_STARVATION_FACTOR.DEFAULT,
        regularBitrateFactor: ABR_REGULAR_FACTOR.DEFAULT
      };
    }
  }

  var _proto = NetworkAnalyzer.prototype;

  _proto.getBandwidthEstimate = function getBandwidthEstimate(clockTick, bandwidthEstimator, currentRepresentation, currentRequests, lastEstimatedBitrate) {
    var newBitrateCeil; // bitrate ceil for the chosen Representation

    var bandwidthEstimate;
    var localConf = this._config;
    var bufferGap = clockTick.bufferGap,
        currentTime = clockTick.currentTime,
        duration = clockTick.duration; // check if should get in/out of starvation mode

    if (isNaN(duration) || bufferGap + currentTime < duration - ABR_STARVATION_DURATION_DELTA) {
      if (!this._inStarvationMode && bufferGap <= localConf.starvationGap) {
        log["a" /* default */].info("ABR: enter starvation mode.");
        this._inStarvationMode = true;
      } else if (this._inStarvationMode && bufferGap >= localConf.outOfStarvationGap) {
        log["a" /* default */].info("ABR: exit starvation mode.");
        this._inStarvationMode = false;
      }
    } else if (this._inStarvationMode) {
      log["a" /* default */].info("ABR: exit starvation mode.");
      this._inStarvationMode = false;
    } // If in starvation mode, check if a quick new estimate can be done
    // from the last requests.
    // If so, cancel previous estimations and replace it by the new one


    if (this._inStarvationMode) {
      bandwidthEstimate = estimateStarvationModeBitrate(currentRequests, clockTick, currentRepresentation, lastEstimatedBitrate);

      if (bandwidthEstimate != null) {
        log["a" /* default */].info("ABR: starvation mode emergency estimate:", bandwidthEstimate);
        bandwidthEstimator.reset();
        newBitrateCeil = currentRepresentation == null ? bandwidthEstimate : Math.min(bandwidthEstimate, currentRepresentation.bitrate);
      }
    } // if newBitrateCeil is not yet defined, do the normal estimation


    if (newBitrateCeil == null) {
      bandwidthEstimate = bandwidthEstimator.getEstimate();

      if (bandwidthEstimate != null) {
        newBitrateCeil = bandwidthEstimate * (this._inStarvationMode ? localConf.starvationBitrateFactor : localConf.regularBitrateFactor);
      } else if (lastEstimatedBitrate != null) {
        newBitrateCeil = lastEstimatedBitrate * (this._inStarvationMode ? localConf.starvationBitrateFactor : localConf.regularBitrateFactor);
      } else {
        newBitrateCeil = this._initialBitrate;
      }
    }

    if (clockTick.speed > 1) {
      newBitrateCeil /= clockTick.speed;
    }

    return {
      bandwidthEstimate: bandwidthEstimate,
      bitrateChosen: newBitrateCeil
    };
  }
  /**
   * For a given wanted bitrate, tells if should switch urgently.
   * @param {number} bitrate
   * @param {Object} clockTick
   * @returns {boolean}
   */
  ;

  _proto.isUrgent = function isUrgent(bitrate, currentRepresentation, currentRequests, clockTick) {
    if (currentRepresentation == null) {
      return true;
    } else if (bitrate === currentRepresentation.bitrate) {
      return false;
    } else if (bitrate > currentRepresentation.bitrate) {
      return !this._inStarvationMode;
    }

    return shouldDirectlySwitchToLowBitrate(clockTick, currentRequests, this._config.starvationGap);
  };

  return NetworkAnalyzer;
}();


// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(82);

// CONCATENATED MODULE: ./src/core/abr/pending_requests_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Store information about pending requests, like information about:
 *   - for which segments they are
 *   - how the request's progress goes
 * @class PendingRequestsStore
 */

var pending_requests_store_PendingRequestsStore = /*#__PURE__*/function () {
  function PendingRequestsStore() {
    this._currentRequests = {};
  }
  /**
   * Add information about a new pending request.
   * @param {string} id
   * @param {Object} payload
   */


  var _proto = PendingRequestsStore.prototype;

  _proto.add = function add(payload) {
    var id = payload.id,
        time = payload.time,
        duration = payload.duration,
        requestTimestamp = payload.requestTimestamp;
    this._currentRequests[id] = {
      time: time,
      duration: duration,
      requestTimestamp: requestTimestamp,
      progress: []
    };
  }
  /**
   * Notify of the progress of a currently pending request.
   * @param {Object} progress
   */
  ;

  _proto.addProgress = function addProgress(progress) {
    var request = this._currentRequests[progress.id];

    if (request == null) {
      if (false) {}

      log["a" /* default */].warn("ABR: progress for a request not added");
      return;
    }

    request.progress.push(progress);
  }
  /**
   * Remove a request previously set as pending.
   * @param {string} id
   */
  ;

  _proto.remove = function remove(id) {
    if (this._currentRequests[id] == null) {
      if (false) {}

      log["a" /* default */].warn("ABR: can't remove unknown request");
    }

    delete this._currentRequests[id];
  }
  /**
   * Returns information about all pending requests, in segment's chronological
   * order.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getRequests = function getRequests() {
    return Object(object_values["a" /* default */])(this._currentRequests).filter(function (x) {
      return x != null;
    }).sort();
  };

  return PendingRequestsStore;
}();


// CONCATENATED MODULE: ./src/core/abr/representation_score_calculator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Calculate the "maintainability score" of a given Representation:
 *   - A score higher than 1 means that the Representation can theorically
 *     be downloaded faster than the duration of the media it represents.
 *     (e.g. a segment representing 4 seconds can be downloaded in less than 4
 *     seconds).
 *   - A score lower or equal to 1 means that the Representation cannot be
 *     downloaded
 *
 * The score follows a simple linear relation to both variables it is based
 * on:
 *   - if n seconds of content can be downloaded in 2*n seconds, the score will
 *     be `0.5`.
 *   - if n seconds of content can be downloaded in n seconds, the score will be
 *     `1`.
 *   - if n seconds of content can be downloaded in n/2 seconds, the score will
 *     be `2`.
 *   - ...
 *
 * The score is mainly here to tell you when your buffer-based guesses are
 * actually higher than the quality you should normally reach.
 *
 * /!\ Please bear in mind that we don't consider the playback rate in those
 * operations.
 * Still, integrating the playback rate a posteriori should not be difficult
 * (e.g. you can just divide the score by that rate).
 *
 * @class RepresentationScoreCalculator
 */

var representation_score_calculator_RepresentationScoreCalculator = /*#__PURE__*/function () {
  function RepresentationScoreCalculator() {
    this._currentRepresentationData = null;
    this._lastRepresentationWithGoodScore = null;
  }
  /**
   * Add new sample data.
   * @param {Representation} representation
   * @param {number} requestDuration - duration taken for doing the request for
   * the whole segment.
   * @param {number} segmentDuration - media duration of the whole segment, in
   * seconds.
   */


  var _proto = RepresentationScoreCalculator.prototype;

  _proto.addSample = function addSample(representation, requestDuration, segmentDuration) {
    var ratio = segmentDuration / requestDuration;

    var oldEwma = this._getEWMA(representation);

    var currentEWMA;

    if (oldEwma != null) {
      currentEWMA = oldEwma;
      oldEwma.addSample(requestDuration, ratio);
    } else {
      currentEWMA = new EWMA(5);
      currentEWMA.addSample(requestDuration, ratio);
      this._currentRepresentationData = {
        representation: representation,
        ewma: currentEWMA
      };
    }

    if (currentEWMA.getEstimate() > 1 && this._lastRepresentationWithGoodScore !== representation) {
      log["a" /* default */].debug("ABR: New last stable representation", representation);
      this._lastRepresentationWithGoodScore = representation;
    }
  }
  /**
   * Get score estimate for the given Representation.
   * undefined if no estimate is available.
   * @param {Representation} representation
   * @returns {number|undefined}
   */
  ;

  _proto.getEstimate = function getEstimate(representation) {
    var ewma = this._getEWMA(representation);

    if (ewma != null) {
      return ewma.getEstimate();
    }
  }
  /**
   * Returns last Representation which had reached a score superior to 1.
   * This Representation is the last known one which could be maintained.
   * Useful to know if a current guess is higher than what you should
   * normally be able to play.
   * `null` if no Representation ever reach that score.
   * @returns {Representation|null}
   */
  ;

  _proto.getLastStableRepresentation = function getLastStableRepresentation() {
    return this._lastRepresentationWithGoodScore;
  }
  /**
   * Returns EWMA for the given Representation.
   * null if no EWMA is currently stored for it.
   * @param {Representation} representation
   * @returns {EWMA|null}
   */
  ;

  _proto._getEWMA = function _getEWMA(representation) {
    if (this._currentRepresentationData != null && this._currentRepresentationData.representation.id === representation.id) {
      return this._currentRepresentationData.ewma;
    }

    return null;
  };

  return RepresentationScoreCalculator;
}();


// CONCATENATED MODULE: ./src/core/abr/representation_estimator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * Filter representations given through filters options.
 * @param {Array.<Representation>} representations
 * @param {Object} filters - Filter Object.
 * _Can_ contain each of the following properties:
 *   - bitrate {Number} - max bitrate authorized (included).
 *   - width {Number} - max width authorized (included).
 * @returns {Array.<Representation>}
 */

function getFilteredRepresentations(representations, filters) {
  var _representations = representations;

  if (filters.bitrate != null) {
    _representations = filterByBitrate(_representations, filters.bitrate);
  }

  if (filters.width != null) {
    _representations = filterByWidth(_representations, filters.width);
  }

  return _representations;
}
/**
 * Emit the estimated bitrate and best Representation according to the current
 * network and buffer situation.
 * @param {Object} args
 * @returns {Observable}
 */


function RepresentationEstimator(_ref) {
  var bandwidthEstimator = _ref.bandwidthEstimator,
      bufferEvents$ = _ref.bufferEvents$,
      clock$ = _ref.clock$,
      filters$ = _ref.filters$,
      initialBitrate = _ref.initialBitrate,
      lowLatencyMode = _ref.lowLatencyMode,
      manualBitrate$ = _ref.manualBitrate$,
      maxAutoBitrate$ = _ref.maxAutoBitrate$,
      representations = _ref.representations;
  var scoreCalculator = new representation_score_calculator_RepresentationScoreCalculator();
  var networkAnalyzer = new network_analyzer_NetworkAnalyzer(initialBitrate == null ? 0 : initialBitrate, lowLatencyMode);
  var requestsStore = new pending_requests_store_PendingRequestsStore();
  /**
   * Callback to call when new metrics arrive.
   * @param {Object} value
   */

  function onMetric(value) {
    var duration = value.duration,
        size = value.size,
        content = value.content; // calculate bandwidth

    bandwidthEstimator.addSample(duration, size); // calculate "maintainability score"

    var segment = content.segment;

    if (segment.duration == null) {
      return;
    }

    var requestDuration = duration / 1000;
    var segmentDuration = segment.duration / segment.timescale;
    var representation = content.representation;
    scoreCalculator.addSample(representation, requestDuration, segmentDuration);
  }

  var metrics$ = bufferEvents$.pipe(Object(filter["a" /* filter */])(function (e) {
    return e.type === "metrics";
  }), Object(tap["a" /* tap */])(function (_ref2) {
    var value = _ref2.value;
    return onMetric(value);
  }), Object(ignoreElements["a" /* ignoreElements */])());
  var requests$ = bufferEvents$.pipe(Object(tap["a" /* tap */])(function (evt) {
    switch (evt.type) {
      case "requestBegin":
        requestsStore.add(evt.value);
        break;

      case "requestEnd":
        requestsStore.remove(evt.value.id);
        break;

      case "progress":
        requestsStore.addProgress(evt.value);
        break;
    }
  }), Object(ignoreElements["a" /* ignoreElements */])());
  var currentRepresentation$ = bufferEvents$.pipe(Object(filter["a" /* filter */])(function (e) {
    return e.type === "representationChange";
  }), Object(map["a" /* map */])(function (e) {
    return e.value.representation;
  }), Object(startWith["a" /* startWith */])(null));
  var estimate$ = Object(defer["a" /* defer */])(function () {
    if (representations.length === 0) {
      throw new Error("ABRManager: no representation choice given");
    }

    if (representations.length === 1) {
      return Object(of["a" /* of */])({
        bitrate: undefined,
        representation: representations[0],
        manual: false,
        urgent: true,
        knownStableBitrate: undefined
      });
    }

    return manualBitrate$.pipe(Object(switchMap["a" /* switchMap */])(function (manualBitrate) {
      if (manualBitrate >= 0) {
        // -- MANUAL mode --
        var manualRepresentation = function () {
          var fromBitrate = fromBitrateCeil(representations, manualBitrate);

          if (fromBitrate !== undefined) {
            return fromBitrate;
          }

          return representations[0];
        }();

        return Object(of["a" /* of */])({
          representation: manualRepresentation,
          bitrate: undefined,
          knownStableBitrate: undefined,
          manual: true,
          urgent: true
        });
      } // -- AUTO mode --


      var lastEstimatedBitrate;
      var forceBandwidthMode = true; // Emit each time a buffer-based estimation should be actualized (each
      // time a segment is added).

      var bufferBasedClock$ = bufferEvents$.pipe(Object(filter["a" /* filter */])(function (e) {
        return e.type === "added-segment";
      }), withLatestFrom(clock$), Object(map["a" /* map */])(function (_ref3) {
        var evtValue = _ref3[0].value,
            _ref3$ = _ref3[1],
            speed = _ref3$.speed,
            currentTime = _ref3$.currentTime;
        var timeRanges = evtValue.buffered;
        var bufferGap = Object(ranges["d" /* getLeftSizeOfRange */])(timeRanges, currentTime);
        var representation = evtValue.content.representation;
        var currentScore = scoreCalculator.getEstimate(representation);
        var currentBitrate = representation.bitrate;
        return {
          bufferGap: bufferGap,
          currentBitrate: currentBitrate,
          currentScore: currentScore,
          speed: speed
        };
      }));
      var bitrates = representations.map(function (r) {
        return r.bitrate;
      });
      var bufferBasedEstimation$ = BufferBasedChooser(bufferBasedClock$, bitrates).pipe(Object(startWith["a" /* startWith */])(undefined));
      return Object(combineLatest["a" /* combineLatest */])([clock$, maxAutoBitrate$, filters$, bufferBasedEstimation$]).pipe(withLatestFrom(currentRepresentation$), Object(map["a" /* map */])(function (_ref4) {
        var _ref4$ = _ref4[0],
            clock = _ref4$[0],
            maxAutoBitrate = _ref4$[1],
            filters = _ref4$[2],
            bufferBasedBitrate = _ref4$[3],
            currentRepresentation = _ref4[1];

        var _representations = getFilteredRepresentations(representations, filters);

        var requests = requestsStore.getRequests();

        var _networkAnalyzer$getB = networkAnalyzer.getBandwidthEstimate(clock, bandwidthEstimator, currentRepresentation, requests, lastEstimatedBitrate),
            bandwidthEstimate = _networkAnalyzer$getB.bandwidthEstimate,
            bitrateChosen = _networkAnalyzer$getB.bitrateChosen;

        lastEstimatedBitrate = bandwidthEstimate;
        var stableRepresentation = scoreCalculator.getLastStableRepresentation();
        var knownStableBitrate = stableRepresentation == null ? undefined : stableRepresentation.bitrate / (clock.speed > 0 ? clock.speed : 1);
        var bufferGap = clock.bufferGap;

        if (!forceBandwidthMode && bufferGap <= 5) {
          forceBandwidthMode = true;
        } else if (forceBandwidthMode && Number.isFinite(bufferGap) && bufferGap > 10) {
          forceBandwidthMode = false;
        }

        var chosenRepFromBandwidth = function () {
          var fromBitrate = fromBitrateCeil(_representations, Math.min(bitrateChosen, maxAutoBitrate));

          if (fromBitrate !== undefined) {
            return fromBitrate;
          }

          if (_representations.length > 0) {
            return _representations[0];
          }

          return representations[0];
        }();

        if (forceBandwidthMode) {
          log["a" /* default */].debug("ABR: Choosing representation with bandwith estimation.", chosenRepFromBandwidth);
          return {
            bitrate: bandwidthEstimate,
            representation: chosenRepFromBandwidth,
            urgent: networkAnalyzer.isUrgent(chosenRepFromBandwidth.bitrate, currentRepresentation, requests, clock),
            manual: false,
            knownStableBitrate: knownStableBitrate
          };
        }

        if (bufferBasedBitrate == null || chosenRepFromBandwidth.bitrate >= bufferBasedBitrate) {
          log["a" /* default */].debug("ABR: Choosing representation with bandwith estimation.", chosenRepFromBandwidth);
          return {
            bitrate: bandwidthEstimate,
            representation: chosenRepFromBandwidth,
            urgent: networkAnalyzer.isUrgent(chosenRepFromBandwidth.bitrate, currentRepresentation, requests, clock),
            manual: false,
            knownStableBitrate: knownStableBitrate
          };
        }

        var limitedBitrate = Math.min(bufferBasedBitrate, maxAutoBitrate);

        var chosenRepresentation = function () {
          var fromBitrate = fromBitrateCeil(_representations, limitedBitrate);

          if (fromBitrate !== undefined) {
            return fromBitrate;
          }

          if (_representations.length > 0) {
            return _representations[0];
          }

          return representations[0];
        }();

        if (bufferBasedBitrate <= maxAutoBitrate) {
          log["a" /* default */].debug("ABR: Choosing representation with buffer based bitrate ceiling.", chosenRepresentation);
        }

        return {
          bitrate: bandwidthEstimate,
          representation: chosenRepresentation,
          urgent: networkAnalyzer.isUrgent(bufferBasedBitrate, currentRepresentation, requests, clock),
          manual: false,
          knownStableBitrate: knownStableBitrate
        };
      }));
    }));
  });
  return Object(merge["a" /* merge */])(metrics$, requests$, estimate$);
}
// CONCATENATED MODULE: ./src/core/abr/abr_manager.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Adaptive BitRate Manager.
 *
 * Select the right Representation from the network and buffer infos it
 * receives.
 * @class ABRManager
 */

var abr_manager_ABRManager = /*#__PURE__*/function () {
  /**
   * @param {Object} options
   */
  function ABRManager(options) {
    this._manualBitrates = options.manualBitrates;
    this._maxAutoBitrates = options.maxAutoBitrates;
    this._initialBitrates = options.initialBitrates;
    this._throttlers = options.throttlers;
    this._bandwidthEstimators = {};
    this._lowLatencyMode = options.lowLatencyMode;
  }
  /**
   * Take type and an array of the available representations, spit out an
   * observable emitting the best representation (given the network/buffer
   * state).
   * @param {string} type
   * @param {Array.<Representation>|undefined} representations
   * @param {Observable<Object>} clock$
   * @param {Observable<Object>} bufferEvents$
   * @returns {Observable}
   */


  var _proto = ABRManager.prototype;

  _proto.get$ = function get$(type, representations, clock$, bufferEvents$) {
    if (representations === void 0) {
      representations = [];
    }

    var bandwidthEstimator = this._getBandwidthEstimator(type);

    var manualBitrate$ = Object(take_first_set["a" /* default */])(this._manualBitrates[type], Object(of["a" /* of */])(-1));
    var maxAutoBitrate$ = Object(take_first_set["a" /* default */])(this._maxAutoBitrates[type], Object(of["a" /* of */])(Infinity));
    var initialBitrate = Object(take_first_set["a" /* default */])(this._initialBitrates[type], 0);
    var filters$ = createFilters(this._throttlers.limitWidth[type], this._throttlers.throttleBitrate[type], this._throttlers.throttle[type]);
    return RepresentationEstimator({
      bandwidthEstimator: bandwidthEstimator,
      bufferEvents$: bufferEvents$,
      clock$: clock$,
      filters$: filters$,
      initialBitrate: initialBitrate,
      manualBitrate$: manualBitrate$,
      maxAutoBitrate$: maxAutoBitrate$,
      representations: representations,
      lowLatencyMode: this._lowLatencyMode
    });
  }
  /**
   * @param {string} bufferType
   * @returns {Object}
   */
  ;

  _proto._getBandwidthEstimator = function _getBandwidthEstimator(bufferType) {
    var originalBandwidthEstimator = this._bandwidthEstimators[bufferType];

    if (originalBandwidthEstimator == null) {
      log["a" /* default */].debug("ABR: Creating new BandwidthEstimator for ", bufferType);
      var bandwidthEstimator = new bandwidth_estimator_BandwidthEstimator();
      this._bandwidthEstimators[bufferType] = bandwidthEstimator;
      return bandwidthEstimator;
    }

    return originalBandwidthEstimator;
  };

  return ABRManager;
}();


// CONCATENATED MODULE: ./src/core/abr/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var abr = (abr_manager_ABRManager);
// EXTERNAL MODULE: ./src/utils/rx-try_catch.ts
var rx_try_catch = __webpack_require__(37);

// EXTERNAL MODULE: ./src/errors/request_error.ts
var request_error = __webpack_require__(139);

// EXTERNAL MODULE: ./src/errors/network_error.ts
var network_error = __webpack_require__(171);

// CONCATENATED MODULE: ./src/core/fetchers/utils/error_selector.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generate a new error from the infos given.
 * @param {string} code
 * @param {Error} error
 * @returns {Error}
 */

function errorSelector(error) {
  if (error instanceof request_error["a" /* default */]) {
    return new network_error["a" /* default */]("PIPELINE_LOAD_ERROR", error);
  }

  return formatError(error, {
    defaultCode: "PIPELINE_LOAD_ERROR",
    defaultReason: "Unknown error when fetching the Manifest"
  });
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/timer.js
var timer = __webpack_require__(217);

// EXTERNAL MODULE: ./src/compat/is_offline.ts
var is_offline = __webpack_require__(163);

// EXTERNAL MODULE: ./src/utils/get_fuzzed_delay.ts
var get_fuzzed_delay = __webpack_require__(109);

// CONCATENATED MODULE: ./src/core/fetchers/utils/try_urls_with_backoff.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Called on a loader error.
 * Returns whether the loader request should be retried.
 * @param {Error} error
 * @returns {Boolean} - If true, the request can be retried.
 */

function shouldRetry(error) {
  if (error instanceof request_error["a" /* default */]) {
    if (error.type === error_codes["c" /* NetworkErrorTypes */].ERROR_HTTP_CODE) {
      return error.status >= 500 || error.status === 404 || error.status === 415 || // some CDN seems to use that code when
      // requesting low-latency segments too much
      // in advance
      error.status === 412;
    }

    return error.type === error_codes["c" /* NetworkErrorTypes */].TIMEOUT || error.type === error_codes["c" /* NetworkErrorTypes */].ERROR_EVENT;
  }

  return Object(is_known_error["a" /* default */])(error) && error.code === "INTEGRITY_ERROR";
}
/**
 * Returns true if we're pretty sure that the current error is due to the
 * user being offline.
 * @param {Error} error
 * @returns {Boolean}
 */


function isOfflineRequestError(error) {
  return error.type === error_codes["c" /* NetworkErrorTypes */].ERROR_EVENT && Object(is_offline["a" /* default */])();
}

var REQUEST_ERROR_TYPES;

(function (REQUEST_ERROR_TYPES) {
  REQUEST_ERROR_TYPES[REQUEST_ERROR_TYPES["None"] = 0] = "None";
  REQUEST_ERROR_TYPES[REQUEST_ERROR_TYPES["Regular"] = 1] = "Regular";
  REQUEST_ERROR_TYPES[REQUEST_ERROR_TYPES["Offline"] = 2] = "Offline";
})(REQUEST_ERROR_TYPES || (REQUEST_ERROR_TYPES = {}));
/**
 * Guess the type of error obtained.
 * @param {*} error
 * @returns {number}
 */


function getRequestErrorType(error) {
  return error instanceof request_error["a" /* default */] && isOfflineRequestError(error) ? REQUEST_ERROR_TYPES.Offline : REQUEST_ERROR_TYPES.Regular;
}
/**
 * Specific algorithm used to perform segment and manifest requests.
 *
 * Here how it works:
 *
 *   1. we give it one or multiple URLs available for the element we want to
 *      request, the request callback and some options
 *
 *   2. it tries to call the request callback with the first URL:
 *        - if it works as expected, it wrap the response in a `response` event.
 *        - if it fails, it emits a `retry` event and try with the next one.
 *
 *   3. When all URLs have been tested (and failed), it decides - according to
 *      the error counters, configuration and errors received - if it can retry
 *      at least one of them, in the same order:
 *        - If it can, it increments the corresponding error counter, wait a
 *          delay (based on an exponential backoff) and restart the same logic
 *          for all retry-able URL.
 *        - If it can't it just throws the error.
 *
 * Note that there are in fact two separate counters:
 *   - one for "offline" errors
 *   - one for other xhr errors
 * Both counters are resetted if the error type changes from an error to the
 * next.
 * @param {Array.<string} obs$
 * @param {Function} request$
 * @param {Object} options - Configuration options.
 * @returns {Observable}
 */


function tryURLsWithBackoff(urls, request$, options) {
  var baseDelay = options.baseDelay,
      maxDelay = options.maxDelay,
      maxRetryRegular = options.maxRetryRegular,
      maxRetryOffline = options.maxRetryOffline;
  var retryCount = 0;
  var lastError = REQUEST_ERROR_TYPES.None;
  var urlsToTry = urls.slice();

  if (urlsToTry.length === 0) {
    log["a" /* default */].warn("Fetchers: no URL given to `tryURLsWithBackoff`.");
    return empty["a" /* EMPTY */];
  }

  return tryURLsRecursively(urlsToTry[0], 0);
  /**
   * Try to do the request of a given `url` which corresponds to the `index`
   * argument in the `urlsToTry` Array.
   *
   * If it fails try the next one.
   *
   * If all URLs fail, start a timer and retry the first element in that array
   * by following the configuration.
   *
   * @param {string|null} url
   * @param {number} index
   * @returns {Observable}
   */

  function tryURLsRecursively(url, index) {
    return request$(url).pipe(Object(map["a" /* map */])(function (res) {
      return {
        type: "response",
        value: res
      };
    }), Object(catchError["a" /* catchError */])(function (error) {
      if (!shouldRetry(error)) {
        // ban this URL
        if (urlsToTry.length <= 1) {
          // This was the last one, throw
          throw error;
        } // else, remove that element from the array and go the next URL


        urlsToTry.splice(index);
        var newIndex = index >= urlsToTry.length - 1 ? 0 : index;
        return tryURLsRecursively(urlsToTry[newIndex], newIndex).pipe(Object(startWith["a" /* startWith */])({
          type: "retry",
          value: error
        }));
      }

      var currentError = getRequestErrorType(error);
      var maxRetry = currentError === REQUEST_ERROR_TYPES.Offline ? maxRetryOffline : maxRetryRegular;

      if (currentError !== lastError) {
        retryCount = 0;
        lastError = currentError;
      }

      if (index < urlsToTry.length - 1) {
        // there is still URLs to test
        var _newIndex = index + 1;

        return tryURLsRecursively(urlsToTry[_newIndex], _newIndex).pipe(Object(startWith["a" /* startWith */])({
          type: "retry",
          value: error
        }));
      } // Here, we were using the last element of the `urlsToTry` array.
      // Increment counter and restart with the first URL


      retryCount++;

      if (retryCount > maxRetry) {
        throw error;
      }

      var delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);
      var fuzzedDelay = Object(get_fuzzed_delay["a" /* default */])(delay);
      var nextURL = urlsToTry[0];
      return Object(timer["a" /* timer */])(fuzzedDelay).pipe(Object(mergeMap["a" /* mergeMap */])(function () {
        return tryURLsRecursively(nextURL, 0);
      }), Object(startWith["a" /* startWith */])({
        type: "retry",
        value: error
      }));
    }));
  }
}
/**
 * Lightweight version of the request algorithm, this time with only a simple
 * Observable given.
 * @param {Function} request$
 * @param {Object} options
 * @returns {Observable}
 */

function tryRequestObservableWithBackoff(request$, options) {
  // same than for a single unknown URL
  return tryURLsWithBackoff([null], function () {
    return request$;
  }, options);
}
// CONCATENATED MODULE: ./src/core/fetchers/utils/create_request_scheduler.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





function createRequestScheduler(backoffOptions, warning$) {
  /**
   * Allow the parser to schedule a new request.
   * @param {Function} request - Function performing the request.
   * @returns {Function}
   */
  return function scheduleRequest(request) {
    return tryRequestObservableWithBackoff(Object(rx_try_catch["a" /* default */])(request, undefined), backoffOptions).pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
      if (evt.type === "retry") {
        warning$.next(errorSelector(evt.value));
        return empty["a" /* EMPTY */];
      }

      return Object(of["a" /* of */])(evt.value);
    }), Object(catchError["a" /* catchError */])(function (error) {
      throw errorSelector(error);
    }));
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/manifest/create_manifest_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Returns function allowing to download the Manifest through a
 * `resolver -> loader` transport pipeline.
 *
 * The function returned takes the loader's data in arguments and returns an
 * Observable which will emit:
 *
 *   - each time a minor request error is encountered (type "warning").
 *     With the error as a value.
 *
 *   - The fetched data (type "response").
 *
 * This observable will throw if, following the options given, the request and
 * possible retries all failed.
 *
 * @param {Object} manifestPipeline
 * @param {Object} backoffOptions
 * @returns {Function}
 */

function createManifestLoader(manifestPipeline, backoffOptions) {
  var loader = manifestPipeline.loader; // TODO Remove the resolver completely in the next major version

  var resolver = manifestPipeline.resolver != null ? manifestPipeline.resolver :
  /* tslint:disable deprecation */
  of["a" /* of */];
  /* tslint:enable deprecation */

  /**
   * Call the transport's resolver - if it exists - with the given data.
   * Throws with the right error if it fails.
   * @param {Object} resolverArgument
   * @returns {Observable}
   */

  function callResolver(resolverArgument) {
    return Object(rx_try_catch["a" /* default */])(resolver, resolverArgument).pipe(Object(catchError["a" /* catchError */])(function (error) {
      throw errorSelector(error);
    }));
  }
  /**
   * Load wanted data:
   *   - get it from cache if present
   *   - call the transport loader - with an exponential backoff - if not
   * @param {Object} loaderArgument - Input given to the loader
   * @returns {Observable}
   */


  function loadData(loaderArgument) {
    var loader$ = Object(rx_try_catch["a" /* default */])(loader, loaderArgument);
    return tryRequestObservableWithBackoff(loader$, backoffOptions).pipe(Object(catchError["a" /* catchError */])(function (error) {
      throw errorSelector(error);
    }), Object(map["a" /* map */])(function (evt) {
      return evt.type === "retry" ? {
        type: "warning",
        value: errorSelector(evt.value)
      } : evt.value;
    }));
  }
  /**
   * Load the corresponding data.
   * @param {sObject} pipelineInputData
   * @returns {Observable}
   */


  return function loadManifest(loaderArgs) {
    return callResolver(loaderArgs).pipe(Object(mergeMap["a" /* mergeMap */])(function (resolverResponse) {
      return loadData(resolverResponse).pipe(Object(mergeMap["a" /* mergeMap */])(function (arg) {
        if (arg.type === "warning") {
          return Object(of["a" /* of */])(arg);
        }

        var value = arg.value;
        return Object(of["a" /* of */])({
          type: "response",
          value: {
            responseData: value.responseData,
            url: value.url,
            sendingTime: value.sendingTime,
            receivedTime: value.receivedTime
          }
        });
      }));
    }));
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/manifest/get_manifest_backoff_options.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var DEFAULT_MAX_MANIFEST_REQUEST_RETRY = config["a" /* default */].DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
    DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE = config["a" /* default */].DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE,
    INITIAL_BACKOFF_DELAY_BASE = config["a" /* default */].INITIAL_BACKOFF_DELAY_BASE,
    MAX_BACKOFF_DELAY_BASE = config["a" /* default */].MAX_BACKOFF_DELAY_BASE;
/**
 * Parse config to replace missing manifest backoff options.
 * @param {Object} backoffOptions
 * @returns {Object}
 */

function getManifestBackoffOptions(_ref) {
  var maxRetryRegular = _ref.maxRetryRegular,
      maxRetryOffline = _ref.maxRetryOffline,
      lowLatencyMode = _ref.lowLatencyMode;
  var baseDelay = lowLatencyMode ? INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY : INITIAL_BACKOFF_DELAY_BASE.REGULAR;
  var maxDelay = lowLatencyMode ? MAX_BACKOFF_DELAY_BASE.LOW_LATENCY : MAX_BACKOFF_DELAY_BASE.REGULAR;
  return {
    baseDelay: baseDelay,
    maxDelay: maxDelay,
    maxRetryRegular: maxRetryRegular !== undefined ? maxRetryRegular : DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
    maxRetryOffline: maxRetryOffline !== undefined ? maxRetryOffline : DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/manifest/create_manifest_fetcher.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Create function allowing to easily fetch and parse a Manifest from its URL.
 * @example
 * ```js
 * const manifestFetcher = createManifestFetcher(pipelines, options);
 * manifestFetcher.fetch(manifestURL).pipe(
 *   // Filter only responses (might also receive warning events)
 *   filter((evt) => evt.type === "response");
 *   // Parse the Manifest
 *   mergeMap(res => res.parse({ externalClockOffset }))
 *   // (again)
 *   filter((evt) => evt.type === "parsed");
 * ).subscribe(({ value }) => {
 *   console.log("Manifest:", value.manifest);
 * });
 * ```
 * @param {Object} pipelines
 * @param {Subject} backoffOptions
 * @returns {Object}
 */

function createManifestFetcher(pipelines, options) {
  var backoffOptions = getManifestBackoffOptions(options);
  var loader = createManifestLoader(pipelines.manifest, backoffOptions);
  var parser = pipelines.manifest.parser;
  return {
    /**
     * Fetch the manifest corresponding to the URL given.
     * @param {string} url - URL of the manifest
     * @returns {Observable}
     */
    fetch: function fetch(url) {
      return loader({
        url: url
      }).pipe(Object(map["a" /* map */])(function (evt) {
        if (evt.type === "warning") {
          return evt;
        }

        var _evt$value = evt.value,
            sendingTime = _evt$value.sendingTime,
            receivedTime = _evt$value.receivedTime;
        var parsingTimeStart = performance.now();
        var schedulerWarnings$ = new Subject["a" /* Subject */]();
        var scheduleRequest = createRequestScheduler(backoffOptions, schedulerWarnings$);
        return {
          type: "response",
          parse: function parse(parserOptions) {
            return Object(merge["a" /* merge */])(schedulerWarnings$.pipe(Object(map["a" /* map */])(function (err) {
              return {
                type: "warning",
                value: err
              };
            })), parser({
              response: evt.value,
              url: url,
              externalClockOffset: parserOptions.externalClockOffset,
              scheduleRequest: scheduleRequest
            }).pipe(Object(catchError["a" /* catchError */])(function (error) {
              throw formatError(error, {
                defaultCode: "PIPELINE_PARSE_ERROR",
                defaultReason: "Unknown error when parsing the Manifest"
              });
            }), Object(mergeMap["a" /* mergeMap */])(function (_ref) {
              var manifest = _ref.manifest;
              // 1 - send warnings first
              var warnings = manifest.parsingErrors;
              var warningEvts$ = empty["a" /* EMPTY */];

              for (var i = 0; i < warnings.length; i++) {
                var warning = warnings[i];
                warningEvts$ = Object(concat["a" /* concat */])(warningEvts$, Object(of["a" /* of */])({
                  type: "warning",
                  value: warning
                }));
              } // 2 - send response


              var parsingTime = performance.now() - parsingTimeStart;
              return Object(concat["a" /* concat */])(warningEvts$, Object(of["a" /* of */])({
                type: "parsed",
                manifest: manifest,
                sendingTime: sendingTime,
                receivedTime: receivedTime,
                parsingTime: parsingTime
              }));
            }), finalize(function () {
              schedulerWarnings$.complete();
            })));
          }
        };
      }));
    }
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/manifest/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var fetchers_manifest = (createManifestFetcher);
// CONCATENATED MODULE: ./src/core/fetchers/segment/get_segment_backoff_options.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR = config["a" /* default */].DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR,
    get_segment_backoff_options_DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE = config["a" /* default */].DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE,
    get_segment_backoff_options_INITIAL_BACKOFF_DELAY_BASE = config["a" /* default */].INITIAL_BACKOFF_DELAY_BASE,
    get_segment_backoff_options_MAX_BACKOFF_DELAY_BASE = config["a" /* default */].MAX_BACKOFF_DELAY_BASE;
/**
 * @param {string} bufferType
 * @param {Object}
 * @returns {Object}
 */

function getSegmentBackoffOptions(bufferType, _ref) {
  var maxRetryRegular = _ref.maxRetryRegular,
      maxRetryOffline = _ref.maxRetryOffline,
      lowLatencyMode = _ref.lowLatencyMode;
  return {
    maxRetryRegular: bufferType === "image" ? 0 : maxRetryRegular !== null && maxRetryRegular !== void 0 ? maxRetryRegular : DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR,
    maxRetryOffline: maxRetryOffline !== null && maxRetryOffline !== void 0 ? maxRetryOffline : get_segment_backoff_options_DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE,
    baseDelay: lowLatencyMode ? get_segment_backoff_options_INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY : get_segment_backoff_options_INITIAL_BACKOFF_DELAY_BASE.REGULAR,
    maxDelay: lowLatencyMode ? get_segment_backoff_options_MAX_BACKOFF_DELAY_BASE.LOW_LATENCY : get_segment_backoff_options_MAX_BACKOFF_DELAY_BASE.REGULAR
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/segment/prioritized_segment_fetcher.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This function basically put in relation:
 *   - a SegmentFetcher, which will be used to perform the segment request
 *   - a prioritizer, which will handle the priority of a segment request
 *
 * and returns functions to fetch segments with a given priority.
 * @param {Object} prioritizer
 * @param {Object} fetcher
 * @returns {Object}
 */
function applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {
  return {
    /**
     * Create a Segment request with a given priority.
     * @param {Object} content - content to request
     * @param {Number} priority - priority at which the content should be
     * requested.
     * @returns {Observable}
     */
    createRequest: function createRequest(content, priority) {
      if (priority === void 0) {
        priority = 0;
      }

      return prioritizer.create(fetcher(content), priority);
    },

    /**
     * Update the priority of a pending request, created through
     * `createRequest`.
     * @param {Observable} observable - the corresponding request
     * @param {Number} priority
     */
    updatePriority: function updatePriority(observable, priority) {
      prioritizer.updatePriority(observable, priority);
    }
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/segment/prioritizer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Create Observables which can be priorized between one another.
 *
 * With this class, you can create Observables with linked priority numbers.
 * The lower this number is, the more priority the resulting Observable will
 * have.
 *
 * Such Observable will then basically wait for pending Observables with more
 * priority to finish before "starting".
 *
 * You can also update the priority of an already-created Observable.
 * This will only have an effect if the Observable is currently "waiting" for
 * its turn (started observable won't be canceled if their priority were
 * lowered).
 *
 * ```js
 * const prioritizer = new ObservablePrioritizer();
 *
 * const observable1 = Observable.of(1);
 * const observable2 = Observable.of(2);
 * const observable3 = Observable.of(3);
 * const observable4 = Observable.of(4);
 * const observable5 = Observable.of(5);
 *
 * const pObservable1 = prioritizer.create(observable1, 4);
 * const pObservable2 = prioritizer.create(observable2, 2);
 * const pObservable3 = prioritizer.create(observable3, 1);
 * const pObservable4 = prioritizer.create(observable4, 3);
 * const pObservable5 = prioritizer.create(observable5, 2);
 *
 * // To spice things up, update pObservable1 priority to go before
 * // pObservable4
 * if (i === 5) { // if pObservable5 is currently emitting
 *   prioritizer.updatePriority(pObservable1, 1);
 * }
 *
 * // start every Observables at the same time
 * observableMerge(
 *   pObservable1,
 *   pObservable2,
 *   pObservable3,
 *   pObservable4,
 *   pObservable5
 * ).subscribe((i) => {
 *   console.log(i);
 * });
 *
 * // Result:
 * // 3
 * // 2
 * // 5
 * // 1
 * // 4
 *
 * // Note: here "1" goes before "4" only because the former's priority has been
 * // updated before the latter was started.
 * // It would be the other way around if not.
 * ```
 *
 * @class ObservablePrioritizer
 */

var prioritizer_ObservablePrioritizer = /*#__PURE__*/function () {
  function ObservablePrioritizer() {
    this._pendingPriority = null;
    this._numberOfPendingObservables = 0;
    this._queue = [];
  }
  /**
   * Create a priorized Observable from a base Observable.
   *
   * When subscribed to, this Observable will have its priority compared to
   * all the already-running Observables created from this class.
   * Only if this number is inferior or equal to the priority of the
   * currently-running Observables will it be immediately started.
   * In the opposite case, we will wait for higher-priority Observables to
   * finish before starting it.
   *
   * Note that while this Observable is waiting for its turn, it is possible
   * to update its property through the updatePriority method, by providing
   * the Observable returned by this function and its new priority number.
   *
   * @param {Observable} obs
   * @param {number} priority
   * @returns {Observable}
   */


  var _proto = ObservablePrioritizer.prototype;

  _proto.create = function create(obs, priority) {
    var _this = this;

    var pObs$ = Object(defer["a" /* defer */])(function () {
      if (_this._pendingPriority == null || _this._pendingPriority >= priority) {
        // Update the priority and start immediately the Observable
        _this._pendingPriority = priority;
        return _this._startObservable(obs);
      } else {
        var trigger = new Subject["a" /* Subject */]();

        _this._queue.push({
          observable: pObs$,
          priority: priority,
          trigger: trigger
        });

        return trigger.pipe(Object(mergeMap["a" /* mergeMap */])(function () {
          return _this._startObservable(obs);
        }));
      }
    });
    return pObs$;
  }
  /**
   * Update the priority of an Observable created through the create method.
   *
   * Note that this will only have an effect on Observable which are not yet
   * started.
   * This means it will only have an effect on:
   *   - unsubscribed Observables
   *   - Observables waiting for Observables with an higher priority to
   *     finish
   *
   * @param {Observable} obs
   * @param {number} priority
   */
  ;

  _proto.updatePriority = function updatePriority(obs, priority) {
    var index = Object(array_find_index["a" /* default */])(this._queue, function (elt) {
      return elt.observable === obs;
    });

    if (index < 0) {
      return;
    }

    var queueElement = this._queue[index];
    queueElement.priority = priority;

    if (this._pendingPriority == null || this._pendingPriority >= priority) {
      this._queue.splice(index, 1);

      queueElement.trigger.next();
      queueElement.trigger.complete();
    }
  };

  _proto._startObservable = function _startObservable(obs) {
    var _this2 = this;

    var onObservableFinish = function onObservableFinish() {
      _this2._numberOfPendingObservables--;

      if (_this2._numberOfPendingObservables > 0) {
        // still waiting for Observables to finish
        return;
      }

      _this2._pendingPriority = null;

      if (_this2._queue.length === 0) {
        return;
      }

      _this2._pendingPriority = _this2._queue.reduce(function (acc, elt) {
        return acc == null || acc > elt.priority ? elt.priority : acc;
      }, null);

      for (var i = 0; i < _this2._queue.length; i++) {
        var elt = _this2._queue[i];

        if (elt.priority === _this2._pendingPriority) {
          _this2._queue.splice(i, 1);

          i--;
          elt.trigger.next();
          elt.trigger.complete();
        }
      }
    };

    this._numberOfPendingObservables++;
    return obs.pipe(finalize(onObservableFinish));
  };

  return ObservablePrioritizer;
}();


// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(10);

// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(57);

// CONCATENATED MODULE: ./src/utils/initialization_segment_cache.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Caching object used to cache initialization segments.
 * This allow to have a faster representation switch and faster seeking.
 * @class InitializationSegmentCache
 */
var InitializationSegmentCache = /*#__PURE__*/function () {
  function InitializationSegmentCache() {
    this._cache = new WeakMap();
  }
  /**
   * @param {Object} obj
   * @param {*} response
   */


  var _proto = InitializationSegmentCache.prototype;

  _proto.add = function add(_ref, response) {
    var representation = _ref.representation,
        segment = _ref.segment;

    if (segment.isInit) {
      this._cache.set(representation, response);
    }
  }
  /**
   * @param {Object} obj
   * @returns {*} response
   */
  ;

  _proto.get = function get(_ref2) {
    var representation = _ref2.representation,
        segment = _ref2.segment;

    if (segment.isInit) {
      var value = this._cache.get(representation);

      if (value !== undefined) {
        return value;
      }
    }

    return null;
  };

  return InitializationSegmentCache;
}();

/* harmony default export */ var initialization_segment_cache = (InitializationSegmentCache);
// EXTERNAL MODULE: ./src/errors/assertion_error.ts
var assertion_error = __webpack_require__(208);

// CONCATENATED MODULE: ./src/utils/assert_unreachable.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function assertUnreachable(_) {
  throw new assertion_error["a" /* default */]("Unreachable path taken");
}
// EXTERNAL MODULE: ./src/utils/cast_to_observable.ts
var cast_to_observable = __webpack_require__(23);

// CONCATENATED MODULE: ./src/core/fetchers/segment/create_segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Returns function allowing to download the wanted data through the loader.
 *
 * (The data can be for example: audio and video segments, text,
 * images...)
 *
 * The function returned takes the initial data in arguments and returns an
 * Observable which will emit:
 *
 *   - each time a request begins (type "request").
 *     This is not emitted if the value is retrieved from a local js cache.
 *     This event emits the payload as a value.
 *
 *   - as the request progresses (type "progress").
 *
 *   - each time a request ends (type "metrics").
 *     This event contains information about the metrics of the request.
 *
 *   - each time a minor request error is encountered (type "warning").
 *     With the error as a value.
 *
 *   - Lastly, with the fetched data (type "response").
 *
 *
 * Each of these but "warning" can be emitted at most one time.
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting the data.
 *
 * Type parameters:
 *   - T: type of the data emitted
 *
 * @param {Function} loader
 * @param {Object | undefined} cache
 * @param {Object} options
 * @returns {Function}
 */

function createSegmentLoader(loader, cache, backoffOptions) {
  /**
   * Load wanted data:
   *   - get it from cache if present
   *   - call the transport loader - with an exponential backoff - if not
   *
   * @param {Object} loaderArgument - Input given to the loader
   * @returns {Observable}
   */
  function loadData(wantedContent) {
    /**
     * Call the Pipeline's loader with an exponential Backoff.
     * @returns {Observable}
     */
    function startLoaderWithBackoff() {
      var _a;

      var request$ = function request$(url) {
        var loaderArgument = Object(object_assign["a" /* default */])({
          url: url
        }, wantedContent);
        return Object(concat["a" /* concat */])(Object(of["a" /* of */])({
          type: "request",
          value: loaderArgument
        }), Object(rx_try_catch["a" /* default */])(loader, loaderArgument));
      };

      return tryURLsWithBackoff((_a = wantedContent.segment.mediaURLs) !== null && _a !== void 0 ? _a : [null], request$, backoffOptions).pipe(Object(catchError["a" /* catchError */])(function (error) {
        throw errorSelector(error);
      }), Object(map["a" /* map */])(function (evt) {
        if (evt.type === "retry") {
          return {
            type: "warning",
            value: errorSelector(evt.value)
          };
        } else if (evt.value.type === "request") {
          return evt.value;
        }

        var response = evt.value;

        if (response.type === "data-loaded" && cache != null) {
          cache.add(wantedContent, response.value);
        }

        return evt.value;
      }));
    }

    var dataFromCache = cache != null ? cache.get(wantedContent) : null;

    if (dataFromCache != null) {
      return Object(cast_to_observable["a" /* default */])(dataFromCache).pipe(Object(map["a" /* map */])(function (response) {
        return {
          type: "cache",
          value: response
        };
      }), Object(catchError["a" /* catchError */])(startLoaderWithBackoff));
    }

    return startLoaderWithBackoff();
  }
  /**
   * Load the corresponding data.
   * @param {Object} content
   * @returns {Observable}
   */


  return function loadSegment(content) {
    return loadData(content).pipe(Object(mergeMap["a" /* mergeMap */])(function (arg) {
      var metrics$ = arg.type === "data-chunk-complete" || arg.type === "data-loaded" ? Object(of["a" /* of */])({
        type: "metrics",
        value: {
          size: arg.value.size,
          duration: arg.value.duration
        }
      }) : empty["a" /* EMPTY */]; // "cache": data taken from the SegmentLoader's cache.
      // "data-created": the data is available but no request has been done
      // "data-loaded": data received through a request

      switch (arg.type) {
        case "warning":
          return Object(of["a" /* of */])(arg);

        case "cache":
        case "data-created":
        case "data-loaded":
          var chunck$ = Object(of["a" /* of */])({
            type: "data",
            value: Object(object_assign["a" /* default */])({}, content, {
              responseData: arg.value.responseData
            })
          });
          return Object(concat["a" /* concat */])(chunck$, metrics$);

        case "request":
        case "progress":
          return Object(of["a" /* of */])(arg);

        case "data-chunk":
          return Object(of["a" /* of */])({
            type: "chunk",
            value: Object(object_assign["a" /* default */])({}, content, {
              responseData: arg.value.responseData
            })
          });

        case "data-chunk-complete":
          var _complete$ = Object(of["a" /* of */])({
            type: "chunk-complete",
            value: null
          });

          return Object(concat["a" /* concat */])(_complete$, metrics$);
      }

      return assertUnreachable(arg);
    }));
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/segment/segment_fetcher.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







var generateRequestID = Object(id_generator["a" /* default */])();
/**
 * Create a function which will fetch and parse segments.
 * @param {string} bufferType
 * @param {Object} transport
 * @param {Subject} requests$
 * @param {Object} options
 * @returns {Function}
 */

function segment_fetcher_createSegmentFetcher(bufferType, transport, requests$, options) {
  var cache = Object(array_includes["a" /* default */])(["audio", "video"], bufferType) ? new initialization_segment_cache() : undefined;
  var segmentLoader = createSegmentLoader(transport[bufferType].loader, cache, options);
  var segmentParser = transport[bufferType].parser; // deal with it

  /**
   * Process the segmentLoader observable to adapt it to the the rest of the
   * code:
   *   - use the requests subject for network requests and their progress
   *   - use the warning$ subject for retries' error messages
   *   - only emit the data
   * @param {Object} content
   * @returns {Observable}
   */

  return function fetchSegment(content) {
    var id = generateRequestID();
    var requestBeginSent = false;
    return segmentLoader(content).pipe(Object(tap["a" /* tap */])(function (arg) {
      switch (arg.type) {
        case "metrics":
          {
            var value = arg.value;
            var size = value.size,
                duration = value.duration; // unwrapping for TS
            // format it for ABR Handling

            if (size != null && duration != null) {
              requests$.next({
                type: "metrics",
                value: {
                  size: size,
                  duration: duration,
                  content: content
                }
              });
            }

            break;
          }

        case "request":
          {
            var _value = arg.value; // format it for ABR Handling

            var segment = _value.segment;

            if (segment == null || segment.duration == null) {
              return;
            }

            requestBeginSent = true;

            var _duration = segment.duration / segment.timescale;

            var time = segment.time / segment.timescale;
            requests$.next({
              type: "requestBegin",
              value: {
                duration: _duration,
                time: time,
                requestTimestamp: performance.now(),
                id: id
              }
            });
            break;
          }

        case "progress":
          {
            var _value2 = arg.value;

            if (_value2.totalSize != null && _value2.size < _value2.totalSize) {
              requests$.next({
                type: "progress",
                value: {
                  duration: _value2.duration,
                  size: _value2.size,
                  totalSize: _value2.totalSize,
                  timestamp: performance.now(),
                  id: id
                }
              });
            }

            break;
          }
      }
    }), finalize(function () {
      if (requestBeginSent) {
        requests$.next({
          type: "requestEnd",
          value: {
            id: id
          }
        });
      }
    }), Object(filter["a" /* filter */])(function (e) {
      switch (e.type) {
        case "chunk":
        case "chunk-complete":
        case "data":
          return true;

        default:
          return false;
      }
    }), Object(mergeMap["a" /* mergeMap */])(function (evt) {
      if (evt.type === "warning") {
        return Object(of["a" /* of */])(evt);
      }

      if (evt.type === "chunk-complete") {
        return Object(of["a" /* of */])({
          type: "chunk-complete"
        });
      }

      var isChunked = evt.type === "chunk";
      var data = {
        type: "chunk",

        /**
         * Parse the loaded data.
         * @param {Object} [initTimescale]
         * @returns {Observable}
         */
        parse: function parse(initTimescale) {
          var response = {
            data: evt.value.responseData,
            isChunked: isChunked
          };
          /* tslint:disable no-unsafe-any */

          return segmentParser({
            response: response,
            initTimescale: initTimescale,
            content: content
          })
          /* tslint:enable no-unsafe-any */
          .pipe(Object(catchError["a" /* catchError */])(function (error) {
            throw formatError(error, {
              defaultCode: "PIPELINE_PARSE_ERROR",
              defaultReason: "Unknown parsing error"
            });
          }));
        }
      };

      if (isChunked) {
        return Object(of["a" /* of */])(data);
      }

      return Object(concat["a" /* concat */])(Object(of["a" /* of */])(data), Object(of["a" /* of */])({
        type: "chunk-complete"
      }));
    }), Object(share["a" /* share */])() // avoid multiple side effects if multiple subs
    );
  };
}
// CONCATENATED MODULE: ./src/core/fetchers/segment/segment_fetcher_creator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Interact with the transport pipelines to download segments with the right
 * priority.
 *
 * @class SegmentFetcherCreator
 *
 * @example
 * ```js
 * const creator = new SegmentFetcherCreator(transport);
 *
 * // 2 - create a new fetcher with its backoff options
 * const fetcher = creator.createSegmentFetcher("audio", {
 *   maxRetryRegular: Infinity,
 *   maxRetryOffline: Infinity,
 * });
 *
 * // 3 - load a segment with a given priority
 * fetcher.createRequest(myContent, 1)
 *   // 4 - parse it
 *   .pipe(
 *     filter(evt => evt.type === "chunk"),
 *     mergeMap(response => response.parse());
 *   )
 *   // 5 - use it
 *   .subscribe((res) => console.log("audio chunk downloaded:", res));
 * ```
 */

var segment_fetcher_creator_SegmentFetcherCreator = /*#__PURE__*/function () {
  /**
   * @param {Object} transport
   */
  function SegmentFetcherCreator(transport, options) {
    this._transport = transport;
    this._prioritizer = new prioritizer_ObservablePrioritizer();
    this._backoffOptions = options;
  }
  /**
   * Create a segment fetcher, allowing to easily perform segment requests.
   * @param {string} bufferType
   * @param {Object} options
   * @returns {Object}
   */


  var _proto = SegmentFetcherCreator.prototype;

  _proto.createSegmentFetcher = function createSegmentFetcher(bufferType, requests$) {
    var backoffOptions = getSegmentBackoffOptions(bufferType, this._backoffOptions);

    var segmentFetcher = segment_fetcher_createSegmentFetcher(bufferType, this._transport, requests$, backoffOptions);

    return applyPrioritizerToSegmentFetcher(this._prioritizer, segmentFetcher);
  };

  return SegmentFetcherCreator;
}();


// CONCATENATED MODULE: ./src/core/fetchers/segment/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var fetchers_segment = (segment_fetcher_creator_SegmentFetcherCreator);
// EXTERNAL MODULE: ./src/core/init/create_eme_manager.ts
var create_eme_manager = __webpack_require__(124);

// EXTERNAL MODULE: ./src/compat/clear_element_src.ts
var clear_element_src = __webpack_require__(90);

// EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
var browser_compatibility_types = __webpack_require__(26);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/core/init/create_media_source.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var onSourceOpen$ = compat["a" /* events */].onSourceOpen$;
/**
 * Set the media duration in the mediaSource.
 * @param {MediaSource} mediaSource
 * @param {number} duration
 */

function setDurationToMediaSource(mediaSource, duration) {
  var newDuration = duration === Infinity ? Number.MAX_VALUE : duration;

  if (mediaSource.duration !== newDuration) {
    log["a" /* default */].info("Init: Setting duration", newDuration);
    mediaSource.duration = newDuration;
  }
}
/**
 * Dispose of ressources taken by the MediaSource:
 *   - Clear the MediaSource' SourceBuffers
 *   - Clear the mediaElement's src (stop the mediaElement)
 *   - Revoke MediaSource' URL
 * @param {HTMLMediaElement} mediaElement
 * @param {MediaSource|null} mediaSource
 * @param {string|null} mediaSourceURL
 */

function resetMediaSource(mediaElement, mediaSource, mediaSourceURL) {
  if (mediaSource !== null && mediaSource.readyState !== "closed") {
    var readyState = mediaSource.readyState,
        sourceBuffers = mediaSource.sourceBuffers;

    for (var i = sourceBuffers.length - 1; i >= 0; i--) {
      var sourceBuffer = sourceBuffers[i];

      try {
        if (readyState === "open") {
          log["a" /* default */].info("Init: Removing SourceBuffer from mediaSource", sourceBuffer);
          sourceBuffer.abort();
        }

        mediaSource.removeSourceBuffer(sourceBuffer);
      } catch (e) {
        log["a" /* default */].warn("Init: Error while disposing SourceBuffer", e);
      }
    }

    if (sourceBuffers.length > 0) {
      log["a" /* default */].warn("Init: Not all SourceBuffers could have been removed.");
    }
  }

  Object(clear_element_src["a" /* default */])(mediaElement);

  if (mediaSourceURL !== null) {
    try {
      log["a" /* default */].debug("Init: Revoking previous URL");
      URL.revokeObjectURL(mediaSourceURL);
    } catch (e) {
      log["a" /* default */].warn("Init: Error while revoking the media source URL", e);
    }
  }
}
/**
 * Create, on subscription, a MediaSource instance and attach it to the given
 * mediaElement element's src attribute.
 *
 * Returns an Observable which emits the MediaSource when created and attached
 * to the mediaElement element.
 * This Observable never completes. It can throw if MediaSource is not
 * available in the current environment.
 *
 * On unsubscription, the mediaElement.src is cleaned, MediaSource sourceBuffers
 * and customBuffers are aborted and some minor cleaning is done.
 *
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function createMediaSource(mediaElement) {
  return new Observable["a" /* Observable */](function (observer) {
    if (browser_compatibility_types["c" /* MediaSource_ */] == null) {
      throw new media_error["a" /* default */]("MEDIA_SOURCE_NOT_SUPPORTED", "No MediaSource Object was found in the current browser.");
    } // make sure the media has been correctly reset


    var oldSrc = Object(is_non_empty_string["a" /* default */])(mediaElement.src) ? mediaElement.src : null;
    resetMediaSource(mediaElement, null, oldSrc);
    log["a" /* default */].info("Init: Creating MediaSource");
    var mediaSource = new browser_compatibility_types["c" /* MediaSource_ */]();
    var objectURL = URL.createObjectURL(mediaSource);
    log["a" /* default */].info("Init: Attaching MediaSource URL to the media element", objectURL);
    mediaElement.src = objectURL;
    observer.next(mediaSource);
    return function () {
      resetMediaSource(mediaElement, mediaSource, objectURL);
    };
  });
}
/**
 * Create and open a new MediaSource object on the given media element.
 * Emit the MediaSource when done.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */


function openMediaSource(mediaElement) {
  return createMediaSource(mediaElement).pipe(Object(mergeMap["a" /* mergeMap */])(function (mediaSource) {
    return onSourceOpen$(mediaSource).pipe(Object(take["a" /* take */])(1), Object(mapTo["a" /* mapTo */])(mediaSource));
  }));
}
// EXTERNAL MODULE: ./src/core/init/events_generators.ts
var events_generators = __webpack_require__(30);

// CONCATENATED MODULE: ./src/core/init/get_initial_time.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var DEFAULT_LIVE_GAP = config["a" /* default */].DEFAULT_LIVE_GAP;
/**
 * Returns the calculated initial time for the content described by the given
 * Manifest:
 *   1. if a start time is defined by user, calculate starting time from the
 *      manifest information
 *   2. else if the media is live, use the live edge and suggested delays from
 *      it
 *   3. else returns the minimum time announced in the manifest
 * @param {Manifest} manifest
 * @param {boolean} lowLatencyMode
 * @param {Object} startAt
 * @returns {Number}
 */

function getInitialTime(manifest, lowLatencyMode, startAt) {
  log["a" /* default */].debug("Init: calculating initial time");

  if (startAt != null) {
    var min = manifest.getMinimumPosition();
    var max = manifest.getMaximumPosition();

    if (startAt.position != null) {
      log["a" /* default */].debug("Init: using startAt.minimumPosition");
      return Math.max(Math.min(startAt.position, max), min);
    } else if (startAt.wallClockTime != null) {
      log["a" /* default */].debug("Init: using startAt.wallClockTime");
      var ast = manifest.availabilityStartTime == null ? 0 : manifest.availabilityStartTime;
      var position = startAt.wallClockTime - ast;
      return Math.max(Math.min(position, max), min);
    } else if (startAt.fromFirstPosition != null) {
      log["a" /* default */].debug("Init: using startAt.fromFirstPosition");
      var fromFirstPosition = startAt.fromFirstPosition;
      return fromFirstPosition <= 0 ? min : Math.min(max, min + fromFirstPosition);
    } else if (startAt.fromLastPosition != null) {
      log["a" /* default */].debug("Init: using startAt.fromLastPosition");
      var fromLastPosition = startAt.fromLastPosition;
      return fromLastPosition >= 0 ? max : Math.max(min, max + fromLastPosition);
    } else if (startAt.percentage != null) {
      log["a" /* default */].debug("Init: using startAt.percentage");
      var percentage = startAt.percentage;

      if (percentage > 100) {
        return max;
      } else if (percentage < 0) {
        return min;
      }

      var ratio = +percentage / 100;
      var extent = max - min;
      return min + extent * ratio;
    }
  }

  var minimumPosition = manifest.getMinimumPosition();

  if (manifest.isLive) {
    var suggestedPresentationDelay = manifest.suggestedPresentationDelay,
        clockOffset = manifest.clockOffset;
    var maximumPosition = manifest.getMaximumPosition();
    var liveTime;

    if (clockOffset == null) {
      log["a" /* default */].info("Init: no clock offset found for a live content, " + "starting close to maximum available position");
      liveTime = maximumPosition;
    } else {
      log["a" /* default */].info("Init: clock offset found for a live content, " + "checking if we can start close to it");

      var _ast = manifest.availabilityStartTime == null ? 0 : manifest.availabilityStartTime;

      var clockRelativeLiveTime = (performance.now() + clockOffset) / 1000 - _ast;

      liveTime = Math.min(maximumPosition, clockRelativeLiveTime);
    }

    log["a" /* default */].debug("Init: " + liveTime + " defined as the live time, applying a live gap" + (" of " + suggestedPresentationDelay));

    if (suggestedPresentationDelay !== undefined) {
      return Math.max(liveTime - suggestedPresentationDelay, minimumPosition);
    }

    var defaultStartingPos = liveTime - (lowLatencyMode ? DEFAULT_LIVE_GAP.LOW_LATENCY : DEFAULT_LIVE_GAP.DEFAULT);
    return Math.max(defaultStartingPos, minimumPosition);
  }

  log["a" /* default */].info("Init: starting at the minimum available position:", minimumPosition);
  return minimumPosition;
}
// EXTERNAL MODULE: ./src/core/init/is_eme_ready.ts
var is_eme_ready = __webpack_require__(129);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/InnerSubscriber.js
var InnerSubscriber = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js + 6 modules
var from = __webpack_require__(63);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */






function exhaustMap(project, resultSelector) {
    if (resultSelector) {
        return function (source) { return source.pipe(exhaustMap(function (a, i) { return Object(from["a" /* from */])(project(a, i)).pipe(Object(map["a" /* map */])(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) {
        return source.lift(new ExhaustMapOperator(project));
    };
}
var ExhaustMapOperator = /*@__PURE__*/ (function () {
    function ExhaustMapOperator(project) {
        this.project = project;
    }
    ExhaustMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new exhaustMap_ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator;
}());
var exhaustMap_ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result, value, index);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscriber = new InnerSubscriber["a" /* InnerSubscriber */](this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        Object(subscribeToResult["a" /* subscribeToResult */])(this, result, value, index, innerSubscriber);
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(OuterSubscriber["a" /* OuterSubscriber */]));
//# sourceMappingURL=exhaustMap.js.map

// CONCATENATED MODULE: ./src/utils/sorted_list.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Creates an Array automatically sorted with the sorting function given to the
 * constructor when the add method is called.
 *
 * @example
 * ```js
 * const sortedList = new SortedList((a, b) => a.start - b.start);
 * const element1 = { start: 20 };
 * const element2 = { start: 10 };
 * const element3 = { start: 15 };
 *
 * sortedList.add(element1, element2);
 * console.log(sortedList.unwrap());
 * // -> [{ start: 10 }, { start : 20 }]
 *
 * sortedList.add(element3);
 * console.log(sortedList.unwrap());
 * // -> [{ start: 10 }, { start : 15 }, { start: 20 }]
 *
 * sortedList.removeElement(element2);
 * // -> [{ start: 10 }, { start: 15 }]
 * ```
 * @class SortedList
 */

var sorted_list_SortedList = /*#__PURE__*/function () {
  /**
   * @param {Function} sortingFunction
   */
  function SortedList(sortingFunction) {
    this._array = [];
    this._sortingFn = sortingFunction;
  }
  /**
   * Add a new element to the List at the right place for the List to stay
   * sorted.
   *
   * /!\ The added Element will share the same reference than the given
   * argument, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @param {...*} elements
   */


  var _proto = SortedList.prototype;

  _proto.add = function add() {
    for (var _len = arguments.length, elements = new Array(_len), _key = 0; _key < _len; _key++) {
      elements[_key] = arguments[_key];
    }

    elements.sort(this._sortingFn);
    var j = 0;

    for (var i = 0; i < elements.length; i++) {
      var element = elements[i];
      var inserted = false;

      while (!inserted && j < this._array.length) {
        if (this._sortingFn(element, this._array[j]) < 0) {
          this._array.splice(j, 0, element);

          inserted = true;
        } else {
          j++;
        }
      }

      if (!inserted) {
        this._array.push(element);
      }
    }
  }
  /**
   * Returns the current length of the list.
   * @returns {number}
   */
  ;

  _proto.length = function length() {
    return this._array.length;
  }
  /**
   * Returns the nth element. Throws if the index does not exist.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @throws Error - Throws if the given index is negative or superior to the
   * array's length.
   * @param {number} index
   * @returns {*}
   */
  ;

  _proto.get = function get(index) {
    if (index < 0 || index >= this._array.length) {
      throw new Error("Invalid index.");
    }

    return this._array[index];
  }
  /**
   * Find the first element corresponding to the given predicate.
   *
   * /!\ The returned element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @param {Function} fn
   * @returns {*}
   */
  ;

  _proto.findFirst = function findFirst(fn) {
    return Object(array_find["a" /* default */])(this._array, fn);
  }
  /**
   * Returns true if the List contains the given element.
   * @param {*} element
   * @returns {Boolean}
   */
  ;

  _proto.has = function has(element) {
    return Object(array_includes["a" /* default */])(this._array, element);
  }
  /**
   * Remove the first occurence of the given element.
   * Returns the index of the removed element. Undefined if not found.
   * @returns {number|undefined}
   */
  ;

  _proto.removeElement = function removeElement(element) {
    var indexOf = this._array.indexOf(element);

    if (indexOf >= 0) {
      this._array.splice(indexOf, 1);

      return indexOf;
    }
  }
  /**
   * Returns the first element.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @returns {*}
   */
  ;

  _proto.head = function head() {
    return this._array[0];
  }
  /**
   * Returns the last element.
   *
   * /!\ The returned Element shares the same reference with what is used
   * internally, any mutation on your part can lead to an un-sorted SortedList.
   * You can still re-force the sorting to happen by calling forceSort.
   * @returns {*}
   */
  ;

  _proto.last = function last() {
    return this._array[this._array.length - 1];
  }
  /**
   * Remove the first element.
   * Returns the element removed or undefined if no element were removed.
   * @returns {*}
   */
  ;

  _proto.shift = function shift() {
    return this._array.shift();
  }
  /**
   * Remove the last element.
   * Returns the element removed or undefined if no element were removed.
   * @returns {*}
   */
  ;

  _proto.pop = function pop() {
    return this._array.pop();
  };

  return SortedList;
}();


// CONCATENATED MODULE: ./src/utils/weak_map_memory.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Memoize Function results linked to an object, through a WeakMap.
 *
 * @example
 * ```js
 * // Initialize the WeakMapMemory with its logic:
 * const memory = new WeakMapMemory(arg => {
 *   console.log("side-effect");
 *   return [arg.a, arg.b];
 * });
 *
 * const obj = { a: 1, b: 2 };
 *
 * // first time obj is given: call the function, save the result and return it:
 * const arr1 = memory.get(obj);
 * // >  "side-effect"
 * // <- [1, 2]
 *
 * // nth time obj is given, returns the saved result without calling the
 * // function:
 * const arr2 = memory.get(obj);
 * // <- [1, 2]
 *
 * // both of these use the same object, so the result is also the exact same
 * // one
 * console.log(arr1 === arr2); // => true
 *
 * // /!\ with a new object however:
 * const obj2 = { a: 1, b: 2 };
 *
 * const arr3 = memory.get(obj2);
 * // >  "side-effect"
 * // <- [1, 2]
 *
 * console.log(arr1 === arr3); // => false
 * ```
 * @class WeakMapMemory
 */
var WeakMapMemory = /*#__PURE__*/function () {
  /**
   * @param {Function}
   */
  function WeakMapMemory(fn) {
    this._weakMap = new WeakMap();
    this._fn = fn;
  }
  /**
   * @param {Object} obj
   * @returns {*}
   */


  var _proto = WeakMapMemory.prototype;

  _proto.get = function get(obj) {
    var fromMemory = this._weakMap.get(obj);

    if (fromMemory === undefined) {
      var newElement = this._fn(obj);

      this._weakMap.set(obj, newElement);

      return newElement;
    } else {
      return fromMemory;
    }
  }
  /**
   * @param {Object} obj
   */
  ;

  _proto.destroy = function destroy(obj) {
    this._weakMap["delete"](obj);
  };

  return WeakMapMemory;
}();


// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatAll.js
var concatAll = __webpack_require__(169);

// CONCATENATED MODULE: ./src/core/source_buffers/garbage_collector.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Perform cleaning of the buffer according to the values set by the user
 * at each clock tick and each times the maxBufferBehind/maxBufferAhead values
 * change.
 *
 * @param {Object} opt
 * @returns {Observable}
 */

function BufferGarbageCollector(_ref) {
  var queuedSourceBuffer = _ref.queuedSourceBuffer,
      clock$ = _ref.clock$,
      maxBufferBehind$ = _ref.maxBufferBehind$,
      maxBufferAhead$ = _ref.maxBufferAhead$;
  return Object(combineLatest["a" /* combineLatest */])([clock$, maxBufferBehind$, maxBufferAhead$]).pipe(Object(mergeMap["a" /* mergeMap */])(function (_ref2) {
    var currentTime = _ref2[0],
        maxBufferBehind = _ref2[1],
        maxBufferAhead = _ref2[2];
    return clearBuffer(queuedSourceBuffer, currentTime, maxBufferBehind, maxBufferAhead);
  }));
}
/**
 * Remove buffer from the browser's memory based on the user's
 * maxBufferAhead / maxBufferBehind settings.
 *
 * Normally, the browser garbage-collect automatically old-added chunks of
 * buffer date when memory is scarce. However, you might want to control
 * the size of memory allocated. This function takes the current position
 * and a "depth" behind and ahead wanted for the buffer, in seconds.
 *
 * Anything older than the depth will be removed from the buffer.
 * @param {QueuedSourceBuffer} qSourceBuffer
 * @param {Number} position - The current position
 * @param {Number} maxBufferBehind
 * @param {Number} maxBufferAhead
 * @returns {Observable}
 */

function clearBuffer(qSourceBuffer, position, maxBufferBehind, maxBufferAhead) {
  if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) {
    return empty["a" /* EMPTY */];
  }

  var cleanedupRanges = [];

  var _getInnerAndOuterTime = Object(ranges["c" /* getInnerAndOuterTimeRanges */])(qSourceBuffer.getBufferedRanges(), position),
      innerRange = _getInnerAndOuterTime.innerRange,
      outerRanges = _getInnerAndOuterTime.outerRanges;

  var collectBufferBehind = function collectBufferBehind() {
    if (!isFinite(maxBufferBehind)) {
      return;
    } // begin from the oldest


    for (var i = 0; i < outerRanges.length; i++) {
      var outerRange = outerRanges[i];

      if (position - maxBufferBehind >= outerRange.end) {
        cleanedupRanges.push(outerRange);
      } else if (position >= outerRange.end && position - maxBufferBehind > outerRange.start && position - maxBufferBehind < outerRange.end) {
        cleanedupRanges.push({
          start: outerRange.start,
          end: position - maxBufferBehind
        });
      }
    }

    if (innerRange != null) {
      if (position - maxBufferBehind > innerRange.start) {
        cleanedupRanges.push({
          start: innerRange.start,
          end: position - maxBufferBehind
        });
      }
    }
  };

  var collectBufferAhead = function collectBufferAhead() {
    if (!isFinite(maxBufferAhead)) {
      return;
    } // begin from the oldest


    for (var i = 0; i < outerRanges.length; i++) {
      var outerRange = outerRanges[i];

      if (position + maxBufferAhead <= outerRange.start) {
        cleanedupRanges.push(outerRange);
      } else if (position <= outerRange.start && position + maxBufferAhead < outerRange.end && position + maxBufferAhead > outerRange.start) {
        cleanedupRanges.push({
          start: position + maxBufferAhead,
          end: outerRange.end
        });
      }
    }

    if (innerRange != null) {
      if (position + maxBufferAhead < innerRange.end) {
        cleanedupRanges.push({
          start: position + maxBufferAhead,
          end: innerRange.end
        });
      }
    }
  };

  collectBufferBehind();
  collectBufferAhead();
  var clean$ = Object(from["a" /* from */])(cleanedupRanges.map(function (range) {
    log["a" /* default */].debug("GC: cleaning range from SourceBuffer", range);
    return qSourceBuffer.removeBuffer(range.start, range.end);
  })).pipe(Object(concatAll["a" /* concatAll */])(), Object(ignoreElements["a" /* ignoreElements */])());
  return clean$;
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
var observable_interval = __webpack_require__(207);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(206);

// EXTERNAL MODULE: ./src/compat/change_source_buffer_type.ts
var change_source_buffer_type = __webpack_require__(165);

// EXTERNAL MODULE: ./src/manifest/are_same_content.ts
var are_same_content = __webpack_require__(164);

// CONCATENATED MODULE: ./src/core/source_buffers/segment_inventory.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE = config["a" /* default */].MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE,
    MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE = config["a" /* default */].MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE,
    MINIMUM_SEGMENT_SIZE = config["a" /* default */].MINIMUM_SEGMENT_SIZE;
/**
 * Keep track of every chunk downloaded and currently in the browser's memory.
 *
 * The main point of this class is to know which CDN chunks are already
 * pushed to the SourceBuffer, at which bitrate, and which have been
 * garbage-collected since by the browser (and thus should be re-downloaded).
 * @class SegmentInventory
 */

var segment_inventory_SegmentInventory = /*#__PURE__*/function () {
  function SegmentInventory() {
    this.inventory = [];
  }
  /**
   * Reset the whole inventory.
   */


  var _proto = SegmentInventory.prototype;

  _proto.reset = function reset() {
    this.inventory.length = 0;
  }
  /**
   * Infer each segment's bufferedStart and bufferedEnd from the TimeRanges
   * given (coming from the SourceBuffer).
   * @param {TimeRanges}
   */
  ;

  _proto.synchronizeBuffered = function synchronizeBuffered(buffered) {
    var inventory = this.inventory;
    var inventoryIndex = 0; // Current index considered.

    var thisSegment = inventory[0]; // Current segmentInfos considered

    var rangesLength = buffered.length;

    for (var i = 0; i < rangesLength; i++) {
      if (thisSegment === undefined) {
        // we arrived at the end of our inventory
        return;
      } // take the i'nth contiguous buffered TimeRange


      var rangeStart = buffered.start(i);
      var rangeEnd = buffered.end(i);

      if (rangeEnd - rangeStart < MINIMUM_SEGMENT_SIZE) {
        log["a" /* default */].warn("SI: skipped TimeRange when synchronizing because it was too small", rangeStart, rangeEnd);
        continue;
      }

      var indexBefore = inventoryIndex; // keep track of that number
      // Find the first segment either within this TimeRange or completely past
      // it:
      // skip until first segment with at least `MINIMUM_SEGMENT_SIZE` past the
      // start of that range.

      while (thisSegment !== undefined && Object(take_first_set["a" /* default */])(thisSegment.bufferedEnd, thisSegment.end) - rangeStart < MINIMUM_SEGMENT_SIZE) {
        thisSegment = inventory[++inventoryIndex];
      } // Contains infos about the last garbage-collected segment before
      // `thisSegment`.


      var lastDeletedSegmentInfos = {
        end: -1,
        precizeEnd: false
      }; // remove garbage-collected segments
      // (not in that TimeRange nor in the previous one)

      var numberOfSegmentToDelete = inventoryIndex - indexBefore;

      if (numberOfSegmentToDelete > 0) {
        var lastDeletedSegment = // last garbage-collected segment
        inventory[indexBefore + numberOfSegmentToDelete - 1];
        lastDeletedSegmentInfos.end = Object(take_first_set["a" /* default */])(lastDeletedSegment.bufferedEnd, lastDeletedSegment.end);
        lastDeletedSegmentInfos.precizeEnd = lastDeletedSegment.precizeEnd;
        log["a" /* default */].debug("SI: " + numberOfSegmentToDelete + " segments GCed.");
        inventory.splice(indexBefore, numberOfSegmentToDelete);
        inventoryIndex = indexBefore;
      }

      if (thisSegment === undefined) {
        return;
      } // If the current segment is actually completely outside that range (it
      // is contained in one of the next one), skip that part.


      if (rangeEnd - Object(take_first_set["a" /* default */])(thisSegment.bufferedStart, thisSegment.start) >= MINIMUM_SEGMENT_SIZE) {
        guessBufferedStartFromRangeStart(thisSegment, rangeStart, lastDeletedSegmentInfos);

        if (inventoryIndex === inventory.length - 1) {
          guessBufferedEndFromRangeEnd(thisSegment, rangeEnd);
          return;
        }

        thisSegment = inventory[++inventoryIndex]; // Make contiguous until first segment outside that range

        var thisSegmentStart = Object(take_first_set["a" /* default */])(thisSegment.bufferedStart, thisSegment.start);
        var thisSegmentEnd = Object(take_first_set["a" /* default */])(thisSegment.bufferedEnd, thisSegment.end);
        var nextRangeStart = i < rangesLength - 1 ? buffered.start(i + 1) : undefined;

        while (thisSegment !== undefined && rangeEnd - thisSegmentStart >= MINIMUM_SEGMENT_SIZE && (nextRangeStart === undefined || rangeEnd - thisSegmentStart >= thisSegmentEnd - nextRangeStart)) {
          var prevSegment = inventory[inventoryIndex - 1]; // those segments are contiguous, we have no way to infer their real
          // end

          if (prevSegment.bufferedEnd === undefined) {
            prevSegment.bufferedEnd = thisSegment.precizeStart ? thisSegment.start : prevSegment.end;
            log["a" /* default */].debug("SI: calculating buffered end of contiguous segment", prevSegment.bufferedEnd, prevSegment.end);
          }

          thisSegment.bufferedStart = prevSegment.bufferedEnd;
          thisSegment = inventory[++inventoryIndex];

          if (thisSegment !== undefined) {
            thisSegmentStart = Object(take_first_set["a" /* default */])(thisSegment.bufferedStart, thisSegment.start);
            thisSegmentEnd = Object(take_first_set["a" /* default */])(thisSegment.bufferedEnd, thisSegment.end);
          }
        }
      } // update the bufferedEnd of the last segment in that range


      var lastSegmentInRange = inventory[inventoryIndex - 1];

      if (lastSegmentInRange !== undefined) {
        guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd);
      }
    } // if we still have segments left, they are not affiliated to any range.
    // They might have been garbage collected, delete them from here.


    if (thisSegment != null) {
      log["a" /* default */].debug("SI: last segments have been GCed", inventoryIndex, inventory.length);
      inventory.splice(inventoryIndex, inventory.length - inventoryIndex);
    }
  }
  /**
   * Add a new segment in the inventory.
   *
   * Note: As new segments can "replace" partially or completely old ones, we
   * have to perform a complex logic and might update previously added segments.
   *
   * @param {Object} chunkInformation
   */
  ;

  _proto.insertChunk = function insertChunk(_ref) {
    var period = _ref.period,
        adaptation = _ref.adaptation,
        representation = _ref.representation,
        segment = _ref.segment,
        start = _ref.start,
        end = _ref.end;

    if (segment.isInit) {
      return;
    }

    if (start >= end) {
      log["a" /* default */].warn("SI: Invalid chunked inserted: starts before it ends", start, end);
      return;
    }

    var inventory = this.inventory;
    var newSegment = {
      partiallyPushed: true,
      estimatedStart: start,
      start: start,
      end: end,
      precizeStart: false,
      precizeEnd: false,
      bufferedStart: undefined,
      bufferedEnd: undefined,
      infos: {
        segment: segment,
        period: period,
        adaptation: adaptation,
        representation: representation
      }
    }; // begin by the end as in most use cases this will be faster

    for (var i = inventory.length - 1; i >= 0; i--) {
      var segmentI = inventory[i];

      if (segmentI.start <= start) {
        if (segmentI.end <= start) {
          // our segment is after, push it after this one
          //
          // Case 1:
          //   prevSegment  : |------|
          //   newSegment   :        |======|
          //   ===>         : |------|======|
          //
          // Case 2:
          //   prevSegment  : |------|
          //   newSegment   :          |======|
          //   ===>         : |------| |======|
          log["a" /* default */].debug("SI: Pushing segment strictly after previous one.");
          this.inventory.splice(i + 1, 0, newSegment);
          i += 2; // Go to segment immediately after newSegment

          while (i < inventory.length && inventory[i].start < newSegment.end) {
            if (inventory[i].end > newSegment.end) {
              // The next segment ends after newSegment.
              // Mutate the next segment.
              //
              // Case 1:
              //   prevSegment  : |------|
              //   newSegment   :        |======|
              //   nextSegment  :            |----|
              //   ===>         : |------|======|-|
              log["a" /* default */].debug("SI: Segment pushed updates the start of the next one");
              inventory[i].start = newSegment.end;
              inventory[i].bufferedStart = undefined;
              inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd;
              return;
            } // The next segment was completely contained in newSegment.
            // Remove it.
            //
            // Case 1:
            //   prevSegment  : |------|
            //   newSegment   :        |======|
            //   nextSegment  :          |---|
            //   ===>         : |------|======|
            //
            // Case 2:
            //   prevSegment  : |------|
            //   newSegment   :        |======|
            //   nextSegment  :          |----|
            //   ===>         : |------|======|


            log["a" /* default */].debug("SI: Segment pushed removes the next one");
            inventory.splice(i, 1);
          }

          return;
        } else {
          if (segmentI.start === start) {
            if (segmentI.end <= end) {
              // In those cases, replace
              //
              // Case 1:
              //  prevSegment  : |-------|
              //  newSegment   : |=======|
              //  ===>         : |=======|
              //
              // Case 2:
              //  prevSegment  : |-------|
              //  newSegment   : |==========|
              //  ===>         : |==========|
              log["a" /* default */].debug("SI: Segment pushed replace another one");
              this.inventory.splice(i, 1, newSegment);
              i += 1; // Go to segment immediately after newSegment

              while (i < inventory.length && inventory[i].start < newSegment.end) {
                if (inventory[i].end > newSegment.end) {
                  // The next segment ends after newSegment.
                  // Mutate the next segment.
                  //
                  // Case 1:
                  //   newSegment   : |======|
                  //   nextSegment  :      |----|
                  //   ===>         : |======|--|
                  log["a" /* default */].debug("SI: Segment pushed updates the start of the next one");
                  inventory[i].start = newSegment.end;
                  inventory[i].bufferedStart = undefined;
                  inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd;
                  return;
                } // The next segment was completely contained in newSegment.
                // Remove it.
                //
                // Case 1:
                //   newSegment   : |======|
                //   nextSegment  :   |---|
                //   ===>         : |======|
                //
                // Case 2:
                //   newSegment   : |======|
                //   nextSegment  :   |----|
                //   ===>         : |======|


                log["a" /* default */].debug("SI: Segment pushed removes the next one");
                inventory.splice(i, 1);
              }

              return;
            } else {
              // The previous segment starts at the same time and finishes
              // after the new segment.
              // Update the start of the previous segment and put the new
              // segment before.
              //
              // Case 1:
              //  prevSegment  : |------------|
              //  newSegment   : |==========|
              //  ===>         : |==========|-|
              log["a" /* default */].debug("SI: Segment pushed ends before another with the same start");
              inventory.splice(i, 0, newSegment);
              segmentI.start = newSegment.end;
              segmentI.bufferedStart = undefined;
              segmentI.precizeStart = segmentI.precizeStart && newSegment.precizeEnd;
              return;
            }
          } else {
            if (segmentI.end <= newSegment.end) {
              // our segment has a "complex" relation with this one,
              // update the old one end and add this one after it.
              //
              // Case 1:
              //  prevSegment  : |-------|
              //  newSegment   :    |======|
              //  ===>         : |--|======|
              //
              // Case 2:
              //  prevSegment  : |-------|
              //  newSegment   :    |====|
              //  ===>         : |--|====|
              log["a" /* default */].debug("SI: Segment pushed updates end of previous one");
              this.inventory.splice(i + 1, 0, newSegment);
              segmentI.end = newSegment.start;
              segmentI.bufferedEnd = undefined;
              segmentI.precizeEnd = segmentI.precizeEnd && newSegment.precizeStart;
              i += 2; // Go to segment immediately after newSegment

              while (i < inventory.length && inventory[i].start < newSegment.end) {
                if (inventory[i].end > newSegment.end) {
                  // The next segment ends after newSegment.
                  // Mutate the next segment.
                  //
                  // Case 1:
                  //   newSegment   : |======|
                  //   nextSegment  :      |----|
                  //   ===>         : |======|--|
                  log["a" /* default */].debug("SI: Segment pushed updates the start of the next one");
                  inventory[i].start = newSegment.end;
                  inventory[i].bufferedStart = undefined;
                  inventory[i].precizeStart = inventory[i].precizeStart && newSegment.precizeEnd;
                  return;
                } // The next segment was completely contained in newSegment.
                // Remove it.
                //
                // Case 1:
                //   newSegment   : |======|
                //   nextSegment  :   |---|
                //   ===>         : |======|
                //
                // Case 2:
                //   newSegment   : |======|
                //   nextSegment  :   |----|
                //   ===>         : |======|


                log["a" /* default */].debug("SI: Segment pushed removes the next one");
                inventory.splice(i, 1);
              }

              return;
            } else {
              // The previous segment completely recovers the new segment.
              // Split the previous segment into two segments, before and after
              // the new segment.
              //
              // Case 1:
              //  prevSegment  : |---------|
              //  newSegment   :    |====|
              //  ===>         : |--|====|-|
              log["a" /* default */].debug("SI: Segment pushed is contained in a previous one");
              var nextSegment = {
                partiallyPushed: segmentI.partiallyPushed,
                start: newSegment.end,
                end: segmentI.end,
                precizeStart: segmentI.precizeStart && segmentI.precizeEnd && newSegment.precizeEnd,
                precizeEnd: segmentI.precizeEnd,
                bufferedStart: undefined,
                bufferedEnd: segmentI.end,
                infos: segmentI.infos
              };
              segmentI.end = newSegment.start;
              segmentI.bufferedEnd = undefined;
              segmentI.precizeEnd = segmentI.precizeEnd && newSegment.precizeStart;
              inventory.splice(i + 1, 0, newSegment);
              inventory.splice(i + 2, 0, nextSegment);
              return;
            }
          }
        }
      }
    } // if we got here, we are the first segment
    // check bounds of the previous first segment


    var firstSegment = this.inventory[0];

    if (firstSegment == null) {
      // we do not have any segment yet
      log["a" /* default */].debug("SI: Segment pushed comes after all previous ones");
      this.inventory.push(newSegment);
      return;
    }

    if (firstSegment.start >= end) {
      // our segment is before, put it before
      //
      // Case 1:
      //  firstSegment :      |----|
      //  newSegment   : |====|
      //  ===>         : |====|----|
      //
      // Case 2:
      //  firstSegment :        |----|
      //  newSegment   : |====|
      //  ===>         : |====| |----|
      log["a" /* default */].debug("SI: Segment pushed comes before all previous ones");
      this.inventory.splice(0, 0, newSegment);
    } else if (firstSegment.end <= end) {
      // Our segment is bigger, replace the first
      //
      // Case 1:
      //  firstSegment :   |---|
      //  newSegment   : |=======|
      //  ===>         : |=======|
      //
      // Case 2:
      //  firstSegment :   |-----|
      //  newSegment   : |=======|
      //  ===>         : |=======|
      log["a" /* default */].debug("SI: Segment pushed starts before and completely " + "recovers the previous first one");
      this.inventory.splice(0, 1, newSegment);

      while (inventory.length > 1 && inventory[1].start < newSegment.end) {
        if (inventory[1].end > newSegment.end) {
          // The next segment ends after newSegment.
          // Mutate the next segment.
          //
          // Case 1:
          //   newSegment   : |======|
          //   nextSegment  :      |----|
          //   ===>         : |======|--|
          log["a" /* default */].debug("SI: Segment pushed updates the start of the next one");
          inventory[1].start = newSegment.end;
          inventory[1].bufferedStart = undefined;
          inventory[1].precizeStart = newSegment.precizeEnd;
          return;
        } // The next segment was completely contained in newSegment.
        // Remove it.
        //
        // Case 1:
        //   newSegment   : |======|
        //   nextSegment  :   |---|
        //   ===>         : |======|
        //
        // Case 2:
        //   newSegment   : |======|
        //   nextSegment  :   |----|
        //   ===>         : |======|


        log["a" /* default */].debug("SI: Segment pushed removes the next one");
        inventory.splice(1, 1);
      }

      return;
    } else {
      // our segment has a "complex" relation with the first one,
      // update the old one start and add this one before it.
      //
      // Case 1:
      //  firstSegment :    |------|
      //  newSegment   : |======|
      //  ===>         : |======|--|
      log["a" /* default */].debug("SI: Segment pushed start of the next one");
      firstSegment.start = end;
      firstSegment.bufferedStart = undefined;
      firstSegment.precizeStart = newSegment.precizeEnd;
      this.inventory.splice(0, 0, newSegment);
      return;
    }
  }
  /**
   * Indicate that inserted chunks can now be considered as a complete segment.
   * Take in argument the same content than what was given to `insertChunk` for
   * the corresponding chunks.
   * @param {Object} content
   */
  ;

  _proto.completeSegment = function completeSegment(content) {
    if (content.segment.isInit) {
      return;
    }

    var inventory = this.inventory;
    var foundIt = false;

    for (var i = 0; i < inventory.length; i++) {
      if (Object(are_same_content["a" /* default */])(inventory[i].infos, content)) {
        if (foundIt) {
          log["a" /* default */].warn("SI: Completed Segment is splitted.", content);
        }

        foundIt = true;
        var firstI = i;
        i += 1;

        while (i < inventory.length && Object(are_same_content["a" /* default */])(inventory[i].infos, content)) {
          i++;
        }

        var lastI = i - 1;
        var length = lastI - firstI;
        var lastEnd = inventory[lastI].end;
        var lastBufferedEnd = inventory[lastI].bufferedEnd;

        if (length > 0) {
          this.inventory.splice(firstI + 1, length);
          i -= length;
        }

        this.inventory[firstI].partiallyPushed = false;
        this.inventory[firstI].end = lastEnd;
        this.inventory[firstI].bufferedEnd = lastBufferedEnd;
      }
    }

    if (!foundIt) {
      log["a" /* default */].warn("SI: Completed Segment not found", content);
    }
  }
  /**
   * @returns {Array.<Object>}
   */
  ;

  _proto.getInventory = function getInventory() {
    return this.inventory;
  };

  return SegmentInventory;
}();
/**
 * Returns `true` if the buffered start of the given chunk looks coherent enough
 * relatively to what is anounced in the Manifest.
 * @param {Object} thisSegment
 * @returns {Boolean}
 */




function bufferedStartLooksCoherent(thisSegment) {
  if (thisSegment.bufferedStart === undefined || thisSegment.partiallyPushed) {
    return false;
  }

  var start = thisSegment.start,
      end = thisSegment.end;
  var duration = end - start;
  return Math.abs(start - thisSegment.bufferedStart) <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE && (thisSegment.bufferedEnd === undefined || thisSegment.bufferedEnd > thisSegment.bufferedStart && Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart - duration) <= Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3));
}
/**
 * Returns `true` if the buffered end of the given chunk looks coherent enough
 * relatively to what is anounced in the Manifest.
 * @param {Object} thisSegment
 * @returns {Boolean}
 */


function bufferedEndLooksCoherent(thisSegment) {
  if (thisSegment.bufferedEnd === undefined || thisSegment.partiallyPushed) {
    return false;
  }

  var start = thisSegment.start,
      end = thisSegment.end;
  var duration = end - start;
  return Math.abs(end - thisSegment.bufferedEnd) <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE && thisSegment.bufferedStart != null && thisSegment.bufferedEnd > thisSegment.bufferedStart && Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart - duration) <= Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3);
}
/**
 * Evaluate the given buffered Chunk's buffered start from its range's start,
 * considering that this chunk is the first one in it.
 * @param {Object} firstSegmentInRange
 * @param {number} rangeStart
 * @param {Object} lastDeletedSegmentInfos
 */


function guessBufferedStartFromRangeStart(firstSegmentInRange, rangeStart, lastDeletedSegmentInfos) {
  if (firstSegmentInRange.bufferedStart !== undefined) {
    if (firstSegmentInRange.bufferedStart < rangeStart) {
      log["a" /* default */].debug("SI: Segment partially GCed at the start", firstSegmentInRange.bufferedStart, rangeStart);
      firstSegmentInRange.bufferedStart = rangeStart;
    }

    if (!firstSegmentInRange.precizeStart && bufferedStartLooksCoherent(firstSegmentInRange)) {
      firstSegmentInRange.start = firstSegmentInRange.bufferedStart;
      firstSegmentInRange.precizeStart = true;
    }
  } else if (firstSegmentInRange.precizeStart) {
    log["a" /* default */].debug("SI: buffered start is precize start", firstSegmentInRange.start);
    firstSegmentInRange.bufferedStart = firstSegmentInRange.start;
  } else if (lastDeletedSegmentInfos.end >= 0 && lastDeletedSegmentInfos.end > rangeStart && (lastDeletedSegmentInfos.precizeEnd || firstSegmentInRange.start - lastDeletedSegmentInfos.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE)) {
    log["a" /* default */].debug("SI: buffered start is end of previous segment", rangeStart, firstSegmentInRange.start, lastDeletedSegmentInfos.end);
    firstSegmentInRange.bufferedStart = lastDeletedSegmentInfos.end;

    if (bufferedStartLooksCoherent(firstSegmentInRange)) {
      firstSegmentInRange.start = lastDeletedSegmentInfos.end;
      firstSegmentInRange.precizeStart = true;
    }
  } else if (firstSegmentInRange.start - rangeStart <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE) {
    log["a" /* default */].debug("SI: found true buffered start", rangeStart, firstSegmentInRange.start);
    firstSegmentInRange.bufferedStart = rangeStart;

    if (bufferedStartLooksCoherent(firstSegmentInRange)) {
      firstSegmentInRange.start = rangeStart;
      firstSegmentInRange.precizeStart = true;
    }
  } else if (rangeStart < firstSegmentInRange.start) {
    log["a" /* default */].debug("SI: range start too far from expected start", rangeStart, firstSegmentInRange.start);
  } else {
    log["a" /* default */].debug("SI: Segment appears immediately garbage collected at the start", firstSegmentInRange.bufferedStart, rangeStart);
    firstSegmentInRange.bufferedStart = rangeStart;
  }
}
/**
 * Evaluate the given buffered Chunk's buffered end from its range's end,
 * considering that this chunk is the last one in it.
 * @param {Object} firstSegmentInRange
 * @param {number} rangeStart
 * @param {Object} infos
 */


function guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd) {
  if (lastSegmentInRange.bufferedEnd !== undefined) {
    if (lastSegmentInRange.bufferedEnd > rangeEnd) {
      log["a" /* default */].debug("SI: Segment partially GCed at the end", lastSegmentInRange.bufferedEnd, rangeEnd);
      lastSegmentInRange.bufferedEnd = rangeEnd;
    }

    if (!lastSegmentInRange.precizeEnd && bufferedEndLooksCoherent(lastSegmentInRange)) {
      lastSegmentInRange.precizeEnd = true;
      lastSegmentInRange.end = rangeEnd;
    }
  } else if (lastSegmentInRange.precizeEnd) {
    log["a" /* default */].debug("SI: buffered end is precize end", lastSegmentInRange.end);
    lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;
  } else if (rangeEnd - lastSegmentInRange.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE) {
    log["a" /* default */].debug("SI: found true buffered end", rangeEnd, lastSegmentInRange.end);
    lastSegmentInRange.bufferedEnd = rangeEnd;

    if (bufferedEndLooksCoherent(lastSegmentInRange)) {
      lastSegmentInRange.end = rangeEnd;
      lastSegmentInRange.precizeEnd = true;
    }
  } else if (rangeEnd > lastSegmentInRange.end) {
    log["a" /* default */].debug("SI: range end too far from expected end", rangeEnd, lastSegmentInRange.end);
    lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;

    if (bufferedEndLooksCoherent(lastSegmentInRange)) {
      lastSegmentInRange.end = rangeEnd;
      lastSegmentInRange.precizeEnd = true;
    }
  } else {
    log["a" /* default */].debug("SI: Segment appears immediately garbage collected at the end", lastSegmentInRange.bufferedEnd, rangeEnd);
    lastSegmentInRange.bufferedEnd = rangeEnd;
  }
}
// CONCATENATED MODULE: ./src/core/source_buffers/queued_source_buffer.ts
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







var APPEND_WINDOW_SECURITIES = config["a" /* default */].APPEND_WINDOW_SECURITIES,
    SOURCE_BUFFER_FLUSHING_INTERVAL = config["a" /* default */].SOURCE_BUFFER_FLUSHING_INTERVAL;
var SourceBufferAction;

(function (SourceBufferAction) {
  SourceBufferAction[SourceBufferAction["Push"] = 0] = "Push";
  SourceBufferAction[SourceBufferAction["Remove"] = 1] = "Remove";
  SourceBufferAction[SourceBufferAction["EndOfSegment"] = 2] = "EndOfSegment";
})(SourceBufferAction || (SourceBufferAction = {}));
/**
 * Allows to push and remove new Segments to a SourceBuffer in a FIFO queue (not
 * doing so can lead to browser Errors) while keeping an inventory of what has
 * been pushed.
 *
 * To work correctly, only a single QueuedSourceBuffer per SourceBuffer should
 * be created.
 *
 * @class QueuedSourceBuffer
 */


var queued_source_buffer_QueuedSourceBuffer = /*#__PURE__*/function () {
  /**
   * @constructor
   * @param {string} bufferType
   * @param {string} codec
   * @param {SourceBuffer} sourceBuffer
   */
  function QueuedSourceBuffer(bufferType, codec, sourceBuffer) {
    var _this = this;

    this._destroy$ = new Subject["a" /* Subject */]();
    this.bufferType = bufferType;
    this._sourceBuffer = sourceBuffer;
    this._queue = [];
    this._pendingTask = null;
    this._lastInitSegment = null;
    this._currentCodec = codec;
    this._segmentInventory = new segment_inventory_SegmentInventory(); // Some browsers (happened with firefox 66) sometimes "forget" to send us
    // `update` or `updateend` events.
    // In that case, we're completely unable to continue the queue here and
    // stay locked in a waiting state.
    // This interval is here to check at regular intervals if the underlying
    // SourceBuffer is currently updating.

    Object(observable_interval["a" /* interval */])(SOURCE_BUFFER_FLUSHING_INTERVAL).pipe(Object(tap["a" /* tap */])(function () {
      return _this._flush();
    }), Object(takeUntil["a" /* takeUntil */])(this._destroy$)).subscribe();
    Object(fromEvent["a" /* fromEvent */])(this._sourceBuffer, "error").pipe(Object(tap["a" /* tap */])(function (err) {
      return _this._onError(err);
    }), Object(takeUntil["a" /* takeUntil */])(this._destroy$)).subscribe();
    Object(fromEvent["a" /* fromEvent */])(this._sourceBuffer, "updateend").pipe(Object(tap["a" /* tap */])(function () {
      return _this._flush();
    }), Object(takeUntil["a" /* takeUntil */])(this._destroy$)).subscribe();
  }
  /**
   * Public access to the SourceBuffer's current codec.
   * @returns {string}
   */


  var _proto = QueuedSourceBuffer.prototype;

  /**
   * Push a chunk of the media segment given to the attached SourceBuffer, in a
   * FIFO queue.
   *
   * Once all chunks of a single Segment have been given to `pushChunk`, you
   * should call `endOfSegment` to indicate that the whole Segment has been
   * pushed.
   *
   * Depending on the type of data appended, this might need an associated
   * initialization segment.
   *
   * Such initialization segment will be pushed in the SourceBuffer if the
   * last segment pushed was associated to another initialization segment.
   * This detection is entirely reference-based so make sure that the same
   * initSegment argument given share the same reference.
   *
   * You can disable the usage of initialization segment by setting the
   * `infos.data.initSegment` argument to null.
   *
   * You can also only push an initialization segment by setting the
   * `infos.data.chunk` argument to null.
   *
   * @param {Object} infos
   * @returns {Observable}
   */
  _proto.pushChunk = function pushChunk(infos) {
    log["a" /* default */].debug("QSB: receiving order to push data to the SourceBuffer", this.bufferType, infos);
    return this._addToQueue({
      type: SourceBufferAction.Push,
      value: infos
    });
  }
  /**
   * Remove buffered data (added to the same FIFO queue than `pushChunk`).
   * @param {number} start - start position, in seconds
   * @param {number} end - end position, in seconds
   * @returns {Observable}
   */
  ;

  _proto.removeBuffer = function removeBuffer(start, end) {
    log["a" /* default */].debug("QSB: receiving order to remove data from the SourceBuffer", this.bufferType, start, end);
    return this._addToQueue({
      type: SourceBufferAction.Remove,
      value: {
        start: start,
        end: end
      }
    });
  }
  /**
   * Indicate that every chunks from a Segment has been given to pushChunk so
   * far.
   * This will update our internal Segment inventory accordingly.
   * The returned Observable will emit and complete successively once the whole
   * segment has been pushed and this indication is acknowledged.
   * @param {Object} infos
   * @returns {Observable}
   */
  ;

  _proto.endOfSegment = function endOfSegment(infos) {
    log["a" /* default */].debug("QSB: receiving order for validating end of segment", this.bufferType, infos.segment);
    return this._addToQueue({
      type: SourceBufferAction.EndOfSegment,
      value: infos
    });
  }
  /**
   * The maintained inventory can fall out of sync from garbage collection or
   * other events.
   *
   * This methods allow to manually trigger a synchronization. It should be
   * called before retrieving Segment information from it (e.g. with
   * `getInventory`).
   */
  ;

  _proto.synchronizeInventory = function synchronizeInventory() {
    this._segmentInventory.synchronizeBuffered(this.getBufferedRanges());
  }
  /**
   * Returns the currently buffered data, in a TimeRanges object.
   * @returns {TimeRanges}
   */
  ;

  _proto.getBufferedRanges = function getBufferedRanges() {
    return this._sourceBuffer.buffered;
  }
  /**
   * Returns the currently buffered data for which the content is known with
   * the corresponding content information.
   * /!\ This data can fall out of sync with the real buffered ranges. Please
   * call `synchronizeInventory` before to make sure it is correctly
   * synchronized.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getInventory = function getInventory() {
    return this._segmentInventory.getInventory();
  }
  /**
   * Dispose of the resources used by this QueuedSourceBuffer.
   *
   * /!\ You won't be able to use the QueuedSourceBuffer after calling this
   * function.
   * @private
   */
  ;

  _proto.dispose = function dispose() {
    this._destroy$.next();

    this._destroy$.complete();

    if (this._pendingTask != null) {
      this._pendingTask.subject.complete();

      this._pendingTask = null;
    }

    while (this._queue.length > 0) {
      var nextElement = this._queue.shift();

      if (nextElement != null) {
        nextElement.subject.complete();
      }
    }
  }
  /**
   * Abort the linked SourceBuffer.
   * You should call this only if the linked MediaSource is still "open".
   *
   * /!\ You won't be able to use the QueuedSourceBuffer after calling this
   * function.
   * @private
   */
  ;

  _proto.abort = function abort() {
    this._sourceBuffer.abort();
  }
  /**
   * @private
   * @param {Event} error
   */
  ;

  _proto._onError = function _onError(err) {
    var error = err instanceof Error ? err : new Error("An unknown error occured when appending buffer");
    this._lastInitSegment = null; // initialize init segment as a security

    if (this._pendingTask != null) {
      this._pendingTask.subject.error(error);
    }
  }
  /**
   * When the returned observable is subscribed:
   *   1. Add your action to the queue.
   *   2. Begin the queue if not pending.
   *
   * Cancel queued action on unsubscription.
   * @private
   * @param {Object} action
   * @returns {Observable}
   */
  ;

  _proto._addToQueue = function _addToQueue(action) {
    var _this2 = this;

    return new Observable["a" /* Observable */](function (obs) {
      var shouldRestartQueue = _this2._queue.length === 0 && _this2._pendingTask == null;
      var subject = new Subject["a" /* Subject */]();
      var queueItem = Object(object_assign["a" /* default */])({
        subject: subject
      }, action);

      _this2._queue.push(queueItem);

      var subscription = subject.subscribe(obs);

      if (shouldRestartQueue) {
        _this2._flush();
      }

      return function () {
        subscription.unsubscribe();

        var index = _this2._queue.indexOf(queueItem);

        if (index >= 0) {
          _this2._queue.splice(index, 1);
        }
      };
    });
  }
  /**
   * Perform next task if one.
   * @private
   */
  ;

  _proto._flush = function _flush() {
    if (this._sourceBuffer.updating) {
      return; // still processing `this._pendingTask`
    } // handle end of previous task if needed


    if (this._pendingTask != null) {
      if (this._pendingTask.type !== SourceBufferAction.Push || this._pendingTask.steps.length === 0) {
        switch (this._pendingTask.type) {
          case SourceBufferAction.Push:
            this._segmentInventory.insertChunk(this._pendingTask.inventoryData);

            break;

          case SourceBufferAction.EndOfSegment:
            this._segmentInventory.completeSegment(this._pendingTask.value);

            break;

          case SourceBufferAction.Remove:
            this.synchronizeInventory();
            break;
        }

        var subject = this._pendingTask.subject;
        this._pendingTask = null;
        subject.next();
        subject.complete();

        if (this._queue.length > 0) {
          this._flush();
        }

        return;
      }
    } else if (this._queue.length === 0) {
      return; // we have nothing left to do
    } else {
      var newQueueItem = this._queue.shift();

      if (newQueueItem == null) {
        // TODO TypeScrypt do not get the previous length check. Find solution /
        // open issue
        throw new Error("An item from the QueuedSourceBuffer queue was not defined");
      }

      this._pendingTask = convertQueueItemToTask(newQueueItem);

      if (this._pendingTask == null) {
        // nothing to do, complete and go to next item
        newQueueItem.subject.next();
        newQueueItem.subject.complete();

        this._flush();

        return;
      }
    } // now handle current task


    var task = this._pendingTask;

    try {
      switch (task.type) {
        case SourceBufferAction.EndOfSegment:
          // nothing to do, we will just acknowledge the segment.
          log["a" /* default */].debug("QSB: Acknowledging complete segment", task.value);

          this._flush();

          return;

        case SourceBufferAction.Push:
          var nextStep = task.steps.shift();

          if (nextStep == null || nextStep.isInit && this._lastInitSegment === nextStep.segmentData) {
            this._flush();

            return;
          }

          this._pushSegmentData(nextStep);

          break;

        case SourceBufferAction.Remove:
          var _task$value = task.value,
              start = _task$value.start,
              end = _task$value.end;
          log["a" /* default */].debug("QSB: removing data from SourceBuffer", this.bufferType, start, end);

          this._sourceBuffer.remove(start, end);

          break;
      }
    } catch (e) {
      this._onError(e);
    }
  }
  /**
   * Push given data to the underlying SourceBuffer.
   * /!\ Heavily mutates the private state.
   * @param {Object} task
   */
  ;

  _proto._pushSegmentData = function _pushSegmentData(data) {
    var isInit = data.isInit,
        segmentData = data.segmentData,
        timestampOffset = data.timestampOffset,
        appendWindow = data.appendWindow,
        codec = data.codec;

    if (this._currentCodec !== codec) {
      log["a" /* default */].debug("QSB: updating codec");
      var couldUpdateType = Object(change_source_buffer_type["a" /* default */])(this._sourceBuffer, codec);

      if (couldUpdateType) {
        this._currentCodec = codec;
      } else {
        log["a" /* default */].warn("QSB: could not update codec", codec, this._currentCodec);
      }
    }

    if (this._sourceBuffer.timestampOffset !== timestampOffset) {
      var newTimestampOffset = timestampOffset;
      log["a" /* default */].debug("QSB: updating timestampOffset", this.bufferType, this._sourceBuffer.timestampOffset, newTimestampOffset);
      this._sourceBuffer.timestampOffset = newTimestampOffset;
    }

    if (appendWindow[0] == null) {
      if (this._sourceBuffer.appendWindowStart > 0) {
        this._sourceBuffer.appendWindowStart = 0;
      }
    } else if (appendWindow[0] !== this._sourceBuffer.appendWindowStart) {
      if (appendWindow[0] >= this._sourceBuffer.appendWindowEnd) {
        this._sourceBuffer.appendWindowEnd = appendWindow[0] + 1;
      }

      this._sourceBuffer.appendWindowStart = appendWindow[0];
    }

    if (appendWindow[1] == null) {
      if (this._sourceBuffer.appendWindowEnd !== Infinity) {
        this._sourceBuffer.appendWindowEnd = Infinity;
      }
    } else if (appendWindow[1] !== this._sourceBuffer.appendWindowEnd) {
      this._sourceBuffer.appendWindowEnd = appendWindow[1];
    }

    log["a" /* default */].debug("QSB: pushing new data to SourceBuffer", this.bufferType);

    if (isInit) {
      this._lastInitSegment = segmentData;
    }

    this._sourceBuffer.appendBuffer(segmentData);
  };

  _createClass(QueuedSourceBuffer, [{
    key: "codec",
    get: function get() {
      return this._currentCodec;
    }
  }]);

  return QueuedSourceBuffer;
}();
/**
 * @param {Object} item
 * @returns {Object|null}
 */




function convertQueueItemToTask(item) {
  switch (item.type) {
    case SourceBufferAction.Push:
      // Push actions with both an init segment and a regular segment need
      // to be separated into two steps
      var steps = [];
      var itemValue = item.value;
      var data = itemValue.data,
          inventoryInfos = itemValue.inventoryInfos;
      var estimatedDuration = inventoryInfos.estimatedDuration,
          estimatedStart = inventoryInfos.estimatedStart,
          segment = inventoryInfos.segment; // Cutting exactly at the start or end of the appendWindow can lead to
      // cases of infinite rebuffering due to how browser handle such windows.
      // To work-around that, we add a small offset before and after those.

      var safeAppendWindow = [data.appendWindow[0] !== undefined ? Math.max(0, data.appendWindow[0] - APPEND_WINDOW_SECURITIES.START) : undefined, data.appendWindow[1] !== undefined ? data.appendWindow[1] + APPEND_WINDOW_SECURITIES.END : undefined];

      if (data.initSegment !== null) {
        steps.push({
          isInit: true,
          segmentData: data.initSegment,
          codec: data.codec,
          timestampOffset: data.timestampOffset,
          appendWindow: safeAppendWindow
        });
      }

      if (data.chunk !== null) {
        steps.push({
          isInit: false,
          segmentData: data.chunk,
          codec: data.codec,
          timestampOffset: data.timestampOffset,
          appendWindow: safeAppendWindow
        });
      }

      if (steps.length === 0) {
        return null;
      }

      var start = estimatedStart === undefined ? segment.time / segment.timescale : estimatedStart;
      var duration = estimatedDuration === undefined ? segment.duration / segment.timescale : estimatedDuration;
      var end = start + duration;

      if (safeAppendWindow[0] !== undefined) {
        start = Math.max(start, safeAppendWindow[0]);
      }

      if (safeAppendWindow[1] !== undefined) {
        end = Math.min(end, safeAppendWindow[1]);
      }

      var inventoryData = {
        period: inventoryInfos.period,
        adaptation: inventoryInfos.adaptation,
        representation: inventoryInfos.representation,
        segment: inventoryInfos.segment,
        start: start,
        end: end
      };
      return {
        type: SourceBufferAction.Push,
        steps: steps,
        inventoryData: inventoryData,
        subject: item.subject
      };

    case SourceBufferAction.Remove:
    case SourceBufferAction.EndOfSegment:
      return item;
  }

  return null;
}
// CONCATENATED MODULE: ./src/core/source_buffers/source_buffers_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var POSSIBLE_BUFFER_TYPES = ["audio", "video", "text", "image"];
/**
 * Get all currently available buffer types.
 * /!\ This list can evolve at runtime depending on feature switching.
 * @returns {Array.<string>}
 */

function getBufferTypes() {
  var bufferTypes = ["audio", "video"];

  if (features["a" /* default */].nativeTextTracksBuffer != null || features["a" /* default */].htmlTextTracksBuffer != null) {
    bufferTypes.push("text");
  }

  if (features["a" /* default */].imageBuffer != null) {
    bufferTypes.push("image");
  }

  return bufferTypes;
}
/**
 * Allows to easily create and dispose SourceBuffers.
 *
 * Only one SourceBuffer per type is allowed at the same time:
 *
 *   - source buffers for native types (which depends on the native
 *     SourceBuffer implementation), are reused if one is re-created.
 *
 *   - source buffers for custom types are aborted each time a new one of the
 *     same type is created.
 *
 * The returned SourceBuffer is actually a QueuedSourceBuffer instance which
 * wrap a SourceBuffer implementation to queue all its actions.
 *
 * @class SourceBuffersStore
 */

var source_buffers_store_SourceBuffersStore = /*#__PURE__*/function () {
  /**
   * @param {HTMLMediaElement} mediaElement
   * @param {MediaSource} mediaSource
   * @constructor
   */
  function SourceBuffersStore(mediaElement, mediaSource) {
    this._mediaElement = mediaElement;
    this._mediaSource = mediaSource;
    this._initializedSourceBuffers = {};
  }
  /**
   * Returns true if the SourceBuffer is "native" (has to be attached to the
   * mediaSource before playback).
   * @static
   * @param {string} bufferType
   * @returns {Boolean}
   */


  SourceBuffersStore.isNative = function isNative(bufferType) {
    return shouldHaveNativeSourceBuffer(bufferType);
  }
  /**
   * Returns the created QueuedSourceBuffer for the given type.
   * Returns null if no QueuedSourceBuffer were created for the given type.
   *
   * @param {string} bufferType
   * @returns {QueuedSourceBuffer|null}
   */
  ;

  var _proto = SourceBuffersStore.prototype;

  _proto.get = function get(bufferType) {
    var initializedBuffer = this._initializedSourceBuffers[bufferType];
    return initializedBuffer != null ? initializedBuffer : null;
  }
  /**
   * Creates a new QueuedSourceBuffer for the SourceBuffer type.
   * Reuse an already created one if a QueuedSourceBuffer for the given type
   * already exists.
   * @param {string} bufferType
   * @param {string} codec
   * @param {Object|undefined} options
   * @returns {QueuedSourceBuffer}
   */
  ;

  _proto.createSourceBuffer = function createSourceBuffer(bufferType, codec, options) {
    if (options === void 0) {
      options = {};
    }

    var memorizedSourceBuffer = this._initializedSourceBuffers[bufferType];

    if (shouldHaveNativeSourceBuffer(bufferType)) {
      if (memorizedSourceBuffer != null) {
        if (memorizedSourceBuffer.codec !== codec) {
          log["a" /* default */].warn("SB: Reusing native SourceBuffer with codec", memorizedSourceBuffer.codec, "for codec", codec);
        } else {
          log["a" /* default */].info("SB: Reusing native SourceBuffer with codec", codec);
        }

        return memorizedSourceBuffer;
      }

      log["a" /* default */].info("SB: Adding native SourceBuffer with codec", codec);
      var nativeSourceBuffer = createNativeQueuedSourceBuffer(bufferType, this._mediaSource, codec);
      this._initializedSourceBuffers[bufferType] = nativeSourceBuffer;
      return nativeSourceBuffer;
    }

    if (memorizedSourceBuffer != null) {
      log["a" /* default */].info("SB: Reusing a previous custom SourceBuffer for the type", bufferType);
      return memorizedSourceBuffer;
    }

    if (bufferType === "text") {
      log["a" /* default */].info("SB: Creating a new text SourceBuffer with codec", codec);
      var sourceBuffer;

      if (options.textTrackMode === "html") {
        if (features["a" /* default */].htmlTextTracksBuffer == null) {
          throw new Error("HTML Text track feature not activated");
        }

        sourceBuffer = new features["a" /* default */].htmlTextTracksBuffer(this._mediaElement, options.textTrackElement);
      } else {
        if (features["a" /* default */].nativeTextTracksBuffer == null) {
          throw new Error("Native Text track feature not activated");
        }

        sourceBuffer = new features["a" /* default */].nativeTextTracksBuffer(this._mediaElement, options.hideNativeSubtitle === true);
      }

      var queuedSourceBuffer = new queued_source_buffer_QueuedSourceBuffer("text", codec, sourceBuffer);
      this._initializedSourceBuffers.text = queuedSourceBuffer;
      return queuedSourceBuffer;
    } else if (bufferType === "image") {
      if (features["a" /* default */].imageBuffer == null) {
        throw new Error("Image buffer feature not activated");
      }

      log["a" /* default */].info("SB: Creating a new image SourceBuffer with codec", codec);

      var _sourceBuffer = new features["a" /* default */].imageBuffer();

      var _queuedSourceBuffer = new queued_source_buffer_QueuedSourceBuffer("image", codec, _sourceBuffer);

      this._initializedSourceBuffers.image = _queuedSourceBuffer;
      return _queuedSourceBuffer;
    }

    log["a" /* default */].error("SB: Unknown buffer type:", bufferType);
    throw new media_error["a" /* default */]("BUFFER_TYPE_UNKNOWN", "The player wants to create a SourceBuffer of an unknown type.");
  }
  /**
   * Dispose of the active SourceBuffer for the given type.
   * @param {string} bufferType
   */
  ;

  _proto.disposeSourceBuffer = function disposeSourceBuffer(bufferType) {
    var memorizedSourceBuffer = this._initializedSourceBuffers[bufferType];

    if (memorizedSourceBuffer == null) {
      log["a" /* default */].warn("SB: Trying to dispose a SourceBuffer that does not exist");
      return;
    }

    log["a" /* default */].info("SB: Aborting SourceBuffer", bufferType);
    memorizedSourceBuffer.dispose();

    if (!shouldHaveNativeSourceBuffer(bufferType) || this._mediaSource.readyState === "open") {
      try {
        memorizedSourceBuffer.abort();
      } catch (e) {
        log["a" /* default */].warn("SB: Failed to abort a " + bufferType + " SourceBuffer:", e);
      }
    }

    delete this._initializedSourceBuffers[bufferType];
  }
  /**
   * Dispose of all QueuedSourceBuffer created on this SourceBuffersStore.
   */
  ;

  _proto.disposeAll = function disposeAll() {
    var _this = this;

    POSSIBLE_BUFFER_TYPES.forEach(function (bufferType) {
      if (_this.get(bufferType) != null) {
        _this.disposeSourceBuffer(bufferType);
      }
    });
  };

  return SourceBuffersStore;
}();
/**
 * Adds a SourceBuffer to the MediaSource.
 * @param {MediaSource} mediaSource
 * @param {string} codec
 * @returns {SourceBuffer}
 */




function createNativeQueuedSourceBuffer(bufferType, mediaSource, codec) {
  var sourceBuffer = mediaSource.addSourceBuffer(codec);
  return new queued_source_buffer_QueuedSourceBuffer(bufferType, codec, sourceBuffer);
}
/**
 * Returns true if the given buffeType is a native buffer, false otherwise.
 * "Native" SourceBuffers are directly added to the MediaSource.
 * @param {string} bufferType
 * @returns {Boolean}
 */


function shouldHaveNativeSourceBuffer(bufferType) {
  return bufferType === "audio" || bufferType === "video";
}
// CONCATENATED MODULE: ./src/core/buffers/events_generators.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var EVENTS = {
  activeBuffer: function activeBuffer(bufferType) {
    return {
      type: "active-buffer",
      value: {
        bufferType: bufferType
      }
    };
  },
  activePeriodChanged: function activePeriodChanged(period) {
    return {
      type: "activePeriodChanged",
      value: {
        period: period
      }
    };
  },
  adaptationChange: function adaptationChange(bufferType, adaptation, period) {
    return {
      type: "adaptationChange",
      value: {
        type: bufferType,
        adaptation: adaptation,
        period: period
      }
    };
  },
  addedSegment: function addedSegment(content, segment, buffered, segmentData) {
    return {
      type: "added-segment",
      value: {
        content: content,
        segment: segment,
        segmentData: segmentData,
        buffered: buffered
      }
    };
  },
  bitrateEstimationChange: function bitrateEstimationChange(type, bitrate) {
    return {
      type: "bitrateEstimationChange",
      value: {
        type: type,
        bitrate: bitrate
      }
    };
  },
  bufferComplete: function bufferComplete(bufferType) {
    return {
      type: "complete-buffer",
      value: {
        type: bufferType
      }
    };
  },
  discontinuityEncountered: function discontinuityEncountered(gap, bufferType) {
    return {
      type: "discontinuity-encountered",
      value: {
        bufferType: bufferType,
        gap: gap
      }
    };
  },
  endOfStream: function endOfStream() {
    return {
      type: "end-of-stream",
      value: undefined
    };
  },
  fullBuffer: function fullBuffer(bufferType) {
    return {
      type: "full-buffer",
      value: {
        bufferType: bufferType
      }
    };
  },
  needsManifestRefresh: function needsManifestRefresh() {
    return {
      type: "needs-manifest-refresh",
      value: undefined
    };
  },
  manifestMightBeOufOfSync: function manifestMightBeOufOfSync() {
    return {
      type: "manifest-might-be-out-of-sync",
      value: undefined
    };
  },
  needsMediaSourceReload: function needsMediaSourceReload(_ref) {
    var currentTime = _ref.currentTime,
        isPaused = _ref.isPaused;
    return {
      type: "needs-media-source-reload",
      value: {
        currentTime: currentTime,
        isPaused: isPaused
      }
    };
  },
  needsDecipherabilityFlush: function needsDecipherabilityFlush(_ref2) {
    var currentTime = _ref2.currentTime,
        isPaused = _ref2.isPaused,
        duration = _ref2.duration;
    return {
      type: "needs-decipherability-flush",
      value: {
        currentTime: currentTime,
        isPaused: isPaused,
        duration: duration
      }
    };
  },
  periodBufferReady: function periodBufferReady(type, period, adaptation$) {
    return {
      type: "periodBufferReady",
      value: {
        type: type,
        period: period,
        adaptation$: adaptation$
      }
    };
  },
  periodBufferCleared: function periodBufferCleared(type, period) {
    return {
      type: "periodBufferCleared",
      value: {
        type: type,
        period: period
      }
    };
  },
  protectedSegment: function protectedSegment(initDataInfo) {
    return {
      type: "protected-segment",
      value: initDataInfo
    };
  },
  representationChange: function representationChange(type, period, representation) {
    return {
      type: "representationChange",
      value: {
        type: type,
        period: period,
        representation: representation
      }
    };
  },
  resumeStream: function resumeStream() {
    return {
      type: "resume-stream",
      value: undefined
    };
  },
  warning: function warning(value) {
    return {
      type: "warning",
      value: value
    };
  }
};
/* harmony default export */ var buffers_events_generators = (EVENTS);
// CONCATENATED MODULE: ./src/core/source_buffers/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/* harmony default export */ var source_buffers = (source_buffers_store_SourceBuffersStore);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/throwError.js
var throwError = __webpack_require__(65);

// CONCATENATED MODULE: ./src/utils/concat_map_latest.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Same as concatMap, but get last emitted value from source instead of unstack
 * inner values.
 * @param {function} callback
 * @returns {function}
 */

function concatMapLatest(callback) {
  return function (source) {
    return Object(defer["a" /* defer */])(function () {
      var counter = 0;
      var valuePending;
      var hasValuePending = false;
      var isExhausting = false;

      function next(value) {
        return Object(defer["a" /* defer */])(function () {
          if (isExhausting) {
            valuePending = value;
            hasValuePending = true;
            return empty["a" /* EMPTY */];
          }

          hasValuePending = false;
          isExhausting = true;
          return callback(value, counter++).pipe(Object(tap["a" /* tap */])({
            complete: function complete() {
              return isExhausting = false;
            }
          }), function (s) {
            return Object(concat["a" /* concat */])(s, Object(defer["a" /* defer */])(function () {
              return hasValuePending ? next(valuePending) : empty["a" /* EMPTY */];
            }));
          });
        });
      }

      return source.pipe(Object(mergeMap["a" /* mergeMap */])(next));
    });
  };
}
// EXTERNAL MODULE: ./node_modules/next-tick/index.js
var next_tick = __webpack_require__(73);
var next_tick_default = /*#__PURE__*/__webpack_require__.n(next_tick);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeWhile.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function takeWhile(predicate, inclusive) {
    if (inclusive === void 0) {
        inclusive = false;
    }
    return function (source) {
        return source.lift(new TakeWhileOperator(predicate, inclusive));
    };
}
var TakeWhileOperator = /*@__PURE__*/ (function () {
    function TakeWhileOperator(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new takeWhile_TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator;
}());
var takeWhile_TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            if (this.inclusive) {
                destination.next(value);
            }
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber["a" /* Subscriber */]));
//# sourceMappingURL=takeWhile.js.map

// EXTERNAL MODULE: ./src/utils/simple_set.ts
var simple_set = __webpack_require__(107);

// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(21);

// CONCATENATED MODULE: ./src/compat/should_append_buffer_after_padding.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * When the player decides to load another quality and replace
 * currently buffered one, it may append buffer on current playback time.
 *
 * On Safari, with HSS contents, this provoques green macro-block screens
 * during the transition. To avoid this situation, we decide not to load a
 * segment if it may be pushed during playback time. We should not buffer
 * under a certain padding from the current time.
 */

var shouldAppendBufferAfterPadding = browser_detection["d" /* isSafari */];
/* harmony default export */ var should_append_buffer_after_padding = (shouldAppendBufferAfterPadding);
// CONCATENATED MODULE: ./src/core/buffers/representation/get_needed_segments.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file allows to create RepresentationBuffers.
 *
 * A RepresentationBuffer downloads and push segment for a single
 * Representation (e.g. a single video stream of a given quality).
 * It chooses which segments should be downloaded according to the current
 * position and what is currently buffered.
 */
// import objectAssign from "object-assign";



var CONTENT_REPLACEMENT_PADDING = config["a" /* default */].CONTENT_REPLACEMENT_PADDING,
    BITRATE_REBUFFERING_RATIO = config["a" /* default */].BITRATE_REBUFFERING_RATIO,
    MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT = config["a" /* default */].MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT,
    get_needed_segments_MINIMUM_SEGMENT_SIZE = config["a" /* default */].MINIMUM_SEGMENT_SIZE;
/**
 * @param {Object} segmentFilterArgument
 * @returns {Array.<Object>}
 */

function getNeededSegments(_ref) {
  var content = _ref.content,
      currentPlaybackTime = _ref.currentPlaybackTime,
      knownStableBitrate = _ref.knownStableBitrate,
      loadedSegmentPendingPush = _ref.loadedSegmentPendingPush,
      neededRange = _ref.neededRange,
      segmentInventory = _ref.segmentInventory;
  // 1 - construct lists of segments possible and actually pushed
  var possibleSegments = content.representation.index.getSegments(neededRange.start, neededRange.end - neededRange.start);
  var currentSegments = getCorrespondingBufferedSegments({
    start: Math.max(neededRange.start - 0.5, 0),
    end: neededRange.end + 0.5
  }, segmentInventory); // 2 - remove from pushed list of current segments the contents we want to replace

  var consideredSegments = currentSegments.filter(function (bufferedSegment) {
    return !shouldContentBeReplaced(bufferedSegment.infos, content, currentPlaybackTime, knownStableBitrate);
  }); // 3 - remove from that list the segments who appeared to have been GCed

  var completeSegments = filterGarbageCollectedSegments(consideredSegments, neededRange); // 4 - now filter the list of segments we can download

  var roundingError = Math.min(1 / 60, get_needed_segments_MINIMUM_SEGMENT_SIZE);
  return possibleSegments.filter(function (segment) {
    if (loadedSegmentPendingPush.test(segment.id)) {
      return false; // we're already pushing it
    }

    var duration = segment.duration,
        time = segment.time,
        timescale = segment.timescale;

    if (segment.isInit || duration === undefined) {
      return true; // never skip those
    }

    if (duration / timescale < get_needed_segments_MINIMUM_SEGMENT_SIZE) {
      return false; // too small
    }

    var scaledTime = time / timescale;
    var scaledDuration = duration / timescale;
    var scaledEnd = scaledTime + scaledDuration; // check if the segment is already downloaded

    for (var i = 0; i < completeSegments.length; i++) {
      var completeSeg = completeSegments[i];
      var areFromSamePeriod = completeSeg.infos.period.id === content.period.id; // Check if content are from same period, as there can't be overlapping
      // periods, we should consider a segment as already downloaded if
      // it is from same period (but can be from different adaptation or
      // representation)

      if (areFromSamePeriod) {
        var segTime = completeSeg.infos.segment.time;
        var segDuration = completeSeg.infos.segment.duration;
        var segTimeScale = completeSeg.infos.segment.timescale;
        var scaledSegTime = segTime / segTimeScale;
        var scaledSegEnd = scaledSegTime + segDuration / segTimeScale;

        if (scaledTime - scaledSegTime > -roundingError && scaledSegEnd - scaledEnd > -roundingError) {
          return false; // already downloaded
        }
      }
    } // check if there is an hole in place of the segment currently


    for (var _i = 0; _i < completeSegments.length; _i++) {
      var _completeSeg = completeSegments[_i];

      if (_completeSeg.end > scaledTime) {
        if (_completeSeg.start > scaledTime + roundingError) {
          return true;
        }

        var j = _i + 1; // go through all contiguous segments and take the last one

        while (j < completeSegments.length - 1 && completeSegments[j - 1].end + roundingError > completeSegments[j].start) {
          j++;
        }

        j--; // index of last contiguous segment

        return completeSegments[j].end < scaledEnd + roundingError;
      }
    }

    return true;
  });
}
/**
 * Returns `true` if segments linked to the given `oldContent` currently present
 * in the buffer should be replaced by segments coming from `currentContent`.
 * @param {Object} oldContent
 * @param {Object} currentContent
 * @param {number} currentPlaybackTime
 * @param {number} [knownStableBitrate]
 * @returns {boolean}
 */

function shouldContentBeReplaced(oldContent, currentContent, currentPlaybackTime, knownStableBitrate) {
  if (oldContent.period.id !== currentContent.period.id) {
    return false; // keep segments from another Period by default.
  }

  var segment = oldContent.segment;

  if (should_append_buffer_after_padding && segment.time / segment.timescale < currentPlaybackTime + CONTENT_REPLACEMENT_PADDING) {
    return false;
  }

  if (oldContent.adaptation.id !== currentContent.adaptation.id) {
    return true; // replace segments from another Adaptation
  }

  var oldContentBitrate = oldContent.representation.bitrate;

  if (knownStableBitrate === undefined) {
    // only re-load comparatively-poor bitrates for the same Adaptation.
    var bitrateCeil = oldContentBitrate * BITRATE_REBUFFERING_RATIO;
    return currentContent.representation.bitrate > bitrateCeil;
  }

  return oldContentBitrate < knownStableBitrate && currentContent.representation.bitrate > oldContentBitrate;
}
/**
 * Returns an Array which removed the segments from `consideredSegments` which
 * appeared to have been garbage collected.
 * @param {Array.<Object>} consideredSegments
 * @param {Object} neededRange
 * @returns {Array.<Object>}
 */


function filterGarbageCollectedSegments(consideredSegments, neededRange) {
  var completeSegments = [];

  for (var i = 0; i < consideredSegments.length; i++) {
    var segmentStartIsComplete = true;
    var segmentEndIsComplete = true;
    var currentSeg = consideredSegments[i];
    var prevSeg = i === 0 ? null : consideredSegments[i - 1];
    var nextSeg = i >= consideredSegments.length - 1 ? null : consideredSegments[i + 1];

    if (currentSeg.bufferedStart === undefined) {
      segmentStartIsComplete = false;
    } else if ((prevSeg === null || prevSeg.bufferedEnd === undefined || prevSeg.bufferedEnd !== currentSeg.bufferedStart) && neededRange.start < currentSeg.bufferedStart && currentSeg.bufferedStart - currentSeg.start > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
      log["a" /* default */].info("Buffer: The start of the wanted segment has been garbage collected", currentSeg);
      segmentStartIsComplete = false;
    }

    if (currentSeg.bufferedEnd === undefined) {
      segmentEndIsComplete = false;
    } else if ((nextSeg === null || nextSeg.bufferedEnd === undefined || nextSeg.bufferedEnd !== currentSeg.bufferedStart) && neededRange.end > currentSeg.bufferedEnd && currentSeg.end - currentSeg.bufferedEnd > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
      log["a" /* default */].info("Buffer: The end of the wanted segment has been garbage collected", currentSeg);
      segmentEndIsComplete = false;
    }

    if (segmentStartIsComplete && segmentEndIsComplete) {
      completeSegments.push(currentSeg);
    }
  }

  return completeSegments;
}
/**
 * From the given SegmentInventory, filters the buffered Segment Object which
 * overlap with the given range.
 * @param {Object} neededRange
 * @param {Array.<Object>} segmentInventory
 * @returns {Array.<Object>}
 */


function getCorrespondingBufferedSegments(neededRange, segmentInventory) {
  var segmentRoundingError = Math.max(1 / 60, get_needed_segments_MINIMUM_SEGMENT_SIZE);
  var minEnd = neededRange.start + segmentRoundingError;
  var maxStart = neededRange.end - segmentRoundingError;
  var overlappingChunks = [];

  for (var i = segmentInventory.length - 1; i >= 0; i--) {
    var eltInventory = segmentInventory[i];

    if (!eltInventory.partiallyPushed && eltInventory.infos.representation.decipherable !== false) {
      var inventorySegment = eltInventory.infos.segment;
      var eltInventoryStart = inventorySegment.time / inventorySegment.timescale;
      var eltInventoryEnd = inventorySegment.duration == null ? eltInventory.end : eltInventoryStart + inventorySegment.duration / inventorySegment.timescale;

      if (eltInventoryEnd > minEnd && eltInventoryStart < maxStart || eltInventory.end > minEnd && eltInventory.start < maxStart) {
        overlappingChunks.unshift(eltInventory);
      }
    }
  }

  return overlappingChunks;
}
// CONCATENATED MODULE: ./src/core/buffers/representation/get_segment_priority.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SEGMENT_PRIORITIES_STEPS = config["a" /* default */].SEGMENT_PRIORITIES_STEPS;
/**
 * Calculate the priority number of the Segment, in function of the distance
 * with the current time.
 *
 * The lower is this number, the higher should be the priority of the request.
 *
 * @param {Object} segment
 * @param {Object} clockTick
 * @returns {number}
 */

function getSegmentPriority(segment, clockTick) {
  var currentTime = clockTick.currentTime + clockTick.wantedTimeOffset;
  var segmentStart = segment.time / segment.timescale;
  var distance = segmentStart - currentTime;

  for (var priority = 0; priority < SEGMENT_PRIORITIES_STEPS.length; priority++) {
    if (distance < SEGMENT_PRIORITIES_STEPS[priority]) {
      return priority;
    }
  }

  return SEGMENT_PRIORITIES_STEPS.length;
}
// CONCATENATED MODULE: ./src/core/buffers/representation/get_wanted_range.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the range of segments needed for a particular point in time.
 *
 * @param {Object} hardLimits
 * @param {TimeRanges} buffered
 * @param {Object} tick
 * @param {number} bufferGoal
 * @param {Object} paddings
 * @returns {Object}
 */
function getWantedRange(hardLimits, tick, bufferGoal) {
  var currentTime = tick.currentTime + tick.wantedTimeOffset;
  var startHardLimit = hardLimits.start == null ? 0 : hardLimits.start;
  var endHardLimit = hardLimits.end == null ? Infinity : hardLimits.end;
  var boundedLimits = {
    start: Math.max(startHardLimit, currentTime),
    end: endHardLimit
  };
  return {
    start: Math.min(boundedLimits.end, Math.max(currentTime, boundedLimits.start)),
    end: Math.min(boundedLimits.end, Math.max(currentTime + bufferGoal, boundedLimits.start))
  };
}
// CONCATENATED MODULE: ./src/core/buffers/representation/force_garbage_collection.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var GC_GAP_CALM = config["a" /* default */].BUFFER_GC_GAPS.CALM;
var GC_GAP_BEEFY = config["a" /* default */].BUFFER_GC_GAPS.BEEFY;
/**
 * Run the garbage collector.
 *
 * Try to clean up buffered ranges from a low gcGap at first.
 * If it does not succeed to clean up space, use a higher gcCap.
 *
 * @param {Observable} timings$
 * @param {Object} bufferingQueue
 * @returns {Observable}
 */

function forceGarbageCollection(timings$, bufferingQueue) {
  // wait for next timing event
  return timings$.pipe(Object(take["a" /* take */])(1), Object(mergeMap["a" /* mergeMap */])(function (timing) {
    log["a" /* default */].warn("Buffer: Running garbage collector");
    var buffered = bufferingQueue.getBufferedRanges();
    var cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_CALM); // more aggressive GC if we could not find any range to clean

    if (cleanedupRanges.length === 0) {
      cleanedupRanges = selectGCedRanges(timing.currentTime, buffered, GC_GAP_BEEFY);
    }

    log["a" /* default */].debug("Buffer: GC cleaning", cleanedupRanges);
    return Object(from["a" /* from */])(cleanedupRanges.map(function (_ref) {
      var start = _ref.start,
          end = _ref.end;
      return bufferingQueue.removeBuffer(start, end);
    })).pipe(Object(concatAll["a" /* concatAll */])());
  }));
}
/**
 * Buffer garbage collector algorithm.
 *
 * Tries to free up some part of the ranges that are distant from the current
 * playing time.
 * See: https://w3c.github.io/media-source/#sourcebuffer-prepare-append
 *
 * @param {Number} currentTime
 * @param {TimeRanges} buffered - current buffered ranges
 * @param {Number} gcGap - delta gap from current timestamp from which we
 * should consider cleaning up.
 * @returns {Array.<Object>} - Ranges selected for clean up
 */

function selectGCedRanges(currentTime, buffered, gcGap) {
  var _getInnerAndOuterTime = Object(ranges["c" /* getInnerAndOuterTimeRanges */])(buffered, currentTime),
      innerRange = _getInnerAndOuterTime.innerRange,
      outerRanges = _getInnerAndOuterTime.outerRanges;

  var cleanedupRanges = []; // start by trying to remove all ranges that do not contain the
  // current time and respect the gcGap
  // respect the gcGap? FIXME?

  for (var i = 0; i < outerRanges.length; i++) {
    var outerRange = outerRanges[i];

    if (currentTime - gcGap < outerRange.end) {
      cleanedupRanges.push(outerRange);
    } else if (currentTime + gcGap > outerRange.start) {
      cleanedupRanges.push(outerRange);
    }
  } // try to clean up some space in the current range


  if (innerRange != null) {
    log["a" /* default */].debug("Buffer: GC removing part of inner range", cleanedupRanges);

    if (currentTime - gcGap > innerRange.start) {
      cleanedupRanges.push({
        start: innerRange.start,
        end: currentTime - gcGap
      });
    }

    if (currentTime + gcGap < innerRange.end) {
      cleanedupRanges.push({
        start: currentTime + gcGap,
        end: innerRange.end
      });
    }
  }

  return cleanedupRanges;
}
// CONCATENATED MODULE: ./src/core/buffers/representation/append_segment_to_source_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file allows any Buffer to push data to a QueuedSourceBuffer.
 */




/**
 * Append buffer to the queuedSourceBuffer.
 * If it leads to a QuotaExceededError, try to run our custom range
 * _garbage collector_.
 *
 * @param {Observable} clock$
 * @param {Object} queuedSourceBuffer
 * @param {Object} dataInfos
 * @returns {Observable}
 */

function appendSegmentToSourceBuffer(clock$, queuedSourceBuffer, dataInfos) {
  var append$ = queuedSourceBuffer.pushChunk(dataInfos);
  return append$.pipe(Object(catchError["a" /* catchError */])(function (appendError) {
    if (!(appendError instanceof Error) || appendError.name !== "QuotaExceededError") {
      var reason = appendError instanceof Error ? appendError.toString() : "An unknown error happened when pushing content";
      throw new media_error["a" /* default */]("BUFFER_APPEND_ERROR", reason);
    }

    return Object(concat["a" /* concat */])(forceGarbageCollection(clock$, queuedSourceBuffer).pipe(Object(ignoreElements["a" /* ignoreElements */])()), append$).pipe(Object(catchError["a" /* catchError */])(function (forcedGCError) {
      var reason = forcedGCError instanceof Error ? forcedGCError.toString() : "Could not clean the buffer"; // (weird Typing either due to TypeScript or RxJS bug)

      throw new media_error["a" /* default */]("BUFFER_FULL_ERROR", reason);
    }));
  }));
}
// CONCATENATED MODULE: ./src/core/buffers/representation/push_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Push the initialization segment to the QueuedSourceBuffer.
 * The Observable returned:
 *   - emit an event once the segment has been pushed.
 *   - throws on Error.
 * @param {Object} args
 * @returns {Observable}
 */

function pushInitSegment(_ref) {
  var clock$ = _ref.clock$,
      content = _ref.content,
      segment = _ref.segment,
      segmentData = _ref.segmentData,
      queuedSourceBuffer = _ref.queuedSourceBuffer;
  return Object(defer["a" /* defer */])(function () {
    if (segmentData === null) {
      return empty["a" /* EMPTY */];
    }

    var codec = content.representation.getMimeTypeString();
    var data = {
      initSegment: segmentData,
      chunk: null,
      timestampOffset: 0,
      appendWindow: [undefined, undefined],
      codec: codec
    };
    var inventoryInfos = Object(object_assign["a" /* default */])({
      segment: segment
    }, content);
    return appendSegmentToSourceBuffer(clock$, queuedSourceBuffer, {
      data: data,
      inventoryInfos: inventoryInfos
    }).pipe(Object(map["a" /* map */])(function () {
      var buffered = queuedSourceBuffer.getBufferedRanges();
      return buffers_events_generators.addedSegment(content, segment, buffered, segmentData);
    }));
  });
}
// CONCATENATED MODULE: ./src/core/buffers/representation/push_media_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Push a given media segment (non-init segment) to a QueuedSourceBuffer.
 * The Observable returned:
 *   - emit an event once the segment has been pushed.
 *   - throws on Error.
 * @param {Object} args
 * @returns {Observable}
 */

function pushMediaSegment(_ref) {
  var clock$ = _ref.clock$,
      content = _ref.content,
      initSegmentData = _ref.initSegmentData,
      parsedSegment = _ref.parsedSegment,
      segment = _ref.segment,
      queuedSourceBuffer = _ref.queuedSourceBuffer;
  return Object(defer["a" /* defer */])(function () {
    if (parsedSegment.chunkData === null) {
      return empty["a" /* EMPTY */];
    }

    var chunkData = parsedSegment.chunkData,
        chunkInfos = parsedSegment.chunkInfos,
        chunkOffset = parsedSegment.chunkOffset,
        appendWindow = parsedSegment.appendWindow;
    var codec = content.representation.getMimeTypeString();
    var data = {
      initSegment: initSegmentData,
      chunk: chunkData,
      timestampOffset: chunkOffset,
      appendWindow: appendWindow,
      codec: codec
    };
    var estimatedStart;
    var estimatedDuration;

    if (chunkInfos !== null) {
      estimatedStart = chunkInfos.time / chunkInfos.timescale;
      estimatedDuration = chunkInfos.duration !== undefined ? chunkInfos.duration / chunkInfos.timescale : undefined;
    }

    var inventoryInfos = Object(object_assign["a" /* default */])({
      segment: segment,
      estimatedStart: estimatedStart,
      estimatedDuration: estimatedDuration
    }, content);
    return appendSegmentToSourceBuffer(clock$, queuedSourceBuffer, {
      data: data,
      inventoryInfos: inventoryInfos
    }).pipe(Object(map["a" /* map */])(function () {
      var buffered = queuedSourceBuffer.getBufferedRanges();
      return buffers_events_generators.addedSegment(content, segment, buffered, chunkData);
    }));
  });
}
// CONCATENATED MODULE: ./src/core/buffers/representation/representation_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file allows to create RepresentationBuffers.
 *
 * A RepresentationBuffer downloads and push segment for a single
 * Representation (e.g. a single video stream of a given quality).
 * It chooses which segments should be downloaded according to the current
 * position and what is currently buffered.
 */












/**
 * Build up buffer for a single Representation.
 *
 * Download and push segments linked to the given Representation according
 * to what is already in the SourceBuffer and where the playback currently is.
 *
 * Multiple RepresentationBuffer observables can run on the same SourceBuffer.
 * This allows for example smooth transitions between multiple periods.
 *
 * @param {Object} args
 * @returns {Observable}
 */

function RepresentationBuffer(_ref) {
  var bufferGoal$ = _ref.bufferGoal$,
      clock$ = _ref.clock$,
      content = _ref.content,
      knownStableBitrate$ = _ref.knownStableBitrate$,
      queuedSourceBuffer = _ref.queuedSourceBuffer,
      segmentFetcher = _ref.segmentFetcher,
      terminate$ = _ref.terminate$;
  var manifest = content.manifest,
      period = content.period,
      adaptation = content.adaptation,
      representation = content.representation;
  var bufferType = adaptation.type;
  var initSegment = representation.index.getInitSegment(); // Saved initSegment state for this representation.

  var initSegmentObject = initSegment == null ? {
    initializationData: null,
    segmentProtections: [],
    initTimescale: undefined
  } : null; // Segments queued for download in the BufferQueue.

  var downloadQueue = []; // Subject to start/restart a downloading Queue.

  var startDownloadingQueue$ = new ReplaySubject["a" /* ReplaySubject */](1); // Emit when the RepresentationBuffer asks to re-check which segments are needed.

  var reCheckNeededSegments$ = new Subject["a" /* Subject */](); // Keep track of the information about the pending Segment request.
  // null if no request is pending.

  var currentSegmentRequest = null; // Keep track of downloaded segments currently awaiting to be appended to the
  // QueuedSourceBuffer.

  var loadedSegmentPendingPush = new simple_set["a" /* default */]();
  var status$ = Object(combineLatest["a" /* combineLatest */])([clock$, bufferGoal$, terminate$.pipe(Object(take["a" /* take */])(1), Object(mapTo["a" /* mapTo */])(true), Object(startWith["a" /* startWith */])(false)), reCheckNeededSegments$.pipe(Object(startWith["a" /* startWith */])(undefined))]).pipe(withLatestFrom(knownStableBitrate$), Object(map["a" /* map */])(function getCurrentStatus(_ref2) {
    var _ref2$ = _ref2[0],
        timing = _ref2$[0],
        bufferGoal = _ref2$[1],
        terminate = _ref2$[2],
        knownStableBitrate = _ref2[1];
    queuedSourceBuffer.synchronizeInventory();
    var neededRange = getWantedRange(period, timing, bufferGoal);
    var discontinuity = timing.stalled != null ? representation.index.checkDiscontinuity(timing.currentTime) : -1;
    var shouldRefreshManifest = representation.index.shouldRefresh(neededRange.start, neededRange.end);
    var segmentInventory = queuedSourceBuffer.getInventory();
    var neededSegments = getNeededSegments({
      content: content,
      currentPlaybackTime: timing.currentTime,
      knownStableBitrate: knownStableBitrate,
      loadedSegmentPendingPush: loadedSegmentPendingPush,
      neededRange: neededRange,
      segmentInventory: segmentInventory
    }).map(function (segment) {
      return {
        priority: getSegmentPriority(segment, timing),
        segment: segment
      };
    });

    if (initSegment !== null && initSegmentObject === null) {
      // prepend initialization segment
      var initSegmentPriority = getSegmentPriority(initSegment, timing);
      neededSegments = [{
        segment: initSegment,
        priority: initSegmentPriority
      }].concat(neededSegments);
    }

    var isFull; // True if the current buffer is full and the one
    // from the next Period can be created

    if (neededSegments.length > 0 || period.end == null) {
      // Either we still have segments to download or the current Period is
      // not yet ended: not full
      isFull = false;
    } else {
      var lastPosition = representation.index.getLastPosition();

      if (lastPosition === undefined) {
        // We do not know the end of this index.
        // If we reached the end of the period, check that all segments are
        // available.
        isFull = neededRange.end >= period.end && representation.index.isFinished();
      } else if (lastPosition === null) {
        // There is no available segment in the index currently. If the index
        // tells us it has finished generating new segments, we're done.
        isFull = representation.index.isFinished();
      } else {
        // We have a declared end. Check that our range went until the last
        // position available in the index. If that's the case and we're left
        // with no segments after filtering them, it means we already have
        // downloaded the last segments and have nothing left to do: full.
        var endOfRange = period.end != null ? Math.min(period.end, lastPosition) : lastPosition;
        isFull = neededRange.end >= endOfRange && representation.index.isFinished();
      }
    }

    return {
      discontinuity: discontinuity,
      isFull: isFull,
      terminate: terminate,
      neededSegments: neededSegments,
      shouldRefreshManifest: shouldRefreshManifest
    };
  }), Object(mergeMap["a" /* mergeMap */])(function handleStatus(status) {
    var neededSegments = status.neededSegments;
    var mostNeededSegment = neededSegments[0];

    if (status.terminate) {
      downloadQueue = [];

      if (currentSegmentRequest == null) {
        log["a" /* default */].debug("Buffer: no request, terminate.", bufferType);
        startDownloadingQueue$.complete(); // complete the downloading queue

        return Object(of["a" /* of */])({
          type: "terminated"
        });
      } else if (mostNeededSegment == null || currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) {
        log["a" /* default */].debug("Buffer: cancel request and terminate.", bufferType);
        startDownloadingQueue$.next(); // interrupt the current request

        startDownloadingQueue$.complete(); // complete the downloading queue

        return Object(of["a" /* of */])({
          type: "terminated"
        });
      } else if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
        var _currentSegmentReques = currentSegmentRequest,
            request$ = _currentSegmentReques.request$;
        segmentFetcher.updatePriority(request$, mostNeededSegment.priority);
        currentSegmentRequest.priority = mostNeededSegment.priority;
      }

      log["a" /* default */].debug("Buffer: terminate after request.", bufferType);
      return empty["a" /* EMPTY */];
    }

    var neededActions = [];

    if (status.discontinuity > 1) {
      var nextTime = status.discontinuity + 1;
      var gap = [status.discontinuity, nextTime];
      neededActions.push(buffers_events_generators.discontinuityEncountered(gap, bufferType));
    }

    if (status.shouldRefreshManifest) {
      neededActions.push(buffers_events_generators.needsManifestRefresh());
    }

    if (mostNeededSegment == null) {
      if (currentSegmentRequest != null) {
        log["a" /* default */].debug("Buffer: interrupt segment request.", bufferType);
      }

      downloadQueue = [];
      startDownloadingQueue$.next(); // (re-)start with an empty queue

      return Object(concat["a" /* concat */])(of["a" /* of */].apply(void 0, neededActions), status.isFull ? Object(of["a" /* of */])(buffers_events_generators.fullBuffer(bufferType)) : empty["a" /* EMPTY */]);
    }

    if (currentSegmentRequest == null) {
      log["a" /* default */].debug("Buffer: start downloading queue.", bufferType);
      downloadQueue = neededSegments;
      startDownloadingQueue$.next(); // restart the queue
    } else if (currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) {
      log["a" /* default */].debug("Buffer: restart download queue.", bufferType);
      downloadQueue = neededSegments;
      startDownloadingQueue$.next(); // restart the queue
    } else if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
      log["a" /* default */].debug("Buffer: update request priority.", bufferType);
      var _currentSegmentReques2 = currentSegmentRequest,
          _request$ = _currentSegmentReques2.request$;
      segmentFetcher.updatePriority(_request$, mostNeededSegment.priority);
      currentSegmentRequest.priority = mostNeededSegment.priority;
    } else {
      log["a" /* default */].debug("Buffer: update downloading queue", bufferType); // Update the previous queue to be all needed segments but the first one,
      // for which a request is already pending

      downloadQueue = neededSegments.slice().splice(1, neededSegments.length);
    }

    return Object(concat["a" /* concat */])(of["a" /* of */].apply(void 0, neededActions), Object(of["a" /* of */])(buffers_events_generators.activeBuffer(bufferType)));
  }), takeWhile(function (e) {
    return e.type !== "terminated";
  })); // Buffer Queue:
  //   - download every segments queued sequentially
  //   - append them to the SourceBuffer

  var bufferQueue$ = startDownloadingQueue$.pipe(Object(switchMap["a" /* switchMap */])(function () {
    return downloadQueue.length > 0 ? loadSegmentsFromQueue() : empty["a" /* EMPTY */];
  }), Object(mergeMap["a" /* mergeMap */])(onLoaderEvent));
  return Object(merge["a" /* merge */])(status$, bufferQueue$).pipe(Object(share["a" /* share */])());
  /**
   * Request every Segment in the ``downloadQueue`` on subscription.
   * Emit the data of a segment when a request succeeded.
   *
   * Important side-effects:
   *   - Mutates `currentSegmentRequest` when doing and finishing a request.
   *   - Will emit from reCheckNeededSegments$ Subject when it's done.
   *
   * Might emit warnings when a request is retried.
   *
   * Throws when the request will not be retried (configuration or un-retryable
   * error).
   * @returns {Observable}
   */

  function loadSegmentsFromQueue() {
    var requestNextSegment$ = Object(defer["a" /* defer */])(function () {
      var currentNeededSegment = downloadQueue.shift();

      if (currentNeededSegment == null) {
        next_tick_default()(function () {
          reCheckNeededSegments$.next();
        });
        return empty["a" /* EMPTY */];
      }

      var segment = currentNeededSegment.segment,
          priority = currentNeededSegment.priority;
      var context = {
        manifest: manifest,
        period: period,
        adaptation: adaptation,
        representation: representation,
        segment: segment
      };
      var request$ = segmentFetcher.createRequest(context, priority);
      currentSegmentRequest = {
        segment: segment,
        priority: priority,
        request$: request$
      };
      var response$ = request$.pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
        if (evt.type === "warning") {
          return Object(of["a" /* of */])({
            type: "retry",
            value: {
              segment: segment,
              error: evt.value
            }
          });
        } else if (evt.type === "chunk-complete") {
          currentSegmentRequest = null;
          return Object(of["a" /* of */])({
            type: "end-of-segment",
            value: {
              segment: segment
            }
          });
        }

        var initTimescale = initSegmentObject === null || initSegmentObject === void 0 ? void 0 : initSegmentObject.initTimescale;
        return evt.parse(initTimescale).pipe(Object(map["a" /* map */])(function (parserResponse) {
          return Object(object_assign["a" /* default */])({
            segment: segment
          }, parserResponse);
        }));
      }));
      return Object(concat["a" /* concat */])(response$, requestNextSegment$);
    });
    return requestNextSegment$.pipe(finalize(function () {
      currentSegmentRequest = null;
    }));
  }
  /**
   * React to event from `loadSegmentsFromQueue`.
   * @param {Object} evt
   * @returns {Observable}
   */


  function onLoaderEvent(evt) {
    var _a;

    switch (evt.type) {
      case "retry":
        return Object(concat["a" /* concat */])(Object(of["a" /* of */])({
          type: "warning",
          value: evt.value.error
        }), Object(defer["a" /* defer */])(function () {
          var retriedSegment = evt.value.segment;
          var index = representation.index;

          if (index.isSegmentStillAvailable(retriedSegment) === false) {
            reCheckNeededSegments$.next();
          } else if (index.canBeOutOfSyncError(evt.value.error)) {
            return Object(of["a" /* of */])(buffers_events_generators.manifestMightBeOufOfSync());
          }

          return empty["a" /* EMPTY */];
        }));

      case "parsed-init-segment":
        initSegmentObject = evt.value;
        var protectedEvents$ = of["a" /* of */].apply(void 0, evt.value.segmentProtections.map(function (segmentProt) {
          return buffers_events_generators.protectedSegment(segmentProt);
        }));
        var pushEvent$ = pushInitSegment({
          clock$: clock$,
          content: content,
          segment: evt.segment,
          segmentData: evt.value.initializationData,
          queuedSourceBuffer: queuedSourceBuffer
        });
        return Object(merge["a" /* merge */])(protectedEvents$, pushEvent$);

      case "parsed-segment":
        var initSegmentData = (_a = initSegmentObject === null || initSegmentObject === void 0 ? void 0 : initSegmentObject.initializationData) !== null && _a !== void 0 ? _a : null;
        return pushMediaSegment({
          clock$: clock$,
          content: content,
          initSegmentData: initSegmentData,
          parsedSegment: evt.value,
          segment: evt.segment,
          queuedSourceBuffer: queuedSourceBuffer
        });

      case "end-of-segment":
        {
          var segment = evt.value.segment;
          loadedSegmentPendingPush.add(segment.id);
          return queuedSourceBuffer.endOfSegment(Object(object_assign["a" /* default */])({
            segment: segment
          }, content)).pipe(Object(ignoreElements["a" /* ignoreElements */])(), finalize(function () {
            loadedSegmentPendingPush.remove(segment.id);
          }));
        }
    }
  }
}
// CONCATENATED MODULE: ./src/core/buffers/representation/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var buffers_representation = (RepresentationBuffer);
// CONCATENATED MODULE: ./src/core/buffers/adaptation/adaptation_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file allows to create AdaptationBuffers.
 *
 * An AdaptationBuffer downloads and push segment for a single Adaptation (e.g.
 * a single audio or text track).
 * It chooses which Representation to download mainly thanks to the
 * ABRManager, and orchestrates the various RepresentationBuffer, which will
 * download and push segments for a single Representation.
 */







/**
 * Create new Buffer Observable linked to the given Adaptation.
 *
 * It will rely on the ABRManager to choose at any time the best Representation
 * for this Adaptation and then run the logic to download and push the
 * corresponding segments in the SourceBuffer.
 *
 * It will emit various events to report its status to the caller.
 *
 * @param {Object} args
 * @returns {Observable}
 */

function AdaptationBuffer(_ref) {
  var abrManager = _ref.abrManager,
      clock$ = _ref.clock$,
      content = _ref.content,
      options = _ref.options,
      queuedSourceBuffer = _ref.queuedSourceBuffer,
      segmentFetcherCreator = _ref.segmentFetcherCreator,
      wantedBufferAhead$ = _ref.wantedBufferAhead$;
  var directManualBitrateSwitching = options.manualBitrateSwitchingMode === "direct";
  var manifest = content.manifest,
      period = content.period,
      adaptation = content.adaptation; // The buffer goal ratio limits the wanted buffer ahead to determine the
  // buffer goal.
  //
  // It can help in cases such as : the current browser has issues with
  // buffering and tells us that we should try to bufferize less data :
  // https://developers.google.com/web/updates/2017/10/quotaexceedederror

  var bufferGoalRatioMap = {}; // emit when the current RepresentationBuffer should be stopped right now

  var killCurrentBuffer$ = new Subject["a" /* Subject */](); // emit when the current RepresentationBuffer should stop making new downloads

  var terminateCurrentBuffer$ = new Subject["a" /* Subject */](); // use ABRManager for choosing the Representation

  var bufferEvents$ = new Subject["a" /* Subject */]();
  var requestsEvents$ = new Subject["a" /* Subject */]();
  var abrEvents$ = Object(merge["a" /* merge */])(bufferEvents$, requestsEvents$);
  var decipherableRepresentations = adaptation.representations.filter(function (representation) {
    return representation.decipherable !== false;
  });

  if (decipherableRepresentations.length <= 0) {
    var noRepErr = new media_error["a" /* default */]("NO_PLAYABLE_REPRESENTATION", "No Representation in the chosen " + "Adaptation can be played");
    return Object(throwError["a" /* throwError */])(noRepErr);
  }

  var abr$ = abrManager.get$(adaptation.type, decipherableRepresentations, clock$, abrEvents$).pipe(Object(subscribeOn["a" /* subscribeOn */])(asap["a" /* asap */]), Object(share["a" /* share */])());
  var segmentFetcher = segmentFetcherCreator.createSegmentFetcher(adaptation.type, requestsEvents$); // Bitrate higher or equal to this value should not be replaced by segments of
  // better quality.
  // undefined means everything can potentially be replaced

  var knownStableBitrate$ = abr$.pipe(Object(map["a" /* map */])(function (_ref2) {
    var knownStableBitrate = _ref2.knownStableBitrate;
    return knownStableBitrate;
  }), // always emit the last on subscribe
  Object(multicast["a" /* multicast */])(function () {
    return new ReplaySubject["a" /* ReplaySubject */](1);
  }), Object(startWith["a" /* startWith */])(undefined), Object(distinctUntilChanged["a" /* distinctUntilChanged */])()); // Emit at each bitrate estimate done by the ABRManager

  var bitrateEstimates$ = abr$.pipe(Object(filter["a" /* filter */])(function (_ref3) {
    var bitrate = _ref3.bitrate;
    return bitrate != null;
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])(function (old, current) {
    return old.bitrate === current.bitrate;
  }), Object(map["a" /* map */])(function (_ref4) {
    var bitrate = _ref4.bitrate;
    log["a" /* default */].debug("Buffer: new " + adaptation.type + " bitrate estimation", bitrate);
    return buffers_events_generators.bitrateEstimationChange(adaptation.type, bitrate);
  }));
  var newRepresentation$ = abr$.pipe(Object(distinctUntilChanged["a" /* distinctUntilChanged */])(function (a, b) {
    return a.manual === b.manual && a.representation.id === b.representation.id;
  }));
  var adaptationBuffer$ = Object(merge["a" /* merge */])(newRepresentation$.pipe(concatMapLatest(function (estimate, i) {
    var representation = estimate.representation; // A manual bitrate switch might need an immediate feedback.
    // To do that properly, we need to reload the MediaSource

    if (directManualBitrateSwitching && estimate.manual && i !== 0) {
      return clock$.pipe(Object(take["a" /* take */])(1), Object(map["a" /* map */])(function (t) {
        return buffers_events_generators.needsMediaSourceReload(t);
      }));
    }

    var representationChange$ = Object(of["a" /* of */])(buffers_events_generators.representationChange(adaptation.type, period, representation));
    var representationBuffer$ = createRepresentationBuffer(representation).pipe(Object(takeUntil["a" /* takeUntil */])(killCurrentBuffer$));
    return Object(concat["a" /* concat */])(representationChange$, representationBuffer$).pipe(Object(tap["a" /* tap */])(function (evt) {
      if (evt.type === "representationChange" || evt.type === "added-segment") {
        return bufferEvents$.next(evt);
      }
    }));
  })), // NOTE: This operator was put in a merge on purpose. It's a "clever"
  // hack to allow it to be called just *AFTER* the concatMapLatest one.
  newRepresentation$.pipe(Object(map["a" /* map */])(function (estimation, i) {
    if (i === 0) {
      // Initial run == no Buffer pending. We have nothing to do:
      return; // The one just created will be launched right away.
    }

    if (estimation.urgent) {
      log["a" /* default */].info("Buffer: urgent Representation switch", adaptation.type); // Kill current Buffer immediately. The one just chosen take its place.

      killCurrentBuffer$.next();
    } else {
      log["a" /* default */].info("Buffer: slow Representation switch", adaptation.type); // terminate current Buffer. The last chosen Representation at the time
      // it will be finished will take its place.

      terminateCurrentBuffer$.next();
    }
  }), Object(ignoreElements["a" /* ignoreElements */])()));
  return Object(merge["a" /* merge */])(adaptationBuffer$, bitrateEstimates$);
  /**
   * Create and returns a new RepresentationBuffer Observable, linked to the
   * given Representation.
   * @param {Representation} representation
   * @returns {Observable}
   */

  function createRepresentationBuffer(representation) {
    return Object(defer["a" /* defer */])(function () {
      var oldBufferGoalRatio = bufferGoalRatioMap[representation.id];
      var bufferGoalRatio = oldBufferGoalRatio != null ? oldBufferGoalRatio : 1;
      bufferGoalRatioMap[representation.id] = bufferGoalRatio;
      var bufferGoal$ = wantedBufferAhead$.pipe(Object(map["a" /* map */])(function (wba) {
        return wba * bufferGoalRatio;
      }));
      log["a" /* default */].info("Buffer: changing representation", adaptation.type, representation);
      return buffers_representation({
        clock$: clock$,
        content: {
          representation: representation,
          adaptation: adaptation,
          period: period,
          manifest: manifest
        },
        queuedSourceBuffer: queuedSourceBuffer,
        segmentFetcher: segmentFetcher,
        terminate$: terminateCurrentBuffer$,
        bufferGoal$: bufferGoal$,
        knownStableBitrate$: knownStableBitrate$
      }).pipe(Object(catchError["a" /* catchError */])(function (err) {
        var formattedError = formatError(err, {
          defaultCode: "NONE",
          defaultReason: "Unknown `RepresentationBuffer` error"
        });

        if (formattedError.code === "BUFFER_FULL_ERROR") {
          var wantedBufferAhead = wantedBufferAhead$.getValue();
          var lastBufferGoalRatio = bufferGoalRatio;

          if (lastBufferGoalRatio <= 0.25 || wantedBufferAhead * lastBufferGoalRatio <= 2) {
            throw formattedError;
          }

          bufferGoalRatioMap[representation.id] = lastBufferGoalRatio - 0.25;
          return createRepresentationBuffer(representation);
        }

        throw formattedError;
      }));
    });
  }
}
// CONCATENATED MODULE: ./src/core/buffers/adaptation/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var buffers_adaptation = (AdaptationBuffer);
// CONCATENATED MODULE: ./src/core/buffers/period/create_empty_adaptation_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Create empty AdaptationBuffer Observable, linked to a Period.
 *
 * This observable will never download any segment and just emit a "full"
 * event when reaching the end.
 * @param {Observable} bufferClock$
 * @param {Observable} wantedBufferAhead$
 * @param {string} bufferType
 * @param {Object} content
 * @returns {Observable}
 */

function creatEmptyAdaptationBuffer(bufferClock$, wantedBufferAhead$, bufferType, content) {
  var period = content.period;
  return Object(combineLatest["a" /* combineLatest */])([bufferClock$, wantedBufferAhead$]).pipe(Object(filter["a" /* filter */])(function (_ref) {
    var clockTick = _ref[0],
        wantedBufferAhead = _ref[1];
    return period.end != null && clockTick.currentTime + wantedBufferAhead >= period.end;
  }), Object(map["a" /* map */])(function () {
    log["a" /* default */].debug("Buffer: full \"empty\" AdaptationBuffer", bufferType);
    return {
      type: "full-buffer",
      value: {
        bufferType: bufferType
      }
    };
  }));
}
// CONCATENATED MODULE: ./src/core/buffers/period/get_adaptation_switch_strategy.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var ADAPTATION_SWITCH_BUFFER_PADDINGS = config["a" /* default */].ADAPTATION_SWITCH_BUFFER_PADDINGS;
/**
 * Find out what to do when switching adaptation, based on the current
 * situation.
 * @param {Object} queuedSourceBuffer
 * @param {Object} period
 * @param {Object} adaptation
 * @param {Object} clockTick
 * @returns {Object}
 */

function getAdaptationSwitchStrategy(queuedSourceBuffer, period, adaptation, clockTick) {
  var buffered = queuedSourceBuffer.getBufferedRanges();

  if (buffered.length === 0) {
    return {
      type: "continue",
      value: undefined
    };
  }

  var bufferedRanges = Object(ranges["a" /* convertToRanges */])(buffered);
  var start = period.start;
  var end = period.end == null ? Infinity : period.end;
  var intersection = Object(ranges["l" /* keepRangeIntersection */])(bufferedRanges, [{
    start: start,
    end: end
  }]);

  if (intersection.length === 0) {
    return {
      type: "continue",
      value: undefined
    };
  } // remove from that intersection what we know to be the right Adaptation


  var adaptationInBuffer = getBufferedRangesFromAdaptation(queuedSourceBuffer, period, adaptation);
  var currentTime = clockTick.currentTime;

  if (adaptation.type === "video" && clockTick.readyState > 1 && Object(ranges["j" /* isTimeInRange */])({
    start: start,
    end: end
  }, currentTime) && Object(ranges["k" /* isTimeInRanges */])(bufferedRanges, currentTime) && !Object(ranges["k" /* isTimeInRanges */])(adaptationInBuffer, currentTime)) {
    return {
      type: "needs-reload",
      value: undefined
    };
  }

  var unwantedData = Object(ranges["b" /* excludeFromRanges */])(intersection, adaptationInBuffer);
  var bufferType = adaptation.type;
  var paddingBefore = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].before;

  if (paddingBefore == null) {
    paddingBefore = 0;
  }

  var paddingAfter = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].after;

  if (paddingAfter == null) {
    paddingAfter = 0;
  }

  var toRemove = Object(ranges["b" /* excludeFromRanges */])(unwantedData, [{
    start: Math.max(currentTime - paddingBefore, start),
    end: Math.min(currentTime + paddingAfter, end)
  }]);
  return toRemove.length > 0 ? {
    type: "clean-buffer",
    value: toRemove
  } : {
    type: "continue",
    value: undefined
  };
}
/**
 * Returns buffered ranges of what we know correspond to the given `adaptation`
 * in the SourceBuffer.
 * @param {Object} queuedSourceBuffer
 * @param {Object} period
 * @param {Object} adaptation
 * @returns {Array.<Object>}
 */

function getBufferedRangesFromAdaptation(queuedSourceBuffer, period, adaptation) {
  queuedSourceBuffer.synchronizeInventory();
  return queuedSourceBuffer.getInventory().reduce(function (acc, chunk) {
    if (chunk.infos.period.id !== period.id || chunk.infos.adaptation.id !== adaptation.id) {
      return acc;
    }

    var bufferedStart = chunk.bufferedStart,
        bufferedEnd = chunk.bufferedEnd;

    if (bufferedStart === undefined || bufferedEnd === undefined) {
      return acc;
    }

    acc.push({
      start: bufferedStart,
      end: bufferedEnd
    });
    return acc;
  }, []);
}
// CONCATENATED MODULE: ./src/core/buffers/period/period_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * Create single PeriodBuffer Observable:
 *   - Lazily create (or reuse) a SourceBuffer for the given type.
 *   - Create a Buffer linked to an Adaptation each time it changes, to
 *     download and append the corresponding Segments in the SourceBuffer.
 *   - Announce when the Buffer is full or is awaiting new Segments through
 *     events
 * @param {Object} args
 * @returns {Observable}
 */

function PeriodBuffer(_ref) {
  var abrManager = _ref.abrManager,
      bufferType = _ref.bufferType,
      clock$ = _ref.clock$,
      content = _ref.content,
      garbageCollectors = _ref.garbageCollectors,
      segmentFetcherCreator = _ref.segmentFetcherCreator,
      sourceBuffersStore = _ref.sourceBuffersStore,
      options = _ref.options,
      wantedBufferAhead$ = _ref.wantedBufferAhead$;
  var period = content.period; // Emits the chosen Adaptation for the current type.
  // `null` when no Adaptation is chosen (e.g. no subtitles)

  var adaptation$ = new ReplaySubject["a" /* ReplaySubject */](1);
  return adaptation$.pipe(Object(switchMap["a" /* switchMap */])(function (adaptation) {
    if (adaptation == null) {
      log["a" /* default */].info("Buffer: Set no " + bufferType + " Adaptation", period);
      var previousQSourceBuffer = sourceBuffersStore.get(bufferType);
      var cleanBuffer$;

      if (previousQSourceBuffer != null) {
        log["a" /* default */].info("Buffer: Clearing previous " + bufferType + " SourceBuffer");
        cleanBuffer$ = previousQSourceBuffer.removeBuffer(period.start, period.end == null ? Infinity : period.end);
      } else {
        cleanBuffer$ = Object(of["a" /* of */])(null);
      }

      return Object(concat["a" /* concat */])(cleanBuffer$.pipe(Object(mapTo["a" /* mapTo */])(buffers_events_generators.adaptationChange(bufferType, null, period))), creatEmptyAdaptationBuffer(clock$, wantedBufferAhead$, bufferType, {
        period: period
      }));
    }

    log["a" /* default */].info("Buffer: Updating " + bufferType + " adaptation", adaptation, period);
    var newBuffer$ = clock$.pipe(Object(take["a" /* take */])(1), Object(mergeMap["a" /* mergeMap */])(function (tick) {
      var qSourceBuffer = createOrReuseQueuedSourceBuffer(sourceBuffersStore, bufferType, adaptation, options);
      var strategy = getAdaptationSwitchStrategy(qSourceBuffer, period, adaptation, tick);

      if (strategy.type === "needs-reload") {
        return Object(of["a" /* of */])(buffers_events_generators.needsMediaSourceReload(tick));
      }

      var cleanBuffer$ = strategy.type === "clean-buffer" ? concat["a" /* concat */].apply(void 0, strategy.value.map(function (_ref2) {
        var start = _ref2.start,
            end = _ref2.end;
        return qSourceBuffer.removeBuffer(start, end);
      })).pipe(Object(ignoreElements["a" /* ignoreElements */])()) : empty["a" /* EMPTY */];
      var bufferGarbageCollector$ = garbageCollectors.get(qSourceBuffer);
      var adaptationBuffer$ = createAdaptationBuffer(adaptation, qSourceBuffer);
      return Object(concat["a" /* concat */])(cleanBuffer$, Object(merge["a" /* merge */])(adaptationBuffer$, bufferGarbageCollector$));
    }));
    return Object(concat["a" /* concat */])(Object(of["a" /* of */])(buffers_events_generators.adaptationChange(bufferType, adaptation, period)), newBuffer$);
  }), Object(startWith["a" /* startWith */])(buffers_events_generators.periodBufferReady(bufferType, period, adaptation$)));
  /**
   * @param {Object} adaptation
   * @param {Object} qSourceBuffer
   * @returns {Observable}
   */

  function createAdaptationBuffer(adaptation, qSourceBuffer) {
    var manifest = content.manifest;
    var adaptationBufferClock$ = clock$.pipe(Object(map["a" /* map */])(function (tick) {
      var buffered = qSourceBuffer.getBufferedRanges();
      return Object(object_assign["a" /* default */])({}, tick, {
        bufferGap: Object(ranges["d" /* getLeftSizeOfRange */])(buffered, tick.currentTime)
      });
    }));
    return buffers_adaptation({
      abrManager: abrManager,
      clock$: adaptationBufferClock$,
      content: {
        manifest: manifest,
        period: period,
        adaptation: adaptation
      },
      options: options,
      queuedSourceBuffer: qSourceBuffer,
      segmentFetcherCreator: segmentFetcherCreator,
      wantedBufferAhead$: wantedBufferAhead$
    }).pipe(Object(catchError["a" /* catchError */])(function (error) {
      // non native buffer should not impact the stability of the
      // player. ie: if a text buffer sends an error, we want to
      // continue playing without any subtitles
      if (!source_buffers.isNative(bufferType)) {
        log["a" /* default */].error("Buffer: Custom " + bufferType + " buffer crashed. Aborting it.", error);
        sourceBuffersStore.disposeSourceBuffer(bufferType);
        var formattedError = formatError(error, {
          defaultCode: "NONE",
          defaultReason: "Unknown `AdaptationBuffer` error"
        });
        return Object(concat["a" /* concat */])(Object(of["a" /* of */])(buffers_events_generators.warning(formattedError)), creatEmptyAdaptationBuffer(clock$, wantedBufferAhead$, bufferType, {
          period: period
        }));
      }

      log["a" /* default */].error("Buffer: Native " + bufferType + " buffer crashed. Stopping playback.", error);
      throw error;
    }));
  }
}
/**
 * @param {string} bufferType
 * @param {Object} adaptation
 * @returns {Object}
 */

function createOrReuseQueuedSourceBuffer(sourceBuffersStore, bufferType, adaptation, options) {
  var currentQSourceBuffer = sourceBuffersStore.get(bufferType);

  if (currentQSourceBuffer != null) {
    log["a" /* default */].info("Buffer: Reusing a previous SourceBuffer for the type", bufferType);
    return currentQSourceBuffer;
  }

  var codec = getFirstDeclaredMimeType(adaptation);
  var sbOptions = bufferType === "text" ? options.textTrackOptions : undefined;
  return sourceBuffersStore.createSourceBuffer(bufferType, codec, sbOptions);
}
/**
 * Get mimetype string of the first representation declared in the given
 * adaptation.
 * @param {Adaptation} adaptation
 * @returns {string}
 */


function getFirstDeclaredMimeType(adaptation) {
  var representations = adaptation.representations;

  if (representations[0] == null) {
    return "";
  }

  return representations[0].getMimeTypeString();
}
// CONCATENATED MODULE: ./src/core/buffers/period/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var buffers_period = (PeriodBuffer);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/scan.js
var scan = __webpack_require__(222);

// CONCATENATED MODULE: ./src/core/buffers/orchestrator/active_period_emitter.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file helps to keep track of the currently active Periods.
 * That is, Periods for which at least a single Buffer is currently active.
 *
 * It also keep track of the currently active period:
 * The first chronological period for which all types of buffers are active.
 */


/**
 * Emit the active Period each times it changes.
 *
 * The active Period is the first Period (in chronological order) which has
 * a RepresentationBuffer associated for every defined BUFFER_TYPES.
 *
 * Emit null if no Period can be considered active currently.
 *
 * @example
 * For 4 BUFFER_TYPES: "AUDIO", "VIDEO", "TEXT" and "IMAGE":
 * ```
 *                     +-------------+
 *         Period 1    | Period 2    | Period 3
 * AUDIO   |=========| | |===      | |
 * VIDEO               | |=====    | |
 * TEXT    |(NO TEXT)| | |(NO TEXT)| | |====    |
 * IMAGE   |=========| | |=        | |
 *                     +-------------+
 *
 * The active Period here is Period 2 as Period 1 has no video
 * RepresentationBuffer.
 *
 * If we are missing a or multiple PeriodBuffers in the first chronological
 * Period, like that is the case here, it generally means that we are
 * currently switching between Periods.
 *
 * For here we are surely switching from Period 1 to Period 2 beginning by the
 * video PeriodBuffer. As every PeriodBuffer is ready for Period 2, we can
 * already inform that it is the current Period.
 * ```
 *
 * @param {Array.<string>} bufferTypes - Every buffer types in the content.
 * @param {Observable} addPeriodBuffer$ - Emit PeriodBuffer information when
 * one is added.
 * @param {Observable} removePeriodBuffer$ - Emit PeriodBuffer information when
 * one is removed.
 * @returns {Observable}
 */

function ActivePeriodEmitter(buffers$) {
  var numberOfBuffers = buffers$.length;
  return merge["a" /* merge */].apply(void 0, buffers$).pipe( // not needed to filter, this is an optim
  Object(filter["a" /* filter */])(function (_ref) {
    var type = _ref.type;
    return type === "periodBufferCleared" || type === "adaptationChange" || type === "representationChange";
  }), Object(scan["a" /* scan */])(function (acc, evt) {
    switch (evt.type) {
      case "periodBufferCleared":
        {
          var _evt$value = evt.value,
              period = _evt$value.period,
              type = _evt$value.type;
          var currentInfos = acc[period.id];

          if (currentInfos != null && currentInfos.buffers.has(type)) {
            currentInfos.buffers["delete"](type);

            if (currentInfos.buffers.size === 0) {
              delete acc[period.id];
            }
          }
        }
        break;

      case "adaptationChange":
        {
          // `adaptationChange` with a null Adaptation will not lead to a
          // `representationChange` event
          if (evt.value.adaptation != null) {
            return acc;
          }
        }

      case "representationChange":
        {
          var _evt$value2 = evt.value,
              _period = _evt$value2.period,
              _type = _evt$value2.type;
          var _currentInfos = acc[_period.id];

          if (_currentInfos != null && !_currentInfos.buffers.has(_type)) {
            _currentInfos.buffers.add(_type);
          } else {
            var bufferSet = new Set();
            bufferSet.add(_type);
            acc[_period.id] = {
              period: _period,
              buffers: bufferSet
            };
          }
        }
        break;
    }

    return acc;
  }, {}), Object(map["a" /* map */])(function (list) {
    var activePeriodIDs = Object.keys(list);
    var completePeriods = [];

    for (var i = 0; i < activePeriodIDs.length; i++) {
      var periodInfos = list[activePeriodIDs[i]];

      if (periodInfos != null && periodInfos.buffers.size === numberOfBuffers) {
        completePeriods.push(periodInfos.period);
      }
    }

    return completePeriods.reduce(function (acc, period) {
      if (acc == null) {
        return period;
      }

      return period.start < acc.start ? period : acc;
    }, null);
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])(function (a, b) {
    return a == null && b == null || a != null && b != null && a.id === b.id;
  }));
}
// CONCATENATED MODULE: ./src/core/buffers/orchestrator/are_buffers_complete.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns an Observable which emits ``true`` when all PeriodBuffers given are
 * _complete_.
 * Returns false otherwise.
 *
 * A PeriodBuffer for a given type is considered _complete_ when both of these
 * conditions are true:
 *   - it is the last PeriodBuffer in the content for the given type
 *   - it has finished downloading segments (it is _full_)
 *
 * Simply put a _complete_ PeriodBuffer for a given type means that every
 * segments needed for this Buffer have been downloaded.
 *
 * When the Observable returned here emits, every Buffer are finished.
 * @param {...Observable} buffers
 * @returns {Observable}
 */

function areBuffersComplete() {
  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {
    buffers[_key] = arguments[_key];
  }

  /**
   * Array of Observables linked to the Array of Buffers which emit:
   *   - true when the corresponding buffer is considered _complete_.
   *   - false when the corresponding buffer is considered _active_.
   * @type {Array.<Observable>}
   */
  var isCompleteArray = buffers.map(function (buffer) {
    return buffer.pipe(Object(filter["a" /* filter */])(function (evt) {
      return evt.type === "complete-buffer" || evt.type === "active-buffer";
    }), Object(map["a" /* map */])(function (evt) {
      return evt.type === "complete-buffer";
    }), Object(startWith["a" /* startWith */])(false), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
  });
  return Object(combineLatest["a" /* combineLatest */])(isCompleteArray).pipe(Object(map["a" /* map */])(function (areComplete) {
    return areComplete.every(function (isComplete) {
      return isComplete;
    });
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
}
// CONCATENATED MODULE: ./src/core/buffers/orchestrator/get_blacklisted_ranges.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the buffered ranges which hold the given content.
 * Returns the whole buffered ranges if some of it is unknown.
 * @param {Object} queuedSourceBuffer
 * @param {Array.<Object>} contents
 * @returns {Array.<Object>}
 */

function getBlacklistedRanges(queuedSourceBuffer, contents) {
  queuedSourceBuffer.synchronizeInventory();
  var accumulator = [];
  var inventory = queuedSourceBuffer.getInventory();

  var _loop = function _loop(i) {
    var chunk = inventory[i];
    var hasContent = contents.some(function (content) {
      return chunk.infos.period.id === content.period.id && chunk.infos.adaptation.id === content.adaptation.id && chunk.infos.representation.id === content.representation.id;
    });

    if (hasContent) {
      var bufferedStart = chunk.bufferedStart,
          bufferedEnd = chunk.bufferedEnd;

      if (bufferedStart === undefined || bufferedEnd === undefined) {
        log["a" /* default */].warn("BO: No buffered start or end found from a segment.");
        var buffered = queuedSourceBuffer.getBufferedRanges();
        var len = buffered.length;

        if (len === 0) {
          return {
            v: []
          };
        }

        return {
          v: [{
            start: buffered.start(0),
            end: buffered.end(len - 1)
          }]
        };
      }

      var previousLastElement = accumulator[accumulator.length - 1];

      if (previousLastElement !== undefined && previousLastElement.end === bufferedStart) {
        previousLastElement.end = bufferedEnd;
      } else {
        accumulator.push({
          start: bufferedStart,
          end: bufferedEnd
        });
      }
    }
  };

  for (var i = 0; i < inventory.length; i++) {
    var _ret = _loop(i);

    if (typeof _ret === "object") return _ret.v;
  }

  return accumulator;
}
// CONCATENATED MODULE: ./src/core/buffers/orchestrator/buffer_orchestrator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














var MAXIMUM_MAX_BUFFER_AHEAD = config["a" /* default */].MAXIMUM_MAX_BUFFER_AHEAD,
    MAXIMUM_MAX_BUFFER_BEHIND = config["a" /* default */].MAXIMUM_MAX_BUFFER_BEHIND;
/**
 * Create and manage the various Buffer Observables needed for the content to
 * play:
 *
 *   - Create or dispose SourceBuffers depending on the chosen Adaptations.
 *
 *   - Push the right segments to those SourceBuffers depending on the user's
 *     preferences, the current position, the bandwidth, the decryption
 *     conditions...
 *
 *   - Concatenate Buffers for adaptation from separate Periods at the right
 *     time, to allow smooth transitions between periods.
 *
 *   - Emit various events to notify of its health and issues
 *
 * Here multiple buffers can be created at the same time to allow smooth
 * transitions between periods.
 * To do this, we dynamically create or destroy buffers as they are needed.
 * @param {Object} content
 * @param {Observable} clock$ - Emit position information
 * @param {Object} abrManager - Emit bitrate estimation and best Representation
 * to play.
 * @param {Object} sourceBuffersStore - Will be used to lazily create
 * SourceBuffer instances associated with the current content.
 * @param {Object} segmentFetcherCreator - Allow to download segments.
 * @param {Object} options
 * @returns {Observable}
 *
 * TODO Special case for image Buffer, where we want data for EVERY active
 * periods.
 */

function BufferOrchestrator(content, clock$, abrManager, sourceBuffersStore, segmentFetcherCreator, options) {
  var manifest = content.manifest,
      initialPeriod = content.initialPeriod;
  var maxBufferAhead$ = options.maxBufferAhead$,
      maxBufferBehind$ = options.maxBufferBehind$,
      wantedBufferAhead$ = options.wantedBufferAhead$; // Keep track of a unique BufferGarbageCollector created per
  // QueuedSourceBuffer.

  var garbageCollectors = new WeakMapMemory(function (qSourceBuffer) {
    var bufferType = qSourceBuffer.bufferType;
    var defaultMaxBehind = MAXIMUM_MAX_BUFFER_BEHIND[bufferType] != null ? MAXIMUM_MAX_BUFFER_BEHIND[bufferType] : Infinity;
    var defaultMaxAhead = MAXIMUM_MAX_BUFFER_AHEAD[bufferType] != null ? MAXIMUM_MAX_BUFFER_AHEAD[bufferType] : Infinity;
    return BufferGarbageCollector({
      queuedSourceBuffer: qSourceBuffer,
      clock$: clock$.pipe(Object(map["a" /* map */])(function (tick) {
        return tick.currentTime;
      })),
      maxBufferBehind$: maxBufferBehind$.pipe(Object(map["a" /* map */])(function (val) {
        return Math.min(val, defaultMaxBehind);
      })),
      maxBufferAhead$: maxBufferAhead$.pipe(Object(map["a" /* map */])(function (val) {
        return Math.min(val, defaultMaxAhead);
      }))
    });
  }); // trigger warnings when the wanted time is before or after the manifest's
  // segments

  var outOfManifest$ = clock$.pipe(Object(mergeMap["a" /* mergeMap */])(function (_ref) {
    var currentTime = _ref.currentTime,
        wantedTimeOffset = _ref.wantedTimeOffset;
    var position = wantedTimeOffset + currentTime;

    if (position < manifest.getMinimumPosition()) {
      var warning = new media_error["a" /* default */]("MEDIA_TIME_BEFORE_MANIFEST", "The current position is behind the " + "earliest time announced in the Manifest.");
      return Object(of["a" /* of */])(buffers_events_generators.warning(warning));
    } else if (position > manifest.getMaximumPosition()) {
      var _warning = new media_error["a" /* default */]("MEDIA_TIME_AFTER_MANIFEST", "The current position is after the latest " + "time announced in the Manifest.");

      return Object(of["a" /* of */])(buffers_events_generators.warning(_warning));
    }

    return empty["a" /* EMPTY */];
  }));
  var bufferTypes = getBufferTypes(); // Every PeriodBuffers for every possible types

  var buffersArray = bufferTypes.map(function (bufferType) {
    return manageEveryBuffers(bufferType, initialPeriod).pipe(Object(subscribeOn["a" /* subscribeOn */])(asap["a" /* asap */]), Object(share["a" /* share */])());
  }); // Emits the activePeriodChanged events every time the active Period changes.

  var activePeriodChanged$ = ActivePeriodEmitter(buffersArray).pipe(Object(filter["a" /* filter */])(function (period) {
    return period != null;
  }), Object(map["a" /* map */])(function (period) {
    log["a" /* default */].info("Buffer: New active period", period);
    return buffers_events_generators.activePeriodChanged(period);
  })); // Emits an "end-of-stream" event once every PeriodBuffer are complete.
  // Emits a 'resume-stream" when it's not

  var endOfStream$ = areBuffersComplete.apply(void 0, buffersArray).pipe(Object(map["a" /* map */])(function (areComplete) {
    return areComplete ? buffers_events_generators.endOfStream() : buffers_events_generators.resumeStream();
  }));
  return merge["a" /* merge */].apply(void 0, buffersArray.concat([activePeriodChanged$, endOfStream$, outOfManifest$]));
  /**
   * Manage creation and removal of Buffers for every Periods for a given type.
   *
   * Works by creating consecutive buffers through the
   * `manageConsecutivePeriodBuffers` function, and restarting it when the clock
   * goes out of the bounds of these buffers.
   * @param {string} bufferType - e.g. "audio" or "video"
   * @param {Period} basePeriod - Initial Period downloaded.
   * @returns {Observable}
   */

  function manageEveryBuffers(bufferType, basePeriod) {
    // Each Period for which there is currently a Buffer, chronologically
    var periodList = new sorted_list_SortedList(function (a, b) {
      return a.start - b.start;
    });
    var destroyBuffers$ = new Subject["a" /* Subject */](); // When set to `true`, all the currently active PeriodBuffer will be destroyed
    // and re-created from the new current position if we detect it to be out of
    // their bounds.
    // This is set to false when we're in the process of creating the first
    // PeriodBuffer, to avoid interferences while no PeriodBuffer is available.

    var enableOutOfBoundsCheck = false;
    /**
     * @param {Object} period
     * @returns {Observable}
     */

    function launchConsecutiveBuffersForPeriod(period) {
      return manageConsecutivePeriodBuffers(bufferType, period, destroyBuffers$).pipe(Object(tap["a" /* tap */])(function (message) {
        if (message.type === "periodBufferReady") {
          enableOutOfBoundsCheck = true;
          periodList.add(message.value.period);
        } else if (message.type === "periodBufferCleared") {
          periodList.removeElement(message.value.period);
        }
      }), Object(share["a" /* share */])());
    }
    /**
     * Returns true if the given time is either:
     *   - less than the start of the chronologically first Period
     *   - more than the end of the chronologically last Period
     * @param {number} time
     * @returns {boolean}
     */


    function isOutOfPeriodList(time) {
      var head = periodList.head();
      var last = periodList.last();

      if (head == null || last == null) {
        // if no period
        return true;
      }

      return head.start > time || (last.end == null ? Infinity : last.end) < time;
    } // Restart the current buffer when the wanted time is in another period
    // than the ones already considered


    var restartBuffersWhenOutOfBounds$ = clock$.pipe(Object(filter["a" /* filter */])(function (_ref2) {
      var currentTime = _ref2.currentTime,
          wantedTimeOffset = _ref2.wantedTimeOffset;
      return enableOutOfBoundsCheck && manifest.getPeriodForTime(wantedTimeOffset + currentTime) !== undefined && isOutOfPeriodList(wantedTimeOffset + currentTime);
    }), Object(tap["a" /* tap */])(function (_ref3) {
      var currentTime = _ref3.currentTime,
          wantedTimeOffset = _ref3.wantedTimeOffset;
      log["a" /* default */].info("BO: Current position out of the bounds of the active periods," + "re-creating buffers.", bufferType, currentTime + wantedTimeOffset);
      enableOutOfBoundsCheck = false;
      destroyBuffers$.next();
    }), Object(mergeMap["a" /* mergeMap */])(function (_ref4) {
      var currentTime = _ref4.currentTime,
          wantedTimeOffset = _ref4.wantedTimeOffset;
      var newInitialPeriod = manifest.getPeriodForTime(currentTime + wantedTimeOffset);

      if (newInitialPeriod == null) {
        throw new media_error["a" /* default */]("MEDIA_TIME_NOT_FOUND", "The wanted position is not found in the Manifest.");
      }

      return launchConsecutiveBuffersForPeriod(newInitialPeriod);
    }));
    var handleDecipherabilityUpdate$ = Object(event_emitter["b" /* fromEvent */])(manifest, "decipherabilityUpdate").pipe(Object(mergeMap["a" /* mergeMap */])(function (updates) {
      var queuedSourceBuffer = sourceBuffersStore.get(bufferType);
      var hasType = updates.some(function (update) {
        return update.adaptation.type === bufferType;
      });

      if (!hasType || queuedSourceBuffer == null) {
        return empty["a" /* EMPTY */]; // no need to stop the current buffers
      }

      var rangesToClean = getBlacklistedRanges(queuedSourceBuffer, updates);
      enableOutOfBoundsCheck = false;
      destroyBuffers$.next();
      return concat["a" /* concat */].apply(void 0, rangesToClean.map(function (_ref5) {
        var start = _ref5.start,
            end = _ref5.end;
        return queuedSourceBuffer.removeBuffer(start, end).pipe(Object(ignoreElements["a" /* ignoreElements */])());
      }).concat([clock$.pipe(Object(take["a" /* take */])(1), Object(mergeMap["a" /* mergeMap */])(function (lastTick) {
        return Object(concat["a" /* concat */])(Object(of["a" /* of */])(buffers_events_generators.needsDecipherabilityFlush(lastTick)), Object(defer["a" /* defer */])(function () {
          var lastPosition = lastTick.currentTime + lastTick.wantedTimeOffset;
          var newInitialPeriod = manifest.getPeriodForTime(lastPosition);

          if (newInitialPeriod == null) {
            throw new media_error["a" /* default */]("MEDIA_TIME_NOT_FOUND", "The wanted position is not found in the Manifest.");
          }

          return launchConsecutiveBuffersForPeriod(newInitialPeriod);
        }));
      }))]));
    }));
    return Object(merge["a" /* merge */])(restartBuffersWhenOutOfBounds$, handleDecipherabilityUpdate$, launchConsecutiveBuffersForPeriod(basePeriod));
  }
  /**
   * Create lazily consecutive PeriodBuffers:
   *
   * It first creates the PeriodBuffer for `basePeriod` and - once it becomes
   * full - automatically creates the next chronological one.
   * This process repeats until the PeriodBuffer linked to the last Period is
   * full.
   *
   * If an "old" PeriodBuffer becomes active again, it destroys all PeriodBuffer
   * coming after it (from the last chronological one to the first).
   *
   * To clean-up PeriodBuffers, each one of them are also automatically
   * destroyed once the clock anounce a time superior or equal to the end of
   * the concerned Period.
   *
   * A "periodBufferReady" event is sent each times a new PeriodBuffer is
   * created. The first one (for `basePeriod`) should be sent synchronously on
   * subscription.
   *
   * A "periodBufferCleared" event is sent each times a PeriodBuffer is
   * destroyed.
   * @param {string} bufferType - e.g. "audio" or "video"
   * @param {Period} basePeriod - Initial Period downloaded.
   * @param {Observable} destroy$ - Emit when/if all created Buffers from this
   * point should be destroyed.
   * @returns {Observable}
   */


  function manageConsecutivePeriodBuffers(bufferType, basePeriod, destroy$) {
    log["a" /* default */].info("BO: Creating new Buffer for", bufferType, basePeriod); // Emits the Period of the next Period Buffer when it can be created.

    var createNextPeriodBuffer$ = new Subject["a" /* Subject */](); // Emits when the Buffers for the next Periods should be destroyed, if
    // created.

    var destroyNextBuffers$ = new Subject["a" /* Subject */](); // Emits when the current position goes over the end of the current buffer.

    var endOfCurrentBuffer$ = clock$.pipe(Object(filter["a" /* filter */])(function (_ref6) {
      var currentTime = _ref6.currentTime,
          wantedTimeOffset = _ref6.wantedTimeOffset;
      return basePeriod.end != null && currentTime + wantedTimeOffset >= basePeriod.end;
    })); // Create Period Buffer for the next Period.

    var nextPeriodBuffer$ = createNextPeriodBuffer$.pipe(exhaustMap(function (nextPeriod) {
      return manageConsecutivePeriodBuffers(bufferType, nextPeriod, destroyNextBuffers$);
    })); // Allows to destroy each created Buffer, from the newest to the oldest,
    // once destroy$ emits.

    var destroyAll$ = destroy$.pipe(Object(take["a" /* take */])(1), Object(tap["a" /* tap */])(function () {
      // first complete createNextBuffer$ to allow completion of the
      // nextPeriodBuffer$ observable once every further Buffers have been
      // cleared.
      createNextPeriodBuffer$.complete(); // emit destruction signal to the next Buffer first

      destroyNextBuffers$.next();
      destroyNextBuffers$.complete(); // we do not need it anymore
    }), Object(share["a" /* share */])() // share side-effects
    ); // Will emit when the current buffer should be destroyed.

    var killCurrentBuffer$ = Object(merge["a" /* merge */])(endOfCurrentBuffer$, destroyAll$);
    var periodBuffer$ = buffers_period({
      abrManager: abrManager,
      bufferType: bufferType,
      clock$: clock$,
      content: {
        manifest: manifest,
        period: basePeriod
      },
      garbageCollectors: garbageCollectors,
      segmentFetcherCreator: segmentFetcherCreator,
      sourceBuffersStore: sourceBuffersStore,
      options: options,
      wantedBufferAhead$: wantedBufferAhead$
    }).pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
      var type = evt.type;

      if (type === "full-buffer") {
        var nextPeriod = manifest.getPeriodAfter(basePeriod);

        if (nextPeriod == null) {
          return Object(of["a" /* of */])(buffers_events_generators.bufferComplete(bufferType));
        } else {
          // current buffer is full, create the next one if not
          createNextPeriodBuffer$.next(nextPeriod);
        }
      } else if (type === "active-buffer") {
        // current buffer is active, destroy next buffer if created
        destroyNextBuffers$.next();
      }

      return Object(of["a" /* of */])(evt);
    }), Object(share["a" /* share */])()); // Buffer for the current Period.

    var currentBuffer$ = Object(concat["a" /* concat */])(periodBuffer$.pipe(Object(takeUntil["a" /* takeUntil */])(killCurrentBuffer$)), Object(of["a" /* of */])(buffers_events_generators.periodBufferCleared(bufferType, basePeriod)).pipe(Object(tap["a" /* tap */])(function () {
      log["a" /* default */].info("BO: Destroying buffer for", bufferType, basePeriod);
    })));
    return Object(merge["a" /* merge */])(currentBuffer$, nextPeriodBuffer$, destroyAll$.pipe(Object(ignoreElements["a" /* ignoreElements */])()));
  }
}
// CONCATENATED MODULE: ./src/core/buffers/orchestrator/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var orchestrator = (BufferOrchestrator);
// CONCATENATED MODULE: ./src/core/buffers/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var core_buffers = (orchestrator);
// CONCATENATED MODULE: ./src/core/init/create_buffer_clock.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Create clock Observable for the Buffers part of the code.
 * @param {Observable} initClock$
 * @param {Object} bufferClockArgument
 * @returns {Observable}
 */

function createBufferClock(initClock$, _ref) {
  var autoPlay = _ref.autoPlay,
      initialPlay$ = _ref.initialPlay$,
      initialSeek$ = _ref.initialSeek$,
      manifest = _ref.manifest,
      speed$ = _ref.speed$,
      startTime = _ref.startTime;
  var initialPlayPerformed = false;
  var initialSeekPerformed = false;
  var updateIsPaused$ = initialPlay$.pipe(Object(tap["a" /* tap */])(function () {
    initialPlayPerformed = true;
  }), Object(ignoreElements["a" /* ignoreElements */])());
  var updateTimeOffset$ = initialSeek$.pipe(Object(tap["a" /* tap */])(function () {
    initialSeekPerformed = true;
  }), Object(ignoreElements["a" /* ignoreElements */])());
  var clock$ = Object(combineLatest["a" /* combineLatest */])([initClock$, speed$]).pipe(Object(map["a" /* map */])(function (_ref2) {
    var tick = _ref2[0],
        speed = _ref2[1];
    var isLive = manifest.isLive;
    return {
      currentTime: tick.currentTime,
      duration: tick.duration,
      isPaused: initialPlayPerformed ? tick.paused : !autoPlay,
      liveGap: isLive ? manifest.getMaximumPosition() - tick.currentTime : Infinity,
      readyState: tick.readyState,
      speed: speed,
      stalled: tick.stalled,
      // wantedTimeOffset is an offset to add to the timing's current time to have
      // the "real" wanted position.
      // For now, this is seen when the media element has not yet seeked to its
      // initial position, the currentTime will most probably be 0 where the
      // effective starting position will be _startTime_.
      // Thus we initially set a wantedTimeOffset equal to startTime.
      wantedTimeOffset: initialSeekPerformed ? 0 : startTime - tick.currentTime
    };
  }));
  return Object(merge["a" /* merge */])(updateIsPaused$, updateTimeOffset$, clock$);
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/race.js
var race = __webpack_require__(216);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = __webpack_require__(106);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeLast.js
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return Object(empty["b" /* empty */])();
        }
        else {
            return source.lift(new takeLast_TakeLastOperator(count));
        }
    };
}
var takeLast_TakeLastOperator = /*@__PURE__*/ (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError["a" /* ArgumentOutOfRangeError */];
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new takeLast_TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var takeLast_TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber["a" /* Subscriber */]));
//# sourceMappingURL=takeLast.js.map

// CONCATENATED MODULE: ./src/core/init/end_of_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var onRemoveSourceBuffers$ = compat["a" /* events */].onRemoveSourceBuffers$,
    end_of_stream_onSourceOpen$ = compat["a" /* events */].onSourceOpen$,
    onUpdate$ = compat["a" /* events */].onUpdate$;
/**
 * Get "updating" SourceBuffers from a SourceBufferList.
 * @param {SourceBufferList} sourceBuffers
 * @returns {Array.<SourceBuffer>}
 */

function getUpdatingSourceBuffers(sourceBuffers) {
  var updatingSourceBuffers = [];

  for (var i = 0; i < sourceBuffers.length; i++) {
    var SourceBuffer = sourceBuffers[i];

    if (SourceBuffer.updating) {
      updatingSourceBuffers.push(SourceBuffer);
    }
  }

  return updatingSourceBuffers;
}
/**
 * Trigger the `endOfStream` method of a MediaSource.
 *
 * If the MediaSource is ended/closed, do not call this method.
 * If SourceBuffers are updating, wait for them to be updated before closing
 * it.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */


function triggerEndOfStream(mediaSource) {
  return Object(defer["a" /* defer */])(function () {
    log["a" /* default */].debug("Init: Trying to call endOfStream");

    if (mediaSource.readyState !== "open") {
      log["a" /* default */].debug("Init: MediaSource not open, cancel endOfStream");
      return Object(of["a" /* of */])(null);
    }

    var sourceBuffers = mediaSource.sourceBuffers;
    var updatingSourceBuffers = getUpdatingSourceBuffers(sourceBuffers);

    if (updatingSourceBuffers.length === 0) {
      log["a" /* default */].info("Init: Triggering end of stream");
      mediaSource.endOfStream();
      return Object(of["a" /* of */])(null);
    }

    log["a" /* default */].debug("Init: Waiting SourceBuffers to be updated before calling endOfStream.");
    var updatedSourceBuffers$ = updatingSourceBuffers.map(function (sourceBuffer) {
      return onUpdate$(sourceBuffer).pipe(Object(take["a" /* take */])(1));
    });
    return Object(race["a" /* race */])(merge["a" /* merge */].apply(void 0, updatedSourceBuffers$).pipe(takeLast(1)), onRemoveSourceBuffers$(sourceBuffers).pipe(Object(take["a" /* take */])(1))).pipe(Object(mergeMap["a" /* mergeMap */])(function () {
      return triggerEndOfStream(mediaSource);
    }));
  });
}
/**
 * Trigger the `endOfStream` method of a MediaSource each times it opens.
 * @see triggerEndOfStream
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */

function maintainEndOfStream(mediaSource) {
  return end_of_stream_onSourceOpen$(mediaSource).pipe(Object(startWith["a" /* startWith */])(null), Object(switchMap["a" /* switchMap */])(function () {
    return triggerEndOfStream(mediaSource);
  }));
}
// EXTERNAL MODULE: ./src/compat/is_playback_stuck.ts
var is_playback_stuck = __webpack_require__(166);

// CONCATENATED MODULE: ./src/core/init/get_discontinuities.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var BUFFER_DISCONTINUITY_THRESHOLD = config["a" /* default */].BUFFER_DISCONTINUITY_THRESHOLD;
/**
 * Perform various checks about discontinuities during playback.
 * @param {Observable} clock$
 * @param {Object} manifest
 * @returns {Observable}
 */

function getDiscontinuities(clock$, manifest) {
  return clock$.pipe(Object(filter["a" /* filter */])(function (_ref) {
    var stalled = _ref.stalled;
    return stalled !== null;
  }), Object(map["a" /* map */])(function (tick) {
    var buffered = tick.buffered,
        currentTime = tick.currentTime,
        currentRange = tick.currentRange,
        state = tick.state,
        stalled = tick.stalled;
    var nextBufferRangeGap = Object(ranges["e" /* getNextRangeGap */])(buffered, currentTime); // 1: Is it a browser bug? -> force seek at the same current time

    if (Object(is_playback_stuck["a" /* default */])(currentTime, currentRange, state, stalled !== null)) {
      log["a" /* default */].warn("Init: After freeze seek", currentTime, currentRange);
      return [currentTime, currentTime]; // 2. Is it a short discontinuity in buffer ? -> Seek at the beginning of the
      //                                               next range
      //
      // Discontinuity check in case we are close a buffered range but still
      // calculate a stalled state. This is useful for some
      // implementation that might drop an injected segment, or in
      // case of small discontinuity in the content.
    } else if (nextBufferRangeGap < BUFFER_DISCONTINUITY_THRESHOLD) {
      var seekTo = currentTime + nextBufferRangeGap + 1 / 60;
      return [currentTime, seekTo];
    } // 3. Is it a discontinuity between periods ? -> Seek at the beginning of the
    //                                               next period


    var currentPeriod = manifest.getPeriodForTime(currentTime);

    if (currentPeriod != null) {
      var nextPeriod = manifest.getPeriodAfter(currentPeriod);

      if (currentPeriod != null && currentPeriod.end != null && nextPeriod != null && currentTime > currentPeriod.end - 1 && currentTime <= nextPeriod.start && nextPeriod.start - currentPeriod.end === 0) {
        return [currentPeriod.end, nextPeriod.start];
      }
    }
  }), Object(filter["a" /* filter */])(function (x) {
    return x !== undefined;
  }), Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
}
// EXTERNAL MODULE: ./src/core/init/get_stalled_events.ts
var get_stalled_events = __webpack_require__(128);

// CONCATENATED MODULE: ./src/core/init/handle_discontinuity.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Handle discontinuity against current time and stall status
 * @param {number} seekTo
 * @param {boolean} isStalled
 */

function handleDiscontinuity(seekTo, mediaElement) {
  if (seekTo < mediaElement.currentTime) {
    return;
  }

  log["a" /* default */].warn("Init: discontinuity seek", mediaElement.currentTime, seekTo);
  mediaElement.currentTime = seekTo;
}
// EXTERNAL MODULE: ./src/core/init/initial_seek_and_play.ts
var initial_seek_and_play = __webpack_require__(122);

// EXTERNAL MODULE: ./src/core/init/update_playback_rate.ts
var update_playback_rate = __webpack_require__(127);

// CONCATENATED MODULE: ./src/core/init/load_on_media_source.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















/**
 * Returns a function allowing to load or reload the content in arguments into
 * a single or multiple MediaSources.
 * @param {Object} args
 * @returns {Observable}
 */

function createMediaSourceLoader(_ref) {
  var mediaElement = _ref.mediaElement,
      manifest = _ref.manifest,
      clock$ = _ref.clock$,
      speed$ = _ref.speed$,
      bufferOptions = _ref.bufferOptions,
      abrManager = _ref.abrManager,
      segmentFetcherCreator = _ref.segmentFetcherCreator;

  /**
   * Load the content on the given MediaSource.
   * @param {MediaSource} mediaSource
   * @param {number} initialTime
   * @param {boolean} autoPlay
   */
  return function loadContentOnMediaSource(mediaSource, initialTime, autoPlay) {
    // TODO Update the duration if it evolves?
    var duration = manifest.isLive ? Infinity : manifest.getMaximumPosition();
    setDurationToMediaSource(mediaSource, duration);
    var initialPeriod = manifest.getPeriodForTime(initialTime);

    if (initialPeriod == null) {
      throw new media_error["a" /* default */]("MEDIA_STARTING_TIME_NOT_FOUND", "Wanted starting time not found in the Manifest.");
    } // Creates SourceBuffersStore allowing to create and keep track of a
    // single SourceBuffer per type.


    var sourceBuffersStore = new source_buffers(mediaElement, mediaSource); // Initialize all native source buffers from the first period at the same
    // time.
    // We cannot lazily create native sourcebuffers since the spec does not
    // allow adding them during playback.
    //
    // From https://w3c.github.io/media-source/#methods
    //    For example, a user agent may throw a QuotaExceededError
    //    exception if the media element has reached the HAVE_METADATA
    //    readyState. This can occur if the user agent's media engine
    //    does not support adding more tracks during playback.

    createNativeSourceBuffersForPeriod(sourceBuffersStore, initialPeriod);

    var _seekAndLoadOnMediaEv = Object(initial_seek_and_play["a" /* default */])({
      clock$: clock$,
      mediaElement: mediaElement,
      startTime: initialTime,
      mustAutoPlay: autoPlay,
      isDirectfile: false
    }),
        seek$ = _seekAndLoadOnMediaEv.seek$,
        load$ = _seekAndLoadOnMediaEv.load$;

    var initialPlay$ = load$.pipe(Object(filter["a" /* filter */])(function (evt) {
      return evt !== "not-loaded-metadata";
    }));
    var bufferClock$ = createBufferClock(clock$, {
      autoPlay: autoPlay,
      initialPlay$: initialPlay$,
      initialSeek$: seek$,
      manifest: manifest,
      speed$: speed$,
      startTime: initialTime
    }); // Will be used to cancel any endOfStream tries when the contents resume

    var cancelEndOfStream$ = new Subject["a" /* Subject */](); // Creates Observable which will manage every Buffer for the given Content.

    var buffers$ = core_buffers({
      manifest: manifest,
      initialPeriod: initialPeriod
    }, bufferClock$, abrManager, sourceBuffersStore, segmentFetcherCreator, bufferOptions).pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
      switch (evt.type) {
        case "end-of-stream":
          log["a" /* default */].debug("Init: end-of-stream order received.");
          return maintainEndOfStream(mediaSource).pipe(Object(ignoreElements["a" /* ignoreElements */])(), Object(takeUntil["a" /* takeUntil */])(cancelEndOfStream$));

        case "resume-stream":
          log["a" /* default */].debug("Init: resume-stream order received.");
          cancelEndOfStream$.next(null);
          return empty["a" /* EMPTY */];

        case "discontinuity-encountered":
          var _evt$value = evt.value,
              bufferType = _evt$value.bufferType,
              gap = _evt$value.gap;

          if (source_buffers.isNative(bufferType)) {
            handleDiscontinuity(gap[1], mediaElement);
          }

          return empty["a" /* EMPTY */];

        default:
          return Object(of["a" /* of */])(evt);
      }
    })); // update the speed set by the user on the media element while pausing a
    // little longer while the buffer is empty.

    var playbackRate$ = Object(update_playback_rate["a" /* default */])(mediaElement, speed$, clock$, {
      pauseWhenStalled: true
    }).pipe(Object(map["a" /* map */])(events_generators["a" /* default */].speedChanged)); // Create Stalling Manager, an observable which will try to get out of
    // various infinite stalling issues

    var stalled$ = Object(get_stalled_events["a" /* default */])(clock$).pipe(Object(map["a" /* map */])(events_generators["a" /* default */].stalled));
    var handledDiscontinuities$ = getDiscontinuities(clock$, manifest).pipe(Object(tap["a" /* tap */])(function (gap) {
      var seekTo = gap[1];
      handleDiscontinuity(seekTo, mediaElement);
    }), Object(ignoreElements["a" /* ignoreElements */])());
    var loadedEvent$ = load$.pipe(Object(mergeMap["a" /* mergeMap */])(function (evt) {
      if (evt === "autoplay-blocked") {
        var error = new media_error["a" /* default */]("MEDIA_ERR_BLOCKED_AUTOPLAY", "Cannot trigger auto-play automatically: " + "your browser does not allow it.");
        return Object(of["a" /* of */])(events_generators["a" /* default */].warning(error), events_generators["a" /* default */].loaded(sourceBuffersStore));
      } else if (evt === "not-loaded-metadata") {
        var _error = new media_error["a" /* default */]("MEDIA_ERR_NOT_LOADED_METADATA", "Cannot load automatically: your browser " + "falsely announced having loaded the content.");

        return Object(of["a" /* of */])(events_generators["a" /* default */].warning(_error));
      }

      log["a" /* default */].debug("Init: The current content is loaded.");
      return Object(of["a" /* of */])(events_generators["a" /* default */].loaded(sourceBuffersStore));
    }));
    return Object(merge["a" /* merge */])(handledDiscontinuities$, loadedEvent$, playbackRate$, stalled$, buffers$).pipe(finalize(function () {
      // clean-up every created SourceBuffers
      sourceBuffersStore.disposeAll();
    }));
  };
}
/**
 * Create all native SourceBuffers needed for a given Period.
 *
 * Native Buffers have the particulary to need to be created at the beginning of
 * the content.
 * Custom source buffers (entirely managed in JS) can generally be created and
 * disposed at will during the lifecycle of the content.
 * @param {SourceBuffersStore} sourceBuffersStore
 * @param {Period} period
 */

function createNativeSourceBuffersForPeriod(sourceBuffersStore, period) {
  Object.keys(period.adaptations).forEach(function (bufferType) {
    if (source_buffers.isNative(bufferType)) {
      var adaptations = period.adaptations[bufferType];
      var representations = adaptations != null && adaptations.length > 0 ? adaptations[0].representations : [];

      if (representations.length > 0) {
        var codec = representations[0].getMimeTypeString();
        sourceBuffersStore.createSourceBuffer(bufferType, codec);
      }
    }
  });
}
// CONCATENATED MODULE: ./src/core/init/manifest_update_scheduler.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY = config["a" /* default */].FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY;
/**
 * Refresh the Manifest at the right time.
 * @param {Object} manifestUpdateSchedulerArguments
 * @returns {Observable}
 */

function manifestUpdateScheduler(_ref) {
  var fetchManifest = _ref.fetchManifest,
      initialManifest = _ref.initialManifest,
      manifestUpdateUrl = _ref.manifestUpdateUrl,
      minimumManifestUpdateInterval = _ref.minimumManifestUpdateInterval,
      scheduleRefresh$ = _ref.scheduleRefresh$;
  // The Manifest always keeps the same Manifest
  var manifest = initialManifest.manifest;

  function handleManifestRefresh$(manifestInfos) {
    var sendingTime = manifestInfos.sendingTime;
    var internalRefresh$ = scheduleRefresh$.pipe(Object(mergeMap["a" /* mergeMap */])(function (_ref2) {
      var completeRefresh = _ref2.completeRefresh,
          delay = _ref2.delay;
      return startManualRefreshTimer(delay !== null && delay !== void 0 ? delay : 0, minimumManifestUpdateInterval, sendingTime).pipe(Object(mapTo["a" /* mapTo */])({
        completeRefresh: completeRefresh
      }));
    }));
    var timeSinceRequest = sendingTime == null ? 0 : performance.now() - sendingTime;
    var minInterval = Math.max(minimumManifestUpdateInterval - timeSinceRequest, 0);
    var autoRefresh$;

    if (manifest.lifetime === undefined || manifest.lifetime < 0) {
      autoRefresh$ = empty["a" /* EMPTY */];
    } else {
      var parsingTime = manifestInfos.parsingTime,
          updatingTime = manifestInfos.updatingTime;
      var autoRefreshInterval = manifest.lifetime * 1000 - timeSinceRequest;

      if (parsingTime + (updatingTime !== null && updatingTime !== void 0 ? updatingTime : 0) >= manifest.lifetime * 1000 / 4) {
        var newInterval = Math.max(autoRefreshInterval, 0) + parsingTime + (updatingTime !== null && updatingTime !== void 0 ? updatingTime : 0);
        log["a" /* default */].info("MUS: Manifest took too long to parse. Postponing next request", autoRefreshInterval, newInterval);
        autoRefreshInterval = newInterval;
      }

      autoRefresh$ = Object(timer["a" /* timer */])(Math.max(autoRefreshInterval, minInterval)).pipe(Object(mapTo["a" /* mapTo */])({
        completeRefresh: false
      }));
    }

    var expired$ = manifest.expired === null ? empty["a" /* EMPTY */] : Object(timer["a" /* timer */])(minInterval).pipe(Object(mergeMapTo["a" /* mergeMapTo */])(Object(from["a" /* from */])(manifest.expired)), Object(mapTo["a" /* mapTo */])({
      completeRefresh: true
    })); // Emit when the manifest should be refreshed. Either when:
    //   - A buffer asks for it to be refreshed
    //   - its lifetime expired.

    return Object(merge["a" /* merge */])(autoRefresh$, internalRefresh$, expired$).pipe(Object(take["a" /* take */])(1), Object(mergeMap["a" /* mergeMap */])(function (_ref3) {
      var completeRefresh = _ref3.completeRefresh;
      return refreshManifest(completeRefresh);
    }), Object(mergeMap["a" /* mergeMap */])(function (evt) {
      if (evt.type === "warning") {
        return Object(of["a" /* of */])(evt);
      }

      return handleManifestRefresh$(evt);
    }));
  }

  return Object(defer["a" /* defer */])(function () {
    return handleManifestRefresh$(initialManifest);
  });
  /**
   * Refresh the Manifest.
   * Perform a full update if a partial update failed.
   * @param {boolean} completeRefresh
   * @returns {Observable}
   */

  function refreshManifest(completeRefresh) {
    var fullRefresh = completeRefresh || manifestUpdateUrl === undefined;
    var refreshURL = fullRefresh ? manifest.getUrl() : manifestUpdateUrl;

    if (!Object(is_non_empty_string["a" /* default */])(refreshURL)) {
      log["a" /* default */].warn("Init: Cannot refresh the manifest: no url");
      return empty["a" /* EMPTY */];
    }

    var externalClockOffset = manifest.clockOffset;
    return fetchManifest(refreshURL, externalClockOffset).pipe(Object(mergeMap["a" /* mergeMap */])(function (value) {
      if (value.type === "warning") {
        return Object(of["a" /* of */])(value);
      }

      var newManifest = value.manifest,
          newSendingTime = value.sendingTime,
          receivedTime = value.receivedTime,
          parsingTime = value.parsingTime;
      var updateTimeStart = performance.now();

      if (fullRefresh) {
        manifest.replace(newManifest);
      } else {
        try {
          manifest.update(newManifest);
        } catch (e) {
          var message = e instanceof Error ? e.message : "unknown error";
          log["a" /* default */].warn("MUS: Attempt to update Manifest failed: " + message, "Re-downloading the Manifest fully");
          return startManualRefreshTimer(FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY, minimumManifestUpdateInterval, newSendingTime).pipe(Object(mergeMap["a" /* mergeMap */])(function () {
            return refreshManifest(true);
          }));
        }
      }

      return Object(of["a" /* of */])({
        type: "parsed",
        manifest: manifest,
        sendingTime: newSendingTime,
        receivedTime: receivedTime,
        parsingTime: parsingTime,
        updatingTime: performance.now() - updateTimeStart
      });
    }));
  }
}
/**
 * Launch a timer Observable which will emit when it is time to refresh the
 * Manifest.
 * The timer's delay is calculated from:
 *   - a target delay (`wantedDelay`), which is the minimum time we want to wait
 *     in the best scenario
 *   - the minimum set possible interval between manifest updates
 *     (`minimumManifestUpdateInterval`)
 *   - the time at which was done the last Manifest refresh
 *     (`lastManifestRequestTime`)
 * @param {number} wantedDelay
 * @param {number} minimumManifestUpdateInterval
 * @param {number|undefined} lastManifestRequestTime
 * @returns {Observable}
 */

function startManualRefreshTimer(wantedDelay, minimumManifestUpdateInterval, lastManifestRequestTime) {
  return Object(defer["a" /* defer */])(function () {
    // The value allows to set a delay relatively to the last Manifest refresh
    // (to avoid asking for it too often).
    var timeSinceLastRefresh = lastManifestRequestTime == null ? 0 : performance.now() - lastManifestRequestTime;

    var _minInterval = Math.max(minimumManifestUpdateInterval - timeSinceLastRefresh, 0);

    return Object(timer["a" /* timer */])(Math.max(wantedDelay - timeSinceLastRefresh, _minInterval));
  });
}
// EXTERNAL MODULE: ./src/core/init/throw_on_media_error.ts
var throw_on_media_error = __webpack_require__(126);

// CONCATENATED MODULE: ./src/core/init/initialize_media_source.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



















var OUT_OF_SYNC_MANIFEST_REFRESH_DELAY = config["a" /* default */].OUT_OF_SYNC_MANIFEST_REFRESH_DELAY;
/**
 * Play a content described by the given Manifest.
 *
 * On subscription:
 *   - Creates the MediaSource and attached sourceBuffers instances.
 *   - download the content's Manifest and handle its refresh logic
 *   - Perform EME management if needed
 *   - get Buffers for each active adaptations.
 *   - give choice of the adaptation to the caller (e.g. to choose a language)
 *   - returns Observable emitting notifications about the content lifecycle.
 * @param {Object} args
 * @returns {Observable}
 */

function InitializeOnMediaSource(_ref) {
  var adaptiveOptions = _ref.adaptiveOptions,
      autoPlay = _ref.autoPlay,
      bufferOptions = _ref.bufferOptions,
      clock$ = _ref.clock$,
      keySystems = _ref.keySystems,
      lowLatencyMode = _ref.lowLatencyMode,
      manifestUpdateUrl = _ref.manifestUpdateUrl,
      mediaElement = _ref.mediaElement,
      minimumManifestUpdateInterval = _ref.minimumManifestUpdateInterval,
      networkConfig = _ref.networkConfig,
      speed$ = _ref.speed$,
      startAt = _ref.startAt,
      textTrackOptions = _ref.textTrackOptions,
      transportPipelines = _ref.transportPipelines,
      url = _ref.url;
  var offlineRetry = networkConfig.offlineRetry,
      segmentRetry = networkConfig.segmentRetry,
      manifestRetry = networkConfig.manifestRetry;
  var manifestFetcher = fetchers_manifest(transportPipelines, {
    lowLatencyMode: lowLatencyMode,
    maxRetryRegular: manifestRetry,
    maxRetryOffline: offlineRetry
  });
  /**
   * Fetch and parse the manifest from the URL given.
   * Throttled to avoid doing multiple simultaneous requests.
   */

  var fetchManifest = throttle(function (manifestURL, externalClockOffset) {
    return manifestFetcher.fetch(manifestURL).pipe(Object(mergeMap["a" /* mergeMap */])(function (response) {
      return response.type === "warning" ? Object(of["a" /* of */])(response) : // bubble-up warnings
      response.parse({
        externalClockOffset: externalClockOffset
      });
    }), Object(share["a" /* share */])());
  });
  /** Interface used to download segments. */

  var segmentFetcherCreator = new fetchers_segment(transportPipelines, {
    lowLatencyMode: lowLatencyMode,
    maxRetryOffline: offlineRetry,
    maxRetryRegular: segmentRetry
  });
  /** Choose the right "Representation" for a given "Adaptation". */

  var abrManager = new abr(adaptiveOptions);
  /**
   * Create and open a new MediaSource object on the given media element.
   * The MediaSource will be closed on unsubscription.
   */

  var openMediaSource$ = openMediaSource(mediaElement).pipe(Object(subscribeOn["a" /* subscribeOn */])(asap["a" /* asap */]), // to launch subscriptions only when all
  Object(share["a" /* share */])()); // Observables here are linked

  /** Send content protection data to the `EMEManager`. */

  var protectedSegments$ = new Subject["a" /* Subject */]();
  /** Create `EMEManager`, an observable which will handle content DRM. */

  var emeManager$ = openMediaSource$.pipe(Object(mergeMap["a" /* mergeMap */])(function () {
    return Object(create_eme_manager["a" /* default */])(mediaElement, keySystems, protectedSegments$);
  }), Object(subscribeOn["a" /* subscribeOn */])(asap["a" /* asap */]), // to launch subscriptions only when all
  Object(share["a" /* share */])()); // Observables here are linked

  /**
   * Translate errors coming from the media element into RxPlayer errors
   * through a throwing Observable.
   */

  var mediaError$ = Object(throw_on_media_error["a" /* default */])(mediaElement);
  /**
   * Emit when EME negociations that should happen before pushing any content
   * have finished.
   */

  var waitForEMEReady$ = emeManager$.pipe(Object(filter["a" /* filter */])(is_eme_ready["a" /* default */]), Object(take["a" /* take */])(1));
  /** Do the first Manifest request. */

  var initialManifestRequest$ = fetchManifest(url, undefined).pipe(Object(subscribeOn["a" /* subscribeOn */])(asap["a" /* asap */]), // to launch subscriptions only when all
  Object(share["a" /* share */])()); // Observables here are linked

  var initialManifestRequestWarnings$ = initialManifestRequest$.pipe(Object(filter["a" /* filter */])(function (evt) {
    return evt.type === "warning";
  }));
  var initialManifest$ = initialManifestRequest$.pipe(Object(filter["a" /* filter */])(function (evt) {
    return evt.type === "parsed";
  }));
  /** Load and play the content asked. */

  var loadContent$ = Object(combineLatest["a" /* combineLatest */])([initialManifest$, openMediaSource$, waitForEMEReady$]).pipe(Object(mergeMap["a" /* mergeMap */])(function (_ref2) {
    var parsedManifest = _ref2[0],
        initialMediaSource = _ref2[1];
    var manifest = parsedManifest.manifest;
    log["a" /* default */].debug("Init: Calculating initial time");
    var initialTime = getInitialTime(manifest, lowLatencyMode, startAt);
    log["a" /* default */].debug("Init: Initial time calculated:", initialTime);
    var mediaSourceLoader = createMediaSourceLoader({
      abrManager: abrManager,
      bufferOptions: Object(object_assign["a" /* default */])({
        textTrackOptions: textTrackOptions
      }, bufferOptions),
      clock$: clock$,
      manifest: manifest,
      mediaElement: mediaElement,
      segmentFetcherCreator: segmentFetcherCreator,
      speed$: speed$
    }); // handle initial load and reloads

    var recursiveLoad$ = recursivelyLoadOnMediaSource(initialMediaSource, initialTime, autoPlay); // Emit when we want to manually update the manifest.

    var scheduleRefresh$ = new Subject["a" /* Subject */]();
    var manifestUpdate$ = manifestUpdateScheduler({
      fetchManifest: fetchManifest,
      initialManifest: parsedManifest,
      manifestUpdateUrl: manifestUpdateUrl,
      minimumManifestUpdateInterval: minimumManifestUpdateInterval,
      scheduleRefresh$: scheduleRefresh$
    });
    var manifestEvents$ = Object(merge["a" /* merge */])(Object(event_emitter["b" /* fromEvent */])(manifest, "manifestUpdate").pipe(Object(mapTo["a" /* mapTo */])(events_generators["a" /* default */].manifestUpdate())), Object(event_emitter["b" /* fromEvent */])(manifest, "decipherabilityUpdate").pipe(Object(map["a" /* map */])(events_generators["a" /* default */].decipherabilityUpdate)));
    var setUndecipherableRepresentations$ = emeManager$.pipe(Object(tap["a" /* tap */])(function (evt) {
      if (evt.type === "blacklist-keys") {
        log["a" /* default */].info("Init: blacklisting Representations based on keyIDs");
        manifest.addUndecipherableKIDs(evt.value);
      } else if (evt.type === "blacklist-protection-data") {
        log["a" /* default */].info("Init: blacklisting Representations based on protection data.");
        manifest.addUndecipherableProtectionData(evt.value.type, evt.value.data);
      }
    }));
    return Object(merge["a" /* merge */])(manifestEvents$, manifestUpdate$, setUndecipherableRepresentations$, recursiveLoad$).pipe(Object(startWith["a" /* startWith */])(events_generators["a" /* default */].manifestReady(manifest)), finalize(function () {
      scheduleRefresh$.complete();
    }));
    /**
     * Load the content defined by the Manifest in the mediaSource given at the
     * given position and playing status.
     * This function recursively re-call itself when a MediaSource reload is
     * wanted.
     * @param {MediaSource} mediaSource
     * @param {number} position
     * @param {boolean} shouldPlay
     * @returns {Observable}
     */

    function recursivelyLoadOnMediaSource(mediaSource, position, shouldPlay) {
      var reloadMediaSource$ = new Subject["a" /* Subject */]();
      var mediaSourceLoader$ = mediaSourceLoader(mediaSource, position, shouldPlay).pipe(Object(tap["a" /* tap */])(function (evt) {
        switch (evt.type) {
          case "needs-manifest-refresh":
            scheduleRefresh$.next({
              completeRefresh: false
            });
            break;

          case "manifest-might-be-out-of-sync":
            scheduleRefresh$.next({
              completeRefresh: true,
              delay: OUT_OF_SYNC_MANIFEST_REFRESH_DELAY
            });
            break;

          case "needs-media-source-reload":
            reloadMediaSource$.next(evt.value);
            break;

          case "needs-decipherability-flush":
            var keySystem = Object(get_current_key_system["a" /* default */])(mediaElement);

            if (Object(should_reload_media_source_on_decipherability_update["a" /* default */])(keySystem)) {
              reloadMediaSource$.next(evt.value);
              return;
            } // simple seek close to the current position to flush the buffers


            var currentTime = evt.value.currentTime;

            if (currentTime + 0.001 < evt.value.duration) {
              mediaElement.currentTime += 0.001;
            } else {
              mediaElement.currentTime = currentTime;
            }

            break;

          case "protected-segment":
            protectedSegments$.next(evt.value);
        }
      }));
      var currentLoad$ = mediaSourceLoader$.pipe(Object(takeUntil["a" /* takeUntil */])(reloadMediaSource$));
      var handleReloads$ = reloadMediaSource$.pipe(Object(switchMap["a" /* switchMap */])(function (_ref3) {
        var currentTime = _ref3.currentTime,
            isPaused = _ref3.isPaused;
        return openMediaSource(mediaElement).pipe(Object(mergeMap["a" /* mergeMap */])(function (newMS) {
          return recursivelyLoadOnMediaSource(newMS, currentTime, !isPaused);
        }), Object(startWith["a" /* startWith */])(events_generators["a" /* default */].reloadingMediaSource()));
      }));
      return Object(merge["a" /* merge */])(handleReloads$, currentLoad$);
    }
  }));
  return Object(merge["a" /* merge */])(initialManifestRequestWarnings$, loadContent$, mediaError$, emeManager$);
}
// CONCATENATED MODULE: ./src/core/init/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var init = (InitializeOnMediaSource);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/refCount.js
var refCount = __webpack_require__(125);

// CONCATENATED MODULE: ./src/core/api/clock.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file defines a global clock for the RxPlayer.
 *
 * Each clock tick also pass information about the current state of the
 * media element to sub-parts of the player.
 */






var SAMPLING_INTERVAL_MEDIASOURCE = config["a" /* default */].SAMPLING_INTERVAL_MEDIASOURCE,
    SAMPLING_INTERVAL_LOW_LATENCY = config["a" /* default */].SAMPLING_INTERVAL_LOW_LATENCY,
    SAMPLING_INTERVAL_NO_MEDIASOURCE = config["a" /* default */].SAMPLING_INTERVAL_NO_MEDIASOURCE,
    RESUME_GAP_AFTER_SEEKING = config["a" /* default */].RESUME_GAP_AFTER_SEEKING,
    RESUME_GAP_AFTER_NOT_ENOUGH_DATA = config["a" /* default */].RESUME_GAP_AFTER_NOT_ENOUGH_DATA,
    RESUME_GAP_AFTER_BUFFERING = config["a" /* default */].RESUME_GAP_AFTER_BUFFERING,
    STALL_GAP = config["a" /* default */].STALL_GAP;
/**
 * HTMLMediaElement Events for which timings are calculated and emitted.
 * @type {Array.<string>}
 */

var SCANNED_MEDIA_ELEMENTS_EVENTS = ["canplay", "play", "progress", "seeking", "seeked", "loadedmetadata", "ratechange"];
/**
 * Returns the amount of time in seconds the buffer should have ahead of the
 * current position before resuming playback. Based on the infos of the stall.
 * Waiting time differs between a "seeking" stall and a buffering stall.
 * @param {Object|null} stalled
 * @param {Boolean} lowLatencyMode
 * @returns {Number}
 */

function getResumeGap(stalled, lowLatencyMode) {
  if (stalled === null) {
    return 0;
  }

  var suffix = lowLatencyMode ? "LOW_LATENCY" : "DEFAULT";

  switch (stalled.reason) {
    case "seeking":
      return RESUME_GAP_AFTER_SEEKING[suffix];

    case "not-ready":
      return RESUME_GAP_AFTER_NOT_ENOUGH_DATA[suffix];

    default:
      return RESUME_GAP_AFTER_BUFFERING[suffix];
  }
}
/**
 * @param {Object} currentRange
 * @param {Number} duration
 * @param {Boolean} lowLatencyMode
 * @returns {Boolean}
 */


function hasLoadedUntilTheEnd(currentRange, duration, lowLatencyMode) {
  var suffix = lowLatencyMode ? "LOW_LATENCY" : "DEFAULT";
  return currentRange !== null && duration - currentRange.end <= STALL_GAP[suffix];
}
/**
 * Generate a basic timings object from the media element and the eventName
 * which triggered the request.
 * @param {HTMLMediaElement} mediaElement
 * @param {string} currentState
 * @returns {Object}
 */


function getMediaInfos(mediaElement, currentState) {
  var buffered = mediaElement.buffered,
      currentTime = mediaElement.currentTime,
      duration = mediaElement.duration,
      ended = mediaElement.ended,
      paused = mediaElement.paused,
      playbackRate = mediaElement.playbackRate,
      readyState = mediaElement.readyState,
      seeking = mediaElement.seeking;
  return {
    bufferGap: Object(ranges["d" /* getLeftSizeOfRange */])(buffered, currentTime),
    buffered: buffered,
    currentRange: Object(ranges["g" /* getRange */])(buffered, currentTime),
    currentTime: currentTime,
    duration: duration,
    ended: ended,
    paused: paused,
    playbackRate: playbackRate,
    readyState: readyState,
    seeking: seeking,
    state: currentState
  };
}
/**
 * Infer stalled status of the media based on:
 *   - the return of the function getMediaInfos
 *   - the previous timings object.
 *
 * @param {Object} prevTimings - Previous timings object. See function to know
 * the different properties needed.
 * @param {Object} currentTimings - Current timings object. This does not need
 * to have every single infos, see function to know which properties are needed.
 * @param {Object} options
 * @returns {Object|null}
 */


function getStalledStatus(prevTimings, currentTimings, _ref) {
  var withMediaSource = _ref.withMediaSource,
      lowLatencyMode = _ref.lowLatencyMode;
  var currentState = currentTimings.state,
      currentTime = currentTimings.currentTime,
      bufferGap = currentTimings.bufferGap,
      currentRange = currentTimings.currentRange,
      duration = currentTimings.duration,
      paused = currentTimings.paused,
      readyState = currentTimings.readyState,
      ended = currentTimings.ended;
  var prevStalled = prevTimings.stalled,
      prevState = prevTimings.state,
      prevTime = prevTimings.currentTime;
  var fullyLoaded = hasLoadedUntilTheEnd(currentRange, duration, lowLatencyMode);
  var canStall = readyState >= 1 && currentState !== "loadedmetadata" && prevStalled === null && !(fullyLoaded || ended);
  var shouldStall;
  var shouldUnstall;

  if (withMediaSource) {
    if (canStall && (bufferGap <= (lowLatencyMode ? STALL_GAP.LOW_LATENCY : STALL_GAP.DEFAULT) || bufferGap === Infinity || readyState === 1)) {
      shouldStall = true;
    } else if (prevStalled !== null && readyState > 1 && (bufferGap < Infinity && bufferGap > getResumeGap(prevStalled, lowLatencyMode) || fullyLoaded || ended)) {
      shouldUnstall = true;
    }
  } // when using a direct file, the media will stall and unstall on its
  // own, so we only try to detect when the media timestamp has not changed
  // between two consecutive timeupdates
  else {
      if (canStall && (!paused && currentState === "timeupdate" && prevState === "timeupdate" && currentTime === prevTime || currentState === "seeking" && bufferGap === Infinity)) {
        shouldStall = true;
      } else if (prevStalled !== null && (currentState !== "seeking" && currentTime !== prevTime || currentState === "canplay" || bufferGap < Infinity && (bufferGap > getResumeGap(prevStalled, lowLatencyMode) || fullyLoaded || ended))) {
        shouldUnstall = true;
      }
    }

  if (shouldUnstall === true) {
    return null;
  } else if (shouldStall === true || prevStalled !== null) {
    var reason;

    if (currentState === "seeking" || currentTimings.seeking || prevStalled !== null && prevStalled.reason === "seeking") {
      reason = "seeking";
    } else if (readyState === 1) {
      reason = "not-ready";
    } else {
      reason = "buffering";
    }

    if (prevStalled !== null && prevStalled.reason === reason) {
      return prevStalled;
    }

    return {
      reason: reason,
      timestamp: performance.now()
    };
  }

  return null;
}
/**
 * Timings observable.
 *
 * This Observable samples snapshots of player's current state:
 *   * time position
 *   * playback rate
 *   * current buffered range
 *   * gap with current buffered range ending
 *   * media duration
 *
 * In addition to sampling, this Observable also reacts to "seeking" and "play"
 * events.
 *
 * Observable is shared for performance reason: reduces the number of event
 * listeners and intervals/timeouts but also limit access to the media element
 * properties and gap calculations.
 *
 * The sampling is manual instead of based on "timeupdate" to reduce the
 * number of events.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} options
 * @returns {Observable}
 */


function createClock(mediaElement, options) {
  return Object(defer["a" /* defer */])(function () {
    var lastTimings = Object(object_assign["a" /* default */])(getMediaInfos(mediaElement, "init"), {
      stalled: null
    });

    function getCurrentClockTick(state) {
      var mediaTimings = getMediaInfos(mediaElement, state);
      var stalledState = getStalledStatus(lastTimings, mediaTimings, options); // /!\ Mutate mediaTimings

      return Object(object_assign["a" /* default */])(mediaTimings, {
        stalled: stalledState
      });
    }

    var eventObs = SCANNED_MEDIA_ELEMENTS_EVENTS.map(function (eventName) {
      return Object(fromEvent["a" /* fromEvent */])(mediaElement, eventName).pipe(Object(mapTo["a" /* mapTo */])(eventName));
    });
    var interval = options.lowLatencyMode ? SAMPLING_INTERVAL_LOW_LATENCY : options.withMediaSource ? SAMPLING_INTERVAL_MEDIASOURCE : SAMPLING_INTERVAL_NO_MEDIASOURCE;
    var interval$ = Object(observable_interval["a" /* interval */])(interval).pipe(Object(mapTo["a" /* mapTo */])("timeupdate"));
    return merge["a" /* merge */].apply(void 0, [interval$].concat(eventObs)).pipe(Object(map["a" /* map */])(function (state) {
      lastTimings = getCurrentClockTick(state);
      log["a" /* default */].debug("API: new clock tick", lastTimings);
      return lastTimings;
    }), Object(startWith["a" /* startWith */])(lastTimings));
  }).pipe(Object(multicast["a" /* multicast */])(function () {
    return new ReplaySubject["a" /* ReplaySubject */](1);
  }), // Always emit the last
  Object(refCount["a" /* refCount */])());
}

/* harmony default export */ var api_clock = (createClock);
// CONCATENATED MODULE: ./src/core/api/emit_seek_events.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns Observable which will emit:
 *   - `"seeking"` when we are seeking in the given mediaElement
 *   - `"seeked"` when a seek is considered as finished by the given clock$
 *     Observable.
 * @param {HTMLMediaElement} mediaElement
 * @param {Observable} clock$
 * @returns {Observable}
 */

function emitSeekEvents(mediaElement, clock$) {
  return Object(defer["a" /* defer */])(function () {
    if (mediaElement === null) {
      return empty["a" /* EMPTY */];
    }

    var isSeeking$ = Object(fromEvent["a" /* fromEvent */])(mediaElement, "seeking").pipe(Object(mapTo["a" /* mapTo */])("seeking"));
    var hasSeeked$ = Object(fromEvent["a" /* fromEvent */])(mediaElement, "seeked").pipe(Object(switchMapTo["a" /* switchMapTo */])(clock$.pipe(Object(mergeMap["a" /* mergeMap */])(function (tick) {
      return tick.stalled === null || tick.stalled.reason !== "seeking" ? Object(of["a" /* of */])("seeked") : empty["a" /* EMPTY */];
    }), Object(take["a" /* take */])(1))));
    var seekingEvents$ = Object(merge["a" /* merge */])(isSeeking$, hasSeeked$);
    return mediaElement.seeking ? seekingEvents$.pipe(Object(startWith["a" /* startWith */])("seeking")) : seekingEvents$;
  });
}
// CONCATENATED MODULE: ./src/core/api/get_player_state.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var FORCED_ENDED_THRESHOLD = config["a" /* default */].FORCED_ENDED_THRESHOLD;
/** Player state dictionnary. */

var PLAYER_STATES = {
  STOPPED: "STOPPED",
  LOADED: "LOADED",
  LOADING: "LOADING",
  PLAYING: "PLAYING",
  PAUSED: "PAUSED",
  ENDED: "ENDED",
  BUFFERING: "BUFFERING",
  SEEKING: "SEEKING",
  RELOADING: "RELOADING"
};
/**
 * Get state string for a _loaded_ content.
 * @param {HTMLMediaElement} mediaElement
 * @param {boolean} isPlaying - false when the player is paused. true otherwise.
 * @param {Object} stalledStatus - Current stalled state:
 *   - null when not stalled
 *   - an object with a description of the situation if stalled.
 * @returns {string}
 */

function getLoadedContentState(mediaElement, isPlaying, stalledStatus) {
  if (mediaElement.ended) {
    return PLAYER_STATES.ENDED;
  }

  if (stalledStatus !== null) {
    // On some old browsers (e.g. Chrome 54), the browser does not
    // emit an 'ended' event in some conditions. Detect if we
    // reached the end by comparing the current position and the
    // duration instead.
    var gapBetweenDurationAndCurrentTime = Math.abs(mediaElement.duration - mediaElement.currentTime);

    if (FORCED_ENDED_THRESHOLD != null && gapBetweenDurationAndCurrentTime < FORCED_ENDED_THRESHOLD) {
      return PLAYER_STATES.ENDED;
    }

    return stalledStatus.reason === "seeking" ? PLAYER_STATES.SEEKING : PLAYER_STATES.BUFFERING;
  }

  return isPlaying ? PLAYER_STATES.PLAYING : PLAYER_STATES.PAUSED;
}
// EXTERNAL MODULE: ./src/utils/languages/normalize.ts + 2 modules
var normalize = __webpack_require__(97);

// CONCATENATED MODULE: ./src/core/api/option_parsers.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file exports various helpers to parse options given to various APIs,
 * throw if something is wrong, and return a normalized option object.
 */





var DEFAULT_AUTO_PLAY = config["a" /* default */].DEFAULT_AUTO_PLAY,
    DEFAULT_INITIAL_BITRATES = config["a" /* default */].DEFAULT_INITIAL_BITRATES,
    DEFAULT_LIMIT_VIDEO_WIDTH = config["a" /* default */].DEFAULT_LIMIT_VIDEO_WIDTH,
    DEFAULT_MANUAL_BITRATE_SWITCHING_MODE = config["a" /* default */].DEFAULT_MANUAL_BITRATE_SWITCHING_MODE,
    DEFAULT_MAX_BITRATES = config["a" /* default */].DEFAULT_MAX_BITRATES,
    DEFAULT_MAX_BUFFER_AHEAD = config["a" /* default */].DEFAULT_MAX_BUFFER_AHEAD,
    DEFAULT_MAX_BUFFER_BEHIND = config["a" /* default */].DEFAULT_MAX_BUFFER_BEHIND,
    DEFAULT_SHOW_NATIVE_SUBTITLE = config["a" /* default */].DEFAULT_SHOW_NATIVE_SUBTITLE,
    DEFAULT_STOP_AT_END = config["a" /* default */].DEFAULT_STOP_AT_END,
    DEFAULT_TEXT_TRACK_MODE = config["a" /* default */].DEFAULT_TEXT_TRACK_MODE,
    DEFAULT_THROTTLE_WHEN_HIDDEN = config["a" /* default */].DEFAULT_THROTTLE_WHEN_HIDDEN,
    DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN = config["a" /* default */].DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN,
    DEFAULT_WANTED_BUFFER_AHEAD = config["a" /* default */].DEFAULT_WANTED_BUFFER_AHEAD;
/**
 * Parse options given to the API constructor and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 * @param {Object|undefined} options
 * @returns {Object}
 */

function parseConstructorOptions(options) {
  var maxBufferAhead;
  var maxBufferBehind;
  var wantedBufferAhead;
  var limitVideoWidth;
  var throttleWhenHidden;
  var throttleVideoBitrateWhenHidden;
  var preferredAudioTracks;
  var preferredTextTracks;
  var videoElement;
  var initialVideoBitrate;
  var initialAudioBitrate;
  var maxAudioBitrate;
  var maxVideoBitrate;
  var stopAtEnd;

  if (options.maxBufferAhead == null) {
    maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD;
  } else {
    maxBufferAhead = Number(options.maxBufferAhead);

    if (isNaN(maxBufferAhead)) {
      throw new Error("Invalid maxBufferAhead parameter. Should be a number.");
    }
  }

  if (options.maxBufferBehind == null) {
    maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND;
  } else {
    maxBufferBehind = Number(options.maxBufferBehind);

    if (isNaN(maxBufferBehind)) {
      throw new Error("Invalid maxBufferBehind parameter. Should be a number.");
    }
  }

  if (options.wantedBufferAhead == null) {
    wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD;
  } else {
    wantedBufferAhead = Number(options.wantedBufferAhead);

    if (isNaN(wantedBufferAhead)) {
      /* tslint:disable:max-line-length */
      throw new Error("Invalid wantedBufferAhead parameter. Should be a number.");
      /* tslint:enable:max-line-length */
    }
  }

  limitVideoWidth = options.limitVideoWidth == null ? DEFAULT_LIMIT_VIDEO_WIDTH : !!options.limitVideoWidth;

  if (options.throttleWhenHidden != null) {
    Object(warn_once["a" /* default */])("`throttleWhenHidden` API is deprecated. Consider using " + "`throttleVideoBitrateWhenHidden` instead.");
    throttleWhenHidden = !!options.throttleWhenHidden;
  } else {
    throttleWhenHidden = DEFAULT_THROTTLE_WHEN_HIDDEN;
  } // `throttleWhenHidden` and `throttleVideoBitrateWhenHidden` can be in conflict
  // Do not activate the latter if the former is


  if (throttleWhenHidden) {
    throttleVideoBitrateWhenHidden = false;
  } else {
    throttleVideoBitrateWhenHidden = options.throttleVideoBitrateWhenHidden == null ? DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN : !!options.throttleVideoBitrateWhenHidden;
  }

  if (options.preferredTextTracks !== undefined) {
    if (!Array.isArray(options.preferredTextTracks)) {
      Object(warn_once["a" /* default */])("Invalid `preferredTextTracks` option, it should be an Array");
      preferredTextTracks = [];
    } else {
      preferredTextTracks = options.preferredTextTracks;
    }
  } else {
    preferredTextTracks = [];
  }

  if (options.preferredAudioTracks !== undefined) {
    if (!Array.isArray(options.preferredAudioTracks)) {
      Object(warn_once["a" /* default */])("Invalid `preferredAudioTracks` option, it should be an Array");
      preferredAudioTracks = [];
    } else {
      preferredAudioTracks = options.preferredAudioTracks;
    }
  } else {
    preferredAudioTracks = [];
  }

  if (options.videoElement == null) {
    videoElement = document.createElement("video");
  } else if (options.videoElement instanceof HTMLMediaElement) {
    videoElement = options.videoElement;
  } else {
    /* tslint:disable:max-line-length */
    throw new Error("Invalid videoElement parameter. Should be a HTMLMediaElement.");
    /* tslint:enable:max-line-length */
  }

  if (options.initialVideoBitrate == null) {
    initialVideoBitrate = DEFAULT_INITIAL_BITRATES.video;
  } else {
    initialVideoBitrate = Number(options.initialVideoBitrate);

    if (isNaN(initialVideoBitrate)) {
      /* tslint:disable:max-line-length */
      throw new Error("Invalid initialVideoBitrate parameter. Should be a number.");
      /* tslint:enable:max-line-length */
    }
  }

  if (options.initialAudioBitrate == null) {
    initialAudioBitrate = DEFAULT_INITIAL_BITRATES.audio;
  } else {
    initialAudioBitrate = Number(options.initialAudioBitrate);

    if (isNaN(initialAudioBitrate)) {
      /* tslint:disable:max-line-length */
      throw new Error("Invalid initialAudioBitrate parameter. Should be a number.");
      /* tslint:enable:max-line-length */
    }
  }

  if (options.maxVideoBitrate == null) {
    maxVideoBitrate = DEFAULT_MAX_BITRATES.video;
  } else {
    maxVideoBitrate = Number(options.maxVideoBitrate);

    if (isNaN(maxVideoBitrate)) {
      throw new Error("Invalid maxVideoBitrate parameter. Should be a number.");
    }
  }

  if (options.maxAudioBitrate == null) {
    maxAudioBitrate = DEFAULT_MAX_BITRATES.audio;
  } else {
    maxAudioBitrate = Number(options.maxAudioBitrate);

    if (isNaN(maxAudioBitrate)) {
      throw new Error("Invalid maxAudioBitrate parameter. Should be a number.");
    }
  }

  stopAtEnd = options.stopAtEnd == null ? DEFAULT_STOP_AT_END : !!options.stopAtEnd;
  return {
    maxBufferAhead: maxBufferAhead,
    maxBufferBehind: maxBufferBehind,
    limitVideoWidth: limitVideoWidth,
    videoElement: videoElement,
    wantedBufferAhead: wantedBufferAhead,
    throttleWhenHidden: throttleWhenHidden,
    throttleVideoBitrateWhenHidden: throttleVideoBitrateWhenHidden,
    preferredAudioTracks: preferredAudioTracks,
    preferredTextTracks: preferredTextTracks,
    initialAudioBitrate: initialAudioBitrate,
    initialVideoBitrate: initialVideoBitrate,
    maxAudioBitrate: maxAudioBitrate,
    maxVideoBitrate: maxVideoBitrate,
    stopAtEnd: stopAtEnd
  };
}
/**
 * Parse options given to loadVideo and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 *
 * Throws if any mandatory option is not set.
 * @param {Object|undefined} options
 * @param {Object} ctx - The player context, needed for some default values.
 * @returns {Object}
 */


function parseLoadVideoOptions(options) {
  var _a, _b, _c;

  var url;
  var transport;
  var keySystems;
  var textTrackMode;
  var textTrackElement;
  var startAt;

  if (options == null) {
    throw new Error("No option set on loadVideo");
  }

  if (options.url != null) {
    url = String(options.url);
  } else if (options.transportOptions == null || options.transportOptions.manifestLoader == null) {
    throw new Error("No url set on loadVideo");
  }

  if (options.transport == null) {
    throw new Error("No transport set on loadVideo");
  } else {
    transport = String(options.transport);
  }

  var autoPlay = options.autoPlay == null ? DEFAULT_AUTO_PLAY : !!options.autoPlay;

  if (options.keySystems == null) {
    keySystems = [];
  } else {
    keySystems = Array.isArray(options.keySystems) ? options.keySystems : [options.keySystems];

    for (var _iterator = keySystems, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var keySystem = _ref;

      if (typeof keySystem.type !== "string" || typeof keySystem.getLicense !== "function") {
        throw new Error("Invalid key system given: Missing type string or " + "getLicense callback");
      }
    }
  }

  var lowLatencyMode = options.lowLatencyMode === undefined ? false : !!options.lowLatencyMode;
  var transportOptsArg = typeof options.transportOptions === "object" && options.transportOptions !== null ? options.transportOptions : {};
  var transportOptions = {
    aggressiveMode: transportOptsArg.aggressiveMode,
    checkMediaSegmentIntegrity: transportOptsArg.checkMediaSegmentIntegrity,
    lowLatencyMode: lowLatencyMode,
    manifestLoader: transportOptsArg.manifestLoader,
    referenceDateTime: transportOptsArg.referenceDateTime,
    representationFilter: transportOptsArg.representationFilter,
    segmentLoader: transportOptsArg.segmentLoader,
    serverSyncInfos: transportOptsArg.serverSyncInfos,
    supplementaryImageTracks: [],
    supplementaryTextTracks: []
  };

  if (options.supplementaryTextTracks !== undefined) {
    Object(warn_once["a" /* default */])("The `supplementaryTextTracks` loadVideo option is deprecated.\n" + "Please use the `TextTrackRenderer` tool instead.");
    var supplementaryTextTracks = Array.isArray(options.supplementaryTextTracks) ? options.supplementaryTextTracks : [options.supplementaryTextTracks];

    for (var _iterator2 = supplementaryTextTracks, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var supplementaryTextTrack = _ref2;

      if (typeof supplementaryTextTrack.language !== "string" || typeof supplementaryTextTrack.mimeType !== "string" || typeof supplementaryTextTrack.url !== "string") {
        throw new Error("Invalid supplementary text track given. " + "Missing either language, mimetype or url");
      }
    }

    transportOptions.supplementaryTextTracks = supplementaryTextTracks;
  }

  if (options.supplementaryImageTracks !== undefined) {
    Object(warn_once["a" /* default */])("The `supplementaryImageTracks` loadVideo option is deprecated.\n" + "Please use the `parseBifThumbnails` tool instead.");
    var supplementaryImageTracks = Array.isArray(options.supplementaryImageTracks) ? options.supplementaryImageTracks : [options.supplementaryImageTracks];

    for (var _iterator3 = supplementaryImageTracks, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var supplementaryImageTrack = _ref3;

      if (typeof supplementaryImageTrack.mimeType !== "string" || typeof supplementaryImageTrack.url !== "string") {
        throw new Error("Invalid supplementary image track given. " + "Missing either mimetype or url");
      }
    }

    transportOptions.supplementaryImageTracks = supplementaryImageTracks;
  }

  if (options.textTrackMode == null) {
    textTrackMode = DEFAULT_TEXT_TRACK_MODE;
  } else {
    if (options.textTrackMode !== "native" && options.textTrackMode !== "html") {
      throw new Error("Invalid textTrackMode.");
    }

    textTrackMode = options.textTrackMode;
  }

  if (options.defaultAudioTrack != null) {
    Object(warn_once["a" /* default */])("The `defaultAudioTrack` loadVideo option is deprecated.\n" + "Please use the `preferredAudioTracks` constructor option or the" + "`setPreferredAudioTracks` method instead");
  }

  var defaultAudioTrack = Object(normalize["b" /* normalizeAudioTrack */])(options.defaultAudioTrack);

  if (options.defaultTextTrack != null) {
    Object(warn_once["a" /* default */])("The `defaultTextTrack` loadVideo option is deprecated.\n" + "Please use the `preferredTextTracks` constructor option or the" + "`setPreferredTextTracks` method instead");
  }

  var defaultTextTrack = Object(normalize["c" /* normalizeTextTrack */])(options.defaultTextTrack);
  var hideNativeSubtitle = !DEFAULT_SHOW_NATIVE_SUBTITLE;

  if (options.hideNativeSubtitle != null) {
    Object(warn_once["a" /* default */])("The `hideNativeSubtitle` loadVideo option is deprecated");
    hideNativeSubtitle = !!options.hideNativeSubtitle;
  }

  var manualBitrateSwitchingMode = options.manualBitrateSwitchingMode == null ? DEFAULT_MANUAL_BITRATE_SWITCHING_MODE : options.manualBitrateSwitchingMode;

  if (textTrackMode === "html") {
    // TODO Better way to express that in TypeScript?
    if (options.textTrackElement == null) {
      throw new Error("You have to provide a textTrackElement " + "in \"html\" textTrackMode.");
    } else if (!(options.textTrackElement instanceof HTMLElement)) {
      throw new Error("textTrackElement should be an HTMLElement.");
    } else {
      textTrackElement = options.textTrackElement;
    }
  } else if (options.textTrackElement != null) {
    log["a" /* default */].warn("API: You have set a textTrackElement without being in " + "an \"html\" textTrackMode. It will be ignored.");
  }

  if (options.startAt != null) {
    // TODO Better way to express that in TypeScript?
    if (options.startAt.wallClockTime instanceof Date) {
      var wallClockTime = options.startAt.wallClockTime.getTime() / 1000;
      startAt = Object(object_assign["a" /* default */])({}, options.startAt, {
        wallClockTime: wallClockTime
      });
    } else {
      startAt = options.startAt;
    }
  }

  var manifestUpdateUrl = (_a = options.transportOptions) === null || _a === void 0 ? void 0 : _a.manifestUpdateUrl;
  var minimumManifestUpdateInterval = (_c = (_b = options.transportOptions) === null || _b === void 0 ? void 0 : _b.minimumManifestUpdateInterval) !== null && _c !== void 0 ? _c : 0;
  var networkConfig = options.networkConfig == null ? {} : {
    manifestRetry: options.networkConfig.manifestRetry,
    offlineRetry: options.networkConfig.offlineRetry,
    segmentRetry: options.networkConfig.segmentRetry
  }; // TODO without cast

  /* tslint:disable no-object-literal-type-assertion */

  return {
    autoPlay: autoPlay,
    defaultAudioTrack: defaultAudioTrack,
    defaultTextTrack: defaultTextTrack,
    hideNativeSubtitle: hideNativeSubtitle,
    keySystems: keySystems,
    lowLatencyMode: lowLatencyMode,
    manualBitrateSwitchingMode: manualBitrateSwitchingMode,
    manifestUpdateUrl: manifestUpdateUrl,
    minimumManifestUpdateInterval: minimumManifestUpdateInterval,
    networkConfig: networkConfig,
    startAt: startAt,
    textTrackElement: textTrackElement,
    textTrackMode: textTrackMode,
    transport: transport,
    transportOptions: transportOptions,
    url: url
  };
  /* tslint:enable no-object-literal-type-assertion */
}


// EXTERNAL MODULE: ./src/utils/languages/index.ts
var languages = __webpack_require__(50);

// CONCATENATED MODULE: ./src/core/api/track_choice_manager.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Transform an array of IAudioTrackPreference into an array of
 * INormalizedPreferredAudioTrack to be exploited by the TrackChoiceManager.
 * @param {Array.<Object|null>}
 * @returns {Array.<Object|null>}
 */

function normalizeAudioTracks(tracks) {
  return tracks.map(function (t) {
    return t == null ? t : {
      normalized: Object(languages["a" /* default */])(t.language),
      audioDescription: t.audioDescription
    };
  });
}
/**
 * Transform an array of ITextTrackPreference into an array of
 * INormalizedPreferredTextTrack to be exploited by the TrackChoiceManager.
 * @param {Array.<Object|null>} tracks
 * @returns {Array.<Object|null>}
 */


function normalizeTextTracks(tracks) {
  return tracks.map(function (t) {
    return t == null ? t : {
      normalized: Object(languages["a" /* default */])(t.language),
      closedCaption: t.closedCaption
    };
  });
}
/**
 * Manage audio and text tracks for all active periods.
 * Chose the audio and text tracks for each period and record this choice.
 * @class TrackChoiceManager
 */


var track_choice_manager_TrackChoiceManager = /*#__PURE__*/function () {
  /**
   * @param {BehaviorSubject<Array.<Object|null>>} preferredAudioTracks - Array
   * of audio track preferences
   * @param {BehaviorSubject<Array.<Object|null>>} preferredAudioTracks - Array
   * of text track preferences
   */
  function TrackChoiceManager(defaults) {
    var preferredAudioTracks = defaults.preferredAudioTracks,
        preferredTextTracks = defaults.preferredTextTracks;
    this._periods = new sorted_list_SortedList(function (a, b) {
      return a.period.start - b.period.start;
    });
    this._audioChoiceMemory = new WeakMap();
    this._textChoiceMemory = new WeakMap();
    this._videoChoiceMemory = new WeakMap();
    this._preferredAudioTracks = preferredAudioTracks;
    this._preferredTextTracks = preferredTextTracks;
  }
  /**
   * Add Subject to choose Adaptation for new "audio" or "text" Period.
   * @param {string} bufferType - The concerned buffer type
   * @param {Period} period - The concerned Period.
   * @param {Subject.<Object|null>} adaptation$ - A subject through which the
   * choice will be given
   */


  var _proto = TrackChoiceManager.prototype;

  _proto.addPeriod = function addPeriod(bufferType, period, adaptation$) {
    var periodItem = getPeriodItem(this._periods, period);
    var adaptations = period.adaptations[bufferType];

    if (adaptations == null) {
      adaptations = [];
    }

    if (periodItem != null) {
      if (periodItem[bufferType] != null) {
        log["a" /* default */].warn("TrackChoiceManager: " + bufferType + " already added for period", period);
        return;
      } else {
        periodItem[bufferType] = {
          adaptations: adaptations,
          adaptation$: adaptation$
        };
      }
    } else {
      var _this$_periods$add;

      this._periods.add((_this$_periods$add = {
        period: period
      }, _this$_periods$add[bufferType] = {
        adaptations: adaptations,
        adaptation$: adaptation$
      }, _this$_periods$add));
    }
  }
  /**
   * Remove Subject to choose an "audio", "video" or "text" Adaptation for a
   * Period.
   * @param {string} bufferType - The concerned buffer type
   * @param {Period} period - The concerned Period.
   */
  ;

  _proto.removePeriod = function removePeriod(bufferType, period) {
    var periodIndex = findPeriodIndex(this._periods, period);

    if (periodIndex == null) {
      log["a" /* default */].warn("TrackChoiceManager: " + bufferType + " not found for period", period);
      return;
    }

    var periodItem = this._periods.get(periodIndex);

    if (periodItem[bufferType] == null) {
      log["a" /* default */].warn("TrackChoiceManager: " + bufferType + " already removed for period", period);
      return;
    }

    delete periodItem[bufferType];

    if (periodItem.audio == null && periodItem.text == null && periodItem.video == null) {
      this._periods.removeElement(periodItem);
    }
  };

  _proto.resetPeriods = function resetPeriods() {
    while (this._periods.length() > 0) {
      this._periods.pop();
    }
  }
  /**
   * Update the choice of all added Periods based on:
   *   1. What was the last chosen adaptation
   *   2. If not found, the preferences
   */
  ;

  _proto.update = function update() {
    this._updateAudioTrackChoices();

    this._updateTextTrackChoices();

    this._updateVideoTrackChoices();
  }
  /**
   * Emit initial audio Adaptation through the given Subject based on:
   *   - the preferred audio tracks
   *   - the last choice for this period, if one
   * @param {Period} period - The concerned Period.
   */
  ;

  _proto.setInitialAudioTrack = function setInitialAudioTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var audioInfos = periodItem != null ? periodItem.audio : null;

    if (audioInfos == null || periodItem == null) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }

    var preferredAudioTracks = this._preferredAudioTracks.getValue();

    var audioAdaptations = period.adaptations.audio === undefined ? [] : period.adaptations.audio;

    var chosenAudioAdaptation = this._audioChoiceMemory.get(period);

    if (chosenAudioAdaptation === null) {
      // If the Period was previously without audio, keep it that way
      audioInfos.adaptation$.next(null);
    } else if (chosenAudioAdaptation === undefined || !Object(array_includes["a" /* default */])(audioAdaptations, chosenAudioAdaptation)) {
      // Find the optimal audio Adaptation
      var normalizedPref = normalizeAudioTracks(preferredAudioTracks);
      var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, normalizedPref);

      this._audioChoiceMemory.set(period, optimalAdaptation);

      audioInfos.adaptation$.next(optimalAdaptation);
    } else {
      audioInfos.adaptation$.next(chosenAudioAdaptation); // set last one
    }
  }
  /**
   * Emit initial text Adaptation through the given Subject based on:
   *   - the preferred text tracks
   *   - the last choice for this period, if one
   * @param {Period} period - The concerned Period.
   */
  ;

  _proto.setInitialTextTrack = function setInitialTextTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem != null ? periodItem.text : null;

    if (textInfos == null || periodItem == null) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }

    var preferredTextTracks = this._preferredTextTracks.getValue();

    var textAdaptations = period.adaptations.text === undefined ? [] : period.adaptations.text;

    var chosenTextAdaptation = this._textChoiceMemory.get(period);

    if (chosenTextAdaptation === null) {
      // If the Period was previously without text, keep it that way
      textInfos.adaptation$.next(null);
    } else if (chosenTextAdaptation === undefined || !Object(array_includes["a" /* default */])(textAdaptations, chosenTextAdaptation)) {
      // Find the optimal text Adaptation
      var normalizedPref = normalizeTextTracks(preferredTextTracks);
      var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, normalizedPref);

      this._textChoiceMemory.set(period, optimalAdaptation);

      textInfos.adaptation$.next(optimalAdaptation);
    } else {
      textInfos.adaptation$.next(chosenTextAdaptation); // set last one
    }
  }
  /**
   * Emit initial video Adaptation through the given Subject based on:
   *   - the preferred video tracks
   *   - the last choice for this period, if one
   * @param {Period} period - The concerned Period.
   */
  ;

  _proto.setInitialVideoTrack = function setInitialVideoTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem != null ? periodItem.video : null;

    if (videoInfos == null || periodItem == null) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }

    var videoAdaptations = period.adaptations.video === undefined ? [] : period.adaptations.video;

    var chosenVideoAdaptation = this._videoChoiceMemory.get(period);

    if (chosenVideoAdaptation === null) {
      // If the Period was previously without video, keep it that way
      videoInfos.adaptation$.next(null);
    } else if (chosenVideoAdaptation === undefined || !Object(array_includes["a" /* default */])(videoAdaptations, chosenVideoAdaptation)) {
      var optimalAdaptation = videoAdaptations[0];

      this._videoChoiceMemory.set(period, optimalAdaptation);

      videoInfos.adaptation$.next(optimalAdaptation);
    } else {
      videoInfos.adaptation$.next(chosenVideoAdaptation); // set last one
    }
  }
  /**
   * Set audio track based on the ID of its adaptation for a given added Period.
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   */
  ;

  _proto.setAudioTrackByID = function setAudioTrackByID(period, wantedId) {
    var periodItem = getPeriodItem(this._periods, period);
    var audioInfos = periodItem != null ? periodItem.audio : null;

    if (audioInfos == null) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }

    var wantedAdaptation = Object(array_find["a" /* default */])(audioInfos.adaptations, function (_ref) {
      var id = _ref.id;
      return id === wantedId;
    });

    if (wantedAdaptation === undefined) {
      throw new Error("Audio Track not found.");
    }

    var chosenAudioAdaptation = this._audioChoiceMemory.get(period);

    if (chosenAudioAdaptation === wantedAdaptation) {
      return;
    }

    this._audioChoiceMemory.set(period, wantedAdaptation);

    audioInfos.adaptation$.next(wantedAdaptation);
  }
  /**
   * Set text track based on the ID of its adaptation for a given added Period.
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   */
  ;

  _proto.setTextTrackByID = function setTextTrackByID(period, wantedId) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem != null ? periodItem.text : null;

    if (textInfos == null) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }

    var wantedAdaptation = Object(array_find["a" /* default */])(textInfos.adaptations, function (_ref2) {
      var id = _ref2.id;
      return id === wantedId;
    });

    if (wantedAdaptation === undefined) {
      throw new Error("Text Track not found.");
    }

    var chosenTextAdaptation = this._textChoiceMemory.get(period);

    if (chosenTextAdaptation === wantedAdaptation) {
      return;
    }

    this._textChoiceMemory.set(period, wantedAdaptation);

    textInfos.adaptation$.next(wantedAdaptation);
  }
  /**
   * Set video track based on the ID of its adaptation for a given added Period.
   * @param {Period} period - The concerned Period.
   * @param {string} wantedId - adaptation id of the wanted track
   *
   * @throws Error - Throws if the period given has not been added
   * @throws Error - Throws if the given id is not found in any video adaptation
   * of the given Period.
   */
  ;

  _proto.setVideoTrackByID = function setVideoTrackByID(period, wantedId) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem != null ? periodItem.video : null;

    if (videoInfos == null) {
      throw new Error("LanguageManager: Given Period not found.");
    }

    var wantedAdaptation = Object(array_find["a" /* default */])(videoInfos.adaptations, function (_ref3) {
      var id = _ref3.id;
      return id === wantedId;
    });

    if (wantedAdaptation === undefined) {
      throw new Error("Video Track not found.");
    }

    var chosenVideoAdaptation = this._videoChoiceMemory.get(period);

    if (chosenVideoAdaptation === wantedAdaptation) {
      return;
    }

    this._videoChoiceMemory.set(period, wantedAdaptation);

    videoInfos.adaptation$.next(wantedAdaptation);
  }
  /**
   * Disable the current text track for a given period.
   *
   * @param {Period} period - The concerned Period.
   *
   * @throws Error - Throws if the period given has not been added
   */
  ;

  _proto.disableTextTrack = function disableTextTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem != null ? periodItem.text : null;

    if (textInfos == null) {
      throw new Error("TrackChoiceManager: Given Period not found.");
    }

    var chosenTextAdaptation = this._textChoiceMemory.get(period);

    if (chosenTextAdaptation === null) {
      return;
    }

    this._textChoiceMemory.set(period, null);

    textInfos.adaptation$.next(null);
  }
  /**
   * Returns an object describing the chosen audio track for the given audio
   * Period.
   *
   * Returns null is the the current audio track is disabled or not
   * set yet.
   *
   * @param {Period} period - The concerned Period.
   * @returns {Object|null} - The audio track chosen for this Period
   */
  ;

  _proto.getChosenAudioTrack = function getChosenAudioTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var audioInfos = periodItem != null ? periodItem.audio : null;

    if (audioInfos == null) {
      return null;
    }

    var adaptationChosen = this._audioChoiceMemory.get(period);

    if (adaptationChosen == null) {
      return null;
    }

    var audioTrack = {
      language: Object(take_first_set["a" /* default */])(adaptationChosen.language, ""),
      normalized: Object(take_first_set["a" /* default */])(adaptationChosen.normalizedLanguage, ""),
      audioDescription: adaptationChosen.isAudioDescription === true,
      id: adaptationChosen.id
    };

    if (adaptationChosen.isDub === true) {
      audioTrack.dub = true;
    }

    return audioTrack;
  }
  /**
   * Returns an object describing the chosen text track for the given text
   * Period.
   *
   * Returns null is the the current text track is disabled or not
   * set yet.
   *
   * @param {Period} period - The concerned Period.
   * @returns {Object|null} - The text track chosen for this Period
   */
  ;

  _proto.getChosenTextTrack = function getChosenTextTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem != null ? periodItem.text : null;

    if (textInfos == null) {
      return null;
    }

    var chosenTextAdaptation = this._textChoiceMemory.get(period);

    if (chosenTextAdaptation == null) {
      return null;
    }

    return {
      language: Object(take_first_set["a" /* default */])(chosenTextAdaptation.language, ""),
      normalized: Object(take_first_set["a" /* default */])(chosenTextAdaptation.normalizedLanguage, ""),
      closedCaption: chosenTextAdaptation.isClosedCaption === true,
      id: chosenTextAdaptation.id
    };
  }
  /**
   * Returns an object describing the chosen video track for the given video
   * Period.
   *
   * Returns null is the the current video track is disabled or not
   * set yet.
   *
   * @param {Period} period - The concerned Period.
   * @returns {Object|null} - The video track chosen for this Period
   */
  ;

  _proto.getChosenVideoTrack = function getChosenVideoTrack(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem != null ? periodItem.video : null;

    if (videoInfos == null) {
      return null;
    }

    var chosenVideoAdaptation = this._videoChoiceMemory.get(period);

    if (chosenVideoAdaptation == null) {
      return null;
    }

    return {
      id: chosenVideoAdaptation.id,
      representations: chosenVideoAdaptation.representations.map(parseVideoRepresentation)
    };
  }
  /**
   * Returns all available audio tracks for a given Period, as an array of
   * objects.
   *
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAvailableAudioTracks = function getAvailableAudioTracks(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var audioInfos = periodItem != null ? periodItem.audio : null;

    if (audioInfos == null) {
      return [];
    }

    var chosenAudioAdaptation = this._audioChoiceMemory.get(period);

    var currentId = chosenAudioAdaptation != null ? chosenAudioAdaptation.id : null;
    return audioInfos.adaptations.map(function (adaptation) {
      var formatted = {
        language: Object(take_first_set["a" /* default */])(adaptation.language, ""),
        normalized: Object(take_first_set["a" /* default */])(adaptation.normalizedLanguage, ""),
        audioDescription: adaptation.isAudioDescription === true,
        id: adaptation.id,
        active: currentId == null ? false : currentId === adaptation.id
      };

      if (adaptation.isDub === true) {
        formatted.dub = true;
      }

      return formatted;
    });
  }
  /**
   * Returns all available text tracks for a given Period, as an array of
   * objects.
   *
   * @param {Period} period
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAvailableTextTracks = function getAvailableTextTracks(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var textInfos = periodItem != null ? periodItem.text : null;

    if (textInfos == null) {
      return [];
    }

    var chosenTextAdaptation = this._textChoiceMemory.get(period);

    var currentId = chosenTextAdaptation != null ? chosenTextAdaptation.id : null;
    return textInfos.adaptations.map(function (adaptation) {
      return {
        language: Object(take_first_set["a" /* default */])(adaptation.language, ""),
        normalized: Object(take_first_set["a" /* default */])(adaptation.normalizedLanguage, ""),
        closedCaption: adaptation.isClosedCaption === true,
        id: adaptation.id,
        active: currentId == null ? false : currentId === adaptation.id
      };
    });
  }
  /**
   * Returns all available video tracks for a given Period, as an array of
   * objects.
   *
   * @returns {Array.<Object>}
   */
  ;

  _proto.getAvailableVideoTracks = function getAvailableVideoTracks(period) {
    var periodItem = getPeriodItem(this._periods, period);
    var videoInfos = periodItem != null ? periodItem.video : null;

    if (videoInfos == null) {
      return [];
    }

    var chosenVideoAdaptation = this._videoChoiceMemory.get(period);

    var currentId = chosenVideoAdaptation != null ? chosenVideoAdaptation.id : null;
    return videoInfos.adaptations.map(function (adaptation) {
      return {
        id: adaptation.id,
        active: currentId === null ? false : currentId === adaptation.id,
        representations: adaptation.representations.map(parseVideoRepresentation)
      };
    });
  };

  _proto._updateAudioTrackChoices = function _updateAudioTrackChoices() {
    var _this = this;

    var preferredAudioTracks = this._preferredAudioTracks.getValue();

    var normalizedPref = normalizeAudioTracks(preferredAudioTracks);

    var recursiveUpdateAudioTrack = function recursiveUpdateAudioTrack(index) {
      if (index >= _this._periods.length()) {
        // we did all audio Buffers, exit
        return;
      }

      var periodItem = _this._periods.get(index);

      if (periodItem.audio == null) {
        // No audio Buffer for this period, check next one
        recursiveUpdateAudioTrack(index + 1);
        return;
      }

      var period = periodItem.period,
          audioItem = periodItem.audio;
      var audioAdaptations = period.adaptations.audio === undefined ? [] : period.adaptations.audio;

      var chosenAudioAdaptation = _this._audioChoiceMemory.get(period);

      if (chosenAudioAdaptation === null || chosenAudioAdaptation !== undefined && Object(array_includes["a" /* default */])(audioAdaptations, chosenAudioAdaptation)) {
        // Already best audio for this Buffer, check next one
        recursiveUpdateAudioTrack(index + 1);
        return;
      }

      var optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, normalizedPref);

      _this._audioChoiceMemory.set(period, optimalAdaptation);

      audioItem.adaptation$.next(optimalAdaptation); // previous "next" call could have changed everything, start over

      recursiveUpdateAudioTrack(0);
    };

    recursiveUpdateAudioTrack(0);
  };

  _proto._updateTextTrackChoices = function _updateTextTrackChoices() {
    var _this2 = this;

    var preferredTextTracks = this._preferredTextTracks.getValue();

    var normalizedPref = normalizeTextTracks(preferredTextTracks);

    var recursiveUpdateTextTrack = function recursiveUpdateTextTrack(index) {
      if (index >= _this2._periods.length()) {
        // we did all text Buffers, exit
        return;
      }

      var periodItem = _this2._periods.get(index);

      if (periodItem.text == null) {
        // No text Buffer for this period, check next one
        recursiveUpdateTextTrack(index + 1);
        return;
      }

      var period = periodItem.period,
          textItem = periodItem.text;
      var textAdaptations = period.adaptations.text === undefined ? [] : period.adaptations.text;

      var chosenTextAdaptation = _this2._textChoiceMemory.get(period);

      if (chosenTextAdaptation === null || chosenTextAdaptation !== undefined && Object(array_includes["a" /* default */])(textAdaptations, chosenTextAdaptation)) {
        // Already best text for this Buffer, check next one
        recursiveUpdateTextTrack(index + 1);
        return;
      }

      var optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, normalizedPref);

      _this2._textChoiceMemory.set(period, optimalAdaptation);

      textItem.adaptation$.next(optimalAdaptation); // previous "next" call could have changed everything, start over

      recursiveUpdateTextTrack(0);
    };

    recursiveUpdateTextTrack(0);
  };

  _proto._updateVideoTrackChoices = function _updateVideoTrackChoices() {
    var _this3 = this;

    var recursiveUpdateVideoTrack = function recursiveUpdateVideoTrack(index) {
      if (index >= _this3._periods.length()) {
        // we did all video Buffers, exit
        return;
      }

      var periodItem = _this3._periods.get(index);

      if (periodItem.video == null) {
        // No video Buffer for this period, check next one
        recursiveUpdateVideoTrack(index + 1);
        return;
      }

      var period = periodItem.period,
          videoItem = periodItem.video;
      var videoAdaptations = period.adaptations.video === undefined ? [] : period.adaptations.video;

      var chosenVideoAdaptation = _this3._videoChoiceMemory.get(period);

      if (chosenVideoAdaptation === null || chosenVideoAdaptation !== undefined && Object(array_includes["a" /* default */])(videoAdaptations, chosenVideoAdaptation)) {
        // Already best video for this Buffer, check next one
        recursiveUpdateVideoTrack(index + 1);
        return;
      }

      var optimalAdaptation = videoAdaptations[0];

      _this3._videoChoiceMemory.set(period, optimalAdaptation);

      videoItem.adaptation$.next(optimalAdaptation); // previous "next" call could have changed everything, start over

      recursiveUpdateVideoTrack(0);
    };

    recursiveUpdateVideoTrack(0);
  };

  return TrackChoiceManager;
}();
/**
 * Find an optimal audio adaptation given their list and the array of preferred
 * audio tracks sorted from the most preferred to the least preferred.
 *
 * `null` if the most optimal audio adaptation is no audio adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @param {Array.<Object|null>} preferredAudioTracks
 * @returns {Adaptation|null}
 */




function findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks) {
  if (audioAdaptations.length === 0) {
    return null;
  }

  var _loop = function _loop(i) {
    var preferredAudioTrack = preferredAudioTracks[i];

    if (preferredAudioTrack === null) {
      return {
        v: null
      };
    }

    var foundAdaptation = Object(array_find["a" /* default */])(audioAdaptations, function (audioAdaptation) {
      return Object(take_first_set["a" /* default */])(audioAdaptation.normalizedLanguage, "") === preferredAudioTrack.normalized && (preferredAudioTrack.audioDescription ? audioAdaptation.isAudioDescription === true : audioAdaptation.isAudioDescription !== true);
    });

    if (foundAdaptation !== undefined) {
      return {
        v: foundAdaptation
      };
    }
  };

  for (var i = 0; i < preferredAudioTracks.length; i++) {
    var _ret = _loop(i);

    if (typeof _ret === "object") return _ret.v;
  } // no optimal adaptation, just return the first one


  return audioAdaptations[0];
}
/**
 * Find an optimal text adaptation given their list and the array of preferred
 * text tracks sorted from the most preferred to the least preferred.
 *
 * `null` if the most optimal text adaptation is no text adaptation.
 * @param {Array.<Object>} textAdaptations
 * @param {Array.<Object|null>} preferredTextTracks
 * @returns {Adaptation|null}
 */


function findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks) {
  if (textAdaptations.length === 0) {
    return null;
  }

  var _loop2 = function _loop2(i) {
    var preferredTextTrack = preferredTextTracks[i];

    if (preferredTextTrack === null) {
      return {
        v: null
      };
    }

    var foundAdaptation = Object(array_find["a" /* default */])(textAdaptations, function (textAdaptation) {
      return Object(take_first_set["a" /* default */])(textAdaptation.normalizedLanguage, "") === preferredTextTrack.normalized && (preferredTextTrack.closedCaption ? textAdaptation.isClosedCaption === true : textAdaptation.isClosedCaption !== true);
    });

    if (foundAdaptation !== undefined) {
      return {
        v: foundAdaptation
      };
    }
  };

  for (var i = 0; i < preferredTextTracks.length; i++) {
    var _ret2 = _loop2(i);

    if (typeof _ret2 === "object") return _ret2.v;
  } // no optimal adaptation


  return null;
}
/**
 * Returns the index of the given `period` in the given `periods`
 * SortedList.
 * Returns `undefined` if that `period` is not found.
 * @param {Object} periods
 * @param {Object} period
 * @returns {number|undefined}
 */


function findPeriodIndex(periods, period) {
  for (var i = 0; i < periods.length(); i++) {
    var periodI = periods.get(i);

    if (periodI.period.id === period.id) {
      return i;
    }
  }
}
/**
 * Returns element in the given `periods` SortedList that corresponds to the
 * `period` given.
 * Returns `undefined` if that `period` is not found.
 * @param {Object} periods
 * @param {Object} period
 * @returns {Object|undefined}
 */


function getPeriodItem(periods, period) {
  for (var i = 0; i < periods.length(); i++) {
    var periodI = periods.get(i);

    if (periodI.period.id === period.id) {
      return periodI;
    }
  }
}
/**
 * Parse video Representation into a ITMVideoRepresentation.
 * @param {Object} representation
 * @returns {Object}
 */


function parseVideoRepresentation(_ref4) {
  var id = _ref4.id,
      bitrate = _ref4.bitrate,
      frameRate = _ref4.frameRate,
      width = _ref4.width,
      height = _ref4.height,
      codec = _ref4.codec;
  return {
    id: id,
    bitrate: bitrate,
    frameRate: frameRate,
    width: width,
    height: height,
    codec: codec
  };
}
// CONCATENATED MODULE: ./src/core/api/public_api.ts
function public_api_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function public_api_createClass(Constructor, protoProps, staticProps) { if (protoProps) public_api_defineProperties(Constructor.prototype, protoProps); if (staticProps) public_api_defineProperties(Constructor, staticProps); return Constructor; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file defines the public API for the RxPlayer.
 * It also starts the different sub-parts of the player on various API calls.
 */





















var DEFAULT_UNMUTED_VOLUME = config["a" /* default */].DEFAULT_UNMUTED_VOLUME;
var isActive = compat["a" /* events */].isActive,
    isVideoVisible = compat["a" /* events */].isVideoVisible,
    onEnded$ = compat["a" /* events */].onEnded$,
    onFullscreenChange$ = compat["a" /* events */].onFullscreenChange$,
    onPlayPause$ = compat["a" /* events */].onPlayPause$,
    onPictureInPictureEvent$ = compat["a" /* events */].onPictureInPictureEvent$,
    onSeeking$ = compat["a" /* events */].onSeeking$,
    onTextTrackChanges$ = compat["a" /* events */].onTextTrackChanges$,
    videoWidth$ = compat["a" /* events */].videoWidth$;
/**
 * @class Player
 * @extends EventEmitter
 */

var public_api_Player = /*#__PURE__*/function (_EventEmitter) {
  _inheritsLoose(Player, _EventEmitter);

  /**
   * @constructor
   * @param {Object} options
   */
  function Player(options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _EventEmitter.call(this) || this;

    var _parseConstructorOpti = parseConstructorOptions(options),
        initialAudioBitrate = _parseConstructorOpti.initialAudioBitrate,
        initialVideoBitrate = _parseConstructorOpti.initialVideoBitrate,
        limitVideoWidth = _parseConstructorOpti.limitVideoWidth,
        maxAudioBitrate = _parseConstructorOpti.maxAudioBitrate,
        maxBufferAhead = _parseConstructorOpti.maxBufferAhead,
        maxBufferBehind = _parseConstructorOpti.maxBufferBehind,
        maxVideoBitrate = _parseConstructorOpti.maxVideoBitrate,
        preferredAudioTracks = _parseConstructorOpti.preferredAudioTracks,
        preferredTextTracks = _parseConstructorOpti.preferredTextTracks,
        throttleWhenHidden = _parseConstructorOpti.throttleWhenHidden,
        throttleVideoBitrateWhenHidden = _parseConstructorOpti.throttleVideoBitrateWhenHidden,
        videoElement = _parseConstructorOpti.videoElement,
        wantedBufferAhead = _parseConstructorOpti.wantedBufferAhead,
        stopAtEnd = _parseConstructorOpti.stopAtEnd; // Workaround to support Firefox autoplay on FF 42.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624


    videoElement.preload = "auto";
    _this.version =
    /*PLAYER_VERSION*/
    "3.19.0";
    _this.log = log["a" /* default */];
    _this.state = "STOPPED";
    _this.videoElement = videoElement;
    _this._priv_destroy$ = new Subject["a" /* Subject */]();
    _this._priv_pictureInPictureEvent$ = new ReplaySubject["a" /* ReplaySubject */](1);
    onPictureInPictureEvent$(videoElement).pipe(Object(takeUntil["a" /* takeUntil */])(_this._priv_destroy$)).subscribe(_this._priv_pictureInPictureEvent$);
    /** @deprecated */

    onFullscreenChange$(videoElement).pipe(Object(takeUntil["a" /* takeUntil */])(_this._priv_destroy$))
    /* tslint:disable deprecation */
    .subscribe(function () {
      return _this.trigger("fullscreenChange", _this.isFullscreen());
    });
    /* tslint:enable deprecation */

    /** @deprecated */

    onTextTrackChanges$(videoElement.textTracks).pipe(Object(takeUntil["a" /* takeUntil */])(_this._priv_destroy$), Object(map["a" /* map */])(function (evt) {
      var target = evt.target;
      var arr = [];

      for (var i = 0; i < target.length; i++) {
        var textTrack = target[i];
        arr.push(textTrack);
      }

      return arr;
    }), // We can have two consecutive textTrackChanges with the exact same
    // payload when we perform multiple texttrack operations before the event
    // loop is freed.
    // In that case we only want to fire one time the observable.
    Object(distinctUntilChanged["a" /* distinctUntilChanged */])(function (textTracksA, textTracksB) {
      if (textTracksA.length !== textTracksB.length) {
        return false;
      }

      for (var i = 0; i < textTracksA.length; i++) {
        if (textTracksA[i] !== textTracksB[i]) {
          return false;
        }
      }

      return true;
    })).subscribe(function (x) {
      return _this._priv_onNativeTextTracksNext(x);
    });
    _this._priv_playing$ = new ReplaySubject["a" /* ReplaySubject */](1);
    _this._priv_speed$ = new BehaviorSubject_BehaviorSubject(videoElement.playbackRate);
    _this._priv_stopCurrentContent$ = new Subject["a" /* Subject */]();
    _this._priv_contentLock$ = new BehaviorSubject_BehaviorSubject(false);
    _this._priv_bufferOptions = {
      wantedBufferAhead$: new BehaviorSubject_BehaviorSubject(wantedBufferAhead),
      maxBufferAhead$: new BehaviorSubject_BehaviorSubject(maxBufferAhead),
      maxBufferBehind$: new BehaviorSubject_BehaviorSubject(maxBufferBehind)
    };
    _this._priv_bitrateInfos = {
      lastBitrates: {
        audio: initialAudioBitrate,
        video: initialVideoBitrate
      },
      maxAutoBitrates: {
        audio: new BehaviorSubject_BehaviorSubject(maxAudioBitrate),
        video: new BehaviorSubject_BehaviorSubject(maxVideoBitrate)
      },
      manualBitrates: {
        audio: new BehaviorSubject_BehaviorSubject(-1),
        video: new BehaviorSubject_BehaviorSubject(-1)
      }
    };
    _this._priv_throttleWhenHidden = throttleWhenHidden;
    _this._priv_throttleVideoBitrateWhenHidden = throttleVideoBitrateWhenHidden;
    _this._priv_limitVideoWidth = limitVideoWidth;
    _this._priv_mutedMemory = DEFAULT_UNMUTED_VOLUME;
    _this._priv_trackChoiceManager = null;
    _this._priv_mediaElementTrackChoiceManager = null;
    _this._priv_currentError = null;
    _this._priv_contentInfos = null;
    _this._priv_contentEventsMemory = {};
    _this._priv_stopAtEnd = stopAtEnd;

    _this._priv_setPlayerState(PLAYER_STATES.STOPPED);

    _this._priv_preferredAudioTracks = new BehaviorSubject_BehaviorSubject(preferredAudioTracks);
    _this._priv_preferredTextTracks = new BehaviorSubject_BehaviorSubject(preferredTextTracks);
    return _this;
  }
  /** All possible Error types emitted by the RxPlayer. */


  var _proto = Player.prototype;

  /**
   * Stop the playback for the current content.
   */
  _proto.stop = function stop() {
    if (this.state !== PLAYER_STATES.STOPPED) {
      this._priv_stopCurrentContent$.next();

      this._priv_cleanUpCurrentContentState();

      this._priv_setPlayerState(PLAYER_STATES.STOPPED);
    }
  }
  /**
   * Free the resources used by the player.
   * /!\ The player cannot be "used" anymore after this method has been called.
   */
  ;

  _proto.dispose = function dispose() {
    // free resources linked to the loaded content
    this.stop();

    if (this.videoElement !== null) {
      // free resources used for EME management
      Object(dispose_eme["a" /* default */])(this.videoElement);
    } // free Observables linked to the Player instance


    this._priv_destroy$.next();

    this._priv_destroy$.complete(); // Complete all subjects


    this._priv_stopCurrentContent$.complete();

    this._priv_playing$.complete();

    this._priv_speed$.complete();

    this._priv_contentLock$.complete();

    this._priv_bufferOptions.wantedBufferAhead$.complete();

    this._priv_bufferOptions.maxBufferAhead$.complete();

    this._priv_bufferOptions.maxBufferBehind$.complete();

    this._priv_pictureInPictureEvent$.complete();

    this._priv_bitrateInfos.manualBitrates.video.complete();

    this._priv_bitrateInfos.manualBitrates.audio.complete();

    this._priv_bitrateInfos.maxAutoBitrates.video.complete();

    this._priv_bitrateInfos.maxAutoBitrates.audio.complete(); // un-attach video element


    this.videoElement = null;
  }
  /**
   * Load a new video.
   * @param {Object} opts
   */
  ;

  _proto.loadVideo = function loadVideo(opts) {
    var _this2 = this;

    var _a, _b, _c;

    var options = parseLoadVideoOptions(opts);
    log["a" /* default */].info("API: Calling loadvideo", options);
    var autoPlay = options.autoPlay,
        defaultAudioTrack = options.defaultAudioTrack,
        defaultTextTrack = options.defaultTextTrack,
        keySystems = options.keySystems,
        lowLatencyMode = options.lowLatencyMode,
        manualBitrateSwitchingMode = options.manualBitrateSwitchingMode,
        manifestUpdateUrl = options.manifestUpdateUrl,
        minimumManifestUpdateInterval = options.minimumManifestUpdateInterval,
        networkConfig = options.networkConfig,
        startAt = options.startAt,
        transport = options.transport,
        transportOptions = options.transportOptions,
        url = options.url; // Perform multiple checks on the given options

    if (this.videoElement === null) {
      throw new Error("the attached video element is disposed");
    } // now that every check has passed, stop previous content


    this.stop();
    var isDirectFile = transport === "directfile";
    this._priv_currentError = null;
    this._priv_contentInfos = {
      url: url,
      isDirectFile: isDirectFile,
      sourceBuffersStore: null,
      thumbnails: null,
      manifest: null,
      currentPeriod: null,
      activeAdaptations: null,
      activeRepresentations: null,
      initialAudioTrack: defaultAudioTrack,
      initialTextTrack: defaultTextTrack
    }; // inilialize to false

    this._priv_playing$.next(false); // get every properties used from context for clarity


    var videoElement = this.videoElement; // Global clock used for the whole application.

    var clock$ = api_clock(videoElement, {
      withMediaSource: !isDirectFile,
      lowLatencyMode: lowLatencyMode
    });
    var contentIsStopped$ = Object(merge["a" /* merge */])(this._priv_stopCurrentContent$, this._priv_stopAtEnd ? onEnded$(videoElement) : empty["a" /* EMPTY */]).pipe(Object(take["a" /* take */])(1));
    var playback$;

    if (!isDirectFile) {
      var transportFn = features["a" /* default */].transports[transport];

      if (typeof transportFn !== "function") {
        throw new Error("transport \"" + transport + "\" not supported");
      }

      var transportPipelines = transportFn(transportOptions); // Options used by the ABR Manager.

      var adaptiveOptions = {
        initialBitrates: this._priv_bitrateInfos.lastBitrates,
        lowLatencyMode: lowLatencyMode,
        manualBitrates: this._priv_bitrateInfos.manualBitrates,
        maxAutoBitrates: this._priv_bitrateInfos.maxAutoBitrates,
        throttlers: {
          throttle: this._priv_throttleWhenHidden ? {
            video: isActive().pipe(Object(map["a" /* map */])(function (active) {
              return active ? Infinity : 0;
            }), Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$))
          } : {},
          throttleBitrate: this._priv_throttleVideoBitrateWhenHidden ? {
            video: isVideoVisible(this._priv_pictureInPictureEvent$).pipe(Object(map["a" /* map */])(function (active) {
              return active ? Infinity : 0;
            }), Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$))
          } : {},
          limitWidth: this._priv_limitVideoWidth ? {
            video: videoWidth$(videoElement, this._priv_pictureInPictureEvent$).pipe(Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$))
          } : {}
        }
      }; // Options used by the TextTrack SourceBuffer

      var textTrackOptions = options.textTrackMode === "native" ? {
        textTrackMode: "native",
        hideNativeSubtitle: options.hideNativeSubtitle
      } : {
        textTrackMode: "html",
        textTrackElement: options.textTrackElement
      };
      var bufferOptions = Object(object_assign["a" /* default */])({
        manualBitrateSwitchingMode: manualBitrateSwitchingMode
      }, this._priv_bufferOptions); // playback$ Observable, through which the content will be launched.

      var init$ = init({
        adaptiveOptions: adaptiveOptions,
        autoPlay: autoPlay,
        bufferOptions: bufferOptions,
        clock$: clock$,
        keySystems: keySystems,
        lowLatencyMode: lowLatencyMode,
        manifestUpdateUrl: manifestUpdateUrl,
        mediaElement: videoElement,
        minimumManifestUpdateInterval: minimumManifestUpdateInterval,
        networkConfig: networkConfig,
        transportPipelines: transportPipelines,
        speed$: this._priv_speed$,
        startAt: startAt,
        textTrackOptions: textTrackOptions,
        url: url
      }).pipe(Object(takeUntil["a" /* takeUntil */])(contentIsStopped$));
      playback$ = publish()(init$);
    } else {
      if (features["a" /* default */].directfile == null) {
        throw new Error("DirectFile feature not activated in your build.");
      }

      this._priv_mediaElementTrackChoiceManager = new features["a" /* default */].directfile.mediaElementTrackChoiceManager({
        preferredAudioTracks: defaultAudioTrack === undefined ? this._priv_preferredAudioTracks : new BehaviorSubject_BehaviorSubject([defaultAudioTrack]),
        preferredTextTracks: defaultTextTrack === undefined ? this._priv_preferredTextTracks : new BehaviorSubject_BehaviorSubject([defaultTextTrack])
      }, this.videoElement);
      this.trigger("availableAudioTracksChange", this._priv_mediaElementTrackChoiceManager.getAvailableAudioTracks());
      this.trigger("availableVideoTracksChange", this._priv_mediaElementTrackChoiceManager.getAvailableVideoTracks());
      this.trigger("availableTextTracksChange", this._priv_mediaElementTrackChoiceManager.getAvailableTextTracks());
      this.trigger("audioTrackChange", (_a = this._priv_mediaElementTrackChoiceManager.getChosenAudioTrack()) !== null && _a !== void 0 ? _a : null);
      this.trigger("textTrackChange", (_b = this._priv_mediaElementTrackChoiceManager.getChosenTextTrack()) !== null && _b !== void 0 ? _b : null);
      this.trigger("videoTrackChange", (_c = this._priv_mediaElementTrackChoiceManager.getChosenVideoTrack()) !== null && _c !== void 0 ? _c : null);

      this._priv_mediaElementTrackChoiceManager.addEventListener("availableVideoTracksChange", function (val) {
        return _this2.trigger("availableVideoTracksChange", val);
      });

      this._priv_mediaElementTrackChoiceManager.addEventListener("availableAudioTracksChange", function (val) {
        return _this2.trigger("availableAudioTracksChange", val);
      });

      this._priv_mediaElementTrackChoiceManager.addEventListener("availableTextTracksChange", function (val) {
        return _this2.trigger("availableTextTracksChange", val);
      });

      this._priv_mediaElementTrackChoiceManager.addEventListener("audioTrackChange", function (val) {
        return _this2.trigger("audioTrackChange", val);
      });

      this._priv_mediaElementTrackChoiceManager.addEventListener("videoTrackChange", function (val) {
        return _this2.trigger("videoTrackChange", val);
      });

      this._priv_mediaElementTrackChoiceManager.addEventListener("textTrackChange", function (val) {
        return _this2.trigger("textTrackChange", val);
      });

      var directfileInit$ = features["a" /* default */].directfile.initDirectFile({
        autoPlay: autoPlay,
        clock$: clock$,
        keySystems: keySystems,
        mediaElement: videoElement,
        speed$: this._priv_speed$,
        startAt: startAt,
        url: url
      }).pipe(Object(takeUntil["a" /* takeUntil */])(contentIsStopped$));
      playback$ = publish()(directfileInit$);
    } // Emit an object when the player stalls and null when it unstall


    var stalled$ = playback$.pipe(Object(filter["a" /* filter */])(function (evt) {
      return evt.type === "stalled";
    }), Object(map["a" /* map */])(function (x) {
      return x.value;
    })); // Emit when the content is considered "loaded".

    var loaded$ = playback$.pipe(Object(filter["a" /* filter */])(function (evt) {
      return evt.type === "loaded";
    }), Object(share["a" /* share */])()); // Emit when we "reload" the MediaSource

    var reloading$ = playback$.pipe(Object(filter["a" /* filter */])(function (evt) {
      return evt.type === "reloading-media-source";
    }), Object(share["a" /* share */])()); // Emit when the media element emits an "ended" event.

    var endedEvent$ = onEnded$(videoElement); // Emit when the media element emits a "seeking" event.

    var seekingEvent$ = onSeeking$(videoElement); // State updates when the content is considered "loaded"

    var loadedStateUpdates$ = Object(combineLatest["a" /* combineLatest */])([this._priv_playing$, stalled$.pipe(Object(startWith["a" /* startWith */])(null)), endedEvent$.pipe(Object(startWith["a" /* startWith */])(null)), seekingEvent$.pipe(Object(startWith["a" /* startWith */])(null))]).pipe(Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$), Object(map["a" /* map */])(function (_ref) {
      var isPlaying = _ref[0],
          stalledStatus = _ref[1];
      return getLoadedContentState(videoElement, isPlaying, stalledStatus);
    })); // Emit the player state as it changes.

    var playerState$ = Object(concat["a" /* concat */])(Object(of["a" /* of */])(PLAYER_STATES.LOADING), // Begin with LOADING
    // LOADED as soon as the first "loaded" event is sent
    loaded$.pipe(Object(take["a" /* take */])(1), Object(mapTo["a" /* mapTo */])(PLAYER_STATES.LOADED)), Object(merge["a" /* merge */])(loadedStateUpdates$.pipe( // From the first reload onward, we enter another dynamic (below)
    Object(takeUntil["a" /* takeUntil */])(reloading$), skipWhile(function (state) {
      return state === PLAYER_STATES.PAUSED;
    })), // when reloading
    reloading$.pipe(Object(switchMapTo["a" /* switchMapTo */])(loaded$.pipe(Object(take["a" /* take */])(1), // wait for the next loaded event
    Object(mergeMapTo["a" /* mergeMapTo */])(loadedStateUpdates$), // to update the state as usual
    Object(startWith["a" /* startWith */])(PLAYER_STATES.RELOADING) // Starts with "RELOADING" state
    ))))).pipe(Object(distinctUntilChanged["a" /* distinctUntilChanged */])());
    var playbackSubscription;

    this._priv_stopCurrentContent$.pipe(Object(take["a" /* take */])(1)).subscribe(function () {
      if (playbackSubscription !== undefined) {
        playbackSubscription.unsubscribe();
      }
    });

    onPlayPause$(videoElement).pipe(Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$)).subscribe(function (e) {
      return _this2._priv_onPlayPauseNext(e.type === "play");
    }, noop["a" /* default */]);
    clock$.pipe(Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$)).subscribe(function (x) {
      return _this2._priv_triggerPositionUpdate(x);
    }, noop["a" /* default */]);
    loaded$.pipe(Object(switchMapTo["a" /* switchMapTo */])(emitSeekEvents(this.videoElement, clock$)), Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$)).subscribe(function (evt) {
      log["a" /* default */].info("API: Triggering \"" + evt + "\" event");

      _this2.trigger(evt, null);
    });
    playerState$.pipe(Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$)).subscribe(function (x) {
      return _this2._priv_setPlayerState(x);
    }, noop["a" /* default */]);
    playback$.subscribe(function (x) {
      return _this2._priv_onPlaybackEvent(x);
    }, function (err) {
      return _this2._priv_onPlaybackError(err);
    }, function () {
      return _this2._priv_onPlaybackFinished();
    }); // initialize the content only when the lock is inactive

    this._priv_contentLock$.pipe(Object(filter["a" /* filter */])(function (isLocked) {
      return !isLocked;
    }), Object(take["a" /* take */])(1), Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$)).subscribe(function () {
      playbackSubscription = playback$.connect();
    });
  }
  /**
   * Returns fatal error if one for the current content.
   * null otherwise.
   * @returns {Object|null} - The current Error (`null` when no error).
   */
  ;

  _proto.getError = function getError() {
    return this._priv_currentError;
  }
  /**
   * Returns manifest/playlist object.
   * null if the player is STOPPED.
   * @returns {Manifest|null} - The current Manifest (`null` when not known).
   */
  ;

  _proto.getManifest = function getManifest() {
    if (this._priv_contentInfos === null) {
      return null;
    }

    return this._priv_contentInfos.manifest;
  }
  /**
   * Returns Adaptations (tracks) for every currently playing type
   * (audio/video/text...).
   * @returns {Object|null} - The current Adaptation objects, per type (`null`
   * when none is known for now.
   */
  ;

  _proto.getCurrentAdaptations = function getCurrentAdaptations() {
    if (this._priv_contentInfos === null) {
      return null;
    }

    var _this$_priv_contentIn = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn.currentPeriod,
        activeAdaptations = _this$_priv_contentIn.activeAdaptations;

    if (currentPeriod === null || activeAdaptations === null || activeAdaptations[currentPeriod.id] == null) {
      return null;
    }

    return activeAdaptations[currentPeriod.id];
  }
  /**
   * Returns representations (qualities) for every currently playing type
   * (audio/video/text...).
   * @returns {Object|null} - The current Representation objects, per type
   * (`null` when none is known for now.
   */
  ;

  _proto.getCurrentRepresentations = function getCurrentRepresentations() {
    if (this._priv_contentInfos === null) {
      return null;
    }

    var _this$_priv_contentIn2 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn2.currentPeriod,
        activeRepresentations = _this$_priv_contentIn2.activeRepresentations;

    if (currentPeriod === null || activeRepresentations === null || activeRepresentations[currentPeriod.id] == null) {
      return null;
    }

    return activeRepresentations[currentPeriod.id];
  }
  /**
   * Returns the media DOM element used by the player.
   * You should not its HTML5 API directly and use the player's method instead,
   * to ensure a well-behaved player.
   * @returns {HTMLMediaElement|null} - The HTMLMediaElement used (`null` when
   * disposed)
   */
  ;

  _proto.getVideoElement = function getVideoElement() {
    return this.videoElement;
  }
  /**
   * If one returns the first native text-track element attached to the media element.
   * @deprecated
   * @returns {TextTrack} - The native TextTrack attached (`null` when none)
   */
  ;

  _proto.getNativeTextTrack = function getNativeTextTrack() {
    Object(warn_once["a" /* default */])("getNativeTextTrack is deprecated." + " Please open an issue if you used this API.");

    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    var videoElement = this.videoElement;
    var textTracks = videoElement.textTracks;

    if (textTracks.length > 0) {
      return videoElement.textTracks[0];
    } else {
      return null;
    }
  }
  /**
   * Returns the player's current state.
   * @returns {string} - The current Player's state
   */
  ;

  _proto.getPlayerState = function getPlayerState() {
    return this.state;
  }
  /**
   * Returns true if both:
   *   - a content is loaded
   *   - the content loaded is a live content
   * @returns {Boolean} - `true` if we're playing a live content, `false` otherwise.
   */
  ;

  _proto.isLive = function isLive() {
    if (this._priv_contentInfos === null) {
      return false;
    }

    var _this$_priv_contentIn3 = this._priv_contentInfos,
        isDirectFile = _this$_priv_contentIn3.isDirectFile,
        manifest = _this$_priv_contentIn3.manifest;

    if (isDirectFile || manifest === null) {
      return false;
    }

    return manifest.isLive;
  }
  /**
   * Returns the url of the content's manifest
   * @returns {string|undefined} - Current URL. `undefined` if not known or no
   * URL yet.
   */
  ;

  _proto.getUrl = function getUrl() {
    if (this._priv_contentInfos === null) {
      return undefined;
    }

    var _this$_priv_contentIn4 = this._priv_contentInfos,
        isDirectFile = _this$_priv_contentIn4.isDirectFile,
        manifest = _this$_priv_contentIn4.manifest,
        url = _this$_priv_contentIn4.url;

    if (isDirectFile) {
      return url;
    }

    if (manifest != null) {
      return manifest.getUrl();
    }

    return undefined;
  }
  /**
   * Returns the video duration, in seconds.
   * NaN if no video is playing.
   * @returns {Number}
   */
  ;

  _proto.getVideoDuration = function getVideoDuration() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    return this.videoElement.duration;
  }
  /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the current time
   * @returns {Number}
   */
  ;

  _proto.getVideoBufferGap = function getVideoBufferGap() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    var videoElement = this.videoElement;
    return Object(ranges["d" /* getLeftSizeOfRange */])(videoElement.buffered, videoElement.currentTime);
  }
  /**
   * Returns in seconds the difference between:
   *   - the end of the current contiguous loaded range.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */
  ;

  _proto.getVideoLoadedTime = function getVideoLoadedTime() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    var videoElement = this.videoElement;
    return Object(ranges["h" /* getSizeOfRange */])(videoElement.buffered, videoElement.currentTime);
  }
  /**
   * Returns in seconds the difference between:
   *   - the current time.
   *   - the start of the current contiguous loaded range.
   * @returns {Number}
   */
  ;

  _proto.getVideoPlayedTime = function getVideoPlayedTime() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    var videoElement = this.videoElement;
    return Object(ranges["f" /* getPlayedSizeOfRange */])(videoElement.buffered, videoElement.currentTime);
  }
  /**
   * Get the current position, in s, in wall-clock time.
   * That is:
   *   - for live content, get a timestamp, in s, of the current played content.
   *   - for static content, returns the position from beginning in s.
   *
   * If you do not know if you want to use this method or getPosition:
   *   - If what you want is to display the current time to the user, use this
   *     one.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use getPosition.
   *
   * @returns {Number}
   */
  ;

  _proto.getWallClockTime = function getWallClockTime() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    if (this._priv_contentInfos === null) {
      return this.videoElement.currentTime;
    }

    var _this$_priv_contentIn5 = this._priv_contentInfos,
        isDirectFile = _this$_priv_contentIn5.isDirectFile,
        manifest = _this$_priv_contentIn5.manifest;

    if (isDirectFile) {
      return this.videoElement.currentTime;
    }

    if (manifest != null) {
      var currentTime = this.videoElement.currentTime;
      var ast = manifest.availabilityStartTime !== undefined ? manifest.availabilityStartTime : 0;
      return currentTime + ast;
    }

    return 0;
  }
  /**
   * Get the current position, in seconds, of the video element.
   *
   * If you do not know if you want to use this method or getWallClockTime:
   *   - If what you want is to display the current time to the user, use
   *     getWallClockTime.
   *   - If what you want is to interact with the player's API or perform other
   *     actions (like statistics) with the real player data, use this one.
   *
   * @returns {Number}
   */
  ;

  _proto.getPosition = function getPosition() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    return this.videoElement.currentTime;
  }
  /**
   * Returns the current speed at which the video plays.
   * @returns {Number}
   */
  ;

  _proto.getPlaybackRate = function getPlaybackRate() {
    return this._priv_speed$.getValue();
  }
  /**
   * Update the playback rate of the video.
   * @param {Number} rate
   */
  ;

  _proto.setPlaybackRate = function setPlaybackRate(rate) {
    this._priv_speed$.next(rate);
  }
  /**
   * Returns all available bitrates for the current video Adaptation.
   * @returns {Array.<Number>}
   */
  ;

  _proto.getAvailableVideoBitrates = function getAvailableVideoBitrates() {
    if (this._priv_contentInfos === null) {
      return [];
    }

    var _this$_priv_contentIn6 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn6.currentPeriod,
        activeAdaptations = _this$_priv_contentIn6.activeAdaptations;

    if (currentPeriod === null || activeAdaptations === null) {
      return [];
    }

    var adaptations = activeAdaptations[currentPeriod.id];

    if (adaptations === undefined || adaptations.video == null) {
      return [];
    }

    return adaptations.video.getAvailableBitrates();
  }
  /**
   * Returns all available bitrates for the current audio Adaptation.
   * @returns {Array.<Number>}
   */
  ;

  _proto.getAvailableAudioBitrates = function getAvailableAudioBitrates() {
    if (this._priv_contentInfos === null) {
      return [];
    }

    var _this$_priv_contentIn7 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn7.currentPeriod,
        activeAdaptations = _this$_priv_contentIn7.activeAdaptations;

    if (currentPeriod === null || activeAdaptations === null) {
      return [];
    }

    var adaptations = activeAdaptations[currentPeriod.id];

    if (adaptations === undefined || adaptations.audio == null) {
      return [];
    }

    return adaptations.audio.getAvailableBitrates();
  }
  /**
   * Returns the manual audio bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */
  ;

  _proto.getManualAudioBitrate = function getManualAudioBitrate() {
    return this._priv_bitrateInfos.manualBitrates.audio.getValue();
  }
  /**
   * Returns the manual video bitrate set. -1 if in AUTO mode.
   * @returns {Number}
   */
  ;

  _proto.getManualVideoBitrate = function getManualVideoBitrate() {
    return this._priv_bitrateInfos.manualBitrates.video.getValue();
  }
  /**
   * Returns currently considered bitrate for video segments.
   * @returns {Number|undefined}
   */
  ;

  _proto.getVideoBitrate = function getVideoBitrate() {
    var representations = this.getCurrentRepresentations();

    if (representations === null || representations.video == null) {
      return undefined;
    }

    return representations.video.bitrate;
  }
  /**
   * Returns currently considered bitrate for audio segments.
   * @returns {Number|undefined}
   */
  ;

  _proto.getAudioBitrate = function getAudioBitrate() {
    var representations = this.getCurrentRepresentations();

    if (representations === null || representations.audio == null) {
      return undefined;
    }

    return representations.audio.bitrate;
  }
  /**
   * Returns max wanted video bitrate currently set.
   * @returns {Number}
   */
  ;

  _proto.getMaxVideoBitrate = function getMaxVideoBitrate() {
    return this._priv_bitrateInfos.maxAutoBitrates.video.getValue();
  }
  /**
   * Returns max wanted audio bitrate currently set.
   * @returns {Number}
   */
  ;

  _proto.getMaxAudioBitrate = function getMaxAudioBitrate() {
    return this._priv_bitrateInfos.maxAutoBitrates.audio.getValue();
  }
  /**
   * Play/Resume the current video.
   * @returns {Promise}
   */
  ;

  _proto.play = function play() {
    var _this3 = this;

    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    var playPromise = this.videoElement.play();
    /* tslint:disable no-unbound-method */

    if (playPromise == null || typeof playPromise["catch"] !== "function") {
      /* tslint:enable no-unbound-method */
      return promise["a" /* default */].resolve();
    }

    return playPromise["catch"](function (error) {
      if (error.name === "NotAllowedError") {
        var warning = new media_error["a" /* default */]("MEDIA_ERR_PLAY_NOT_ALLOWED", error.toString());

        _this3.trigger("warning", warning);
      }

      throw error;
    });
  }
  /**
   * Pause the current video.
   */
  ;

  _proto.pause = function pause() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    this.videoElement.pause();
  }
  /**
   * Seek to a given absolute position.
   * @param {Number|Object} time
   * @returns {Number} - The time the player has seek to
   */
  ;

  _proto.seekTo = function seekTo(time) {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    if (this._priv_contentInfos === null) {
      throw new Error("player: no content loaded");
    }

    var _this$_priv_contentIn8 = this._priv_contentInfos,
        isDirectFile = _this$_priv_contentIn8.isDirectFile,
        manifest = _this$_priv_contentIn8.manifest;

    if (!isDirectFile && manifest === null) {
      throw new Error("player: the content did not load yet");
    }

    var positionWanted;

    if (typeof time === "number") {
      positionWanted = time;
    } else if (typeof time === "object") {
      var timeObj = time;
      var currentTs = this.videoElement.currentTime;

      if (timeObj.relative != null) {
        positionWanted = currentTs + timeObj.relative;
      } else if (timeObj.position != null) {
        positionWanted = timeObj.position;
      } else if (timeObj.wallClockTime != null) {
        positionWanted = isDirectFile || manifest === null ? timeObj.wallClockTime : timeObj.wallClockTime - (manifest.availabilityStartTime !== undefined ? manifest.availabilityStartTime : 0);
      } else {
        throw new Error("invalid time object. You must set one of the " + "following properties: \"relative\", \"position\" or " + "\"wallClockTime\"");
      }
    }

    if (positionWanted === undefined) {
      throw new Error("invalid time given");
    }

    this.videoElement.currentTime = positionWanted;
    return positionWanted;
  }
  /**
   * Returns true if the media element is full screen.
   * @deprecated
   * @returns {Boolean}
   */
  ;

  _proto.isFullscreen = function isFullscreen() {
    Object(warn_once["a" /* default */])("isFullscreen is deprecated." + " Fullscreen management should now be managed by the application");
    return Object(fullscreen["b" /* isFullscreen */])();
  }
  /**
   * Set/exit fullScreen.
   * @deprecated
   * @param {Boolean} [goFull=true] - if false, exit full screen.
   */
  ;

  _proto.setFullscreen = function setFullscreen(goFull) {
    if (goFull === void 0) {
      goFull = true;
    }

    Object(warn_once["a" /* default */])("setFullscreen is deprecated." + " Fullscreen management should now be managed by the application");

    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    if (goFull) {
      Object(fullscreen["c" /* requestFullscreen */])(this.videoElement);
    } else {
      Object(fullscreen["a" /* exitFullscreen */])();
    }
  }
  /**
   * Exit from full screen mode.
   * @deprecated
   */
  ;

  _proto.exitFullscreen = function exitFullscreen() {
    Object(warn_once["a" /* default */])("exitFullscreen is deprecated." + " Fullscreen management should now be managed by the application");

    Object(fullscreen["a" /* exitFullscreen */])();
  }
  /**
   * Returns the current player's audio volume on the media element.
   * From 0 (no audio) to 1 (maximum volume).
   * @returns {Number}
   */
  ;

  _proto.getVolume = function getVolume() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    return this.videoElement.volume;
  }
  /**
   * Set the player's audio volume. From 0 (no volume) to 1 (maximum volume).
   * @param {Number} volume
   */
  ;

  _proto.setVolume = function setVolume(volume) {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    var videoElement = this.videoElement;

    if (volume !== videoElement.volume) {
      videoElement.volume = volume;
      this.trigger("volumeChange", volume);
    }
  }
  /**
   * Returns true if the volume is set to 0. false otherwise.
   * @returns {Boolean}
   */
  ;

  _proto.isMute = function isMute() {
    return this.getVolume() === 0;
  }
  /**
   * Set the volume to 0 and save current one for when unmuted.
   */
  ;

  _proto.mute = function mute() {
    this._priv_mutedMemory = this.getVolume();
    this.setVolume(0);
  }
  /**
   * Set the volume back to when it was when mute was last called.
   * If the volume was set to 0, set a default volume instead (see config).
   */
  ;

  _proto.unMute = function unMute() {
    var vol = this.getVolume();

    if (vol === 0) {
      this.setVolume(this._priv_mutedMemory === 0 ? DEFAULT_UNMUTED_VOLUME : this._priv_mutedMemory);
    }
  }
  /**
   * Force the video bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */
  ;

  _proto.setVideoBitrate = function setVideoBitrate(btr) {
    this._priv_bitrateInfos.manualBitrates.video.next(btr);
  }
  /**
   * Force the audio bitrate to a given value. Act as a ceil.
   * -1 to set it on AUTO Mode
   * @param {Number} btr
   */
  ;

  _proto.setAudioBitrate = function setAudioBitrate(btr) {
    this._priv_bitrateInfos.manualBitrates.audio.next(btr);
  }
  /**
   * Update the maximum video bitrate the user can switch to.
   * @param {Number} btr
   */
  ;

  _proto.setMaxVideoBitrate = function setMaxVideoBitrate(btr) {
    this._priv_bitrateInfos.maxAutoBitrates.video.next(btr);
  }
  /**
   * Update the maximum audio bitrate the user can switch to.
   * @param {Number} btr
   */
  ;

  _proto.setMaxAudioBitrate = function setMaxAudioBitrate(btr) {
    this._priv_bitrateInfos.maxAutoBitrates.audio.next(btr);
  }
  /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */
  ;

  _proto.setMaxBufferBehind = function setMaxBufferBehind(depthInSeconds) {
    this._priv_bufferOptions.maxBufferBehind$.next(depthInSeconds);
  }
  /**
   * Set the max buffer size for the buffer behind the current position.
   * Every buffer data before will be removed.
   * @param {Number} depthInSeconds
   */
  ;

  _proto.setMaxBufferAhead = function setMaxBufferAhead(depthInSeconds) {
    this._priv_bufferOptions.maxBufferAhead$.next(depthInSeconds);
  }
  /**
   * Set the max buffer size for the buffer ahead of the current position.
   * The player will stop downloading chunks when this size is reached.
   * @param {Number} sizeInSeconds
   */
  ;

  _proto.setWantedBufferAhead = function setWantedBufferAhead(sizeInSeconds) {
    this._priv_bufferOptions.wantedBufferAhead$.next(sizeInSeconds);
  }
  /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */
  ;

  _proto.getMaxBufferBehind = function getMaxBufferBehind() {
    return this._priv_bufferOptions.maxBufferBehind$.getValue();
  }
  /**
   * Returns the max buffer size for the buffer behind the current position.
   * @returns {Number}
   */
  ;

  _proto.getMaxBufferAhead = function getMaxBufferAhead() {
    return this._priv_bufferOptions.maxBufferAhead$.getValue();
  }
  /**
   * Returns the max buffer size for the buffer ahead of the current position.
   * @returns {Number}
   */
  ;

  _proto.getWantedBufferAhead = function getWantedBufferAhead() {
    return this._priv_bufferOptions.wantedBufferAhead$.getValue();
  }
  /**
   * Returns type of current keysystem (e.g. playready, widevine) if the content
   * is encrypted. null otherwise.
   * @returns {string|null}
   */
  ;

  _proto.getCurrentKeySystem = function getCurrentKeySystem() {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    return Object(get_current_key_system["a" /* default */])(this.videoElement);
  }
  /**
   * Returns every available audio tracks for the current Period.
   * @returns {Array.<Object>|null}
   */
  ;

  _proto.getAvailableAudioTracks = function getAvailableAudioTracks() {
    var _a, _b;

    if (this._priv_contentInfos === null) {
      return [];
    }

    var _this$_priv_contentIn9 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn9.currentPeriod,
        isDirectFile = _this$_priv_contentIn9.isDirectFile;

    if (isDirectFile) {
      return (_b = (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.getAvailableAudioTracks()) !== null && _b !== void 0 ? _b : [];
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return [];
    }

    return this._priv_trackChoiceManager.getAvailableAudioTracks(currentPeriod);
  }
  /**
   * Returns every available text tracks for the current Period.
   * @returns {Array.<Object>|null}
   */
  ;

  _proto.getAvailableTextTracks = function getAvailableTextTracks() {
    var _a, _b;

    if (this._priv_contentInfos === null) {
      return [];
    }

    var _this$_priv_contentIn10 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn10.currentPeriod,
        isDirectFile = _this$_priv_contentIn10.isDirectFile;

    if (isDirectFile) {
      return (_b = (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.getAvailableTextTracks()) !== null && _b !== void 0 ? _b : [];
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return [];
    }

    return this._priv_trackChoiceManager.getAvailableTextTracks(currentPeriod);
  }
  /**
   * Returns every available video tracks for the current Period.
   * @returns {Array.<Object>|null}
   */
  ;

  _proto.getAvailableVideoTracks = function getAvailableVideoTracks() {
    var _a, _b;

    if (this._priv_contentInfos === null) {
      return [];
    }

    var _this$_priv_contentIn11 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn11.currentPeriod,
        isDirectFile = _this$_priv_contentIn11.isDirectFile;

    if (isDirectFile) {
      return (_b = (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.getAvailableVideoTracks()) !== null && _b !== void 0 ? _b : [];
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return [];
    }

    return this._priv_trackChoiceManager.getAvailableVideoTracks(currentPeriod);
  }
  /**
   * Returns currently chosen audio language for the current Period.
   * @returns {string}
   */
  ;

  _proto.getAudioTrack = function getAudioTrack() {
    if (this._priv_contentInfos === null) {
      return undefined;
    }

    var _this$_priv_contentIn12 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn12.currentPeriod,
        isDirectFile = _this$_priv_contentIn12.isDirectFile;

    if (isDirectFile) {
      if (this._priv_mediaElementTrackChoiceManager === null) {
        return undefined;
      }

      return this._priv_mediaElementTrackChoiceManager.getChosenAudioTrack();
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return undefined;
    }

    return this._priv_trackChoiceManager.getChosenAudioTrack(currentPeriod);
  }
  /**
   * Returns currently chosen subtitle for the current Period.
   * @returns {string}
   */
  ;

  _proto.getTextTrack = function getTextTrack() {
    if (this._priv_contentInfos === null) {
      return undefined;
    }

    var _this$_priv_contentIn13 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn13.currentPeriod,
        isDirectFile = _this$_priv_contentIn13.isDirectFile;

    if (isDirectFile) {
      if (this._priv_mediaElementTrackChoiceManager === null) {
        return undefined;
      }

      return this._priv_mediaElementTrackChoiceManager.getChosenTextTrack();
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return undefined;
    }

    return this._priv_trackChoiceManager.getChosenTextTrack(currentPeriod);
  }
  /**
   * Returns currently chosen video track for the current Period.
   * @returns {string}
   */
  ;

  _proto.getVideoTrack = function getVideoTrack() {
    if (this._priv_contentInfos === null) {
      return undefined;
    }

    var _this$_priv_contentIn14 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn14.currentPeriod,
        isDirectFile = _this$_priv_contentIn14.isDirectFile;

    if (isDirectFile) {
      if (this._priv_mediaElementTrackChoiceManager === null) {
        return undefined;
      }

      return this._priv_mediaElementTrackChoiceManager.getChosenVideoTrack();
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return undefined;
    }

    return this._priv_trackChoiceManager.getChosenVideoTrack(currentPeriod);
  }
  /**
   * Update the audio language for the current Period.
   * @param {string} audioId
   * @throws Error - the current content has no TrackChoiceManager.
   * @throws Error - the given id is linked to no audio track.
   */
  ;

  _proto.setAudioTrack = function setAudioTrack(audioId) {
    var _a;

    if (this._priv_contentInfos === null) {
      throw new Error("No content loaded");
    }

    var _this$_priv_contentIn15 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn15.currentPeriod,
        isDirectFile = _this$_priv_contentIn15.isDirectFile;

    if (isDirectFile) {
      try {
        (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.setAudioTrackById(audioId);
        return;
      } catch (e) {
        throw new Error("player: unknown audio track");
      }
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      throw new Error("No compatible content launched.");
    }

    try {
      this._priv_trackChoiceManager.setAudioTrackByID(currentPeriod, audioId);
    } catch (e) {
      throw new Error("player: unknown audio track");
    }
  }
  /**
   * Update the text language for the current Period.
   * @param {string} sub
   * @throws Error - the current content has no TrackChoiceManager.
   * @throws Error - the given id is linked to no text track.
   */
  ;

  _proto.setTextTrack = function setTextTrack(textId) {
    var _a;

    if (this._priv_contentInfos === null) {
      throw new Error("No content loaded");
    }

    var _this$_priv_contentIn16 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn16.currentPeriod,
        isDirectFile = _this$_priv_contentIn16.isDirectFile;

    if (isDirectFile) {
      try {
        (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.setTextTrackById(textId);
        return;
      } catch (e) {
        throw new Error("player: unknown text track");
      }
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      throw new Error("No compatible content launched.");
    }

    try {
      this._priv_trackChoiceManager.setTextTrackByID(currentPeriod, textId);
    } catch (e) {
      throw new Error("player: unknown text track");
    }
  }
  /**
   * Disable subtitles for the current content.
   */
  ;

  _proto.disableTextTrack = function disableTextTrack() {
    var _a;

    if (this._priv_contentInfos === null) {
      return;
    }

    var _this$_priv_contentIn17 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn17.currentPeriod,
        isDirectFile = _this$_priv_contentIn17.isDirectFile;

    if (isDirectFile) {
      (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.disableTextTrack();
      return;
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      return;
    }

    return this._priv_trackChoiceManager.disableTextTrack(currentPeriod);
  }
  /**
   * Update the video track for the current Period.
   * @param {string} videoId
   * @throws Error - the current content has no TrackChoiceManager.
   * @throws Error - the given id is linked to no video track.
   */
  ;

  _proto.setVideoTrack = function setVideoTrack(videoId) {
    var _a;

    if (this._priv_contentInfos === null) {
      throw new Error("No content loaded");
    }

    var _this$_priv_contentIn18 = this._priv_contentInfos,
        currentPeriod = _this$_priv_contentIn18.currentPeriod,
        isDirectFile = _this$_priv_contentIn18.isDirectFile;

    if (isDirectFile) {
      try {
        (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.setVideoTrackById(videoId);
        return;
      } catch (e) {
        throw new Error("player: unknown video track");
      }
    }

    if (this._priv_trackChoiceManager === null || currentPeriod === null) {
      throw new Error("No compatible content launched.");
    }

    try {
      this._priv_trackChoiceManager.setVideoTrackByID(currentPeriod, videoId);
    } catch (e) {
      throw new Error("player: unknown video track");
    }
  }
  /**
   * Returns the current list of preferred audio tracks, in preference order.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getPreferredAudioTracks = function getPreferredAudioTracks() {
    return this._priv_preferredAudioTracks.getValue();
  }
  /**
   * Returns the current list of preferred text tracks, in preference order.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getPreferredTextTracks = function getPreferredTextTracks() {
    return this._priv_preferredTextTracks.getValue();
  }
  /**
   * Set the list of preferred audio tracks, in preference order.
   * @param {Array.<Object>} tracks
   */
  ;

  _proto.setPreferredAudioTracks = function setPreferredAudioTracks(tracks) {
    if (!Array.isArray(tracks)) {
      throw new Error("Invalid `setPreferredAudioTracks` argument. " + "Should have been an Array.");
    }

    return this._priv_preferredAudioTracks.next(tracks);
  }
  /**
   * Set the list of preferred text tracks, in preference order.
   * @param {Array.<Object>} tracks
   */
  ;

  _proto.setPreferredTextTracks = function setPreferredTextTracks(tracks) {
    if (!Array.isArray(tracks)) {
      throw new Error("Invalid `setPreferredTextTracks` argument. " + "Should have been an Array.");
    }

    return this._priv_preferredTextTracks.next(tracks);
  }
  /**
   * @returns {Array.<Object>|null}
   * @deprecated
   */
  ;

  _proto.getImageTrackData = function getImageTrackData() {
    Object(warn_once["a" /* default */])("`getImageTrackData` is deprecated." + "Please use the `parseBifThumbnails` tool instead.");

    if (this._priv_contentInfos === null) {
      return null;
    }
    /* tslint:disable deprecation */


    return this._priv_contentInfos.thumbnails;
    /* tslint:enable deprecation */
  }
  /**
   * Get minimum seek-able position.
   * @returns {number}
   */
  ;

  _proto.getMinimumPosition = function getMinimumPosition() {
    if (this._priv_contentInfos === null) {
      return null;
    }

    if (this._priv_contentInfos.isDirectFile) {
      return 0;
    }

    var manifest = this._priv_contentInfos.manifest;

    if (manifest != null) {
      return manifest.getMinimumPosition();
    }

    return null;
  }
  /**
   * Get maximum seek-able position.
   * @returns {number}
   */
  ;

  _proto.getMaximumPosition = function getMaximumPosition() {
    if (this._priv_contentInfos === null) {
      return null;
    }

    var _this$_priv_contentIn19 = this._priv_contentInfos,
        isDirectFile = _this$_priv_contentIn19.isDirectFile,
        manifest = _this$_priv_contentIn19.manifest;

    if (isDirectFile) {
      if (this.videoElement === null) {
        throw new Error("Disposed player");
      }

      return this.videoElement.duration;
    }

    if (manifest != null) {
      return manifest.getMaximumPosition();
    }

    return null;
  }
  /**
   * /!\ For demo use only! Do not touch!
   *
   * Returns every chunk buffered for a given buffer type.
   * Returns `null` if no SourceBuffer was created for this type of buffer.
   * @param {string} bufferType
   * @returns {Array.<Object>|null}
   */
  ;

  _proto.__priv_getSourceBufferContent = function __priv_getSourceBufferContent(bufferType) {
    if (this._priv_contentInfos === null || this._priv_contentInfos.sourceBuffersStore === null) {
      return null;
    }

    var queuedSourceBuffer = this._priv_contentInfos.sourceBuffersStore.get(bufferType);

    return queuedSourceBuffer === null ? null : queuedSourceBuffer.getInventory();
  }
  /**
   * Reset all state properties relative to a playing content.
   */
  ;

  _proto._priv_cleanUpCurrentContentState = function _priv_cleanUpCurrentContentState() {
    var _this4 = this;

    var _a; // lock playback of new contents while cleaning up is pending


    this._priv_contentLock$.next(true);

    this._priv_contentInfos = null;
    this._priv_trackChoiceManager = null;
    (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.dispose();
    this._priv_mediaElementTrackChoiceManager = null;
    this._priv_contentEventsMemory = {}; // EME cleaning

    var freeUpContentLock = function freeUpContentLock() {
      _this4._priv_contentLock$.next(false);
    };

    if (this.videoElement != null) {
      Object(clear_eme_session["a" /* default */])(this.videoElement).pipe(Object(catchError["a" /* catchError */])(function () {
        return empty["a" /* EMPTY */];
      })).subscribe(noop["a" /* default */], freeUpContentLock, freeUpContentLock);
    } else {
      freeUpContentLock();
    }
  }
  /**
   * Triggered each time the playback Observable emits.
   *
   * React to various events.
   *
   * @param {Object} event - payload emitted
   */
  ;

  _proto._priv_onPlaybackEvent = function _priv_onPlaybackEvent(event) {
    switch (event.type) {
      case "activePeriodChanged":
        this._priv_onActivePeriodChanged(event.value);

        break;

      case "periodBufferReady":
        this._priv_onPeriodBufferReady(event.value);

        break;

      case "periodBufferCleared":
        this._priv_onPeriodBufferCleared(event.value);

        break;

      case "reloading-media-source":
        this._priv_onReloadingMediaSource();

        break;

      case "representationChange":
        this._priv_onRepresentationChange(event.value);

        break;

      case "adaptationChange":
        this._priv_onAdaptationChange(event.value);

        break;

      case "bitrateEstimationChange":
        this._priv_onBitrateEstimationChange(event.value);

        break;

      case "manifestReady":
        this._priv_onManifestReady(event.value);

        break;

      case "warning":
        this._priv_onPlaybackWarning(event.value);

        break;

      case "loaded":
        if (this._priv_contentInfos === null) {
          log["a" /* default */].error("API: Loaded event while no content is loaded");
          return;
        }

        this._priv_contentInfos.sourceBuffersStore = event.value.sourceBuffersStore;
        break;

      case "decipherabilityUpdate":
        this.trigger("decipherabilityUpdate", event.value);
        break;

      case "added-segment":
        if (this._priv_contentInfos === null) {
          log["a" /* default */].error("API: Added segment while no content is loaded");
          return;
        } // Manage image tracks
        // @deprecated


        var _event$value = event.value,
            content = _event$value.content,
            segmentData = _event$value.segmentData;

        if (content.adaptation.type === "image") {
          if (segmentData != null && segmentData.type === "bif") {
            var imageData = segmentData.data;
            /* tslint:disable deprecation */

            this._priv_contentInfos.thumbnails = imageData;
            this.trigger("imageTrackUpdate", {
              data: this._priv_contentInfos.thumbnails
            });
            /* tslint:enable deprecation */
          }
        }

    }
  }
  /**
   * Triggered when we received a fatal error.
   * Clean-up ressources and signal that the content has stopped on error.
   * @param {Error} error
   */
  ;

  _proto._priv_onPlaybackError = function _priv_onPlaybackError(error) {
    var formattedError = formatError(error, {
      defaultCode: "NONE",
      defaultReason: "An unknown error stopped content playback."
    });
    formattedError.fatal = true;

    this._priv_stopCurrentContent$.next();

    this._priv_cleanUpCurrentContentState();

    this._priv_currentError = formattedError;
    log["a" /* default */].error("API: The player stopped because of an error:", error);

    this._priv_setPlayerState(PLAYER_STATES.STOPPED); // TODO This condition is here because the eventual callback called when the
    // player state is updated can launch a new content, thus the error will not
    // be here anymore, in which case triggering the "error" event is unwanted.
    // This is very ugly though, and we should probable have a better solution


    if (this._priv_currentError === formattedError) {
      this.trigger("error", formattedError);
    }
  }
  /**
   * Triggered when the playback Observable completes.
   * Clean-up ressources and signal that the content has ended.
   */
  ;

  _proto._priv_onPlaybackFinished = function _priv_onPlaybackFinished() {
    this._priv_stopCurrentContent$.next();

    this._priv_cleanUpCurrentContentState();

    this._priv_setPlayerState(PLAYER_STATES.ENDED);
  }
  /**
   * Triggered when we received a warning event during playback.
   * Trigger the right API event.
   * @param {Error} error
   */
  ;

  _proto._priv_onPlaybackWarning = function _priv_onPlaybackWarning(error) {
    var formattedError = formatError(error, {
      defaultCode: "NONE",
      defaultReason: "An unknown error happened."
    });
    log["a" /* default */].warn("API: Sending warning:", formattedError);
    this.trigger("warning", formattedError);
  }
  /**
   * Triggered when the Manifest has been loaded for the current content.
   * Initialize various private properties and emit initial event.
   * @param {Object} value
   */
  ;

  _proto._priv_onManifestReady = function _priv_onManifestReady(_ref2) {
    var _this5 = this;

    var manifest = _ref2.manifest;

    if (this._priv_contentInfos === null) {
      log["a" /* default */].error("API: The manifest is loaded but no content is.");
      return;
    }

    this._priv_contentInfos.manifest = manifest;
    var _this$_priv_contentIn20 = this._priv_contentInfos,
        initialAudioTrack = _this$_priv_contentIn20.initialAudioTrack,
        initialTextTrack = _this$_priv_contentIn20.initialTextTrack;
    this._priv_trackChoiceManager = new track_choice_manager_TrackChoiceManager({
      preferredAudioTracks: initialAudioTrack === undefined ? this._priv_preferredAudioTracks : new BehaviorSubject_BehaviorSubject([initialAudioTrack]),
      preferredTextTracks: initialTextTrack === undefined ? this._priv_preferredTextTracks : new BehaviorSubject_BehaviorSubject([initialTextTrack])
    });
    Object(event_emitter["b" /* fromEvent */])(manifest, "manifestUpdate").pipe(Object(takeUntil["a" /* takeUntil */])(this._priv_stopCurrentContent$)).subscribe(function () {
      // Update the tracks chosen if it changed
      if (_this5._priv_trackChoiceManager != null) {
        _this5._priv_trackChoiceManager.update();
      }
    });
  }
  /**
   * Triggered each times the current Period Changed.
   * Store and emit initial state for the Period.
   *
   * @param {Object} value
   */
  ;

  _proto._priv_onActivePeriodChanged = function _priv_onActivePeriodChanged(_ref3) {
    var period = _ref3.period;

    var _a, _b, _c, _d, _e, _f;

    if (this._priv_contentInfos === null) {
      log["a" /* default */].error("API: The active period changed but no content is loaded");
      return;
    }

    this._priv_contentInfos.currentPeriod = period;

    if (this._priv_contentEventsMemory.periodChange !== period) {
      this._priv_contentEventsMemory.periodChange = period;
      this.trigger("periodChange", period);
    }

    this.trigger("availableAudioTracksChange", this.getAvailableAudioTracks());
    this.trigger("availableTextTracksChange", this.getAvailableTextTracks());
    this.trigger("availableVideoTracksChange", this.getAvailableVideoTracks()); // Emit intial events for the Period

    if (this._priv_trackChoiceManager != null) {
      var audioTrack = this._priv_trackChoiceManager.getChosenAudioTrack(period);

      var textTrack = this._priv_trackChoiceManager.getChosenTextTrack(period);

      var videoTrack = this._priv_trackChoiceManager.getChosenVideoTrack(period);

      this.trigger("audioTrackChange", audioTrack);
      this.trigger("textTrackChange", textTrack);
      this.trigger("videoTrackChange", videoTrack);
    } else {
      this.trigger("audioTrackChange", null);
      this.trigger("textTrackChange", null);
      this.trigger("videoTrackChange", null);
    }

    this._priv_triggerAvailableBitratesChangeEvent("availableAudioBitratesChange", this.getAvailableAudioBitrates());

    this._priv_triggerAvailableBitratesChangeEvent("availableVideoBitratesChange", this.getAvailableVideoBitrates());

    var audioBitrate = (_c = (_b = (_a = this.getCurrentRepresentations()) === null || _a === void 0 ? void 0 : _a.audio) === null || _b === void 0 ? void 0 : _b.bitrate) !== null && _c !== void 0 ? _c : -1;

    this._priv_triggerCurrentBitrateChangeEvent("audioBitrateChange", audioBitrate);

    var videoBitrate = (_f = (_e = (_d = this.getCurrentRepresentations()) === null || _d === void 0 ? void 0 : _d.video) === null || _e === void 0 ? void 0 : _e.bitrate) !== null && _f !== void 0 ? _f : -1;

    this._priv_triggerCurrentBitrateChangeEvent("videoBitrateChange", videoBitrate);
  }
  /**
   * Triggered each times a new "PeriodBuffer" is ready.
   * Choose the right Adaptation for the Period and emit it.
   * @param {Object} value
   */
  ;

  _proto._priv_onPeriodBufferReady = function _priv_onPeriodBufferReady(value) {
    var type = value.type,
        period = value.period,
        adaptation$ = value.adaptation$;

    switch (type) {
      case "video":
        if (this._priv_trackChoiceManager === null) {
          log["a" /* default */].error("API: TrackChoiceManager not instanciated for a new video period");
          adaptation$.next(null);
        } else {
          this._priv_trackChoiceManager.addPeriod(type, period, adaptation$);

          this._priv_trackChoiceManager.setInitialVideoTrack(period);
        }

        break;

      case "audio":
        if (this._priv_trackChoiceManager === null) {
          log["a" /* default */].error("API: TrackChoiceManager not instanciated for a new " + type + " period");
          adaptation$.next(null);
        } else {
          this._priv_trackChoiceManager.addPeriod(type, period, adaptation$);

          this._priv_trackChoiceManager.setInitialAudioTrack(period);
        }

        break;

      case "text":
        if (this._priv_trackChoiceManager === null) {
          log["a" /* default */].error("API: TrackChoiceManager not instanciated for a new " + type + " period");
          adaptation$.next(null);
        } else {
          this._priv_trackChoiceManager.addPeriod(type, period, adaptation$);

          this._priv_trackChoiceManager.setInitialTextTrack(period);
        }

        break;

      default:
        var adaptations = period.adaptations[type];

        if (adaptations != null && adaptations.length > 0) {
          adaptation$.next(adaptations[0]);
        } else {
          adaptation$.next(null);
        }

        break;
    }
  }
  /**
   * Triggered each times we "remove" a PeriodBuffer.
   * @param {Object} value
   */
  ;

  _proto._priv_onPeriodBufferCleared = function _priv_onPeriodBufferCleared(value) {
    var type = value.type,
        period = value.period; // Clean-up track choice from TrackChoiceManager

    switch (type) {
      case "audio":
      case "text":
      case "video":
        if (this._priv_trackChoiceManager != null) {
          this._priv_trackChoiceManager.removePeriod(type, period);
        }

        break;
    } // Clean-up stored Representation and Adaptation information


    if (this._priv_contentInfos === null) {
      return;
    }

    var _this$_priv_contentIn21 = this._priv_contentInfos,
        activeAdaptations = _this$_priv_contentIn21.activeAdaptations,
        activeRepresentations = _this$_priv_contentIn21.activeRepresentations;

    if (activeAdaptations != null && activeAdaptations[period.id] != null) {
      var activePeriodAdaptations = activeAdaptations[period.id];
      delete activePeriodAdaptations[type];

      if (Object.keys(activePeriodAdaptations).length === 0) {
        delete activeAdaptations[period.id];
      }
    }

    if (activeRepresentations != null && activeRepresentations[period.id] != null) {
      var activePeriodRepresentations = activeRepresentations[period.id];
      delete activePeriodRepresentations[type];

      if (Object.keys(activePeriodRepresentations).length === 0) {
        delete activeRepresentations[period.id];
      }
    }
  }
  /**
   * Triggered each time the content is re-loaded on the MediaSource.
   */
  ;

  _proto._priv_onReloadingMediaSource = function _priv_onReloadingMediaSource() {
    if (this._priv_contentInfos !== null) {
      this._priv_contentInfos.sourceBuffersStore = null;
    }

    if (this._priv_trackChoiceManager !== null) {
      this._priv_trackChoiceManager.resetPeriods();
    }
  }
  /**
   * Triggered each times a new Adaptation is considered for the current
   * content.
   * Store given Adaptation and emit it if from the current Period.
   * @param {Object} value
   */
  ;

  _proto._priv_onAdaptationChange = function _priv_onAdaptationChange(_ref4) {
    var type = _ref4.type,
        adaptation = _ref4.adaptation,
        period = _ref4.period;

    if (this._priv_contentInfos === null) {
      log["a" /* default */].error("API: The adaptations changed but no content is loaded");
      return;
    } // lazily create this._priv_contentInfos.activeAdaptations


    if (this._priv_contentInfos.activeAdaptations === null) {
      this._priv_contentInfos.activeAdaptations = {};
    }

    var _this$_priv_contentIn22 = this._priv_contentInfos,
        activeAdaptations = _this$_priv_contentIn22.activeAdaptations,
        currentPeriod = _this$_priv_contentIn22.currentPeriod;
    var activePeriodAdaptations = activeAdaptations[period.id];

    if (activePeriodAdaptations == null) {
      var _activeAdaptations$pe;

      activeAdaptations[period.id] = (_activeAdaptations$pe = {}, _activeAdaptations$pe[type] = adaptation, _activeAdaptations$pe);
    } else {
      activePeriodAdaptations[type] = adaptation;
    }

    if (this._priv_trackChoiceManager != null && currentPeriod != null && period != null && period.id === currentPeriod.id) {
      switch (type) {
        case "audio":
          var audioTrack = this._priv_trackChoiceManager.getChosenAudioTrack(currentPeriod);

          this.trigger("audioTrackChange", audioTrack);
          var availableAudioBitrates = this.getAvailableAudioBitrates();

          this._priv_triggerAvailableBitratesChangeEvent("availableAudioBitratesChange", availableAudioBitrates);

          break;

        case "text":
          var textTrack = this._priv_trackChoiceManager.getChosenTextTrack(currentPeriod);

          this.trigger("textTrackChange", textTrack);
          break;

        case "video":
          var videoTrack = this._priv_trackChoiceManager.getChosenVideoTrack(currentPeriod);

          this.trigger("videoTrackChange", videoTrack);
          var availableVideoBitrates = this.getAvailableVideoBitrates();

          this._priv_triggerAvailableBitratesChangeEvent("availableVideoBitratesChange", availableVideoBitrates);

          break;
      }
    }
  }
  /**
   * Triggered each times a new Representation is considered during playback.
   *
   * Store given Representation and emit it if from the current Period.
   *
   * @param {Object} obj
   */
  ;

  _proto._priv_onRepresentationChange = function _priv_onRepresentationChange(_ref5) {
    var type = _ref5.type,
        period = _ref5.period,
        representation = _ref5.representation;

    var _a;

    if (this._priv_contentInfos === null) {
      log["a" /* default */].error("API: The representations changed but no content is loaded");
      return;
    } // lazily create this._priv_contentInfos.activeRepresentations


    if (this._priv_contentInfos.activeRepresentations === null) {
      this._priv_contentInfos.activeRepresentations = {};
    }

    var _this$_priv_contentIn23 = this._priv_contentInfos,
        activeRepresentations = _this$_priv_contentIn23.activeRepresentations,
        currentPeriod = _this$_priv_contentIn23.currentPeriod;
    var activePeriodRepresentations = activeRepresentations[period.id];

    if (activePeriodRepresentations == null) {
      var _activeRepresentation;

      activeRepresentations[period.id] = (_activeRepresentation = {}, _activeRepresentation[type] = representation, _activeRepresentation);
    } else {
      activePeriodRepresentations[type] = representation;
    }

    var bitrate = (_a = representation === null || representation === void 0 ? void 0 : representation.bitrate) !== null && _a !== void 0 ? _a : -1;

    if (period != null && currentPeriod != null && currentPeriod.id === period.id) {
      if (type === "video") {
        this._priv_triggerCurrentBitrateChangeEvent("videoBitrateChange", bitrate);
      } else if (type === "audio") {
        this._priv_triggerCurrentBitrateChangeEvent("audioBitrateChange", bitrate);
      }
    }
  }
  /**
   * Triggered each time a bitrate estimate is calculated.
   *
   * Emit it.
   *
   * @param {Object} value
   */
  ;

  _proto._priv_onBitrateEstimationChange = function _priv_onBitrateEstimationChange(_ref6) {
    var type = _ref6.type,
        bitrate = _ref6.bitrate;

    if (bitrate != null) {
      this._priv_bitrateInfos.lastBitrates[type] = bitrate;
    }

    this.trigger("bitrateEstimationChange", {
      type: type,
      bitrate: bitrate
    });
  }
  /**
   * Triggered each time the videoElement alternates between play and pause.
   *
   * Emit the info through the right Subject.
   *
   * @param {Boolean} isPlaying
   */
  ;

  _proto._priv_onPlayPauseNext = function _priv_onPlayPauseNext(isPlaying) {
    if (this.videoElement === null) {
      throw new Error("Disposed player");
    }

    this._priv_playing$.next(isPlaying);
  }
  /**
   * Triggered each time a textTrack is added to the video DOM Element.
   *
   * Trigger the right Player Event.
   *
   * @param {Array.<TextTrackElement>} tracks
   */
  ;

  _proto._priv_onNativeTextTracksNext = function _priv_onNativeTextTracksNext(tracks) {
    this.trigger("nativeTextTracksChange", tracks);
  }
  /**
   * Triggered each time the player state updates.
   *
   * Trigger the right Player Event.
   *
   * @param {string} newState
   */
  ;

  _proto._priv_setPlayerState = function _priv_setPlayerState(newState) {
    if (this.state !== newState) {
      this.state = newState;
      log["a" /* default */].info("API: playerStateChange event", newState);
      this.trigger("playerStateChange", newState);
    }
  }
  /**
   * Triggered each time a new clock tick object is emitted.
   *
   * Trigger the right Player Event
   *
   * @param {Object} clockTick
   */
  ;

  _proto._priv_triggerPositionUpdate = function _priv_triggerPositionUpdate(clockTick) {
    if (this._priv_contentInfos === null) {
      log["a" /* default */].warn("API: Cannot perform time update: no content loaded.");
      return;
    }

    if (this.state === PLAYER_STATES.RELOADING) {
      return;
    }

    var _this$_priv_contentIn24 = this._priv_contentInfos,
        isDirectFile = _this$_priv_contentIn24.isDirectFile,
        manifest = _this$_priv_contentIn24.manifest;

    if (!isDirectFile && manifest === null || clockTick == null) {
      return;
    }

    var maximumPosition = manifest !== null ? manifest.getMaximumPosition() : undefined;
    var positionData = {
      position: clockTick.currentTime,
      duration: clockTick.duration,
      playbackRate: clockTick.playbackRate,
      maximumBufferTime: maximumPosition,
      // TODO fix higher up?
      bufferGap: isFinite(clockTick.bufferGap) ? clockTick.bufferGap : 0
    };

    if (manifest !== null && maximumPosition != null && manifest.isLive && clockTick.currentTime > 0) {
      var ast = manifest.availabilityStartTime == null ? 0 : manifest.availabilityStartTime;
      positionData.wallClockTime = clockTick.currentTime + ast;
      positionData.liveGap = maximumPosition - clockTick.currentTime;
    }

    this.trigger("positionUpdate", positionData);
  }
  /**
   * Trigger one of the "availableBitratesChange" event only if it changed from
   * the previously stored value.
   * @param {string} event
   * @param {Array.<number>} newVal
   */
  ;

  _proto._priv_triggerAvailableBitratesChangeEvent = function _priv_triggerAvailableBitratesChangeEvent(event, newVal) {
    var prevVal = this._priv_contentEventsMemory[event];

    if (prevVal === undefined || Object(are_arrays_of_numbers_equal["a" /* default */])(newVal, prevVal)) {
      this._priv_contentEventsMemory[event] = newVal;
      this.trigger(event, newVal);
    }
  }
  /**
   * Trigger one of the "bitrateChange" event only if it changed from the
   * previously stored value.
   * @param {string} event
   * @param {number} newVal
   */
  ;

  _proto._priv_triggerCurrentBitrateChangeEvent = function _priv_triggerCurrentBitrateChangeEvent(event, newVal) {
    if (newVal !== this._priv_contentEventsMemory[event]) {
      this._priv_contentEventsMemory[event] = newVal;
      this.trigger(event, newVal);
    }
  };

  public_api_createClass(Player, null, [{
    key: "ErrorTypes",
    get: function get() {
      return error_codes["b" /* ErrorTypes */];
    }
    /** All possible Error codes emitted by the RxPlayer. */

  }, {
    key: "ErrorCodes",
    get: function get() {
      return error_codes["a" /* ErrorCodes */];
    }
    /**
     * Current log level.
     * Update current log level.
     * Should be either (by verbosity ascending):
     *   - "NONE"
     *   - "ERROR"
     *   - "WARNING"
     *   - "INFO"
     *   - "DEBUG"
     * Any other value will be translated to "NONE".
     */

  }, {
    key: "LogLevel",
    get: function get() {
      return log["a" /* default */].getLevel();
    },
    set: function set(logLevel) {
      log["a" /* default */].setLevel(logLevel);
    }
  }]);

  return Player;
}(event_emitter["a" /* default */]);

public_api_Player.version =
/*PLAYER_VERSION*/
"3.19.0";
/* harmony default export */ var public_api = (public_api_Player);
// CONCATENATED MODULE: ./src/core/api/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var api = (public_api);
// CONCATENATED MODULE: ./src/features/initialize_features.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Selects the features to include based on environment variables.
 *
 * @param {Object} features
 */

function initializeFeaturesObject() {
  /* tslint:disable no-unsafe-any */

  /* tslint:disable no-var-requires */
  if (true) {
    features["a" /* default */].emeManager = __webpack_require__(140)["default"];
  }
  /* tslint:enable no-var-requires */

  /* tslint:disable no-var-requires */


  if (true) {
    features["a" /* default */].imageBuffer = __webpack_require__(204)["default"];
    features["a" /* default */].imageParser = __webpack_require__(187)["default"];
  }
  /* tslint:enable no-var-requires */
  // Feature switching the Native TextTrack implementation


  var HAS_NATIVE_MODE =  true || false;
  /* tslint:disable no-var-requires */

  if (true) {
    features["a" /* default */].transports.smooth = __webpack_require__(197)["default"];
  }

  if (true) {
    features["a" /* default */].transports.dash = __webpack_require__(196)["default"];
  }

  if (false) {}

  if (true) {
    features["a" /* default */].transports.metaplaylist = __webpack_require__(200)["default"];
  }
  /* tslint:enable no-var-requires */

  /* tslint:disable no-var-requires */


  if (HAS_NATIVE_MODE) {
    features["a" /* default */].nativeTextTracksBuffer = __webpack_require__(202)["default"];

    if (true) {
      features["a" /* default */].nativeTextTracksParsers.vtt = __webpack_require__(203)["default"];
    }

    if (true) {
      features["a" /* default */].nativeTextTracksParsers.ttml = __webpack_require__(205)["default"];
    }

    if (true) {
      features["a" /* default */].nativeTextTracksParsers.sami = __webpack_require__(189)["default"];
    }

    if (true) {
      features["a" /* default */].nativeTextTracksParsers.srt = __webpack_require__(190)["default"];
    }
  }
  /* tslint:enable no-var-requires */
  // Feature switching the HTML TextTrack implementation


  var HAS_HTML_MODE =  true || false;
  /* tslint:disable no-var-requires */

  if (HAS_HTML_MODE) {
    features["a" /* default */].htmlTextTracksBuffer = __webpack_require__(201)["default"];

    if (true) {
      features["a" /* default */].htmlTextTracksParsers.sami = __webpack_require__(191)["default"];
    }

    if (true) {
      features["a" /* default */].htmlTextTracksParsers.ttml = __webpack_require__(198)["default"];
    }

    if (true) {
      features["a" /* default */].htmlTextTracksParsers.srt = __webpack_require__(192)["default"];
    }

    if (true) {
      features["a" /* default */].htmlTextTracksParsers.vtt = __webpack_require__(199)["default"];
    }
    /* tslint:enable no-var-requires */

  }
  /* tslint:disable no-var-requires */


  if (true) {
    var initDirectFile = __webpack_require__(193)["default"];

    var mediaElementTrackChoiceManager = __webpack_require__(194)["default"];

    features["a" /* default */].directfile = {
      initDirectFile: initDirectFile,
      mediaElementTrackChoiceManager: mediaElementTrackChoiceManager
    };
  }
  /* tslint:enable no-var-requires */

  /* tslint:enable no-unsafe-any */

}
// CONCATENATED MODULE: ./src/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This file exports a Player class with a default feature set (depends on the
 * environment variables set at build).
 *
 * This is the class used from a regular build.
 */


 // set initial features according to environment variables

initializeFeaturesObject();

if (false) {}

/* harmony default export */ var src = __webpack_exports__["default"] = (api);

/***/ }),
/* 196 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/transports/utils/document_manifest_loader.ts
var document_manifest_loader = __webpack_require__(115);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(27);

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(11);

// EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
var request = __webpack_require__(24);

// EXTERNAL MODULE: ./src/utils/take_first_set.ts
var take_first_set = __webpack_require__(16);

// CONCATENATED MODULE: ./src/transports/dash/image_pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @param {Object} args
 * @returns {Observable}
 */

function imageLoader(_ref) {
  var segment = _ref.segment,
      url = _ref.url;

  if (segment.isInit || url === null) {
    return Object(of["a" /* of */])({
      type: "data-created",
      value: {
        responseData: null
      }
    });
  }

  return Object(request["a" /* default */])({
    url: url,
    responseType: "arraybuffer",
    sendProgressEvents: true
  });
}
/**
 * @param {Object} args
 * @returns {Observable}
 */

function imageParser(_ref2) {
  var response = _ref2.response,
      content = _ref2.content;
  var segment = content.segment,
      period = content.period;
  var data = response.data,
      isChunked = response.isChunked;

  if (content.segment.isInit) {
    // image init segment has no use
    return Object(of["a" /* of */])({
      type: "parsed-init-segment",
      value: {
        initializationData: null,
        segmentProtections: [],
        initTimescale: undefined
      }
    });
  }

  if (isChunked) {
    throw new Error("Image data should not be downloaded in chunks");
  }

  var chunkOffset = Object(take_first_set["a" /* default */])(segment.timestampOffset, 0); // TODO image Parsing should be more on the sourceBuffer side, no?

  if (data === null || features["a" /* default */].imageParser === null) {
    return Object(of["a" /* of */])({
      type: "parsed-segment",
      value: {
        chunkData: null,
        chunkInfos: segment.timescale > 0 ? {
          duration: segment.isInit ? 0 : segment.duration,
          time: segment.isInit ? -1 : segment.time,
          timescale: segment.timescale
        } : null,
        chunkOffset: chunkOffset,
        appendWindow: [period.start, period.end]
      }
    });
  }

  var bifObject = features["a" /* default */].imageParser(new Uint8Array(data));
  var thumbsData = bifObject.thumbs;
  return Object(of["a" /* of */])({
    type: "parsed-segment",
    value: {
      chunkData: {
        data: thumbsData,
        start: 0,
        end: Number.MAX_VALUE,
        timescale: 1,
        type: "bif"
      },
      chunkInfos: {
        time: 0,
        duration: Number.MAX_VALUE,
        timescale: bifObject.timescale
      },
      chunkOffset: chunkOffset,
      appendWindow: [period.start, period.end]
    }
  });
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(215);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(179);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(47);

// EXTERNAL MODULE: ./src/manifest/index.ts + 5 modules
var src_manifest = __webpack_require__(66);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(3);

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(14);

// EXTERNAL MODULE: ./src/utils/resolve_url.ts
var resolve_url = __webpack_require__(61);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/check_manifest_ids.ts
var check_manifest_ids = __webpack_require__(114);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/extract_minimum_availability_time_offset.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * From 0 to N baseURL elements takes the minimum availabilityTimeOffset
 * possible.
 *
 * `0` if no baseURL was given (which means `no delay added`: coherent with how
 * this value is used).
 *
 * Taking the minimum time allow to simplify its processing:
 * Instead of having multiple URL each with a different pool of available
 * segment at a given instant, let's always consider every URLs by aligning with
 * the one with the most segment.
 *
 * @param {Array.<Object>} baseURLs
 */
function extractMinimumAvailabilityTimeOffset(baseURLs) {
  return baseURLs.length === 0 ? 0 : baseURLs.reduce(function (acc, baseURL) {
    var _a;

    return Math.min((_a = baseURL.attributes.availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0, acc);
  }, Infinity);
}
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/get_clock_offset.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Get difference between the server's clock, in milliseconds and the return of
 * the JS function `performance.now`.
 * This property allows to calculate the server time at any moment.
 *
 * `undefined` if we could not define such offset (in which case, you could have
 * to rely on the user's clock instead).
 *
 * For example, a response of 1000 would mean that performance.now() is 1 second
 * behind the server's time.
 * @param {string} serverClock
 * @returns {number|undefined}
 */

function getClockOffset(serverClock) {
  var httpOffset = Date.parse(serverClock) - performance.now();

  if (isNaN(httpOffset)) {
    log["a" /* default */].warn("DASH Parser: Invalid clock received: ", serverClock);
    return undefined;
  }

  return httpOffset;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/get_http_utc-timing_url.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Object} mpdIR
 * @returns {string|undefined}
 */
function getHTTPUTCTimingURL(mpdIR) {
  var UTCTimingHTTP = mpdIR.children.utcTimings.filter(function (utcTiming) {
    return utcTiming.schemeIdUri === "urn:mpeg:dash:utc:http-iso:2014" && utcTiming.value != null;
  });
  return UTCTimingHTTP.length > 0 ? UTCTimingHTTP[0].value : undefined;
}
// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_last_time_from_adaptation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns "last time of reference" from the adaptation given, considering a
 * dynamic content.
 * Undefined if a time could not be found.
 * Null if the Adaptation has no segments (it could be that it didn't started or
 * that it already finished for example).
 *
 * We consider the earliest last time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined|null}
 */
function getLastPositionFromAdaptation(adaptation) {
  var representations = adaptation.representations;
  var min = null;

  for (var i = 0; i < representations.length; i++) {
    var lastPosition = representations[i].index.getLastPosition();

    if (lastPosition === undefined) {
      // we cannot tell
      return undefined;
    }

    if (lastPosition !== null) {
      min = min == null ? lastPosition : Math.min(min, lastPosition);
    }
  }

  if (min === null) {
    // It means that all positions were null === no segments (yet?)
    return null;
  }

  return min;
}
// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_maximum_position.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} manifest
 * @returns {number | undefined}
 */

function getMaximumPosition(manifest) {
  for (var i = manifest.periods.length - 1; i >= 0; i--) {
    var periodAdaptations = manifest.periods[i].adaptations;
    var firstAudioAdaptationFromPeriod = periodAdaptations.audio === undefined ? undefined : periodAdaptations.audio[0];
    var firstVideoAdaptationFromPeriod = periodAdaptations.video === undefined ? undefined : periodAdaptations.video[0];

    if (firstAudioAdaptationFromPeriod !== undefined || firstVideoAdaptationFromPeriod !== undefined) {
      // null == no segment
      var maximumAudioPosition = null;
      var maximumVideoPosition = null;

      if (firstAudioAdaptationFromPeriod !== undefined) {
        var lastPosition = getLastPositionFromAdaptation(firstAudioAdaptationFromPeriod);

        if (lastPosition === undefined) {
          return undefined;
        }

        maximumAudioPosition = lastPosition;
      }

      if (firstVideoAdaptationFromPeriod !== undefined) {
        var _lastPosition = getLastPositionFromAdaptation(firstVideoAdaptationFromPeriod);

        if (_lastPosition === undefined) {
          return undefined;
        }

        maximumVideoPosition = _lastPosition;
      }

      if (firstAudioAdaptationFromPeriod !== undefined && maximumAudioPosition === null || firstVideoAdaptationFromPeriod !== undefined && maximumVideoPosition === null) {
        log["a" /* default */].info("Parser utils: found Period with no segment. ", "Going to previous one to calculate last position");
        return undefined;
      }

      if (maximumVideoPosition !== null) {
        if (maximumAudioPosition !== null) {
          return Math.min(maximumAudioPosition, maximumVideoPosition);
        }

        return maximumVideoPosition;
      }

      if (maximumAudioPosition !== null) {
        return maximumAudioPosition;
      }
    }
  }
}
// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_first_time_from_adaptation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns "first time of reference" from the adaptation given, considering a
 * dynamic content.
 * Undefined if a time could not be found.
 *
 * We consider the latest first time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined}
 */
function getFirstPositionFromAdaptation(adaptation) {
  var representations = adaptation.representations;
  var max = null;

  for (var i = 0; i < representations.length; i++) {
    var firstPosition = representations[i].index.getFirstPosition();

    if (firstPosition === undefined) {
      // we cannot tell
      return undefined;
    }

    if (firstPosition !== null) {
      max = max == null ? firstPosition : Math.max(max, firstPosition);
    }
  }

  if (max === null) {
    // It means that all positions were null === no segments (yet?)
    return null;
  }

  return max;
}
// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_minimum_position.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} manifest
 * @returns {number | undefined}
 */

function getMinimumPosition(manifest) {
  for (var i = 0; i <= manifest.periods.length - 1; i++) {
    var periodAdaptations = manifest.periods[i].adaptations;
    var firstAudioAdaptationFromPeriod = periodAdaptations.audio === undefined ? undefined : periodAdaptations.audio[0];
    var firstVideoAdaptationFromPeriod = periodAdaptations.video === undefined ? undefined : periodAdaptations.video[0];

    if (firstAudioAdaptationFromPeriod !== undefined || firstVideoAdaptationFromPeriod !== undefined) {
      // null == no segment
      var minimumAudioPosition = null;
      var minimumVideoPosition = null;

      if (firstAudioAdaptationFromPeriod !== undefined) {
        var firstPosition = getFirstPositionFromAdaptation(firstAudioAdaptationFromPeriod);

        if (firstPosition === undefined) {
          return undefined;
        }

        minimumAudioPosition = firstPosition;
      }

      if (firstVideoAdaptationFromPeriod !== undefined) {
        var _firstPosition = getFirstPositionFromAdaptation(firstVideoAdaptationFromPeriod);

        if (_firstPosition === undefined) {
          return undefined;
        }

        minimumVideoPosition = _firstPosition;
      }

      if (firstAudioAdaptationFromPeriod !== undefined && minimumAudioPosition === null || firstVideoAdaptationFromPeriod !== undefined && minimumVideoPosition === null) {
        log["a" /* default */].info("Parser utils: found Period with no segment. ", "Going to next one to calculate first position");
        return undefined;
      }

      if (minimumVideoPosition !== null) {
        if (minimumAudioPosition !== null) {
          return Math.max(minimumAudioPosition, minimumVideoPosition);
        }

        return minimumVideoPosition;
      }

      if (minimumAudioPosition !== null) {
        return minimumAudioPosition;
      }
    }
  }
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/get_minimum_and_maximum_positions.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} manifest
 * @returns {Array.<number>}
 */

function getMinimumAndMaximumPosition(manifest) {
  if (manifest.periods.length === 0) {
    throw new Error("DASH Parser: no period available for a dynamic content");
  }

  return [getMinimumPosition(manifest), getMaximumPosition(manifest)];
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/BaseURL.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse "BaseURL" Element attributes in a DASH MPD.
 * @param {Element} root
 * @returns {Object}
 */
function parseBaseURL(root) {
  var attributes = {};
  var value = root.textContent;

  if (value === null || value.length === 0) {
    return undefined;
  }

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "availabilityTimeOffset":
        attributes.availabilityTimeOffset = attribute.value === "INF" ? Infinity : parseInt(attribute.value, 10);
        break;
    }
  }

  return {
    value: value,
    attributes: attributes
  };
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentComponent.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a "ContentComponent" Element in a DASH MPD.
 * @param {Element} root
 * @returns {Object}
 */
function parseContentComponent(root) {
  var ret = {};

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "id":
        ret.id = attribute.value;
        break;

      case "lang":
        ret.language = attribute.value;
        break;

      case "contentType":
        ret.contentType = attribute.value;
        break;

      case "par":
        ret.par = attribute.value;
        break;
    }
  }

  return ret;
}
// CONCATENATED MODULE: ./src/utils/base64_to_uint8array.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* tslint:disable max-line-length */

/**
 * Convert Base64 string to Uint8Array.
 * Largely taken from:
 * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding
 * Tried hard to understand it but nope.
 * Still seems to work though!
 * @param {string} sBase64
 * @returns {Uint8Array}
 */

/* tslint:enable max-line-length */
function base64ToUint8Array(sBase64) {
  // remove invalid base64 characters
  var base64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, "");
  var len = base64Enc.length;
  var outputLength = len * 3 + 1 >>> 2;
  var output = new Uint8Array(outputLength);

  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, idx = 0; idx < len; idx++) {
    nMod4 = idx & 3;
    nUint24 |= b64ToUint6(base64Enc.charCodeAt(idx)) << 18 - nMod4 * 6;

    if (nMod4 === 3 || len - idx === 1) {
      for (nMod3 = 0; nMod3 < 3 && nOutIdx < outputLength; nMod3++, nOutIdx++) {
        output[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
      }

      nUint24 = 0;
    }
  }

  return output;
}
/**
 * Don't ask.
 * @param {number} nChr
 * @returns {number}
 */

function b64ToUint6(nChr) {
  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
}
// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(1);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentProtection.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {NodeList} contentProtectionChildren
 * @Returns {Object}
 */

function parseContentProtectionChildren(contentProtectionChildren) {
  var cencPssh = [];

  for (var i = 0; i < contentProtectionChildren.length; i++) {
    if (contentProtectionChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = contentProtectionChildren[i];

      if (currentElement.nodeName === "cenc:pssh") {
        var content = currentElement.textContent;

        if (content !== null && content.length > 0) {
          cencPssh.push(base64ToUint8Array(content));
        }
      }
    }
  }

  return {
    cencPssh: cencPssh
  };
}
/**
 * Parse the "ContentProtection" node of a MPD.
 * @param {Element} root
 * @returns {Object}
 */


function parseContentProtectionAttributes(root) {
  var schemeIdUri;
  var value;
  var keyId;

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "schemeIdUri":
        schemeIdUri = attribute.value;
        break;

      case "value":
        value = attribute.value;
        break;

      case "cenc:default_KID":
        keyId = Object(byte_parsing["j" /* hexToBytes */])(attribute.value.replace(/-/g, ""));
    }
  }

  return {
    schemeIdUri: schemeIdUri,
    value: value,
    keyId: keyId
  };
}
/**
 * @param {Element} contentProtectionElement
 * @returns {Object}
 */


function parseContentProtection(contentProtectionElement) {
  return {
    children: parseContentProtectionChildren(contentProtectionElement.childNodes),
    attributes: parseContentProtectionAttributes(contentProtectionElement)
  };
}
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(7);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// XML-Schema

/* tslint:disable:max-line-length */
// <http://standards.iso.org/ittf/PubliclyAvailableStandards/MPEG-DASH_schema_files/DASH-MPD.xsd>

/* tslint:enable:max-line-length */

var iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;
var rangeRe = /([0-9]+)-([0-9]+)/;
/**
 * Parse MPD boolean attributes.
 * @param {string} str
 * @returns {Boolean}
 */

function parseBoolean(str) {
  return str === "true";
}
/**
 * Parse some MPD attributes.
 * @param {string} str
 * @returns {Boolean|Number}
 */


function parseIntOrBoolean(str) {
  if (str === "true") {
    return true;
  }

  if (str === "false") {
    return false;
  }

  return parseInt(str, 10);
}
/**
 * Parse MPD date attributes.
 * @param {string} str
 * @returns {Date}
 */


function parseDateTime(str) {
  return new Date(Date.parse(str)).getTime() / 1000;
}
/**
 * Parse MPD ISO8601 duration attributes into seconds.
 * @param {string} date
 * @returns {Number}
 */


function parseDuration(date) {
  if (!Object(is_non_empty_string["a" /* default */])(date)) {
    return 0;
  }

  var match = iso8601Duration.exec(date);

  if (match == null) {
    throw new Error(date + " is not a valid ISO8601 duration");
  }

  return parseFloat(Object(is_non_empty_string["a" /* default */])(match[2]) ? match[2] : "0") * 365 * 24 * 60 * 60 + parseFloat(Object(is_non_empty_string["a" /* default */])(match[4]) ? match[4] : "0") * 30 * 24 * 60 * 60 + parseFloat(Object(is_non_empty_string["a" /* default */])(match[6]) ? match[6] : "0") * 24 * 60 * 60 + parseFloat(Object(is_non_empty_string["a" /* default */])(match[8]) ? match[8] : "0") * 60 * 60 + parseFloat(Object(is_non_empty_string["a" /* default */])(match[10]) ? match[10] : "0") * 60 + parseFloat(Object(is_non_empty_string["a" /* default */])(match[12]) ? match[12] : "0");
}
/**
 * Parse MPD byterange attributes into arrays of two elements: the start and
 * the end.
 * @param {string} str
 * @returns {Array.<Number>}
 */


function parseByteRange(str) {
  var match = rangeRe.exec(str);

  if (match == null) {
    return null;
  } else {
    return [+match[1], +match[2]];
  }
}
/**
 * @param {Element} root
 * @returns {Object}
 */


function parseScheme(root) {
  var schemeIdUri;
  var value;

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "schemeIdUri":
        schemeIdUri = attribute.value;
        break;

      case "value":
        value = attribute.value;
        break;
    }
  }

  return {
    schemeIdUri: schemeIdUri,
    value: value
  };
}


// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Initialization.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Element} root
 * @returns {Object}
 */

function parseInitialization(root) {
  var parsedInitialization = {};

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "range":
        {
          var range = parseByteRange(attribute.value);

          if (range == null) {
            log["a" /* default */].warn("DASH: invalid range (\"" + attribute.value + "\")");
          } else {
            parsedInitialization.range = range;
          }
        }
        break;

      case "sourceURL":
        parsedInitialization.media = attribute.value;
        break;
    }
  }

  return parsedInitialization;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentBase.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @param {Element} root
 * @returns {Object}
 */

function parseSegmentBase(root) {
  var attributes = {};
  var segmentBaseChildren = root.childNodes;

  for (var i = 0; i < segmentBaseChildren.length; i++) {
    if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = segmentBaseChildren[i];

      if (currentNode.nodeName === "Initialization") {
        attributes.initialization = parseInitialization(currentNode);
      }
    }
  }

  for (var _i = 0; _i < root.attributes.length; _i++) {
    var attribute = root.attributes[_i];

    switch (attribute.name) {
      case "timescale":
        {
          var _timescale = parseInt(attribute.value, 10);

          if (isNaN(_timescale)) {
            log["a" /* default */].warn("DASH: invalid timescale (\"" + attribute.value + "\")");
          } else {
            attributes.timescale = _timescale;
          }
        }
        break;

      case "presentationTimeOffset":
        {
          var _presentationTimeOffset = parseFloat(attribute.value);

          if (isNaN(_presentationTimeOffset)) {
            log["a" /* default */].warn("DASH: invalid presentationTimeOffset (\"" + attribute.value + "\")");
          } else {
            attributes.presentationTimeOffset = _presentationTimeOffset;
          }
        }
        break;

      case "indexRange":
        var indexRange = parseByteRange(attribute.value);

        if (!Array.isArray(indexRange)) {
          log["a" /* default */].warn("DASH: invalid indexRange (\"" + attribute.value + "\")");
        } else {
          attributes.indexRange = indexRange;
        }

        break;

      case "indexRangeExact":
        attributes.indexRangeExact = parseBoolean(attribute.value);
        break;

      case "availabilityTimeOffset":
        {
          var availabilityTimeOffset = parseFloat(attribute.value);

          if (isNaN(availabilityTimeOffset)) {
            log["a" /* default */].warn("DASH: invalid availabilityTimeOffset (\"" + attribute.value + "\")");
          } else {
            attributes.availabilityTimeOffset = availabilityTimeOffset;
          }
        }
        break;

      case "availabilityTimeComplete":
        attributes.availabilityTimeComplete = parseBoolean(attribute.value);
        break;

      case "duration":
        {
          var duration = parseInt(attribute.value, 10);

          if (isNaN(duration)) {
            log["a" /* default */].warn("DASH: invalid duration (\"" + attribute.value + "\")");
          } else {
            attributes.duration = duration;
          }
        }
        break;

      case "startNumber":
        {
          var startNumber = parseInt(attribute.value, 10);

          if (isNaN(startNumber)) {
            log["a" /* default */].warn("DASH: invalid startNumber (\"" + attribute.value + "\")");
          } else {
            attributes.startNumber = startNumber;
          }
        }
        break;
    }
  }

  var timescale = attributes.timescale == null ? 1 : attributes.timescale;
  var indexRangeExact = attributes.indexRangeExact === true;
  var availabilityTimeComplete = attributes.availabilityTimeComplete == null ? true : attributes.availabilityTimeComplete;
  return Object(object_assign["a" /* default */])(attributes, {
    availabilityTimeComplete: availabilityTimeComplete,
    indexRangeExact: indexRangeExact,
    timeline: [],
    timescale: timescale
  });
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentURL.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Element} root
 * @returns {Object}
 */

function parseSegmentURL(root) {
  var parsedSegmentURL = {};

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "media":
        parsedSegmentURL.media = attribute.value;
        break;

      case "indexRange":
        {
          var indexRange = parseByteRange(attribute.value);

          if (!Array.isArray(indexRange)) {
            log["a" /* default */].warn("DASH: invalid indexRange (\"" + attribute.value + "\")");
          } else {
            parsedSegmentURL.indexRange = indexRange;
          }
        }
        break;

      case "index":
        parsedSegmentURL.index = attribute.value;
        break;

      case "mediaRange":
        {
          var mediaRange = parseByteRange(attribute.value);

          if (!Array.isArray(mediaRange)) {
            log["a" /* default */].warn("DASH: invalid mediaRange (\"" + attribute.value + "\")");
          } else {
            parsedSegmentURL.mediaRange = mediaRange;
          }
        }
        break;
    }
  }

  return parsedSegmentURL;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentList.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Element} root
 * @returns {Object}
 */

function parseSegmentList(root) {
  var base = parseSegmentBase(root);
  var list = [];
  var segmentListChildren = root.childNodes;

  for (var i = 0; i < segmentListChildren.length; i++) {
    if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = segmentListChildren[i];

      if (currentNode.nodeName === "SegmentURL") {
        var segmentURL = parseSegmentURL(currentNode);
        list.push(segmentURL);
      }
    }
  }

  var baseDuration = base.duration;

  if (baseDuration == null) {
    throw new Error("Invalid SegmentList: no duration");
  }

  return Object(object_assign["a" /* default */])(base, {
    list: list,
    duration: baseDuration
  });
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/S.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a given <S> element in the MPD into a JS Object.
 * @param {Element} root
 * @returns {Object}
 */

function parseS(root) {
  var parsedS = {};

  for (var j = 0; j < root.attributes.length; j++) {
    var attribute = root.attributes[j];

    switch (attribute.name) {
      case "t":
        var start = parseInt(attribute.value, 10);

        if (isNaN(start)) {
          log["a" /* default */].warn("DASH: invalid t (\"" + attribute.value + "\")");
        } else {
          parsedS.start = start;
        }

        break;

      case "d":
        var duration = parseInt(attribute.value, 10);

        if (isNaN(duration)) {
          log["a" /* default */].warn("DASH: invalid d (\"" + attribute.value + "\")");
        } else {
          parsedS.duration = duration;
        }

        break;

      case "r":
        var repeatCount = parseInt(attribute.value, 10);

        if (isNaN(repeatCount)) {
          log["a" /* default */].warn("DASH: invalid r (\"" + attribute.value + "\")");
        } else {
          parsedS.repeatCount = repeatCount;
        }

        break;
    }
  }

  return parsedS;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTimeline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Element} root
 * @returns {Function}
 */

function createSegmentTimelineParser(root) {
  var result = null;
  return function () {
    if (result === null) {
      var parsedS = [];
      var timelineChildren = root.getElementsByTagName("S");
      var timelineChildrenLength = timelineChildren.length;

      for (var i = 0; i < timelineChildrenLength; i++) {
        var currentElement = timelineChildren[i];
        var s = parseS(currentElement);
        parsedS.push(s);
      }

      result = parsedS;
    }

    return result;
  };
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTemplate.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Parse initialization attribute found in segment Template to
 * correspond to the initialization found in a regular segmentBase.
 * @param {string} attrValue
 * @returns {Object}
 */

function parseInitializationAttribute(attrValue) {
  return {
    media: attrValue
  };
}
/**
 * @param {Element} root
 * @returns {Object}
 */


function parseSegmentTemplate(root) {
  var base = parseSegmentBase(root);
  var ret;
  var index;
  var availabilityTimeOffset;
  var media;
  var bitstreamSwitching;
  var parseTimeline;

  for (var i = 0; i < root.childNodes.length; i++) {
    if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = root.childNodes[i];

      if (currentNode.nodeName === "SegmentTimeline") {
        parseTimeline = createSegmentTimelineParser(currentNode);
      }
    }
  }

  for (var _i = 0; _i < root.attributes.length; _i++) {
    var attribute = root.attributes[_i];

    switch (attribute.nodeName) {
      case "initialization":
        if (base.initialization == null) {
          base.initialization = parseInitializationAttribute(attribute.value);
        }

        break;

      case "index":
        index = attribute.value;
        break;

      case "availabilityTimeOffset":
        availabilityTimeOffset = attribute.value;
        break;

      case "media":
        media = attribute.value;
        break;

      case "bitstreamSwitching":
        bitstreamSwitching = parseBoolean(attribute.value);
        break;
    }
  }

  if (parseTimeline != null) {
    ret = Object(object_assign["a" /* default */])({}, base, {
      indexType: "timeline",
      parseTimeline: parseTimeline
    });
  } else {
    var segmentDuration = base.duration;

    if (segmentDuration == null) {
      throw new Error("Invalid SegmentTemplate: no duration");
    }

    ret = Object(object_assign["a" /* default */])({}, base, {
      indexType: "template",
      duration: segmentDuration
    });
  }

  if (index != null) {
    ret.index = index;
  }

  if (media != null) {
    ret.media = media;
  }

  if (bitstreamSwitching != null) {
    ret.bitstreamSwitching = bitstreamSwitching;
  }

  if (availabilityTimeOffset != null) {
    ret.availabilityTimeOffset = availabilityTimeOffset === "INF" ? Infinity : parseInt(availabilityTimeOffset, 10);
  }

  return ret;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Representation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * @param {NodeList} representationChildren
 * @returns {Object}
 */

function parseRepresentationChildren(representationChildren) {
  var children = {
    baseURLs: []
  };

  for (var i = 0; i < representationChildren.length; i++) {
    if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = representationChildren[i];

      switch (currentElement.nodeName) {
        case "BaseURL":
          var baseURLObj = parseBaseURL(currentElement);

          if (baseURLObj !== undefined) {
            children.baseURLs.push(baseURLObj);
          }

          break;

        case "SegmentBase":
          children.segmentBase = parseSegmentBase(currentElement);
          break;

        case "SegmentList":
          children.segmentList = parseSegmentList(currentElement);
          break;

        case "SegmentTemplate":
          children.segmentTemplate = parseSegmentTemplate(currentElement);
          break;
      }
    }
  }

  return children;
}
/**
 * @param {Element} representationElement
 * @returns {Object}
 */


function parseRepresentationAttributes(representationElement) {
  var attributes = {};

  for (var i = 0; i < representationElement.attributes.length; i++) {
    var attribute = representationElement.attributes[i];

    switch (attribute.name) {
      case "audioSamplingRate":
        attributes.audioSamplingRate = attribute.value;
        break;

      case "bandwidth":
        {
          var bitrate = parseInt(attribute.value, 10);

          if (isNaN(bitrate)) {
            log["a" /* default */].warn("DASH: invalid bandwidth (\"" + attribute.value + "\")");
          } else {
            attributes.bitrate = bitrate;
          }
        }
        break;

      case "codecs":
        attributes.codecs = attribute.value;
        break;

      case "codingDependency":
        attributes.codingDependency = parseBoolean(attribute.value);
        break;

      case "frameRate":
        attributes.frameRate = attribute.value;
        break;

      case "height":
        {
          var height = parseInt(attribute.value, 10);

          if (isNaN(height)) {
            log["a" /* default */].warn("DASH: invalid height (\"" + attribute.value + "\")");
          } else {
            attributes.height = height;
          }
        }
        break;

      case "id":
        attributes.id = attribute.value;
        break;

      case "maxPlayoutRate":
        {
          var maxPlayoutRate = parseFloat(attribute.value);

          if (isNaN(maxPlayoutRate)) {
            log["a" /* default */].warn("DASH: invalid maxPlayoutRate (\"" + attribute.value + "\")");
          } else {
            attributes.maxPlayoutRate = maxPlayoutRate;
          }
        }
        break;

      case "maximumSAPPeriod":
        {
          var maximumSAPPeriod = parseFloat(attribute.value);

          if (isNaN(maximumSAPPeriod)) {
            log["a" /* default */].warn("DASH: invalid maximumSAPPeriod (\"" + attribute.value + "\")");
          } else {
            attributes.maximumSAPPeriod = maximumSAPPeriod;
          }
        }
        break;

      case "mimeType":
        attributes.mimeType = attribute.value;
        break;

      case "profiles":
        attributes.profiles = attribute.value;
        break;

      case "qualityRanking":
        {
          var qualityRanking = parseInt(attribute.value, 10);

          if (isNaN(qualityRanking)) {
            log["a" /* default */].warn("DASH: invalid qualityRanking (\"" + attribute.value + "\")");
          } else {
            attributes.qualityRanking = qualityRanking;
          }
        }
        break;

      case "segmentProfiles":
        attributes.segmentProfiles = attribute.value;
        break;

      case "width":
        {
          var width = parseInt(attribute.value, 10);

          if (isNaN(width)) {
            log["a" /* default */].warn("DASH: invalid width (\"" + attribute.value + "\")");
          } else {
            attributes.width = width;
          }
        }
        break;
    }
  }

  return attributes;
}

function createRepresentationIntermediateRepresentation(representationElement) {
  return {
    children: parseRepresentationChildren(representationElement.childNodes),
    attributes: parseRepresentationAttributes(representationElement)
  };
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/AdaptationSet.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










function parseAdaptationSetChildren(adaptationSetChildren) {
  var children = {
    baseURLs: [],
    representations: []
  };
  var contentProtections = [];

  for (var i = 0; i < adaptationSetChildren.length; i++) {
    if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = adaptationSetChildren[i];

      switch (currentElement.nodeName) {
        case "Accessibility":
          children.accessibility = parseScheme(currentElement);
          break;

        case "BaseURL":
          var baseURLObj = parseBaseURL(currentElement);

          if (baseURLObj !== undefined) {
            children.baseURLs.push(baseURLObj);
          }

          break;

        case "ContentComponent":
          children.contentComponent = parseContentComponent(currentElement);
          break;

        case "EssentialProperty":
          if (children.essentialProperties == null) {
            children.essentialProperties = [parseScheme(currentElement)];
          } else {
            children.essentialProperties.push(parseScheme(currentElement));
          }

          break;

        case "Representation":
          var representation = createRepresentationIntermediateRepresentation(currentElement);
          children.representations.push(representation);
          break;

        case "Role":
          if (children.roles == null) {
            children.roles = [parseScheme(currentElement)];
          } else {
            children.roles.push(parseScheme(currentElement));
          }

          break;

        case "SupplementalProperty":
          if (children.supplementalProperties == null) {
            children.supplementalProperties = [parseScheme(currentElement)];
          } else {
            children.supplementalProperties.push(parseScheme(currentElement));
          }

          break;

        case "SegmentBase":
          children.segmentBase = parseSegmentBase(currentElement);
          break;

        case "SegmentList":
          children.segmentList = parseSegmentList(currentElement);
          break;

        case "SegmentTemplate":
          children.segmentTemplate = parseSegmentTemplate(currentElement);
          break;

        case "ContentProtection":
          var contentProtection = parseContentProtection(currentElement);

          if (contentProtection !== undefined) {
            contentProtections.push(contentProtection);
          }

          break;
        // case "Rating":
        //   children.rating = currentElement;
        //   break;
        // case "Viewpoint":
        //   children.viewpoint = currentElement;
        //   break;
      }
    }
  }

  if (contentProtections.length > 0) {
    children.contentProtections = contentProtections;
  }

  return children;
}

function parseAdaptationSetAttributes(root) {
  var parsedAdaptation = {};

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "id":
        parsedAdaptation.id = attribute.value;
        break;

      case "group":
        {
          var group = parseInt(attribute.value, 10);

          if (isNaN(group)) {
            log["a" /* default */].warn("DASH: invalid group (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.group = group;
          }
        }
        break;

      case "lang":
        parsedAdaptation.language = attribute.value;
        break;

      case "contentType":
        parsedAdaptation.contentType = attribute.value;
        break;

      case "par":
        parsedAdaptation.par = attribute.value;
        break;

      case "minBandwidth":
        {
          var minBitrate = parseInt(attribute.value, 10);

          if (isNaN(minBitrate)) {
            log["a" /* default */].warn("DASH: invalid minBandwidth (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.minBitrate = minBitrate;
          }
        }
        break;

      case "maxBandwidth":
        {
          var maxBitrate = parseInt(attribute.value, 10);

          if (isNaN(maxBitrate)) {
            log["a" /* default */].warn("DASH: invalid maxBandwidth (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.maxBitrate = maxBitrate;
          }
        }
        break;

      case "minWidth":
        {
          var minWidth = parseInt(attribute.value, 10);

          if (isNaN(minWidth)) {
            log["a" /* default */].warn("DASH: invalid minWidth (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.minWidth = minWidth;
          }
        }
        break;

      case "maxWidth":
        {
          var maxWidth = parseInt(attribute.value, 10);

          if (isNaN(maxWidth)) {
            log["a" /* default */].warn("DASH: invalid maxWidth (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.maxWidth = maxWidth;
          }
        }
        break;

      case "minHeight":
        {
          var minHeight = parseInt(attribute.value, 10);

          if (isNaN(minHeight)) {
            log["a" /* default */].warn("DASH: invalid minHeight (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.minHeight = minHeight;
          }
        }
        break;

      case "maxHeight":
        {
          var maxHeight = parseInt(attribute.value, 10);

          if (isNaN(maxHeight)) {
            log["a" /* default */].warn("DASH: invalid maxHeight (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.maxHeight = maxHeight;
          }
        }
        break;

      case "minFrameRate":
        {
          parsedAdaptation.minFrameRate = attribute.value;
        }
        break;

      case "maxFrameRate":
        parsedAdaptation.maxFrameRate = attribute.value;
        break;

      case "segmentAlignment":
        {
          var segmentAlignment = parseIntOrBoolean(attribute.value);

          if (typeof segmentAlignment === "number" && isNaN(segmentAlignment)) {
            log["a" /* default */].warn("DASH: invalid segmentAlignment (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.segmentAlignment = segmentAlignment;
          }
        }
        break;

      case "subsegmentAlignment":
        {
          var subsegmentAlignment = parseIntOrBoolean(attribute.value);

          if (typeof subsegmentAlignment === "number" && isNaN(subsegmentAlignment)) {
            log["a" /* default */].warn("DASH: invalid subsegmentAlignment (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.subsegmentAlignment = subsegmentAlignment;
          }
        }
        break;

      case "bitstreamSwitching":
        parsedAdaptation.bitstreamSwitching = parseBoolean(attribute.value);
        break;

      case "audioSamplingRate":
        parsedAdaptation.audioSamplingRate = attribute.value;
        break;

      case "codecs":
        parsedAdaptation.codecs = attribute.value;
        break;

      case "codingDependency":
        parsedAdaptation.codingDependency = parseBoolean(attribute.value);
        break;

      case "frameRate":
        parsedAdaptation.frameRate = attribute.value;
        break;

      case "height":
        {
          var height = parseInt(attribute.value, 10);

          if (isNaN(height)) {
            log["a" /* default */].warn("DASH: invalid height (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.height = height;
          }
        }
        break;

      case "maxPlayoutRate":
        {
          var maxPlayoutRate = parseFloat(attribute.value);

          if (isNaN(maxPlayoutRate)) {
            log["a" /* default */].warn("DASH: invalid maxPlayoutRate (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.maxPlayoutRate = maxPlayoutRate;
          }
        }
        break;

      case "maximumSAPPeriod":
        {
          var maximumSAPPeriod = parseFloat(attribute.value);

          if (isNaN(maximumSAPPeriod)) {
            log["a" /* default */].warn("DASH: invalid maximumSAPPeriod (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.maximumSAPPeriod = maximumSAPPeriod;
          }
        }
        break;

      case "mimeType":
        parsedAdaptation.mimeType = attribute.value;
        break;

      case "profiles":
        parsedAdaptation.profiles = attribute.value;
        break;

      case "segmentProfiles":
        parsedAdaptation.segmentProfiles = attribute.value;
        break;

      case "width":
        {
          var width = parseInt(attribute.value, 10);

          if (isNaN(width)) {
            log["a" /* default */].warn("DASH: invalid width (\"" + attribute.value + "\")");
          } else {
            parsedAdaptation.width = width;
          }
        }
        break;
    }
  }

  return parsedAdaptation;
}

function createAdaptationSetIntermediateRepresentation(adaptationSetElement) {
  return {
    children: parseAdaptationSetChildren(adaptationSetElement.childNodes),
    attributes: parseAdaptationSetAttributes(adaptationSetElement)
  };
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Period.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @param {NodeList} periodChildren
 * @returns {Object}
 */

function parsePeriodChildren(periodChildren) {
  var baseURLs = [];
  var adaptations = [];

  for (var i = 0; i < periodChildren.length; i++) {
    if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentElement = periodChildren[i];

      switch (currentElement.nodeName) {
        case "BaseURL":
          var baseURLObj = parseBaseURL(currentElement);

          if (baseURLObj !== undefined) {
            baseURLs.push(baseURLObj);
          }

          break;

        case "AdaptationSet":
          var adaptation = createAdaptationSetIntermediateRepresentation(currentElement);
          adaptations.push(adaptation);
          break;
      }
    }
  }

  return {
    baseURLs: baseURLs,
    adaptations: adaptations
  };
}
/**
 * @param {Element} periodElement
 * @returns {Object}
 */


function parsePeriodAttributes(periodElement) {
  var res = {};

  for (var i = 0; i < periodElement.attributes.length; i++) {
    var attribute = periodElement.attributes[i];

    switch (attribute.name) {
      case "id":
        res.id = attribute.value;
        break;

      case "start":
        {
          var tempStart = parseDuration(attribute.value);

          if (!isNaN(tempStart)) {
            res.start = tempStart;
          } else {
            log["a" /* default */].warn("DASH: Unrecognized start in the mpd:", attribute.value);
          }
        }
        break;

      case "duration":
        {
          var tempDuration = parseDuration(attribute.value);

          if (!isNaN(tempDuration)) {
            res.duration = tempDuration;
          } else {
            log["a" /* default */].warn("DASH: Unrecognized duration in the mpd:", attribute.value);
          }
        }
        break;

      case "bitstreamSwitching":
        res.bitstreamSwitching = parseBoolean(attribute.value);
        break;

      case "xlink:href":
        res.xlinkHref = attribute.value;
        break;

      case "xlink:actuate":
        res.xlinkActuate = attribute.value;
        break;
    }
  }

  return res;
}

function createPeriodIntermediateRepresentation(periodElement) {
  return {
    children: parsePeriodChildren(periodElement.childNodes),
    attributes: parsePeriodAttributes(periodElement)
  };
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/MPD.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse children of the MPD's root into a simple object.
 * @param {NodeList} mpdChildren
 * @returns {Object}
 */

function parseMPDChildren(mpdChildren) {
  var baseURLs = [];
  var locations = [];
  var periods = [];
  var utcTimings = [];

  for (var i = 0; i < mpdChildren.length; i++) {
    if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {
      var currentNode = mpdChildren[i];

      switch (currentNode.nodeName) {
        case "BaseURL":
          var baseURLObj = parseBaseURL(currentNode);

          if (baseURLObj !== undefined) {
            baseURLs.push(baseURLObj);
          }

          break;

        case "Location":
          locations.push(currentNode.textContent === null ? "" : currentNode.textContent);
          break;

        case "Period":
          var period = createPeriodIntermediateRepresentation(currentNode);
          periods.push(period);
          break;

        case "UTCTiming":
          var utcTiming = parseScheme(currentNode);
          utcTimings.push(utcTiming);
          break;
      }
    }
  }

  return {
    baseURLs: baseURLs,
    locations: locations,
    periods: periods,
    utcTimings: utcTimings
  };
}
/**
 * @param {Element} root
 * @returns {Object}
 */


function parseMPDAttributes(root) {
  var res = {};

  for (var i = 0; i < root.attributes.length; i++) {
    var attribute = root.attributes[i];

    switch (attribute.name) {
      case "id":
        res.id = attribute.value;
        break;

      case "profiles":
        res.profiles = attribute.value;
        break;

      case "type":
        res.type = attribute.value;
        break;

      case "availabilityStartTime":
        res.availabilityStartTime = parseDateTime(attribute.value);
        break;

      case "availabilityEndTime":
        res.availabilityEndTime = parseDateTime(attribute.value);
        break;

      case "publishTime":
        res.publishTime = parseDateTime(attribute.value);
        break;

      case "mediaPresentationDuration":
        res.duration = parseDuration(attribute.value);
        break;

      case "minimumUpdatePeriod":
        res.minimumUpdatePeriod = parseDuration(attribute.value);
        break;

      case "minBufferTime":
        res.minBufferTime = parseDuration(attribute.value);
        break;

      case "timeShiftBufferDepth":
        res.timeShiftBufferDepth = parseDuration(attribute.value);
        break;

      case "suggestedPresentationDelay":
        res.suggestedPresentationDelay = parseDuration(attribute.value);
        break;

      case "maxSegmentDuration":
        res.maxSegmentDuration = parseDuration(attribute.value);
        break;

      case "maxSubsegmentDuration":
        res.maxSubsegmentDuration = parseDuration(attribute.value);
        break;
    }
  }

  return res;
}

function createMPDIntermediateRepresentation(root) {
  return {
    children: parseMPDChildren(root.childNodes),
    attributes: parseMPDAttributes(root)
  };
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_availability_start_time.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the base time of the Manifest.
 * @param {Object} rootAttributes
 * @param {number|undefined}
 */
function parseAvailabilityStartTime(rootAttributes, referenceDateTime) {
  if (rootAttributes.type !== "dynamic") {
    return 0;
  }

  if (rootAttributes.availabilityStartTime == null) {
    return referenceDateTime == null ? 0 : referenceDateTime;
  }

  return rootAttributes.availabilityStartTime;
}
// EXTERNAL MODULE: ./src/utils/flat_map.ts
var flat_map = __webpack_require__(91);

// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(57);

// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(82);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/flatten_overlapping_periods.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Avoid periods to overlap.
 *
 * According to DASH guidelines, if a period has media duration longer than
 * the distance between the start of this period and the start of the next period,
 * use of start times implies that the client will start the playout of the next
 * period at the time stated, rather than finishing the playout of the last period.
 *
 * Even if that case if defined when period last(s) segment(s) is/are a bit longer,
 * it can be meaningful when two periods are overlapping. We will always shorten
 * the first period, and even erase it if its duration is equal to zero.
 *
 * Example (Periods are numbered under their manifest order) :
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][ Period 3 ]
 *             [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][  2  ][ Period 3 ]
 *                  [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [  1  ][      Period 3     ]
 *        [      Period 3     ]
 *
 * @param {Array.<Object>} parsedPeriods
 * @return {Array.<Object>}
 */

function flattenOverlappingPeriods(parsedPeriods) {
  if (parsedPeriods.length === 0) {
    return [];
  }

  var flattenedPeriods = [parsedPeriods[0]];

  for (var i = 1; i < parsedPeriods.length; i++) {
    var parsedPeriod = parsedPeriods[i];
    var lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];

    while (lastFlattenedPeriod.duration == null || lastFlattenedPeriod.start + lastFlattenedPeriod.duration > parsedPeriod.start) {
      log["a" /* default */].warn("DASH: Updating overlapping Periods.", lastFlattenedPeriod, parsedPeriod);
      lastFlattenedPeriod.duration = parsedPeriod.start - lastFlattenedPeriod.start;
      lastFlattenedPeriod.end = parsedPeriod.start;

      if (lastFlattenedPeriod.duration <= 0) {
        flattenedPeriods.pop();
        lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];
      }
    }

    flattenedPeriods.push(parsedPeriod);
  }

  return flattenedPeriods;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/get_periods_time_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Get periods time information from current, next and previous
 * periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @return {Array.<Object>}
 */
function getPeriodsTimeInformation(periodsIR, manifestInfos) {
  var periodsTimeInformation = [];
  periodsIR.forEach(function (currentPeriod, i) {
    var periodStart;

    if (currentPeriod.attributes.start != null) {
      periodStart = currentPeriod.attributes.start;
    } else {
      if (i === 0) {
        periodStart = !manifestInfos.isDynamic || manifestInfos.availabilityStartTime == null ? 0 : manifestInfos.availabilityStartTime;
      } else {
        // take time information from previous period
        var prevPeriodInfos = periodsTimeInformation[periodsTimeInformation.length - 1];

        if (prevPeriodInfos != null && prevPeriodInfos.periodEnd != null) {
          periodStart = prevPeriodInfos.periodEnd;
        } else {
          throw new Error("Missing start time when parsing periods.");
        }
      }
    }

    var periodDuration;
    var nextPeriod = periodsIR[i + 1];

    if (currentPeriod.attributes.duration != null) {
      periodDuration = currentPeriod.attributes.duration;
    } else if (i === periodsIR.length - 1) {
      periodDuration = manifestInfos.duration;
    } else if (nextPeriod.attributes.start != null) {
      periodDuration = nextPeriod.attributes.start - periodStart;
    }

    var periodEnd = periodDuration != null ? periodStart + periodDuration : undefined;
    periodsTimeInformation.push({
      periodStart: periodStart,
      periodDuration: periodDuration,
      periodEnd: periodEnd
    });
  });
  return periodsTimeInformation;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/manifest_bounds_calculator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This class allows to easily calculate the first and last available positions
 * in a content at any time.
 *
 * That task can be an hard for dynamic DASH contents: it depends on a
 * `timeShiftBufferDepth` defined in the MPD and on the maximum possible
 * position.
 *
 * The latter can come from either a clock synchronization mechanism or the
 * indexing schemes (e.g. SegmentTemplate, SegmentTimeline etc.) of the last
 * Periods.
 * As such, it might only be known once a large chunk of the MPD has already
 * been parsed.
 *
 * By centralizing the manifest bounds calculation in this class and by giving
 * an instance of it to each parsed elements which might depend on it, we
 * ensure that we can provide it once it is known to every one of those
 * elements without needing to parse a second time the MPD.
 *
 * @example
 * ```js
 * const manifestBoundsCalculator = new ManifestBoundsCalculator();
 *
 * // let's imagine a property `index` on a Representation which need to obtain
 * // the last position at any time
 * someRepresentation.index = new TemplateRepresentationIndex({
 *   // ...
 *   manifestBoundsCalculator // for now, `getLastPosition` will return `undefined`
 * });
 *
 * // ...
 * // Let's imagine a function which try to guess the last position based on a
 * // given parsed period
 * const lastPosition = getMaximumBound(somePeriod);
 * if (lastPosition != null) {
 *   const positionTime = performance.now() / 1000;
 *   manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
 *   // `getLastPosition` will now be correctly communicate the last position
 *   // (it returned `undefined` until then).
 * }
 * ```
 * @class ManifestBoundsCalculator
 */
var ManifestBoundsCalculator = /*#__PURE__*/function () {
  /**
   * @param {Object} args
   */
  function ManifestBoundsCalculator(args) {
    this._isDynamic = args.isDynamic;
    this._timeShiftBufferDepth = !args.isDynamic || args.timeShiftBufferDepth === undefined ? null : args.timeShiftBufferDepth;
  }
  /**
   * Set the last position and the position time (the value of `performance.now()`
   * at the time that position was true converted into seconds).
   *
   * @example
   * Example if you trust `Date.now()` to give you a reliable offset:
   * ```js
   * const lastPosition = Date.now();
   * const positionTime = performance.now() / 1000;
   * manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
   * ```
   *
   * @param {number} lastPosition
   * @param {number|undefined} positionTime
   */


  var _proto = ManifestBoundsCalculator.prototype;

  _proto.setLastPosition = function setLastPosition(lastPosition, positionTime) {
    this._lastPosition = lastPosition;
    this._positionTime = positionTime;
  }
  /**
   * Returns `true` if the last position and the position time
   * (for dynamic content only) have been comunicated.
   * `false` otherwise.
   * @returns {boolean}
   */
  ;

  _proto.lastPositionIsKnown = function lastPositionIsKnown() {
    if (this._isDynamic) {
      return this._positionTime != null && this._lastPosition != null;
    }

    return this._lastPosition != null;
  }
  /**
   * Get minimum bound of content.
   * @return {number|undefined}
   */
  ;

  _proto.getMinimumBound = function getMinimumBound() {
    if (!this._isDynamic || this._timeShiftBufferDepth === null) {
      return 0;
    }

    var maximumBound = this.getMaximumBound();

    if (maximumBound === undefined) {
      return undefined;
    }

    var minimumBound = maximumBound - this._timeShiftBufferDepth;
    return minimumBound;
  }
  /**
   * Calculate the current maximum bound by using both the calculated
   * last position and the timeshift buffer depth.
   * `undefined` if the last position has never been communicated.
   * @return {number|undefined}
   */
  ;

  _proto.getMaximumBound = function getMaximumBound() {
    if (this._isDynamic && this._positionTime != null && this._lastPosition != null) {
      return Math.max(this._lastPosition - this._positionTime + performance.now() / 1000, 0);
    }

    return this._lastPosition;
  };

  return ManifestBoundsCalculator;
}();


// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(10);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/infer_adaptation_type.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/** Array grouping every possible type a parsed Adaptation can be. */

var KNOWN_ADAPTATION_TYPES = ["audio", "video", "text", "image"];
/** Different `role`s a text Adaptation can be. */

var SUPPORTED_TEXT_TYPES = ["subtitle", "caption"];
/**
 * Infers the type of adaptation from codec and mimetypes found in it.
 *
 * This follows the guidelines defined by the DASH-IF IOP:
 *   - one adaptation set contains a single media type
 *   - The order of verifications are:
 *       1. mimeType
 *       2. Role
 *       3. codec
 *
 * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.
 * @param {Array.<Object>} representations
 * @param {string|null} adaptationMimeType
 * @param {string|null} adaptationCodecs
 * @param {Array.<Object>|null} adaptationRoles
 * @returns {string} - "audio"|"video"|"text"|"image"|"metadata"|"unknown"
 */

function inferAdaptationType(representations, adaptationMimeType, adaptationCodecs, adaptationRoles) {
  function fromMimeType(mimeType, roles) {
    var topLevel = mimeType.split("/")[0];

    if (Object(array_includes["a" /* default */])(KNOWN_ADAPTATION_TYPES, topLevel)) {
      return topLevel;
    }

    if (mimeType === "application/bif") {
      return "image";
    }

    if (mimeType === "application/ttml+xml") {
      return "text";
    } // manage DASH-IF mp4-embedded subtitles and metadata


    if (mimeType === "application/mp4") {
      if (roles != null) {
        if (Object(array_find["a" /* default */])(roles, function (role) {
          return role.schemeIdUri === "urn:mpeg:dash:role:2011" && Object(array_includes["a" /* default */])(SUPPORTED_TEXT_TYPES, role.value);
        }) != null) {
          return "text";
        }
      }

      return undefined;
    }
  }

  function fromCodecs(codecs) {
    switch (codecs.substring(0, 3)) {
      case "avc":
      case "hev":
      case "hvc":
      case "vp8":
      case "vp9":
      case "av1":
        return "video";

      case "vtt":
        return "text";

      case "bif":
        return "image";
    }

    switch (codecs.substring(0, 4)) {
      case "mp4a":
        return "audio";

      case "wvtt":
      case "stpp":
        return "text";
    }
  }

  if (adaptationMimeType !== null) {
    var typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRoles);

    if (typeFromMimeType !== undefined) {
      return typeFromMimeType;
    }
  }

  if (adaptationCodecs !== null) {
    var typeFromCodecs = fromCodecs(adaptationCodecs);

    if (typeFromCodecs !== undefined) {
      return typeFromCodecs;
    }
  }

  for (var i = 0; i < representations.length; i++) {
    var representation = representations[i];
    var _representation$attri = representation.attributes,
        mimeType = _representation$attri.mimeType,
        codecs = _representation$attri.codecs;

    if (mimeType !== undefined) {
      var _typeFromMimeType = fromMimeType(mimeType, adaptationRoles);

      if (_typeFromMimeType !== undefined) {
        return _typeFromMimeType;
      }
    }

    if (codecs !== undefined) {
      var _typeFromCodecs = fromCodecs(codecs);

      if (_typeFromCodecs !== undefined) {
        return _typeFromCodecs;
      }
    }
  }

  return undefined;
}
// EXTERNAL MODULE: ./src/parsers/manifest/utils/index_helpers.ts
var index_helpers = __webpack_require__(18);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/get_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Construct init segment for the given index.
 * @param {Object} index
 * @returns {Object}
 */
function get_init_segment_getInitSegment(index) {
  var _a;

  var initialization = index.initialization;
  return {
    id: "init",
    isInit: true,
    time: 0,
    duration: 0,
    range: initialization != null ? initialization.range : undefined,
    indexRange: index.indexRange,
    mediaURLs: (_a = initialization === null || initialization === void 0 ? void 0 : initialization.mediaURLs) !== null && _a !== void 0 ? _a : null,
    timescale: index.timescale,
    timestampOffset: -(index.indexTimeOffset / index.timescale)
  };
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/tokens.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Pad with 0 in the left of the given n argument to reach l length
 * @param {Number|string} n
 * @param {Number} l
 * @returns {string}
 */

function padLeftWithZeros(n, l) {
  var nToString = n.toString();

  if (nToString.length >= l) {
    return nToString;
  }

  var arr = new Array(l + 1).join("0") + nToString;
  return arr.slice(-l);
}
/**
 * @param {string|number} replacer
 * @returns {Function}
 */


function processFormatedToken(replacer) {
  return function (_match, _format, widthStr) {
    var width = Object(is_non_empty_string["a" /* default */])(widthStr) ? parseInt(widthStr, 10) : 1;
    return padLeftWithZeros(String(replacer), width);
  };
}
/**
 * @param {string} representationURL
 * @param {string|undefined} media
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */


function createIndexURLs(baseURLs, media, id, bitrate) {
  if (baseURLs.length === 0) {
    return media !== undefined ? [replaceRepresentationDASHTokens(media, id, bitrate)] : null;
  }

  return baseURLs.map(function (baseURL) {
    return replaceRepresentationDASHTokens(Object(resolve_url["a" /* default */])(baseURL, media), id, bitrate);
  });
}
/**
 * Replace "tokens" written in a given path (e.g. $RepresentationID$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */

function replaceRepresentationDASHTokens(path, id, bitrate) {
  if (path.indexOf("$") === -1) {
    return path;
  } else {
    return path.replace(/\$\$/g, "$").replace(/\$RepresentationID\$/g, String(id)).replace(/\$Bandwidth(|\%0(\d+)d)\$/g, processFormatedToken(bitrate === undefined ? 0 : bitrate));
  }
}
/**
 * Replace "tokens" written in a given path (e.g. $Time$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {number|undefined} time
 * @param {number|undefined} nb
 * @returns {string}
 *
 * @throws Error - Throws if we do not have enough data to construct the URL
 */

function replaceSegmentDASHTokens(path, time, nb) {
  if (path.indexOf("$") === -1) {
    return path;
  } else {
    return path.replace(/\$\$/g, "$").replace(/\$Number(|\%0(\d+)d)\$/g, function (_x, _y, widthStr) {
      if (nb == null) {
        throw new Error("Segment number not defined in a $Number$ scheme");
      }

      return processFormatedToken(nb)(_x, _y, widthStr);
    }).replace(/\$Time(|\%0(\d+)d)\$/g, function (_x, _y, widthStr) {
      if (time == null) {
        throw new Error("Segment time not defined in a $Time$ scheme");
      }

      return processFormatedToken(time)(_x, _y, widthStr);
    });
  }
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/get_segments_from_timeline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * For the given start time and duration of a timeline element, calculate how
 * much this element should be repeated to contain the time given.
 * 0 being the same element, 1 being the next one etc.
 * @param {Number} segmentStartTime
 * @param {Number} segmentDuration
 * @param {Number} wantedTime
 * @returns {Number}
 */

function getWantedRepeatIndex(segmentStartTime, segmentDuration, wantedTime) {
  var diff = wantedTime - segmentStartTime;
  return diff > 0 ? Math.floor(diff / segmentDuration) : 0;
}
/**
 * Get a list of Segments for the time range wanted.
 * @param {Object} index - index object, constructed by parsing the manifest.
 * @param {number} from - starting timestamp wanted, in seconds
 * @param {number} durationWanted - duration wanted, in seconds
 * @param {number|undefined} maximumTime
 * @returns {Array.<Object>}
 */


function getSegmentsFromTimeline(index, from, durationWanted, maximumTime) {
  var _a;

  var scaledUp = Object(index_helpers["e" /* toIndexTime */])(from, index);
  var scaledTo = Object(index_helpers["e" /* toIndexTime */])(from + durationWanted, index);
  var timeline = index.timeline,
      timescale = index.timescale,
      mediaURLs = index.mediaURLs,
      startNumber = index.startNumber;
  var currentNumber = startNumber != null ? startNumber : undefined;
  var segments = [];
  var timelineLength = timeline.length; // TODO(pierre): use @maxSegmentDuration if possible

  var maxEncounteredDuration = timeline.length > 0 && timeline[0].duration != null ? timeline[0].duration : 0;

  var _loop = function _loop(i) {
    var timelineItem = timeline[i];
    var duration = timelineItem.duration,
        start = timelineItem.start,
        range = timelineItem.range;
    maxEncounteredDuration = Math.max(maxEncounteredDuration, duration);
    var repeat = Object(index_helpers["a" /* calculateRepeat */])(timelineItem, timeline[i + 1], maximumTime);
    var segmentNumberInCurrentRange = getWantedRepeatIndex(start, duration, scaledUp);
    var segmentTime = start + segmentNumberInCurrentRange * duration;

    var _loop2 = function _loop2() {
      var segmentNumber = currentNumber != null ? currentNumber + segmentNumberInCurrentRange : undefined;
      var detokenizedURLs = (_a = mediaURLs === null || mediaURLs === void 0 ? void 0 : mediaURLs.map(function (url) {
        return replaceSegmentDASHTokens(url, segmentTime, segmentNumber);
      })) !== null && _a !== void 0 ? _a : null;
      var segment = {
        id: String(segmentTime),
        time: segmentTime - index.indexTimeOffset,
        isInit: false,
        range: range,
        duration: duration,
        timescale: timescale,
        mediaURLs: detokenizedURLs,
        number: segmentNumber,
        timestampOffset: -(index.indexTimeOffset / timescale)
      };
      segments.push(segment); // update segment number and segment time for the next segment

      segmentNumberInCurrentRange++;
      segmentTime = start + segmentNumberInCurrentRange * duration;
    };

    while (segmentTime < scaledTo && segmentNumberInCurrentRange <= repeat) {
      _loop2();
    }

    if (segmentTime >= scaledTo) {
      // we reached ``scaledTo``, we're done
      return {
        v: segments
      };
    }

    if (currentNumber != null) {
      currentNumber += repeat + 1;
    }
  };

  for (var i = 0; i < timelineLength; i++) {
    var _ret = _loop(i);

    if (typeof _ret === "object") return _ret.v;
  }

  return segments;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/base.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} segmentInfos
 * @returns {Boolean} - true if the segment has been added
 */

function _addSegmentInfos(index, segmentInfos) {
  if (segmentInfos.timescale !== index.timescale) {
    var timescale = index.timescale;
    index.timeline.push({
      start: segmentInfos.time / segmentInfos.timescale * timescale,
      duration: segmentInfos.duration / segmentInfos.timescale * timescale,
      repeatCount: segmentInfos.count === undefined ? 0 : segmentInfos.count,
      range: segmentInfos.range
    });
  } else {
    index.timeline.push({
      start: segmentInfos.time,
      duration: segmentInfos.duration,
      repeatCount: segmentInfos.count === undefined ? 0 : segmentInfos.count,
      range: segmentInfos.range
    });
  }

  return true;
}

var base_BaseRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function BaseRepresentationIndex(index, context) {
    var periodStart = context.periodStart,
        periodEnd = context.periodEnd,
        representationBaseURLs = context.representationBaseURLs,
        representationId = context.representationId,
        representationBitrate = context.representationBitrate;
    var timescale = index.timescale;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var indexTimeOffset = presentationTimeOffset - periodStart * timescale;
    var mediaURLs = createIndexURLs(representationBaseURLs, index.initialization !== undefined ? index.initialization.media : undefined, representationId, representationBitrate); // TODO If indexRange is either undefined or behind the initialization segment
    // the following logic will not work.
    // However taking the nth first bytes like `dash.js` does (where n = 1500) is
    // not straightforward as we would need to clean-up the segment after that.
    // The following logic corresponds to 100% of tested cases, so good enough for
    // now.

    var range = index.initialization !== undefined ? index.initialization.range : index.indexRange !== undefined ? [0, index.indexRange[0] - 1] : undefined;
    this._index = {
      indexRange: index.indexRange,
      indexTimeOffset: indexTimeOffset,
      initialization: {
        mediaURLs: mediaURLs,
        range: range
      },
      mediaURLs: createIndexURLs(representationBaseURLs, index.media, representationId, representationBitrate),
      startNumber: index.startNumber,
      timeline: index.timeline,
      timescale: timescale
    };
    this._scaledPeriodEnd = periodEnd == null ? undefined : Object(index_helpers["e" /* toIndexTime */])(periodEnd, this._index);
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */


  var _proto = BaseRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    return get_init_segment_getInitSegment(this._index);
  }
  /**
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments(_up, _to) {
    return getSegmentsFromTimeline(this._index, _up, _to, this._scaledPeriodEnd);
  }
  /**
   * Returns false as no Segment-Base based index should need to be refreshed.
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh() {
    return false;
  }
  /**
   * Returns first position in index.
   * @returns {Number|null}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    var index = this._index;

    if (index.timeline.length === 0) {
      return null;
    }

    return Object(index_helpers["b" /* fromIndexTime */])(index.timeline[0].start, index);
  }
  /**
   * Returns last position in index.
   * @returns {Number|null}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    var timeline = this._index.timeline;

    if (timeline.length === 0) {
      return null;
    }

    var lastTimelineElement = timeline[timeline.length - 1];
    var lastTime = Object(index_helpers["c" /* getIndexSegmentEnd */])(lastTimelineElement, null, this._scaledPeriodEnd);
    return Object(index_helpers["b" /* fromIndexTime */])(lastTime, this._index);
  }
  /**
   * Segments in a segmentBase scheme should stay available.
   * @returns {Boolean|undefined}
   */
  ;

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable() {
    return true;
  }
  /**
   * We do not check for discontinuity in SegmentBase-based indexes.
   * @returns {Number}
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity() {
    return -1;
  }
  /**
   * @param {Array.<Object>} nextSegments
   * @returns {Array.<Object>}
   */
  ;

  _proto._addSegments = function _addSegments(nextSegments) {
    for (var i = 0; i < nextSegments.length; i++) {
      _addSegmentInfos(this._index, nextSegments[i]);
    }
  }
  /**
   * Returns true as SegmentBase does not get updated.
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
    return false;
  }
  /**
   * Returns true as SegmentBase does not get updated.
   * @returns {Boolean}
   */
  ;

  _proto.isFinished = function isFinished() {
    return true;
  }
  /**
   * @param {Object} newIndex
   */
  ;

  _proto._replace = function _replace(newIndex) {
    this._index = newIndex._index;
  };

  _proto._update = function _update() {
    log["a" /* default */].error("Base RepresentationIndex: Cannot update a SegmentList");
  };

  return BaseRepresentationIndex;
}();


// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/list.ts
/*
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var list_ListRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function ListRepresentationIndex(index, context) {
    var periodStart = context.periodStart,
        representationBaseURLs = context.representationBaseURLs,
        representationId = context.representationId,
        representationBitrate = context.representationBitrate;
    this._periodStart = periodStart;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var indexTimeOffset = presentationTimeOffset - periodStart * index.timescale;
    var list = index.list.map(function (lItem) {
      return {
        mediaURLs: createIndexURLs(representationBaseURLs, lItem.media, representationId, representationBitrate),
        mediaRange: lItem.mediaRange
      };
    });
    this._index = {
      list: list,
      timescale: index.timescale,
      duration: index.duration,
      indexTimeOffset: indexTimeOffset,
      indexRange: index.indexRange,
      initialization: index.initialization == null ? undefined : {
        mediaURLs: createIndexURLs(representationBaseURLs, index.initialization.media, representationId, representationBitrate),
        range: index.initialization.range
      }
    };
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */


  var _proto = ListRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    return get_init_segment_getInitSegment(this._index);
  }
  /**
   * @param {Number} fromTime
   * @param {Number} duration
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments(fromTime, dur) {
    var index = this._index;
    var duration = index.duration,
        list = index.list,
        timescale = index.timescale;
    var fromTimeInPeriod = fromTime - this._periodStart;

    var _getTimescaledRange = Object(index_helpers["d" /* getTimescaledRange */])(fromTimeInPeriod, dur, timescale),
        up = _getTimescaledRange[0],
        to = _getTimescaledRange[1];

    var scaledStart = this._periodStart * timescale;
    var length = Math.min(list.length - 1, Math.floor(to / duration));
    var segments = [];
    var i = Math.floor(up / duration);

    while (i <= length) {
      var range = list[i].mediaRange;
      var mediaURLs = list[i].mediaURLs;
      var args = {
        id: String(i),
        time: i * duration + scaledStart,
        isInit: false,
        range: range,
        duration: duration,
        timescale: timescale,
        mediaURLs: mediaURLs,
        timestampOffset: -(index.indexTimeOffset / timescale)
      };
      segments.push(args);
      i++;
    }

    return segments;
  }
  /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Number} _fromTime
   * @param {Number} toTime
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh(_fromTime, toTime) {
    var _this$_index = this._index,
        timescale = _this$_index.timescale,
        duration = _this$_index.duration,
        list = _this$_index.list;
    var scaledTo = toTime * timescale;
    var i = Math.floor(scaledTo / duration);
    return i < 0 || i >= list.length;
  }
  /**
   * Returns first position in this index, in seconds.
   * @returns {Number}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    return this._periodStart;
  }
  /**
   * Returns last position in this index, in seconds.
   * @returns {Number}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    var index = this._index;
    var duration = index.duration,
        list = index.list;
    return list.length * duration / index.timescale + this._periodStart;
  }
  /**
   * Returns true if a Segment returned by this index is still considered
   * available.
   * @param {Object} segment
   * @returns {Boolean}
   */
  ;

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    if (segment.isInit) {
      return true;
    }

    var index = this._index;
    var scaledStart = this._periodStart * index.timescale;
    var scaledSegmentStartInPeriod = segment.timescale !== index.timescale ? segment.time * index.timescale / segment.timescale + scaledStart : segment.time - scaledStart;
    var duration = index.duration;
    var segmentNb = scaledSegmentStartInPeriod / duration;
    return segmentNb > 0 && segmentNb % 1 === 0;
  }
  /**
   * We do not check for discontinuity in SegmentList-based indexes.
   * @returns {Number}
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity() {
    return -1;
  }
  /**
   * SegmentList should not be updated.
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
    return false;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isFinished = function isFinished() {
    return true;
  }
  /**
   * @param {Object} newIndex
   */
  ;

  _proto._replace = function _replace(newIndex) {
    this._index = newIndex._index;
  }
  /**
   * @param {Object} newIndex
   */
  ;

  _proto._update = function _update() {
    log["a" /* default */].error("List RepresentationIndex: Cannot update a SegmentList");
  };

  _proto._addSegments = function _addSegments() {
    if (false) {}
  };

  return ListRepresentationIndex;
}();


// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/template.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var MINIMUM_SEGMENT_SIZE = config["a" /* default */].MINIMUM_SEGMENT_SIZE;
/**
 * IRepresentationIndex implementation for DASH' SegmentTemplate without a
 * SegmentTimeline.
 * @class TemplateRepresentationIndex
 */

var template_TemplateRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function TemplateRepresentationIndex(index, context) {
    var timescale = index.timescale;
    var aggressiveMode = context.aggressiveMode,
        availabilityTimeOffset = context.availabilityTimeOffset,
        manifestBoundsCalculator = context.manifestBoundsCalculator,
        isDynamic = context.isDynamic,
        periodEnd = context.periodEnd,
        periodStart = context.periodStart,
        representationBaseURLs = context.representationBaseURLs,
        representationId = context.representationId,
        representationBitrate = context.representationBitrate;
    this._availabilityTimeOffset = availabilityTimeOffset;
    this._manifestBoundsCalculator = manifestBoundsCalculator;
    this._aggressiveMode = aggressiveMode;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var scaledStart = periodStart * timescale;
    var indexTimeOffset = presentationTimeOffset - scaledStart;
    this._index = {
      duration: index.duration,
      timescale: timescale,
      indexRange: index.indexRange,
      indexTimeOffset: indexTimeOffset,
      initialization: index.initialization == null ? undefined : {
        mediaURLs: createIndexURLs(representationBaseURLs, index.initialization.media, representationId, representationBitrate),
        range: index.initialization.range
      },
      mediaURLs: createIndexURLs(representationBaseURLs, index.media, representationId, representationBitrate),
      presentationTimeOffset: presentationTimeOffset,
      startNumber: index.startNumber
    };
    this._isDynamic = isDynamic;
    this._periodStart = periodStart;
    this._relativePeriodEnd = periodEnd == null ? undefined : periodEnd - periodStart;
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */


  var _proto = TemplateRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    return get_init_segment_getInitSegment(this._index);
  }
  /**
   * @param {Number} fromTime
   * @param {Number} dur
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments(fromTime, dur) {
    var _this = this;

    var _a;

    var index = this._index;
    var duration = index.duration,
        startNumber = index.startNumber,
        timescale = index.timescale,
        mediaURLs = index.mediaURLs;
    var scaledStart = this._periodStart * timescale;
    var scaledEnd = this._relativePeriodEnd == null ? undefined : this._relativePeriodEnd * timescale; // Convert the asked position to the right timescales, and consider them
    // relatively to the Period's start.

    var upFromPeriodStart = fromTime * timescale - scaledStart;
    var toFromPeriodStart = (fromTime + dur) * timescale - scaledStart;

    var firstSegmentStart = this._getFirstSegmentStart();

    var lastSegmentStart = this._getLastSegmentStart();

    if (firstSegmentStart == null || lastSegmentStart == null) {
      return [];
    }

    var startPosition = Math.max(firstSegmentStart, upFromPeriodStart);
    var lastWantedStartPosition = Math.min(lastSegmentStart, toFromPeriodStart);

    if (lastWantedStartPosition + duration <= startPosition) {
      return [];
    }

    var segments = []; // number corresponding to the Period's start

    var numberOffset = startNumber == null ? 1 : startNumber; // calcul initial time from Period start, where the first segment would have
    // the `0` number

    var numberIndexedToZero = Math.floor(startPosition / duration);

    var _loop = function _loop(timeFromPeriodStart) {
      // To obtain the real number, adds the real number from the Period's start
      var realNumber = numberIndexedToZero + numberOffset;
      var realDuration = scaledEnd != null && timeFromPeriodStart + duration > scaledEnd ? scaledEnd - timeFromPeriodStart : duration;
      var realTime = timeFromPeriodStart + scaledStart;
      var manifestTime = timeFromPeriodStart + _this._index.presentationTimeOffset;
      var detokenizedURLs = (_a = mediaURLs === null || mediaURLs === void 0 ? void 0 : mediaURLs.map(function (url) {
        return replaceSegmentDASHTokens(url, manifestTime, realNumber);
      })) !== null && _a !== void 0 ? _a : null;
      var args = {
        id: String(realNumber),
        number: realNumber,
        time: realTime,
        isInit: false,
        duration: realDuration,
        timescale: timescale,
        mediaURLs: detokenizedURLs,
        timestampOffset: -(index.indexTimeOffset / timescale)
      };
      segments.push(args);
      numberIndexedToZero++;
    };

    for (var timeFromPeriodStart = numberIndexedToZero * duration; timeFromPeriodStart <= lastWantedStartPosition; timeFromPeriodStart += duration) {
      _loop(timeFromPeriodStart);
    }

    return segments;
  }
  /**
   * Returns first possible position in the index, in seconds.
   * @returns {number|null|undefined}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    var firstSegmentStart = this._getFirstSegmentStart();

    if (firstSegmentStart == null) {
      return firstSegmentStart; // return undefined or null
    }

    return firstSegmentStart / this._index.timescale + this._periodStart;
  }
  /**
   * Returns last possible position in the index, in seconds.
   * @returns {number|null}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    var lastSegmentStart = this._getLastSegmentStart();

    if (lastSegmentStart == null) {
      // In that case (null or undefined), getLastPosition should reflect
      // the result of getLastSegmentStart, as the meaning is the same for
      // the two functions. So, we return the result of the latter.
      return lastSegmentStart;
    }

    var lastSegmentEnd = lastSegmentStart + this._index.duration;
    return lastSegmentEnd / this._index.timescale + this._periodStart;
  }
  /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * We never have to refresh a SegmentTemplate-based manifest.
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh() {
    return false;
  }
  /**
   * We cannot check for discontinuity in SegmentTemplate-based indexes.
   * @returns {Number}
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity() {
    return -1;
  }
  /**
   * Returns `true` if the given segment should still be available as of now
   * (not removed since and still request-able).
   * Returns `false` if that's not the case.
   * Returns `undefined` if we do not know whether that's the case or not.
   * @param {Object} segment
   * @returns {boolean|undefined}
   */
  ;

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    if (segment.isInit) {
      return true;
    }

    if (segment.timescale !== this._index.timescale) {
      return undefined;
    }

    var timescale = segment.timescale;
    var timeRelativeToPeriodStart = segment.time - this._periodStart * timescale;

    var firstSegmentStart = this._getFirstSegmentStart();

    var lastSegmentStart = this._getLastSegmentStart();

    if (firstSegmentStart === undefined || lastSegmentStart === undefined) {
      return undefined;
    }

    if (firstSegmentStart === null || lastSegmentStart === null) {
      return false;
    }

    if (timeRelativeToPeriodStart < firstSegmentStart) {
      return false;
    }

    if (timeRelativeToPeriodStart > lastSegmentStart || segment.duration !== this._index.duration) {
      return false;
    }

    return timeRelativeToPeriodStart / this._index.duration % 1 === 0;
  }
  /**
   * SegmentTemplate without a SegmentTimeline should not be updated.
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
    return false;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isFinished = function isFinished() {
    if (!this._isDynamic) {
      return true;
    }

    if (this._relativePeriodEnd == null) {
      return false;
    }

    var timescale = this._index.timescale;

    var lastSegmentStart = this._getLastSegmentStart(); // As last segment start is null if live time is before
    // current period, consider the index not to be finished.


    if (lastSegmentStart == null) {
      return false;
    }

    var lastSegmentEnd = lastSegmentStart + this._index.duration; // (1 / 60 for possible rounding errors)

    var roundingError = 1 / 60 * timescale;
    return lastSegmentEnd + roundingError >= this._relativePeriodEnd * timescale;
  }
  /**
   * We do not have to add new segments to SegmentList-based indexes.
   * @returns {Array}
   */
  ;

  _proto._addSegments = function _addSegments() {
    log["a" /* default */].warn("Tried to add Segments to a template RepresentationIndex");
  }
  /**
   * @param {Object} newIndex
   */
  ;

  _proto._replace = function _replace(newIndex) {
    this._index = newIndex._index;
    this._aggressiveMode = newIndex._aggressiveMode;
    this._isDynamic = newIndex._isDynamic;
    this._periodStart = newIndex._periodStart;
    this._relativePeriodEnd = newIndex._relativePeriodEnd;
    this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
  }
  /**
   * @param {Object} newIndex
   */
  ;

  _proto._update = function _update(newIndex) {
    // As segments are not declared individually, as long as this Representation
    // is present, we have every information we need
    this._replace(newIndex);
  }
  /**
   * Returns the timescaled start of the first segment that should be available,
   * relatively to the start of the Period.
   * @returns {number | null | undefined}
   */
  ;

  _proto._getFirstSegmentStart = function _getFirstSegmentStart() {
    if (!this._isDynamic) {
      return 0; // it is the start of the Period
    } // 1 - check that this index is already available


    if (this._relativePeriodEnd === 0 || this._relativePeriodEnd == null) {
      // /!\ The scaled max position augments continuously and might not
      // reflect exactly the real server-side value. As segments are
      // generated discretely.
      var maximumBound = this._manifestBoundsCalculator.getMaximumBound();

      if (maximumBound !== undefined && maximumBound < this._periodStart) {
        // Maximum position is before this period.
        // No segment is yet available here
        return null;
      }
    }

    var _this$_index = this._index,
        duration = _this$_index.duration,
        timescale = _this$_index.timescale;

    var firstPosition = this._manifestBoundsCalculator.getMinimumBound();

    if (firstPosition === undefined) {
      return undefined;
    }

    var segmentTime = firstPosition > this._periodStart ? (firstPosition - this._periodStart) * timescale : 0;
    var numberIndexedToZero = Math.floor(segmentTime / duration);
    return numberIndexedToZero * duration;
  }
  /**
   * Returns the timescaled start of the last segment that should be available,
   * relatively to the start of the Period.
   * Returns null if live time is before current period.
   * @returns {number|null|undefined}
   */
  ;

  _proto._getLastSegmentStart = function _getLastSegmentStart() {
    var _this$_index2 = this._index,
        duration = _this$_index2.duration,
        timescale = _this$_index2.timescale;

    if (this._isDynamic) {
      var lastPos = this._manifestBoundsCalculator.getMaximumBound();

      if (lastPos === undefined) {
        return undefined;
      }

      var agressiveModeOffset = this._aggressiveMode ? duration / timescale : 0;

      if (this._relativePeriodEnd != null && this._relativePeriodEnd < lastPos + agressiveModeOffset - this._periodStart) {
        var scaledRelativePeriodEnd = this._relativePeriodEnd * timescale;

        if (scaledRelativePeriodEnd < duration) {
          return null;
        }

        return (Math.floor(scaledRelativePeriodEnd / duration) - 1) * duration;
      } // /!\ The scaled last position augments continuously and might not
      // reflect exactly the real server-side value. As segments are
      // generated discretely.


      var scaledLastPosition = (lastPos - this._periodStart) * timescale; // Maximum position is before this period.
      // No segment is yet available here

      if (scaledLastPosition < 0) {
        return null;
      }

      var availabilityTimeOffset = ((this._availabilityTimeOffset !== undefined ? this._availabilityTimeOffset : 0) + agressiveModeOffset) * timescale;
      var numberOfSegmentsAvailable = Math.floor((scaledLastPosition + availabilityTimeOffset) / duration);
      return numberOfSegmentsAvailable <= 0 ? null : (numberOfSegmentsAvailable - 1) * duration;
    } else {
      var maximumTime = (this._relativePeriodEnd === undefined ? 0 : this._relativePeriodEnd) * timescale;
      var numberIndexedToZero = Math.ceil(maximumTime / duration) - 1;
      var regularLastSegmentStart = numberIndexedToZero * duration; // In some SegmentTemplate, we could think that there is one more
      // segment that there actually is due to a very little difference between
      // the period's duration and a multiple of a segment's duration.
      // Check that we're within a good margin

      var minimumDuration = MINIMUM_SEGMENT_SIZE * timescale;

      if (maximumTime - regularLastSegmentStart > minimumDuration || numberIndexedToZero === 0) {
        return regularLastSegmentStart;
      }

      return (numberIndexedToZero - 1) * duration;
    }
  };

  return TemplateRepresentationIndex;
}();


// EXTERNAL MODULE: ./src/errors/network_error.ts
var network_error = __webpack_require__(171);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/clear_timeline_from_position.ts
var clear_timeline_from_position = __webpack_require__(113);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/is_segment_still_available.ts
var is_segment_still_available = __webpack_require__(111);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/update_segment_timeline.ts
var update_segment_timeline = __webpack_require__(112);

// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









/**
 * Translate parsed `S` node into Segment compatible with this index:
 * Find out the start, repeatCount and duration of each of these.
 *
 * @param {Object} item - parsed `S` node
 * @param {Object|null} previousItem - the previously parsed Segment (related
 * to the `S` node coming just before). If `null`, we're talking about the first
 * segment.
 * @param {Object|null} nextItem - the `S` node coming next. If `null`, we're
 * talking about the last segment.
 * @param {number} timelineStart - Absolute start for the timeline. In the same
 * timescale than the given `S` nodes.
 * @returns {Object|null}
 */

function fromParsedSToIndexSegment(item, previousItem, nextItem, timelineStart) {
  var start = item.start;
  var duration = item.duration;
  var repeatCount = item.repeatCount;

  if (start == null) {
    if (previousItem == null) {
      start = timelineStart;
    } else if (previousItem.duration != null) {
      start = previousItem.start + previousItem.duration * (previousItem.repeatCount + 1);
    }
  }

  if ((duration == null || isNaN(duration)) && nextItem != null && nextItem.start != null && !isNaN(nextItem.start) && start != null && !isNaN(start)) {
    duration = nextItem.start - start;
  }

  if (start != null && !isNaN(start) && duration != null && !isNaN(duration) && (repeatCount == null || !isNaN(repeatCount))) {
    return {
      start: start,
      duration: duration,
      repeatCount: repeatCount === undefined ? 0 : repeatCount
    };
  }

  log["a" /* default */].warn("DASH: A \"S\" Element could not have been parsed.");
  return null;
}
/**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} start
 * @returns {Number}
 */


function getSegmentIndex(timeline, start) {
  var low = 0;
  var high = timeline.length;

  while (low < high) {
    var mid = low + high >>> 1;

    if (timeline[mid].start < start) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return low > 0 ? low - 1 : low;
}

var timeline_TimelineRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} index
   * @param {Object} context
   */
  function TimelineRepresentationIndex(index, context) {
    var manifestBoundsCalculator = context.manifestBoundsCalculator,
        isDynamic = context.isDynamic,
        representationBaseURLs = context.representationBaseURLs,
        representationId = context.representationId,
        representationBitrate = context.representationBitrate,
        periodStart = context.periodStart,
        periodEnd = context.periodEnd;
    var timescale = index.timescale;
    var presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset : 0;
    var scaledStart = periodStart * timescale;
    var indexTimeOffset = presentationTimeOffset - scaledStart;
    this._manifestBoundsCalculator = manifestBoundsCalculator;
    this._lastUpdate = context.receivedTime == null ? performance.now() : context.receivedTime;
    this._isDynamic = isDynamic;
    this._parseTimeline = index.parseTimeline;
    this._index = {
      indexRange: index.indexRange,
      indexTimeOffset: indexTimeOffset,
      initialization: index.initialization == null ? undefined : {
        mediaURLs: createIndexURLs(representationBaseURLs, index.initialization.media, representationId, representationBitrate),
        range: index.initialization.range
      },
      mediaURLs: createIndexURLs(representationBaseURLs, index.media, representationId, representationBitrate),
      startNumber: index.startNumber,
      timeline: null,
      timescale: timescale
    };
    this._scaledPeriodStart = Object(index_helpers["e" /* toIndexTime */])(periodStart, this._index);
    this._scaledPeriodEnd = periodEnd == null ? undefined : Object(index_helpers["e" /* toIndexTime */])(periodEnd, this._index);
  }
  /**
   * Construct init Segment.
   * @returns {Object}
   */


  var _proto = TimelineRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    return get_init_segment_getInitSegment(this._index);
  }
  /**
   * Asks for segments to download for a given time range.
   * @param {Number} from - Beginning of the time wanted, in seconds
   * @param {Number} duration - duration wanted, in seconds
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments(from, duration) {
    this._refreshTimeline(); // clear timeline if needed


    if (this._index.timeline === null) {
      this._index.timeline = this._constructTimeline();
    } // destructuring to please TypeScript


    var _this$_index = this._index,
        mediaURLs = _this$_index.mediaURLs,
        startNumber = _this$_index.startNumber,
        timeline = _this$_index.timeline,
        timescale = _this$_index.timescale,
        indexTimeOffset = _this$_index.indexTimeOffset;
    return getSegmentsFromTimeline({
      mediaURLs: mediaURLs,
      startNumber: startNumber,
      timeline: timeline,
      timescale: timescale,
      indexTimeOffset: indexTimeOffset
    }, from, duration, this._scaledPeriodEnd);
  }
  /**
   * Returns true if the index should be refreshed.
   * @param {Number} _up
   * @param {Number} to
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh() {
    // DASH Manifest based on a SegmentTimeline should have minimumUpdatePeriod
    // attribute which should be sufficient to know when to refresh it.
    return false;
  }
  /**
   * Returns the starting time, in seconds, of the earliest segment currently
   * available.
   * Returns null if nothing is in the index
   * @returns {Number|null}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    this._refreshTimeline();

    if (this._index.timeline === null) {
      this._index.timeline = this._constructTimeline();
    }

    var timeline = this._index.timeline;
    return timeline.length === 0 ? null : Object(index_helpers["b" /* fromIndexTime */])(timeline[0].start, this._index);
  }
  /**
   * Returns the ending time, in seconds, of the last segment currently
   * available.
   * Returns null if nothing is in the index
   * @returns {Number|null}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    this._refreshTimeline();

    if (this._index.timeline === null) {
      this._index.timeline = this._constructTimeline();
    }

    var lastTime = TimelineRepresentationIndex.getIndexEnd(this._index.timeline, this._scaledPeriodStart);
    return lastTime === null ? null : Object(index_helpers["b" /* fromIndexTime */])(lastTime, this._index);
  }
  /**
   * Returns true if a Segment returned by this index is still considered
   * available.
   * Returns false if it is not available anymore.
   * Returns undefined if we cannot know whether it is still available or not.
   * @param {Object} segment
   * @returns {Boolean|undefined}
   */
  ;

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    if (segment.isInit) {
      return true;
    }

    this._refreshTimeline();

    if (this._index.timeline === null) {
      this._index.timeline = this._constructTimeline();
    }

    var _this$_index2 = this._index,
        timeline = _this$_index2.timeline,
        timescale = _this$_index2.timescale,
        indexTimeOffset = _this$_index2.indexTimeOffset;
    return Object(is_segment_still_available["a" /* default */])(segment, timeline, timescale, indexTimeOffset);
  }
  /**
   * Checks if the time given is in a discontinuity. That is:
   *   - We're on the upper bound of the current range (end of the range - time
   *     is inferior to the timescale)
   *   - The next range starts after the end of the current range.
   * @param {Number} _time
   * @returns {Number} - If a discontinuity is present, this is the Starting
   * time for the next (discontinuited) range. If not this is equal to -1.
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity(_time) {
    this._refreshTimeline();

    if (this._index.timeline === null) {
      this._index.timeline = this._constructTimeline();
    }

    var _this$_index3 = this._index,
        timeline = _this$_index3.timeline,
        timescale = _this$_index3.timescale;
    var scaledTime = Object(index_helpers["e" /* toIndexTime */])(_time, this._index);

    if (scaledTime <= 0) {
      return -1;
    }

    var segmentIndex = getSegmentIndex(this._index.timeline, scaledTime);

    if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
      return -1;
    }

    var timelineItem = timeline[segmentIndex];

    if (timelineItem.duration === -1) {
      return -1;
    }

    var nextTimelineItem = timeline[segmentIndex + 1];

    if (nextTimelineItem == null) {
      return -1;
    }

    var rangeUp = timelineItem.start;
    var rangeTo = Object(index_helpers["c" /* getIndexSegmentEnd */])(timelineItem, nextTimelineItem, this._scaledPeriodEnd); // Every segments defined in range (from rangeUp to rangeTo) are
    // explicitely contiguous.
    // We want to check that the range end is before the next timeline item
    // start, and that scaled time is in this discontinuity.

    if (rangeTo < nextTimelineItem.start && scaledTime >= rangeUp && rangeTo - scaledTime < timescale) {
      return Object(index_helpers["b" /* fromIndexTime */])(nextTimelineItem.start, this._index);
    }

    return -1;
  }
  /**
   * @param {Error} error
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError(error) {
    if (!this._isDynamic) {
      return false;
    }

    return error instanceof network_error["a" /* default */] && error.isHttpError(404);
  }
  /**
   * Replace this RepresentationIndex with one from a new version of the
   * Manifest.
   * @param {Object} newIndex
   */
  ;

  _proto._replace = function _replace(newIndex) {
    this._parseTimeline = newIndex._parseTimeline;
    this._index = newIndex._index;
    this._isDynamic = newIndex._isDynamic;
    this._scaledPeriodStart = newIndex._scaledPeriodStart;
    this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
    this._lastUpdate = newIndex._lastUpdate;
    this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
  }
  /**
   * Update this RepresentationIndex with a shorter version of it coming from a
   * new version of the MPD.
   * @param {Object} newIndex
   */
  ;

  _proto._update = function _update(newIndex) {
    if (this._index.timeline === null) {
      this._index.timeline = this._constructTimeline();
    }

    if (newIndex._index.timeline === null) {
      newIndex._index.timeline = newIndex._constructTimeline();
    }

    Object(update_segment_timeline["a" /* default */])(this._index.timeline, newIndex._index.timeline);
    this._isDynamic = newIndex._isDynamic;
    this._scaledPeriodStart = newIndex._scaledPeriodStart;
    this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
    this._lastUpdate = newIndex._lastUpdate;
    this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
  };

  _proto._addSegments = function _addSegments() {
    if (false) {}
  }
  /**
   * Returns `true` if this RepresentationIndex currently contains its last
   * segment.
   * Returns `false` if it's still pending.
   * @returns {Boolean}
   */
  ;

  _proto.isFinished = function isFinished() {
    if (!this._isDynamic) {
      return true;
    }

    if (this._index.timeline === null) {
      this._index.timeline = this._constructTimeline();
    }

    var timeline = this._index.timeline;

    if (this._scaledPeriodEnd == null || timeline.length === 0) {
      return false;
    }

    var lastTimelineElement = timeline[timeline.length - 1];
    var lastTime = Object(index_helpers["c" /* getIndexSegmentEnd */])(lastTimelineElement, null, this._scaledPeriodEnd); // We can never be truly sure if a SegmentTimeline-based index is finished
    // or not (1 / 60 for possible rounding errors)

    return lastTime + 1 / 60 >= this._scaledPeriodEnd;
  }
  /**
   * Clean-up timeline to remove segment information which should not be
   * available due to timeshifting.
   */
  ;

  _proto._refreshTimeline = function _refreshTimeline() {
    if (this._index.timeline === null) {
      this._index.timeline = this._constructTimeline();
    }

    var firstPosition = this._manifestBoundsCalculator.getMinimumBound();

    if (firstPosition == null) {
      return; // we don't know yet
    }

    var scaledFirstPosition = Object(index_helpers["e" /* toIndexTime */])(firstPosition, this._index);
    Object(clear_timeline_from_position["a" /* default */])(this._index.timeline, scaledFirstPosition);
  };

  TimelineRepresentationIndex.getIndexEnd = function getIndexEnd(timeline, scaledPeriodEnd) {
    if (timeline.length <= 0) {
      return null;
    }

    return Object(index_helpers["c" /* getIndexSegmentEnd */])(timeline[timeline.length - 1], null, scaledPeriodEnd);
  }
  /**
   * Allows to generate the "timeline" for this RepresentationIndex.
   * Call this function when the timeline is unknown.
   * This function was added to only perform that task lazily, i.e. only when
   * first needed.
   * @returns {Array.<Object>}
   */
  ;

  _proto._constructTimeline = function _constructTimeline() {
    var initialTimeline = this._parseTimeline();

    var timeline = [];

    for (var i = 0; i < initialTimeline.length; i++) {
      var item = initialTimeline[i];
      var nextItem = timeline[timeline.length - 1] === undefined ? null : timeline[timeline.length - 1];
      var prevItem = initialTimeline[i + 1] === undefined ? null : initialTimeline[i + 1];
      var timelineElement = fromParsedSToIndexSegment(item, nextItem, prevItem, this._scaledPeriodStart);

      if (timelineElement != null) {
        timeline.push(timelineElement);
      }
    }

    return timeline;
  };

  return TimelineRepresentationIndex;
}();


// CONCATENATED MODULE: ./src/parsers/manifest/dash/resolve_base_urls.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Array.<string>} currentBaseURLs
 * @param {Array.<Object>} newBaseURLs
 * @returns {Array.<string>}
 */

function resolveBaseURLs(currentBaseURLs, newBaseURLs) {
  var result = [];

  if (newBaseURLs.length === 0) {
    return currentBaseURLs;
  } else if (currentBaseURLs.length === 0) {
    for (var i = 0; i < newBaseURLs.length; i++) {
      if (!Object(array_includes["a" /* default */])(result, newBaseURLs[i].value)) {
        result.push(newBaseURLs[i].value);
      }
    }

    return result;
  } else {
    for (var _i = 0; _i < currentBaseURLs.length; _i++) {
      var rootURL = currentBaseURLs[_i];

      for (var j = 0; j < newBaseURLs.length; j++) {
        var newURL = Object(resolve_url["a" /* default */])(rootURL, newBaseURLs[j].value);

        if (!Object(array_includes["a" /* default */])(result, newURL)) {
          result.push(newURL);
        }
      }
    }
  }

  return result;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_representations.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Find and parse RepresentationIndex located in an AdaptationSet node.
 * Returns a generic parsed SegmentTemplate with a single element if not found.
 * @param {Object} adaptation
 * @param {Object} context
 */

function findAdaptationIndex(adaptation, context) {
  var adaptationChildren = adaptation.children;
  var adaptationIndex;

  if (adaptationChildren.segmentBase != null) {
    var segmentBase = adaptationChildren.segmentBase;
    adaptationIndex = new base_BaseRepresentationIndex(segmentBase, context);
  } else if (adaptationChildren.segmentList != null) {
    var segmentList = adaptationChildren.segmentList;
    adaptationIndex = new list_ListRepresentationIndex(segmentList, context);
  } else if (adaptationChildren.segmentTemplate != null) {
    var segmentTemplate = adaptationChildren.segmentTemplate;
    adaptationIndex = segmentTemplate.indexType === "timeline" ? new timeline_TimelineRepresentationIndex(segmentTemplate, context) : new template_TemplateRepresentationIndex(segmentTemplate, context);
  } else {
    adaptationIndex = new template_TemplateRepresentationIndex({
      duration: Number.MAX_VALUE,
      timescale: 1,
      startNumber: 0,
      initialization: {
        media: ""
      },
      media: ""
    }, context);
  }

  return adaptationIndex;
}
/**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @returns {Array.<Object>}
 */


function parseRepresentations(representationsIR, adaptation, adaptationInfos) {
  return representationsIR.map(function (representation) {
    var _a, _b;

    var representationBaseURLs = resolveBaseURLs(adaptationInfos.baseURLs, representation.children.baseURLs); // 4-2-1. Find Index

    var context = {
      aggressiveMode: adaptationInfos.aggressiveMode,
      availabilityTimeOffset: adaptationInfos.availabilityTimeOffset,
      manifestBoundsCalculator: adaptationInfos.manifestBoundsCalculator,
      isDynamic: adaptationInfos.isDynamic,
      periodEnd: adaptationInfos.end,
      periodStart: adaptationInfos.start,
      receivedTime: adaptationInfos.receivedTime,
      representationBaseURLs: representationBaseURLs,
      representationBitrate: representation.attributes.bitrate,
      representationId: representation.attributes.id,
      timeShiftBufferDepth: adaptationInfos.timeShiftBufferDepth
    };
    var representationIndex;

    if (representation.children.segmentBase != null) {
      var segmentBase = representation.children.segmentBase;
      context.availabilityTimeOffset = adaptationInfos.availabilityTimeOffset + extractMinimumAvailabilityTimeOffset(representation.children.baseURLs) + ((_a = segmentBase.availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0);
      representationIndex = new base_BaseRepresentationIndex(segmentBase, context);
    } else if (representation.children.segmentList != null) {
      var segmentList = representation.children.segmentList;
      representationIndex = new list_ListRepresentationIndex(segmentList, context);
    } else if (representation.children.segmentTemplate != null) {
      var segmentTemplate = representation.children.segmentTemplate;

      if (segmentTemplate.indexType === "timeline") {
        representationIndex = new timeline_TimelineRepresentationIndex(segmentTemplate, context);
      } else {
        context.availabilityTimeOffset = adaptationInfos.availabilityTimeOffset + extractMinimumAvailabilityTimeOffset(representation.children.baseURLs) + ((_b = segmentTemplate.availabilityTimeOffset) !== null && _b !== void 0 ? _b : 0);
        representationIndex = new template_TemplateRepresentationIndex(segmentTemplate, context);
      }
    } else {
      representationIndex = findAdaptationIndex(adaptation, context);
    } // 4-2-2. Find bitrate


    var representationBitrate;

    if (representation.attributes.bitrate == null) {
      log["a" /* default */].warn("DASH: No usable bitrate found in the Representation.");
      representationBitrate = 0;
    } else {
      representationBitrate = representation.attributes.bitrate;
    } // 4-2-3. Set ID


    var representationID = representation.attributes.id != null ? representation.attributes.id : String(representation.attributes.bitrate) + (representation.attributes.height != null ? "-" + representation.attributes.height : "") + (representation.attributes.width != null ? "-" + representation.attributes.width : "") + (representation.attributes.mimeType != null ? "-" + representation.attributes.mimeType : "") + (representation.attributes.codecs != null ? "-" + representation.attributes.codecs : ""); // 4-2-4. Construct Representation Base

    var parsedRepresentation = {
      bitrate: representationBitrate,
      index: representationIndex,
      id: representationID
    }; // 4-2-5. Add optional attributes

    var codecs;

    if (representation.attributes.codecs != null) {
      codecs = representation.attributes.codecs;
    } else if (adaptation.attributes.codecs != null) {
      codecs = adaptation.attributes.codecs;
    }

    if (codecs != null) {
      codecs = codecs === "mp4a.40.02" ? "mp4a.40.2" : codecs;
      parsedRepresentation.codecs = codecs;
    }

    if (representation.attributes.frameRate != null) {
      parsedRepresentation.frameRate = representation.attributes.frameRate;
    } else if (adaptation.attributes.frameRate != null) {
      parsedRepresentation.frameRate = adaptation.attributes.frameRate;
    }

    if (representation.attributes.height != null) {
      parsedRepresentation.height = representation.attributes.height;
    } else if (adaptation.attributes.height != null) {
      parsedRepresentation.height = adaptation.attributes.height;
    }

    if (representation.attributes.mimeType != null) {
      parsedRepresentation.mimeType = representation.attributes.mimeType;
    } else if (adaptation.attributes.mimeType != null) {
      parsedRepresentation.mimeType = adaptation.attributes.mimeType;
    }

    if (representation.attributes.width != null) {
      parsedRepresentation.width = representation.attributes.width;
    } else if (adaptation.attributes.width != null) {
      parsedRepresentation.width = adaptation.attributes.width;
    }

    if (adaptation.children.contentProtections != null) {
      var contentProtections = adaptation.children.contentProtections.reduce(function (acc, cp) {
        var systemId;

        if (cp.attributes.schemeIdUri !== undefined && cp.attributes.schemeIdUri.substring(0, 9) === "urn:uuid:") {
          systemId = cp.attributes.schemeIdUri.substring(9).replace(/-/g, "").toLowerCase();
        }

        if (cp.attributes.keyId !== undefined && cp.attributes.keyId.length > 0) {
          acc.keyIds.push({
            keyId: cp.attributes.keyId,
            systemId: systemId
          });
        }

        if (systemId !== undefined) {
          var cencPssh = cp.children.cencPssh;

          for (var i = 0; i < cencPssh.length; i++) {
            var data = cencPssh[i];

            if (acc.initData.cenc === undefined) {
              acc.initData.cenc = [];
            }

            acc.initData.cenc.push({
              systemId: systemId,
              data: data
            });
          }
        }

        return acc;
      }, {
        keyIds: [],
        initData: {}
      });

      if (Object.keys(contentProtections.initData).length > 0 || contentProtections.keyIds.length > 0) {
        parsedRepresentation.contentProtections = contentProtections;
      }
    }

    return parsedRepresentation;
  });
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_adaptation_sets.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Detect if the accessibility given defines an adaptation for the visually
 * impaired.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */

function isVisuallyImpaired(accessibility) {
  if (accessibility == null) {
    return false;
  }

  return accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" && accessibility.value === "1";
}
/**
 * Detect if the accessibility given defines an adaptation for the hard of
 * hearing.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */


function isHardOfHearing(accessibility) {
  if (accessibility == null) {
    return false;
  }

  return accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" && accessibility.value === "2";
}
/**
 * Contruct Adaptation ID from the information we have.
 * @param {Object} adaptation
 * @param {Array.<Object>} representations
 * @param {Object} infos
 * @returns {string}
 */


function getAdaptationID(adaptation, representations, infos) {
  if (Object(is_non_empty_string["a" /* default */])(adaptation.attributes.id)) {
    return adaptation.attributes.id;
  }

  var idString = infos.type;

  if (Object(is_non_empty_string["a" /* default */])(adaptation.attributes.language)) {
    idString += "-" + adaptation.attributes.language;
  }

  if (infos.isClosedCaption === true) {
    idString += "-cc";
  }

  if (infos.isAudioDescription === true) {
    idString += "-ad";
  }

  if (Object(is_non_empty_string["a" /* default */])(adaptation.attributes.contentType)) {
    idString += "-" + adaptation.attributes.contentType;
  }

  if (Object(is_non_empty_string["a" /* default */])(adaptation.attributes.codecs)) {
    idString += "-" + adaptation.attributes.codecs;
  }

  if (Object(is_non_empty_string["a" /* default */])(adaptation.attributes.mimeType)) {
    idString += "-" + adaptation.attributes.mimeType;
  }

  if (Object(is_non_empty_string["a" /* default */])(adaptation.attributes.frameRate)) {
    idString += "-" + adaptation.attributes.frameRate;
  }

  if (idString.length === infos.type.length) {
    idString += representations.length > 0 ? "-" + representations[0].id : "-empty";
  }

  return "adaptation-" + idString;
}
/**
 * Returns a list of ID this adaptation can be seamlessly switched to
 * @param {Object} adaptation
 * @returns {Array.<string>}
 */


function getAdaptationSetSwitchingIDs(adaptation) {
  if (adaptation.children.supplementalProperties != null) {
    var supplementalProperties = adaptation.children.supplementalProperties;

    for (var j = 0; j < supplementalProperties.length; j++) {
      var supplementalProperty = supplementalProperties[j];

      if (supplementalProperty.schemeIdUri === "urn:mpeg:dash:adaptation-set-switching:2016" && supplementalProperty.value != null) {
        return supplementalProperty.value.split(",").map(function (id) {
          return id.trim();
        }).filter(function (id) {
          return id;
        });
      }
    }
  }

  return [];
}
/**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @returns {Array.<Object>}
 */


function parseAdaptationSets(adaptationsIR, periodInfos) {
  return adaptationsIR.reduce(function (acc, adaptation) {
    var adaptationChildren = adaptation.children;
    var parsedAdaptations = acc.adaptations;
    var essentialProperties = adaptationChildren.essentialProperties,
        roles = adaptationChildren.roles;
    var isExclusivelyTrickModeTrack = Array.isArray(essentialProperties) && essentialProperties.some(function (ep) {
      return ep.schemeIdUri === "http://dashif.org/guidelines/trickmode";
    });

    if (isExclusivelyTrickModeTrack) {
      // We do not for the moment parse trickmode tracks
      return acc;
    }

    var isMainAdaptation = Array.isArray(roles) && roles.some(function (role) {
      return role.value === "main";
    }) && roles.some(function (role) {
      return role.schemeIdUri === "urn:mpeg:dash:role:2011";
    });
    var representationsIR = adaptation.children.representations;
    var availabilityTimeOffset = extractMinimumAvailabilityTimeOffset(adaptation.children.baseURLs) + periodInfos.availabilityTimeOffset;
    var adaptationInfos = {
      aggressiveMode: periodInfos.aggressiveMode,
      availabilityTimeOffset: availabilityTimeOffset,
      baseURLs: resolveBaseURLs(periodInfos.baseURLs, adaptationChildren.baseURLs),
      manifestBoundsCalculator: periodInfos.manifestBoundsCalculator,
      end: periodInfos.end,
      isDynamic: periodInfos.isDynamic,
      receivedTime: periodInfos.receivedTime,
      start: periodInfos.start,
      timeShiftBufferDepth: periodInfos.timeShiftBufferDepth
    };
    var adaptationMimeType = adaptation.attributes.mimeType;
    var adaptationCodecs = adaptation.attributes.codecs;
    var type = inferAdaptationType(representationsIR, Object(is_non_empty_string["a" /* default */])(adaptationMimeType) ? adaptationMimeType : null, Object(is_non_empty_string["a" /* default */])(adaptationCodecs) ? adaptationCodecs : null, adaptationChildren.roles != null ? adaptationChildren.roles : null);

    if (type === undefined) {
      return acc; // let's not parse unrecognized tracks
    }

    var representations = parseRepresentations(representationsIR, adaptation, adaptationInfos);
    var originalID = adaptation.attributes.id;
    var newID;
    var adaptationSetSwitchingIDs = getAdaptationSetSwitchingIDs(adaptation);
    var videoMainAdaptation = acc.videoMainAdaptation;

    if (type === "video" && videoMainAdaptation !== null && isMainAdaptation) {
      var _videoMainAdaptation$;

      (_videoMainAdaptation$ = videoMainAdaptation.representations).push.apply(_videoMainAdaptation$, representations);

      newID = videoMainAdaptation.id;
    } else {
      var accessibility = adaptationChildren.accessibility;
      var isDub;

      if (roles !== undefined && roles.some(function (role) {
        return role.value === "dub";
      })) {
        isDub = true;
      }

      var isClosedCaption = type === "text" && accessibility != null && isHardOfHearing(accessibility) ? true : undefined;
      var isAudioDescription = type === "audio" && accessibility != null && isVisuallyImpaired(accessibility) ? true : undefined;
      var adaptationID = newID = getAdaptationID(adaptation, representations, {
        isClosedCaption: isClosedCaption,
        isAudioDescription: isAudioDescription,
        type: type
      });
      var parsedAdaptationSet = {
        id: adaptationID,
        representations: representations,
        type: type
      };

      if (adaptation.attributes.language != null) {
        parsedAdaptationSet.language = adaptation.attributes.language;
      }

      if (isClosedCaption != null) {
        parsedAdaptationSet.closedCaption = isClosedCaption;
      }

      if (isAudioDescription != null) {
        parsedAdaptationSet.audioDescription = isAudioDescription;
      }

      if (isDub === true) {
        parsedAdaptationSet.isDub = true;
      }

      var adaptationsOfTheSameType = parsedAdaptations[type];

      if (adaptationsOfTheSameType === undefined) {
        parsedAdaptations[type] = [parsedAdaptationSet];

        if (isMainAdaptation && type === "video") {
          acc.videoMainAdaptation = parsedAdaptationSet;
        }
      } else {
        var mergedInto = null; // look if we have to merge this into another Adaptation

        var _loop = function _loop(k) {
          var id = adaptationSetSwitchingIDs[k];
          var switchingInfos = acc.adaptationSwitchingInfos[id];

          if (switchingInfos != null && switchingInfos.newID !== newID && Object(array_includes["a" /* default */])(switchingInfos.adaptationSetSwitchingIDs, originalID)) {
            var adaptationToMergeInto = Object(array_find["a" /* default */])(adaptationsOfTheSameType, function (a) {
              return a.id === id;
            });

            if (adaptationToMergeInto != null && adaptationToMergeInto.audioDescription === parsedAdaptationSet.audioDescription && adaptationToMergeInto.closedCaption === parsedAdaptationSet.closedCaption && adaptationToMergeInto.language === parsedAdaptationSet.language) {
              var _adaptationToMergeInt;

              log["a" /* default */].info("DASH Parser: merging \"switchable\" AdaptationSets", originalID, id);

              (_adaptationToMergeInt = adaptationToMergeInto.representations).push.apply(_adaptationToMergeInt, parsedAdaptationSet.representations);

              mergedInto = adaptationToMergeInto;
            }
          }
        };

        for (var k = 0; k < adaptationSetSwitchingIDs.length; k++) {
          _loop(k);
        }

        if (isMainAdaptation && type === "video") {
          if (mergedInto == null) {
            // put "main" adaptation as the first
            adaptationsOfTheSameType.unshift(parsedAdaptationSet);
            acc.videoMainAdaptation = parsedAdaptationSet;
          } else {
            // put the resulting adaptation first instead
            var indexOf = adaptationsOfTheSameType.indexOf(mergedInto);

            if (indexOf < 0) {
              adaptationsOfTheSameType.unshift(parsedAdaptationSet);
            } else if (indexOf !== 0) {
              adaptationsOfTheSameType.splice(indexOf, 1);
              adaptationsOfTheSameType.unshift(mergedInto);
            }

            acc.videoMainAdaptation = mergedInto;
          }
        } else if (mergedInto === null) {
          adaptationsOfTheSameType.push(parsedAdaptationSet);
        }
      }
    }

    if (originalID != null && acc.adaptationSwitchingInfos[originalID] == null) {
      acc.adaptationSwitchingInfos[originalID] = {
        newID: newID,
        adaptationSetSwitchingIDs: adaptationSetSwitchingIDs
      };
    }

    return {
      adaptations: parsedAdaptations,
      adaptationSwitchingInfos: acc.adaptationSwitchingInfos,
      videoMainAdaptation: acc.videoMainAdaptation
    };
  }, {
    adaptations: {},
    videoMainAdaptation: null,
    adaptationSwitchingInfos: {}
  }).adaptations;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_periods.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










var generatePeriodID = Object(id_generator["a" /* default */])();
/**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} contextInfos
 * @returns {Array.<Object>}
 */

function parsePeriods(periodsIR, contextInfos) {
  var parsedPeriods = [];
  var periodsTimeInformation = getPeriodsTimeInformation(periodsIR, contextInfos);

  if (periodsTimeInformation.length !== periodsIR.length) {
    throw new Error("MPD parsing error: the time information are incoherent.");
  }

  var isDynamic = contextInfos.isDynamic,
      timeShiftBufferDepth = contextInfos.timeShiftBufferDepth;
  var manifestBoundsCalculator = new ManifestBoundsCalculator({
    isDynamic: isDynamic,
    timeShiftBufferDepth: timeShiftBufferDepth
  });

  if (!isDynamic && contextInfos.duration != null) {
    manifestBoundsCalculator.setLastPosition(contextInfos.duration);
  } // We parse it in reverse because we might need to deduce the buffer depth from
  // the last Periods' indexes


  for (var i = periodsIR.length - 1; i >= 0; i--) {
    var periodIR = periodsIR[i];
    var xlinkInfos = contextInfos.xlinkInfos.get(periodIR);
    var periodBaseURLs = resolveBaseURLs(contextInfos.baseURLs, periodIR.children.baseURLs);
    var _periodsTimeInformati = periodsTimeInformation[i],
        periodStart = _periodsTimeInformati.periodStart,
        periodDuration = _periodsTimeInformati.periodDuration,
        periodEnd = _periodsTimeInformati.periodEnd;
    var periodID = void 0;

    if (periodIR.attributes.id == null) {
      log["a" /* default */].warn("DASH: No usable id found in the Period. Generating one.");
      periodID = "gen-dash-period-" + generatePeriodID();
    } else {
      periodID = periodIR.attributes.id;
    }

    var receivedTime = xlinkInfos !== undefined ? xlinkInfos.receivedTime : contextInfos.receivedTime;
    var availabilityTimeOffset = extractMinimumAvailabilityTimeOffset(periodIR.children.baseURLs) + contextInfos.availabilityTimeOffset;
    var periodInfos = {
      aggressiveMode: contextInfos.aggressiveMode,
      availabilityTimeOffset: availabilityTimeOffset,
      baseURLs: periodBaseURLs,
      manifestBoundsCalculator: manifestBoundsCalculator,
      end: periodEnd,
      isDynamic: isDynamic,
      receivedTime: receivedTime,
      start: periodStart,
      timeShiftBufferDepth: timeShiftBufferDepth
    };
    var adaptations = parseAdaptationSets(periodIR.children.adaptations, periodInfos);
    var parsedPeriod = {
      id: periodID,
      start: periodStart,
      end: periodEnd,
      duration: periodDuration,
      adaptations: adaptations
    };
    parsedPeriods.unshift(parsedPeriod);

    if (!manifestBoundsCalculator.lastPositionIsKnown()) {
      var lastPosition = getMaximumLastPosition(adaptations);

      if (!isDynamic) {
        if (typeof lastPosition === "number") {
          manifestBoundsCalculator.setLastPosition(lastPosition);
        }
      } else {
        if (typeof lastPosition === "number") {
          var positionTime = performance.now() / 1000;
          manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
        } else {
          var guessedLastPositionFromClock = guessLastPositionFromClock(contextInfos, periodStart);

          if (guessedLastPositionFromClock !== undefined) {
            var guessedLastPosition = guessedLastPositionFromClock[0],
                guessedPositionTime = guessedLastPositionFromClock[1];
            manifestBoundsCalculator.setLastPosition(guessedLastPosition, guessedPositionTime);
          }
        }
      }
    }
  }

  if (contextInfos.isDynamic && !manifestBoundsCalculator.lastPositionIsKnown()) {
    // Guess a last time the last position
    var _guessedLastPositionFromClock = guessLastPositionFromClock(contextInfos, 0);

    if (_guessedLastPositionFromClock !== undefined) {
      var _lastPosition = _guessedLastPositionFromClock[0],
          _positionTime = _guessedLastPositionFromClock[1];
      manifestBoundsCalculator.setLastPosition(_lastPosition, _positionTime);
    }
  }

  return flattenOverlappingPeriods(parsedPeriods);
}
/**
 * Try to guess the "last position", which is the last position
 * available in the manifest in seconds, and the "position time", the time
 * (`performance.now()`) in which the last position was collected.
 *
 * These values allows to retrieve at any time in the future the new last
 * position, by substracting the position time to the last position, and
 * adding to it the new value returned by `performance.now`.
 *
 * The last position and position time are returned by this function if and only if
 * it would indicate a last position superior to the `minimumTime` given.
 *
 * This last part allows for example to detect which Period is likely to be the
 * "current" one in multi-periods contents. By giving the Period's start as a
 * `minimumTime`, you ensure that you will get a value only if the current time
 * is in that period.
 *
 * This is useful as guessing the live time from the clock can be seen as a last
 * resort. By detecting that the current time is before the currently considered
 * Period, we can just parse and look at the previous Period. If we can guess
 * the live time more directly from that previous one, we might be better off
 * than just using the clock.
 *
 * @param {Object} contextInfos
 * @param {number} minimumTime
 * @returns {Array.<number|undefined>}
 */

function guessLastPositionFromClock(contextInfos, minimumTime) {
  if (contextInfos.clockOffset != null) {
    var lastPosition = contextInfos.clockOffset / 1000 - contextInfos.availabilityStartTime;
    var positionTime = performance.now() / 1000;
    var timeInSec = positionTime + lastPosition;

    if (timeInSec >= minimumTime) {
      return [timeInSec, positionTime];
    }
  } else {
    var now = Date.now() / 1000;

    if (now >= minimumTime) {
      log["a" /* default */].warn("DASH Parser: no clock synchronization mechanism found." + " Using the system clock instead.");

      var _lastPosition2 = now - contextInfos.availabilityStartTime;

      var _positionTime2 = performance.now() / 1000;

      return [_lastPosition2, _positionTime2];
    }
  }

  return undefined;
}
/**
 * Try to extract the last position declared for any segments in a Period:
 *   - If at least a single index' last position is defined, take the maximum
 *     among them.
 *   - If segments are available but we cannot define the last position
 *     return undefined.
 *   - If no segment are available in that period, return null
 * @param {Object} adaptationsPerType
 * @returns {number|null|undefined}
 */


function getMaximumLastPosition(adaptationsPerType) {
  var maxEncounteredPosition = null;
  var allIndexAreEmpty = true;
  var adaptationsVal = Object(object_values["a" /* default */])(adaptationsPerType).filter(function (ada) {
    return ada != null;
  });
  var allAdaptations = Object(flat_map["a" /* default */])(adaptationsVal, function (adaptationsForType) {
    return adaptationsForType;
  });

  for (var adapIndex = 0; adapIndex < allAdaptations.length; adapIndex++) {
    var representations = allAdaptations[adapIndex].representations;

    for (var repIndex = 0; repIndex < representations.length; repIndex++) {
      var representation = representations[repIndex];
      var position = representation.index.getLastPosition();

      if (position !== null) {
        allIndexAreEmpty = false;

        if (typeof position === "number") {
          maxEncounteredPosition = maxEncounteredPosition == null ? position : Math.max(maxEncounteredPosition, position);
        }
      }
    }
  }

  if (maxEncounteredPosition != null) {
    return maxEncounteredPosition;
  } else if (allIndexAreEmpty) {
    return null;
  }

  return undefined;
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_mpd.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













var DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0 = config["a" /* default */].DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0;
/**
 * @param {Element} root - The MPD root.
 * @param {Object} args
 * @returns {Object}
 */

function parseMPD(root, args) {
  // Transform whole MPD into a parsed JS object representation
  var mpdIR = createMPDIntermediateRepresentation(root);
  return loadExternalRessourcesAndParse(mpdIR, args);
}
/**
 * Checks if xlinks needs to be loaded before actually parsing the manifest.
 * @param {Object} mpdIR
 * @param {Object} args
 * @returns {Object}
 */

function loadExternalRessourcesAndParse(mpdIR, args, hasLoadedClock) {
  var rootChildren = mpdIR.children,
      rootAttributes = mpdIR.attributes;
  var xlinkInfos = new WeakMap();

  if (args.externalClockOffset == null) {
    var isDynamic = rootAttributes.type === "dynamic";
    var directTiming = Object(array_find["a" /* default */])(rootChildren.utcTimings, function (utcTiming) {
      return utcTiming.schemeIdUri === "urn:mpeg:dash:utc:direct:2014" && utcTiming.value != null;
    });
    var clockOffsetFromDirectUTCTiming = directTiming != null && directTiming.value != null ? getClockOffset(directTiming.value) : undefined;
    var clockOffset = clockOffsetFromDirectUTCTiming != null && !isNaN(clockOffsetFromDirectUTCTiming) ? clockOffsetFromDirectUTCTiming : undefined;

    if (clockOffset != null) {
      args.externalClockOffset = clockOffset;
    } else if (isDynamic && hasLoadedClock !== true) {
      var UTCTimingHTTPURL = getHTTPUTCTimingURL(mpdIR);

      if (UTCTimingHTTPURL != null && UTCTimingHTTPURL.length > 0) {
        // TODO fetch UTCTiming and XLinks at the same time
        return {
          type: "needs-ressources",
          value: {
            ressources: [UTCTimingHTTPURL],
            "continue": function continueParsingMPD(loadedRessources) {
              if (loadedRessources.length !== 1) {
                throw new Error("DASH parser: wrong number of loaded ressources.");
              }

              clockOffset = getClockOffset(loadedRessources[0].responseData);
              args.externalClockOffset = clockOffset;
              return loadExternalRessourcesAndParse(mpdIR, args, true);
            }
          }
        };
      }
    }
  }

  var xlinksToLoad = [];

  for (var i = 0; i < rootChildren.periods.length; i++) {
    var _rootChildren$periods = rootChildren.periods[i].attributes,
        xlinkHref = _rootChildren$periods.xlinkHref,
        xlinkActuate = _rootChildren$periods.xlinkActuate;

    if (xlinkHref != null && xlinkActuate === "onLoad") {
      xlinksToLoad.push({
        index: i,
        ressource: xlinkHref
      });
    }
  }

  if (xlinksToLoad.length === 0) {
    return parseCompleteIntermediateRepresentation(mpdIR, args, xlinkInfos);
  }

  return {
    type: "needs-ressources",
    value: {
      ressources: xlinksToLoad.map(function (_ref) {
        var ressource = _ref.ressource;
        return ressource;
      }),
      "continue": function continueParsingMPD(loadedRessources) {
        if (loadedRessources.length !== xlinksToLoad.length) {
          throw new Error("DASH parser: wrong number of loaded ressources.");
        } // Note: It is important to go from the last index to the first index in
        // the resulting array, as we will potentially add elements to the array


        for (var _i = loadedRessources.length - 1; _i >= 0; _i--) {
          var _rootChildren$periods2;

          var index = xlinksToLoad[_i].index;
          var _loadedRessources$_i = loadedRessources[_i],
              xlinkData = _loadedRessources$_i.responseData,
              receivedTime = _loadedRessources$_i.receivedTime,
              sendingTime = _loadedRessources$_i.sendingTime,
              url = _loadedRessources$_i.url;
          var wrappedData = "<root>" + xlinkData + "</root>";
          var dataAsXML = new DOMParser().parseFromString(wrappedData, "text/xml");

          if (dataAsXML == null || dataAsXML.children.length === 0) {
            throw new Error("DASH parser: Invalid external ressources");
          }

          var periods = dataAsXML.children[0].children;
          var periodsIR = [];

          for (var j = 0; j < periods.length; j++) {
            if (periods[j].nodeType === Node.ELEMENT_NODE) {
              var periodIR = createPeriodIntermediateRepresentation(periods[j]);
              xlinkInfos.set(periodIR, {
                receivedTime: receivedTime,
                sendingTime: sendingTime,
                url: url
              });
              periodsIR.push(periodIR);
            }
          } // replace original "xlinked" periods by the real deal


          (_rootChildren$periods2 = rootChildren.periods).splice.apply(_rootChildren$periods2, [index, 1].concat(periodsIR));
        }

        return loadExternalRessourcesAndParse(mpdIR, args);
      }
    }
  };
}
/**
 * Parse the MPD intermediate representation into a regular Manifest.
 * @param {Object} mpdIR
 * @param {Object} args
 * @returns {Object}
 */


function parseCompleteIntermediateRepresentation(mpdIR, args, xlinkInfos) {
  var _a, _b;

  var rootChildren = mpdIR.children,
      rootAttributes = mpdIR.attributes;
  var isDynamic = rootAttributes.type === "dynamic";
  var baseURLs = resolveBaseURLs(args.url === undefined ? [] : [Object(resolve_url["b" /* normalizeBaseURL */])(args.url)], rootChildren.baseURLs);
  var availabilityStartTime = parseAvailabilityStartTime(rootAttributes, args.referenceDateTime);
  var timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth;
  var clockOffset = args.externalClockOffset;
  var availabilityTimeOffset = extractMinimumAvailabilityTimeOffset(rootChildren.baseURLs);
  var manifestInfos = {
    aggressiveMode: args.aggressiveMode,
    availabilityStartTime: availabilityStartTime,
    availabilityTimeOffset: availabilityTimeOffset,
    baseURLs: baseURLs,
    clockOffset: clockOffset,
    duration: rootAttributes.duration,
    isDynamic: isDynamic,
    receivedTime: args.manifestReceivedTime,
    timeShiftBufferDepth: timeShiftBufferDepth,
    xlinkInfos: xlinkInfos
  };
  var parsedPeriods = parsePeriods(rootChildren.periods, manifestInfos);
  var mediaPresentationDuration = rootAttributes.duration;
  var parsedMPD = {
    availabilityStartTime: availabilityStartTime,
    clockOffset: args.externalClockOffset,
    isDynamic: isDynamic,
    isLive: isDynamic,
    periods: parsedPeriods,
    suggestedPresentationDelay: rootAttributes.suggestedPresentationDelay,
    transportType: "dash",
    uris: args.url == null ? rootChildren.locations : [args.url].concat(rootChildren.locations)
  }; // -- add optional fields --

  if (rootAttributes.minimumUpdatePeriod !== undefined && rootAttributes.minimumUpdatePeriod >= 0) {
    parsedMPD.lifetime = rootAttributes.minimumUpdatePeriod === 0 ? DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0 : rootAttributes.minimumUpdatePeriod;
  }

  Object(check_manifest_ids["a" /* default */])(parsedMPD);

  var _getMinimumAndMaximum = getMinimumAndMaximumPosition(parsedMPD),
      minTime = _getMinimumAndMaximum[0],
      maxTime = _getMinimumAndMaximum[1];

  var now = performance.now();

  if (!isDynamic) {
    if (minTime !== undefined) {
      parsedMPD.minimumTime = {
        isContinuous: false,
        value: minTime,
        time: now
      };
    } else if (((_a = parsedPeriods[0]) === null || _a === void 0 ? void 0 : _a.start) !== undefined) {
      parsedMPD.minimumTime = {
        isContinuous: false,
        value: parsedPeriods[0].start,
        time: now
      };
    }

    if (maxTime !== undefined) {
      parsedMPD.maximumTime = {
        isContinuous: false,
        value: maxTime,
        time: now
      };
    } else if (mediaPresentationDuration !== undefined) {
      parsedMPD.maximumTime = {
        isContinuous: false,
        value: mediaPresentationDuration,
        time: now
      };
    } else if (parsedPeriods[parsedPeriods.length - 1] !== undefined) {
      var lastPeriod = parsedPeriods[parsedPeriods.length - 1];
      var end = (_b = lastPeriod.end) !== null && _b !== void 0 ? _b : lastPeriod.duration !== undefined ? lastPeriod.start + lastPeriod.duration : undefined;

      if (end !== undefined) {
        parsedMPD.maximumTime = {
          isContinuous: false,
          value: end,
          time: now
        };
      }
    }
  } else {
    if (minTime != null) {
      parsedMPD.minimumTime = {
        isContinuous: timeShiftBufferDepth != null,
        value: minTime,
        time: now
      };
    }

    if (maxTime != null) {
      parsedMPD.maximumTime = {
        isContinuous: true,
        value: maxTime,
        time: now
      };

      if (minTime == null) {
        parsedMPD.minimumTime = {
          isContinuous: true,
          value: maxTime,
          time: now
        };
      }
    }
  }

  return {
    type: "done",
    value: parsedMPD
  };
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_from_document.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Document} manifest - Original manifest as returned by the server
 * @param {Object} args
 * @returns {Object} - parsed manifest
 */

function parseFromDocument(document, args) {
  var root = document.documentElement;

  if (root == null || root.nodeName !== "MPD") {
    throw new Error("DASH Parser: document root should be MPD");
  }

  return parseMPD(root, args);
}
// CONCATENATED MODULE: ./src/parsers/manifest/dash/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var dash = (parseFromDocument);
// CONCATENATED MODULE: ./src/transports/dash/manifest_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Request external "xlink" ressource from a MPD.
 * @param {string} xlinkURL
 * @returns {Observable}
 */

function requestStringResource(url) {
  return Object(request["a" /* default */])({
    url: url,
    responseType: "text"
  }).pipe(Object(filter["a" /* filter */])(function (e) {
    return e.type === "data-loaded";
  }), Object(map["a" /* map */])(function (e) {
    return e.value;
  }));
}
/**
 * @param {Object} options
 * @returns {Function}
 */


function generateManifestParser(options) {
  var aggressiveMode = options.aggressiveMode,
      referenceDateTime = options.referenceDateTime;
  var serverTimeOffset = options.serverSyncInfos !== undefined ? options.serverSyncInfos.serverTimestamp - options.serverSyncInfos.clientTime : undefined;
  return function manifestParser(args) {
    var _a;

    var response = args.response,
        scheduleRequest = args.scheduleRequest;
    var argClockOffset = args.externalClockOffset;
    var loaderURL = args.url;
    var url = (_a = response.url) !== null && _a !== void 0 ? _a : loaderURL;
    var data = typeof response.responseData === "string" ? new DOMParser().parseFromString(response.responseData, "text/xml") : // TODO find a way to check if Document?
    response.responseData;
    var externalClockOffset = serverTimeOffset !== null && serverTimeOffset !== void 0 ? serverTimeOffset : argClockOffset;
    var parsedManifest = dash(data, {
      aggressiveMode: aggressiveMode === true,
      url: url,
      referenceDateTime: referenceDateTime,
      externalClockOffset: externalClockOffset
    });
    return loadExternalResources(parsedManifest);

    function loadExternalResources(parserResponse) {
      if (parserResponse.type === "done") {
        var manifest = new src_manifest["a" /* default */](parserResponse.value, options);
        return Object(of["a" /* of */])({
          manifest: manifest,
          url: url
        });
      }

      var _parserResponse$value = parserResponse.value,
          ressources = _parserResponse$value.ressources,
          continueParsing = _parserResponse$value["continue"];
      var externalResources$ = ressources.map(function (resource) {
        return scheduleRequest(function () {
          return requestStringResource(resource);
        });
      });
      return Object(combineLatest["a" /* combineLatest */])(externalResources$).pipe(Object(mergeMap["a" /* mergeMap */])(function (loadedResources) {
        var resources = [];

        for (var i = 0; i < loadedResources.length; i++) {
          var resource = loadedResources[i];

          if (typeof resource.responseData !== "string") {
            throw new Error("External DASH resources should only be strings");
          } // Normally not needed but TypeScript is just dumb here


          resources.push(Object(object_assign["a" /* default */])(resource, {
            responseData: resource.responseData
          }));
        }

        return loadExternalResources(continueParsing(resources));
      }));
    }
  };
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(151);

// EXTERNAL MODULE: ./src/utils/request/fetch.ts
var fetch = __webpack_require__(89);

// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(20);

// EXTERNAL MODULE: ./src/transports/utils/byte_range.ts
var byte_range = __webpack_require__(44);

// EXTERNAL MODULE: ./src/transports/utils/check_isobmff_integrity.ts
var check_isobmff_integrity = __webpack_require__(76);

// CONCATENATED MODULE: ./src/transports/utils/is_webm_embedded_track.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Object} representation
 * @returns {boolean}
 */
function isWEBMEmbeddedTrack(representation) {
  return representation.mimeType === "video/webm" || representation.mimeType === "audio/webm";
}
// CONCATENATED MODULE: ./src/transports/dash/init_segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Perform a request for an initialization segment, agnostic to the container.
 * @param {string} url
 * @param {Object} content
 */

function initSegmentLoader(url, _ref) {
  var segment = _ref.segment;

  if (segment.range === undefined) {
    return Object(request["a" /* default */])({
      url: url,
      responseType: "arraybuffer",
      sendProgressEvents: true
    });
  }

  if (segment.indexRange === undefined) {
    return Object(request["a" /* default */])({
      url: url,
      headers: {
        Range: Object(byte_range["a" /* default */])(segment.range)
      },
      responseType: "arraybuffer",
      sendProgressEvents: true
    });
  } // range and indexRange are contiguous (99% of the cases)


  if (segment.range[1] + 1 === segment.indexRange[0]) {
    return Object(request["a" /* default */])({
      url: url,
      headers: {
        Range: Object(byte_range["a" /* default */])([segment.range[0], segment.indexRange[1]])
      },
      responseType: "arraybuffer",
      sendProgressEvents: true
    });
  }

  var rangeRequest$ = Object(request["a" /* default */])({
    url: url,
    headers: {
      Range: Object(byte_range["a" /* default */])(segment.range)
    },
    responseType: "arraybuffer",
    sendProgressEvents: false
  });
  var indexRequest$ = Object(request["a" /* default */])({
    url: url,
    headers: {
      Range: Object(byte_range["a" /* default */])(segment.indexRange)
    },
    responseType: "arraybuffer",
    sendProgressEvents: false
  });
  return Object(combineLatest["a" /* combineLatest */])([rangeRequest$, indexRequest$]).pipe(Object(map["a" /* map */])(function (_ref2) {
    var initData = _ref2[0],
        indexData = _ref2[1];
    var data = Object(byte_parsing["h" /* concat */])(new Uint8Array(initData.value.responseData), new Uint8Array(indexData.value.responseData));
    var sendingTime = Math.min(initData.value.sendingTime, indexData.value.sendingTime);
    var receivedTime = Math.max(initData.value.receivedTime, indexData.value.receivedTime);
    return {
      type: "data-loaded",
      value: {
        url: url,
        responseData: data,
        size: initData.value.size + indexData.value.size,
        duration: receivedTime - sendingTime,
        sendingTime: sendingTime,
        receivedTime: receivedTime
      }
    };
  }));
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/scan.js
var scan = __webpack_require__(222);

// EXTERNAL MODULE: ./src/transports/utils/find_complete_box.ts
var find_complete_box = __webpack_require__(72);

// CONCATENATED MODULE: ./src/transports/dash/extract_complete_chunks.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Take a chunk of ISOBMFF data and extract complete `moof`+`mdat` subsegments
 * which are ready to be decoded.
 * Returns a tuple of two containing first an array of those subsegments
 * followed by tha last un-decodable part.
 * @param {Uint8Array} buffer
 * @returns {Array}
 */

function extractCompleteChunks(buffer) {
  var _position = 0;
  var chunks = [];

  while (_position < buffer.length) {
    var currentBuffer = buffer.subarray(_position, Infinity);
    var moofIndex = Object(find_complete_box["a" /* default */])(currentBuffer, 0x6D6F6F66
    /* moof */
    );

    if (moofIndex < 0) {
      // no moof, not a segment.
      return [chunks, currentBuffer];
    }

    var moofLen = Object(byte_parsing["c" /* be4toi */])(buffer, moofIndex + _position);
    var moofEnd = _position + moofIndex + moofLen;

    if (moofEnd > buffer.length) {
      // not a complete moof segment
      return [chunks, currentBuffer];
    }

    var mdatIndex = Object(find_complete_box["a" /* default */])(currentBuffer, 0x6D646174
    /* mdat */
    );

    if (mdatIndex < 0) {
      // no mdat, not a segment.
      return [chunks, currentBuffer];
    }

    var mdatLen = Object(byte_parsing["c" /* be4toi */])(buffer, mdatIndex + _position);
    var mdatEnd = _position + mdatIndex + mdatLen;

    if (mdatEnd > buffer.length) {
      // not a complete mdat segment
      return [chunks, currentBuffer];
    }

    var maxEnd = Math.max(moofEnd, mdatEnd);
    var chunk = buffer.subarray(_position, maxEnd);
    chunks.push(chunk);
    _position = maxEnd;
  }

  return [chunks, null];
}
// CONCATENATED MODULE: ./src/transports/dash/low_latency_segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







function lowLatencySegmentLoader(url, args) {
  var segment = args.segment;
  var headers = segment.range !== undefined ? {
    Range: Object(byte_range["a" /* default */])(segment.range)
  } : undefined;
  return Object(fetch["a" /* default */])({
    url: url,
    headers: headers
  }).pipe(Object(scan["a" /* scan */])(function (acc, evt) {
    if (evt.type === "data-complete") {
      if (acc.partialChunk !== null) {
        log["a" /* default */].warn("DASH Pipelines: remaining chunk does not belong to any segment");
      }

      return {
        event: evt,
        completeChunks: [],
        partialChunk: null
      };
    }

    var data = new Uint8Array(evt.value.chunk);
    var concatenated = acc.partialChunk !== null ? Object(byte_parsing["h" /* concat */])(acc.partialChunk, data) : data;

    var _extractCompleteChunk = extractCompleteChunks(concatenated),
        completeChunks = _extractCompleteChunk[0],
        partialChunk = _extractCompleteChunk[1];

    return {
      event: evt,
      completeChunks: completeChunks,
      partialChunk: partialChunk
    };
  }, {
    event: null,
    completeChunks: [],
    partialChunk: null
  }), Object(mergeMap["a" /* mergeMap */])(function (evt) {
    var emitted = [];

    for (var i = 0; i < evt.completeChunks.length; i++) {
      emitted.push({
        type: "data-chunk",
        value: {
          responseData: evt.completeChunks[i]
        }
      });
    }

    var event = evt.event;

    if (event !== null && event.type === "data-chunk") {
      var value = event.value;
      emitted.push({
        type: "progress",
        value: {
          duration: value.duration,
          size: value.size,
          totalSize: value.totalSize
        }
      });
    } else if (event !== null && event.type === "data-complete") {
      var _value = event.value;
      emitted.push({
        type: "data-chunk-complete",
        value: {
          duration: _value.duration,
          receivedTime: _value.receivedTime,
          sendingTime: _value.sendingTime,
          size: _value.size,
          status: _value.status,
          url: _value.url
        }
      });
    }

    return of["a" /* of */].apply(void 0, emitted);
  }));
}
// CONCATENATED MODULE: ./src/transports/dash/segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */

function regularSegmentLoader(url, args, lowLatencyMode) {
  if (args.segment.isInit) {
    return initSegmentLoader(url, args);
  }

  var isWEBM = isWEBMEmbeddedTrack(args.representation);

  if (lowLatencyMode && !isWEBM) {
    if (Object(fetch["b" /* fetchIsSupported */])()) {
      return lowLatencySegmentLoader(url, args);
    } else {
      Object(warn_once["a" /* default */])("DASH: Your browser does not have the fetch API. You will have " + "a higher chance of rebuffering when playing close to the live edge");
    }
  }

  var segment = args.segment;
  return Object(request["a" /* default */])({
    url: url,
    responseType: "arraybuffer",
    sendProgressEvents: true,
    headers: segment.range !== undefined ? {
      Range: Object(byte_range["a" /* default */])(segment.range)
    } : undefined
  });
}
/**
 * Generate a segment loader:
 *   - call a custom SegmentLoader if defined
 *   - call the regular loader if not
 * @param {boolean} lowLatencyMode
 * @param {Function} [customSegmentLoader]
 * @returns {Function}
 */


function generateSegmentLoader(_ref) {
  var lowLatencyMode = _ref.lowLatencyMode,
      customSegmentLoader = _ref.segmentLoader,
      checkMediaSegmentIntegrity = _ref.checkMediaSegmentIntegrity;

  if (checkMediaSegmentIntegrity !== true) {
    return segmentLoader;
  }

  return function (content) {
    return segmentLoader(content).pipe(Object(tap["a" /* tap */])(function (res) {
      if ((res.type === "data-loaded" || res.type === "data-chunk") && res.value.responseData !== null && !isWEBMEmbeddedTrack(content.representation)) {
        Object(check_isobmff_integrity["a" /* default */])(new Uint8Array(res.value.responseData), content.segment.isInit);
      }
    }));
  };
  /**
   * @param {Object} content
   * @returns {Observable}
   */

  function segmentLoader(content) {
    var url = content.url;

    if (url == null) {
      return Object(of["a" /* of */])({
        type: "data-created",
        value: {
          responseData: null
        }
      });
    }

    if (lowLatencyMode || customSegmentLoader === undefined) {
      return regularSegmentLoader(url, content, lowLatencyMode);
    }

    var args = {
      adaptation: content.adaptation,
      manifest: content.manifest,
      period: content.period,
      representation: content.representation,
      segment: content.segment,
      transport: "dash",
      url: url
    };
    return new Observable["a" /* Observable */](function (obs) {
      var hasFinished = false;
      var hasFallbacked = false;
      /**
       * Callback triggered when the custom segment loader has a response.
       * @param {Object} args
       */

      var resolve = function resolve(_args) {
        if (!hasFallbacked) {
          hasFinished = true;
          obs.next({
            type: "data-loaded",
            value: {
              responseData: _args.data,
              size: _args.size,
              duration: _args.duration
            }
          });
          obs.complete();
        }
      };
      /**
       * Callback triggered when the custom segment loader fails
       * @param {*} err - The corresponding error encountered
       */


      var reject = function reject(err) {
        if (err === void 0) {
          err = {};
        }

        if (!hasFallbacked) {
          hasFinished = true;
          obs.error(err);
        }
      };

      var progress = function progress(_args) {
        if (!hasFallbacked) {
          obs.next({
            type: "progress",
            value: {
              duration: _args.duration,
              size: _args.size,
              totalSize: _args.totalSize
            }
          });
        }
      };
      /**
       * Callback triggered when the custom segment loader wants to fallback to
       * the "regular" implementation
       */


      var fallback = function fallback() {
        hasFallbacked = true;
        var regular$ = regularSegmentLoader(url, content, lowLatencyMode); // HACK What is TypeScript/RxJS doing here??????

        /* tslint:disable deprecation */
        // @ts-ignore

        regular$.subscribe(obs);
        /* tslint:enable deprecation */
      };

      var callbacks = {
        reject: reject,
        resolve: resolve,
        progress: progress,
        fallback: fallback
      };
      var abort = customSegmentLoader(args, callbacks);
      return function () {
        if (!hasFinished && !hasFallbacked && typeof abort === "function") {
          abort();
        }
      };
    });
  }
}
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/utils.ts
var utils = __webpack_require__(221);

// CONCATENATED MODULE: ./src/parsers/containers/matroska/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var SEGMENT_ID = 0x18538067;
var INFO_ID = 0x1549A966;
var TIMECODESCALE_ID = 0x2AD7B1;
var DURATION_ID = 0x4489;
var CUES_ID = 0x1C53BB6B;
var CUE_POINT_ID = 0xBB;
var CUE_TIME_ID = 0xB3;
var CUE_TRACK_POSITIONS_ID = 0xB7;
var CUE_CLUSTER_POSITIONS_ID = 0xF1;
/**
 * Find the offsets of the value linked to the given element ID.
 * @param {number} elementID - ID for the searched element.
 * @param {Array.<number>} parents - eventual IDs of the parent elements. From
 * top level to lower level (from the furthest to the closest).
 * @param {Uint8Array} buffer - buffer where the ID will be searched
 * @param {Array.<number>} range - start and end offsets in the buffer where the
 * ID will be searched.
 * @returns {Array.<number>|null}
 */

function findNextElement(elementID, parents, buffer, _ref) {
  var initialOffset = _ref[0],
      maxOffset = _ref[1];
  var currentOffset = initialOffset;

  while (currentOffset < maxOffset) {
    var parsedID = getEBMLID(buffer, currentOffset);

    if (parsedID == null) {
      return null;
    }

    var ebmlTagID = parsedID.value,
        ebmlTagLength = parsedID.length;
    var sizeOffset = currentOffset + ebmlTagLength;
    var parsedValue = getEBMLValue(buffer, sizeOffset);

    if (parsedValue == null) {
      return null;
    }

    var valueLengthLength = parsedValue.length,
        valueLength = parsedValue.value;
    var valueOffset = sizeOffset + valueLengthLength;
    var valueEndOffset = valueOffset + valueLength;

    if (ebmlTagID === elementID) {
      return [valueOffset, valueEndOffset];
    } else if (parents.length > 0) {
      for (var i = 0; i < parents.length; i++) {
        if (ebmlTagID === parents[i]) {
          var newParents = parents.slice(i + 1, parents.length);
          return findNextElement(elementID, newParents, buffer, [valueOffset, valueEndOffset]);
        }
      }
    }

    currentOffset = valueEndOffset;
  }

  return null;
}
/**
 * Return the timecode scale (basically timescale) of the whole file.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */


function getTimeCodeScale(buffer, initialOffset) {
  var timeCodeScaleOffsets = findNextElement(TIMECODESCALE_ID, [SEGMENT_ID, INFO_ID], buffer, [initialOffset, buffer.length]);

  if (timeCodeScaleOffsets == null) {
    return null;
  }

  var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
  return 1e9 / bytesToNumber(buffer, timeCodeScaleOffsets[0], length);
}
/**
 * Return the duration of the concerned media.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */

function getDuration(buffer, initialOffset) {
  var timeCodeScaleOffsets = findNextElement(DURATION_ID, [SEGMENT_ID, INFO_ID], buffer, [initialOffset, buffer.length]);

  if (timeCodeScaleOffsets == null) {
    return null;
  }

  var length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];

  if (length === 4) {
    return get_IEEE754_32Bits(buffer, timeCodeScaleOffsets[0]);
  } else if (length === 8) {
    return get_IEEE754_64Bits(buffer, timeCodeScaleOffsets[0]);
  }

  return null;
}
/**
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {Array.<Object>|null}
 */


function getSegmentsFromCues(buffer, initialOffset) {
  var segmentRange = findNextElement(SEGMENT_ID, [], buffer, [initialOffset, buffer.length]);

  if (segmentRange == null) {
    return null;
  }

  var segmentRangeStart = segmentRange[0],
      segmentRangeEnd = segmentRange[1];
  var timescale = getTimeCodeScale(buffer, segmentRangeStart);

  if (timescale == null) {
    return null;
  }

  var duration = getDuration(buffer, segmentRangeStart);

  if (duration == null) {
    return null;
  }

  var cuesRange = findNextElement(CUES_ID, [], buffer, [segmentRangeStart, segmentRangeEnd]);

  if (cuesRange == null) {
    return null;
  }

  var rawInfos = [];
  var currentOffset = cuesRange[0];

  while (currentOffset < cuesRange[1]) {
    var cuePointRange = findNextElement(CUE_POINT_ID, [], buffer, [currentOffset, cuesRange[1]]);

    if (cuePointRange == null) {
      break;
    }

    var cueTimeRange = findNextElement(CUE_TIME_ID, [], buffer, [cuePointRange[0], cuePointRange[1]]);

    if (cueTimeRange == null) {
      return null;
    }

    var time = bytesToNumber(buffer, cueTimeRange[0], cueTimeRange[1] - cueTimeRange[0]);
    var cueOffsetRange = findNextElement(CUE_CLUSTER_POSITIONS_ID, [CUE_TRACK_POSITIONS_ID], buffer, [cuePointRange[0], cuePointRange[1]]);

    if (cueOffsetRange == null) {
      return null;
    }

    var rangeStart = bytesToNumber(buffer, cueOffsetRange[0], cueOffsetRange[1] - cueOffsetRange[0]) + segmentRangeStart;
    rawInfos.push({
      time: time,
      rangeStart: rangeStart
    });
    currentOffset = cuePointRange[1];
  }

  var segments = [];

  for (var i = 0; i < rawInfos.length; i++) {
    var currentSegment = rawInfos[i];

    if (i === rawInfos.length - 1) {
      segments.push({
        time: currentSegment.time,
        count: 0,
        timescale: timescale,
        duration: i === 0 ? duration : duration - currentSegment.time,
        range: [currentSegment.rangeStart, Infinity]
      });
    } else {
      segments.push({
        time: currentSegment.time,
        count: 0,
        timescale: timescale,
        duration: rawInfos[i + 1].time - currentSegment.time,
        range: [currentSegment.rangeStart, rawInfos[i + 1].rangeStart - 1]
      });
    }
  }

  return segments;
}

function getLength(buffer, offset) {
  for (var length = 1; length <= 8; length++) {
    if (buffer[offset] >= Math.pow(2, 8 - length)) {
      return length;
    }
  }

  return undefined;
}

function getEBMLID(buffer, offset) {
  var length = getLength(buffer, offset);

  if (length == null) {
    log["a" /* default */].warn("webm: unrepresentable length");
    return null;
  }

  if (offset + length > buffer.length) {
    log["a" /* default */].warn("webm: impossible length");
    return null;
  }

  var value = 0;

  for (var i = 0; i < length; i++) {
    value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
  }

  return {
    length: length,
    value: value
  };
}

function getEBMLValue(buffer, offset) {
  var length = getLength(buffer, offset);

  if (length == null) {
    log["a" /* default */].warn("webm: unrepresentable length");
    return null;
  }

  if (offset + length > buffer.length) {
    log["a" /* default */].warn("webm: impossible length");
    return null;
  }

  var value = (buffer[offset] & (1 << 8 - length) - 1) * Math.pow(2, (length - 1) * 8);

  for (var i = 1; i < length; i++) {
    value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
  }

  return {
    length: length,
    value: value
  };
}
/**
 * Convert a IEEE754 32 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */


function get_IEEE754_32Bits(buffer, offset) {
  return new DataView(buffer.buffer).getFloat32(offset);
}
/**
 * Convert a IEEE754 64 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */


function get_IEEE754_64Bits(buffer, offset) {
  return new DataView(buffer.buffer).getFloat64(offset);
}

function bytesToNumber(buffer, offset, length) {
  var value = 0;

  for (var i = 0; i < length; i++) {
    value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
  }

  return value;
}
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(9);

// CONCATENATED MODULE: ./src/transports/utils/get_isobmff_timing_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get precize start and duration of a chunk.
 * @param {UInt8Array} buffer - An ISOBMFF container (at least a `moof` + a
 * `mdat` box.
 * @param {Boolean} isChunked - If true, the whole segment was chunked into
 * multiple parts and buffer is one of them. If false, buffer is the whole
 * segment.
 * @param {Object} segment
 * @param {Array.<Object>|undefined} sidxSegments - Segments from sidx. Here
 * pre-parsed for performance reasons as it is usually available when
 * this function is called.
 * @param {number|undefined} initTimescale
 * @returns {Object}
 */

function getISOBMFFTimingInfos(buffer, isChunked, segment, initTimescale) {
  var startTime;
  var duration;
  var trunDuration = Object(utils["a" /* getDurationFromTrun */])(buffer);
  var timescale = initTimescale !== null && initTimescale !== void 0 ? initTimescale : segment.timescale;
  var baseDecodeTime = Object(utils["d" /* getTrackFragmentDecodeTime */])(buffer);

  if (isChunked) {
    // when chunked, no mean to know the duration for now
    if (initTimescale === undefined) {
      return null;
    }

    if (baseDecodeTime < 0) {
      return null;
    }

    return {
      time: baseDecodeTime,
      duration: trunDuration >= 0 ? trunDuration : undefined,
      timescale: initTimescale
    };
  } // we could always make a mistake when reading a container.
  // If the estimate is too far from what the segment seems to imply, take
  // the segment infos instead.


  var maxDecodeTimeDelta; // Scaled start time and duration as announced in the segment data

  var segmentDuration;

  if (timescale === segment.timescale) {
    maxDecodeTimeDelta = Math.min(timescale * 0.9, !Object(is_null_or_undefined["a" /* default */])(segment.duration) ? segment.duration / 4 : 0.25);
    segmentDuration = segment.duration;
  } else {
    maxDecodeTimeDelta = Math.min(timescale * 0.9, !Object(is_null_or_undefined["a" /* default */])(segment.duration) ? segment.duration / segment.timescale * timescale / 4 : 0.25);
    segmentDuration = !Object(is_null_or_undefined["a" /* default */])(segment.duration) ? segment.duration / segment.timescale * timescale : undefined;
  }

  if (baseDecodeTime >= 0) {
    startTime = segment.timestampOffset !== undefined ? baseDecodeTime + segment.timestampOffset * timescale : baseDecodeTime;
  } else {
    return null;
  }

  if (trunDuration >= 0 && (segmentDuration === undefined || Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta)) {
    duration = trunDuration;
  }

  return {
    timescale: timescale,
    time: startTime,
    duration: duration
  };
}
// CONCATENATED MODULE: ./src/transports/dash/segment_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






function parser(_ref) {
  var content = _ref.content,
      response = _ref.response,
      initTimescale = _ref.initTimescale;
  var period = content.period,
      representation = content.representation,
      segment = content.segment;
  var data = response.data,
      isChunked = response.isChunked;
  var appendWindow = [period.start, period.end];

  if (data === null) {
    if (segment.isInit) {
      var _segmentProtections = representation.getProtectionsInitializationData();

      return Object(of["a" /* of */])({
        type: "parsed-init-segment",
        value: {
          initializationData: null,
          segmentProtections: _segmentProtections,
          initTimescale: undefined
        }
      });
    }

    return Object(of["a" /* of */])({
      type: "parsed-segment",
      value: {
        chunkData: null,
        chunkInfos: null,
        chunkOffset: 0,
        appendWindow: appendWindow
      }
    });
  }

  var chunkData = data instanceof Uint8Array ? data : new Uint8Array(data);
  var isWEBM = isWEBMEmbeddedTrack(representation);

  if (!segment.isInit) {
    var chunkInfos = isWEBM ? null : // TODO extract time info from webm
    getISOBMFFTimingInfos(chunkData, isChunked, segment, initTimescale);
    var chunkOffset = Object(take_first_set["a" /* default */])(segment.timestampOffset, 0);
    return Object(of["a" /* of */])({
      type: "parsed-segment",
      value: {
        chunkData: chunkData,
        chunkInfos: chunkInfos,
        chunkOffset: chunkOffset,
        appendWindow: appendWindow
      }
    });
  } // we're handling an initialization segment


  var indexRange = segment.indexRange;
  var nextSegments = isWEBM ? getSegmentsFromCues(chunkData, 0) : Object(utils["c" /* getSegmentsFromSidx */])(chunkData, Array.isArray(indexRange) ? indexRange[0] : 0);

  if (nextSegments !== null && nextSegments.length > 0) {
    representation.index._addSegments(nextSegments);
  }

  var timescale = isWEBM ? getTimeCodeScale(chunkData, 0) : Object(utils["b" /* getMDHDTimescale */])(chunkData);
  var parsedTimescale = timescale !== null && timescale > 0 ? timescale : undefined; // if (!isWEBM) { // TODO extract webm protection information
  //   const psshInfo = takePSSHOut(chunkData);
  //   for (let i = 0; i < psshInfo.length; i++) {
  //     const { systemID, data: psshData } = psshInfo[i];
  //     representation._addProtectionData("cenc", systemID, psshData);
  //   }
  // }

  var segmentProtections = representation.getProtectionsInitializationData();
  return Object(of["a" /* of */])({
    type: "parsed-init-segment",
    value: {
      initializationData: chunkData,
      segmentProtections: segmentProtections,
      initTimescale: parsedTimescale
    }
  });
}
// CONCATENATED MODULE: ./src/transports/utils/is_mp4_embedded_text_track.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */
function isMP4EmbeddedTextTrack(representation) {
  return representation.mimeType === "application/mp4";
}
// CONCATENATED MODULE: ./src/transports/dash/text_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









/**
 * Perform requests for "text" segments
 * @param {boolean} lowLatencyMode
 * @returns {Function}
 */

function generateTextTrackLoader(_ref) {
  var lowLatencyMode = _ref.lowLatencyMode,
      checkMediaSegmentIntegrity = _ref.checkMediaSegmentIntegrity;

  if (checkMediaSegmentIntegrity !== true) {
    return textTrackLoader;
  }

  return function (content) {
    return textTrackLoader(content).pipe(Object(tap["a" /* tap */])(function (res) {
      if ((res.type === "data-loaded" || res.type === "data-chunk") && res.value.responseData !== null && typeof res.value.responseData !== "string") {
        Object(check_isobmff_integrity["a" /* default */])(new Uint8Array(res.value.responseData), content.segment.isInit);
      }
    }));
  };
  /**
   * @param {Object} args
   * @returns {Observable}
   */

  function textTrackLoader(args) {
    var range = args.segment.range;
    var url = args.url;

    if (url === null) {
      return Object(of["a" /* of */])({
        type: "data-created",
        value: {
          responseData: null
        }
      });
    }

    if (args.segment.isInit) {
      return initSegmentLoader(url, args);
    }

    var isMP4Embedded = isMP4EmbeddedTextTrack(args.representation);

    if (lowLatencyMode && isMP4Embedded) {
      if (Object(fetch["b" /* fetchIsSupported */])()) {
        return lowLatencySegmentLoader(url, args);
      } else {
        Object(warn_once["a" /* default */])("DASH: Your browser does not have the fetch API. You will have " + "a higher chance of rebuffering when playing close to the live edge");
      }
    } // ArrayBuffer when in mp4 to parse isobmff manually, text otherwise


    var responseType = isMP4Embedded ? "arraybuffer" : "text";
    return Object(request["a" /* default */])({
      url: url,
      responseType: responseType,
      headers: Array.isArray(range) ? {
        Range: Object(byte_range["a" /* default */])(range)
      } : null,
      sendProgressEvents: true
    });
  }
}
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/read.ts
var read = __webpack_require__(137);

// EXTERNAL MODULE: ./src/utils/string_from_utf8.ts
var string_from_utf8 = __webpack_require__(117);

// CONCATENATED MODULE: ./src/transports/utils/parse_text_track.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Return plain text text track from the given ISOBMFF.
 * @param {Uint8Array} chunkBytes
 * @returns {string}
 */

function extractTextTrackFromISOBMFF(chunkBytes) {
  return Object(string_from_utf8["a" /* default */])(Object(read["a" /* getMDAT */])(chunkBytes));
}
/**
 * Returns the a string expliciting the format of a text track when that text
 * track is embedded into a ISOBMFF file.
 * @param {Object} representation
 * @returns {string}
 */

function getISOBMFFTextTrackFormat(representation) {
  var codec = representation.codec;

  if (codec === undefined) {
    throw new Error("Cannot parse subtitles: unknown format");
  }

  switch (codec.toLowerCase()) {
    case "stpp": // stpp === TTML in MP4

    case "stpp.ttml.im1t":
      return "ttml";

    case "wvtt":
      // wvtt === WebVTT in MP4
      return "vtt";
  }

  throw new Error("The codec used for the subtitles " + ("\"" + codec + "\" is not managed yet."));
}
/**
 * Returns the a string expliciting the format of a text track in plain text.
 * @param {Object} representation
 * @returns {string}
 */

function getPlainTextTrackFormat(representation) {
  var _representation$mimeT = representation.mimeType,
      mimeType = _representation$mimeT === void 0 ? "" : _representation$mimeT;

  switch (representation.mimeType) {
    case "application/ttml+xml":
      return "ttml";

    case "application/x-sami":
    case "application/smil":
      return "sami";

    case "text/vtt":
      return "vtt";
  }

  var _representation$codec = representation.codec,
      codec = _representation$codec === void 0 ? "" : _representation$codec;
  var codeLC = codec.toLowerCase();

  if (codeLC === "srt") {
    return "srt";
  }

  throw new Error("could not find a text-track parser for the type " + mimeType);
}
/**
 * @param {Object} content
 * @param {ArrayBuffer|UInt8Array|null} chunkData
 * @param {Object|null} chunkInfos
 * @param {boolean} isChunked
 * @returns {Object|null}
 */

function getISOBMFFEmbeddedTextTrackData(_ref, chunkBytes, chunkInfos, isChunked) {
  var segment = _ref.segment,
      adaptation = _ref.adaptation,
      representation = _ref.representation;

  if (segment.isInit) {
    return null;
  }

  var startTime;
  var endTime;
  var timescale = 1;

  if (chunkInfos === null) {
    if (!isChunked) {
      log["a" /* default */].warn("Transport: Unavailable time data for current text track.");
    } else {
      startTime = segment.time;
      endTime = startTime + segment.duration;
      timescale = segment.timescale;
    }
  } else {
    startTime = chunkInfos.time;

    if (chunkInfos.duration !== undefined) {
      endTime = startTime + chunkInfos.duration;
    } else if (!isChunked) {
      endTime = startTime + segment.duration;
    }

    timescale = chunkInfos.timescale;
  }

  var type = getISOBMFFTextTrackFormat(representation);
  var textData = extractTextTrackFromISOBMFF(chunkBytes);
  return {
    data: textData,
    type: type,
    language: adaptation.language,
    start: startTime,
    end: endTime,
    timescale: timescale
  };
}
/**
 * @param {Object} content
 * @param {ArrayBuffer|UInt8Array|null} chunkData
 * @param {Object|null} chunkInfos
 * @param {boolean} isChunked
 * @returns {Object|null}
 */

function getPlainTextTrackData(_ref2, textTrackData, isChunked) {
  var segment = _ref2.segment,
      adaptation = _ref2.adaptation,
      representation = _ref2.representation;

  if (segment.isInit) {
    return null;
  }

  var start;
  var end;
  var timescale = 1;

  if (!isChunked) {
    start = segment.time;
    end = start + segment.duration;
    timescale = segment.timescale;
  } else {
    log["a" /* default */].warn("Transport: Unavailable time data for current text track.");
  }

  var type = getPlainTextTrackFormat(representation);
  return {
    data: textTrackData,
    type: type,
    language: adaptation.language,
    start: start,
    end: end,
    timescale: timescale
  };
}
// CONCATENATED MODULE: ./src/transports/dash/text_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Parse TextTrack data when it is embedded in an ISOBMFF file.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */

function parseISOBMFFEmbeddedTextTrack(_ref) {
  var response = _ref.response,
      content = _ref.content,
      initTimescale = _ref.initTimescale;
  var period = content.period,
      representation = content.representation,
      segment = content.segment;
  var isInit = segment.isInit,
      indexRange = segment.indexRange;
  var data = response.data,
      isChunked = response.isChunked;
  var chunkBytes = typeof data === "string" ? Object(byte_parsing["q" /* strToBytes */])(data) : data instanceof Uint8Array ? data : new Uint8Array(data);

  if (isInit) {
    var sidxSegments = Object(utils["c" /* getSegmentsFromSidx */])(chunkBytes, Array.isArray(indexRange) ? indexRange[0] : 0);
    var mdhdTimescale = Object(utils["b" /* getMDHDTimescale */])(chunkBytes);

    if (sidxSegments !== null && sidxSegments.length > 0) {
      representation.index._addSegments(sidxSegments);
    }

    return Object(of["a" /* of */])({
      type: "parsed-init-segment",
      value: {
        initializationData: null,
        segmentProtections: [],
        initTimescale: mdhdTimescale > 0 ? mdhdTimescale : undefined
      }
    });
  }

  var chunkInfos = getISOBMFFTimingInfos(chunkBytes, isChunked, segment, initTimescale);
  var chunkData = getISOBMFFEmbeddedTextTrackData(content, chunkBytes, chunkInfos, isChunked);
  var chunkOffset = Object(take_first_set["a" /* default */])(segment.timestampOffset, 0);
  return Object(of["a" /* of */])({
    type: "parsed-segment",
    value: {
      chunkData: chunkData,
      chunkInfos: chunkInfos,
      chunkOffset: chunkOffset,
      appendWindow: [period.start, period.end]
    }
  });
}
/**
 * Parse TextTrack data in plain text form.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */


function parsePlainTextTrack(_ref2) {
  var response = _ref2.response,
      content = _ref2.content;
  var period = content.period,
      segment = content.segment;
  var _segment$timestampOff = segment.timestampOffset,
      timestampOffset = _segment$timestampOff === void 0 ? 0 : _segment$timestampOff;

  if (segment.isInit) {
    return Object(of["a" /* of */])({
      type: "parsed-init-segment",
      value: {
        initializationData: null,
        segmentProtections: [],
        initTimescale: undefined
      }
    });
  }

  var data = response.data,
      isChunked = response.isChunked;
  var textTrackData;

  if (typeof data !== "string") {
    var bytesData = data instanceof Uint8Array ? data : new Uint8Array(data);
    textTrackData = Object(byte_parsing["f" /* bytesToStr */])(bytesData);
  } else {
    textTrackData = data;
  }

  var chunkData = getPlainTextTrackData(content, textTrackData, isChunked);
  return Object(of["a" /* of */])({
    type: "parsed-segment",
    value: {
      chunkData: chunkData,
      chunkInfos: null,
      chunkOffset: timestampOffset,
      appendWindow: [period.start, period.end]
    }
  });
}
/**
 * Parse TextTrack data.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */


function textTrackParser(_ref3) {
  var response = _ref3.response,
      content = _ref3.content,
      initTimescale = _ref3.initTimescale;
  var period = content.period,
      representation = content.representation,
      segment = content.segment;
  var _segment$timestampOff2 = segment.timestampOffset,
      timestampOffset = _segment$timestampOff2 === void 0 ? 0 : _segment$timestampOff2;
  var data = response.data,
      isChunked = response.isChunked;

  if (data === null) {
    // No data, just return empty infos
    if (segment.isInit) {
      return Object(of["a" /* of */])({
        type: "parsed-init-segment",
        value: {
          initializationData: null,
          segmentProtections: [],
          initTimescale: undefined
        }
      });
    }

    return Object(of["a" /* of */])({
      type: "parsed-segment",
      value: {
        chunkData: null,
        chunkInfos: null,
        chunkOffset: timestampOffset,
        appendWindow: [period.start, period.end]
      }
    });
  }

  var isMP4 = isMP4EmbeddedTextTrack(representation);

  if (isMP4) {
    return parseISOBMFFEmbeddedTextTrack({
      response: {
        data: data,
        isChunked: isChunked
      },
      content: content,
      initTimescale: initTimescale
    });
  } else {
    return parsePlainTextTrack({
      response: {
        data: data,
        isChunked: isChunked
      },
      content: content
    });
  }
}
// CONCATENATED MODULE: ./src/transports/dash/pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Returns pipelines used for DASH streaming.
 * @param {Object} options
 * implementation. Used for each generated http request.
 * @returns {Object}
 */

/* harmony default export */ var pipelines = (function (options) {
  var manifestLoader = Object(document_manifest_loader["a" /* default */])({
    customManifestLoader: options.manifestLoader
  });
  var manifestParser = generateManifestParser(options);
  var segmentLoader = generateSegmentLoader(options);
  var textTrackLoader = generateTextTrackLoader(options);
  return {
    manifest: {
      loader: manifestLoader,
      parser: manifestParser
    },
    audio: {
      loader: segmentLoader,
      parser: parser
    },
    video: {
      loader: segmentLoader,
      parser: parser
    },
    text: {
      loader: textTrackLoader,
      parser: textTrackParser
    },
    image: {
      loader: imageLoader,
      parser: imageParser
    }
  };
});
// CONCATENATED MODULE: ./src/transports/dash/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var transports_dash = __webpack_exports__["default"] = (pipelines);

/***/ }),
/* 197 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(151);

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(11);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/manifest/index.ts + 5 modules
var src_manifest = __webpack_require__(66);

// EXTERNAL MODULE: ./src/parsers/containers/isobmff/read.ts
var read = __webpack_require__(137);

// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(10);

// EXTERNAL MODULE: ./src/utils/assert.ts
var assert = __webpack_require__(48);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(7);

// EXTERNAL MODULE: ./src/utils/resolve_url.ts
var resolve_url = __webpack_require__(61);

// EXTERNAL MODULE: ./src/utils/take_first_set.ts
var take_first_set = __webpack_require__(16);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/check_manifest_ids.ts
var check_manifest_ids = __webpack_require__(114);

// CONCATENATED MODULE: ./src/parsers/manifest/smooth/get_codecs.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {string} codecPrivateData
 * @param {string|undefined} fourCC
 * @returns {string}
 */

function getAudioCodecs(codecPrivateData, fourCC) {
  var mpProfile;

  if (fourCC === "AACH") {
    mpProfile = 5; // High Efficiency AAC Profile
  } else {
    mpProfile = Object(is_non_empty_string["a" /* default */])(codecPrivateData) ? (parseInt(codecPrivateData.substring(0, 2), 16) & 0xF8) >> 3 : 2;
  }

  if (mpProfile === 0) {
    // Return default audio codec
    return "mp4a.40.2";
  }

  return "mp4a.40." + mpProfile;
}
/**
 * @param {string} codecPrivateData
 * @returns {string}
 */

function getVideoCodecs(codecPrivateData) {
  // we can extract codes only if fourCC is on of "H264", "X264", "DAVC", "AVC1"
  var arr = /00000001\d7([0-9a-fA-F]{6})/.exec(codecPrivateData);

  if (arr === null || !Object(is_non_empty_string["a" /* default */])(arr[1])) {
    // Return default video codec
    return "avc1.4D401E";
  }

  return "avc1." + arr[1];
}
// CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_C_nodes.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse C nodes to build index timeline.
 * @param {Element} nodes
 */

function parseCNodes(nodes) {
  return nodes.reduce(function (timeline, node, i) {
    var dAttr = node.getAttribute("d");
    var tAttr = node.getAttribute("t");
    var rAttr = node.getAttribute("r");
    var repeatCount = rAttr !== null ? +rAttr - 1 : 0;
    var start = tAttr !== null ? +tAttr : undefined;
    var duration = dAttr !== null ? +dAttr : undefined;

    if (i === 0) {
      // first node
      start = start === undefined || isNaN(start) ? 0 : start;
    } else {
      // from second node to the end
      var prev = timeline[i - 1];

      if (start == null || isNaN(start)) {
        if (prev.duration == null || isNaN(prev.duration)) {
          throw new Error("Smooth: Invalid CNodes. Missing timestamp.");
        }

        start = prev.start + prev.duration * (prev.repeatCount + 1);
      }
    }

    if (duration == null || isNaN(duration)) {
      var nextNode = nodes[i + 1];

      if (nextNode !== undefined) {
        var nextTAttr = nextNode.getAttribute("t");
        var nextStart = Object(is_non_empty_string["a" /* default */])(nextTAttr) ? +nextTAttr : null;

        if (nextStart === null) {
          throw new Error("Can't build index timeline from Smooth Manifest.");
        }

        duration = nextStart - start;
      } else {
        return timeline;
      }
    }

    timeline.push({
      duration: duration,
      start: start,
      repeatCount: repeatCount
    });
    return timeline;
  }, []);
}
// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(1);

// EXTERNAL MODULE: ./src/parsers/containers/isobmff/drm/playready.ts
var playready = __webpack_require__(188);

// CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_protection_node.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Uint8Array} keyIdBytes
 * @returns {Array.<Object>}
 */

function createWidevineKeySystem(keyIdBytes) {
  return [{
    systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
    privateData: Object(byte_parsing["h" /* concat */])([0x08, 0x01, 0x12, 0x10], keyIdBytes)
  }];
}
/**
 * Parse "Protection" Node, which contains DRM information
 * @param {Element} protectionNode
 * @returns {Object}
 */


function parseProtectionNode(protectionNode, keySystemCreator) {
  if (keySystemCreator === void 0) {
    keySystemCreator = createWidevineKeySystem;
  }

  if (protectionNode.firstElementChild === null || protectionNode.firstElementChild.nodeName !== "ProtectionHeader") {
    throw new Error("Protection should have ProtectionHeader child");
  }

  var header = protectionNode.firstElementChild;
  var privateData = Object(byte_parsing["q" /* strToBytes */])(atob(header.textContent === null ? "" : header.textContent));
  var keyIdHex = Object(playready["a" /* getPlayReadyKIDFromPrivateData */])(privateData);
  var keyIdBytes = Object(byte_parsing["j" /* hexToBytes */])(keyIdHex); // remove possible braces

  var systemIdAttr = header.getAttribute("SystemID");
  var systemId = (systemIdAttr !== null ? systemIdAttr : "").toLowerCase().replace(/\{|\}/g, "");
  return {
    keyId: keyIdBytes,
    keySystems: [{
      systemId: systemId,
      privateData: privateData
    }].concat(keySystemCreator(keyIdBytes))
  };
}
// EXTERNAL MODULE: ./src/errors/network_error.ts
var network_error = __webpack_require__(171);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/clear_timeline_from_position.ts
var clear_timeline_from_position = __webpack_require__(113);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/index_helpers.ts
var index_helpers = __webpack_require__(18);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/is_segment_still_available.ts
var is_segment_still_available = __webpack_require__(111);

// EXTERNAL MODULE: ./src/parsers/manifest/utils/update_segment_timeline.ts
var update_segment_timeline = __webpack_require__(112);

// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/add_segment_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Object} currentSegment
 * @returns {Boolean} - true if the segment has been added
 */

function _addSegmentInfos(index, newSegment, currentSegment) {
  var timeline = index.timeline,
      timescale = index.timescale;
  var timelineLength = timeline.length;
  var last = timeline[timelineLength - 1];
  var scaledNewSegment = newSegment.timescale === timescale ? {
    time: newSegment.time,
    duration: newSegment.duration
  } : {
    time: newSegment.time / newSegment.timescale * timescale,
    duration: newSegment.duration / newSegment.timescale * timescale
  };
  var scaledCurrentTime;

  if (currentSegment.timescale !== 0) {
    scaledCurrentTime = currentSegment.timescale === timescale ? currentSegment.time : currentSegment.time / currentSegment.timescale * timescale;
  } // in some circumstances, the new segment information are only duration
  // information that we could use to deduct the start of the next segment.
  // This is the case where the new segment are associated to a current
  // segment and have the same start.
  // However, we prefer to be sure of the duration of the new segments
  // before adding such segments.


  var shouldDeductNextSegment = scaledCurrentTime != null && scaledNewSegment.time === scaledCurrentTime;

  if (shouldDeductNextSegment) {
    return false;
  } else if (scaledNewSegment.time >= Object(index_helpers["c" /* getIndexSegmentEnd */])(last, null)) {
    // if the given timing has a timestamp after the timeline end we
    // just need to push a new element in the timeline, or increase
    // the @r attribute of the last element.
    if (last.duration === scaledNewSegment.duration) {
      last.repeatCount++;
    } else {
      index.timeline.push({
        duration: scaledNewSegment.duration,
        start: scaledNewSegment.time,
        repeatCount: 0
      });
    }

    return true;
  }

  return false;
}
// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/tokens.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {string} url
 * @param {string|number} bitrate
 * @returns {string}
 */
function replaceRepresentationSmoothTokens(url, bitrate, customAttributes) {
  return url.replace(/\{bitrate\}/g, String(bitrate)).replace(/{CustomAttributes}/g, customAttributes.length > 0 ? customAttributes[0] : "");
}
/**
 * @param {string} url
 * @param {number} time
 * @returns {string}
 */


function replaceSegmentSmoothTokens(url, time) {
  return url.replace(/\{start time\}/g, String(time));
}


// CONCATENATED MODULE: ./src/parsers/manifest/smooth/representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Get index of the segment containing the given timescaled timestamp.
 * @param {Object} index
 * @param {Number} start
 * @returns {Number}
 */

function getSegmentIndex(index, start) {
  var timeline = index.timeline;
  var low = 0;
  var high = timeline.length;

  while (low < high) {
    var mid = low + high >>> 1;

    if (timeline[mid].start < start) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }

  return low > 0 ? low - 1 : low;
}
/**
 * @param {Number} start
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */


function getSegmentNumber(start, up, duration) {
  var diff = up - start;
  return diff > 0 ? Math.floor(diff / duration) : 0;
} // interface ISmoothIndex {
//   presentationTimeOffset? : number;
//   timescale : number;
//   media? : string;
//   timeline : IIndexSegment[];
//   startNumber? : number;
// }

/**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} start
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */


function normalizeRange(index, start, duration) {
  var timescale = index.timescale === undefined || index.timescale === 0 ? 1 : index.timescale;
  return {
    up: start * timescale,
    to: (start + duration) * timescale
  };
}
/**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} segment
 * @param {Object} nextSegment
 * @returns {Number}
 */


function calculateRepeat(segment, nextSegment) {
  var repeatCount = segment.repeatCount; // A negative value of the @r attribute of the S element indicates
  // that the duration indicated in @d attribute repeats until the
  // start of the next S element, the end of the Period or until the
  // next MPD update.
  // TODO Also for SMOOTH????

  if (segment.duration != null && repeatCount < 0) {
    var repeatEnd = nextSegment !== undefined ? nextSegment.start : Infinity;
    repeatCount = Math.ceil((repeatEnd - segment.start) / segment.duration) - 1;
  }

  return repeatCount;
}
/**
 * RepresentationIndex implementation for Smooth Manifests.
 *
 * Allows to interact with the index to create new Segments.
 *
 * @class SmoothRepresentationIndex
 */


var representation_index_SmoothRepresentationIndex = /*#__PURE__*/function () {
  function SmoothRepresentationIndex(index, options) {
    var aggressiveMode = options.aggressiveMode,
        isLive = options.isLive,
        segmentPrivateInfos = options.segmentPrivateInfos;
    var estimatedReceivedTime = index.manifestReceivedTime == null ? performance.now() : index.manifestReceivedTime;
    this._index = index;
    this._indexValidityTime = estimatedReceivedTime;
    this._initSegmentInfos = {
      bitsPerSample: segmentPrivateInfos.bitsPerSample,
      channels: segmentPrivateInfos.channels,
      codecPrivateData: segmentPrivateInfos.codecPrivateData,
      packetSize: segmentPrivateInfos.packetSize,
      samplingRate: segmentPrivateInfos.samplingRate,
      protection: segmentPrivateInfos.protection
    };
    this._isAggressiveMode = aggressiveMode;
    this._isLive = isLive;

    if (index.timeline.length !== 0) {
      var lastItem = index.timeline[index.timeline.length - 1];
      var scaledEnd = Object(index_helpers["c" /* getIndexSegmentEnd */])(lastItem, null);
      this._initialScaledLastPosition = scaledEnd;

      if (index.isLive) {
        var scaledReceivedTime = estimatedReceivedTime / 1000 * index.timescale;
        this._scaledLiveGap = scaledReceivedTime - scaledEnd;
      }
    }
  }
  /**
   * Construct init Segment compatible with a Smooth Manifest.
   * @returns {Object}
   */


  var _proto = SmoothRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    return {
      id: "init",
      isInit: true,
      time: 0,
      duration: 0,
      timescale: this._index.timescale,
      privateInfos: {
        smoothInit: this._initSegmentInfos
      },
      mediaURLs: null
    };
  }
  /**
   * Generate a list of Segments for a particular period of time.
   *
   * @param {Number} _up
   * @param {Number} _to
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments(_up, _to) {
    this._refreshTimeline();

    var _normalizeRange = normalizeRange(this._index, _up, _to),
        up = _normalizeRange.up,
        to = _normalizeRange.to;

    var _this$_index = this._index,
        timeline = _this$_index.timeline,
        timescale = _this$_index.timescale,
        media = _this$_index.media;
    var isAggressive = this._isAggressiveMode;
    var currentNumber;
    var segments = [];
    var timelineLength = timeline.length;
    var maxPosition = this._scaledLiveGap == null ? undefined : performance.now() / 1000 * timescale - this._scaledLiveGap;

    for (var i = 0; i < timelineLength; i++) {
      var segmentRange = timeline[i];
      var duration = segmentRange.duration,
          start = segmentRange.start;
      var repeat = calculateRepeat(segmentRange, timeline[i + 1]);
      var segmentNumberInCurrentRange = getSegmentNumber(start, up, duration);
      var segmentTime = start + segmentNumberInCurrentRange * duration;
      var timeToAddToCheckMaxPosition = isAggressive ? 0 : duration;

      while (segmentTime < to && segmentNumberInCurrentRange <= repeat && (maxPosition == null || segmentTime + timeToAddToCheckMaxPosition <= maxPosition)) {
        var time = segmentTime;
        var number = currentNumber != null ? currentNumber + segmentNumberInCurrentRange : undefined;
        var segment = {
          id: String(segmentTime),
          time: time,
          isInit: false,
          duration: duration,
          timescale: timescale,
          number: number,
          mediaURLs: [replaceSegmentSmoothTokens(media, time)]
        };
        segments.push(segment); // update segment number and segment time for the next segment

        segmentNumberInCurrentRange++;
        segmentTime = start + segmentNumberInCurrentRange * duration;
      }

      if (segmentTime >= to) {
        // we reached ``to``, we're done
        return segments;
      }

      if (currentNumber != null) {
        currentNumber += repeat + 1;
      }
    }

    return segments;
  }
  /**
   * Returns true if, based on the arguments, the index should be refreshed.
   * (If we should re-fetch the manifest)
   * @param {Number} up
   * @param {Number} to
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh(up, to) {
    this._refreshTimeline();

    if (!this._index.isLive) {
      return false;
    }

    var _this$_index2 = this._index,
        timeline = _this$_index2.timeline,
        timescale = _this$_index2.timescale;
    var lastSegmentInCurrentTimeline = timeline[timeline.length - 1];

    if (lastSegmentInCurrentTimeline === undefined) {
      return false;
    }

    var repeat = lastSegmentInCurrentTimeline.repeatCount;
    var endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + (repeat + 1) * lastSegmentInCurrentTimeline.duration;

    if (to * timescale < endOfLastSegmentInCurrentTimeline) {
      return false;
    }

    if (up * timescale >= endOfLastSegmentInCurrentTimeline) {
      return true;
    } // ----


    var startOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + repeat * lastSegmentInCurrentTimeline.duration;
    return up * timescale > startOfLastSegmentInCurrentTimeline;
  }
  /**
   * Returns first position available in the index.
   *
   * @param {Object} index
   * @returns {Number|null}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    this._refreshTimeline();

    var index = this._index;

    if (index.timeline.length === 0) {
      return null;
    }

    return index.timeline[0].start / index.timescale;
  }
  /**
   * Returns last position available in the index.
   * @param {Object} index
   * @returns {Number}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    this._refreshTimeline();

    var index = this._index;

    if (this._scaledLiveGap == null) {
      var lastTimelineElement = index.timeline[index.timeline.length - 1];
      return Object(index_helpers["c" /* getIndexSegmentEnd */])(lastTimelineElement, null) / index.timescale;
    }

    for (var i = index.timeline.length - 1; i >= 0; i--) {
      var timelineElt = index.timeline[i];
      var timescaledNow = performance.now() / 1000 * index.timescale;
      var start = timelineElt.start,
          duration = timelineElt.duration,
          repeatCount = timelineElt.repeatCount;

      for (var j = repeatCount; j >= 0; j--) {
        var end = start + duration * (j + 1);
        var positionToReach = this._isAggressiveMode ? end - duration : end;

        if (positionToReach <= timescaledNow - this._scaledLiveGap) {
          return end / index.timescale;
        }
      }
    }

    return undefined;
  }
  /**
   * Checks if the time given is in a discontinuity. That is:
   *   - We're on the upper bound of the current range (end of the range - time
   *     is inferior to the timescale)
   *   - The next range starts after the end of the current range.
   *
   * @param {Number} _time
   * @returns {Number} - If a discontinuity is present, this is the Starting
   * time for the next (discontinuited) range. If not this is equal to -1.
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity(_time) {
    this._refreshTimeline();

    var index = this._index;
    var timeline = index.timeline,
        _index$timescale = index.timescale,
        timescale = _index$timescale === void 0 ? 1 : _index$timescale;
    var time = _time * timescale;

    if (time <= 0) {
      return -1;
    }

    var segmentIndex = getSegmentIndex(index, time);

    if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
      return -1;
    }

    var range = timeline[segmentIndex];

    if (range.duration === -1) {
      return -1;
    }

    var rangeUp = range.start;
    var rangeTo = Object(index_helpers["c" /* getIndexSegmentEnd */])(range, null);
    var nextRange = timeline[segmentIndex + 1]; // when we are actually inside the found range and this range has
    // an explicit discontinuity with the next one

    if (rangeTo !== nextRange.start && time >= rangeUp && time <= rangeTo && rangeTo - time < timescale) {
      return nextRange.start / timescale;
    }

    return -1;
  };

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    if (segment.isInit) {
      return true;
    }

    this._refreshTimeline();

    var _this$_index3 = this._index,
        timeline = _this$_index3.timeline,
        timescale = _this$_index3.timescale;
    return Object(is_segment_still_available["a" /* default */])(segment, timeline, timescale, 0);
  }
  /**
   * @param {Error} error
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError(error) {
    if (!this._isLive) {
      return false;
    }

    return error instanceof network_error["a" /* default */] && (error.isHttpError(404) || error.isHttpError(412));
  }
  /**
   * Replace this RepresentationIndex by a newly downloaded one.
   * Check if the old index had more information about new segments and re-add
   * them if that's the case.
   * @param {Object} newIndex
   */
  ;

  _proto._replace = function _replace(newIndex) {
    var oldTimeline = this._index.timeline;
    var newTimeline = newIndex._index.timeline;
    var oldTimescale = this._index.timescale;
    var newTimescale = newIndex._index.timescale;
    this._index = newIndex._index;
    this._initialScaledLastPosition = newIndex._initialScaledLastPosition;
    this._indexValidityTime = newIndex._indexValidityTime;
    this._scaledLiveGap = newIndex._scaledLiveGap;

    if (oldTimeline.length === 0 || newTimeline.length === 0 || oldTimescale !== newTimescale) {
      return; // don't take risk, if something is off, take the new one
    }

    var lastOldTimelineElement = oldTimeline[oldTimeline.length - 1];
    var lastNewTimelineElement = newTimeline[newTimeline.length - 1];
    var newEnd = Object(index_helpers["c" /* getIndexSegmentEnd */])(lastNewTimelineElement, null);

    if (Object(index_helpers["c" /* getIndexSegmentEnd */])(lastOldTimelineElement, null) <= newEnd) {
      return;
    }

    for (var i = 0; i < oldTimeline.length; i++) {
      var oldTimelineRange = oldTimeline[i];
      var oldEnd = Object(index_helpers["c" /* getIndexSegmentEnd */])(oldTimelineRange, null);

      if (oldEnd === newEnd) {
        // just add the supplementary segments
        this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i + 1));
        return;
      }

      if (oldEnd > newEnd) {
        // adjust repeatCount + add supplementary segments
        if (oldTimelineRange.duration !== lastNewTimelineElement.duration) {
          return;
        }

        var rangeDuration = newEnd - oldTimelineRange.start;

        if (rangeDuration === 0) {
          log["a" /* default */].warn("Smooth Parser: a discontinuity detected in the previous manifest" + " has been resolved.");
          this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i));
          return;
        }

        if (rangeDuration < 0 || rangeDuration % oldTimelineRange.duration !== 0) {
          return;
        }

        var repeatWithOld = rangeDuration / oldTimelineRange.duration - 1;
        var relativeRepeat = oldTimelineRange.repeatCount - repeatWithOld;

        if (relativeRepeat < 0) {
          return;
        }

        lastNewTimelineElement.repeatCount += relativeRepeat;
        var supplementarySegments = oldTimeline.slice(i + 1);
        this._index.timeline = this._index.timeline.concat(supplementarySegments);
        return;
      }
    }
  };

  _proto._update = function _update(newIndex) {
    Object(update_segment_timeline["a" /* default */])(this._index.timeline, newIndex._index.timeline);
    this._initialScaledLastPosition = newIndex._initialScaledLastPosition;
    this._indexValidityTime = newIndex._indexValidityTime;
    this._scaledLiveGap = newIndex._scaledLiveGap;
  }
  /**
   * @returns {Boolean | undefined}
   */
  ;

  _proto.isFinished = function isFinished() {
    return !this._isLive;
  };

  _proto._addSegments = function _addSegments(nextSegments, currentSegment) {
    this._refreshTimeline();

    for (var i = 0; i < nextSegments.length; i++) {
      _addSegmentInfos(this._index, nextSegments[i], currentSegment);
    }
  }
  /**
   * Clean-up timeline to remove segment information which should not be
   * available due to the timeshift window
   */
  ;

  _proto._refreshTimeline = function _refreshTimeline() {
    // clean segments before time shift buffer depth
    if (this._initialScaledLastPosition == null) {
      return;
    }

    var index = this._index;
    var timeShiftBufferDepth = index.timeShiftBufferDepth;
    var timeSinceLastRealUpdate = (performance.now() - this._indexValidityTime) / 1000;
    var lastPositionEstimate = timeSinceLastRealUpdate + this._initialScaledLastPosition / index.timescale;

    if (timeShiftBufferDepth != null) {
      var minimumPosition = (lastPositionEstimate - timeShiftBufferDepth) * index.timescale;
      Object(clear_timeline_from_position["a" /* default */])(index.timeline, minimumPosition);
    }
  };

  return SmoothRepresentationIndex;
}();


// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/parseBoolean.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {*} parseBoolean
 * @returns {Boolean}
 */
function parseBoolean(val) {
  if (typeof val === "boolean") {
    return val;
  } else if (typeof val === "string") {
    return val.toUpperCase() === "TRUE";
  } else {
    return false;
  }
}
// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/reduceChildren.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Reduce implementation for the children of the given element.
 * @param {Element} root
 * @param {Function} fn
 * @param {*} init
 * @returns {*}
 */
function reduceChildren(root, fn, init) {
  var node = root.firstElementChild;
  var accumulator = init;

  while (node !== null) {
    accumulator = fn(accumulator, node.nodeName, node);
    node = node.nextElementSibling;
  }

  return accumulator;
}
// CONCATENATED MODULE: ./src/parsers/manifest/smooth/create_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















/**
 * Default value for the aggressive `mode`.
 * In this mode, segments will be returned even if we're not sure those had time
 * to be generated.
 */

var DEFAULT_AGGRESSIVE_MODE = false;
var KNOWN_ADAPTATION_TYPES = ["audio", "video", "text", "image"];
var DEFAULT_MIME_TYPES = {
  audio: "audio/mp4",
  video: "video/mp4",
  text: "application/ttml+xml"
};
var MIME_TYPES = {
  AACL: "audio/mp4",
  AVC1: "video/mp4",
  H264: "video/mp4",
  TTML: "application/ttml+xml+mp4"
};
/**
 * @param {Object|undefined} parserOptions
 * @returns {Function}
 */

function createSmoothStreamingParser(parserOptions) {
  if (parserOptions === void 0) {
    parserOptions = {};
  }

  var referenceDateTime = parserOptions.referenceDateTime === undefined ? Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1000 : parserOptions.referenceDateTime;
  var minRepresentationBitrate = parserOptions.minRepresentationBitrate === undefined ? 0 : parserOptions.minRepresentationBitrate;
  var _parserOptions = parserOptions,
      serverSyncInfos = _parserOptions.serverSyncInfos;
  var serverTimeOffset = serverSyncInfos !== undefined ? serverSyncInfos.serverTimestamp - serverSyncInfos.clientTime : undefined;
  /**
   * @param {Element} q
   * @param {string} streamType
   * @return {Object}
   */

  function parseQualityLevel(q, streamType) {
    var customAttributes = reduceChildren(q, function (acc, qName, qNode) {
      if (qName === "CustomAttributes") {
        acc.push.apply(acc, reduceChildren(qNode, function (cAttrs, cName, cNode) {
          if (cName === "Attribute") {
            var name = cNode.getAttribute("Name");
            var value = cNode.getAttribute("Value");

            if (name !== null && value !== null) {
              cAttrs.push(name + "=" + value);
            }
          }

          return cAttrs;
        }, []));
      }

      return acc;
    }, []);
    /**
     * @param {string} name
     * @returns {string|undefined}
     */

    function getAttribute(name) {
      var attr = q.getAttribute(name);
      return attr == null ? undefined : attr;
    }

    switch (streamType) {
      case "audio":
        {
          var audiotag = getAttribute("AudioTag");
          var bitsPerSample = getAttribute("BitsPerSample");
          var channels = getAttribute("Channels");
          var codecPrivateData = getAttribute("CodecPrivateData");
          var fourCC = getAttribute("FourCC");
          var packetSize = getAttribute("PacketSize");
          var samplingRate = getAttribute("SamplingRate");
          var bitrateAttr = getAttribute("Bitrate");
          var bitrate = bitrateAttr === undefined ? 0 : isNaN(parseInt(bitrateAttr, 10)) ? 0 : parseInt(bitrateAttr, 10);

          if (fourCC !== undefined && MIME_TYPES[fourCC] === undefined || codecPrivateData === undefined) {
            log["a" /* default */].warn("Smooth parser: Unsupported audio codec. Ignoring quality level.");
            return null;
          }

          var codecs = getAudioCodecs(codecPrivateData, fourCC);
          return {
            audiotag: audiotag !== undefined ? parseInt(audiotag, 10) : audiotag,
            bitrate: bitrate,
            bitsPerSample: bitsPerSample !== undefined ? parseInt(bitsPerSample, 10) : bitsPerSample,
            channels: channels !== undefined ? parseInt(channels, 10) : channels,
            codecPrivateData: codecPrivateData,
            codecs: codecs,
            customAttributes: customAttributes,
            mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,
            packetSize: packetSize !== undefined ? parseInt(packetSize, 10) : packetSize,
            samplingRate: samplingRate !== undefined ? parseInt(samplingRate, 10) : samplingRate
          };
        }

      case "video":
        {
          var _codecPrivateData = getAttribute("CodecPrivateData");

          var _fourCC = getAttribute("FourCC");

          var width = getAttribute("MaxWidth");
          var height = getAttribute("MaxHeight");

          var _bitrateAttr = getAttribute("Bitrate");

          var _bitrate = _bitrateAttr === undefined ? 0 : isNaN(parseInt(_bitrateAttr, 10)) ? 0 : parseInt(_bitrateAttr, 10);

          if (_fourCC !== undefined && MIME_TYPES[_fourCC] === undefined || _codecPrivateData === undefined) {
            log["a" /* default */].warn("Smooth parser: Unsupported video codec. Ignoring quality level.");
            return null;
          }

          var _codecs = getVideoCodecs(_codecPrivateData);

          return {
            bitrate: _bitrate,
            customAttributes: customAttributes,
            mimeType: _fourCC !== undefined ? MIME_TYPES[_fourCC] : _fourCC,
            codecPrivateData: _codecPrivateData,
            codecs: _codecs,
            width: width !== undefined ? parseInt(width, 10) : undefined,
            height: height !== undefined ? parseInt(height, 10) : undefined
          };
        }

      case "text":
        {
          var _codecPrivateData2 = getAttribute("CodecPrivateData");

          var _fourCC2 = getAttribute("FourCC");

          var _bitrateAttr2 = getAttribute("Bitrate");

          var _bitrate2 = _bitrateAttr2 === undefined ? 0 : isNaN(parseInt(_bitrateAttr2, 10)) ? 0 : parseInt(_bitrateAttr2, 10);

          return {
            bitrate: _bitrate2,
            customAttributes: customAttributes,
            mimeType: _fourCC2 !== undefined ? MIME_TYPES[_fourCC2] : _fourCC2,
            codecPrivateData: Object(take_first_set["a" /* default */])(_codecPrivateData2, "")
          };
        }

      default:
        log["a" /* default */].error("Smooth Parser: Unrecognized StreamIndex type: " + streamType);
        return null;
    }
  }
  /**
   * Parse the adaptations (<StreamIndex>) tree containing
   * representations (<QualityLevels>) and timestamp indexes (<c>).
   * Indexes can be quite huge, and this function needs to
   * to be optimized.
   * @param {Object} args
   * @returns {Object}
   */


  function parseAdaptation(args) {
    var root = args.root,
        timescale = args.timescale,
        rootURL = args.rootURL,
        protections = args.protections,
        timeShiftBufferDepth = args.timeShiftBufferDepth,
        manifestReceivedTime = args.manifestReceivedTime,
        isLive = args.isLive;
    var timescaleAttr = root.getAttribute("Timescale");

    var _timescale = timescaleAttr === null ? timescale : isNaN(+timescaleAttr) ? timescale : +timescaleAttr;

    var typeAttribute = root.getAttribute("Type");

    if (typeAttribute === null) {
      throw new Error("StreamIndex without type.");
    }

    if (!Object(array_includes["a" /* default */])(KNOWN_ADAPTATION_TYPES, typeAttribute)) {
      log["a" /* default */].warn("Smooth Parser: Unrecognized adaptation type:", typeAttribute);
    }

    var adaptationType = typeAttribute;
    var subType = root.getAttribute("Subtype");
    var language = root.getAttribute("Language");
    var baseURLAttr = root.getAttribute("Url");
    var baseURL = baseURLAttr === null ? "" : baseURLAttr;

    if (false) {}

    var _reduceChildren = reduceChildren(root, function (res, _name, node) {
      switch (_name) {
        case "QualityLevel":
          var qualityLevel = parseQualityLevel(node, adaptationType);

          if (qualityLevel === null) {
            return res;
          } // filter out video qualityLevels with small bitrates


          if (adaptationType !== "video" || qualityLevel.bitrate > minRepresentationBitrate) {
            res.qualityLevels.push(qualityLevel);
          }

          break;

        case "c":
          res.cNodes.push(node);
          break;
      }

      return res;
    }, {
      qualityLevels: [],
      cNodes: []
    }),
        qualityLevels = _reduceChildren.qualityLevels,
        cNodes = _reduceChildren.cNodes;

    var index = {
      timeline: parseCNodes(cNodes),
      timescale: _timescale
    }; // we assume that all qualityLevels have the same
    // codec and mimeType

    Object(assert["b" /* default */])(qualityLevels.length !== 0, "Adaptation should have at least one playable representation.");
    var adaptationID = adaptationType + (Object(is_non_empty_string["a" /* default */])(language) ? "_" + language : "");
    var representations = qualityLevels.map(function (qualityLevel) {
      var path = Object(resolve_url["a" /* default */])(rootURL, baseURL);
      var repIndex = {
        timeline: index.timeline,
        timescale: index.timescale,
        media: replaceRepresentationSmoothTokens(path, qualityLevel.bitrate, qualityLevel.customAttributes),
        isLive: isLive,
        timeShiftBufferDepth: timeShiftBufferDepth,
        manifestReceivedTime: manifestReceivedTime
      };
      var mimeType = Object(is_non_empty_string["a" /* default */])(qualityLevel.mimeType) ? qualityLevel.mimeType : DEFAULT_MIME_TYPES[adaptationType];
      var codecs = qualityLevel.codecs;
      var id = adaptationID + "_" + (adaptationType != null ? adaptationType + "-" : "") + (mimeType != null ? mimeType + "-" : "") + (codecs != null ? codecs + "-" : "") + String(qualityLevel.bitrate);
      var keyIDs = [];
      var firstProtection;

      if (protections.length > 0) {
        firstProtection = protections[0];
        protections.forEach(function (protection) {
          var keyId = protection.keyId;
          protection.keySystems.forEach(function (keySystem) {
            keyIDs.push({
              keyId: keyId,
              systemId: keySystem.systemId
            });
          });
        });
      }

      var segmentPrivateInfos = {
        bitsPerSample: qualityLevel.bitsPerSample,
        channels: qualityLevel.channels,
        codecPrivateData: qualityLevel.codecPrivateData,
        packetSize: qualityLevel.packetSize,
        samplingRate: qualityLevel.samplingRate,
        // TODO set multiple protections here
        // instead of the first one
        protection: firstProtection != null ? {
          keyId: firstProtection.keyId,
          keySystems: firstProtection.keySystems
        } : undefined
      };
      var aggressiveMode = parserOptions.aggressiveMode == null ? DEFAULT_AGGRESSIVE_MODE : parserOptions.aggressiveMode;
      var reprIndex = new representation_index_SmoothRepresentationIndex(repIndex, {
        aggressiveMode: aggressiveMode,
        isLive: isLive,
        segmentPrivateInfos: segmentPrivateInfos
      });
      var representation = Object(object_assign["a" /* default */])({}, qualityLevel, {
        index: reprIndex,
        mimeType: mimeType,
        codecs: codecs,
        id: id
      });

      if (keyIDs.length > 0) {
        representation.contentProtections = {
          keyIds: keyIDs,
          initData: {}
        };
      }

      return representation;
    }); // TODO(pierre): real ad-insert support

    if (subType === "ADVT") {
      return null;
    }

    var parsedAdaptation = {
      id: adaptationID,
      type: adaptationType,
      representations: representations,
      language: language == null ? undefined : language
    };

    if (adaptationType === "text" && subType === "DESC") {
      parsedAdaptation.closedCaption = true;
    }

    return parsedAdaptation;
  }

  function parseFromDocument(doc, url, manifestReceivedTime) {
    var rootURL = Object(resolve_url["b" /* normalizeBaseURL */])(url == null ? "" : url);
    var root = doc.documentElement;

    if (root == null || root.nodeName !== "SmoothStreamingMedia") {
      throw new Error("document root should be SmoothStreamingMedia");
    }

    var majorVersionAttr = root.getAttribute("MajorVersion");
    var minorVersionAttr = root.getAttribute("MinorVersion");

    if (majorVersionAttr === null || minorVersionAttr === null || !/^[2]-[0-2]$/.test(majorVersionAttr + "-" + minorVersionAttr)) {
      throw new Error("Version should be 2.0, 2.1 or 2.2");
    }

    var timescaleAttr = root.getAttribute("Timescale");
    var timescale = !Object(is_non_empty_string["a" /* default */])(timescaleAttr) ? 10000000 : isNaN(+timescaleAttr) ? 10000000 : +timescaleAttr;

    var _reduceChildren2 = reduceChildren(root, function (res, name, node) {
      switch (name) {
        case "Protection":
          {
            res.protections.push(parseProtectionNode(node, parserOptions.keySystems));
            break;
          }

        case "StreamIndex":
          res.adaptationNodes.push(node);
          break;
      }

      return res;
    }, {
      adaptationNodes: [],
      protections: []
    }),
        protections = _reduceChildren2.protections,
        adaptationNodes = _reduceChildren2.adaptationNodes;

    var initialAdaptations = {};
    var isLive = parseBoolean(root.getAttribute("IsLive"));
    var timeShiftBufferDepth;

    if (isLive) {
      var dvrWindowLength = root.getAttribute("DVRWindowLength");

      if (dvrWindowLength != null && !isNaN(+dvrWindowLength) && +dvrWindowLength !== 0) {
        timeShiftBufferDepth = +dvrWindowLength / timescale;
      }
    }

    var adaptations = adaptationNodes.reduce(function (acc, node) {
      var adaptation = parseAdaptation({
        root: node,
        rootURL: rootURL,
        timescale: timescale,
        protections: protections,
        isLive: isLive,
        timeShiftBufferDepth: timeShiftBufferDepth,
        manifestReceivedTime: manifestReceivedTime
      });

      if (adaptation === null) {
        return acc;
      }

      var type = adaptation.type;
      var adaps = acc[type];

      if (adaps === undefined) {
        acc[type] = [adaptation];
      } else {
        adaps.push(adaptation);
      }

      return acc;
    }, initialAdaptations);
    var suggestedPresentationDelay;
    var availabilityStartTime;
    var minimumTime;
    var maximumTime;
    var firstVideoAdaptation = adaptations.video !== undefined ? adaptations.video[0] : undefined;
    var firstAudioAdaptation = adaptations.audio !== undefined ? adaptations.audio[0] : undefined;
    var firstTimeReference;
    var lastTimeReference;

    if (firstVideoAdaptation !== undefined || firstAudioAdaptation !== undefined) {
      var firstTimeReferences = [];
      var lastTimeReferences = [];

      if (firstVideoAdaptation !== undefined) {
        var firstVideoRepresentation = firstVideoAdaptation.representations[0];

        if (firstVideoRepresentation !== undefined) {
          var firstVideoTimeReference = firstVideoRepresentation.index.getFirstPosition();
          var lastVideoTimeReference = firstVideoRepresentation.index.getLastPosition();

          if (firstVideoTimeReference != null) {
            firstTimeReferences.push(firstVideoTimeReference);
          }

          if (lastVideoTimeReference != null) {
            lastTimeReferences.push(lastVideoTimeReference);
          }
        }
      }

      if (firstAudioAdaptation !== undefined) {
        var firstAudioRepresentation = firstAudioAdaptation.representations[0];

        if (firstAudioRepresentation !== undefined) {
          var firstAudioTimeReference = firstAudioRepresentation.index.getFirstPosition();
          var lastAudioTimeReference = firstAudioRepresentation.index.getLastPosition();

          if (firstAudioTimeReference != null) {
            firstTimeReferences.push(firstAudioTimeReference);
          }

          if (lastAudioTimeReference != null) {
            lastTimeReferences.push(lastAudioTimeReference);
          }
        }
      }

      if (firstTimeReferences.length > 0) {
        firstTimeReference = Math.max.apply(Math, firstTimeReferences);
      }

      if (lastTimeReferences.length > 0) {
        lastTimeReference = Math.min.apply(Math, lastTimeReferences);
      }
    }

    var manifestDuration = root.getAttribute("Duration");
    var duration = manifestDuration != null && +manifestDuration !== 0 ? +manifestDuration / timescale : undefined;

    if (isLive) {
      suggestedPresentationDelay = parserOptions.suggestedPresentationDelay;
      availabilityStartTime = referenceDateTime;
      var time = performance.now();
      maximumTime = {
        isContinuous: true,
        value: lastTimeReference != null ? lastTimeReference : Date.now() / 1000 - availabilityStartTime,
        time: time
      };

      if (timeShiftBufferDepth == null) {
        // infinite buffer
        minimumTime = {
          isContinuous: false,
          value: firstTimeReference != null ? firstTimeReference : availabilityStartTime,
          time: time
        };
      } else {
        minimumTime = {
          isContinuous: true,
          value: Math.min(maximumTime.value - timeShiftBufferDepth + 5, maximumTime.value),
          time: time
        };
      }
    } else {
      minimumTime = {
        isContinuous: false,
        value: firstTimeReference != null ? firstTimeReference : 0,
        time: performance.now()
      };

      if (lastTimeReference !== undefined) {
        maximumTime = {
          isContinuous: false,
          value: lastTimeReference,
          time: performance.now()
        };
      } else if (duration !== undefined) {
        maximumTime = {
          isContinuous: false,
          value: minimumTime.value + duration,
          time: performance.now()
        };
      }
    }

    var periodStart = isLive ? 0 : minimumTime.value;
    var periodEnd = isLive ? undefined : maximumTime === null || maximumTime === void 0 ? void 0 : maximumTime.value;
    var manifest = {
      availabilityStartTime: availabilityStartTime === undefined ? 0 : availabilityStartTime,
      clockOffset: serverTimeOffset,
      isLive: isLive,
      isDynamic: isLive,
      maximumTime: maximumTime,
      minimumTime: minimumTime,
      periods: [{
        adaptations: adaptations,
        duration: periodEnd !== undefined ? periodEnd - periodStart : duration,
        end: periodEnd,
        id: "gen-smooth-period-0",
        start: periodStart
      }],
      suggestedPresentationDelay: suggestedPresentationDelay,
      transportType: "smooth",
      uris: url == null ? [] : [url]
    };
    Object(check_manifest_ids["a" /* default */])(manifest);
    return manifest;
  }

  return parseFromDocument;
}

/* harmony default export */ var create_parser = (createSmoothStreamingParser);
// CONCATENATED MODULE: ./src/parsers/manifest/smooth/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var smooth = (create_parser);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(9);

// EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
var request = __webpack_require__(24);

// EXTERNAL MODULE: ./src/utils/string_from_utf8.ts
var string_from_utf8 = __webpack_require__(117);

// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(20);

// EXTERNAL MODULE: ./src/transports/utils/check_isobmff_integrity.ts
var check_isobmff_integrity = __webpack_require__(76);

// EXTERNAL MODULE: ./src/transports/utils/document_manifest_loader.ts
var document_manifest_loader = __webpack_require__(115);

// EXTERNAL MODULE: ./src/parsers/containers/isobmff/utils.ts
var utils = __webpack_require__(221);

// EXTERNAL MODULE: ./src/parsers/containers/isobmff/get_box.ts
var get_box = __webpack_require__(78);

// CONCATENATED MODULE: ./src/transports/smooth/isobmff/parse_tfrf.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Uint8Array} traf
 * @returns {Array.<Object>}
 */

function parseTfrf(traf) {
  var tfrf = Object(get_box["d" /* getUuidContent */])(traf, 0xD4807EF2, 0xCA394695, 0x8E5426CB, 0x9E46A79F);

  if (tfrf === undefined) {
    return [];
  }

  var frags = [];
  var version = tfrf[0];
  var fragCount = tfrf[4];

  for (var i = 0; i < fragCount; i++) {
    var duration = void 0;
    var time = void 0;

    if (version === 1) {
      time = Object(byte_parsing["d" /* be8toi */])(tfrf, i * 16 + 5);
      duration = Object(byte_parsing["d" /* be8toi */])(tfrf, i * 16 + 5 + 8);
    } else {
      time = Object(byte_parsing["c" /* be4toi */])(tfrf, i * 8 + 5);
      duration = Object(byte_parsing["c" /* be4toi */])(tfrf, i * 8 + 5 + 4);
    }

    frags.push({
      time: time,
      duration: duration
    });
  }

  return frags;
}
// CONCATENATED MODULE: ./src/transports/smooth/isobmff/parse_tfxd.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Uint8Array} traf
 * @returns {Object|undefined}
 */

function parseTfxd(traf) {
  var tfxd = Object(get_box["d" /* getUuidContent */])(traf, 0x6D1D9B05, 0x42D544E6, 0x80E2141D, 0xAFF757B2);

  if (tfxd === undefined) {
    return undefined;
  }

  return {
    duration: Object(byte_parsing["d" /* be8toi */])(tfxd, 12),
    time: Object(byte_parsing["d" /* be8toi */])(tfxd, 4)
  };
}
// CONCATENATED MODULE: ./src/transports/smooth/extract_timings_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Try to obtain time information from the given data.
 * @param {Uint8Array} data
 * @param {boolean} isChunked
 * @param {Object} segment
 * @param {boolean} isLive
 * @returns {Object}
 */

function extractTimingsInfos(data, isChunked, segment, isLive) {
  var nextSegments = [];
  var chunkInfos;
  var tfxdSegment;
  var tfrfSegments;

  if (isLive) {
    var traf = Object(read["c" /* getTRAF */])(data);

    if (traf !== null) {
      tfrfSegments = parseTfrf(traf);
      tfxdSegment = parseTfxd(traf);
    } else {
      log["a" /* default */].warn("smooth: could not find traf atom");
    }
  }

  if (tfrfSegments !== undefined) {
    for (var i = 0; i < tfrfSegments.length; i++) {
      nextSegments.push({
        time: tfrfSegments[i].time,
        duration: tfrfSegments[i].duration,
        timescale: segment.timescale
      });
    }
  }

  if (tfxdSegment !== undefined) {
    chunkInfos = {
      time: tfxdSegment.time,
      duration: tfxdSegment.duration,
      timescale: segment.timescale
    };
    return {
      nextSegments: nextSegments,
      chunkInfos: chunkInfos
    };
  }

  if (isChunked) {
    return {
      nextSegments: nextSegments,
      chunkInfos: null
    };
  } // we could always make a mistake when reading a container.
  // If the estimate is too far from what the segment seems to imply, take
  // the segment infos instead.


  var maxDecodeTimeDelta = Math.min(segment.timescale * 0.9, segment.duration / 4);
  var trunDuration = Object(utils["a" /* getDurationFromTrun */])(data);

  if (trunDuration >= 0 && (Object(is_null_or_undefined["a" /* default */])(segment.duration) || Math.abs(trunDuration - segment.duration) <= maxDecodeTimeDelta)) {
    chunkInfos = {
      time: segment.time,
      duration: trunDuration,
      timescale: segment.timescale
    };
  } else {
    chunkInfos = {
      time: segment.time,
      duration: segment.duration,
      timescale: segment.timescale
    };
  }

  return {
    nextSegments: nextSegments,
    chunkInfos: chunkInfos
  };
}
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/create_box.ts
var create_box = __webpack_require__(172);

// CONCATENATED MODULE: ./src/transports/smooth/isobmff/add_data_offset_flag_in_trun.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Update `trun` box given to add a data offset flag and the corresponding space
 * to set a data offset.
 * Do not do anything if the flag is already set.
 * @param {Uint8Array} trun
 * @returns {Uint8Array}
 */

function addDataOffsetFlagInTrun(trun) {
  var lastFlags = trun[11];
  var hasDataOffset = lastFlags & 0x01;

  if (hasDataOffset !== 0) {
    return trun;
  } // If no dataoffset is present, we add one


  var newTrun = new Uint8Array(trun.length + 4);
  newTrun.set(Object(byte_parsing["m" /* itobe4 */])(trun.length + 4), 0); // original length + data_offset size

  newTrun.set(trun.subarray(4, 16), 4); // name + (version + flags) + samplecount

  newTrun[11] = newTrun[11] | 0x01; // add data_offset flag

  newTrun.set([0, 0, 0, 0], 16); // add data offset

  newTrun.set(trun.subarray(16, trun.length), 20);
  return newTrun;
}
// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_boxes.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encDepth
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @returns {Uint8Array}
 */

function createAVC1Box(width, height, hRes, vRes, encName, colorDepth, avcc) {
  return Object(create_box["a" /* createBox */])("avc1", Object(byte_parsing["h" /* concat */])(6, // 6 bytes reserved
  Object(byte_parsing["l" /* itobe2 */])(1), 16, // drefIdx + QuickTime reserved, zeroes
  Object(byte_parsing["l" /* itobe2 */])(width), // size 2 w
  Object(byte_parsing["l" /* itobe2 */])(height), // size 2 h
  Object(byte_parsing["l" /* itobe2 */])(hRes), 2, // reso 4 h
  Object(byte_parsing["l" /* itobe2 */])(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes
  [0, 1, encName.length], // frame count (default 1)
  Object(byte_parsing["q" /* strToBytes */])(encName), // 1byte len + encoder name str
  31 - encName.length, // + padding
  Object(byte_parsing["l" /* itobe2 */])(colorDepth), // color depth
  [0xFF, 0xFF], // reserved ones
  avcc // avcc atom,
  ));
}
/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encDepth
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @param {Uint8Array} sinf - Uint8Array representing the sinf atom
 * @returns {Uint8Array}
 */


function createENCVBox(width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
  return Object(create_box["a" /* createBox */])("encv", Object(byte_parsing["h" /* concat */])(6, // 6 bytes reserved
  Object(byte_parsing["l" /* itobe2 */])(1), 16, // drefIdx + QuickTime reserved, zeroes
  Object(byte_parsing["l" /* itobe2 */])(width), // size 2 w
  Object(byte_parsing["l" /* itobe2 */])(height), // size 2 h
  Object(byte_parsing["l" /* itobe2 */])(hRes), 2, // reso 4 h
  Object(byte_parsing["l" /* itobe2 */])(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes
  [0, 1, encName.length], // frame count (default 1)
  Object(byte_parsing["q" /* strToBytes */])(encName), // 1byte len + encoder name str
  31 - encName.length, // + padding
  Object(byte_parsing["l" /* itobe2 */])(colorDepth), // color depth
  [0xFF, 0xFF], // reserved ones
  avcc, // avcc atom,
  sinf));
}
/**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */


function createMP4ABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds) {
  return Object(create_box["a" /* createBox */])("mp4a", Object(byte_parsing["h" /* concat */])(6, Object(byte_parsing["l" /* itobe2 */])(drefIdx), 8, Object(byte_parsing["l" /* itobe2 */])(channelsCount), Object(byte_parsing["l" /* itobe2 */])(sampleSize), 2, Object(byte_parsing["l" /* itobe2 */])(packetSize), Object(byte_parsing["l" /* itobe2 */])(sampleRate), 2, esds));
}
/**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */


function createENCABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
  return Object(create_box["a" /* createBox */])("enca", Object(byte_parsing["h" /* concat */])(6, Object(byte_parsing["l" /* itobe2 */])(drefIdx), 8, Object(byte_parsing["l" /* itobe2 */])(channelsCount), Object(byte_parsing["l" /* itobe2 */])(sampleSize), 2, Object(byte_parsing["l" /* itobe2 */])(packetSize), Object(byte_parsing["l" /* itobe2 */])(sampleRate), 2, esds, sinf));
}
/**
 * @param {url} Uint8Array
 * @returns {Uint8Array}
 */


function createDREFBox(url) {
  // only one description here... FIXME
  return Object(create_box["a" /* createBox */])("dref", Object(byte_parsing["h" /* concat */])(7, [1], url));
}
/**
 * @param {string} majorBrand
 * @param {Array.<string>} brands
 * @returns {Uint8Array}
 */


function createFTYPBox(majorBrand, brands) {
  return Object(create_box["a" /* createBox */])("ftyp", byte_parsing["h" /* concat */].apply(null, [Object(byte_parsing["q" /* strToBytes */])(majorBrand), [0, 0, 0, 1]].concat(brands.map(byte_parsing["q" /* strToBytes */]))));
}
/**
 * @param {string} schemeType - four letters (eg "cenc" for Common Encryption)
 * @param {Number} schemeVersion - eg 65536
 * @returns {Uint8Array}
 */


function createSCHMBox(schemeType, schemeVersion) {
  return Object(create_box["a" /* createBox */])("schm", Object(byte_parsing["h" /* concat */])(4, Object(byte_parsing["q" /* strToBytes */])(schemeType), Object(byte_parsing["m" /* itobe4 */])(schemeVersion)));
}
/**
 * Create tfdt box from a decoding time.
 * @param {number} decodeTime
 * @returns {Uint8Array}
 */


function createTfdtBox(decodeTime) {
  return Object(create_box["a" /* createBox */])("tfdt", Object(byte_parsing["h" /* concat */])([1, 0, 0, 0], Object(byte_parsing["n" /* itobe8 */])(decodeTime)));
}
/**
 * @returns {Uint8Array}
 */


function createVMHDBox() {
  var arr = new Uint8Array(12);
  arr[3] = 1; // QuickTime...

  return Object(create_box["a" /* createBox */])("vmhd", arr);
}
/**
 * @param {Number} trackId
 * @returns {Uint8Array}
 */


function createTREXBox(trackId) {
  // default sample desc idx = 1
  return Object(create_box["a" /* createBox */])("trex", Object(byte_parsing["h" /* concat */])(4, Object(byte_parsing["m" /* itobe4 */])(trackId), [0, 0, 0, 1], 12));
}
/**
 * @param {Number} length
 * @returns {Uint8Array}
 */


function createFreeBox(length) {
  return Object(create_box["a" /* createBox */])("free", new Uint8Array(length - 8));
}
/**
 * @param {Number} stream
 * @param {string} codecPrivateData - hex string
 * @returns {Uint8Array}
 */


function createESDSBox(stream, codecPrivateData) {
  return Object(create_box["a" /* createBox */])("esds", Object(byte_parsing["h" /* concat */])(4, [0x03, 0x19], Object(byte_parsing["l" /* itobe2 */])(stream), [0x00, 0x04, 0x11, 0x40, 0x15], 11, [0x05, 0x02], Object(byte_parsing["j" /* hexToBytes */])(codecPrivateData), [0x06, 0x01, 0x02]));
}
/**
 * @param {string} dataFormat - four letters (eg "avc1")
 * @returns {Uint8Array}
 */


function createFRMABox(dataFormat) {
  return Object(create_box["a" /* createBox */])("frma", Object(byte_parsing["q" /* strToBytes */])(dataFormat));
}
/**
 * @param {Uint8Array} sps
 * @param {Uint8Array} pps
 * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes
 * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, "674d400d96560c0efcb80a70505050a0",
 * 1, "68ef3880")
 * @returns {Uint8Array}
 */


function createAVCCBox(sps, pps, nalLen) {
  var nal = nalLen === 2 ? 0x1 : nalLen === 4 ? 0x3 : 0x0; // Deduce AVC Profile from SPS

  var h264Profile = sps[1];
  var h264CompatibleProfile = sps[2];
  var h264Level = sps[3];
  return Object(create_box["a" /* createBox */])("avcC", Object(byte_parsing["h" /* concat */])([1, h264Profile, h264CompatibleProfile, h264Level, 0x3F << 2 | nal, 0xE0 | 1], Object(byte_parsing["l" /* itobe2 */])(sps.length), sps, [1], Object(byte_parsing["l" /* itobe2 */])(pps.length), pps));
}
/**
 * @param {string} type - "video"/"audio"/"hint"
 * @returns {Uint8Array}
 */


function createHDLRBox(type) {
  var name;
  var handlerName;

  switch (type) {
    case "video":
      name = "vide";
      handlerName = "VideoHandler";
      break;

    case "audio":
      name = "soun";
      handlerName = "SoundHandler";
      break;

    default:
      name = "hint";
      handlerName = "";
      break;
  }

  return Object(create_box["a" /* createBox */])("hdlr", Object(byte_parsing["h" /* concat */])(8, Object(byte_parsing["q" /* strToBytes */])(name), 12, Object(byte_parsing["q" /* strToBytes */])(handlerName), 1 // handler name is C-style string (0 terminated)
  ));
}
/**
 * @param {number} timescale
 * @returns {Uint8Array}
 */


function createMDHDBox(timescale) {
  return Object(create_box["a" /* createBox */])("mdhd", Object(byte_parsing["h" /* concat */])(12, Object(byte_parsing["m" /* itobe4 */])(timescale), 8));
}
/**
 * @param {Number} timescale
 * @param {Number} trackId
 * @returns {Uint8Array}
 */


function createMVHDBox(timescale, trackId) {
  return Object(create_box["a" /* createBox */])("mvhd", Object(byte_parsing["h" /* concat */])(12, Object(byte_parsing["m" /* itobe4 */])(timescale), 4, [0, 1], 2, // we assume rate = 1;
  [1, 0], 10, // we assume volume = 100%;
  [0, 1], 14, // default matrix
  [0, 1], 14, // default matrix
  [64, 0, 0, 0], 26, Object(byte_parsing["l" /* itobe2 */])(trackId + 1) // next trackId (=trackId + 1);
  ));
}
/**
 * @param {string} systemId - Hex string representing the CDM, 16 bytes.
 * @param {Uint8Array|undefined} privateData - Data associated to protection
 * specific system.
 * @param {Array.<Uint8Array>} keyIds - List of key ids contained in the PSSH
 * @returns {Uint8Array}
 */


function createPSSHBox(systemId, privateData, keyIds) {
  if (privateData === void 0) {
    privateData = new Uint8Array(0);
  }

  if (keyIds === void 0) {
    keyIds = new Uint8Array(0);
  }

  var _systemId = systemId.replace(/-/g, "");

  if (_systemId.length !== 32) {
    throw new Error("HSS: wrong system id length");
  }

  var version;
  var kidList;
  var kidCount = keyIds.length;

  if (kidCount > 0) {
    version = 1;
    kidList = byte_parsing["h" /* concat */].apply(void 0, [Object(byte_parsing["m" /* itobe4 */])(kidCount)].concat(keyIds));
  } else {
    version = 0;
    kidList = [];
  }

  return Object(create_box["a" /* createBox */])("pssh", Object(byte_parsing["h" /* concat */])([version, 0, 0, 0], Object(byte_parsing["j" /* hexToBytes */])(_systemId), kidList, Object(byte_parsing["m" /* itobe4 */])(privateData.length), privateData));
}
/**
 * @param {Uint8Array} mfhd
 * @param {Uint8Array} tfhd
 * @param {Uint8Array} tfdt
 * @param {Uint8Array} trun
 * @returns {Uint8Array}
 */


function createSAIOBox(mfhd, tfhd, tfdt, trun) {
  return Object(create_box["a" /* createBox */])("saio", Object(byte_parsing["h" /* concat */])(4, [0, 0, 0, 1], // ??
  Object(byte_parsing["m" /* itobe4 */])(mfhd.length + tfhd.length + tfdt.length + trun.length + 8 + 8 + 8 + 8)));
}
/**
 * @param {Uint8Array} sencContent - including 8 bytes flags and entries count
 * @returns {Uint8Array}
 */


function createSAIZBox(sencContent) {
  if (sencContent.length === 0) {
    return Object(create_box["a" /* createBox */])("saiz", new Uint8Array(0));
  }

  var flags = Object(byte_parsing["c" /* be4toi */])(sencContent, 0);
  var entries = Object(byte_parsing["c" /* be4toi */])(sencContent, 4);
  var arr = new Uint8Array(entries + 9);
  arr.set(Object(byte_parsing["m" /* itobe4 */])(entries), 5);
  var i = 9;
  var j = 8;
  var pairsCnt;
  var pairsLen;

  while (j < sencContent.length) {
    j += 8; // assuming IV is 8 bytes TODO handle 16 bytes IV
    // if we have extradata for each entry

    if ((flags & 0x2) === 0x2) {
      pairsLen = 2;
      pairsCnt = Object(byte_parsing["a" /* be2toi */])(sencContent, j);
      j += pairsCnt * 6 + 2;
    } else {
      pairsCnt = 0;
      pairsLen = 0;
    }

    arr[i] = pairsCnt * 6 + 8 + pairsLen;
    i++;
  }

  return Object(create_box["a" /* createBox */])("saiz", arr);
}
/**
 * @returns {Uint8Array}
 */


function createSMHDBox() {
  return Object(create_box["a" /* createBox */])("smhd", new Uint8Array(8));
}
/**
 * @param {Array.<Uint8Array>} representations - arrays of Uint8Array,
 * typically [avc1] or [encv, avc1]
 * @returns {Uint8Array}
 */


function createSTSDBox(reps) {
  // only one description here... FIXME
  var arrBase = [7, [reps.length]];
  return Object(create_box["a" /* createBox */])("stsd", byte_parsing["h" /* concat */].apply(void 0, arrBase.concat(reps)));
}
/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} trackId
 * @returns {Uint8Array}
 */


function createTKHDBox(width, height, trackId) {
  return Object(create_box["a" /* createBox */])("tkhd", Object(byte_parsing["h" /* concat */])(Object(byte_parsing["m" /* itobe4 */])(1 + 2 + 4), 8, // we assume track is enabled,
  // in media and in preview.
  Object(byte_parsing["m" /* itobe4 */])(trackId), 20, // we assume trackId = 1;
  [1, 0, 0, 0], // we assume volume = 100%;
  [0, 1, 0, 0], 12, // default matrix
  [0, 1, 0, 0], 12, // default matrix
  [64, 0, 0, 0], // ??
  Object(byte_parsing["l" /* itobe2 */])(width), 2, // width (TODO handle fixed)
  Object(byte_parsing["l" /* itobe2 */])(height), 2 // height (TODO handle fixed)
  ));
}
/**
 * @param {Number} algId - eg 1
 * @param {Number} ivSize - eg 8
 * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546
 * @returns {Uint8Array}
 */


function createTENCBox(algId, ivSize, keyId) {
  return Object(create_box["a" /* createBox */])("tenc", Object(byte_parsing["h" /* concat */])(6, [algId, ivSize], keyId));
}


// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_traf_box.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function createTrafBox(tfhd, tfdt, trun, mfhd, senc) {
  var trafs = [tfhd, tfdt, trun];

  if (senc !== undefined) {
    trafs.push(Object(create_box["a" /* createBox */])("senc", senc), createSAIZBox(senc), createSAIOBox(mfhd, tfhd, tfdt, trun));
  }

  return Object(create_box["b" /* createBoxWithChildren */])("traf", trafs);
}
// EXTERNAL MODULE: ./src/compat/can_patch_isobmff.ts
var can_patch_isobmff = __webpack_require__(158);

// CONCATENATED MODULE: ./src/transports/smooth/isobmff/replace_moof.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Replace a moof in a segment by a new one.
 * @param {Uint8Array} segment
 * @param {Uint8Array} newMoof
 * @param {Array.<number>} moofOffsets
 * @param {number} trunOffsetInMoof
 * @returns {Uint8Array}
 */

function replaceMoofInSegment(segment, newMoof, moofOffsets, trunOffsetInMoof) {
  var oldMoofLength = moofOffsets[1] - moofOffsets[0];
  var moofDelta = newMoof.length - oldMoofLength;
  var mdatOffsets = Object(get_box["c" /* getBoxOffsets */])(segment, 0x6D646174
  /* "mdat" */
  );

  if (mdatOffsets === null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }

  if (Object(can_patch_isobmff["a" /* default */])() && (moofDelta === 0 || moofDelta <= -8)) {
    // patch trun data_offset
    newMoof.set(Object(byte_parsing["m" /* itobe4 */])(mdatOffsets[0] + 8), trunOffsetInMoof + 16);
    segment.set(newMoof, moofOffsets[0]);

    if (moofDelta <= -8) {
      segment.set(createFreeBox(-moofDelta), newMoof.length);
    }

    return segment;
  } // patch trun data_offset


  newMoof.set(Object(byte_parsing["m" /* itobe4 */])(mdatOffsets[0] + moofDelta + 8), trunOffsetInMoof + 16);
  var newSegment = new Uint8Array(segment.length + moofDelta);
  var beforeMoof = segment.subarray(0, moofOffsets[0]);
  var afterMoof = segment.subarray(moofOffsets[1], segment.length);
  newSegment.set(beforeMoof, 0);
  newSegment.set(newMoof, beforeMoof.length);
  newSegment.set(afterMoof, beforeMoof.length + newMoof.length);
  return newSegment;
}
// CONCATENATED MODULE: ./src/transports/smooth/isobmff/patch_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Patch ISOBMFF Segment downloaded in Smooth Streaming.
 * @param {Uint8Array} segment
 * @param {Number} decodeTime
 * @return {Uint8Array}
 */

function patchSegment(segment, decodeTime) {
  var moofOffsets = Object(get_box["c" /* getBoxOffsets */])(segment, 0x6D6F6F66
  /* moof */
  );

  if (moofOffsets === null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }

  var moofContent = segment.subarray(moofOffsets[0] + 8, moofOffsets[1]);
  var mfhdBox = Object(get_box["a" /* getBox */])(moofContent, 0x6D666864
  /* mfhd */
  );
  var trafContent = Object(get_box["b" /* getBoxContent */])(moofContent, 0x74726166
  /* traf */
  );

  if (trafContent === null || mfhdBox === null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  }

  var tfhdBox = Object(get_box["a" /* getBox */])(trafContent, 0x74666864
  /* tfhd */
  );
  var trunBox = Object(get_box["a" /* getBox */])(trafContent, 0x7472756E
  /* trun */
  );

  if (tfhdBox === null || trunBox === null) {
    throw new Error("Smooth: Invalid ISOBMFF given");
  } // force trackId=1 since trackIds are not always reliable...


  tfhdBox.set([0, 0, 0, 1], 12);
  var tfdtBox = createTfdtBox(decodeTime);
  var newTrunBox = addDataOffsetFlagInTrun(trunBox);
  var sencContent = Object(get_box["d" /* getUuidContent */])(trafContent, 0xA2394F52, 0x5A9B4F14, 0xA2446C42, 0x7C648DF4);
  var newTrafBox = createTrafBox(tfhdBox, tfdtBox, newTrunBox, mfhdBox, sencContent);
  var newMoof = Object(create_box["b" /* createBoxWithChildren */])("moof", [mfhdBox, newTrafBox]);
  var trunOffsetInMoof = mfhdBox.length + tfhdBox.length + tfdtBox.length + 8
  /* moof size + name */
  + 8
  /* traf size + name */
  ;
  return replaceMoofInSegment(segment, newMoof, moofOffsets, trunOffsetInMoof);
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./src/transports/utils/byte_range.ts
var byte_range = __webpack_require__(44);

// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Uint8Array} mvhd
 * @param {Uint8Array} mvex
 * @param {Uint8Array} trak
 * @param {Object} pssList
 * @returns {Array.<Uint8Array>}
 */

function createMOOVBox(mvhd, mvex, trak, pssList) {
  var children = [mvhd, mvex, trak];
  pssList.forEach(function (pss) {
    var pssh = createPSSHBox(pss.systemId, pss.privateData, pss.keyIds);
    children.push(pssh);
  });
  return Object(create_box["b" /* createBoxWithChildren */])("moov", children);
}
/**
 * Create an initialization segment with the information given.
 * @param {Number} timescale
 * @param {string} type
 * @param {Uint8Array} stsd
 * @param {Uint8Array} mhd
 * @param {Number} width
 * @param {Number} height
 * @param {Array.<Object>} pssList - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */


function createInitSegment(timescale, type, stsd, mhd, width, height, pssList) {
  var stbl = Object(create_box["b" /* createBoxWithChildren */])("stbl", [stsd, Object(create_box["a" /* createBox */])("stts", new Uint8Array(0x08)), Object(create_box["a" /* createBox */])("stsc", new Uint8Array(0x08)), Object(create_box["a" /* createBox */])("stsz", new Uint8Array(0x0C)), Object(create_box["a" /* createBox */])("stco", new Uint8Array(0x08))]);
  var url = Object(create_box["a" /* createBox */])("url ", new Uint8Array([0, 0, 0, 1]));
  var dref = createDREFBox(url);
  var dinf = Object(create_box["b" /* createBoxWithChildren */])("dinf", [dref]);
  var minf = Object(create_box["b" /* createBoxWithChildren */])("minf", [mhd, dinf, stbl]);
  var hdlr = createHDLRBox(type);
  var mdhd = createMDHDBox(timescale); // this one is really important

  var mdia = Object(create_box["b" /* createBoxWithChildren */])("mdia", [mdhd, hdlr, minf]);
  var tkhd = createTKHDBox(width, height, 1);
  var trak = Object(create_box["b" /* createBoxWithChildren */])("trak", [tkhd, mdia]);
  var trex = createTREXBox(1);
  var mvex = Object(create_box["b" /* createBoxWithChildren */])("mvex", [trex]);
  var mvhd = createMVHDBox(timescale, 1); // in fact, we don't give a sh** about
  // this value :O

  var moov = createMOOVBox(mvhd, mvex, trak, pssList);
  var ftyp = createFTYPBox("isom", ["isom", "iso2", "iso6", "avc1", "dash"]);
  return Object(byte_parsing["h" /* concat */])(ftyp, moov);
}
// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_video_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Return full video Init segment as Uint8Array
 * @param {Number} timescale - lowest number, this one will be set into mdhd
 * *10000 in mvhd, e.g. 1000
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes
 * @param {Number} vRes
 * @param {Number} nalLength (1, 2 or 4)
 * @param {string} codecPrivateData
 * @param {Uint8Array} keyId - hex string representing the key Id,
 * 32 chars. eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList] - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */

function createVideoInitSegment(timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId, pssList) {
  var _pssList = pssList === undefined ? [] : pssList;

  var _codecPrivateData$spl = codecPrivateData.split("00000001"),
      spsHex = _codecPrivateData$spl[1],
      ppsHex = _codecPrivateData$spl[2];

  if (spsHex === undefined || ppsHex === undefined) {
    throw new Error("Smooth: unsupported codec private data.");
  }

  var sps = Object(byte_parsing["j" /* hexToBytes */])(spsHex);
  var pps = Object(byte_parsing["j" /* hexToBytes */])(ppsHex); // TODO NAL length is forced to 4

  var avcc = createAVCCBox(sps, pps, nalLength);
  var stsd;

  if (_pssList.length === 0 || keyId === undefined) {
    var avc1 = createAVC1Box(width, height, hRes, vRes, "AVC Coding", 24, avcc);
    stsd = createSTSDBox([avc1]);
  } else {
    var tenc = createTENCBox(1, 8, keyId);
    var schi = Object(create_box["b" /* createBoxWithChildren */])("schi", [tenc]);
    var schm = createSCHMBox("cenc", 65536);
    var frma = createFRMABox("avc1");
    var sinf = Object(create_box["b" /* createBoxWithChildren */])("sinf", [frma, schm, schi]);
    var encv = createENCVBox(width, height, hRes, vRes, "AVC Coding", 24, avcc, sinf);
    stsd = createSTSDBox([encv]);
  }

  return createInitSegment(timescale, "video", stsd, createVMHDBox(), width, height, _pssList);
}
// CONCATENATED MODULE: ./src/transports/smooth/isobmff/get_aaces_header.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Sampling frequencies defined in MPEG-4 Audio.
 * @type {Array.<Number>}
 */

var SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];
/**
 * Return AAC ES Header (hexstr form)
 *
 * @param {Number} type
 *          1 = AAC Main
 *          2 = AAC LC
 *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio
 * @param {Number} frequency
 * @param {Number} chans (1 or 2)
 * @returns {string}
 */

function getAacesHeader(type, frequency, chans) {
  var freq = SAMPLING_FREQUENCIES.indexOf(frequency); // TODO : handle Idx = 15...

  var val;
  val = (type & 0x3F) << 0x4;
  val = (val | freq & 0x1F) << 0x4;
  val = (val | chans & 0x1F) << 0x3;
  return Object(byte_parsing["e" /* bytesToHex */])(Object(byte_parsing["l" /* itobe2 */])(val));
}
// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_audio_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Return full audio initialization segment as Uint8Array.
 * @param {Number} timescale
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {string} codecPrivateData
 * @param {Uint8Array} keyId - hex string representing the key Id, 32 chars.
 * eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList]
 * @returns {Uint8Array}
 */

function createAudioInitSegment(timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId, pssList) {
  if (pssList === void 0) {
    pssList = [];
  }

  var _codecPrivateData = codecPrivateData.length === 0 ? getAacesHeader(2, sampleRate, channelsCount) : codecPrivateData;

  var esds = createESDSBox(1, _codecPrivateData);

  var stsd = function () {
    if (pssList.length === 0 || keyId === undefined) {
      var mp4a = createMP4ABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds);
      return createSTSDBox([mp4a]);
    }

    var tenc = createTENCBox(1, 8, keyId);
    var schi = Object(create_box["b" /* createBoxWithChildren */])("schi", [tenc]);
    var schm = createSCHMBox("cenc", 65536);
    var frma = createFRMABox("mp4a");
    var sinf = Object(create_box["b" /* createBoxWithChildren */])("sinf", [frma, schm, schi]);
    var enca = createENCABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf);
    return createSTSDBox([enca]);
  }();

  return createInitSegment(timescale, "audio", stsd, createSMHDBox(), 0, 0, pssList);
}
// CONCATENATED MODULE: ./src/transports/smooth/segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */

function regularSegmentLoader(_ref) {
  var url = _ref.url,
      segment = _ref.segment;
  var headers;
  var range = segment.range;

  if (Array.isArray(range)) {
    headers = {
      Range: Object(byte_range["a" /* default */])(range)
    };
  }

  return Object(request["a" /* default */])({
    url: url,
    responseType: "arraybuffer",
    headers: headers,
    sendProgressEvents: true
  });
}
/**
 * Defines the url for the request, load the right loader (custom/default
 * one).
 */


var segment_loader_generateSegmentLoader = function generateSegmentLoader(customSegmentLoader) {
  return function (_ref2) {
    var segment = _ref2.segment,
        representation = _ref2.representation,
        adaptation = _ref2.adaptation,
        period = _ref2.period,
        manifest = _ref2.manifest,
        url = _ref2.url;

    if (segment.isInit) {
      if (segment.privateInfos === undefined || segment.privateInfos.smoothInit === undefined) {
        throw new Error("Smooth: Invalid segment format");
      }

      var smoothInitPrivateInfos = segment.privateInfos.smoothInit;
      var responseData;
      var codecPrivateData = smoothInitPrivateInfos.codecPrivateData,
          _smoothInitPrivateInf = smoothInitPrivateInfos.protection,
          protection = _smoothInitPrivateInf === void 0 ? {
        keyId: undefined,
        keySystems: undefined
      } : _smoothInitPrivateInf;

      if (codecPrivateData === undefined) {
        throw new Error("Smooth: no codec private data.");
      }

      switch (adaptation.type) {
        case "video":
          {
            var _representation$width = representation.width,
                width = _representation$width === void 0 ? 0 : _representation$width,
                _representation$heigh = representation.height,
                height = _representation$heigh === void 0 ? 0 : _representation$heigh;
            responseData = createVideoInitSegment(segment.timescale, width, height, 72, 72, 4, // vRes, hRes, nal
            codecPrivateData, protection.keyId, protection.keySystems);
            break;
          }

        case "audio":
          {
            var _smoothInitPrivateInf2 = smoothInitPrivateInfos.channels,
                channels = _smoothInitPrivateInf2 === void 0 ? 0 : _smoothInitPrivateInf2,
                _smoothInitPrivateInf3 = smoothInitPrivateInfos.bitsPerSample,
                bitsPerSample = _smoothInitPrivateInf3 === void 0 ? 0 : _smoothInitPrivateInf3,
                _smoothInitPrivateInf4 = smoothInitPrivateInfos.packetSize,
                packetSize = _smoothInitPrivateInf4 === void 0 ? 0 : _smoothInitPrivateInf4,
                _smoothInitPrivateInf5 = smoothInitPrivateInfos.samplingRate,
                samplingRate = _smoothInitPrivateInf5 === void 0 ? 0 : _smoothInitPrivateInf5;
            responseData = createAudioInitSegment(segment.timescale, channels, bitsPerSample, packetSize, samplingRate, codecPrivateData, protection.keyId, protection.keySystems);
            break;
          }

        default:
          if (false) {}

          responseData = new Uint8Array(0);
      }

      return Object(of["a" /* of */])({
        type: "data-created",
        value: {
          responseData: responseData
        }
      });
    } else if (url === null) {
      return Object(of["a" /* of */])({
        type: "data-created",
        value: {
          responseData: null
        }
      });
    } else {
      var args = {
        adaptation: adaptation,
        manifest: manifest,
        period: period,
        representation: representation,
        segment: segment,
        transport: "smooth",
        url: url
      };

      if (typeof customSegmentLoader !== "function") {
        return regularSegmentLoader(args);
      }

      return new Observable["a" /* Observable */](function (obs) {
        var hasFinished = false;
        var hasFallbacked = false;
        /**
         * Callback triggered when the custom segment loader has a response.
         * @param {Object} args
         */

        var resolve = function resolve(_args) {
          if (!hasFallbacked) {
            hasFinished = true;
            obs.next({
              type: "data-loaded",
              value: {
                responseData: _args.data,
                size: _args.size,
                duration: _args.duration
              }
            });
            obs.complete();
          }
        };
        /**
         * Callback triggered when the custom segment loader fails
         * @param {*} err - The corresponding error encountered
         */


        var reject = function reject(err) {
          if (err === void 0) {
            err = {};
          }

          if (!hasFallbacked) {
            hasFinished = true;
            obs.error(err);
          }
        };

        var progress = function progress(_args) {
          if (!hasFallbacked) {
            obs.next({
              type: "progress",
              value: {
                duration: _args.duration,
                size: _args.size,
                totalSize: _args.totalSize
              }
            });
          }
        };

        var fallback = function fallback() {
          hasFallbacked = true; // HACK What is TypeScript/RxJS doing here??????

          /* tslint:disable deprecation */
          // @ts-ignore

          regularSegmentLoader(args).subscribe(obs);
          /* tslint:enable deprecation */
        };

        var callbacks = {
          reject: reject,
          resolve: resolve,
          fallback: fallback,
          progress: progress
        };
        var abort = customSegmentLoader(args, callbacks);
        return function () {
          if (!hasFinished && !hasFallbacked && typeof abort === "function") {
            abort();
          }
        };
      });
    }
  };
};

/* harmony default export */ var segment_loader = (segment_loader_generateSegmentLoader);
// CONCATENATED MODULE: ./src/transports/smooth/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var ISM_REG = /(\.isml?)(\?token=\S+)?$/;
var TOKEN_REG = /\?token=(\S+)/;
/**
 * TODO Remove this logic completely from the player
 * @param {Document} doc
 * @returns {string|null}
 */

function extractISML(doc) {
  return doc.getElementsByTagName("media")[0].getAttribute("src");
}
/**
 * Returns string corresponding to the token contained in the url's querystring.
 * Empty string if no token is found.
 * @param {string} url
 * @returns {string}
 */


function extractToken(url) {
  var tokenMatch = url.match(TOKEN_REG);

  if (tokenMatch !== null) {
    var match = tokenMatch[1];

    if (match !== undefined) {
      return match;
    }
  }

  return "";
}
/**
 * Replace/Remove token from the url's querystring
 * @param {string} url
 * @param {string} [token]
 * @returns {string}
 */


function replaceToken(url, token) {
  if (Object(is_non_empty_string["a" /* default */])(token)) {
    return url.replace(TOKEN_REG, "?token=" + token);
  } else {
    return url.replace(TOKEN_REG, "");
  }
}
/**
 * @param {string} url
 * @returns {string}
 */


function resolveManifest(url) {
  if (ISM_REG.test(url)) {
    Object(warn_once["a" /* default */])("Giving a isml URL to loadVideo is deprecated." + " Please give the Manifest URL directly");
    return url.replace(ISM_REG, "$1/manifest$2");
  }

  return url;
}


// CONCATENATED MODULE: ./src/transports/smooth/pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


















var WSX_REG = /\.wsx?(\?token=\S+)?/;
/**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */

function addNextSegments(adaptation, nextSegments, dlSegment) {
  log["a" /* default */].debug("Smooth Parser: update segments information.");
  var representations = adaptation.representations;

  for (var i = 0; i < representations.length; i++) {
    var representation = representations[i];

    representation.index._addSegments(nextSegments, dlSegment);
  }
}

/* harmony default export */ var pipelines = (function (options) {
  var smoothManifestParser = smooth(options);
  var segmentLoader = segment_loader(options.segmentLoader);
  var manifestLoaderOptions = {
    customManifestLoader: options.manifestLoader
  };
  var manifestLoader = Object(document_manifest_loader["a" /* default */])(manifestLoaderOptions);
  var manifestPipeline = {
    resolver: function resolver(_ref) {
      var url = _ref.url;

      if (url === undefined) {
        return Object(of["a" /* of */])({
          url: undefined
        });
      } // TODO Remove WSX logic


      var resolving;

      if (WSX_REG.test(url)) {
        Object(warn_once["a" /* default */])("Giving WSX URL to loadVideo is deprecated." + " You should only give Manifest URLs.");
        resolving = Object(request["a" /* default */])({
          url: replaceToken(url, ""),
          responseType: "document"
        }).pipe(Object(map["a" /* map */])(function (_ref2) {
          var value = _ref2.value;
          var extractedURL = extractISML(value.responseData);

          if (extractedURL === null || extractedURL.length === 0) {
            throw new Error("Invalid ISML");
          }

          return extractedURL;
        }));
      } else {
        resolving = Object(of["a" /* of */])(url);
      }

      var token = extractToken(url);
      return resolving.pipe(Object(map["a" /* map */])(function (_url) {
        return {
          url: replaceToken(resolveManifest(_url), token)
        };
      }));
    },
    loader: manifestLoader,
    parser: function parser(_ref3) {
      var response = _ref3.response,
          reqURL = _ref3.url;
      var url = response.url === undefined ? reqURL : response.url;
      var data = typeof response.responseData === "string" ? new DOMParser().parseFromString(response.responseData, "text/xml") : response.responseData; // TODO find a way to check if Document?

      var manifestReceivedTime = response.receivedTime;
      var parserResult = smoothManifestParser(data, url, manifestReceivedTime);
      var manifest = new src_manifest["a" /* default */](parserResult, {
        representationFilter: options.representationFilter,
        supplementaryImageTracks: options.supplementaryImageTracks,
        supplementaryTextTracks: options.supplementaryTextTracks
      });
      return Object(of["a" /* of */])({
        manifest: manifest,
        url: url
      });
    }
  };
  var segmentPipeline = {
    loader: function loader(content) {
      if (content.segment.isInit || options.checkMediaSegmentIntegrity !== true) {
        return segmentLoader(content);
      }

      return segmentLoader(content).pipe(Object(tap["a" /* tap */])(function (res) {
        if ((res.type === "data-loaded" || res.type === "data-chunk") && res.value.responseData !== null) {
          Object(check_isobmff_integrity["a" /* default */])(new Uint8Array(res.value.responseData), content.segment.isInit);
        }
      }));
    },
    parser: function parser(_ref4) {
      var content = _ref4.content,
          response = _ref4.response;
      var segment = content.segment,
          representation = content.representation,
          adaptation = content.adaptation,
          manifest = content.manifest;
      var data = response.data,
          isChunked = response.isChunked;

      if (data === null) {
        if (segment.isInit) {
          var segmentProtections = representation.getProtectionsInitializationData();
          return Object(of["a" /* of */])({
            type: "parsed-init-segment",
            value: {
              initializationData: null,
              segmentProtections: segmentProtections,
              initTimescale: undefined
            }
          });
        }

        return Object(of["a" /* of */])({
          type: "parsed-segment",
          value: {
            chunkData: null,
            chunkInfos: null,
            chunkOffset: 0,
            appendWindow: [undefined, undefined]
          }
        });
      }

      var responseBuffer = data instanceof Uint8Array ? data : new Uint8Array(data);

      if (segment.isInit) {
        // const psshInfo = takePSSHOut(responseBuffer);
        // if (psshInfo.length > 0) {
        //   for (let i = 0; i < psshInfo.length; i++) {
        //     const { systemID, data: psshData } = psshInfo[i];
        //     representation._addProtectionData("cenc", systemID, psshData);
        //   }
        // }
        var _segmentProtections = representation.getProtectionsInitializationData();

        return Object(of["a" /* of */])({
          type: "parsed-init-segment",
          value: {
            initializationData: data,
            segmentProtections: _segmentProtections,
            // smooth init segments are crafted by hand.
            // Their timescale is the one from the manifest.
            initTimescale: segment.timescale
          }
        });
      }

      var _extractTimingsInfos = extractTimingsInfos(responseBuffer, isChunked, segment, manifest.isLive),
          nextSegments = _extractTimingsInfos.nextSegments,
          chunkInfos = _extractTimingsInfos.chunkInfos;

      if (chunkInfos === null) {
        throw new Error("Smooth Segment without time information");
      }

      var chunkData = patchSegment(responseBuffer, chunkInfos.time);

      if (nextSegments.length > 0) {
        addNextSegments(adaptation, nextSegments, chunkInfos);
      }

      return Object(of["a" /* of */])({
        type: "parsed-segment",
        value: {
          chunkData: chunkData,
          chunkInfos: chunkInfos,
          chunkOffset: 0,
          appendWindow: [undefined, undefined]
        }
      });
    }
  };
  var textTrackPipeline = {
    loader: function loader(_ref5) {
      var segment = _ref5.segment,
          representation = _ref5.representation,
          url = _ref5.url;

      if (segment.isInit || url === null) {
        return Object(of["a" /* of */])({
          type: "data-created",
          value: {
            responseData: null
          }
        });
      }

      var isMP4 = isMP4EmbeddedTrack(representation);

      if (!isMP4 || options.checkMediaSegmentIntegrity !== true) {
        return Object(request["a" /* default */])({
          url: url,
          responseType: isMP4 ? "arraybuffer" : "text",
          sendProgressEvents: true
        });
      }

      return Object(request["a" /* default */])({
        url: url,
        responseType: "arraybuffer",
        sendProgressEvents: true
      }).pipe(Object(tap["a" /* tap */])(function (res) {
        if (res.type === "data-loaded") {
          Object(check_isobmff_integrity["a" /* default */])(new Uint8Array(res.value.responseData), segment.isInit);
        }
      }));
    },
    parser: function parser(_ref6) {
      var content = _ref6.content,
          response = _ref6.response;
      var manifest = content.manifest,
          adaptation = content.adaptation,
          representation = content.representation,
          segment = content.segment;
      var language = adaptation.language;
      var _representation$mimeT = representation.mimeType,
          mimeType = _representation$mimeT === void 0 ? "" : _representation$mimeT,
          _representation$codec = representation.codec,
          codec = _representation$codec === void 0 ? "" : _representation$codec;
      var data = response.data,
          isChunked = response.isChunked;

      if (segment.isInit) {
        // text init segment has no use in HSS
        return Object(of["a" /* of */])({
          type: "parsed-init-segment",
          value: {
            initializationData: null,
            segmentProtections: [],
            initTimescale: undefined
          }
        });
      }

      if (data === null) {
        return Object(of["a" /* of */])({
          type: "parsed-segment",
          value: {
            chunkData: null,
            chunkInfos: null,
            chunkOffset: 0,
            appendWindow: [undefined, undefined]
          }
        });
      }

      var nextSegments;
      var chunkInfos = null;
      var isMP4 = mimeType.indexOf("mp4") >= 0;

      var _sdStart;

      var _sdEnd;

      var _sdTimescale = 1;

      var _sdData;

      var _sdType;

      if (isMP4) {
        var chunkBytes;

        if (typeof data === "string") {
          chunkBytes = Object(byte_parsing["q" /* strToBytes */])(data);
        } else {
          chunkBytes = data instanceof Uint8Array ? data : new Uint8Array(data);
        }

        var timings = extractTimingsInfos(chunkBytes, isChunked, segment, manifest.isLive);
        nextSegments = timings.nextSegments;
        chunkInfos = timings.chunkInfos;

        if (chunkInfos === null) {
          if (isChunked) {
            log["a" /* default */].warn("Smooth: Unavailable time data for current text track.");
          } else {
            _sdStart = segment.time;
            _sdEnd = _sdStart + segment.duration;
            _sdTimescale = segment.timescale;
          }
        } else {
          _sdStart = chunkInfos.time;
          _sdEnd = !Object(is_null_or_undefined["a" /* default */])(chunkInfos.duration) ? chunkInfos.time + chunkInfos.duration : undefined;
          _sdTimescale = chunkInfos.timescale;
        }

        var lcCodec = codec.toLowerCase();

        if (mimeType === "application/ttml+xml+mp4" || lcCodec === "stpp" || lcCodec === "stpp.ttml.im1t") {
          _sdType = "ttml";
        } else if (lcCodec === "wvtt") {
          _sdType = "vtt";
        } else {
          throw new Error("could not find a text-track parser for the type " + mimeType);
        }

        var mdat = Object(read["a" /* getMDAT */])(chunkBytes);
        _sdData = Object(string_from_utf8["a" /* default */])(mdat);
      } else {
        var chunkString;

        if (typeof data !== "string") {
          var bytesData = data instanceof Uint8Array ? data : new Uint8Array(data);
          chunkString = Object(byte_parsing["f" /* bytesToStr */])(bytesData);
        } else {
          chunkString = data;
        }

        var segmentTime = segment.time; // vod is simple WebVTT or TTML text

        _sdStart = segmentTime;
        _sdEnd = segmentTime + segment.duration;
        _sdTimescale = segment.timescale;

        switch (mimeType) {
          case "application/x-sami":
          case "application/smil":
            // TODO SMIL should be its own format, no?
            _sdType = "sami";
            break;

          case "application/ttml+xml":
            _sdType = "ttml";
            break;

          case "text/vtt":
            _sdType = "vtt";
            break;
        }

        if (_sdType === undefined) {
          var _lcCodec = codec.toLowerCase();

          if (_lcCodec === "srt") {
            _sdType = "srt";
          } else {
            throw new Error("could not find a text-track parser for the type " + mimeType);
          }
        }

        _sdData = chunkString;
      }

      if (chunkInfos !== null && Array.isArray(nextSegments) && nextSegments.length > 0) {
        addNextSegments(adaptation, nextSegments, chunkInfos);
      }

      var chunkOffset = _sdStart === undefined ? 0 : _sdStart / _sdTimescale;
      return Object(of["a" /* of */])({
        type: "parsed-segment",
        value: {
          chunkData: {
            type: _sdType,
            data: _sdData,
            language: language,
            timescale: _sdTimescale,
            start: _sdStart,
            end: _sdEnd
          },
          chunkInfos: chunkInfos,
          chunkOffset: chunkOffset,
          appendWindow: [undefined, undefined]
        }
      });
    }
  };
  var imageTrackPipeline = {
    loader: function loader(_ref7) {
      var segment = _ref7.segment,
          url = _ref7.url;

      if (segment.isInit || url === null) {
        // image do not need an init segment. Passthrough directly to the parser
        return Object(of["a" /* of */])({
          type: "data-created",
          value: {
            responseData: null
          }
        });
      }

      return Object(request["a" /* default */])({
        url: url,
        responseType: "arraybuffer",
        sendProgressEvents: true
      });
    },
    parser: function parser(_ref8) {
      var response = _ref8.response,
          content = _ref8.content;
      var data = response.data,
          isChunked = response.isChunked;

      if (content.segment.isInit) {
        // image init segment has no use
        return Object(of["a" /* of */])({
          type: "parsed-init-segment",
          value: {
            initializationData: null,
            segmentProtections: [],
            initTimescale: undefined
          }
        });
      }

      if (isChunked) {
        throw new Error("Image data should not be downloaded in chunks");
      } // TODO image Parsing should be more on the sourceBuffer side, no?


      if (data === null || features["a" /* default */].imageParser === null) {
        return Object(of["a" /* of */])({
          type: "parsed-segment",
          value: {
            chunkData: null,
            chunkInfos: null,
            chunkOffset: 0,
            appendWindow: [undefined, undefined]
          }
        });
      }

      var bifObject = features["a" /* default */].imageParser(new Uint8Array(data));
      var thumbsData = bifObject.thumbs;
      return Object(of["a" /* of */])({
        type: "parsed-segment",
        value: {
          chunkData: {
            data: thumbsData,
            start: 0,
            end: Number.MAX_VALUE,
            timescale: 1,
            type: "bif"
          },
          chunkInfos: {
            time: 0,
            duration: Number.MAX_VALUE,
            timescale: bifObject.timescale
          },
          chunkOffset: 0,
          segmentProtections: [],
          appendWindow: [undefined, undefined]
        }
      });
    }
  };
  return {
    manifest: manifestPipeline,
    audio: segmentPipeline,
    video: segmentPipeline,
    text: textTrackPipeline,
    image: imageTrackPipeline
  };
});
/**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */

function isMP4EmbeddedTrack(representation) {
  return typeof representation.mimeType === "string" && representation.mimeType.indexOf("mp4") >= 0;
}
// CONCATENATED MODULE: ./src/transports/smooth/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var transports_smooth = __webpack_exports__["default"] = (pipelines);

/***/ }),
/* 198 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(14);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(7);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_parameters.ts
var get_parameters = __webpack_require__(120);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_parent_elements_by_tag_name.ts
var get_parent_elements_by_tag_name = __webpack_require__(83);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_styling.ts + 1 modules
var get_styling = __webpack_require__(35);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/nodes.ts
var nodes = __webpack_require__(59);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/resolve_styles_inheritance.ts
var resolve_styles_inheritance = __webpack_require__(121);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts + 1 modules
var get_time_delimiters = __webpack_require__(134);

// EXTERNAL MODULE: ./src/compat/add_class_name.ts
var add_class_name = __webpack_require__(162);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
var regexps = __webpack_require__(15);

// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_extent.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Apply `tts:extent` styling to an HTML element.
 * @param {HTMLElement} element
 * @param {string} extent
 */

function applyExtent(element, extent) {
  var trimmedExtent = extent.trim();

  if (trimmedExtent === "auto") {
    return;
  }

  var splittedExtent = trimmedExtent.split(" ");

  if (splittedExtent.length !== 2) {
    return;
  }

  var firstExtent = regexps["c" /* REGXP_LENGTH */].exec(splittedExtent[0]);
  var secondExtent = regexps["c" /* REGXP_LENGTH */].exec(splittedExtent[1]);

  if (firstExtent !== null && secondExtent !== null) {
    if (firstExtent[2] === "px" || firstExtent[2] === "%" || firstExtent[2] === "em") {
      element.style.width = firstExtent[1] + firstExtent[2];
    } else if (firstExtent[2] === "c") {
      Object(add_class_name["a" /* default */])(element, "proportional-style");
      element.setAttribute("data-proportional-width", firstExtent[1]);
    } else {
      log["a" /* default */].warn("TTML Parser: unhandled extent unit:", firstExtent[2]);
    }

    if (secondExtent[2] === "px" || secondExtent[2] === "%" || secondExtent[2] === "em") {
      element.style.height = secondExtent[1] + secondExtent[2];
    } else if (secondExtent[2] === "c") {
      Object(add_class_name["a" /* default */])(element, "proportional-style");
      element.setAttribute("data-proportional-height", secondExtent[1]);
    } else {
      log["a" /* default */].warn("TTML Parser: unhandled extent unit:", secondExtent[2]);
    }
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_font_size.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Apply `tts:fontSize` styling to an HTML element.
 * @param {HTMLElement} element
 * @param {string} fontSize
 */

function applyFontSize(element, fontSize) {
  var trimmedFontSize = fontSize.trim();
  var splittedFontSize = trimmedFontSize.split(" ");

  if (splittedFontSize.length === 0) {
    return;
  }

  var firstFontSize = regexps["c" /* REGXP_LENGTH */].exec(splittedFontSize[0]);

  if (firstFontSize === null) {
    return;
  }

  if (firstFontSize[2] === "px" || firstFontSize[2] === "%" || firstFontSize[2] === "em") {
    element.style.fontSize = firstFontSize[1] + firstFontSize[2];
  } else if (firstFontSize[2] === "c") {
    element.style.position = "relative";
    Object(add_class_name["a" /* default */])(element, "proportional-style");
    element.setAttribute("data-proportional-font-size", firstFontSize[1]);
  } else {
    log["a" /* default */].warn("TTML Parser: unhandled fontSize unit:", firstFontSize[2]);
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_line_height.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLElement} element
 * @param {string} lineHeight
 */

function applyLineHeight(element, lineHeight) {
  var trimmedLineHeight = lineHeight.trim();

  if (trimmedLineHeight === "auto") {
    return;
  }

  var firstLineHeight = regexps["c" /* REGXP_LENGTH */].exec(trimmedLineHeight[0]);

  if (firstLineHeight === null) {
    return;
  }

  if (firstLineHeight[2] === "px" || firstLineHeight[2] === "%" || firstLineHeight[2] === "em") {
    element.style.lineHeight = firstLineHeight[1] + firstLineHeight[2];
  } else if (firstLineHeight[2] === "c") {
    Object(add_class_name["a" /* default */])(element, "proportional-style");
    element.setAttribute("data-proportional-line-height", firstLineHeight[1]);
  } else {
    log["a" /* default */].warn("TTML Parser: unhandled lineHeight unit:", firstLineHeight[2]);
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_origin.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLElement} element
 * @param {string} origin
 */

function applyOrigin(element, origin) {
  var trimmedOrigin = origin.trim();

  if (trimmedOrigin === "auto") {
    return;
  }

  var splittedOrigin = trimmedOrigin.split(" ");

  if (splittedOrigin.length !== 2) {
    return;
  }

  var firstOrigin = regexps["c" /* REGXP_LENGTH */].exec(splittedOrigin[0]);
  var secondOrigin = regexps["c" /* REGXP_LENGTH */].exec(splittedOrigin[1]);

  if (firstOrigin !== null && secondOrigin !== null) {
    if (firstOrigin[2] === "px" || firstOrigin[2] === "%" || firstOrigin[2] === "em") {
      element.style.position = "relative";
      element.style.left = firstOrigin[1] + firstOrigin[2];
    } else if (firstOrigin[2] === "c") {
      element.style.position = "relative";
      Object(add_class_name["a" /* default */])(element, "proportional-style");
      element.setAttribute("data-proportional-left", firstOrigin[1]);
    } else {
      log["a" /* default */].warn("TTML Parser: unhandled origin unit:", firstOrigin[2]);
    }

    if (secondOrigin[2] === "px" || secondOrigin[2] === "%" || secondOrigin[2] === "em") {
      element.style.position = "relative";
      element.style.top = secondOrigin[1] + secondOrigin[2];
    } else if (secondOrigin[2] === "c") {
      element.style.position = "relative";
      Object(add_class_name["a" /* default */])(element, "proportional-style");
      element.setAttribute("data-proportional-top", secondOrigin[1]);
    } else {
      log["a" /* default */].warn("TTML Parser: unhandled origin unit:", secondOrigin[2]);
    }
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_padding.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLElement} element
 * @param {string} padding
 */

function applyPadding(element, padding) {
  var trimmedPadding = padding.trim();
  var splittedPadding = trimmedPadding.split(" ");

  if (splittedPadding.length < 1) {
    return;
  }

  var firstPadding = regexps["c" /* REGXP_LENGTH */].exec(splittedPadding[0]);

  if (firstPadding === null) {
    return;
  }

  if (firstPadding[2] === "px" || firstPadding[2] === "%" || firstPadding[2] === "em") {
    var firstPaddingValue = firstPadding[1] + firstPadding[2];

    if (splittedPadding.length === 1) {
      element.style.padding = firstPaddingValue;
    } else if (splittedPadding.length === 2) {
      element.style.paddingTop = firstPaddingValue;
      element.style.paddingBottom = firstPaddingValue;
    } else {
      element.style.paddingTop = firstPaddingValue;
    }
  } else if (firstPadding[2] === "c") {
    Object(add_class_name["a" /* default */])(element, "proportional-style");

    if (splittedPadding.length === 1) {
      element.setAttribute("data-proportional-padding-top", firstPadding[1]);
      element.setAttribute("data-proportional-padding-bottom", firstPadding[1]);
      element.setAttribute("data-proportional-padding-left", firstPadding[1]);
      element.setAttribute("data-proportional-padding-right", firstPadding[1]);
    } else if (splittedPadding.length === 2) {
      element.setAttribute("data-proportional-padding-top", firstPadding[1]);
      element.setAttribute("data-proportional-padding-bottom", firstPadding[1]);
    } else {
      element.setAttribute("data-proportional-padding-top", firstPadding[1]);
    }
  } else {
    log["a" /* default */].warn("TTML Parser: unhandled padding unit:", firstPadding[2]);
  }

  if (splittedPadding.length === 1) {
    return;
  }

  var secondPadding = regexps["c" /* REGXP_LENGTH */].exec(splittedPadding[1]);

  if (secondPadding === null) {
    return;
  }

  if (secondPadding[2] === "px" || secondPadding[2] === "%" || secondPadding[2] === "em") {
    var secondPaddingValue = secondPadding[1] + secondPadding[2];

    if (splittedPadding.length < 4) {
      element.style.paddingLeft = secondPaddingValue;
      element.style.paddingRight = secondPaddingValue;
    } else {
      element.style.paddingRight = secondPaddingValue;
    }
  } else if (secondPadding[2] === "c") {
    Object(add_class_name["a" /* default */])(element, "proportional-style");

    if (splittedPadding.length < 4) {
      element.setAttribute("data-proportional-padding-left", secondPadding[1]);
      element.setAttribute("data-proportional-padding-right", secondPadding[1]);
    } else {
      element.setAttribute("data-proportional-padding-right", secondPadding[1]);
    }
  } else {
    log["a" /* default */].warn("TTML Parser: unhandled padding unit:", secondPadding[2]);
  }

  if (splittedPadding.length === 2) {
    return;
  }

  var thirdPadding = regexps["c" /* REGXP_LENGTH */].exec(splittedPadding[2]);

  if (thirdPadding === null) {
    return;
  }

  if (thirdPadding[2] === "px" || thirdPadding[2] === "%" || thirdPadding[2] === "em") {
    var thirdPaddingValue = thirdPadding[1] + thirdPadding[2];
    element.style.paddingBottom = thirdPaddingValue;
  } else if (thirdPadding[2] === "c") {
    Object(add_class_name["a" /* default */])(element, "proportional-style");
    element.setAttribute("data-proportional-padding-bottom", thirdPadding[1]);
  } else {
    log["a" /* default */].warn("TTML Parser: unhandled padding unit:", thirdPadding[2]);
  }

  if (splittedPadding.length === 3) {
    return;
  }

  var fourthPadding = regexps["c" /* REGXP_LENGTH */].exec(splittedPadding[3]);

  if (fourthPadding === null) {
    return;
  }

  if (fourthPadding[2] === "px" || fourthPadding[2] === "%" || fourthPadding[2] === "em") {
    var fourthPaddingValue = fourthPadding[1] + fourthPadding[2];
    element.style.paddingLeft = fourthPaddingValue;
  } else if (fourthPadding[2] === "c") {
    Object(add_class_name["a" /* default */])(element, "proportional-style");
    element.setAttribute("data-proportional-padding-left", fourthPadding[1]);
  } else {
    log["a" /* default */].warn("TTML Parser: unhandled padding unit:", fourthPadding[2]);
  }
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/generate_css_test_outline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Try to replicate the textOutline TTML style property into CSS.
 *
 * We mock it throught the text-shadow property, translating the TTML thickness
 * into blur radius and the blur-radius into... nothing.
 *
 * @param {string} color
 * @param {string|number} thickness
 * @returns {string}
 */
function generateCSSTextOutline(color, thickness) {
  return "-1px -1px " + thickness + " " + color + "," + ("1px -1px " + thickness + " " + color + ",") + ("-1px 1px " + thickness + " " + color + ",") + ("1px 1px " + thickness + " " + color);
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/ttml_color_to_css_color.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Translate a color indicated in TTML-style to a CSS-style color.
 * @param {string} color
 * @returns {string} color
 */

function ttmlColorToCSSColor(color) {
  // TODO check all possible color fomats
  var regRes;
  regRes = regexps["b" /* REGXP_8_HEX_COLOR */].exec(color);

  if (regRes != null) {
    return "rgba(" + String(parseInt(regRes[1], 16)) + "," + String(parseInt(regRes[2], 16)) + "," + String(parseInt(regRes[3], 16)) + "," + String(parseInt(regRes[4], 16) / 255) + ")";
  }

  regRes = regexps["a" /* REGXP_4_HEX_COLOR */].exec(color);

  if (regRes != null) {
    return "rgba(" + String(parseInt(regRes[1] + regRes[1], 16)) + "," + String(parseInt(regRes[2] + regRes[2], 16)) + "," + String(parseInt(regRes[3] + regRes[3], 16)) + "," + String(parseInt(regRes[4] + regRes[4], 16) / 255) + ")";
  }

  regRes = regexps["f" /* REGXP_RGB_COLOR */].exec(color);

  if (regRes != null) {
    return "rgb(" + String(+regRes[1]) + "," + String(+regRes[2]) + "," + String(+regRes[3]) + ")";
  }

  regRes = regexps["e" /* REGXP_RGBA_COLOR */].exec(color);

  if (regRes != null) {
    return "rgba(" + String(+regRes[1]) + "," + String(+regRes[2]) + "," + String(+regRes[3]) + "," + String(+regRes[4] / 255) + ")";
  }

  return color;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/create_element.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











 // Styling which can be applied to <span> from any level upper.
// Added here as an optimization

var SPAN_LEVEL_ATTRIBUTES = ["color", "direction", "display", "fontFamily", "fontSize", "fontStyle", "fontWeight", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption"]; // TODO
// tts:showBackground (applies to region)
// tts:zIndex (applies to region)

/**
 * Apply style set for a singular text span of the current cue.
 * @param {HTMLElement} element - The text span
 * @param {Object} style - The style to apply
 */

function applyTextStyle(element, style, shouldTrimWhiteSpace) {
  // applies to span
  var color = style.color;

  if (Object(is_non_empty_string["a" /* default */])(color)) {
    element.style.color = ttmlColorToCSSColor(color);
  } // applies to body, div, p, region, span


  var backgroundColor = style.backgroundColor;

  if (Object(is_non_empty_string["a" /* default */])(backgroundColor)) {
    element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor);
  } // applies to span


  var textOutline = style.textOutline;

  if (Object(is_non_empty_string["a" /* default */])(textOutline)) {
    var outlineData = textOutline.trim().replace(/\s+/g, " ").split(" ");
    var len = outlineData.length;

    if (len === 3) {
      var outlineColor = ttmlColorToCSSColor(outlineData[0]);
      var thickness = outlineData[1];
      element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);
    } else if (Object(is_non_empty_string["a" /* default */])(color) && len === 1) {
      var _thickness = outlineData[0];
      element.style.textShadow = generateCSSTextOutline(color, _thickness);
    } else if (len === 2) {
      var isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);
      var isFirstArgANumber = /^[0-9]/.test(outlineData[0]); // XOR-ing to be sure we get what we have

      if (isFirstArgAColor !== isFirstArgANumber) {
        if (isFirstArgAColor) {
          var _outlineColor = ttmlColorToCSSColor(outlineData[0]);

          var _thickness2 = outlineData[1];
          element.style.textShadow = generateCSSTextOutline(_outlineColor, _thickness2);
        } else if (Object(is_non_empty_string["a" /* default */])(color)) {
          var _thickness3 = outlineData[0];
          element.style.textShadow = generateCSSTextOutline(color, _thickness3);
        }
      }
    }
  } // applies to span


  var textDecoration = style.textDecoration;

  if (Object(is_non_empty_string["a" /* default */])(textDecoration)) {
    switch (textDecoration) {
      case "noUnderline":
      case "noLineThrough":
      case "noOverline":
        element.style.textDecoration = "none";
        break;

      case "lineThrough":
        element.style.textDecoration = "line-through";
        break;

      default:
        element.style.textDecoration = textDecoration;
        break;
    }
  } // applies to span


  var fontFamily = style.fontFamily;

  if (Object(is_non_empty_string["a" /* default */])(fontFamily)) {
    switch (fontFamily) {
      case "proportionalSansSerif":
        element.style.fontFamily = "Arial, Helvetica, Liberation Sans, sans-serif";
        break;
      // TODO monospace or sans-serif or font with both?

      case "monospaceSansSerif":
      case "sansSerif":
        element.style.fontFamily = "sans-serif";
        break;

      case "monospaceSerif":
      case "default":
        element.style.fontFamily = "Courier New, Liberation Mono, monospace";
        break;
      // TODO font with both?

      case "proportionalSerif":
        element.style.fontFamily = "serif";
        break;

      default:
        element.style.fontFamily = fontFamily;
    }
  } // applies to span


  var fontStyle = style.fontStyle;

  if (Object(is_non_empty_string["a" /* default */])(fontStyle)) {
    element.style.fontStyle = fontStyle;
  } // applies to span


  var fontWeight = style.fontWeight;

  if (Object(is_non_empty_string["a" /* default */])(fontWeight)) {
    element.style.fontWeight = fontWeight;
  } // applies to span


  var fontSize = style.fontSize;

  if (Object(is_non_empty_string["a" /* default */])(fontSize)) {
    applyFontSize(element, fontSize);
  } else {
    Object(add_class_name["a" /* default */])(element, "proportional-style");
    element.setAttribute("data-proportional-font-size", "1");
  } // applies to p, span


  var direction = style.direction;

  if (Object(is_non_empty_string["a" /* default */])(direction)) {
    element.style.direction = direction;
  } // applies to p, span


  var unicodeBidi = style.unicodeBidi;

  if (Object(is_non_empty_string["a" /* default */])(unicodeBidi)) {
    switch (unicodeBidi) {
      case "bidiOverride":
        element.style.unicodeBidi = "bidi-override";
        break;

      case "embed":
        element.style.unicodeBidi = "embed";
        break;

      default:
        element.style.unicodeBidi = "normal";
    }
  } // applies to body, div, p, region, span


  var visibility = style.visibility;

  if (Object(is_non_empty_string["a" /* default */])(visibility)) {
    element.style.visibility = visibility;
  } // applies to body, div, p, region, span


  var display = style.display;

  if (display === "none") {
    element.style.display = "none";
  } // applies to body, div, p, region, span


  var wrapOption = style.wrapOption;
  element.style.whiteSpace = wrapOption === "noWrap" ? shouldTrimWhiteSpace ? "nowrap" : "pre" : shouldTrimWhiteSpace ? "normal" : "pre-wrap";
}
/**
 * Apply style for the general text track div.
 * @param {HTMLElement} element - The <div> the style will be applied on.
 * @param {Object} style - The general style object of the paragraph.
 */


function applyGeneralStyle(element, style) {
  // applies to tt, region
  var extent = style.extent;

  if (Object(is_non_empty_string["a" /* default */])(extent)) {
    applyExtent(element, extent);
  } // applies to region


  var writingMode = style.writingMode;

  if (Object(is_non_empty_string["a" /* default */])(writingMode)) {} // TODO
  // applies to region


  var overflow = style.overflow;
  element.style.overflow = Object(is_non_empty_string["a" /* default */])(overflow) ? overflow : "hidden"; // applies to region

  var padding = style.padding;

  if (Object(is_non_empty_string["a" /* default */])(padding)) {
    applyPadding(element, padding);
  } // applies to region


  var origin = style.origin;

  if (Object(is_non_empty_string["a" /* default */])(origin)) {
    applyOrigin(element, origin);
  } // applies to region


  var displayAlign = style.displayAlign;
  element.style.display = "flex";
  element.style.flexDirection = "column";

  if (Object(is_non_empty_string["a" /* default */])(displayAlign)) {
    switch (displayAlign) {
      case "before":
        element.style.justifyContent = "flex-start";
        break;

      case "center":
        element.style.justifyContent = "center";
        break;

      case "after":
        element.style.justifyContent = "flex-end";
        break;
    }
  } // applies to region


  var opacity = style.opacity;

  if (Object(is_non_empty_string["a" /* default */])(opacity)) {
    element.style.opacity = opacity;
  } // applies to body, div, p, region, span


  var visibility = style.visibility;

  if (Object(is_non_empty_string["a" /* default */])(visibility)) {
    element.style.visibility = visibility;
  } // applies to body, div, p, region, span


  var display = style.display;

  if (display === "none") {
    element.style.display = "none";
  }
}
/**
 * Apply style set for a <p> element
 * @param {HTMLElement} element - The <p> element
 * @param {Object} style - The general style object of the paragraph.
 */


function applyPStyle(element, style) {
  element.style.margin = "0px"; // applies to body, div, p, region, span

  var paragraphBackgroundColor = style.backgroundColor;

  if (Object(is_non_empty_string["a" /* default */])(paragraphBackgroundColor)) {
    element.style.backgroundColor = ttmlColorToCSSColor(paragraphBackgroundColor);
  } // applies to p


  var lineHeight = style.lineHeight;

  if (Object(is_non_empty_string["a" /* default */])(lineHeight)) {
    applyLineHeight(element, lineHeight);
  } // applies to p


  var textAlign = style.textAlign;

  if (Object(is_non_empty_string["a" /* default */])(textAlign)) {
    switch (textAlign) {
      case "center":
        element.style.textAlign = "center";
        break;

      case "left":
      case "start":
        // TODO check what start means (difference with left, writing direction?)
        element.style.textAlign = "left";
        break;

      case "right":
      case "end":
        // TODO check what end means (difference with right, writing direction?)
        element.style.textAlign = "right";
        break;
    }
  }
}
/**
 * Creates span of text for the given #text element, with the right style.
 *
 * TODO create text elements as string? Might help performances.
 * @param {Element} el - the #text element, which text content should be
 * displayed
 * @param {Object} style - the style object for the given text
 * @param {Boolean} shouldTrimWhiteSpace - True if the space should be
 * trimmed.
 * @returns {HTMLElement}
 */


function createTextElement(el, style, shouldTrimWhiteSpace) {
  var textElement = document.createElement("span");
  var textContent = el.textContent === null ? "" : el.textContent;

  if (shouldTrimWhiteSpace) {
    // 1. Trim leading and trailing whitespace.
    // 2. Collapse multiple spaces into one.
    var trimmed = textContent.trim();
    trimmed = trimmed.replace(/\s+/g, " ");
    textContent = trimmed;
  }

  textElement.innerHTML = textContent;
  textElement.className = "rxp-texttrack-span";
  applyTextStyle(textElement, style, shouldTrimWhiteSpace);
  return textElement;
}
/**
 * Generate every text elements to display in a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle - The general style object of the paragraph.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {Array.<HTMLElement>}
 */


function generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
  /**
   * Recursive function, taking a node in argument and returning the
   * corresponding array of HTMLElement in order.
   * @param {Node} node - the node in question
   * @param {Object} style - the current state of the style for the node.
   * /!\ The style object can be mutated, provide a copy of it.
   * @param {Array.<Element>} spans - The spans parent of this node.
   * @param {Boolean} shouldTrimWhiteSpaceFromParent - True if the space should be
   * trimmed by default. From the parent xml:space parameter.
   * @returns {Array.<HTMLElement>}
   */
  function loop(node, style, spans, shouldTrimWhiteSpaceFromParent) {
    var childNodes = node.childNodes;
    var elements = [];

    for (var i = 0; i < childNodes.length; i++) {
      var currentNode = childNodes[i];

      if (currentNode.nodeName === "#text") {
        var _getStylingAttributes = Object(get_styling["a" /* getStylingAttributes */])(["backgroundColor"], spans, styles, regions),
            backgroundColor = _getStylingAttributes.backgroundColor;

        if (Object(is_non_empty_string["a" /* default */])(backgroundColor)) {
          style.backgroundColor = backgroundColor;
        } else {
          delete style.backgroundColor;
        }

        var el = createTextElement(currentNode, style, shouldTrimWhiteSpaceFromParent);
        elements.push(el);
      } else if (currentNode.nodeName === "br") {
        var br = document.createElement("BR");
        elements.push(br);
      } else if (currentNode.nodeName === "span" && currentNode.nodeType === Node.ELEMENT_NODE && currentNode.childNodes.length > 0) {
        var spaceAttribute = currentNode.getAttribute("xml:space");
        var shouldTrimWhiteSpaceOnSpan = Object(is_non_empty_string["a" /* default */])(spaceAttribute) ? spaceAttribute === "default" : shouldTrimWhiteSpaceFromParent; // compute the new applyable style

        var newStyle = Object(object_assign["a" /* default */])({}, style, Object(get_styling["a" /* getStylingAttributes */])(SPAN_LEVEL_ATTRIBUTES, [currentNode], styles, regions));
        elements.push.apply(elements, loop(currentNode, newStyle, [currentNode].concat(spans), shouldTrimWhiteSpaceOnSpan));
      }
    }

    return elements;
  }

  return loop(paragraph, Object(object_assign["a" /* default */])({}, paragraphStyle), [], shouldTrimWhiteSpace);
}
/**
 * @param {Element} paragraph
 * @param {Element} body
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {HTMLElement}
 */


function createElement(paragraph, body, regions, styles, paragraphStyle, _ref) {
  var cellResolution = _ref.cellResolution,
      shouldTrimWhiteSpace = _ref.shouldTrimWhiteSpace;
  var divs = Object(get_parent_elements_by_tag_name["a" /* default */])(paragraph, "div");
  var parentElement = document.createElement("DIV");
  parentElement.className = "rxp-texttrack-region";
  parentElement.setAttribute("data-resolution-columns", String(cellResolution.columns));
  parentElement.setAttribute("data-resolution-rows", String(cellResolution.rows));
  applyGeneralStyle(parentElement, paragraphStyle);

  if (body !== null) {
    // applies to body, div, p, region, span
    var _getStylingAttributes2 = Object(get_styling["a" /* getStylingAttributes */])(["backgroundColor"], [].concat(divs, [body]), styles, regions),
        bodyBackgroundColor = _getStylingAttributes2.bodyBackgroundColor;

    if (Object(is_non_empty_string["a" /* default */])(bodyBackgroundColor)) {
      parentElement.style.backgroundColor = ttmlColorToCSSColor(bodyBackgroundColor);
    }
  }

  var pElement = document.createElement("p");
  pElement.className = "rxp-texttrack-p";
  applyPStyle(pElement, paragraphStyle);
  var textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace);

  for (var i = 0; i < textContent.length; i++) {
    pElement.appendChild(textContent[i]);
  } // NOTE:
  // The following code is for the inclusion of div elements. This has no
  // advantage for now, and might only with future evolutions.
  // (This is only an indication of what the base of the code could look like).
  // if (divs.length) {
  //   let container = parentElement;
  //   for (let i = divs.length - 1; i >= 0; i--) {
  //     // TODO manage style at div level?
  //     // They are: visibility, display and backgroundColor
  //     // All these do not have any difference if applied to the <p> element
  //     // instead of the div.
  //     // The advantage might only be for multiple <p> elements dispatched
  //     // in multiple div Which we do not manage anyway for now.
  //     const divEl = document.createElement("DIV");
  //     divEl.className = "rxp-texttrack-div";
  //     container.appendChild(divEl);
  //     container = divEl;
  //   }
  //   container.appendChild(pElement);
  //   parentElement.appendChild(container);
  // } else {
  //   parentElement.appendChild(pElement);
  // }


  parentElement.appendChild(pElement);
  return parentElement;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parse_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Element} paragraph
 * @param {Number} timeOffset
 * @param {Array.<Object>} idStyles
 * @param {Array.<Object>} regionStyles
 * @param {Element} body
 * @param {Object} paragraphStyle
 * @param {Object} ttParams
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {Object|null}
 */

function parseCue(paragraph, timeOffset, idStyles, regionStyles, body, paragraphStyle, ttParams, shouldTrimWhiteSpace) {
  // Disregard empty elements:
  // TTML allows for empty elements like <div></div>.
  // If paragraph has neither time attributes, nor
  // non-whitespace text, don't try to make a cue out of it.
  if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent === null ? "" : paragraph.textContent)) {
    return null;
  }

  var cellResolution = ttParams.cellResolution;

  var _getTimeDelimiters = Object(get_time_delimiters["a" /* default */])(paragraph, ttParams),
      start = _getTimeDelimiters.start,
      end = _getTimeDelimiters.end;

  var element = createElement(paragraph, body, regionStyles, idStyles, paragraphStyle, {
    cellResolution: cellResolution,
    shouldTrimWhiteSpace: shouldTrimWhiteSpace
  });
  return {
    start: start + timeOffset,
    end: end + timeOffset,
    element: element
  };
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parse_ttml_to_div.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









var STYLE_ATTRIBUTES = ["backgroundColor", "color", "direction", "display", "displayAlign", "extent", "fontFamily", "fontSize", "fontStyle", "fontWeight", "lineHeight", "opacity", "origin", "overflow", "padding", "textAlign", "textDecoration", "textOutline", "unicodeBidi", "visibility", "wrapOption", "writingMode"];
/**
 * Create array of objects which should represent the given TTML text track.
 * These objects have the following structure
 *   - start {Number}: start time, in seconds, at which the cue should
 *     be displayed
 *   - end {Number}: end time, in seconds, at which the cue should
 *     be displayed
 *   - element {HTMLElement}: <div> element representing the cue, with the
 *     right style. This div should then be appended to an element having
 *     the exact size of the wanted region the text track provide cues for.
 *
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */

function parseTTMLStringToDIV(str, timeOffset) {
  var ret = [];
  var xml = new DOMParser().parseFromString(str, "text/xml");

  if (xml !== null && xml !== undefined) {
    var tts = xml.getElementsByTagName("tt");
    var tt = tts[0];

    if (tt === undefined) {
      throw new Error("invalid XML");
    }

    var body = Object(nodes["a" /* getBodyNode */])(tt);
    var styleNodes = Object(nodes["c" /* getStyleNodes */])(tt);
    var regionNodes = Object(nodes["b" /* getRegionNodes */])(tt);
    var paragraphNodes = Object(nodes["d" /* getTextNodes */])(tt);
    var ttParams = Object(get_parameters["a" /* default */])(tt); // construct idStyles array based on the xml as an optimization

    var idStyles = [];

    for (var i = 0; i <= styleNodes.length - 1; i++) {
      var styleNode = styleNodes[i];

      if (styleNode instanceof Element) {
        var styleID = styleNode.getAttribute("xml:id");

        if (styleID !== null) {
          var subStyles = styleNode.getAttribute("style");
          var extendsStyles = subStyles === null ? [] : subStyles.split(" ");
          idStyles.push({
            id: styleID,
            style: Object(get_styling["b" /* getStylingFromElement */])(styleNode),
            extendsStyles: extendsStyles
          });
        }
      }
    }

    Object(resolve_styles_inheritance["a" /* default */])(idStyles); // construct regionStyles array based on the xml as an optimization

    var regionStyles = [];

    for (var _i = 0; _i <= regionNodes.length - 1; _i++) {
      var regionNode = regionNodes[_i];

      if (regionNode instanceof Element) {
        var regionID = regionNode.getAttribute("xml:id");

        if (regionID !== null) {
          (function () {
            var regionStyle = Object(get_styling["b" /* getStylingFromElement */])(regionNode);
            var associatedStyleID = regionNode.getAttribute("style");

            if (Object(is_non_empty_string["a" /* default */])(associatedStyleID)) {
              var style = Object(array_find["a" /* default */])(idStyles, function (x) {
                return x.id === associatedStyleID;
              });

              if (style !== undefined) {
                regionStyle = Object(object_assign["a" /* default */])({}, style.style, regionStyle);
              }
            }

            regionStyles.push({
              id: regionID,
              style: regionStyle,
              // already handled
              extendsStyles: []
            });
          })();
        }
      }
    } // Computing the style takes a lot of ressources.
    // To avoid too much re-computation, let's compute the body style right
    // now and do the rest progressively.
    // TODO Compute corresponding CSS style here (as soon as we now the TTML
    // style) to speed up the process even
    // more.


    var bodyStyle = body !== null ? Object(get_styling["a" /* getStylingAttributes */])(STYLE_ATTRIBUTES, [body], idStyles, regionStyles) : Object(get_styling["a" /* getStylingAttributes */])(STYLE_ATTRIBUTES, [], idStyles, regionStyles);
    var bodySpaceAttribute = body !== null ? body.getAttribute("xml:space") : undefined;
    var shouldTrimWhiteSpaceOnBody = bodySpaceAttribute === "default" || ttParams.spaceStyle === "default";

    for (var _i2 = 0; _i2 < paragraphNodes.length; _i2++) {
      var paragraph = paragraphNodes[_i2];

      if (paragraph instanceof Element) {
        var divs = Object(get_parent_elements_by_tag_name["a" /* default */])(paragraph, "div");
        var paragraphStyle = Object(object_assign["a" /* default */])({}, bodyStyle, Object(get_styling["a" /* getStylingAttributes */])(STYLE_ATTRIBUTES, [paragraph].concat(divs), idStyles, regionStyles));
        var paragraphSpaceAttribute = paragraph.getAttribute("xml:space");
        var shouldTrimWhiteSpaceOnParagraph = Object(is_non_empty_string["a" /* default */])(paragraphSpaceAttribute) ? paragraphSpaceAttribute === "default" : shouldTrimWhiteSpaceOnBody;
        var cue = parseCue(paragraph, timeOffset, idStyles, regionStyles, body, paragraphStyle, ttParams, shouldTrimWhiteSpaceOnParagraph);

        if (cue !== null) {
          ret.push(cue);
        }
      }
    }
  }

  return ret;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var html = __webpack_exports__["default"] = (parseTTMLStringToDIV);

/***/ }),
/* 199 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/get_cue_blocks.ts
var get_cue_blocks = __webpack_require__(118);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/utils.ts
var utils = __webpack_require__(62);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/get_style_blocks.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */

function getStyleBlocks(linified, headerOffset) {
  var styleBlocks = [];

  for (var i = headerOffset; i < linified.length; i++) {
    //
    if (Object(utils["d" /* isStartOfStyleBlock */])(linified, i)) {
      var startOfStyleBlock = i;
      i++; // continue incrementing i until either:
      //   - empty line
      //   - end of file

      while (Object(is_non_empty_string["a" /* default */])(linified[i])) {
        i++;
      }

      var styleBlock = linified.slice(startOfStyleBlock, i);
      styleBlocks.push(styleBlock);
    } else if (Object(is_non_empty_string["a" /* default */])(linified[i])) {
      // continue incrementing i until either:
      //   - empty line
      //   - end
      while (Object(is_non_empty_string["a" /* default */])(linified[i])) {
        i++;
      }
    }
  }

  return styleBlocks;
}
// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts + 1 modules
var parse_cue_block = __webpack_require__(133);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_default_style_elements.ts
/**
 * Creates default classes defined in the W3 specification
 *
 * https://www.w3.org/TR/webvtt1/#default-classes
 */
var colorMap = {
  white: "#ffffff",
  lime: "#00ff00",
  cyan: "#00ffff",
  red: "#ff0000",
  yellow: "#ffff00",
  magenta: "#ff00ff",
  blue: "#0000ff",
  black: "#000000"
};
function createDefaultStyleElements() {
  return Object.keys(colorMap).reduce(function (result, key) {
    result[key] = "color: " + colorMap[key] + ";";
    result["bg_" + key] = "background-color: " + colorMap[key] + ";";
    return result;
  }, {});
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parse_style_block.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse style element from WebVTT.
 * @param {Array.<Array.<string>>} styleBlocks
 * @return {Object}
 */

function parseStyleBlocks(styleBlocks) {
  var classes = createDefaultStyleElements();
  var global = "";
  styleBlocks.forEach(function (styleBlock) {
    if (styleBlock.length >= 2) {
      for (var index = 1; index < styleBlock.length; index++) {
        var line = styleBlock[index];

        if (Array.isArray(line.match(/::cue {/))) {
          line = styleBlock[++index];

          while (Object(is_non_empty_string["a" /* default */])(line) && !(Array.isArray(line.match(/}/)) || line.length === 0)) {
            global += line;
            line = styleBlock[++index];
          }
        } else {
          (function () {
            var classNames = [];
            var cueClassLine = line.match(/::cue\(\.?(.*?)\)(?:,| {)/);

            while (Object(is_non_empty_string["a" /* default */])(line) && Array.isArray(cueClassLine)) {
              classNames.push(cueClassLine[1]);
              line = styleBlock[++index];
              cueClassLine = line.match(/::cue\(\.?(.*?)\)(?:,| {)/);
            }

            var styleContent = "";

            while (Object(is_non_empty_string["a" /* default */])(line) && !(Array.isArray(line.match(/}/)) || line.length === 0)) {
              styleContent += line;
              line = styleBlock[++index];
            }

            classNames.forEach(function (className) {
              var styleElement = classes[className];

              if (styleElement === undefined) {
                classes[className] = styleContent;
              } else {
                classes[className] += styleContent;
              }
            });
          })();
        }
      }
    }
  });
  return {
    classes: classes,
    global: global
  };
}
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(10);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_styled_element.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Construct an HTMLElement/TextNode representing the given node and apply
 * the right styling on it.
 * @param {Node} baseNode
 * @param {Array.<Object>} styleElements
 * @param {Array.<string>} styleClasses
 * @returns {Node}
 */

function createStyledElement(baseNode, styleElements) {
  var HTMLTags = ["u", "i", "b"];
  var authorizedNodeNames = ["u", "i", "b", "c", "#text"];
  var mainNodeName = baseNode.nodeName.toLowerCase().split(".")[0];
  var nodeWithStyle;

  if (Object(array_includes["a" /* default */])(authorizedNodeNames, mainNodeName)) {
    if (mainNodeName === "#text") {
      var linifiedText = baseNode.wholeText.split("\n");
      nodeWithStyle = document.createElement("span");

      for (var i = 0; i < linifiedText.length; i++) {
        if (i > 0) {
          nodeWithStyle.appendChild(document.createElement("br"));
        }

        if (linifiedText[i].length > 0) {
          var textNode = document.createTextNode(linifiedText[i]);
          nodeWithStyle.appendChild(textNode);
        }
      }
    } else {
      var nodeClasses = baseNode.nodeName.toLowerCase().split(".");
      var styleContents = [];
      nodeClasses.forEach(function (nodeClass) {
        if (Object(is_non_empty_string["a" /* default */])(styleElements[nodeClass])) {
          styleContents.push(styleElements[nodeClass]);
        }
      });

      if (styleContents.length !== 0) {
        // If style must be applied
        var attr = document.createAttribute("style");
        styleContents.forEach(function (styleContent) {
          attr.value += styleContent;
        });
        var nameClass = Object(array_includes["a" /* default */])(HTMLTags, mainNodeName) ? mainNodeName : "span";
        nodeWithStyle = document.createElement(nameClass);
        nodeWithStyle.setAttributeNode(attr);
      } else {
        // If style mustn't be applied. Rebuild element with tag name
        var elementTag = !Object(array_includes["a" /* default */])(HTMLTags, mainNodeName) ? "span" : mainNodeName;
        nodeWithStyle = document.createElement(elementTag);
      }

      for (var j = 0; j < baseNode.childNodes.length; j++) {
        var child = createStyledElement(baseNode.childNodes[j], styleElements);
        nodeWithStyle.appendChild(child);
      }
    }
  } else {
    nodeWithStyle = document.createElement("span");

    for (var _j = 0; _j < baseNode.childNodes.length; _j++) {
      var _child = createStyledElement(baseNode.childNodes[_j], styleElements);

      nodeWithStyle.appendChild(_child);
    }
  }

  return nodeWithStyle;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/convert_payload_to_html.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {string} text
 * @param {Array.<Object>} styleElements
 * @returns {Array.<HTMLElement>}
 */

function convertPayloadToHTML(text, styleElements) {
  var filteredText = text // Remove timestamp tags
  .replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, "") // Remove tag content or attributes (e.g. <b dfgfdg> => <b>)
  .replace(/<([u,i,b,c])(\..*?)?(?: .*?)?>(.*?)<\/\1>/g, "<$1$2>$3</$1$2>");
  var parsedWebVTT = new DOMParser().parseFromString(filteredText, "text/html");
  var nodes = parsedWebVTT.body.childNodes;
  var styledElements = [];

  for (var i = 0; i < nodes.length; i++) {
    styledElements.push(createStyledElement(nodes[i], styleElements));
  }

  return styledElements;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/to_html.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse cue block into an object with the following properties:
 *   - start {number}: start time at which the cue should be displayed
 *   - end {number}: end time at which the cue should be displayed
 *   - element {HTMLElement}: the cue text, translated into an HTMLElement
 *
 * Returns undefined if the cue block could not be parsed.
 * @param {Array.<string>} cueBlock
 * @param {Number} timeOffset
 * @param {Array.<Object>} classes
 * @returns {Object|undefined}
 */

function toHTML(cueObj, styling) {
  var start = cueObj.start,
      end = cueObj.end,
      header = cueObj.header,
      payload = cueObj.payload;
  var region = document.createElement("div");
  var regionAttr = document.createAttribute("style");
  regionAttr.value = "width:100%;" + "height:100%;" + "display:flex;" + "flex-direction:column;" + "justify-content:flex-end;" + "align-items:center;";
  region.setAttributeNode(regionAttr); // Get content, format and apply style.

  var pElement = document.createElement("p");
  var pAttr = document.createAttribute("style");
  pAttr.value = "text-align:center";
  pElement.setAttributeNode(pAttr);
  var spanElement = document.createElement("span");
  var attr = document.createAttribute("style"); // set color and background-color default values, as indicated in:
  // https://www.w3.org/TR/webvtt1/#applying-css-properties

  attr.value = "background-color:rgba(0,0,0,0.8);" + "color:white;";
  spanElement.setAttributeNode(attr);
  var global = styling.global,
      classes = styling.classes;
  var localStyle = Object(is_non_empty_string["a" /* default */])(header) ? classes[header] : undefined;
  var styles = [global, localStyle].filter(function (s) {
    return s !== undefined;
  }).join("");
  attr.value += styles;
  spanElement.setAttributeNode(attr);
  convertPayloadToHTML(payload.join("\n"), classes).forEach(function (element) {
    spanElement.appendChild(element);
  });
  region.appendChild(pElement);
  pElement.appendChild(spanElement);
  return {
    start: start,
    end: end,
    element: region
  };
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parse_webvtt_to_div.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Parse WebVTT from text. Returns an array with:
 * - start : start of current cue, in seconds
 * - end : end of current cue, in seconds
 * - content : HTML formatted cue.
 *
 * Global style is parsed and applied to div element.
 * Specific style is parsed and applied to class element.
 *
 * @throws Error - Throws if the given WebVTT string is invalid.
 * @param {string} text - The whole webvtt subtitles to parse
 * @param {Number} timeOffset - Offset to add to start and end times, in seconds
 * @return {Array.<Object>}
 */

function parseWebVTT(text, timeOffset) {
  var newLineChar = /\r\n|\n|\r/g; // CRLF|LF|CR

  var linified = text.split(newLineChar);
  var cuesArray = [];

  if (linified[0].match(/^WEBVTT( |\t|\n|\r|$)/) === null) {
    throw new Error("Can't parse WebVTT: Invalid File.");
  }

  var firstLineAfterHeader = Object(utils["b" /* getFirstLineAfterHeader */])(linified);
  var styleBlocks = getStyleBlocks(linified, firstLineAfterHeader);
  var cueBlocks = Object(get_cue_blocks["a" /* default */])(linified, firstLineAfterHeader);
  var styles = parseStyleBlocks(styleBlocks);

  for (var i = 0; i < cueBlocks.length; i++) {
    var cueObject = Object(parse_cue_block["a" /* default */])(cueBlocks[i], timeOffset);

    if (cueObject != null) {
      var htmlCue = toHTML(cueObject, styles);
      cuesArray.push(htmlCue);
    }
  }

  return cuesArray;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var html = __webpack_exports__["default"] = (parseWebVTT);

/***/ }),
/* 200 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(215);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(179);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(47);

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(11);

// EXTERNAL MODULE: ./src/manifest/index.ts + 5 modules
var src_manifest = __webpack_require__(66);

// EXTERNAL MODULE: ./src/manifest/adaptation.ts + 2 modules
var manifest_adaptation = __webpack_require__(67);

// EXTERNAL MODULE: ./src/manifest/representation_index/static.ts
var representation_index_static = __webpack_require__(220);

// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(57);

// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(7);

// CONCATENATED MODULE: ./src/parsers/manifest/metaplaylist/representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The MetaRepresentationIndex is wrapper for all kind of indexes (dash, smooth, etc)
 *
 * It wraps methods from origin indexes, while taking into account of the offset induced
 * by metaplaylist. It makes a bridge between the metaplaylist timeline, and the original
 * timeline of content. (e.g. the segment whose "meta" time is 1500, is actually a
 * segment whose original time is 200, played with an offset of 1300)
 */

var representation_index_MetaRepresentationIndex = /*#__PURE__*/function () {
  function MetaRepresentationIndex(wrappedIndex, contentBounds, transport, baseContentInfos) {
    this._wrappedIndex = wrappedIndex;
    this._timeOffset = contentBounds[0];
    this._contentEnd = contentBounds[1];
    this._transport = transport;
    this._baseContentInfos = baseContentInfos;
  }

  var _proto = MetaRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    var segment = this._wrappedIndex.getInitSegment();

    if (segment === null) {
      return null;
    }

    if (segment.privateInfos === undefined) {
      segment.privateInfos = {};
    }

    segment.privateInfos.metaplaylistInfos = {
      transportType: this._transport,
      baseContent: this._baseContentInfos,
      contentStart: this._timeOffset,
      contentEnd: this._contentEnd
    };
    return segment;
  };

  _proto.getSegments = function getSegments(up, duration) {
    var _this = this;

    return this._wrappedIndex.getSegments(up - this._timeOffset, duration).map(function (segment) {
      if (segment.privateInfos === undefined) {
        segment.privateInfos = {};
      }

      segment.privateInfos.metaplaylistInfos = {
        transportType: _this._transport,
        baseContent: _this._baseContentInfos,
        contentStart: _this._timeOffset,
        contentEnd: _this._contentEnd
      };
      segment.time += _this._timeOffset * segment.timescale;
      return segment;
    });
  };

  _proto.shouldRefresh = function shouldRefresh() {
    return false;
  };

  _proto.getFirstPosition = function getFirstPosition() {
    var wrappedFirstPosition = this._wrappedIndex.getFirstPosition();

    return wrappedFirstPosition != null ? wrappedFirstPosition + this._timeOffset : undefined;
  };

  _proto.getLastPosition = function getLastPosition() {
    var wrappedLastPosition = this._wrappedIndex.getLastPosition();

    return wrappedLastPosition != null ? wrappedLastPosition + this._timeOffset : undefined;
  };

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable(segment) {
    var offset = this._timeOffset * segment.timescale;
    var updatedSegment = Object(object_assign["a" /* default */])({}, segment, {
      time: segment.time - offset
    });
    return this._wrappedIndex.isSegmentStillAvailable(updatedSegment);
  }
  /**
   * @param {Error} error
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError(error) {
    return this._wrappedIndex.canBeOutOfSyncError(error);
  };

  _proto.checkDiscontinuity = function checkDiscontinuity(time) {
    return this._wrappedIndex.checkDiscontinuity(time - this._timeOffset);
  };

  _proto.isFinished = function isFinished() {
    return this._wrappedIndex.isFinished();
  };

  _proto._replace = function _replace(newIndex) {
    if (!(newIndex instanceof MetaRepresentationIndex)) {
      throw new Error("A MetaPlaylist can only be replaced with another MetaPlaylist");
    }

    this._wrappedIndex._replace(newIndex._wrappedIndex);
  };

  _proto._update = function _update(newIndex) {
    if (!(newIndex instanceof MetaRepresentationIndex)) {
      throw new Error("A MetaPlaylist can only be updated with another MetaPlaylist");
    }

    this._wrappedIndex._update(newIndex._wrappedIndex);
  };

  _proto._addSegments = function _addSegments(nextSegments, currentSegment) {
    return this._wrappedIndex._addSegments(nextSegments, currentSegment);
  };

  return MetaRepresentationIndex;
}();


// CONCATENATED MODULE: ./src/parsers/manifest/metaplaylist/metaplaylist_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse playlist string to JSON.
 * Returns an array of contents.
 * @param {string} data
 * @param {string} url
 * @returns {Object}
 */

function parseMetaPlaylist(data, parserOptions) {
  var parsedData;

  if (typeof data === "object" && data != null) {
    parsedData = data;
  } else if (typeof data === "string") {
    try {
      parsedData = JSON.parse(data);
    } catch (error) {
      throw new Error("MPL Parser: Bad MetaPlaylist file. Expected JSON.");
    }
  } else {
    throw new Error("MPL Parser: Parser input must be either a string " + "or the MetaPlaylist data directly.");
  }

  var _parsedData = parsedData,
      contents = _parsedData.contents,
      version = _parsedData.version,
      type = _parsedData.type;

  if (type !== "MPL") {
    throw new Error("MPL Parser: Bad MetaPlaylist. " + "The `type` property is not set to `MPL`");
  }

  if (version !== "0.1") {
    throw new Error("MPL Parser: Bad MetaPlaylist version");
  } // quick checks


  if (contents == null || contents.length === 0) {
    throw new Error("MPL Parser: No content found.");
  }

  var ressources = [];

  for (var i = 0; i < contents.length; i++) {
    var content = contents[i];

    if (content.url == null || content.startTime == null || content.endTime == null || content.transport == null) {
      throw new Error("MPL Parser: Malformed content.");
    }

    ressources.push({
      url: content.url,
      transportType: content.transport
    });
  }

  var metaPlaylist = parsedData;
  return {
    type: "needs-manifest-loader",
    value: {
      ressources: ressources,
      "continue": function parseWholeMPL(loadedRessources) {
        var parsedManifest = createManifest(metaPlaylist, loadedRessources, parserOptions);
        return {
          type: "done",
          value: parsedManifest
        };
      }
    }
  };
}
/**
 * From several parsed manifests, generate a single bigger manifest.
 * Each content presents a start and end time, so that periods
 * boudaries could be adapted.
 * @param {Object} mplData
 * @param {Array<Object>} manifest
 * @param {string} url
 * @returns {Object}
 */

function createManifest(mplData, manifests, parserOptions) {
  var url = parserOptions.url,
      serverSyncInfos = parserOptions.serverSyncInfos;
  var clockOffset = serverSyncInfos !== undefined ? serverSyncInfos.serverTimestamp - serverSyncInfos.clientTime : undefined;
  var generateAdaptationID = Object(id_generator["a" /* default */])();
  var generateRepresentationID = Object(id_generator["a" /* default */])();
  var contents = mplData.contents;
  var minimumTime = contents.length > 0 ? contents[0].startTime : 0;
  var maximumTime = contents.length > 0 ? contents[contents.length - 1].endTime : 0;
  var isDynamic = mplData.dynamic === true;
  var firstStart = null;
  var lastEnd = null;
  var periods = [];

  var _loop = function _loop(iMan) {
    var content = contents[iMan];
    firstStart = firstStart !== null ? Math.min(firstStart, content.startTime) : content.startTime;
    lastEnd = lastEnd !== null ? Math.max(lastEnd, content.endTime) : content.endTime;
    var currentManifest = manifests[iMan];

    if (currentManifest.periods.length <= 0) {
      return "continue";
    }

    var contentOffset = content.startTime - currentManifest.periods[0].start;
    var contentEnd = content.endTime;
    var manifestPeriods = [];

    var _loop2 = function _loop2(iPer) {
      var currentPeriod = currentManifest.periods[iPer];
      var adaptations = manifest_adaptation["a" /* SUPPORTED_ADAPTATIONS_TYPE */].reduce(function (acc, type) {
        var currentAdaptations = currentPeriod.adaptations[type];

        if (currentAdaptations == null) {
          return acc;
        }

        var adaptationsForCurrentType = [];

        for (var iAda = 0; iAda < currentAdaptations.length; iAda++) {
          var currentAdaptation = currentAdaptations[iAda];
          var representations = [];

          for (var iRep = 0; iRep < currentAdaptation.representations.length; iRep++) {
            var currentRepresentation = currentAdaptation.representations[iRep];
            var contentInfos = {
              manifest: currentManifest,
              period: currentPeriod,
              adaptation: currentAdaptation,
              representation: currentRepresentation
            };
            var newIndex = new representation_index_MetaRepresentationIndex(currentRepresentation.index, [contentOffset, contentEnd], content.transport, contentInfos);
            representations.push({
              bitrate: currentRepresentation.bitrate,
              index: newIndex,
              id: currentRepresentation.id,
              height: currentRepresentation.height,
              width: currentRepresentation.width,
              mimeType: currentRepresentation.mimeType,
              frameRate: currentRepresentation.frameRate,
              codecs: currentRepresentation.codec,
              contentProtections: currentRepresentation.contentProtections
            });
          }

          adaptationsForCurrentType.push({
            id: currentAdaptation.id,
            representations: representations,
            type: currentAdaptation.type,
            audioDescription: currentAdaptation.isAudioDescription,
            closedCaption: currentAdaptation.isClosedCaption,
            isDub: currentAdaptation.isDub,
            language: currentAdaptation.language
          });
          acc[type] = adaptationsForCurrentType;
        }

        return acc;
      }, {}); // TODO only first period?

      var textTracks = content.textTracks === undefined ? [] : content.textTracks;
      var newTextAdaptations = textTracks.map(function (track) {
        var adaptationID = "gen-text-ada-" + generateAdaptationID();
        var representationID = "gen-text-rep-" + generateRepresentationID();
        return {
          id: adaptationID,
          type: "text",
          language: track.language,
          closedCaption: track.closedCaption,
          manuallyAdded: true,
          representations: [{
            bitrate: 0,
            id: representationID,
            mimeType: track.mimeType,
            codecs: track.codecs,
            index: new representation_index_static["a" /* default */]({
              media: track.url
            })
          }]
        };
      }, []);

      if (newTextAdaptations.length > 0) {
        if (adaptations.text == null) {
          adaptations.text = newTextAdaptations;
        } else {
          var _adaptations$text;

          (_adaptations$text = adaptations.text).push.apply(_adaptations$text, newTextAdaptations);
        }
      }

      var newPeriod = {
        id: formatId(currentManifest.id) + "_" + formatId(currentPeriod.id),
        adaptations: adaptations,
        duration: currentPeriod.duration,
        start: contentOffset + currentPeriod.start
      };
      manifestPeriods.push(newPeriod);
    };

    for (var iPer = 0; iPer < currentManifest.periods.length; iPer++) {
      _loop2(iPer);
    }

    for (var i = manifestPeriods.length - 1; i >= 0; i--) {
      var period = manifestPeriods[i];

      if (period.start >= content.endTime) {
        manifestPeriods.splice(i, 1);
      } else if (period.duration != null) {
        if (period.start + period.duration > content.endTime) {
          period.duration = content.endTime - period.start;
        }
      } else if (i === manifestPeriods.length - 1) {
        period.duration = content.endTime - period.start;
      }
    }

    periods.push.apply(periods, manifestPeriods);
  };

  for (var iMan = 0; iMan < contents.length; iMan++) {
    var _ret = _loop(iMan);

    if (_ret === "continue") continue;
  }

  var time = performance.now();
  var manifest = {
    availabilityStartTime: 0,
    clockOffset: clockOffset,
    suggestedPresentationDelay: 10,
    periods: periods,
    transportType: "metaplaylist",
    isLive: isDynamic,
    isDynamic: isDynamic,
    uris: url == null ? [] : [url],
    maximumTime: {
      isContinuous: false,
      value: maximumTime,
      time: time
    },
    minimumTime: {
      isContinuous: false,
      value: minimumTime,
      time: time
    },
    lifetime: mplData.pollInterval
  };
  return manifest;
}

function formatId(str) {
  return str.replace(/_/g, "\_");
}
// CONCATENATED MODULE: ./src/parsers/manifest/metaplaylist/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ var metaplaylist = (parseMetaPlaylist);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(9);

// EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
var request = __webpack_require__(24);

// EXTERNAL MODULE: ./src/transports/utils/call_custom_manifest_loader.ts
var call_custom_manifest_loader = __webpack_require__(116);

// CONCATENATED MODULE: ./src/transports/metaplaylist/manifest_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 */

function regularManifestLoader(_ref) {
  var url = _ref.url;

  if (url === undefined) {
    throw new Error("Cannot perform HTTP(s) request. URL not known");
  }

  return Object(request["a" /* default */])({
    url: url,
    responseType: "text"
  });
}
/**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */


function generateManifestLoader(options) {
  var customManifestLoader = options.customManifestLoader;

  if (typeof customManifestLoader !== "function") {
    return regularManifestLoader;
  }

  return Object(call_custom_manifest_loader["a" /* default */])(customManifestLoader, regularManifestLoader);
}
// CONCATENATED MODULE: ./src/transports/metaplaylist/pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * @param {Object} segment
 * @param {number} offset
 * @returns {Object}
 */

function getContent(segment, offset) {
  var _a;

  if (((_a = segment.privateInfos) === null || _a === void 0 ? void 0 : _a.metaplaylistInfos) === undefined) {
    throw new Error("MetaPlaylist: missing private infos");
  }

  var _segment$privateInfos = segment.privateInfos.metaplaylistInfos.baseContent,
      manifest = _segment$privateInfos.manifest,
      period = _segment$privateInfos.period,
      adaptation = _segment$privateInfos.adaptation,
      representation = _segment$privateInfos.representation;
  var newTime = segment.time < 0 ? segment.time : segment.time - offset * segment.timescale;
  var offsetedSegment = Object(object_assign["a" /* default */])({}, segment, {
    time: newTime
  });
  return {
    manifest: manifest,
    period: period,
    adaptation: adaptation,
    representation: representation,
    segment: offsetedSegment
  };
}
/**
 * Prepare any wrapped segment loader's arguments.
 * @param {Object} segment
 * @param {number} offset
 * @returns {Object}
 */


function getLoaderArguments(segment, url, offset) {
  var content = getContent(segment, offset);
  return Object(object_assign["a" /* default */])({
    url: url
  }, content);
}
/**
 * Prepare any wrapped segment parser's arguments.
 * @param {Object} arguments
 * @param {Object} segment
 * @param {number} offset
 * @returns {Object}
 */


function getParserArguments(_ref, segment, offset) {
  var initTimescale = _ref.initTimescale,
      response = _ref.response;
  return {
    initTimescale: initTimescale,
    response: response,
    content: getContent(segment, offset)
  };
}
/**
 * @param {Object} transports
 * @param {string} transportName
 * @param {Object} options
 * @returns {Object}
 */


function getTransportPipelines(transports, transportName, options) {
  var initialTransport = transports[transportName];

  if (initialTransport !== undefined) {
    return initialTransport;
  }

  var feature = features["a" /* default */].transports[transportName];

  if (feature === undefined) {
    throw new Error("MetaPlaylist: Unknown transport " + transportName + ".");
  }

  var transport = feature(options);
  transports[transportName] = transport;
  return transport;
}
/**
 * @param {Object} segment
 * @returns {Object}
 */


function getMetaPlaylistPrivateInfos(segment) {
  var privateInfos = segment.privateInfos;

  if ((privateInfos === null || privateInfos === void 0 ? void 0 : privateInfos.metaplaylistInfos) === undefined) {
    throw new Error("MetaPlaylist: Undefined transport for content for metaplaylist.");
  }

  return privateInfos.metaplaylistInfos;
}

/* harmony default export */ var pipelines = (function (options) {
  var transports = {};
  var manifestLoader = generateManifestLoader({
    customManifestLoader: options.manifestLoader
  }); // remove some options that we might not want to apply to the
  // other streaming protocols used here

  var otherTransportOptions = Object(object_assign["a" /* default */])({}, options, {
    manifestLoader: undefined,
    supplementaryTextTracks: [],
    supplementaryImageTracks: []
  });
  var manifestPipeline = {
    loader: manifestLoader,
    parser: function parser(_ref2) {
      var response = _ref2.response,
          loaderURL = _ref2.url,
          scheduleRequest = _ref2.scheduleRequest,
          externalClockOffset = _ref2.externalClockOffset;
      var url = response.url === undefined ? loaderURL : response.url;
      var responseData = response.responseData;
      var parserOptions = {
        url: url,
        serverSyncInfos: options.serverSyncInfos
      };
      return handleParsedResult(metaplaylist(responseData, parserOptions));

      function handleParsedResult(parsedResult) {
        if (parsedResult.type === "done") {
          var manifest = new src_manifest["a" /* default */](parsedResult.value, options);
          return Object(of["a" /* of */])({
            manifest: manifest
          });
        }

        var loaders$ = parsedResult.value.ressources.map(function (ressource) {
          var transport = getTransportPipelines(transports, ressource.transportType, otherTransportOptions);
          var request$ = scheduleRequest(function () {
            return transport.manifest.loader({
              url: ressource.url
            }).pipe(Object(filter["a" /* filter */])(function (e) {
              return e.type === "data-loaded";
            }), Object(map["a" /* map */])(function (e) {
              return e.value;
            }));
          });
          return request$.pipe(Object(mergeMap["a" /* mergeMap */])(function (responseValue) {
            return transport.manifest.parser({
              response: responseValue,
              url: ressource.url,
              scheduleRequest: scheduleRequest,
              externalClockOffset: externalClockOffset
            }).pipe(Object(map["a" /* map */])(function (parserData) {
              return parserData.manifest;
            }));
          }));
        });
        return Object(combineLatest["a" /* combineLatest */])(loaders$).pipe(Object(mergeMap["a" /* mergeMap */])(function (loadedRessources) {
          return handleParsedResult(parsedResult.value["continue"](loadedRessources));
        }));
      }
    }
  };
  /**
   * @param {Object} segment
   * @param {Object} transports
   * @returns {Object}
   */

  function getTransportPipelinesFromSegment(segment) {
    var _getMetaPlaylistPriva = getMetaPlaylistPrivateInfos(segment),
        transportType = _getMetaPlaylistPriva.transportType;

    return getTransportPipelines(transports, transportType, otherTransportOptions);
  }
  /**
   * @param {number} contentOffset
   * @param {number} scaledContentOffset
   * @param {number|undefined} contentEnd
   * @param {Object} segmentResponse
   * @returns {Object}
   */


  function offsetTimeInfos(contentOffset, scaledContentOffset, contentEnd, segmentResponse) {
    var offsetedSegmentOffset = segmentResponse.chunkOffset + contentOffset;

    if (Object(is_null_or_undefined["a" /* default */])(segmentResponse.chunkData)) {
      return {
        chunkInfos: segmentResponse.chunkInfos,
        chunkOffset: offsetedSegmentOffset,
        appendWindow: [undefined, undefined]
      };
    } // clone chunkInfos


    var chunkInfos = segmentResponse.chunkInfos,
        appendWindow = segmentResponse.appendWindow;
    var offsetedChunkInfos = chunkInfos === null ? null : Object(object_assign["a" /* default */])({}, chunkInfos);

    if (offsetedChunkInfos !== null && offsetedChunkInfos.time > -1) {
      offsetedChunkInfos.time += scaledContentOffset;
    }

    var offsetedWindowStart = appendWindow[0] !== undefined ? Math.max(appendWindow[0] + contentOffset, contentOffset) : contentOffset;
    var offsetedWindowEnd;

    if (appendWindow[1] !== undefined) {
      offsetedWindowEnd = contentEnd !== undefined ? Math.min(appendWindow[1] + contentOffset, contentEnd) : appendWindow[1] + contentOffset;
    } else if (contentEnd !== undefined) {
      offsetedWindowEnd = contentEnd;
    }

    return {
      chunkInfos: offsetedChunkInfos,
      chunkOffset: offsetedSegmentOffset,
      appendWindow: [offsetedWindowStart, offsetedWindowEnd]
    };
  }

  var audioPipeline = {
    loader: function loader(_ref3) {
      var segment = _ref3.segment,
          period = _ref3.period,
          url = _ref3.url;

      var _getTransportPipeline = getTransportPipelinesFromSegment(segment),
          audio = _getTransportPipeline.audio;

      return audio.loader(getLoaderArguments(segment, url, period.start));
    },
    parser: function parser(args) {
      var initTimescale = args.initTimescale,
          content = args.content;
      var segment = content.segment;

      var _getMetaPlaylistPriva2 = getMetaPlaylistPrivateInfos(segment),
          contentStart = _getMetaPlaylistPriva2.contentStart,
          contentEnd = _getMetaPlaylistPriva2.contentEnd;

      var scaledOffset = contentStart * (initTimescale !== null && initTimescale !== void 0 ? initTimescale : segment.timescale);

      var _getTransportPipeline2 = getTransportPipelinesFromSegment(segment),
          audio = _getTransportPipeline2.audio;

      return audio.parser(getParserArguments(args, segment, contentStart)).pipe(Object(map["a" /* map */])(function (res) {
        if (res.type === "parsed-init-segment") {
          return res;
        }

        var timeInfos = offsetTimeInfos(contentStart, scaledOffset, contentEnd, res.value);
        return Object(object_assign["a" /* default */])({
          type: "parsed-segment",
          value: Object(object_assign["a" /* default */])({}, res.value, timeInfos)
        });
      }));
    }
  };
  var videoPipeline = {
    loader: function loader(_ref4) {
      var segment = _ref4.segment,
          period = _ref4.period,
          url = _ref4.url;

      var _getTransportPipeline3 = getTransportPipelinesFromSegment(segment),
          video = _getTransportPipeline3.video;

      return video.loader(getLoaderArguments(segment, url, period.start));
    },
    parser: function parser(args) {
      var initTimescale = args.initTimescale,
          content = args.content;
      var segment = content.segment;

      var _getMetaPlaylistPriva3 = getMetaPlaylistPrivateInfos(segment),
          contentStart = _getMetaPlaylistPriva3.contentStart,
          contentEnd = _getMetaPlaylistPriva3.contentEnd;

      var scaledOffset = contentStart * (initTimescale !== null && initTimescale !== void 0 ? initTimescale : segment.timescale);

      var _getTransportPipeline4 = getTransportPipelinesFromSegment(segment),
          video = _getTransportPipeline4.video;

      return video.parser(getParserArguments(args, segment, contentStart)).pipe(Object(map["a" /* map */])(function (res) {
        if (res.type === "parsed-init-segment") {
          return res;
        }

        var timeInfos = offsetTimeInfos(contentStart, scaledOffset, contentEnd, res.value);
        return Object(object_assign["a" /* default */])({
          type: "parsed-segment",
          value: Object(object_assign["a" /* default */])({}, res.value, timeInfos)
        });
      }));
    }
  };
  var textTrackPipeline = {
    loader: function loader(_ref5) {
      var segment = _ref5.segment,
          period = _ref5.period,
          url = _ref5.url;

      var _getTransportPipeline5 = getTransportPipelinesFromSegment(segment),
          text = _getTransportPipeline5.text;

      return text.loader(getLoaderArguments(segment, url, period.start));
    },
    parser: function parser(args) {
      var initTimescale = args.initTimescale,
          content = args.content;
      var segment = content.segment;

      var _getMetaPlaylistPriva4 = getMetaPlaylistPrivateInfos(segment),
          contentStart = _getMetaPlaylistPriva4.contentStart,
          contentEnd = _getMetaPlaylistPriva4.contentEnd;

      var scaledOffset = contentStart * (initTimescale !== null && initTimescale !== void 0 ? initTimescale : segment.timescale);

      var _getTransportPipeline6 = getTransportPipelinesFromSegment(segment),
          text = _getTransportPipeline6.text;

      return text.parser(getParserArguments(args, segment, contentStart)).pipe(Object(map["a" /* map */])(function (res) {
        if (res.type === "parsed-init-segment") {
          return res;
        }

        var timeInfos = offsetTimeInfos(contentStart, scaledOffset, contentEnd, res.value);
        return Object(object_assign["a" /* default */])({
          type: "parsed-segment",
          value: Object(object_assign["a" /* default */])({}, res.value, timeInfos)
        });
      }));
    }
  };
  var imageTrackPipeline = {
    loader: function loader(_ref6) {
      var segment = _ref6.segment,
          period = _ref6.period,
          url = _ref6.url;

      var _getTransportPipeline7 = getTransportPipelinesFromSegment(segment),
          image = _getTransportPipeline7.image;

      return image.loader(getLoaderArguments(segment, url, period.start));
    },
    parser: function parser(args) {
      var initTimescale = args.initTimescale,
          content = args.content;
      var segment = content.segment;

      var _getMetaPlaylistPriva5 = getMetaPlaylistPrivateInfos(segment),
          contentStart = _getMetaPlaylistPriva5.contentStart,
          contentEnd = _getMetaPlaylistPriva5.contentEnd;

      var scaledOffset = contentStart * (initTimescale !== null && initTimescale !== void 0 ? initTimescale : segment.timescale);

      var _getTransportPipeline8 = getTransportPipelinesFromSegment(segment),
          image = _getTransportPipeline8.image;

      return image.parser(getParserArguments(args, segment, contentStart)).pipe(Object(map["a" /* map */])(function (res) {
        if (res.type === "parsed-init-segment") {
          return res;
        }

        var timeInfos = offsetTimeInfos(contentStart, scaledOffset, contentEnd, res.value);
        return Object(object_assign["a" /* default */])({
          type: "parsed-segment",
          value: Object(object_assign["a" /* default */])({}, res.value, timeInfos)
        });
      }));
    }
  };
  return {
    manifest: manifestPipeline,
    audio: audioPipeline,
    video: videoPipeline,
    text: textTrackPipeline,
    image: imageTrackPipeline
  };
});
// CONCATENATED MODULE: ./src/transports/metaplaylist/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var transports_metaplaylist = __webpack_exports__["default"] = (pipelines);

/***/ }),
/* 201 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(88);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
var interval = __webpack_require__(207);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(135);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
var startWith = __webpack_require__(175);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
var switchMapTo = __webpack_require__(223);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(176);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(177);

// EXTERNAL MODULE: ./src/compat/index.ts + 1 modules
var compat = __webpack_require__(8);

// EXTERNAL MODULE: ./src/compat/on_height_width_change.ts
var on_height_width_change = __webpack_require__(161);

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(3);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/custom_source_buffers/abstract_source_buffer.ts + 1 modules
var abstract_source_buffer = __webpack_require__(84);

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(11);

// CONCATENATED MODULE: ./src/custom_source_buffers/text/html/parsers.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Convert text track data into timed HTML Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<Object>}
 * @throws Error - Throw if no parser is found for the given type
 */

function parseTextTrackToElements(type, data, timestampOffset, language) {
  log["a" /* default */].debug("HTSB: Finding parser for html text tracks:", type);
  var parser = features["a" /* default */].htmlTextTracksParsers[type];

  if (typeof parser !== "function") {
    throw new Error("no parser found for the given text track");
  }

  log["a" /* default */].debug("HTSB: Parser found, parsing...");
  var parsed = parser(data, timestampOffset, language);
  log["a" /* default */].debug("HTTB: Parsed successfully!", parsed);
  return parsed;
}
// CONCATENATED MODULE: ./src/custom_source_buffers/text/html/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Maximum time difference, in seconds, between two text segment's start times
 * and/or end times for them to be considered the same in the custom text's
 * SourceBuffer used for the "html" textTrackMode.
 *
 * For example for two segments s1 and s2 which have a start time respectively
 * of st1 and st2 and end time of et1 and et2:
 *   - if both the absolute difference between st1 and st2 AND the one between
 *     et1 and et2 is inferior or equal to the MAX_DELTA_BUFFER_TIME, s1 and s2
 *     are considered to target the exact same time. As a consequence, if s2 is
 *     added after s1 in the SourceBuffer, s1 will be completely replaced by
 *     it and vice-versa.
 *   - if only one of the two (absolute difference between st1 and st2 OR et1
 *     and et2) is inferior to the MAX_DELTA_BUFFER_TIME then the last added
 *     is not completely considered the same. It WILL still replace - either
 *     partially or completely (depending on the sign of the other difference) -
 *     the previously added segment.
 *   - if both differences are strictly superior to the MAX_DELTA_BUFFER_TIME,
 *     then they are not considered to have the same start nor the same end.
 *     They can still overlap however, and MIGHT thus still replace partially
 *     or completely each other.
 *
 * Setting a value too low might lead to two segments targeting the same time,
 * both being present in the SourceBuffer. In worst case scenarios, this could
 * lead to indicate that an unwanted text track is still here (theorically
 * though, this is a case that should never happen for reasons that might be too
 * long to explain here).
 *
 * Setting a value too high might lead to two segments targeting different times
 * to be wrongly believed to target the same time. In worst case scenarios, this
 * could lead to wanted text tracks being removed.
 * @type Number
 */
var MAX_DELTA_BUFFER_TIME = 0.2;
/**
 * @see MAX_DELTA_BUFFER_TIME
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */

function areNearlyEqual(a, b) {
  return Math.abs(a - b) <= MAX_DELTA_BUFFER_TIME;
}
/**
 * Get all cues which have data before the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */

function getCuesBefore(cues, time) {
  for (var i = cues.length - 1; i >= 0; i--) {
    var cue = cues[i];

    if (cue.start < time) {
      return cues.slice(0, i + 1);
    }
  }

  return [];
}
/**
 * Get all cues which have data after the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */

function getCuesAfter(cues, time) {
  for (var i = 0; i < cues.length; i++) {
    var cue = cues[i];

    if (cue.end > time) {
      return cues.slice(i, cues.length);
    }
  }

  return [];
}
/**
 * @param {Object} cuesInfos
 * @param {Number} start
 * @param {Number} end
 * @returns {Array.<Object>}
 */

function removeCuesInfosBetween(cuesInfos, start, end) {
  var endCuesInfos1 = Math.max(cuesInfos.start, start);
  var cues1 = getCuesBefore(cuesInfos.cues, start);
  var cuesInfos1 = {
    start: cuesInfos.start,
    end: endCuesInfos1,
    cues: cues1
  };
  var startCuesInfos2 = Math.min(end, cuesInfos.end);
  var cues2 = getCuesAfter(cuesInfos.cues, end);
  var cuesInfos2 = {
    start: startCuesInfos2,
    end: cuesInfos.end,
    cues: cues2
  };
  return [cuesInfos1, cuesInfos2];
}
// CONCATENATED MODULE: ./src/custom_source_buffers/text/html/text_track_cues_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Manage the buffer of the HTML text Sourcebuffer.
 * Allows to add, remove and recuperate cues at given times.
 * @class TextTrackCuesStore
 */

var text_track_cues_store_TextTrackCuesStore = /*#__PURE__*/function () {
  function TextTrackCuesStore() {
    this._cuesBuffer = [];
  }
  /**
   * Get corresponding cue for the given time.
   * A cue is an object with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * We do not mutate individual cue here.
   * That is, if the ``get`` method returns the same cue's reference than a
   * previous ``get`` call, its properties are guaranteed to have the exact same
   * values than before, if you did not mutate it on your side.
   * The inverse is true, if the values are the same than before, the reference
   * will stay the same (this is useful to easily check if the DOM should be
   * updated, for example).
   *
   * @param {Number} time
   * @returns {HTMLElement|undefined} - The cue to display
   */


  var _proto = TextTrackCuesStore.prototype;

  _proto.get = function get(time) {
    var cuesBuffer = this._cuesBuffer; // begins at the end as most of the time the player will ask for the last
    // CuesGroup

    for (var i = cuesBuffer.length - 1; i >= 0; i--) {
      var cues = cuesBuffer[i].cues;

      for (var j = cues.length - 1; j >= 0; j--) {
        var cue = cues[j];

        if (time >= cue.start) {
          if (time < cue.end) {
            return cue;
          } else {
            return undefined;
          }
        }
      }
    }

    return undefined;
  }
  /**
   * Remove cue from a certain range of time.
   * @param {Number} from
   * @param {Number} to
   */
  ;

  _proto.remove = function remove(from, _to) {
    if (false) {}

    var to = Math.max(from, _to);
    var cuesBuffer = this._cuesBuffer;

    for (var i = 0; i < cuesBuffer.length; i++) {
      if (cuesBuffer[i].end > from) {
        // this cuesInfos is concerned by the remove
        var startCuesInfos = cuesBuffer[i];

        if (startCuesInfos.start >= to) {
          // our cuesInfos is strictly after this interval, we have nothing to do
          return;
        }

        if (startCuesInfos.end >= to) {
          // our cuesInfos ends after `to`, we have to keep the end of it
          if (from <= startCuesInfos.start) {
            // from -> to only remove the start of startCuesInfos
            startCuesInfos.cues = getCuesAfter(startCuesInfos.cues, to);
            startCuesInfos.start = to;
          } else {
            // from -> to is in the middle part of startCuesInfos
            var _removeCuesInfosBetwe = removeCuesInfosBetween(startCuesInfos, from, to),
                cuesInfos1 = _removeCuesInfosBetwe[0],
                cuesInfos2 = _removeCuesInfosBetwe[1];

            this._cuesBuffer[i] = cuesInfos1;
            cuesBuffer.splice(i + 1, 0, cuesInfos2);
          } // No cuesInfos can be concerned after this one, we can quit


          return;
        } // Else remove all part after `from`


        if (startCuesInfos.start >= from) {
          // all the segment is concerned
          cuesBuffer.splice(i, 1);
          i--; // one less element, we have to decrement the loop
        } else {
          // only the end is concerned
          startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from);
          startCuesInfos.end = Math.max(from, startCuesInfos.start);
        }
      }
    }
  }
  /**
   * Insert new cues in our text buffer.
   * cues is an array of objects with three properties:
   *   - start {Number}: start time for which the cue should be displayed.
   *   - end {Number}: end time for which the cue should be displayed.
   *   - element {HTMLElement}: The cue to diplay
   *
   * @param {Array.<Object>} cues - CuesGroups, array of objects with the
   * following properties:
   *   - start {Number}: the time at which the cue will start to be displayed
   *   - end {Number}: the time at which the cue will end to be displayed
   *   - cue {HTMLElement}: The cue
   * @param {Number} start - Start time at which the CuesGroup applies.
   * This is different than the start of the first cue to display in it, this
   * has more to do with the time at which the _text segment_ starts.
   * @param {Number} end - End time at which the CuesGroup applies.
   * This is different than the end of the last cue to display in it, this
   * has more to do with the time at which the _text segment_ ends.
   *
   * TODO add securities to ensure that:
   *   - the start of a CuesGroup is inferior or equal to the start of the first
   *     cue in it
   *   - the end of a CuesGroup is superior or equal to the end of the last
   *     cue in it
   * If those requirements are not met, we could delete some cues when adding
   * a CuesGroup before/after. Find a solution.
   */
  ;

  _proto.insert = function insert(cues, start, end) {
    var cuesBuffer = this._cuesBuffer;
    var cuesInfosToInsert = {
      start: start,
      end: end,
      cues: cues
    };
    /**
     * Called when we found the index of the next cue relative to the cue we
     * want to insert (that is a cue starting after its start or at the same
     * time but ending strictly after its end).
     * Will insert the cue at the right place and update the next cue
     * accordingly.
     * @param {number} indexOfNextCue
     */

    function onIndexOfNextCueFound(indexOfNextCue) {
      var nextCue = cuesBuffer[indexOfNextCue];

      if (nextCue === undefined || // no cue
      areNearlyEqual(cuesInfosToInsert.end, nextCue.end)) // samey end
        {
          //   ours:            |AAAAA|
          //   the current one: |BBBBB|
          //   Result:          |AAAAA|
          cuesBuffer[indexOfNextCue] = cuesInfosToInsert;
        } else if (nextCue.start >= cuesInfosToInsert.end) {
        // Either
        //   ours:            |AAAAA|
        //   the current one:         |BBBBBB|
        //   Result:          |AAAAA| |BBBBBB|
        // Or:
        //   ours:            |AAAAA|
        //   the current one:       |BBBBBB|
        //   Result:          |AAAAA|BBBBBB|
        // Add ours before
        cuesBuffer.splice(indexOfNextCue, 0, cuesInfosToInsert);
      } else {
        // Either
        //   ours:            |AAAAA|
        //   the current one: |BBBBBBBB|
        //   Result:          |AAAAABBB|
        // Or:
        //   ours:            |AAAAA|
        //   the current one:    |BBBBB|
        //   Result:          |AAAAABBB|
        nextCue.cues = getCuesAfter(nextCue.cues, cuesInfosToInsert.end);
        nextCue.start = cuesInfosToInsert.end;
        cuesBuffer.splice(indexOfNextCue, 0, cuesInfosToInsert);
      }
    }

    for (var i = 0; i < cuesBuffer.length; i++) {
      var cuesInfos = cuesBuffer[i];

      if (start < cuesInfos.end) {
        if (areNearlyEqual(start, cuesInfos.start)) {
          if (areNearlyEqual(end, cuesInfos.end)) {
            // exact same segment
            //   ours:            |AAAAA|
            //   the current one: |BBBBB|
            //   Result:          |AAAAA|
            // Which means:
            //   1. replace the current cue with ours
            cuesBuffer[i] = cuesInfosToInsert;
            return;
          } else if (end < cuesInfos.end) {
            // our cue overlaps with the current one:
            //   ours:            |AAAAA|
            //   the current one: |BBBBBBBB|
            //   Result:          |AAAAABBB|
            // Which means:
            //   1. remove some cues at the start of the current one
            //   2. update start of current one
            //   3. add ours before the current one
            cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
            cuesInfos.start = end;
            cuesBuffer.splice(i, 0, cuesInfosToInsert);
            return;
          } // our cue goes beyond the current one:
          //   ours:            |AAAAAAA|
          //   the current one: |BBBB|...
          //   Result:          |AAAAAAA|
          // Here we have to delete any cuesInfos which end before ours end,
          // and see about the following one.


          do {
            cuesBuffer.splice(i, 1);
            cuesInfos = cuesBuffer[i];
          } while (cuesInfos !== undefined && end > cuesInfos.end);

          onIndexOfNextCueFound(i);
          return;
        } else if (start < cuesInfos.start) {
          if (end < cuesInfos.start) {
            // our cue goes strictly before the current one:
            //   ours:            |AAAAAAA|
            //   the current one:           |BBBB|
            //   Result:          |AAAAAAA| |BBBB|
            // Which means:
            //   - add ours before the current one
            cuesBuffer.splice(i, 0, cuesInfosToInsert);
            return;
          } else if (areNearlyEqual(end, cuesInfos.start)) {
            // our cue goes just before the current one:
            //   ours:            |AAAAAAA|
            //   the current one:         |BBBB|
            //   Result:          |AAAAAAA|BBBB|
            // Which means:
            //   - update start time of the current one to be sure
            //   - add ours before the current one
            cuesInfos.start = end;
            cuesBuffer.splice(i, 0, cuesInfosToInsert);
            return;
          } else if (areNearlyEqual(end, cuesInfos.end)) {
            //   ours:            |AAAAAAA|
            //   the current one:    |BBBB|
            //   Result:          |AAAAAAA|
            // Replace
            cuesBuffer.splice(i, 1, cuesInfosToInsert);
            return;
          } else if (end < cuesInfos.end) {
            //   ours:            |AAAAAAA|
            //   the current one:     |BBBBB|
            //   Result:          |AAAAAAABB|
            cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
            cuesInfos.start = end;
            cuesBuffer.splice(i, 0, cuesInfosToInsert);
            return;
          } //   ours:            |AAAAAAA|
          //   the current one:   |BBB|...
          //   Result:          |AAAAAAA|...


          do {
            cuesBuffer.splice(i, 1);
            cuesInfos = cuesBuffer[i];
          } while (cuesInfos !== undefined && end > cuesInfos.end);

          onIndexOfNextCueFound(i);
          return;
        } // else -> start > cuesInfos.start


        if (areNearlyEqual(cuesInfos.end, end)) {
          //   ours:              |AAAAAA|
          //   the current one: |BBBBBBBB|
          //   Result:          |BBAAAAAA|
          cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
          cuesInfos.end = start;
          cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
          return;
        } else if (cuesInfos.end > end) {
          //   ours:              |AAAAAA|
          //   the current one: |BBBBBBBBBBB|
          //   Result:          |BBAAAAAABBB|
          var _removeCuesInfosBetwe2 = removeCuesInfosBetween(cuesInfos, start, end),
              cuesInfos1 = _removeCuesInfosBetwe2[0],
              cuesInfos2 = _removeCuesInfosBetwe2[1];

          this._cuesBuffer[i] = cuesInfos1;
          cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
          cuesBuffer.splice(i + 2, 0, cuesInfos2);
          return;
        } else {
          //   ours:              |AAAAAA|
          //   the current one: |BBBBB|...
          //   Result:          |BBAAAAAA|...
          cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
          cuesInfos.end = start;
          cuesInfos = cuesBuffer[i + 1];

          while (cuesInfos !== undefined && end > cuesInfos.end) {
            cuesBuffer.splice(i, 1);
            cuesInfos = cuesBuffer[i];
          }

          onIndexOfNextCueFound(i);
          return;
        }
      }
    } // no cues group has the end after our current start.
    // These cues should be the last one


    cuesBuffer.push(cuesInfosToInsert);
  };

  return TextTrackCuesStore;
}();


// CONCATENATED MODULE: ./src/custom_source_buffers/text/html/update_proportional_elements.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Update size of element which are proportional to the current text track
 * element.
 * Returns `true` if at least a single styling information is proportional,
 * `false` otherwise.
 * @param {number} currentHeight
 * @param {number} currentWidth
 * @param {Object} resolution
 * @param {HTMLElement} textTrackElement
 * @returns {boolean}
 */
function updateProportionalElements(currentHeight, currentWidth, resolution, textTrackElement) {
  var cellUnit = [currentWidth / resolution.columns, currentHeight / resolution.rows];
  var proportElts = textTrackElement.getElementsByClassName("proportional-style");

  for (var eltIdx = 0; eltIdx < proportElts.length; eltIdx++) {
    var elt = proportElts[eltIdx];

    if (elt instanceof HTMLElement) {
      var fontSizeVal = elt.getAttribute("data-proportional-font-size");

      if (fontSizeVal !== null && !isNaN(+fontSizeVal)) {
        elt.style.fontSize = String(+fontSizeVal * cellUnit[1]) + "px";
      }

      var widthVal = elt.getAttribute("data-proportional-width");

      if (widthVal !== null && !isNaN(+widthVal)) {
        elt.style.width = String(+widthVal * cellUnit[0]) + "px";
      }

      var heightVal = elt.getAttribute("data-proportional-height");

      if (heightVal !== null && !isNaN(+heightVal)) {
        elt.style.height = String(+heightVal * cellUnit[1]) + "px";
      }

      var lineHeightVal = elt.getAttribute("data-proportional-line-height");

      if (lineHeightVal !== null && !isNaN(+lineHeightVal)) {
        elt.style.lineHeight = String(+lineHeightVal * cellUnit[1]) + "px";
      }

      var leftVal = elt.getAttribute("data-proportional-left");

      if (leftVal !== null && !isNaN(+leftVal)) {
        elt.style.left = String(+leftVal * cellUnit[0]) + "px";
      }

      var topVal = elt.getAttribute("data-proportional-top");

      if (topVal !== null && !isNaN(+topVal)) {
        elt.style.top = String(+topVal * cellUnit[1]) + "px";
      }

      var paddingTopVal = elt.getAttribute("data-proportional-padding-top");

      if (paddingTopVal !== null && !isNaN(+paddingTopVal)) {
        elt.style.paddingTop = String(+paddingTopVal * cellUnit[1]) + "px";
      }

      var paddingBottomVal = elt.getAttribute("data-proportional-padding-bottom");

      if (paddingBottomVal !== null && !isNaN(+paddingBottomVal)) {
        elt.style.paddingBottom = String(+paddingBottomVal * cellUnit[1]) + "px";
      }

      var paddingLeftVal = elt.getAttribute("data-proportional-padding-left");

      if (paddingLeftVal !== null && !isNaN(+paddingLeftVal)) {
        elt.style.paddingLeft = String(+paddingLeftVal * cellUnit[0]) + "px";
      }

      var paddingRightVal = elt.getAttribute("data-proportional-padding-right");

      if (paddingRightVal !== null && !isNaN(+paddingRightVal)) {
        elt.style.paddingRight = String(+paddingRightVal * cellUnit[0]) + "px";
      }
    }
  }

  return proportElts.length > 0;
}
// CONCATENATED MODULE: ./src/custom_source_buffers/text/html/html_text_source_buffer.ts
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









var onEnded$ = compat["a" /* events */].onEnded$,
    onSeeked$ = compat["a" /* events */].onSeeked$,
    onSeeking$ = compat["a" /* events */].onSeeking$;
var MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL = config["a" /* default */].MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL,
    TEXT_TRACK_SIZE_CHECKS_INTERVAL = config["a" /* default */].TEXT_TRACK_SIZE_CHECKS_INTERVAL;
/**
 * Generate the clock at which TextTrack HTML Cues should be refreshed.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */

function generateClock(videoElement) {
  var seeking$ = onSeeking$(videoElement);
  var seeked$ = onSeeked$(videoElement);
  var ended$ = onEnded$(videoElement);
  var manualRefresh$ = Object(merge["a" /* merge */])(seeked$, ended$);
  var autoRefresh$ = Object(interval["a" /* interval */])(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL).pipe(Object(startWith["a" /* startWith */])(null));
  return manualRefresh$.pipe(Object(startWith["a" /* startWith */])(null), Object(switchMapTo["a" /* switchMapTo */])(Object(concat["a" /* concat */])(autoRefresh$.pipe(Object(mapTo["a" /* mapTo */])(true), Object(takeUntil["a" /* takeUntil */])(seeking$)), Object(of["a" /* of */])(false))));
}
/**
 * @param {Element} element
 * @param {Element} child
 */


function safelyRemoveChild(element, child) {
  try {
    element.removeChild(child);
  } catch (_error) {
    log["a" /* default */].warn("HTSB: Can't remove text track: not in the element.");
  }
}
/**
 * @param {HTMLElement} element
 * @returns {Object|null}
 */


function getElementResolution(element) {
  var strRows = element.getAttribute("data-resolution-rows");
  var strColumns = element.getAttribute("data-resolution-columns");

  if (strRows === null || strColumns === null) {
    return null;
  }

  var rows = parseInt(strRows, 10);
  var columns = parseInt(strColumns, 10);

  if (rows === null || columns === null) {
    return null;
  }

  return {
    rows: rows,
    columns: columns
  };
}
/**
 * SourceBuffer to display TextTracks in the given HTML element.
 * @class HTMLTextSourceBuffer
 */


var html_text_source_buffer_HTMLTextSourceBuffer = /*#__PURE__*/function (_AbstractSourceBuffer) {
  _inheritsLoose(HTMLTextSourceBuffer, _AbstractSourceBuffer);

  /**
   * @param {HTMLMediaElement} videoElement
   * @param {HTMLElement} textTrackElement
   */
  function HTMLTextSourceBuffer(videoElement, textTrackElement) {
    var _this;

    log["a" /* default */].debug("HTSB: Creating html text track SourceBuffer");
    _this = _AbstractSourceBuffer.call(this) || this;
    _this._videoElement = videoElement;
    _this._textTrackElement = textTrackElement;
    _this._clearSizeUpdates$ = new Subject["a" /* Subject */]();
    _this._destroy$ = new Subject["a" /* Subject */]();
    _this._buffer = new text_track_cues_store_TextTrackCuesStore();
    _this._currentCue = null; // update text tracks

    generateClock(_this._videoElement).pipe(Object(takeUntil["a" /* takeUntil */])(_this._destroy$)).subscribe(function (shouldDisplay) {
      if (!shouldDisplay) {
        _this._hideCurrentCue();

        return;
      } // to spread the time error, we divide the regular chosen interval.


      var time = Math.max(_this._videoElement.currentTime + MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 1000 / 2, 0);

      var cue = _this._buffer.get(time);

      if (cue === undefined) {
        _this._hideCurrentCue();
      } else {
        _this._displayCue(cue.element);
      }
    });
    return _this;
  }
  /**
   * Append text tracks.
   * @param {Object} data
   */


  var _proto = HTMLTextSourceBuffer.prototype;

  _proto._append = function _append(data) {
    log["a" /* default */].debug("HTSB: Appending new html text tracks", data);
    var timescale = data.timescale,
        timescaledStart = data.start,
        timescaledEnd = data.end,
        dataString = data.data,
        type = data.type,
        language = data.language;
    var startTime = timescaledStart != null ? timescaledStart / timescale : undefined;
    var endTime = timescaledEnd != null ? timescaledEnd / timescale : undefined;
    var cues = parseTextTrackToElements(type, dataString, this.timestampOffset, language);

    if (this.appendWindowStart !== 0 && this.appendWindowEnd !== Infinity) {
      // Removing before window start
      var i = 0;

      while (i < cues.length && cues[i].end <= this.appendWindowStart) {
        i++;
      }

      cues.splice(0, i);
      i = 0;

      while (i < cues.length && cues[i].start < this.appendWindowStart) {
        cues[i].start = this.appendWindowStart;
        i++;
      } // Removing after window end


      i = cues.length - 1;

      while (i >= 0 && cues[i].start >= this.appendWindowEnd) {
        i--;
      }

      cues.splice(i, cues.length);
      i = cues.length - 1;

      while (i >= 0 && cues[i].end > this.appendWindowEnd) {
        cues[i].end = this.appendWindowEnd;
        i--;
      }
    }

    var start;

    if (startTime != null) {
      start = Math.max(this.appendWindowStart, startTime);
    } else {
      if (cues.length <= 0) {
        log["a" /* default */].warn("HTSB: Current text tracks have no cues nor start time. Aborting");
        return;
      }

      log["a" /* default */].warn("HTSB: No start time given. Guessing from cues.");
      start = cues[0].start;
    }

    var end;

    if (endTime != null) {
      end = Math.min(this.appendWindowEnd, endTime);
    } else {
      if (cues.length <= 0) {
        log["a" /* default */].warn("HTSB: Current text tracks have no cues nor end time. Aborting");
        return;
      }

      log["a" /* default */].warn("HTSB: No end time given. Guessing from cues.");
      end = cues[cues.length - 1].end;
    }

    if (end <= start) {
      log["a" /* default */].warn("HTSB: Invalid text track appended: ", "the start time is inferior or equal to the end time.");
      return;
    }

    this._buffer.insert(cues, start, end);

    this.buffered.insert(start, end);
  }
  /**
   * @param {Number} from
   * @param {Number} to
   */
  ;

  _proto._remove = function _remove(from, to) {
    log["a" /* default */].debug("HTSB: Removing html text track data", from, to);

    this._buffer.remove(from, to);

    this.buffered.remove(from, to);
  }
  /**
   * Free up ressources from this sourceBuffer
   */
  ;

  _proto._abort = function _abort() {
    log["a" /* default */].debug("HTSB: Aborting html text track SourceBuffer");

    this._hideCurrentCue();

    this._remove(0, Infinity);

    this._destroy$.next();

    this._destroy$.complete();
  }
  /**
   * Remove the current cue from being displayed.
   */
  ;

  _proto._hideCurrentCue = function _hideCurrentCue() {
    this._clearSizeUpdates$.next();

    if (this._currentCue !== null) {
      safelyRemoveChild(this._textTrackElement, this._currentCue.element);
      this._currentCue = null;
    }
  }
  /**
   * Display a new Cue. If one was already present, it will be replaced.
   * @param {HTMLElement} element
   */
  ;

  _proto._displayCue = function _displayCue(element) {
    var _this2 = this;

    if (this._currentCue !== null && this._currentCue.element === element) {
      return; // we're already good
    }

    this._clearSizeUpdates$.next();

    if (this._currentCue !== null) {
      safelyRemoveChild(this._textTrackElement, this._currentCue.element);
    }

    var resolution = getElementResolution(element);
    this._currentCue = {
      element: element,
      resolution: resolution
    };

    if (resolution !== null) {
      // update propertionally-sized elements periodically
      Object(on_height_width_change["a" /* default */])(this._textTrackElement, TEXT_TRACK_SIZE_CHECKS_INTERVAL).pipe(Object(takeUntil["a" /* takeUntil */])(this._clearSizeUpdates$), Object(takeUntil["a" /* takeUntil */])(this._destroy$)).subscribe(function (_ref) {
        var height = _ref.height,
            width = _ref.width;

        if (_this2._currentCue !== null && _this2._currentCue.resolution !== null) {
          var hasProport = updateProportionalElements(height, width, _this2._currentCue.resolution, _this2._currentCue.element);

          if (!hasProport) {
            _this2._clearSizeUpdates$.next();
          }
        }
      });
    }

    this._textTrackElement.appendChild(element);
  };

  return HTMLTextSourceBuffer;
}(abstract_source_buffer["a" /* default */]);


// CONCATENATED MODULE: ./src/custom_source_buffers/text/html/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var html = __webpack_exports__["default"] = (html_text_source_buffer_HTMLTextSourceBuffer);

/***/ }),
/* 202 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/compat/add_text_track.ts
var add_text_track = __webpack_require__(159);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(21);

// CONCATENATED MODULE: ./src/compat/remove_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Return true if given cue is active.
 * @param {TextTrack} track
 * @param {TextTrackCue} cue
 * @returns {boolean}
 */

function isActiveCue(track, cue) {
  var activeCues = track.activeCues;

  for (var i = 0; i < activeCues.length; i++) {
    if (activeCues[i] === cue) {
      return true;
    }
  }

  return false;
}
/**
 * Remove cue from text track.
 * @param {TextTrack} track
 * @param {TextTrackCue} cue
 */


function removeCue(track, cue) {
  // On Firefox, cue doesn't dissapear when it is removed from track. Track
  // should be hidden, and shown again after removing cue, in order to
  // definitely clean the cue.
  if (browser_detection["a" /* isFirefox */] && isActiveCue(track, cue)) {
    var trackMode = track.mode;
    track.mode = "hidden";

    try {
      track.removeCue(cue);
    } catch (err) {
      log["a" /* default */].warn("Compat: Could not remove cue from text track.");
    }

    track.mode = trackMode;
    return;
  }

  try {
    track.removeCue(cue);
  } catch (err) {
    log["a" /* default */].warn("Compat: Could not remove cue from text track.");
  }
}
// EXTERNAL MODULE: ./src/custom_source_buffers/abstract_source_buffer.ts + 1 modules
var abstract_source_buffer = __webpack_require__(84);

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(11);

// CONCATENATED MODULE: ./src/custom_source_buffers/text/native/parsers.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Convert text track data into timed VTT Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<VTTCue>}
 * @throws Error - Throw if no parser is found for the given type
 */

function parseTextTrackToCues(type, data, timestampOffset, language) {
  log["a" /* default */].debug("NTSB: Finding parser for native text tracks:", type);
  var parser = features["a" /* default */].nativeTextTracksParsers[type];

  if (typeof parser !== "function") {
    throw new Error("no parser found for the given text track");
  }

  log["a" /* default */].debug("NTSB: Parser found, parsing...");
  var parsed = parser(data, timestampOffset, language);
  log["a" /* default */].debug("NTSB: Parsed successfully!", parsed);
  return parsed;
}
// CONCATENATED MODULE: ./src/custom_source_buffers/text/native/native_text_source_buffer.ts
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * SourceBuffer to display TextTracks in a <track> element, in the given
 * video element.
 * @class NativeTextSourceBuffer
 * @extends AbstractSourceBuffer
 */

var native_text_source_buffer_NativeTextSourceBuffer = /*#__PURE__*/function (_AbstractSourceBuffer) {
  _inheritsLoose(NativeTextSourceBuffer, _AbstractSourceBuffer);

  /**
   * @param {HTMLMediaElement} videoElement
   * @param {Boolean} hideNativeSubtitle
   */
  function NativeTextSourceBuffer(videoElement, hideNativeSubtitle) {
    var _this;

    log["a" /* default */].debug("NTSB: Creating native text track SourceBuffer");
    _this = _AbstractSourceBuffer.call(this) || this;

    var _addTextTrack = Object(add_text_track["a" /* default */])(videoElement, hideNativeSubtitle),
        track = _addTextTrack.track,
        trackElement = _addTextTrack.trackElement;

    _this._videoElement = videoElement;
    _this._track = track;
    _this._trackElement = trackElement;
    return _this;
  }
  /**
   * Append text tracks.
   * @param {Object} data
   */


  var _proto = NativeTextSourceBuffer.prototype;

  _proto._append = function _append(data) {
    log["a" /* default */].debug("NTSB: Appending new native text tracks", data);
    var timescale = data.timescale,
        timescaledStart = data.start,
        timescaledEnd = data.end,
        dataString = data.data,
        type = data.type,
        language = data.language;
    var startTime = timescaledStart != null ? timescaledStart / timescale : undefined;
    var endTime = timescaledEnd != null ? timescaledEnd / timescale : undefined;
    var cues = parseTextTrackToCues(type, dataString, this.timestampOffset, language);

    if (this.appendWindowStart !== 0 && this.appendWindowEnd !== Infinity) {
      // Removing before window start
      var i = 0;

      while (i < cues.length && cues[i].endTime <= this.appendWindowStart) {
        i++;
      }

      cues.splice(0, i);
      i = 0;

      while (i < cues.length && cues[i].startTime < this.appendWindowStart) {
        cues[i].startTime = this.appendWindowStart;
        i++;
      } // Removing after window end


      i = cues.length - 1;

      while (i >= 0 && cues[i].startTime >= this.appendWindowEnd) {
        i--;
      }

      cues.splice(i, cues.length);
      i = cues.length - 1;

      while (i >= 0 && cues[i].endTime > this.appendWindowEnd) {
        cues[i].endTime = this.appendWindowEnd;
        i--;
      }
    }

    var start;

    if (startTime != null) {
      start = Math.max(this.appendWindowStart, startTime);
    } else {
      if (cues.length <= 0) {
        log["a" /* default */].warn("NTSB: Current text tracks have no cues nor start time. Aborting");
        return;
      }

      log["a" /* default */].warn("NTSB: No start time given. Guessing from cues.");
      start = cues[0].startTime;
    }

    var end;

    if (endTime != null) {
      end = Math.min(this.appendWindowEnd, endTime);
    } else {
      if (cues.length <= 0) {
        log["a" /* default */].warn("NTSB: Current text tracks have no cues nor end time. Aborting");
        return;
      }

      log["a" /* default */].warn("NTSB: No end time given. Guessing from cues.");
      end = cues[cues.length - 1].endTime;
    }

    if (end <= start) {
      log["a" /* default */].warn("NTSB: Invalid text track appended: ", "the start time is inferior or equal to the end time.");
      return;
    }

    if (cues.length <= 0) {
      this.buffered.insert(start, end);
      return;
    }

    var firstCue = cues[0]; // NOTE(compat): cleanup all current cues if the newly added
    // ones are in the past. this is supposed to fix an issue on
    // IE/Edge.
    // TODO Move to compat

    var currentCues = this._track.cues;

    if (currentCues.length > 0) {
      if (firstCue.startTime < currentCues[currentCues.length - 1].startTime) {
        this._remove(firstCue.startTime, +Infinity);
      }
    }

    for (var _i = 0; _i < cues.length; _i++) {
      this._track.addCue(cues[_i]);
    }

    this.buffered.insert(start, end);
  }
  /**
   * @param {Number} from
   * @param {Number} to
   */
  ;

  _proto._remove = function _remove(from, to) {
    log["a" /* default */].debug("NTSB: Removing native text track data", from, to);
    var track = this._track;
    var cues = track.cues;

    if (cues != null) {
      for (var i = cues.length - 1; i >= 0; i--) {
        var cue = cues[i];
        var startTime = cue.startTime,
            endTime = cue.endTime;

        if (startTime >= from && startTime <= to && endTime <= to) {
          removeCue(track, cue);
        }
      }
    }

    this.buffered.remove(from, to);
  };

  _proto._abort = function _abort() {
    log["a" /* default */].debug("NTSB: Aborting native text track SourceBuffer");

    this._remove(0, Infinity);

    var _trackElement = this._trackElement,
        _videoElement = this._videoElement;

    if (_trackElement !== undefined && _videoElement != null && _videoElement.hasChildNodes()) {
      try {
        _videoElement.removeChild(_trackElement);
      } catch (e) {
        log["a" /* default */].warn("NTSB: Can't remove track element from the video");
      }
    }

    if (this._track != null) {
      this._track.mode = "disabled";
    }

    if (this._trackElement != null) {
      this._trackElement.innerHTML = "";
    }
  };

  return NativeTextSourceBuffer;
}(abstract_source_buffer["a" /* default */]);


// CONCATENATED MODULE: ./src/custom_source_buffers/text/native/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var text_native = __webpack_exports__["default"] = (native_text_source_buffer_NativeTextSourceBuffer);

/***/ }),
/* 203 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/compat/is_vtt_cue.ts
var is_vtt_cue = __webpack_require__(160);

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/get_cue_blocks.ts
var get_cue_blocks = __webpack_require__(118);

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts + 1 modules
var parse_cue_block = __webpack_require__(133);

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/utils.ts
var utils = __webpack_require__(62);

// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(10);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/set_settings_on_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Add the corresponding settings on the given cue.
 * /!\ Mutates the cue given.
 * @param {Object} settings - settings for the cue, as a key-value object.
 * @param {ICompatVTTCue|TextTrackCue} cue
 */

function setSettingsOnCue(settings, cue) {
  if (Object(is_non_empty_string["a" /* default */])(settings.vertical) && (settings.vertical === "rl" || settings.vertical === "lr")) {
    cue.vertical = settings.vertical;
  }

  if (Object(is_non_empty_string["a" /* default */])(settings.line)) {
    // Capture groups:
    //   1 -> percentage position
    //   2 -> optional decimals from percentage position
    //   3 -> optional follow-up of the string indicating alignment value
    //   4 -> alignment value
    var percentagePosition = /^(\d+(\.\d+)?)%(,([a-z]+))?/;
    var percentageMatches = settings.line.match(percentagePosition);

    if (Array.isArray(percentageMatches)) {
      cue.line = Number(percentageMatches[1]);
      cue.snapToLines = false;

      if (Object(array_includes["a" /* default */])(["start", "center", "end"], percentageMatches[4])) {
        cue.lineAlign = percentageMatches[4];
      }
    } else {
      // Capture groups:
      //   1 -> line number
      //   2 -> optional follow-up of the string indicating alignment value
      //   3 -> alignment value
      var linePosition = /^(-?\d+)(,([a-z]+))?/;
      var lineMatches = settings.line.match(linePosition);

      if (Array.isArray(lineMatches)) {
        cue.line = Number(lineMatches[1]);
        cue.snapToLines = true;

        if (Object(array_includes["a" /* default */])(["start", "center", "end"], lineMatches[3])) {
          cue.lineAlign = lineMatches[3];
        }
      }
    }
  }

  if (Object(is_non_empty_string["a" /* default */])(settings.position)) {
    var positionRegex = /^([\d\.]+)%(?:,(line-left|line-right|center))?$/;
    var positionArr = positionRegex.exec(settings.position);

    if (Array.isArray(positionArr) && positionArr.length >= 2) {
      var position = parseInt(positionArr[1], 10);

      if (!isNaN(position)) {
        cue.position = position;

        if (positionArr[2] !== undefined) {
          cue.positionAlign = positionArr[2];
        }
      }
    }
  }

  if (Object(is_non_empty_string["a" /* default */])(settings.size)) {
    cue.size = settings.size;
  }

  if (typeof settings.align === "string" && Object(array_includes["a" /* default */])(["start", "center", "end", "left"], settings.align)) {
    cue.align = settings.align;
  }
}
// EXTERNAL MODULE: ./src/compat/make_vtt_cue.ts
var make_vtt_cue = __webpack_require__(119);

// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/to_native_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Object} cue Object
 * @returns {TextTrackCue|ICompatVTTCue|null}
 */

function toNativeCue(cueObj) {
  var start = cueObj.start,
      end = cueObj.end,
      payload = cueObj.payload;
  var text = payload.join("\n");
  return Object(make_vtt_cue["a" /* default */])(start, end, text);
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/parse_vtt_to_cues.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */





 // Simple VTT to ICompatVTTCue parser:
// Just parse cues and associated settings.
// Does not take into consideration STYLE and REGION blocks.

/**
 * Parse whole WEBVTT file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} vttStr
 * @param {Number} timeOffset
 * @returns {Array.<ICompatVTTCue|TextTrackCue>}
 */

function parseVTTStringToVTTCues(vttStr, timeOffset) {
  // WEBVTT authorize CRLF, LF or CR as line terminators
  var lines = vttStr.split(/\r\n|\n|\r/);

  if (!/^WEBVTT($| |\t)/.test(lines[0])) {
    throw new Error("Can't parse WebVTT: Invalid file.");
  }

  var firstLineAfterHeader = Object(utils["b" /* getFirstLineAfterHeader */])(lines);
  var cueBlocks = Object(get_cue_blocks["a" /* default */])(lines, firstLineAfterHeader);
  var cues = [];

  for (var i = 0; i < cueBlocks.length; i++) {
    var cueObject = Object(parse_cue_block["a" /* default */])(cueBlocks[i], timeOffset);

    if (cueObject != null) {
      var nativeCue = toNativeCue(cueObject);

      if (nativeCue != null) {
        if (Object(is_vtt_cue["a" /* default */])(nativeCue)) {
          setSettingsOnCue(cueObject.settings, nativeCue);
        }

        cues.push(nativeCue);
      }
    }
  }

  return cues;
}
// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var webvtt_native = __webpack_exports__["default"] = (parseVTTStringToVTTCues);

/***/ }),
/* 204 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(0);

// EXTERNAL MODULE: ./src/custom_source_buffers/abstract_source_buffer.ts + 1 modules
var abstract_source_buffer = __webpack_require__(84);

// CONCATENATED MODULE: ./src/custom_source_buffers/image/image_source_buffer.ts
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */


/**
 * Image SourceBuffer implementation.
 * @class ImageSourceBuffer
 */

var image_source_buffer_ImageSourceBuffer = /*#__PURE__*/function (_AbstractSourceBuffer) {
  _inheritsLoose(ImageSourceBuffer, _AbstractSourceBuffer);

  function ImageSourceBuffer() {
    return _AbstractSourceBuffer.apply(this, arguments) || this;
  }

  var _proto = ImageSourceBuffer.prototype;

  /**
   * @param {Object} data
   */
  _proto._append = function _append(data) {
    log["a" /* default */].debug("ImageSourceBuffer: appending new data.");
    var start = data.start,
        end = data.end,
        timescale = data.timescale;
    var timescaledStart = start / timescale;
    var timescaledEnd = end == null ? Number.MAX_VALUE : end / timescale;
    var startTime = Math.max(this.appendWindowStart, timescaledStart);
    var endTime = Math.min(this.appendWindowEnd, timescaledEnd);
    this.buffered.insert(startTime, endTime);
  }
  /**
   * @param {Number} from
   * @param {Number} to
   */
  ;

  _proto._remove = function _remove(from, to) {
    log["a" /* default */].info("ImageSourceBuffer: ignored image data remove order", from, to); // TODO once a better strategy for image cleaning has been set (surely done
    // when we will work for live thumbnails), restore this implementation.
    // log.debug("ImageSourceBuffer: removing image data", from, to);
    // this.buffered.remove(from, to);
  };

  _proto._abort = function _abort() {
    log["a" /* default */].debug("ImageSourceBuffer: aborting image SourceBuffer");

    this._remove(0, Infinity);
  };

  return ImageSourceBuffer;
}(abstract_source_buffer["a" /* default */]);

/* harmony default export */ var image_source_buffer = (image_source_buffer_ImageSourceBuffer);
// CONCATENATED MODULE: ./src/custom_source_buffers/image/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var custom_source_buffers_image = __webpack_exports__["default"] = (image_source_buffer);

/***/ }),
/* 205 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ./src/compat/make_vtt_cue.ts
var make_vtt_cue = __webpack_require__(119);

// EXTERNAL MODULE: ./src/compat/is_vtt_cue.ts
var is_vtt_cue = __webpack_require__(160);

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(14);

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(2);

// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(7);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_parameters.ts
var get_parameters = __webpack_require__(120);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_parent_elements_by_tag_name.ts
var get_parent_elements_by_tag_name = __webpack_require__(83);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_styling.ts + 1 modules
var get_styling = __webpack_require__(35);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts + 1 modules
var get_time_delimiters = __webpack_require__(134);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/nodes.ts
var nodes = __webpack_require__(59);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
var regexps = __webpack_require__(15);

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/resolve_styles_inheritance.ts
var resolve_styles_inheritance = __webpack_require__(121);

// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/native/parse_ttml_to_vtt.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











/**
 * Style attributes currently used.
 */

var WANTED_STYLE_ATTRIBUTES = ["extent", "writingMode", "origin", "align"];
var TEXT_ALIGN_TO_LIGN_ALIGN = {
  left: "start",
  center: "center",
  right: "end",
  start: "start",
  end: "end"
};
/**
 * @type {Object}
 */

var TEXT_ALIGN_TO_POSITION_ALIGN = {
  left: "line-left",
  center: "center",
  right: "line-right"
};
/**
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */

function parseTTMLStringToVTT(str, timeOffset) {
  var ret = [];
  var xml = new DOMParser().parseFromString(str, "text/xml");

  if (xml !== null && xml !== undefined) {
    var tts = xml.getElementsByTagName("tt");
    var tt = tts[0];

    if (tt === undefined) {
      throw new Error("invalid XML");
    }

    var body = Object(nodes["a" /* getBodyNode */])(tt);
    var styleNodes = Object(nodes["c" /* getStyleNodes */])(tt);
    var regionNodes = Object(nodes["b" /* getRegionNodes */])(tt);
    var paragraphNodes = Object(nodes["d" /* getTextNodes */])(tt);
    var params = Object(get_parameters["a" /* default */])(tt); // construct styles array based on the xml as an optimization

    var styles = [];

    for (var i = 0; i <= styleNodes.length - 1; i++) {
      // TODO styles referencing other styles
      var styleNode = styleNodes[i];

      if (styleNode instanceof Element) {
        var styleID = styleNode.getAttribute("xml:id");

        if (styleID != null) {
          var subStyles = styleNode.getAttribute("style");
          var extendsStyles = subStyles === null ? [] : subStyles.split(" ");
          styles.push({
            id: styleID,
            style: Object(get_styling["b" /* getStylingFromElement */])(styleNode),
            extendsStyles: extendsStyles
          });
        }
      }
    }

    Object(resolve_styles_inheritance["a" /* default */])(styles); // construct regions array based on the xml as an optimization

    var regions = [];

    for (var _i = 0; _i <= regionNodes.length - 1; _i++) {
      var regionNode = regionNodes[_i];

      if (regionNode instanceof Element) {
        var regionID = regionNode.getAttribute("xml:id");

        if (regionID != null) {
          (function () {
            var regionStyle = Object(get_styling["b" /* getStylingFromElement */])(regionNode);
            var associatedStyle = regionNode.getAttribute("style");

            if (Object(is_non_empty_string["a" /* default */])(associatedStyle)) {
              var style = Object(array_find["a" /* default */])(styles, function (x) {
                return x.id === associatedStyle;
              });

              if (style !== undefined) {
                regionStyle = Object(object_assign["a" /* default */])({}, style.style, regionStyle);
              }
            }

            regions.push({
              id: regionID,
              style: regionStyle,
              // already handled
              extendsStyles: []
            });
          })();
        }
      }
    } // Computing the style takes a lot of ressources.
    // To avoid too much re-computation, let's compute the body style right
    // now and do the rest progressively.


    var bodyStyle = body !== null ? Object(get_styling["a" /* getStylingAttributes */])(WANTED_STYLE_ATTRIBUTES, [body], styles, regions) : Object(get_styling["a" /* getStylingAttributes */])(WANTED_STYLE_ATTRIBUTES, [], styles, regions);
    var bodySpaceAttribute = body !== null ? body.getAttribute("xml:space") : undefined;
    var shouldTrimWhiteSpaceOnBody = bodySpaceAttribute === "default" || params.spaceStyle === "default";

    for (var _i2 = 0; _i2 < paragraphNodes.length; _i2++) {
      var paragraph = paragraphNodes[_i2];

      if (paragraph instanceof Element) {
        var divs = Object(get_parent_elements_by_tag_name["a" /* default */])(paragraph, "div");
        var paragraphStyle = Object(object_assign["a" /* default */])({}, bodyStyle, Object(get_styling["a" /* getStylingAttributes */])(WANTED_STYLE_ATTRIBUTES, [paragraph].concat(divs), styles, regions));
        var paragraphSpaceAttribute = paragraph.getAttribute("xml:space");
        var shouldTrimWhiteSpaceOnParagraph = Object(is_non_empty_string["a" /* default */])(paragraphSpaceAttribute) ? paragraphSpaceAttribute === "default" : shouldTrimWhiteSpaceOnBody;
        var cue = parseCue(paragraph, timeOffset, styles, regions, paragraphStyle, params, shouldTrimWhiteSpaceOnParagraph);

        if (cue !== null) {
          ret.push(cue);
        }
      }
    }
  }

  return ret;
}
/**
 * Parses an Element into a TextTrackCue or VTTCue.
 * /!\ Mutates the given cueElement Element
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Object} paragraphStyle
 * @param {Object} params
 * @param {Boolean} shouldTrimWhiteSpaceOnParagraph
 * @returns {TextTrackCue|null}
 */


function parseCue(paragraph, offset, _styles, _regions, paragraphStyle, params, shouldTrimWhiteSpace) {
  // Disregard empty elements:
  // TTML allows for empty elements like <div></div>.
  // If paragraph has neither time attributes, nor
  // non-whitespace text, don't try to make a cue out of it.
  if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") && /^\s*$/.test(paragraph.textContent === null ? "" : paragraph.textContent)) {
    return null;
  }

  var _getTimeDelimiters = Object(get_time_delimiters["a" /* default */])(paragraph, params),
      start = _getTimeDelimiters.start,
      end = _getTimeDelimiters.end;

  var text = generateTextContent(paragraph, shouldTrimWhiteSpace);
  var cue = Object(make_vtt_cue["a" /* default */])(start + offset, end + offset, text);

  if (cue === null) {
    return null;
  }

  if (Object(is_vtt_cue["a" /* default */])(cue)) {
    addStyle(cue, paragraphStyle);
  }

  return cue;
}
/**
 * Generate text to display for a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Boolean} shouldTrimWhiteSpaceForParagraph
 * @returns {string}
 */


function generateTextContent(paragraph, shouldTrimWhiteSpaceForParagraph) {
  /**
   * Recursive function, taking a node in argument and returning the
   * corresponding string.
   * @param {Node} node - the node in question
   * @returns {string}
   */
  function loop(node, shouldTrimWhiteSpaceFromParent) {
    var childNodes = node.childNodes;
    var text = "";

    for (var i = 0; i < childNodes.length; i++) {
      var currentNode = childNodes[i];

      if (currentNode.nodeName === "#text") {
        var textContent = currentNode.textContent;

        if (textContent === null) {
          textContent = "";
        }

        if (shouldTrimWhiteSpaceFromParent) {
          // 1. Trim leading and trailing whitespace.
          // 2. Collapse multiple spaces into one.
          var trimmed = textContent.trim();
          trimmed = trimmed.replace(/\s+/g, " ");
          textContent = trimmed;
        } // DOM Parser turns HTML escape caracters into caracters,
        // that may be misinterpreted by VTTCue API (typically, less-than sign
        // and greater-than sign can be interpreted as HTML tags signs).
        // Original escaped caracters must be conserved.


        var escapedTextContent = textContent.replace(/&|\u0026/g, "&amp;").replace(/<|\u003C/g, "&lt;").replace(/>|\u2265/g, "&gt;").replace(/\u200E/g, "&lrm;").replace(/\u200F/g, "&rlm;").replace(/\u00A0/g, "&nbsp;");
        text += escapedTextContent;
      } else if (currentNode.nodeName === "br") {
        text += "\n";
      } else if (currentNode.nodeName === "span" && currentNode.nodeType === Node.ELEMENT_NODE && currentNode.childNodes.length > 0) {
        var spaceAttribute = currentNode.getAttribute("xml:space");
        var shouldTrimWhiteSpaceForSpan = Object(is_non_empty_string["a" /* default */])(spaceAttribute) ? spaceAttribute === "default" : shouldTrimWhiteSpaceFromParent;
        text += loop(currentNode, shouldTrimWhiteSpaceForSpan);
      }
    }

    return text;
  }

  return loop(paragraph, shouldTrimWhiteSpaceForParagraph);
}
/**
 * Adds applicable style properties to a cue.
 * /!\ Mutates cue argument.
 * @param {VTTCue} cue
 * @param {Object} style
 */


function addStyle(cue, style) {
  var extent = style.extent;

  if (Object(is_non_empty_string["a" /* default */])(extent)) {
    var results = regexps["d" /* REGXP_PERCENT_VALUES */].exec(extent);

    if (results != null) {
      // Use width value of the extent attribute for size.
      // Height value is ignored.
      cue.size = Number(results[1]);
    }
  }

  var writingMode = style.writingMode; // let isVerticalText = true;

  switch (writingMode) {
    case "tb":
    case "tblr":
      cue.vertical = "lr";
      break;

    case "tbrl":
      cue.vertical = "rl";
      break;

    default:
      // isVerticalText = false;
      break;
  }

  var origin = style.origin;

  if (Object(is_non_empty_string["a" /* default */])(origin)) {
    var _results = regexps["d" /* REGXP_PERCENT_VALUES */].exec(origin);

    if (_results != null) {// for vertical text use first coordinate of tts:origin
      // to represent line of the cue and second - for position.
      // Otherwise (horizontal), use them the other way around.
      // if (isVerticalText) {
      // TODO check and uncomment
      // cue.position = Number(results[2]);
      // cue.line = Number(results[1]);
      // } else {
      // TODO check and uncomment
      // cue.position = Number(results[1]);
      // cue.line = Number(results[2]);
      // }
      // A boolean indicating whether the line is an integer
      // number of lines (using the line dimensions of the first
      // line of the cue), or whether it is a percentage of the
      // dimension of the video. The flag is set to true when lines
      // are counted, and false otherwise.
      // TODO check and uncomment
      // cue.snapToLines = false;
    }
  }

  var align = style.align;

  if (Object(is_non_empty_string["a" /* default */])(align)) {
    cue.align = align;

    if (align === "center") {
      if (cue.align !== "center") {
        // Workaround for a Chrome bug http://crbug.com/663797
        // Chrome does not support align = "center"
        cue.align = "middle";
      }

      cue.position = "auto";
    }

    var positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align];
    cue.positionAlign = positionAlign === undefined ? "" : positionAlign;
    var lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align];
    cue.lineAlign = lineAlign === undefined ? "" : lineAlign;
  }
}

/* harmony default export */ var parse_ttml_to_vtt = (parseTTMLStringToVTT);
// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/native/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ var ttml_native = __webpack_exports__["default"] = (parse_ttml_to_vtt);

/***/ }),
/* 206 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return fromEvent; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(60);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(32);
/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */




var toString = /*@__PURE__*/ (function () { return Object.prototype.toString; })();
function fromEvent(target, eventName, options, resultSelector) {
    if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__[/* isFunction */ "a"])(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__[/* map */ "a"])(function (args) { return Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__[/* isArray */ "a"])(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}
//# sourceMappingURL=fromEvent.js.map


/***/ }),
/* 207 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return interval; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */



function interval(period, scheduler) {
    if (period === void 0) {
        period = 0;
    }
    if (scheduler === void 0) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__[/* async */ "a"];
    }
    if (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__[/* isNumeric */ "a"])(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__[/* async */ "a"];
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}
//# sourceMappingURL=interval.js.map


/***/ }),
/* 208 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AssertionError; });
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Error due to an abnormal assertion fails.
 *
 * @class AssertionError
 * @extends Error
 */
var AssertionError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(AssertionError, _Error);

  /**
   * @param {string} message
   */
  function AssertionError(message) {
    var _this;

    _this = _Error.call(this) || this; // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class

    Object.setPrototypeOf(_assertThisInitialized(_this), AssertionError.prototype);
    _this.name = "AssertionError";
    _this.message = message;
    return _this;
  }

  return AssertionError;
}( /*#__PURE__*/_wrapNativeSuper(Error));



/***/ }),
/* 209 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return catchError; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(28);
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */




function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
var CatchOperator = /*@__PURE__*/ (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__[/* InnerSubscriber */ "a"](this, undefined, undefined);
            this.add(innerSubscriber);
            Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__[/* subscribeToResult */ "a"])(this, result, undefined, undefined, innerSubscriber);
        }
    };
    return CatchSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__[/* OuterSubscriber */ "a"]));
//# sourceMappingURL=catchError.js.map


/***/ }),
/* 210 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return setMediaKeys$; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);
/* harmony import */ var _utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _custom_media_keys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(147);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Set the MediaKeys given on the media element.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {*}
 */

function _setMediaKeys(elt, mediaKeys) {
  if (mediaKeys instanceof _custom_media_keys__WEBPACK_IMPORTED_MODULE_2__[/* default */ "b"]) {
    return mediaKeys._setVideo(elt);
  }
  /* tslint:disable no-unbound-method */


  if (typeof elt.setMediaKeys === "function") {
    /* tslint:enable no-unbound-method */
    return elt.setMediaKeys(mediaKeys);
  }

  if (mediaKeys === null) {
    return;
  }

  if (elt.WebkitSetMediaKeys) {
    /* tslint:disable no-unsafe-any */
    return elt.WebkitSetMediaKeys(mediaKeys);
    /* tslint:enable no-unsafe-any */
  }

  if (elt.mozSetMediaKeys) {
    /* tslint:disable no-unsafe-any */
    return elt.mozSetMediaKeys(mediaKeys);
    /* tslint:enable no-unsafe-any */
  }

  if (elt.msSetMediaKeys) {
    /* tslint:disable no-unsafe-any */
    return elt.msSetMediaKeys(mediaKeys);
    /* tslint:enable no-unsafe-any */
  }
}
/**
 * Set the given MediaKeys on the given HTMLMediaElement.
 * Emits null when done then complete.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Observable}
 */


function setMediaKeys$(elt, mediaKeys) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* defer */ "a"])(function () {
    return Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(_setMediaKeys(elt, mediaKeys));
  });
}

/***/ }),
/* 211 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ subscribeOn; });

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(12);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/asap.js + 3 modules
var asap = __webpack_require__(94);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isNumeric.js
var isNumeric = __webpack_require__(75);

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js
/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */




var SubscribeOnObservable_SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
    tslib_es6["a" /* __extends */](SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) {
            delayTime = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap["a" /* asap */];
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!Object(isNumeric["a" /* isNumeric */])(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = asap["a" /* asap */];
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) {
            delay = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap["a" /* asap */];
        }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable["a" /* Observable */]));

//# sourceMappingURL=SubscribeOnObservable.js.map

// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/subscribeOn.js
/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return function subscribeOnOperatorFunction(source) {
        return source.lift(new subscribeOn_SubscribeOnOperator(scheduler, delay));
    };
}
var subscribeOn_SubscribeOnOperator = /*@__PURE__*/ (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable_SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());
//# sourceMappingURL=subscribeOn.js.map


/***/ }),
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return combineLatest; });
/* unused harmony export CombineLatestOperator */
/* unused harmony export CombineLatestSubscriber */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70);
/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */






var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = null;
    var scheduler = null;
    if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__[/* isScheduler */ "a"])(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__[/* isArray */ "a"])(observables[0])) {
        observables = observables[0];
    }
    return Object(_fromArray__WEBPACK_IMPORTED_MODULE_5__[/* fromArray */ "a"])(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /*@__PURE__*/ (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());

var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__[/* subscribeToResult */ "a"])(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__[/* OuterSubscriber */ "a"]));

//# sourceMappingURL=combineLatest.js.map


/***/ }),
/* 216 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return race; });
/* unused harmony export RaceOperator */
/* unused harmony export RaceSubscriber */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(70);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(28);
/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__[/* isArray */ "a"])(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return Object(_fromArray__WEBPACK_IMPORTED_MODULE_2__[/* fromArray */ "a"])(observables, undefined).lift(new RaceOperator());
}
var RaceOperator = /*@__PURE__*/ (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());

var RaceSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__[/* subscribeToResult */ "a"])(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__[/* OuterSubscriber */ "a"]));

//# sourceMappingURL=race.js.map


/***/ }),
/* 217 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return timer; });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(49);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */




function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) {
        dueTime = 0;
    }
    var period = -1;
    if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__[/* isNumeric */ "a"])(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__[/* isScheduler */ "a"])(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__[/* isScheduler */ "a"])(scheduler)) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__[/* async */ "a"];
    }
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__[/* Observable */ "a"](function (subscriber) {
        var due = Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__[/* isNumeric */ "a"])(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}
//# sourceMappingURL=timer.js.map


/***/ }),
/* 218 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getInitData; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var _utils_hash_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(39);
/* harmony import */ var _utils_simple_set__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(107);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(108);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * As we observed on some browsers (IE and Edge), the initialization data on
 * some segments have sometimes duplicated PSSH when sent through an encrypted
 * event (but not when pushed to the SourceBuffer).
 *
 * This function tries to guess if the initialization data contains only PSSHs
 * concatenated (as it is usually the case).
 * If that's the case, it will filter duplicated PSSHs from it.
 *
 * @param {Uint8Array} initData - Raw initialization data
 * @returns {Uint8Array} - Initialization data, "cleaned"
 */

function cleanEncryptedEvent(initData) {
  var resInitData = new Uint8Array();
  var currentHashes = new _utils_simple_set__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]();
  var offset = 0;

  while (offset < initData.length) {
    if (initData.length < offset + 8 || Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(initData, offset + 4) !== _constants__WEBPACK_IMPORTED_MODULE_4__[/* PSSH_TO_INTEGER */ "a"]) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: Unrecognized initialization data. Use as is.");
      return initData;
    }

    var len = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* be4toi */ "c"])(new Uint8Array(initData), offset);

    if (offset + len > initData.length) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: Unrecognized initialization data. Use as is.");
      return initData;
    }

    var currentPSSH = initData.subarray(offset, offset + len);
    var currentPSSHHash = Object(_utils_hash_buffer__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])(currentPSSH);

    if (!currentHashes.test(currentPSSHHash)) {
      currentHashes.add(currentPSSHHash);
      resInitData = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__[/* concat */ "h"])(resInitData, currentPSSH);
    } else {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: Duplicated PSSH found in initialization data, removing it.");
    }

    offset += len;
  }

  if (offset !== initData.length) {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: Unrecognized initialization data. Use as is.");
    return initData;
  }

  return resInitData;
}
/**
 * Take out the two things we need on an encryptedEvent:
 *   - the initialization Data
 *   - the initialization Data type
 *
 * @param {MediaEncryptedEvent} encryptedEvent - Payload received with an
 * "encrypted" event.
 * @returns {Object} - Initialization data and Initialization data type.
 * @throws {EncryptedMediaError} - Throws if no initialization data is
 * encountered in the given event.
 */


function getInitData(encryptedEvent) {
  var initData = encryptedEvent.initData,
      initDataType = encryptedEvent.initDataType;

  if (initData == null) {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Compat: No init data found on media encrypted event.");
    return {
      initData: initData,
      initDataType: initDataType
    };
  }

  var initDataBytes = new Uint8Array(initData);
  return {
    initData: cleanEncryptedEvent(initDataBytes),
    initDataType: encryptedEvent.initDataType
  };
}

/***/ }),
/* 219 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export patchInitData */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return generateKeyRequest; });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(79);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var _utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(108);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Some browsers have problems when the CENC PSSH box is the first managed PSSH
 * encountered (for the moment just Edge was noted with this behavior).
 *
 * This function tries to move CENC PSSH boxes at the end of the given init
 * data.
 *
 * If the initData is unrecognized or if a CENC PSSH is not found, this function
 * throws.
 * @param {Uint8Array} initData - Initialization data you want to patch
 * @returns {Uint8Array} - Initialization data, patched
 */

function patchInitData(initData) {
  var initialLength = initData.byteLength;
  _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].info("Compat: Trying to move CENC PSSH from init data at the end of it.");
  var cencs = new Uint8Array();
  var resInitData = new Uint8Array();
  var offset = 0;

  while (offset < initData.length) {
    if (initData.length < offset + 8 || Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(initData, offset + 4) !== _constants__WEBPACK_IMPORTED_MODULE_5__[/* PSSH_TO_INTEGER */ "a"]) {
      _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("Compat: unrecognized initialization data. Cannot patch it.");
      throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
    }

    var len = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(new Uint8Array(initData), offset);

    if (offset + len > initData.length) {
      _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("Compat: unrecognized initialization data. Cannot patch it.");
      throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
    }

    var currentPSSH = initData.subarray(offset, offset + len); // yep

    if (initData[offset + 12] === 0x10 && initData[offset + 13] === 0x77 && initData[offset + 14] === 0xEF && initData[offset + 15] === 0xEC && initData[offset + 16] === 0xC0 && initData[offset + 17] === 0xB2 && initData[offset + 18] === 0x4D && initData[offset + 19] === 0x02 && initData[offset + 20] === 0xAC && initData[offset + 21] === 0xE3 && initData[offset + 22] === 0x3C && initData[offset + 23] === 0x1E && initData[offset + 24] === 0x52 && initData[offset + 25] === 0xE2 && initData[offset + 26] === 0xFB && initData[offset + 27] === 0x4B) {
      _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].info("Compat: CENC PSSH found.");
      cencs = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* concat */ "h"])(cencs, currentPSSH);
    } else {
      resInitData = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* concat */ "h"])(resInitData, currentPSSH);
    }

    offset += len;
  }

  if (offset !== initData.length) {
    _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("Compat: unrecognized initialization data. Cannot patch it.");
    throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
  }

  if (resInitData.byteLength === initialLength) {
    _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].warn("Compat: CENC PSSH not found. Cannot patch it");
    throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
  }

  return Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* concat */ "h"])(resInitData, cencs);
}
/**
 * Generate a request from session.
 * @param {MediaKeySession} session - MediaKeySession on which the request will
 * be done.
 * @param {Uint8Array} initData - Initialization data given e.g. by the
 * "encrypted" event for the corresponding request.
 * @param {string} initDataType - Initialization data type given e.g. by the
 * "encrypted" event for the corresponding request.
 * @param {string} sessionType - Type of session you want to generate. Consult
 * EME Specification for more information on session types.
 * @returns {Observable} - Emit when done. Errors if fails.
 */

function generateKeyRequest(session, initData, initDataType) {
  return Object(rxjs__WEBPACK_IMPORTED_MODULE_0__[/* defer */ "a"])(function () {
    _log__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].debug("Compat: Calling generateRequest on the MediaKeySession");
    var patchedInit;

    if (_browser_detection__WEBPACK_IMPORTED_MODULE_4__[/* isIEOrEdge */ "c"]) {
      try {
        patchedInit = patchInitData(initData);
      } catch (_e) {
        patchedInit = initData;
      }
    } else {
      patchedInit = initData;
    }

    return Object(_utils_cast_to_observable__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"])(session.generateRequest(initDataType == null ? "" : initDataType, patchedInit));
  });
}

/***/ }),
/* 220 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return StaticRepresentationIndex; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Simple RepresentationIndex implementation for static files.
 * @class StaticRepresentationIndex
 */

var StaticRepresentationIndex = /*#__PURE__*/function () {
  /**
   * @param {Object} infos
   */
  function StaticRepresentationIndex(infos) {
    this._mediaURLs = infos.media;
  }
  /**
   * Static contents do not have any initialization segments.
   * Just return null.
   * @returns {null}
   */


  var _proto = StaticRepresentationIndex.prototype;

  _proto.getInitSegment = function getInitSegment() {
    return null;
  }
  /**
   * Returns the only Segment available here.
   * @returns {Array.<Object>}
   */
  ;

  _proto.getSegments = function getSegments() {
    return [{
      id: "0",
      isInit: false,
      number: 0,
      time: 0,
      duration: Number.MAX_VALUE,
      timescale: 1,
      mediaURLs: [this._mediaURLs]
    }];
  }
  /**
   * Returns first position in index.
   * @returns {undefined}
   */
  ;

  _proto.getFirstPosition = function getFirstPosition() {
    return;
    /* tslint:enable return-undefined */
  }
  /**
   * Returns last position in index.
   * @returns {undefined}
   */
  ;

  _proto.getLastPosition = function getLastPosition() {
    return;
  }
  /**
   * Returns false as a static file never need to be refreshed.
   * @returns {Boolean}
   */
  ;

  _proto.shouldRefresh = function shouldRefresh() {
    return false;
  }
  /**
   * @returns {Number}
   */
  ;

  _proto.checkDiscontinuity = function checkDiscontinuity() {
    return -1;
  }
  /**
   * Returns true as a static file should never need lose availability.
   * @returns {Boolean}
   */
  ;

  _proto.isSegmentStillAvailable = function isSegmentStillAvailable() {
    return true;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.canBeOutOfSyncError = function canBeOutOfSyncError() {
    return false;
  }
  /**
   * @returns {Boolean}
   */
  ;

  _proto.isFinished = function isFinished() {
    return true;
  };

  _proto._addSegments = function _addSegments() {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Tried add Segments to a static RepresentationIndex");
  };

  _proto._replace = function _replace() {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Tried to replace a static RepresentationIndex");
  };

  _proto._update = function _update() {
    _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].warn("Tried to update a static RepresentationIndex");
  };

  return StaticRepresentationIndex;
}();



/***/ }),
/* 221 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getMDHDTimescale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getTrackFragmentDecodeTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getDurationFromTrun; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getSegmentsFromSidx; });
/* unused harmony export patchPssh */
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(48);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1);
/* harmony import */ var _create_box__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(172);
/* harmony import */ var _read__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(137);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Find the offset for the first declaration of the given box in an isobmff.
 * Returns -1 if not found.
 *
 * This function calls log.error in case of partial segments.
 * @param {Uint8Array} buf - the isobmff
 * @param {Number} wantedName
 * @returns {Number} - Offset where the box begins. -1 if not found.
 */

function findBox(buf, wantedName) {
  var len = buf.length;
  var i = 0;

  while (i + 8 < len) {
    var size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(buf, i);

    if (size <= 0) {
      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].error("ISOBMFF: size out of range");
      return -1;
    }

    var name = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(buf, i + 4);

    if (name === wantedName) {
      if (i + size <= len) {
        return i;
      }

      _log__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].error("ISOBMFF: box out of range");
      return -1;
    }

    i += size;
  }

  return -1;
}
/**
 * Parse the sidx part (segment index) of the isobmff.
 * Returns null if not found.
 *
 * @param {Uint8Array} buf
 * @param {Number} initialOffset
 * @returns {Object|null} {Array.<Object>} - Information about each subsegment.
 * Contains those keys:
 *   - time {Number}: starting _presentation time_ for the subsegment,
 *     timescaled
 *   - duration {Number}: duration of the subsegment, timescaled
 *   - timescale {Number}: the timescale in which the time and duration are set
 *   - count {Number}: always at 0
 *   - range {Array.<Number>}: first and last bytes in the media file
 *     from the anchor point (first byte after the sidx box) for the
 *     concerned subsegment.
 */


function getSegmentsFromSidx(buf, initialOffset) {
  var index = findBox(buf, 0x73696478
  /* "sidx" */
  );

  if (index === -1) {
    return null;
  }

  var offset = initialOffset;
  var size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(buf, index);
  var pos = index +
  /* size */
  4 +
  /* name */
  4;
  /* version(8) */

  /* flags(24) */

  /* reference_ID(32); */

  /* timescale(32); */

  var version = buf[pos];
  pos += 4 + 4;
  var timescale = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(buf, pos);
  pos += 4;
  /* earliest_presentation_time(32 / 64) */

  /* first_offset(32 / 64) */

  var time;

  if (version === 0) {
    time = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(buf, pos);
    pos += 4;
    offset += Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(buf, pos) + size;
    pos += 4;
  } else if (version === 1) {
    time = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be8toi */ "d"])(buf, pos);
    pos += 8;
    offset += Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be8toi */ "d"])(buf, pos) + size;
    pos += 8;
  } else {
    return null;
  }

  var segments = [];
  /* reserved(16) */

  /* reference_count(16) */

  pos += 2;
  var count = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be2toi */ "a"])(buf, pos);
  pos += 2;

  while (--count >= 0) {
    /* reference_type(1) */

    /* reference_size(31) */

    /* segment_duration(32) */

    /* sap..(32) */
    var refChunk = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(buf, pos);
    pos += 4;
    var refType = (refChunk & 0x80000000) >>> 31;
    var refSize = refChunk & 0x7FFFFFFF; // when set to 1 indicates that the reference is to a sidx, else to media

    if (refType === 1) {
      throw new Error("sidx with reference_type `1` not yet implemented");
    }

    var duration = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(buf, pos);
    pos += 4; // let sapChunk = be4toi(buf, pos + 8);

    pos += 4; // TODO(pierre): handle sap
    // let startsWithSap = (sapChunk & 0x80000000) >>> 31;
    // let sapType = (sapChunk & 0x70000000) >>> 28;
    // let sapDelta = sapChunk & 0x0FFFFFFF;

    segments.push({
      time: time,
      duration: duration,
      count: 0,
      timescale: timescale,
      range: [offset, offset + refSize - 1]
    });
    time += duration;
    offset += refSize;
  }

  return segments;
}
/**
 * Parse track Fragment Decode Time to get a precize initial time for this
 * segment (in the media timescale).
 * Stops at the first tfdt encountered from the beginning of the file.
 * Returns this time. -1 if not found.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */


function getTrackFragmentDecodeTime(buffer) {
  var traf = Object(_read__WEBPACK_IMPORTED_MODULE_4__[/* getTRAF */ "c"])(buffer);

  if (traf === null) {
    return -1;
  }

  var index = findBox(traf, 0x74666474
  /* tfdt */
  );

  if (index === -1) {
    return -1;
  }

  var pos = index +
  /* size */
  4 +
  /* name */
  4;
  var version = traf[pos];
  pos += 4;

  if (version > 1) {
    return -1;
  }

  return version !== 0 ? Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be8toi */ "d"])(traf, pos) : Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(traf, pos);
}
/**
 * @param {Uint8Array} traf
 * @returns {number}
 */


function getDefaultDurationFromTFHDInTRAF(traf) {
  var index = findBox(traf, 0x74666864
  /* tfhd */
  );

  if (index === -1) {
    return -1;
  }

  var pos = index +
  /* size */
  4 +
  /* name */
  4 +
  /* version */
  1;
  var flags = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be3toi */ "b"])(traf, pos);
  pos += 3;
  var hasBaseDataOffset = flags & 0x000001;
  var hasSampleDescriptionIndex = flags & 0x000002;
  var hasDefaultSampleDuration = flags & 0x000008;

  if (hasDefaultSampleDuration === 0) {
    return -1;
  }

  pos += 4;

  if (hasBaseDataOffset !== 0) {
    pos += 8;
  }

  if (hasSampleDescriptionIndex !== 0) {
    pos += 4;
  }

  var defaultDuration = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(traf, pos);
  return defaultDuration;
}
/**
 * @param {Uint8Array} buffer
 * @returns {number}
 */


function getDurationFromTrun(buffer) {
  var traf = Object(_read__WEBPACK_IMPORTED_MODULE_4__[/* getTRAF */ "c"])(buffer);

  if (traf === null) {
    return -1;
  }

  var index = findBox(traf, 0x7472756E
  /* trun */
  );

  if (index === -1) {
    return -1;
  }

  var pos = index +
  /* size */
  4 +
  /* name */
  4;
  var version = traf[pos];
  pos += 1;

  if (version > 1) {
    return -1;
  }

  var flags = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be3toi */ "b"])(traf, pos);
  pos += 3;
  var hasSampleDuration = flags & 0x000100;
  var defaultDuration = 0;

  if (hasSampleDuration === 0) {
    defaultDuration = getDefaultDurationFromTFHDInTRAF(traf);

    if (defaultDuration < 0) {
      return -1;
    }
  }

  var hasDataOffset = flags & 0x000001;
  var hasFirstSampleFlags = flags & 0x000004;
  var hasSampleSize = flags & 0x000200;
  var hasSampleFlags = flags & 0x000400;
  var hasSampleCompositionOffset = flags & 0x000800;
  var sampleCounts = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(traf, pos);
  pos += 4;

  if (hasDataOffset !== 0) {
    pos += 4;
  }

  if (hasFirstSampleFlags !== 0) {
    pos += 4;
  }

  var i = sampleCounts;
  var duration = 0;

  while (i-- > 0) {
    if (hasSampleDuration !== 0) {
      duration += Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(traf, pos);
      pos += 4;
    } else {
      duration += defaultDuration;
    }

    if (hasSampleSize !== 0) {
      pos += 4;
    }

    if (hasSampleFlags !== 0) {
      pos += 4;
    }

    if (hasSampleCompositionOffset !== 0) {
      pos += 4;
    }
  }

  return duration;
}
/**
 * Get various information from a movie header box. Found in init segments.
 * null if not found or not parsed.
 *
 * This timescale is the default timescale used for segments.
 * @param {Uint8Array} buffer
 * @returns {Number}
 */


function getMDHDTimescale(buffer) {
  var mdia = Object(_read__WEBPACK_IMPORTED_MODULE_4__[/* getMDIA */ "b"])(buffer);

  if (mdia === null) {
    return -1;
  }

  var index = findBox(mdia, 0x6D646864
  /* "mdhd" */
  );

  if (index === -1) {
    return -1;
  }

  var pos = index +
  /* size */
  4 +
  /* name */
  4;
  var version = mdia[pos];
  pos += 4;

  if (version === 1) {
    pos += 16;
    return Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(mdia, pos);
  } else if (version === 0) {
    pos += 8;
    return Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(mdia, pos);
  } else {
    return -1;
  }
}
/**
 * Returns a PSSH box from a systemId and private data.
 * @param {Array.<Object>} pssList - The content protections under the form of
 * object containing two properties:
 *   - systemId {string}: The uuid code. Should only contain 32 hexadecimal
 *     numbers and hyphens
 *   - privateData {Uint8Array} private data associated.
 * @returns {Uint8Array}
 */


function createPssh(_ref) {
  var systemId = _ref.systemId,
      privateData = _ref.privateData;

  var _systemId = systemId.replace(/-/g, "");

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__[/* default */ "b"])(_systemId.length === 32);
  return Object(_create_box__WEBPACK_IMPORTED_MODULE_3__[/* createBox */ "a"])("pssh", Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* concat */ "h"])(4, // 4 initial zeroed bytes
  Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* hexToBytes */ "j"])(_systemId), Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* itobe4 */ "m"])(privateData.length), privateData));
}
/**
 * Update ISOBMFF given to add a "pssh" box in the "moov" box for every content
 * protection in the pssList array given.
 * @param {Uint8Array} buf - the ISOBMFF file
 * @param {Array.<Object>} pssList - The content protections under the form of
 * objects containing two properties:
 *   - systemId {string}: The uuid code. Should only contain 32 hexadecimal
 *     numbers and hyphens
 *   - privateData {Uint8Array} private data associated.
 * @returns {Uint8Array} - The new ISOBMFF generated.
 */


function patchPssh(buf, pssList) {
  if (pssList == null || pssList.length === 0) {
    return buf;
  }

  var pos = findBox(buf, 0x6D6F6F76
  /* = "moov" */
  );

  if (pos === -1) {
    return buf;
  }

  var size = Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* be4toi */ "c"])(buf, pos); // size of the "moov" box

  var moov = buf.subarray(pos, pos + size);
  var moovArr = [moov];

  for (var i = 0; i < pssList.length; i++) {
    moovArr.push(createPssh(pssList[i]));
  }

  var newmoov = _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* concat */ "h"].apply(void 0, moovArr);
  newmoov.set(Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* itobe4 */ "m"])(newmoov.length), 0); // overwrite "moov" length

  return Object(_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_2__[/* concat */ "h"])(buf.subarray(0, pos), newmoov, buf.subarray(pos + size));
}



/***/ }),
/* 222 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return scan; });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
var ScanOperator = /*@__PURE__*/ (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = /*@__PURE__*/ (function (_super) {
    tslib__WEBPACK_IMPORTED_MODULE_0__[/* __extends */ "a"](ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__[/* Subscriber */ "a"]));
//# sourceMappingURL=scan.js.map


/***/ }),
/* 223 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return switchMapTo; });
/* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(136);
/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

function switchMapTo(innerObservable, resultSelector) {
    return resultSelector ? Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__[/* switchMap */ "a"])(function () { return innerObservable; }, resultSelector) : Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__[/* switchMap */ "a"])(function () { return innerObservable; });
}
//# sourceMappingURL=switchMapTo.js.map


/***/ })
/******/ ])["default"];
});