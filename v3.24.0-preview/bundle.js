/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 42281:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*!
 * Chart.js v2.9.4
 * https://www.chartjs.org
 * (c) 2020 Chart.js Contributors
 * Released under the MIT License
 */
(function (global, factory) {
   true ? module.exports = factory(function () {
    try {
      return __webpack_require__(74329);
    } catch (e) {}
  }()) : 0;
})(this, function (moment) {
  'use strict';

  moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;

  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace(n) {
    return n && n['default'] || n;
  }

  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  var conversions = createCommonjsModule(function (module) {
    /* MIT license */
    // NOTE: conversions should only return primitive values (i.e. arrays, or
    //       values that give correct `typeof` results).
    //       do not use box values types (i.e. Number(), String(), etc.)
    var reverseKeywords = {};

    for (var key in colorName) {
      if (colorName.hasOwnProperty(key)) {
        reverseKeywords[colorName[key]] = key;
      }
    }

    var convert = module.exports = {
      rgb: {
        channels: 3,
        labels: 'rgb'
      },
      hsl: {
        channels: 3,
        labels: 'hsl'
      },
      hsv: {
        channels: 3,
        labels: 'hsv'
      },
      hwb: {
        channels: 3,
        labels: 'hwb'
      },
      cmyk: {
        channels: 4,
        labels: 'cmyk'
      },
      xyz: {
        channels: 3,
        labels: 'xyz'
      },
      lab: {
        channels: 3,
        labels: 'lab'
      },
      lch: {
        channels: 3,
        labels: 'lch'
      },
      hex: {
        channels: 1,
        labels: ['hex']
      },
      keyword: {
        channels: 1,
        labels: ['keyword']
      },
      ansi16: {
        channels: 1,
        labels: ['ansi16']
      },
      ansi256: {
        channels: 1,
        labels: ['ansi256']
      },
      hcg: {
        channels: 3,
        labels: ['h', 'c', 'g']
      },
      apple: {
        channels: 3,
        labels: ['r16', 'g16', 'b16']
      },
      gray: {
        channels: 1,
        labels: ['gray']
      }
    }; // hide .channels and .labels properties

    for (var model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!('channels' in convert[model])) {
          throw new Error('missing channels property: ' + model);
        }

        if (!('labels' in convert[model])) {
          throw new Error('missing channel labels property: ' + model);
        }

        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error('channel and label counts mismatch: ' + model);
        }

        var channels = convert[model].channels;
        var labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], 'channels', {
          value: channels
        });
        Object.defineProperty(convert[model], 'labels', {
          value: labels
        });
      }
    }

    convert.rgb.hsl = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;

      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      l = (min + max) / 2;

      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100];
    };

    convert.rgb.hsv = function (rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);

      var diffc = function diffc(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };

      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);

        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }

        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }

      return [h * 360, s * 100, v * 100];
    };

    convert.rgb.hwb = function (rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };

    convert.rgb.cmyk = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    /**
     * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
     * */


    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }

    convert.rgb.keyword = function (rgb) {
      var reversed = reverseKeywords[rgb];

      if (reversed) {
        return reversed;
      }

      var currentClosestDistance = Infinity;
      var currentClosestKeyword;

      for (var keyword in colorName) {
        if (colorName.hasOwnProperty(keyword)) {
          var value = colorName[keyword]; // Compute comparative distance

          var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest

          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }

      return currentClosestKeyword;
    };

    convert.keyword.rgb = function (keyword) {
      return colorName[keyword];
    };

    convert.rgb.xyz = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255; // assume sRGB

      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };

    convert.rgb.lab = function (rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };

    convert.hsl.rgb = function (hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;

      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);

        if (t3 < 0) {
          t3++;
        }

        if (t3 > 1) {
          t3--;
        }

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    };

    convert.hsl.hsv = function (hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };

    convert.hsv.rgb = function (hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;

      switch (hi) {
        case 0:
          return [v, t, p];

        case 1:
          return [q, v, p];

        case 2:
          return [p, v, t];

        case 3:
          return [p, q, v];

        case 4:
          return [t, p, v];

        case 5:
          return [v, p, q];
      }
    };

    convert.hsv.hsl = function (hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    }; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


    convert.hwb.rgb = function (hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n; // wh + bl cant be > 1

      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }

      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;

      if ((i & 0x01) !== 0) {
        f = 1 - f;
      }

      n = wh + f * (v - wh); // linear interpolation

      var r;
      var g;
      var b;

      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;

        case 1:
          r = n;
          g = v;
          b = wh;
          break;

        case 2:
          r = wh;
          g = v;
          b = n;
          break;

        case 3:
          r = wh;
          g = n;
          b = v;
          break;

        case 4:
          r = n;
          g = wh;
          b = v;
          break;

        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }

      return [r * 255, g * 255, b * 255];
    };

    convert.cmyk.rgb = function (cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };

    convert.xyz.rgb = function (xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };

    convert.xyz.lab = function (xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };

    convert.lab.xyz = function (lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };

    convert.lab.lch = function (lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;

      if (h < 0) {
        h += 360;
      }

      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };

    convert.lch.lab = function (lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };

    convert.rgb.ansi16 = function (args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

      value = Math.round(value / 50);

      if (value === 0) {
        return 30;
      }

      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

      if (value === 2) {
        ansi += 60;
      }

      return ansi;
    };

    convert.hsv.ansi16 = function (args) {
      // optimization here; we already know the value and don't need to get
      // it converted for us.
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };

    convert.rgb.ansi256 = function (args) {
      var r = args[0];
      var g = args[1];
      var b = args[2]; // we use the extended greyscale palette here, with the exception of
      // black and white. normal palette only has 4 greyscale shades.

      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }

        if (r > 248) {
          return 231;
        }

        return Math.round((r - 8) / 247 * 24) + 232;
      }

      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };

    convert.ansi16.rgb = function (args) {
      var color = args % 10; // handle greyscale

      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }

        color = color / 10.5 * 255;
        return [color, color, color];
      }

      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };

    convert.ansi256.rgb = function (args) {
      // handle greyscale
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }

      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };

    convert.rgb.hex = function (args) {
      var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
      var string = integer.toString(16).toUpperCase();
      return '000000'.substring(string.length) + string;
    };

    convert.hex.rgb = function (args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

      if (!match) {
        return [0, 0, 0];
      }

      var colorString = match[0];

      if (match[0].length === 3) {
        colorString = colorString.split('').map(function (_char) {
          return _char + _char;
        }).join('');
      }

      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 0xFF;
      var g = integer >> 8 & 0xFF;
      var b = integer & 0xFF;
      return [r, g, b];
    };

    convert.rgb.hcg = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;

      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }

      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }

      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };

    convert.hsl.hcg = function (hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;

      if (l < 0.5) {
        c = 2.0 * s * l;
      } else {
        c = 2.0 * s * (1.0 - l);
      }

      if (c < 1.0) {
        f = (l - 0.5 * c) / (1.0 - c);
      }

      return [hsl[0], c * 100, f * 100];
    };

    convert.hsv.hcg = function (hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;

      if (c < 1.0) {
        f = (v - c) / (1 - c);
      }

      return [hsv[0], c * 100, f * 100];
    };

    convert.hcg.rgb = function (hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;

      if (c === 0.0) {
        return [g * 255, g * 255, g * 255];
      }

      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;

      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;

        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;

        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;

        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;

        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;

        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }

      mg = (1.0 - c) * g;
      return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
    };

    convert.hcg.hsv = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      var f = 0;

      if (v > 0.0) {
        f = c / v;
      }

      return [hcg[0], f * 100, v * 100];
    };

    convert.hcg.hsl = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1.0 - c) + 0.5 * c;
      var s = 0;

      if (l > 0.0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1.0) {
        s = c / (2 * (1 - l));
      }

      return [hcg[0], s * 100, l * 100];
    };

    convert.hcg.hwb = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };

    convert.hwb.hcg = function (hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;

      if (c < 1) {
        g = (v - c) / (1 - c);
      }

      return [hwb[0], c * 100, g * 100];
    };

    convert.apple.rgb = function (apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };

    convert.rgb.apple = function (rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };

    convert.gray.rgb = function (args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };

    convert.gray.hsl = convert.gray.hsv = function (args) {
      return [0, 0, args[0]];
    };

    convert.gray.hwb = function (gray) {
      return [0, 100, gray[0]];
    };

    convert.gray.cmyk = function (gray) {
      return [0, 0, 0, gray[0]];
    };

    convert.gray.lab = function (gray) {
      return [gray[0], 0, 0];
    };

    convert.gray.hex = function (gray) {
      var val = Math.round(gray[0] / 100 * 255) & 0xFF;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return '000000'.substring(string.length) + string;
    };

    convert.rgb.gray = function (rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  });
  var conversions_1 = conversions.rgb;
  var conversions_2 = conversions.hsl;
  var conversions_3 = conversions.hsv;
  var conversions_4 = conversions.hwb;
  var conversions_5 = conversions.cmyk;
  var conversions_6 = conversions.xyz;
  var conversions_7 = conversions.lab;
  var conversions_8 = conversions.lch;
  var conversions_9 = conversions.hex;
  var conversions_10 = conversions.keyword;
  var conversions_11 = conversions.ansi16;
  var conversions_12 = conversions.ansi256;
  var conversions_13 = conversions.hcg;
  var conversions_14 = conversions.apple;
  var conversions_15 = conversions.gray;
  /*
  	this function routes a model to all other models.
  
  	all functions that are routed have a property `.conversion` attached
  	to the returned synthetic function. This property is an array
  	of strings, each with the steps in between the 'from' and 'to'
  	color models (inclusive).
  
  	conversions that are not possible simply are not included.
  */

  function buildGraph() {
    var graph = {}; // https://jsperf.com/object-keys-vs-for-in-with-closure/3

    var models = Object.keys(conversions);

    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    }

    return graph;
  } // https://en.wikipedia.org/wiki/Breadth-first_search


  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel]; // unshift -> queue -> pop

    graph[fromModel].distance = 0;

    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);

      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];

        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }

    return graph;
  }

  function link(from, to) {
    return function (args) {
      return to(from(args));
    };
  }

  function wrapConversion(toModel, graph) {
    var path = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;

    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }

    fn.conversion = path;
    return fn;
  }

  var route = function route(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);

    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];

      if (node.parent === null) {
        // no possible conversion, or this node is the source model.
        continue;
      }

      conversion[toModel] = wrapConversion(toModel, graph);
    }

    return conversion;
  };

  var convert = {};
  var models = Object.keys(conversions);

  function wrapRaw(fn) {
    var wrappedFn = function wrappedFn(args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      return fn(args);
    }; // preserve .conversion property if there is one


    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  function wrapRounded(fn) {
    var wrappedFn = function wrappedFn(args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      var result = fn(args); // we're assuming the result is an array here.
      // see notice in conversions.js; don't use box types
      // in conversion functions.

      if (typeof result === 'object') {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }

      return result;
    }; // preserve .conversion property if there is one


    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  models.forEach(function (fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {
      value: conversions[fromModel].channels
    });
    Object.defineProperty(convert[fromModel], 'labels', {
      value: conversions[fromModel].labels
    });
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function (toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  var colorConvert = convert;
  var colorName$1 = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };
  /* MIT license */

  var colorString = {
    getRgba: getRgba,
    getHsla: getHsla,
    getRgb: getRgb,
    getHsl: getHsl,
    getHwb: getHwb,
    getAlpha: getAlpha,
    hexString: hexString,
    rgbString: rgbString,
    rgbaString: rgbaString,
    percentString: percentString,
    percentaString: percentaString,
    hslString: hslString,
    hslaString: hslaString,
    hwbString: hwbString,
    keyword: keyword
  };

  function getRgba(string) {
    if (!string) {
      return;
    }

    var abbr = /^#([a-fA-F0-9]{3,4})$/i,
        hex = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
        rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
        per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
        keyword = /(\w+)/;
    var rgb = [0, 0, 0],
        a = 1,
        match = string.match(abbr),
        hexAlpha = "";

    if (match) {
      match = match[1];
      hexAlpha = match[3];

      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = parseInt(match[i] + match[i], 16);
      }

      if (hexAlpha) {
        a = Math.round(parseInt(hexAlpha + hexAlpha, 16) / 255 * 100) / 100;
      }
    } else if (match = string.match(hex)) {
      hexAlpha = match[2];
      match = match[1];

      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
      }

      if (hexAlpha) {
        a = Math.round(parseInt(hexAlpha, 16) / 255 * 100) / 100;
      }
    } else if (match = string.match(rgba)) {
      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = parseInt(match[i + 1]);
      }

      a = parseFloat(match[4]);
    } else if (match = string.match(per)) {
      for (var i = 0; i < rgb.length; i++) {
        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
      }

      a = parseFloat(match[4]);
    } else if (match = string.match(keyword)) {
      if (match[1] == "transparent") {
        return [0, 0, 0, 0];
      }

      rgb = colorName$1[match[1]];

      if (!rgb) {
        return;
      }
    }

    for (var i = 0; i < rgb.length; i++) {
      rgb[i] = scale(rgb[i], 0, 255);
    }

    if (!a && a != 0) {
      a = 1;
    } else {
      a = scale(a, 0, 1);
    }

    rgb[3] = a;
    return rgb;
  }

  function getHsla(string) {
    if (!string) {
      return;
    }

    var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
    var match = string.match(hsl);

    if (match) {
      var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
          s = scale(parseFloat(match[2]), 0, 100),
          l = scale(parseFloat(match[3]), 0, 100),
          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, s, l, a];
    }
  }

  function getHwb(string) {
    if (!string) {
      return;
    }

    var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
    var match = string.match(hwb);

    if (match) {
      var alpha = parseFloat(match[4]);
      var h = scale(parseInt(match[1]), 0, 360),
          w = scale(parseFloat(match[2]), 0, 100),
          b = scale(parseFloat(match[3]), 0, 100),
          a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
      return [h, w, b, a];
    }
  }

  function getRgb(string) {
    var rgba = getRgba(string);
    return rgba && rgba.slice(0, 3);
  }

  function getHsl(string) {
    var hsla = getHsla(string);
    return hsla && hsla.slice(0, 3);
  }

  function getAlpha(string) {
    var vals = getRgba(string);

    if (vals) {
      return vals[3];
    } else if (vals = getHsla(string)) {
      return vals[3];
    } else if (vals = getHwb(string)) {
      return vals[3];
    }
  } // generators


  function hexString(rgba, a) {
    var a = a !== undefined && rgba.length === 3 ? a : rgba[3];
    return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (a >= 0 && a < 1 ? hexDouble(Math.round(a * 255)) : "");
  }

  function rgbString(rgba, alpha) {
    if (alpha < 1 || rgba[3] && rgba[3] < 1) {
      return rgbaString(rgba, alpha);
    }

    return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
  }

  function rgbaString(rgba, alpha) {
    if (alpha === undefined) {
      alpha = rgba[3] !== undefined ? rgba[3] : 1;
    }

    return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ", " + alpha + ")";
  }

  function percentString(rgba, alpha) {
    if (alpha < 1 || rgba[3] && rgba[3] < 1) {
      return percentaString(rgba, alpha);
    }

    var r = Math.round(rgba[0] / 255 * 100),
        g = Math.round(rgba[1] / 255 * 100),
        b = Math.round(rgba[2] / 255 * 100);
    return "rgb(" + r + "%, " + g + "%, " + b + "%)";
  }

  function percentaString(rgba, alpha) {
    var r = Math.round(rgba[0] / 255 * 100),
        g = Math.round(rgba[1] / 255 * 100),
        b = Math.round(rgba[2] / 255 * 100);
    return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
  }

  function hslString(hsla, alpha) {
    if (alpha < 1 || hsla[3] && hsla[3] < 1) {
      return hslaString(hsla, alpha);
    }

    return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
  }

  function hslaString(hsla, alpha) {
    if (alpha === undefined) {
      alpha = hsla[3] !== undefined ? hsla[3] : 1;
    }

    return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + alpha + ")";
  } // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
  // (hwb have alpha optional & 1 is default value)


  function hwbString(hwb, alpha) {
    if (alpha === undefined) {
      alpha = hwb[3] !== undefined ? hwb[3] : 1;
    }

    return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%" + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
  }

  function keyword(rgb) {
    return reverseNames[rgb.slice(0, 3)];
  } // helpers


  function scale(num, min, max) {
    return Math.min(Math.max(min, num), max);
  }

  function hexDouble(num) {
    var str = num.toString(16).toUpperCase();
    return str.length < 2 ? "0" + str : str;
  } //create a list of reverse color names


  var reverseNames = {};

  for (var name in colorName$1) {
    reverseNames[colorName$1[name]] = name;
  }
  /* MIT license */


  var Color = function Color(obj) {
    if (obj instanceof Color) {
      return obj;
    }

    if (!(this instanceof Color)) {
      return new Color(obj);
    }

    this.valid = false;
    this.values = {
      rgb: [0, 0, 0],
      hsl: [0, 0, 0],
      hsv: [0, 0, 0],
      hwb: [0, 0, 0],
      cmyk: [0, 0, 0, 0],
      alpha: 1
    }; // parse Color() argument

    var vals;

    if (typeof obj === 'string') {
      vals = colorString.getRgba(obj);

      if (vals) {
        this.setValues('rgb', vals);
      } else if (vals = colorString.getHsla(obj)) {
        this.setValues('hsl', vals);
      } else if (vals = colorString.getHwb(obj)) {
        this.setValues('hwb', vals);
      }
    } else if (typeof obj === 'object') {
      vals = obj;

      if (vals.r !== undefined || vals.red !== undefined) {
        this.setValues('rgb', vals);
      } else if (vals.l !== undefined || vals.lightness !== undefined) {
        this.setValues('hsl', vals);
      } else if (vals.v !== undefined || vals.value !== undefined) {
        this.setValues('hsv', vals);
      } else if (vals.w !== undefined || vals.whiteness !== undefined) {
        this.setValues('hwb', vals);
      } else if (vals.c !== undefined || vals.cyan !== undefined) {
        this.setValues('cmyk', vals);
      }
    }
  };

  Color.prototype = {
    isValid: function isValid() {
      return this.valid;
    },
    rgb: function rgb() {
      return this.setSpace('rgb', arguments);
    },
    hsl: function hsl() {
      return this.setSpace('hsl', arguments);
    },
    hsv: function hsv() {
      return this.setSpace('hsv', arguments);
    },
    hwb: function hwb() {
      return this.setSpace('hwb', arguments);
    },
    cmyk: function cmyk() {
      return this.setSpace('cmyk', arguments);
    },
    rgbArray: function rgbArray() {
      return this.values.rgb;
    },
    hslArray: function hslArray() {
      return this.values.hsl;
    },
    hsvArray: function hsvArray() {
      return this.values.hsv;
    },
    hwbArray: function hwbArray() {
      var values = this.values;

      if (values.alpha !== 1) {
        return values.hwb.concat([values.alpha]);
      }

      return values.hwb;
    },
    cmykArray: function cmykArray() {
      return this.values.cmyk;
    },
    rgbaArray: function rgbaArray() {
      var values = this.values;
      return values.rgb.concat([values.alpha]);
    },
    hslaArray: function hslaArray() {
      var values = this.values;
      return values.hsl.concat([values.alpha]);
    },
    alpha: function alpha(val) {
      if (val === undefined) {
        return this.values.alpha;
      }

      this.setValues('alpha', val);
      return this;
    },
    red: function red(val) {
      return this.setChannel('rgb', 0, val);
    },
    green: function green(val) {
      return this.setChannel('rgb', 1, val);
    },
    blue: function blue(val) {
      return this.setChannel('rgb', 2, val);
    },
    hue: function hue(val) {
      if (val) {
        val %= 360;
        val = val < 0 ? 360 + val : val;
      }

      return this.setChannel('hsl', 0, val);
    },
    saturation: function saturation(val) {
      return this.setChannel('hsl', 1, val);
    },
    lightness: function lightness(val) {
      return this.setChannel('hsl', 2, val);
    },
    saturationv: function saturationv(val) {
      return this.setChannel('hsv', 1, val);
    },
    whiteness: function whiteness(val) {
      return this.setChannel('hwb', 1, val);
    },
    blackness: function blackness(val) {
      return this.setChannel('hwb', 2, val);
    },
    value: function value(val) {
      return this.setChannel('hsv', 2, val);
    },
    cyan: function cyan(val) {
      return this.setChannel('cmyk', 0, val);
    },
    magenta: function magenta(val) {
      return this.setChannel('cmyk', 1, val);
    },
    yellow: function yellow(val) {
      return this.setChannel('cmyk', 2, val);
    },
    black: function black(val) {
      return this.setChannel('cmyk', 3, val);
    },
    hexString: function hexString() {
      return colorString.hexString(this.values.rgb);
    },
    rgbString: function rgbString() {
      return colorString.rgbString(this.values.rgb, this.values.alpha);
    },
    rgbaString: function rgbaString() {
      return colorString.rgbaString(this.values.rgb, this.values.alpha);
    },
    percentString: function percentString() {
      return colorString.percentString(this.values.rgb, this.values.alpha);
    },
    hslString: function hslString() {
      return colorString.hslString(this.values.hsl, this.values.alpha);
    },
    hslaString: function hslaString() {
      return colorString.hslaString(this.values.hsl, this.values.alpha);
    },
    hwbString: function hwbString() {
      return colorString.hwbString(this.values.hwb, this.values.alpha);
    },
    keyword: function keyword() {
      return colorString.keyword(this.values.rgb, this.values.alpha);
    },
    rgbNumber: function rgbNumber() {
      var rgb = this.values.rgb;
      return rgb[0] << 16 | rgb[1] << 8 | rgb[2];
    },
    luminosity: function luminosity() {
      // http://www.w3.org/TR/WCAG20/#relativeluminancedef
      var rgb = this.values.rgb;
      var lum = [];

      for (var i = 0; i < rgb.length; i++) {
        var chan = rgb[i] / 255;
        lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
      }

      return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    },
    contrast: function contrast(color2) {
      // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
      var lum1 = this.luminosity();
      var lum2 = color2.luminosity();

      if (lum1 > lum2) {
        return (lum1 + 0.05) / (lum2 + 0.05);
      }

      return (lum2 + 0.05) / (lum1 + 0.05);
    },
    level: function level(color2) {
      var contrastRatio = this.contrast(color2);

      if (contrastRatio >= 7.1) {
        return 'AAA';
      }

      return contrastRatio >= 4.5 ? 'AA' : '';
    },
    dark: function dark() {
      // YIQ equation from http://24ways.org/2010/calculating-color-contrast
      var rgb = this.values.rgb;
      var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
      return yiq < 128;
    },
    light: function light() {
      return !this.dark();
    },
    negate: function negate() {
      var rgb = [];

      for (var i = 0; i < 3; i++) {
        rgb[i] = 255 - this.values.rgb[i];
      }

      this.setValues('rgb', rgb);
      return this;
    },
    lighten: function lighten(ratio) {
      var hsl = this.values.hsl;
      hsl[2] += hsl[2] * ratio;
      this.setValues('hsl', hsl);
      return this;
    },
    darken: function darken(ratio) {
      var hsl = this.values.hsl;
      hsl[2] -= hsl[2] * ratio;
      this.setValues('hsl', hsl);
      return this;
    },
    saturate: function saturate(ratio) {
      var hsl = this.values.hsl;
      hsl[1] += hsl[1] * ratio;
      this.setValues('hsl', hsl);
      return this;
    },
    desaturate: function desaturate(ratio) {
      var hsl = this.values.hsl;
      hsl[1] -= hsl[1] * ratio;
      this.setValues('hsl', hsl);
      return this;
    },
    whiten: function whiten(ratio) {
      var hwb = this.values.hwb;
      hwb[1] += hwb[1] * ratio;
      this.setValues('hwb', hwb);
      return this;
    },
    blacken: function blacken(ratio) {
      var hwb = this.values.hwb;
      hwb[2] += hwb[2] * ratio;
      this.setValues('hwb', hwb);
      return this;
    },
    greyscale: function greyscale() {
      var rgb = this.values.rgb; // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale

      var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
      this.setValues('rgb', [val, val, val]);
      return this;
    },
    clearer: function clearer(ratio) {
      var alpha = this.values.alpha;
      this.setValues('alpha', alpha - alpha * ratio);
      return this;
    },
    opaquer: function opaquer(ratio) {
      var alpha = this.values.alpha;
      this.setValues('alpha', alpha + alpha * ratio);
      return this;
    },
    rotate: function rotate(degrees) {
      var hsl = this.values.hsl;
      var hue = (hsl[0] + degrees) % 360;
      hsl[0] = hue < 0 ? 360 + hue : hue;
      this.setValues('hsl', hsl);
      return this;
    },

    /**
     * Ported from sass implementation in C
     * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
     */
    mix: function mix(mixinColor, weight) {
      var color1 = this;
      var color2 = mixinColor;
      var p = weight === undefined ? 0.5 : weight;
      var w = 2 * p - 1;
      var a = color1.alpha() - color2.alpha();
      var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
      var w2 = 1 - w1;
      return this.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue()).alpha(color1.alpha() * p + color2.alpha() * (1 - p));
    },
    toJSON: function toJSON() {
      return this.rgb();
    },
    clone: function clone() {
      // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
      // making the final build way to big to embed in Chart.js. So let's do it manually,
      // assuming that values to clone are 1 dimension arrays containing only numbers,
      // except 'alpha' which is a number.
      var result = new Color();
      var source = this.values;
      var target = result.values;
      var value, type;

      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          value = source[prop];
          type = {}.toString.call(value);

          if (type === '[object Array]') {
            target[prop] = value.slice(0);
          } else if (type === '[object Number]') {
            target[prop] = value;
          } else {
            console.error('unexpected color value:', value);
          }
        }
      }

      return result;
    }
  };
  Color.prototype.spaces = {
    rgb: ['red', 'green', 'blue'],
    hsl: ['hue', 'saturation', 'lightness'],
    hsv: ['hue', 'saturation', 'value'],
    hwb: ['hue', 'whiteness', 'blackness'],
    cmyk: ['cyan', 'magenta', 'yellow', 'black']
  };
  Color.prototype.maxes = {
    rgb: [255, 255, 255],
    hsl: [360, 100, 100],
    hsv: [360, 100, 100],
    hwb: [360, 100, 100],
    cmyk: [100, 100, 100, 100]
  };

  Color.prototype.getValues = function (space) {
    var values = this.values;
    var vals = {};

    for (var i = 0; i < space.length; i++) {
      vals[space.charAt(i)] = values[space][i];
    }

    if (values.alpha !== 1) {
      vals.a = values.alpha;
    } // {r: 255, g: 255, b: 255, a: 0.4}


    return vals;
  };

  Color.prototype.setValues = function (space, vals) {
    var values = this.values;
    var spaces = this.spaces;
    var maxes = this.maxes;
    var alpha = 1;
    var i;
    this.valid = true;

    if (space === 'alpha') {
      alpha = vals;
    } else if (vals.length) {
      // [10, 10, 10]
      values[space] = vals.slice(0, space.length);
      alpha = vals[space.length];
    } else if (vals[space.charAt(0)] !== undefined) {
      // {r: 10, g: 10, b: 10}
      for (i = 0; i < space.length; i++) {
        values[space][i] = vals[space.charAt(i)];
      }

      alpha = vals.a;
    } else if (vals[spaces[space][0]] !== undefined) {
      // {red: 10, green: 10, blue: 10}
      var chans = spaces[space];

      for (i = 0; i < space.length; i++) {
        values[space][i] = vals[chans[i]];
      }

      alpha = vals.alpha;
    }

    values.alpha = Math.max(0, Math.min(1, alpha === undefined ? values.alpha : alpha));

    if (space === 'alpha') {
      return false;
    }

    var capped; // cap values of the space prior converting all values

    for (i = 0; i < space.length; i++) {
      capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
      values[space][i] = Math.round(capped);
    } // convert to all the other color spaces


    for (var sname in spaces) {
      if (sname !== space) {
        values[sname] = colorConvert[space][sname](values[space]);
      }
    }

    return true;
  };

  Color.prototype.setSpace = function (space, args) {
    var vals = args[0];

    if (vals === undefined) {
      // color.rgb()
      return this.getValues(space);
    } // color.rgb(10, 10, 10)


    if (typeof vals === 'number') {
      vals = Array.prototype.slice.call(args);
    }

    this.setValues(space, vals);
    return this;
  };

  Color.prototype.setChannel = function (space, index, val) {
    var svalues = this.values[space];

    if (val === undefined) {
      // color.red()
      return svalues[index];
    } else if (val === svalues[index]) {
      // color.red(color.red())
      return this;
    } // color.red(100)


    svalues[index] = val;
    this.setValues(space, svalues);
    return this;
  };

  if (typeof window !== 'undefined') {
    window.Color = Color;
  }

  var chartjsColor = Color;

  function isValidKey(key) {
    return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;
  }
  /**
   * @namespace Chart.helpers
   */


  var helpers = {
    /**
     * An empty function that can be used, for example, for optional callback.
     */
    noop: function noop() {},

    /**
     * Returns a unique id, sequentially generated from a global variable.
     * @returns {number}
     * @function
     */
    uid: function () {
      var id = 0;
      return function () {
        return id++;
      };
    }(),

    /**
     * Returns true if `value` is neither null nor undefined, else returns false.
     * @param {*} value - The value to test.
     * @returns {boolean}
     * @since 2.7.0
     */
    isNullOrUndef: function isNullOrUndef(value) {
      return value === null || typeof value === 'undefined';
    },

    /**
     * Returns true if `value` is an array (including typed arrays), else returns false.
     * @param {*} value - The value to test.
     * @returns {boolean}
     * @function
     */
    isArray: function isArray(value) {
      if (Array.isArray && Array.isArray(value)) {
        return true;
      }

      var type = Object.prototype.toString.call(value);

      if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
        return true;
      }

      return false;
    },

    /**
     * Returns true if `value` is an object (excluding null), else returns false.
     * @param {*} value - The value to test.
     * @returns {boolean}
     * @since 2.7.0
     */
    isObject: function isObject(value) {
      return value !== null && Object.prototype.toString.call(value) === '[object Object]';
    },

    /**
     * Returns true if `value` is a finite number, else returns false
     * @param {*} value  - The value to test.
     * @returns {boolean}
     */
    isFinite: function (_isFinite) {
      function isFinite(_x) {
        return _isFinite.apply(this, arguments);
      }

      isFinite.toString = function () {
        return _isFinite.toString();
      };

      return isFinite;
    }(function (value) {
      return (typeof value === 'number' || value instanceof Number) && isFinite(value);
    }),

    /**
     * Returns `value` if defined, else returns `defaultValue`.
     * @param {*} value - The value to return if defined.
     * @param {*} defaultValue - The value to return if `value` is undefined.
     * @returns {*}
     */
    valueOrDefault: function valueOrDefault(value, defaultValue) {
      return typeof value === 'undefined' ? defaultValue : value;
    },

    /**
     * Returns value at the given `index` in array if defined, else returns `defaultValue`.
     * @param {Array} value - The array to lookup for value at `index`.
     * @param {number} index - The index in `value` to lookup for value.
     * @param {*} defaultValue - The value to return if `value[index]` is undefined.
     * @returns {*}
     */
    valueAtIndexOrDefault: function valueAtIndexOrDefault(value, index, defaultValue) {
      return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
    },

    /**
     * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
     * value returned by `fn`. If `fn` is not a function, this method returns undefined.
     * @param {function} fn - The function to call.
     * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
     * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
     * @returns {*}
     */
    callback: function callback(fn, args, thisArg) {
      if (fn && typeof fn.call === 'function') {
        return fn.apply(thisArg, args);
      }
    },

    /**
     * Note(SB) for performance sake, this method should only be used when loopable type
     * is unknown or in none intensive code (not called often and small loopable). Else
     * it's preferable to use a regular for() loop and save extra function calls.
     * @param {object|Array} loopable - The object or array to be iterated.
     * @param {function} fn - The function to call for each item.
     * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
     * @param {boolean} [reverse] - If true, iterates backward on the loopable.
     */
    each: function each(loopable, fn, thisArg, reverse) {
      var i, len, keys;

      if (helpers.isArray(loopable)) {
        len = loopable.length;

        if (reverse) {
          for (i = len - 1; i >= 0; i--) {
            fn.call(thisArg, loopable[i], i);
          }
        } else {
          for (i = 0; i < len; i++) {
            fn.call(thisArg, loopable[i], i);
          }
        }
      } else if (helpers.isObject(loopable)) {
        keys = Object.keys(loopable);
        len = keys.length;

        for (i = 0; i < len; i++) {
          fn.call(thisArg, loopable[keys[i]], keys[i]);
        }
      }
    },

    /**
     * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
     * @see https://stackoverflow.com/a/14853974
     * @param {Array} a0 - The array to compare
     * @param {Array} a1 - The array to compare
     * @returns {boolean}
     */
    arrayEquals: function arrayEquals(a0, a1) {
      var i, ilen, v0, v1;

      if (!a0 || !a1 || a0.length !== a1.length) {
        return false;
      }

      for (i = 0, ilen = a0.length; i < ilen; ++i) {
        v0 = a0[i];
        v1 = a1[i];

        if (v0 instanceof Array && v1 instanceof Array) {
          if (!helpers.arrayEquals(v0, v1)) {
            return false;
          }
        } else if (v0 !== v1) {
          // NOTE: two different object instances will never be equal: {x:20} != {x:20}
          return false;
        }
      }

      return true;
    },

    /**
     * Returns a deep copy of `source` without keeping references on objects and arrays.
     * @param {*} source - The value to clone.
     * @returns {*}
     */
    clone: function clone(source) {
      if (helpers.isArray(source)) {
        return source.map(helpers.clone);
      }

      if (helpers.isObject(source)) {
        var target = Object.create(source);
        var keys = Object.keys(source);
        var klen = keys.length;
        var k = 0;

        for (; k < klen; ++k) {
          target[keys[k]] = helpers.clone(source[keys[k]]);
        }

        return target;
      }

      return source;
    },

    /**
     * The default merger when Chart.helpers.merge is called without merger option.
     * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
     * @private
     */
    _merger: function _merger(key, target, source, options) {
      if (!isValidKey(key)) {
        // We want to ensure we do not copy prototypes over
        // as this can pollute global namespaces
        return;
      }

      var tval = target[key];
      var sval = source[key];

      if (helpers.isObject(tval) && helpers.isObject(sval)) {
        helpers.merge(tval, sval, options);
      } else {
        target[key] = helpers.clone(sval);
      }
    },

    /**
     * Merges source[key] in target[key] only if target[key] is undefined.
     * @private
     */
    _mergerIf: function _mergerIf(key, target, source) {
      if (!isValidKey(key)) {
        // We want to ensure we do not copy prototypes over
        // as this can pollute global namespaces
        return;
      }

      var tval = target[key];
      var sval = source[key];

      if (helpers.isObject(tval) && helpers.isObject(sval)) {
        helpers.mergeIf(tval, sval);
      } else if (!target.hasOwnProperty(key)) {
        target[key] = helpers.clone(sval);
      }
    },

    /**
     * Recursively deep copies `source` properties into `target` with the given `options`.
     * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
     * @param {object} target - The target object in which all sources are merged into.
     * @param {object|object[]} source - Object(s) to merge into `target`.
     * @param {object} [options] - Merging options:
     * @param {function} [options.merger] - The merge method (key, target, source, options)
     * @returns {object} The `target` object.
     */
    merge: function merge(target, source, options) {
      var sources = helpers.isArray(source) ? source : [source];
      var ilen = sources.length;
      var merge, i, keys, klen, k;

      if (!helpers.isObject(target)) {
        return target;
      }

      options = options || {};
      merge = options.merger || helpers._merger;

      for (i = 0; i < ilen; ++i) {
        source = sources[i];

        if (!helpers.isObject(source)) {
          continue;
        }

        keys = Object.keys(source);

        for (k = 0, klen = keys.length; k < klen; ++k) {
          merge(keys[k], target, source, options);
        }
      }

      return target;
    },

    /**
     * Recursively deep copies `source` properties into `target` *only* if not defined in target.
     * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
     * @param {object} target - The target object in which all sources are merged into.
     * @param {object|object[]} source - Object(s) to merge into `target`.
     * @returns {object} The `target` object.
     */
    mergeIf: function mergeIf(target, source) {
      return helpers.merge(target, source, {
        merger: helpers._mergerIf
      });
    },

    /**
     * Applies the contents of two or more objects together into the first object.
     * @param {object} target - The target object in which all objects are merged into.
     * @param {object} arg1 - Object containing additional properties to merge in target.
     * @param {object} argN - Additional objects containing properties to merge in target.
     * @returns {object} The `target` object.
     */
    extend: Object.assign || function (target) {
      return helpers.merge(target, [].slice.call(arguments, 1), {
        merger: function merger(key, dst, src) {
          dst[key] = src[key];
        }
      });
    },

    /**
     * Basic javascript inheritance based on the model created in Backbone.js
     */
    inherits: function inherits(extensions) {
      var me = this;
      var ChartElement = extensions && extensions.hasOwnProperty('constructor') ? extensions.constructor : function () {
        return me.apply(this, arguments);
      };

      var Surrogate = function Surrogate() {
        this.constructor = ChartElement;
      };

      Surrogate.prototype = me.prototype;
      ChartElement.prototype = new Surrogate();
      ChartElement.extend = helpers.inherits;

      if (extensions) {
        helpers.extend(ChartElement.prototype, extensions);
      }

      ChartElement.__super__ = me.prototype;
      return ChartElement;
    },
    _deprecated: function _deprecated(scope, value, previous, current) {
      if (value !== undefined) {
        console.warn(scope + ': "' + previous + '" is deprecated. Please use "' + current + '" instead');
      }
    }
  };
  var helpers_core = helpers; // DEPRECATIONS

  /**
   * Provided for backward compatibility, use Chart.helpers.callback instead.
   * @function Chart.helpers.callCallback
   * @deprecated since version 2.6.0
   * @todo remove at version 3
   * @private
   */

  helpers.callCallback = helpers.callback;
  /**
   * Provided for backward compatibility, use Array.prototype.indexOf instead.
   * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
   * @function Chart.helpers.indexOf
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */

  helpers.indexOf = function (array, item, fromIndex) {
    return Array.prototype.indexOf.call(array, item, fromIndex);
  };
  /**
   * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
   * @function Chart.helpers.getValueOrDefault
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */


  helpers.getValueOrDefault = helpers.valueOrDefault;
  /**
   * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
   * @function Chart.helpers.getValueAtIndexOrDefault
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */

  helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;
  /**
   * Easing functions adapted from Robert Penner's easing equations.
   * @namespace Chart.helpers.easingEffects
   * @see http://www.robertpenner.com/easing/
   */

  var effects = {
    linear: function linear(t) {
      return t;
    },
    easeInQuad: function easeInQuad(t) {
      return t * t;
    },
    easeOutQuad: function easeOutQuad(t) {
      return -t * (t - 2);
    },
    easeInOutQuad: function easeInOutQuad(t) {
      if ((t /= 0.5) < 1) {
        return 0.5 * t * t;
      }

      return -0.5 * (--t * (t - 2) - 1);
    },
    easeInCubic: function easeInCubic(t) {
      return t * t * t;
    },
    easeOutCubic: function easeOutCubic(t) {
      return (t = t - 1) * t * t + 1;
    },
    easeInOutCubic: function easeInOutCubic(t) {
      if ((t /= 0.5) < 1) {
        return 0.5 * t * t * t;
      }

      return 0.5 * ((t -= 2) * t * t + 2);
    },
    easeInQuart: function easeInQuart(t) {
      return t * t * t * t;
    },
    easeOutQuart: function easeOutQuart(t) {
      return -((t = t - 1) * t * t * t - 1);
    },
    easeInOutQuart: function easeInOutQuart(t) {
      if ((t /= 0.5) < 1) {
        return 0.5 * t * t * t * t;
      }

      return -0.5 * ((t -= 2) * t * t * t - 2);
    },
    easeInQuint: function easeInQuint(t) {
      return t * t * t * t * t;
    },
    easeOutQuint: function easeOutQuint(t) {
      return (t = t - 1) * t * t * t * t + 1;
    },
    easeInOutQuint: function easeInOutQuint(t) {
      if ((t /= 0.5) < 1) {
        return 0.5 * t * t * t * t * t;
      }

      return 0.5 * ((t -= 2) * t * t * t * t + 2);
    },
    easeInSine: function easeInSine(t) {
      return -Math.cos(t * (Math.PI / 2)) + 1;
    },
    easeOutSine: function easeOutSine(t) {
      return Math.sin(t * (Math.PI / 2));
    },
    easeInOutSine: function easeInOutSine(t) {
      return -0.5 * (Math.cos(Math.PI * t) - 1);
    },
    easeInExpo: function easeInExpo(t) {
      return t === 0 ? 0 : Math.pow(2, 10 * (t - 1));
    },
    easeOutExpo: function easeOutExpo(t) {
      return t === 1 ? 1 : -Math.pow(2, -10 * t) + 1;
    },
    easeInOutExpo: function easeInOutExpo(t) {
      if (t === 0) {
        return 0;
      }

      if (t === 1) {
        return 1;
      }

      if ((t /= 0.5) < 1) {
        return 0.5 * Math.pow(2, 10 * (t - 1));
      }

      return 0.5 * (-Math.pow(2, -10 * --t) + 2);
    },
    easeInCirc: function easeInCirc(t) {
      if (t >= 1) {
        return t;
      }

      return -(Math.sqrt(1 - t * t) - 1);
    },
    easeOutCirc: function easeOutCirc(t) {
      return Math.sqrt(1 - (t = t - 1) * t);
    },
    easeInOutCirc: function easeInOutCirc(t) {
      if ((t /= 0.5) < 1) {
        return -0.5 * (Math.sqrt(1 - t * t) - 1);
      }

      return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
    },
    easeInElastic: function easeInElastic(t) {
      var s = 1.70158;
      var p = 0;
      var a = 1;

      if (t === 0) {
        return 0;
      }

      if (t === 1) {
        return 1;
      }

      if (!p) {
        p = 0.3;
      }

      if (a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(1 / a);
      }

      return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
    },
    easeOutElastic: function easeOutElastic(t) {
      var s = 1.70158;
      var p = 0;
      var a = 1;

      if (t === 0) {
        return 0;
      }

      if (t === 1) {
        return 1;
      }

      if (!p) {
        p = 0.3;
      }

      if (a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(1 / a);
      }

      return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
    },
    easeInOutElastic: function easeInOutElastic(t) {
      var s = 1.70158;
      var p = 0;
      var a = 1;

      if (t === 0) {
        return 0;
      }

      if ((t /= 0.5) === 2) {
        return 1;
      }

      if (!p) {
        p = 0.45;
      }

      if (a < 1) {
        a = 1;
        s = p / 4;
      } else {
        s = p / (2 * Math.PI) * Math.asin(1 / a);
      }

      if (t < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
      }

      return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
    },
    easeInBack: function easeInBack(t) {
      var s = 1.70158;
      return t * t * ((s + 1) * t - s);
    },
    easeOutBack: function easeOutBack(t) {
      var s = 1.70158;
      return (t = t - 1) * t * ((s + 1) * t + s) + 1;
    },
    easeInOutBack: function easeInOutBack(t) {
      var s = 1.70158;

      if ((t /= 0.5) < 1) {
        return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
      }

      return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
    },
    easeInBounce: function easeInBounce(t) {
      return 1 - effects.easeOutBounce(1 - t);
    },
    easeOutBounce: function easeOutBounce(t) {
      if (t < 1 / 2.75) {
        return 7.5625 * t * t;
      }

      if (t < 2 / 2.75) {
        return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
      }

      if (t < 2.5 / 2.75) {
        return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
      }

      return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    },
    easeInOutBounce: function easeInOutBounce(t) {
      if (t < 0.5) {
        return effects.easeInBounce(t * 2) * 0.5;
      }

      return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
    }
  };
  var helpers_easing = {
    effects: effects
  }; // DEPRECATIONS

  /**
   * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
   * @function Chart.helpers.easingEffects
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */

  helpers_core.easingEffects = effects;
  var PI = Math.PI;
  var RAD_PER_DEG = PI / 180;
  var DOUBLE_PI = PI * 2;
  var HALF_PI = PI / 2;
  var QUARTER_PI = PI / 4;
  var TWO_THIRDS_PI = PI * 2 / 3;
  /**
   * @namespace Chart.helpers.canvas
   */

  var exports$1 = {
    /**
     * Clears the entire canvas associated to the given `chart`.
     * @param {Chart} chart - The chart for which to clear the canvas.
     */
    clear: function clear(chart) {
      chart.ctx.clearRect(0, 0, chart.width, chart.height);
    },

    /**
     * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
     * given size (width, height) and the same `radius` for all corners.
     * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
     * @param {number} x - The x axis of the coordinate for the rectangle starting point.
     * @param {number} y - The y axis of the coordinate for the rectangle starting point.
     * @param {number} width - The rectangle's width.
     * @param {number} height - The rectangle's height.
     * @param {number} radius - The rounded amount (in pixels) for the four corners.
     * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
     */
    roundedRect: function roundedRect(ctx, x, y, width, height, radius) {
      if (radius) {
        var r = Math.min(radius, height / 2, width / 2);
        var left = x + r;
        var top = y + r;
        var right = x + width - r;
        var bottom = y + height - r;
        ctx.moveTo(x, top);

        if (left < right && top < bottom) {
          ctx.arc(left, top, r, -PI, -HALF_PI);
          ctx.arc(right, top, r, -HALF_PI, 0);
          ctx.arc(right, bottom, r, 0, HALF_PI);
          ctx.arc(left, bottom, r, HALF_PI, PI);
        } else if (left < right) {
          ctx.moveTo(left, y);
          ctx.arc(right, top, r, -HALF_PI, HALF_PI);
          ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
        } else if (top < bottom) {
          ctx.arc(left, top, r, -PI, 0);
          ctx.arc(left, bottom, r, 0, PI);
        } else {
          ctx.arc(left, top, r, -PI, PI);
        }

        ctx.closePath();
        ctx.moveTo(x, y);
      } else {
        ctx.rect(x, y, width, height);
      }
    },
    drawPoint: function drawPoint(ctx, style, radius, x, y, rotation) {
      var type, xOffset, yOffset, size, cornerRadius;
      var rad = (rotation || 0) * RAD_PER_DEG;

      if (style && typeof style === 'object') {
        type = style.toString();

        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(rad);
          ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
          ctx.restore();
          return;
        }
      }

      if (isNaN(radius) || radius <= 0) {
        return;
      }

      ctx.beginPath();

      switch (style) {
        // Default includes circle
        default:
          ctx.arc(x, y, radius, 0, DOUBLE_PI);
          ctx.closePath();
          break;

        case 'triangle':
          ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
          rad += TWO_THIRDS_PI;
          ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
          rad += TWO_THIRDS_PI;
          ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
          ctx.closePath();
          break;

        case 'rectRounded':
          // NOTE: the rounded rect implementation changed to use `arc` instead of
          // `quadraticCurveTo` since it generates better results when rect is
          // almost a circle. 0.516 (instead of 0.5) produces results with visually
          // closer proportion to the previous impl and it is inscribed in the
          // circle with `radius`. For more details, see the following PRs:
          // https://github.com/chartjs/Chart.js/issues/5597
          // https://github.com/chartjs/Chart.js/issues/5858
          cornerRadius = radius * 0.516;
          size = radius - cornerRadius;
          xOffset = Math.cos(rad + QUARTER_PI) * size;
          yOffset = Math.sin(rad + QUARTER_PI) * size;
          ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
          ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
          ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
          ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
          ctx.closePath();
          break;

        case 'rect':
          if (!rotation) {
            size = Math.SQRT1_2 * radius;
            ctx.rect(x - size, y - size, 2 * size, 2 * size);
            break;
          }

          rad += QUARTER_PI;

        /* falls through */

        case 'rectRot':
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + yOffset, y - xOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.lineTo(x - yOffset, y + xOffset);
          ctx.closePath();
          break;

        case 'crossRot':
          rad += QUARTER_PI;

        /* falls through */

        case 'cross':
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.moveTo(x + yOffset, y - xOffset);
          ctx.lineTo(x - yOffset, y + xOffset);
          break;

        case 'star':
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.moveTo(x + yOffset, y - xOffset);
          ctx.lineTo(x - yOffset, y + xOffset);
          rad += QUARTER_PI;
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          ctx.moveTo(x + yOffset, y - xOffset);
          ctx.lineTo(x - yOffset, y + xOffset);
          break;

        case 'line':
          xOffset = Math.cos(rad) * radius;
          yOffset = Math.sin(rad) * radius;
          ctx.moveTo(x - xOffset, y - yOffset);
          ctx.lineTo(x + xOffset, y + yOffset);
          break;

        case 'dash':
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
          break;
      }

      ctx.fill();
      ctx.stroke();
    },

    /**
     * Returns true if the point is inside the rectangle
     * @param {object} point - The point to test
     * @param {object} area - The rectangle
     * @returns {boolean}
     * @private
     */
    _isPointInArea: function _isPointInArea(point, area) {
      var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.

      return point.x > area.left - epsilon && point.x < area.right + epsilon && point.y > area.top - epsilon && point.y < area.bottom + epsilon;
    },
    clipArea: function clipArea(ctx, area) {
      ctx.save();
      ctx.beginPath();
      ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
      ctx.clip();
    },
    unclipArea: function unclipArea(ctx) {
      ctx.restore();
    },
    lineTo: function lineTo(ctx, previous, target, flip) {
      var stepped = target.steppedLine;

      if (stepped) {
        if (stepped === 'middle') {
          var midpoint = (previous.x + target.x) / 2.0;
          ctx.lineTo(midpoint, flip ? target.y : previous.y);
          ctx.lineTo(midpoint, flip ? previous.y : target.y);
        } else if (stepped === 'after' && !flip || stepped !== 'after' && flip) {
          ctx.lineTo(previous.x, target.y);
        } else {
          ctx.lineTo(target.x, previous.y);
        }

        ctx.lineTo(target.x, target.y);
        return;
      }

      if (!target.tension) {
        ctx.lineTo(target.x, target.y);
        return;
      }

      ctx.bezierCurveTo(flip ? previous.controlPointPreviousX : previous.controlPointNextX, flip ? previous.controlPointPreviousY : previous.controlPointNextY, flip ? target.controlPointNextX : target.controlPointPreviousX, flip ? target.controlPointNextY : target.controlPointPreviousY, target.x, target.y);
    }
  };
  var helpers_canvas = exports$1; // DEPRECATIONS

  /**
   * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
   * @namespace Chart.helpers.clear
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */

  helpers_core.clear = exports$1.clear;
  /**
   * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
   * @namespace Chart.helpers.drawRoundedRectangle
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */

  helpers_core.drawRoundedRectangle = function (ctx) {
    ctx.beginPath();
    exports$1.roundedRect.apply(exports$1, arguments);
  };

  var defaults = {
    /**
     * @private
     */
    _set: function _set(scope, values) {
      return helpers_core.merge(this[scope] || (this[scope] = {}), values);
    }
  }; // TODO(v3): remove 'global' from namespace.  all default are global and
  // there's inconsistency around which options are under 'global'

  defaults._set('global', {
    defaultColor: 'rgba(0,0,0,0.1)',
    defaultFontColor: '#666',
    defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
    defaultFontSize: 12,
    defaultFontStyle: 'normal',
    defaultLineHeight: 1.2,
    showLines: true
  });

  var core_defaults = defaults;
  var valueOrDefault = helpers_core.valueOrDefault;
  /**
   * Converts the given font object into a CSS font string.
   * @param {object} font - A font object.
   * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
   * @private
   */

  function toFontString(font) {
    if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
      return null;
    }

    return (font.style ? font.style + ' ' : '') + (font.weight ? font.weight + ' ' : '') + font.size + 'px ' + font.family;
  }
  /**
   * @alias Chart.helpers.options
   * @namespace
   */


  var helpers_options = {
    /**
     * Converts the given line height `value` in pixels for a specific font `size`.
     * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
     * @param {number} size - The font size (in pixels) used to resolve relative `value`.
     * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).
     * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
     * @since 2.7.0
     */
    toLineHeight: function toLineHeight(value, size) {
      var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);

      if (!matches || matches[1] === 'normal') {
        return size * 1.2;
      }

      value = +matches[2];

      switch (matches[3]) {
        case 'px':
          return value;

        case '%':
          value /= 100;
          break;
      }

      return size * value;
    },

    /**
     * Converts the given value into a padding object with pre-computed width/height.
     * @param {number|object} value - If a number, set the value to all TRBL component,
     *  else, if and object, use defined properties and sets undefined ones to 0.
     * @returns {object} The padding values (top, right, bottom, left, width, height)
     * @since 2.7.0
     */
    toPadding: function toPadding(value) {
      var t, r, b, l;

      if (helpers_core.isObject(value)) {
        t = +value.top || 0;
        r = +value.right || 0;
        b = +value.bottom || 0;
        l = +value.left || 0;
      } else {
        t = r = b = l = +value || 0;
      }

      return {
        top: t,
        right: r,
        bottom: b,
        left: l,
        height: t + b,
        width: l + r
      };
    },

    /**
     * Parses font options and returns the font object.
     * @param {object} options - A object that contains font options to be parsed.
     * @return {object} The font object.
     * @todo Support font.* options and renamed to toFont().
     * @private
     */
    _parseFont: function _parseFont(options) {
      var globalDefaults = core_defaults.global;
      var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
      var font = {
        family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
        lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
        size: size,
        style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
        weight: null,
        string: ''
      };
      font.string = toFontString(font);
      return font;
    },

    /**
     * Evaluates the given `inputs` sequentially and returns the first defined value.
     * @param {Array} inputs - An array of values, falling back to the last value.
     * @param {object} [context] - If defined and the current value is a function, the value
     * is called with `context` as first argument and the result becomes the new input.
     * @param {number} [index] - If defined and the current value is an array, the value
     * at `index` become the new input.
     * @param {object} [info] - object to return information about resolution in
     * @param {boolean} [info.cacheable] - Will be set to `false` if option is not cacheable.
     * @since 2.7.0
     */
    resolve: function resolve(inputs, context, index, info) {
      var cacheable = true;
      var i, ilen, value;

      for (i = 0, ilen = inputs.length; i < ilen; ++i) {
        value = inputs[i];

        if (value === undefined) {
          continue;
        }

        if (context !== undefined && typeof value === 'function') {
          value = value(context);
          cacheable = false;
        }

        if (index !== undefined && helpers_core.isArray(value)) {
          value = value[index];
          cacheable = false;
        }

        if (value !== undefined) {
          if (info && !cacheable) {
            info.cacheable = false;
          }

          return value;
        }
      }
    }
  };
  /**
   * @alias Chart.helpers.math
   * @namespace
   */

  var exports$2 = {
    /**
     * Returns an array of factors sorted from 1 to sqrt(value)
     * @private
     */
    _factorize: function _factorize(value) {
      var result = [];
      var sqrt = Math.sqrt(value);
      var i;

      for (i = 1; i < sqrt; i++) {
        if (value % i === 0) {
          result.push(i);
          result.push(value / i);
        }
      }

      if (sqrt === (sqrt | 0)) {
        // if value is a square number
        result.push(sqrt);
      }

      result.sort(function (a, b) {
        return a - b;
      }).pop();
      return result;
    },
    log10: Math.log10 || function (x) {
      var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
      // Check for whole powers of 10,
      // which due to floating point rounding error should be corrected.

      var powerOf10 = Math.round(exponent);
      var isPowerOf10 = x === Math.pow(10, powerOf10);
      return isPowerOf10 ? powerOf10 : exponent;
    }
  };
  var helpers_math = exports$2; // DEPRECATIONS

  /**
   * Provided for backward compatibility, use Chart.helpers.math.log10 instead.
   * @namespace Chart.helpers.log10
   * @deprecated since version 2.9.0
   * @todo remove at version 3
   * @private
   */

  helpers_core.log10 = exports$2.log10;

  var getRtlAdapter = function getRtlAdapter(rectX, width) {
    return {
      x: function x(_x2) {
        return rectX + rectX + width - _x2;
      },
      setWidth: function setWidth(w) {
        width = w;
      },
      textAlign: function textAlign(align) {
        if (align === 'center') {
          return align;
        }

        return align === 'right' ? 'left' : 'right';
      },
      xPlus: function xPlus(x, value) {
        return x - value;
      },
      leftForLtr: function leftForLtr(x, itemWidth) {
        return x - itemWidth;
      }
    };
  };

  var getLtrAdapter = function getLtrAdapter() {
    return {
      x: function x(_x3) {
        return _x3;
      },
      setWidth: function setWidth(w) {// eslint-disable-line no-unused-vars
      },
      textAlign: function textAlign(align) {
        return align;
      },
      xPlus: function xPlus(x, value) {
        return x + value;
      },
      leftForLtr: function leftForLtr(x, _itemWidth) {
        // eslint-disable-line no-unused-vars
        return x;
      }
    };
  };

  var getAdapter = function getAdapter(rtl, rectX, width) {
    return rtl ? getRtlAdapter(rectX, width) : getLtrAdapter();
  };

  var overrideTextDirection = function overrideTextDirection(ctx, direction) {
    var style, original;

    if (direction === 'ltr' || direction === 'rtl') {
      style = ctx.canvas.style;
      original = [style.getPropertyValue('direction'), style.getPropertyPriority('direction')];
      style.setProperty('direction', direction, 'important');
      ctx.prevTextDirection = original;
    }
  };

  var restoreTextDirection = function restoreTextDirection(ctx) {
    var original = ctx.prevTextDirection;

    if (original !== undefined) {
      delete ctx.prevTextDirection;
      ctx.canvas.style.setProperty('direction', original[0], original[1]);
    }
  };

  var helpers_rtl = {
    getRtlAdapter: getAdapter,
    overrideTextDirection: overrideTextDirection,
    restoreTextDirection: restoreTextDirection
  };
  var helpers$1 = helpers_core;
  var easing = helpers_easing;
  var canvas = helpers_canvas;
  var options = helpers_options;
  var math = helpers_math;
  var rtl = helpers_rtl;
  helpers$1.easing = easing;
  helpers$1.canvas = canvas;
  helpers$1.options = options;
  helpers$1.math = math;
  helpers$1.rtl = rtl;

  function interpolate(start, view, model, ease) {
    var keys = Object.keys(model);
    var i, ilen, key, actual, origin, target, type, c0, c1;

    for (i = 0, ilen = keys.length; i < ilen; ++i) {
      key = keys[i];
      target = model[key]; // if a value is added to the model after pivot() has been called, the view
      // doesn't contain it, so let's initialize the view to the target value.

      if (!view.hasOwnProperty(key)) {
        view[key] = target;
      }

      actual = view[key];

      if (actual === target || key[0] === '_') {
        continue;
      }

      if (!start.hasOwnProperty(key)) {
        start[key] = actual;
      }

      origin = start[key];
      type = typeof target;

      if (type === typeof origin) {
        if (type === 'string') {
          c0 = chartjsColor(origin);

          if (c0.valid) {
            c1 = chartjsColor(target);

            if (c1.valid) {
              view[key] = c1.mix(c0, ease).rgbString();
              continue;
            }
          }
        } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
          view[key] = origin + (target - origin) * ease;
          continue;
        }
      }

      view[key] = target;
    }
  }

  var Element = function Element(configuration) {
    helpers$1.extend(this, configuration);
    this.initialize.apply(this, arguments);
  };

  helpers$1.extend(Element.prototype, {
    _type: undefined,
    initialize: function initialize() {
      this.hidden = false;
    },
    pivot: function pivot() {
      var me = this;

      if (!me._view) {
        me._view = helpers$1.extend({}, me._model);
      }

      me._start = {};
      return me;
    },
    transition: function transition(ease) {
      var me = this;
      var model = me._model;
      var start = me._start;
      var view = me._view; // No animation -> No Transition

      if (!model || ease === 1) {
        me._view = helpers$1.extend({}, model);
        me._start = null;
        return me;
      }

      if (!view) {
        view = me._view = {};
      }

      if (!start) {
        start = me._start = {};
      }

      interpolate(start, view, model, ease);
      return me;
    },
    tooltipPosition: function tooltipPosition() {
      return {
        x: this._model.x,
        y: this._model.y
      };
    },
    hasValue: function hasValue() {
      return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
    }
  });
  Element.extend = helpers$1.inherits;
  var core_element = Element;
  var exports$3 = core_element.extend({
    chart: null,
    // the animation associated chart instance
    currentStep: 0,
    // the current animation step
    numSteps: 60,
    // default number of steps
    easing: '',
    // the easing to use for this animation
    render: null,
    // render function used by the animation service
    onAnimationProgress: null,
    // user specified callback to fire on each step of the animation
    onAnimationComplete: null // user specified callback to fire when the animation finishes

  });
  var core_animation = exports$3; // DEPRECATIONS

  /**
   * Provided for backward compatibility, use Chart.Animation instead
   * @prop Chart.Animation#animationObject
   * @deprecated since version 2.6.0
   * @todo remove at version 3
   */

  Object.defineProperty(exports$3.prototype, 'animationObject', {
    get: function get() {
      return this;
    }
  });
  /**
   * Provided for backward compatibility, use Chart.Animation#chart instead
   * @prop Chart.Animation#chartInstance
   * @deprecated since version 2.6.0
   * @todo remove at version 3
   */

  Object.defineProperty(exports$3.prototype, 'chartInstance', {
    get: function get() {
      return this.chart;
    },
    set: function set(value) {
      this.chart = value;
    }
  });

  core_defaults._set('global', {
    animation: {
      duration: 1000,
      easing: 'easeOutQuart',
      onProgress: helpers$1.noop,
      onComplete: helpers$1.noop
    }
  });

  var core_animations = {
    animations: [],
    request: null,

    /**
     * @param {Chart} chart - The chart to animate.
     * @param {Chart.Animation} animation - The animation that we will animate.
     * @param {number} duration - The animation duration in ms.
     * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
     */
    addAnimation: function addAnimation(chart, animation, duration, lazy) {
      var animations = this.animations;
      var i, ilen;
      animation.chart = chart;
      animation.startTime = Date.now();
      animation.duration = duration;

      if (!lazy) {
        chart.animating = true;
      }

      for (i = 0, ilen = animations.length; i < ilen; ++i) {
        if (animations[i].chart === chart) {
          animations[i] = animation;
          return;
        }
      }

      animations.push(animation); // If there are no animations queued, manually kickstart a digest, for lack of a better word

      if (animations.length === 1) {
        this.requestAnimationFrame();
      }
    },
    cancelAnimation: function cancelAnimation(chart) {
      var index = helpers$1.findIndex(this.animations, function (animation) {
        return animation.chart === chart;
      });

      if (index !== -1) {
        this.animations.splice(index, 1);
        chart.animating = false;
      }
    },
    requestAnimationFrame: function requestAnimationFrame() {
      var me = this;

      if (me.request === null) {
        // Skip animation frame requests until the active one is executed.
        // This can happen when processing mouse events, e.g. 'mousemove'
        // and 'mouseout' events will trigger multiple renders.
        me.request = helpers$1.requestAnimFrame.call(window, function () {
          me.request = null;
          me.startDigest();
        });
      }
    },

    /**
     * @private
     */
    startDigest: function startDigest() {
      var me = this;
      me.advance(); // Do we have more stuff to animate?

      if (me.animations.length > 0) {
        me.requestAnimationFrame();
      }
    },

    /**
     * @private
     */
    advance: function advance() {
      var animations = this.animations;
      var animation, chart, numSteps, nextStep;
      var i = 0; // 1 animation per chart, so we are looping charts here

      while (i < animations.length) {
        animation = animations[i];
        chart = animation.chart;
        numSteps = animation.numSteps; // Make sure that currentStep starts at 1
        // https://github.com/chartjs/Chart.js/issues/6104

        nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
        animation.currentStep = Math.min(nextStep, numSteps);
        helpers$1.callback(animation.render, [chart, animation], chart);
        helpers$1.callback(animation.onAnimationProgress, [animation], chart);

        if (animation.currentStep >= numSteps) {
          helpers$1.callback(animation.onAnimationComplete, [animation], chart);
          chart.animating = false;
          animations.splice(i, 1);
        } else {
          ++i;
        }
      }
    }
  };
  var resolve = helpers$1.options.resolve;
  var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
  /**
   * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
   * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
   * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
   */

  function listenArrayEvents(array, listener) {
    if (array._chartjs) {
      array._chartjs.listeners.push(listener);

      return;
    }

    Object.defineProperty(array, '_chartjs', {
      configurable: true,
      enumerable: false,
      value: {
        listeners: [listener]
      }
    });
    arrayEvents.forEach(function (key) {
      var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
      var base = array[key];
      Object.defineProperty(array, key, {
        configurable: true,
        enumerable: false,
        value: function value() {
          var args = Array.prototype.slice.call(arguments);
          var res = base.apply(this, args);
          helpers$1.each(array._chartjs.listeners, function (object) {
            if (typeof object[method] === 'function') {
              object[method].apply(object, args);
            }
          });
          return res;
        }
      });
    });
  }
  /**
   * Removes the given array event listener and cleanup extra attached properties (such as
   * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
   */


  function unlistenArrayEvents(array, listener) {
    var stub = array._chartjs;

    if (!stub) {
      return;
    }

    var listeners = stub.listeners;
    var index = listeners.indexOf(listener);

    if (index !== -1) {
      listeners.splice(index, 1);
    }

    if (listeners.length > 0) {
      return;
    }

    arrayEvents.forEach(function (key) {
      delete array[key];
    });
    delete array._chartjs;
  } // Base class for all dataset controllers (line, bar, etc)


  var DatasetController = function DatasetController(chart, datasetIndex) {
    this.initialize(chart, datasetIndex);
  };

  helpers$1.extend(DatasetController.prototype, {
    /**
     * Element type used to generate a meta dataset (e.g. Chart.element.Line).
     * @type {Chart.core.element}
     */
    datasetElementType: null,

    /**
     * Element type used to generate a meta data (e.g. Chart.element.Point).
     * @type {Chart.core.element}
     */
    dataElementType: null,

    /**
     * Dataset element option keys to be resolved in _resolveDatasetElementOptions.
     * A derived controller may override this to resolve controller-specific options.
     * The keys defined here are for backward compatibility for legend styles.
     * @private
     */
    _datasetElementOptions: ['backgroundColor', 'borderCapStyle', 'borderColor', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'borderWidth'],

    /**
     * Data element option keys to be resolved in _resolveDataElementOptions.
     * A derived controller may override this to resolve controller-specific options.
     * The keys defined here are for backward compatibility for legend styles.
     * @private
     */
    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'pointStyle'],
    initialize: function initialize(chart, datasetIndex) {
      var me = this;
      me.chart = chart;
      me.index = datasetIndex;
      me.linkScales();
      me.addElements();
      me._type = me.getMeta().type;
    },
    updateIndex: function updateIndex(datasetIndex) {
      this.index = datasetIndex;
    },
    linkScales: function linkScales() {
      var me = this;
      var meta = me.getMeta();
      var chart = me.chart;
      var scales = chart.scales;
      var dataset = me.getDataset();
      var scalesOpts = chart.options.scales;

      if (meta.xAxisID === null || !(meta.xAxisID in scales) || dataset.xAxisID) {
        meta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;
      }

      if (meta.yAxisID === null || !(meta.yAxisID in scales) || dataset.yAxisID) {
        meta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;
      }
    },
    getDataset: function getDataset() {
      return this.chart.data.datasets[this.index];
    },
    getMeta: function getMeta() {
      return this.chart.getDatasetMeta(this.index);
    },
    getScaleForId: function getScaleForId(scaleID) {
      return this.chart.scales[scaleID];
    },

    /**
     * @private
     */
    _getValueScaleId: function _getValueScaleId() {
      return this.getMeta().yAxisID;
    },

    /**
     * @private
     */
    _getIndexScaleId: function _getIndexScaleId() {
      return this.getMeta().xAxisID;
    },

    /**
     * @private
     */
    _getValueScale: function _getValueScale() {
      return this.getScaleForId(this._getValueScaleId());
    },

    /**
     * @private
     */
    _getIndexScale: function _getIndexScale() {
      return this.getScaleForId(this._getIndexScaleId());
    },
    reset: function reset() {
      this._update(true);
    },

    /**
     * @private
     */
    destroy: function destroy() {
      if (this._data) {
        unlistenArrayEvents(this._data, this);
      }
    },
    createMetaDataset: function createMetaDataset() {
      var me = this;
      var type = me.datasetElementType;
      return type && new type({
        _chart: me.chart,
        _datasetIndex: me.index
      });
    },
    createMetaData: function createMetaData(index) {
      var me = this;
      var type = me.dataElementType;
      return type && new type({
        _chart: me.chart,
        _datasetIndex: me.index,
        _index: index
      });
    },
    addElements: function addElements() {
      var me = this;
      var meta = me.getMeta();
      var data = me.getDataset().data || [];
      var metaData = meta.data;
      var i, ilen;

      for (i = 0, ilen = data.length; i < ilen; ++i) {
        metaData[i] = metaData[i] || me.createMetaData(i);
      }

      meta.dataset = meta.dataset || me.createMetaDataset();
    },
    addElementAndReset: function addElementAndReset(index) {
      var element = this.createMetaData(index);
      this.getMeta().data.splice(index, 0, element);
      this.updateElement(element, index, true);
    },
    buildOrUpdateElements: function buildOrUpdateElements() {
      var me = this;
      var dataset = me.getDataset();
      var data = dataset.data || (dataset.data = []); // In order to correctly handle data addition/deletion animation (an thus simulate
      // real-time charts), we need to monitor these data modifications and synchronize
      // the internal meta data accordingly.

      if (me._data !== data) {
        if (me._data) {
          // This case happens when the user replaced the data array instance.
          unlistenArrayEvents(me._data, me);
        }

        if (data && Object.isExtensible(data)) {
          listenArrayEvents(data, me);
        }

        me._data = data;
      } // Re-sync meta data in case the user replaced the data array or if we missed
      // any updates and so make sure that we handle number of datapoints changing.


      me.resyncElements();
    },

    /**
     * Returns the merged user-supplied and default dataset-level options
     * @private
     */
    _configure: function _configure() {
      var me = this;
      me._config = helpers$1.merge(Object.create(null), [me.chart.options.datasets[me._type], me.getDataset()], {
        merger: function merger(key, target, source) {
          if (key !== '_meta' && key !== 'data') {
            helpers$1._merger(key, target, source);
          }
        }
      });
    },
    _update: function _update(reset) {
      var me = this;

      me._configure();

      me._cachedDataOpts = null;
      me.update(reset);
    },
    update: helpers$1.noop,
    transition: function transition(easingValue) {
      var meta = this.getMeta();
      var elements = meta.data || [];
      var ilen = elements.length;
      var i = 0;

      for (; i < ilen; ++i) {
        elements[i].transition(easingValue);
      }

      if (meta.dataset) {
        meta.dataset.transition(easingValue);
      }
    },
    draw: function draw() {
      var meta = this.getMeta();
      var elements = meta.data || [];
      var ilen = elements.length;
      var i = 0;

      if (meta.dataset) {
        meta.dataset.draw();
      }

      for (; i < ilen; ++i) {
        elements[i].draw();
      }
    },

    /**
     * Returns a set of predefined style properties that should be used to represent the dataset
     * or the data if the index is specified
     * @param {number} index - data index
     * @return {IStyleInterface} style object
     */
    getStyle: function getStyle(index) {
      var me = this;
      var meta = me.getMeta();
      var dataset = meta.dataset;
      var style;

      me._configure();

      if (dataset && index === undefined) {
        style = me._resolveDatasetElementOptions(dataset || {});
      } else {
        index = index || 0;
        style = me._resolveDataElementOptions(meta.data[index] || {}, index);
      }

      if (style.fill === false || style.fill === null) {
        style.backgroundColor = style.borderColor;
      }

      return style;
    },

    /**
     * @private
     */
    _resolveDatasetElementOptions: function _resolveDatasetElementOptions(element, hover) {
      var me = this;
      var chart = me.chart;
      var datasetOpts = me._config;
      var custom = element.custom || {};
      var options = chart.options.elements[me.datasetElementType.prototype._type] || {};
      var elementOptions = me._datasetElementOptions;
      var values = {};
      var i, ilen, key, readKey; // Scriptable options

      var context = {
        chart: chart,
        dataset: me.getDataset(),
        datasetIndex: me.index,
        hover: hover
      };

      for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
        key = elementOptions[i];
        readKey = hover ? 'hover' + key.charAt(0).toUpperCase() + key.slice(1) : key;
        values[key] = resolve([custom[readKey], datasetOpts[readKey], options[readKey]], context);
      }

      return values;
    },

    /**
     * @private
     */
    _resolveDataElementOptions: function _resolveDataElementOptions(element, index) {
      var me = this;
      var custom = element && element.custom;
      var cached = me._cachedDataOpts;

      if (cached && !custom) {
        return cached;
      }

      var chart = me.chart;
      var datasetOpts = me._config;
      var options = chart.options.elements[me.dataElementType.prototype._type] || {};
      var elementOptions = me._dataElementOptions;
      var values = {}; // Scriptable options

      var context = {
        chart: chart,
        dataIndex: index,
        dataset: me.getDataset(),
        datasetIndex: me.index
      }; // `resolve` sets cacheable to `false` if any option is indexed or scripted

      var info = {
        cacheable: !custom
      };
      var keys, i, ilen, key;
      custom = custom || {};

      if (helpers$1.isArray(elementOptions)) {
        for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
          key = elementOptions[i];
          values[key] = resolve([custom[key], datasetOpts[key], options[key]], context, index, info);
        }
      } else {
        keys = Object.keys(elementOptions);

        for (i = 0, ilen = keys.length; i < ilen; ++i) {
          key = keys[i];
          values[key] = resolve([custom[key], datasetOpts[elementOptions[key]], datasetOpts[key], options[key]], context, index, info);
        }
      }

      if (info.cacheable) {
        me._cachedDataOpts = Object.freeze(values);
      }

      return values;
    },
    removeHoverStyle: function removeHoverStyle(element) {
      helpers$1.merge(element._model, element.$previousStyle || {});
      delete element.$previousStyle;
    },
    setHoverStyle: function setHoverStyle(element) {
      var dataset = this.chart.data.datasets[element._datasetIndex];
      var index = element._index;
      var custom = element.custom || {};
      var model = element._model;
      var getHoverColor = helpers$1.getHoverColor;
      element.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth
      };
      model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);
      model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);
      model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);
    },

    /**
     * @private
     */
    _removeDatasetHoverStyle: function _removeDatasetHoverStyle() {
      var element = this.getMeta().dataset;

      if (element) {
        this.removeHoverStyle(element);
      }
    },

    /**
     * @private
     */
    _setDatasetHoverStyle: function _setDatasetHoverStyle() {
      var element = this.getMeta().dataset;
      var prev = {};
      var i, ilen, key, keys, hoverOptions, model;

      if (!element) {
        return;
      }

      model = element._model;
      hoverOptions = this._resolveDatasetElementOptions(element, true);
      keys = Object.keys(hoverOptions);

      for (i = 0, ilen = keys.length; i < ilen; ++i) {
        key = keys[i];
        prev[key] = model[key];
        model[key] = hoverOptions[key];
      }

      element.$previousStyle = prev;
    },

    /**
     * @private
     */
    resyncElements: function resyncElements() {
      var me = this;
      var meta = me.getMeta();
      var data = me.getDataset().data;
      var numMeta = meta.data.length;
      var numData = data.length;

      if (numData < numMeta) {
        meta.data.splice(numData, numMeta - numData);
      } else if (numData > numMeta) {
        me.insertElements(numMeta, numData - numMeta);
      }
    },

    /**
     * @private
     */
    insertElements: function insertElements(start, count) {
      for (var i = 0; i < count; ++i) {
        this.addElementAndReset(start + i);
      }
    },

    /**
     * @private
     */
    onDataPush: function onDataPush() {
      var count = arguments.length;
      this.insertElements(this.getDataset().data.length - count, count);
    },

    /**
     * @private
     */
    onDataPop: function onDataPop() {
      this.getMeta().data.pop();
    },

    /**
     * @private
     */
    onDataShift: function onDataShift() {
      this.getMeta().data.shift();
    },

    /**
     * @private
     */
    onDataSplice: function onDataSplice(start, count) {
      this.getMeta().data.splice(start, count);
      this.insertElements(start, arguments.length - 2);
    },

    /**
     * @private
     */
    onDataUnshift: function onDataUnshift() {
      this.insertElements(0, arguments.length);
    }
  });
  DatasetController.extend = helpers$1.inherits;
  var core_datasetController = DatasetController;
  var TAU = Math.PI * 2;

  core_defaults._set('global', {
    elements: {
      arc: {
        backgroundColor: core_defaults.global.defaultColor,
        borderColor: '#fff',
        borderWidth: 2,
        borderAlign: 'center'
      }
    }
  });

  function clipArc(ctx, arc) {
    var startAngle = arc.startAngle;
    var endAngle = arc.endAngle;
    var pixelMargin = arc.pixelMargin;
    var angleMargin = pixelMargin / arc.outerRadius;
    var x = arc.x;
    var y = arc.y; // Draw an inner border by cliping the arc and drawing a double-width border
    // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders

    ctx.beginPath();
    ctx.arc(x, y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);

    if (arc.innerRadius > pixelMargin) {
      angleMargin = pixelMargin / arc.innerRadius;
      ctx.arc(x, y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);
    } else {
      ctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);
    }

    ctx.closePath();
    ctx.clip();
  }

  function drawFullCircleBorders(ctx, vm, arc, inner) {
    var endAngle = arc.endAngle;
    var i;

    if (inner) {
      arc.endAngle = arc.startAngle + TAU;
      clipArc(ctx, arc);
      arc.endAngle = endAngle;

      if (arc.endAngle === arc.startAngle && arc.fullCircles) {
        arc.endAngle += TAU;
        arc.fullCircles--;
      }
    }

    ctx.beginPath();
    ctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);

    for (i = 0; i < arc.fullCircles; ++i) {
      ctx.stroke();
    }

    ctx.beginPath();
    ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);

    for (i = 0; i < arc.fullCircles; ++i) {
      ctx.stroke();
    }
  }

  function drawBorder(ctx, vm, arc) {
    var inner = vm.borderAlign === 'inner';

    if (inner) {
      ctx.lineWidth = vm.borderWidth * 2;
      ctx.lineJoin = 'round';
    } else {
      ctx.lineWidth = vm.borderWidth;
      ctx.lineJoin = 'bevel';
    }

    if (arc.fullCircles) {
      drawFullCircleBorders(ctx, vm, arc, inner);
    }

    if (inner) {
      clipArc(ctx, arc);
    }

    ctx.beginPath();
    ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);
    ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
    ctx.closePath();
    ctx.stroke();
  }

  var element_arc = core_element.extend({
    _type: 'arc',
    inLabelRange: function inLabelRange(mouseX) {
      var vm = this._view;

      if (vm) {
        return Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2);
      }

      return false;
    },
    inRange: function inRange(chartX, chartY) {
      var vm = this._view;

      if (vm) {
        var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {
          x: chartX,
          y: chartY
        });
        var angle = pointRelativePosition.angle;
        var distance = pointRelativePosition.distance; // Sanitise angle range

        var startAngle = vm.startAngle;
        var endAngle = vm.endAngle;

        while (endAngle < startAngle) {
          endAngle += TAU;
        }

        while (angle > endAngle) {
          angle -= TAU;
        }

        while (angle < startAngle) {
          angle += TAU;
        } // Check if within the range of the open/close angle


        var betweenAngles = angle >= startAngle && angle <= endAngle;
        var withinRadius = distance >= vm.innerRadius && distance <= vm.outerRadius;
        return betweenAngles && withinRadius;
      }

      return false;
    },
    getCenterPoint: function getCenterPoint() {
      var vm = this._view;
      var halfAngle = (vm.startAngle + vm.endAngle) / 2;
      var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
      return {
        x: vm.x + Math.cos(halfAngle) * halfRadius,
        y: vm.y + Math.sin(halfAngle) * halfRadius
      };
    },
    getArea: function getArea() {
      var vm = this._view;
      return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
    },
    tooltipPosition: function tooltipPosition() {
      var vm = this._view;
      var centreAngle = vm.startAngle + (vm.endAngle - vm.startAngle) / 2;
      var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;
      return {
        x: vm.x + Math.cos(centreAngle) * rangeFromCentre,
        y: vm.y + Math.sin(centreAngle) * rangeFromCentre
      };
    },
    draw: function draw() {
      var ctx = this._chart.ctx;
      var vm = this._view;
      var pixelMargin = vm.borderAlign === 'inner' ? 0.33 : 0;
      var arc = {
        x: vm.x,
        y: vm.y,
        innerRadius: vm.innerRadius,
        outerRadius: Math.max(vm.outerRadius - pixelMargin, 0),
        pixelMargin: pixelMargin,
        startAngle: vm.startAngle,
        endAngle: vm.endAngle,
        fullCircles: Math.floor(vm.circumference / TAU)
      };
      var i;
      ctx.save();
      ctx.fillStyle = vm.backgroundColor;
      ctx.strokeStyle = vm.borderColor;

      if (arc.fullCircles) {
        arc.endAngle = arc.startAngle + TAU;
        ctx.beginPath();
        ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
        ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
        ctx.closePath();

        for (i = 0; i < arc.fullCircles; ++i) {
          ctx.fill();
        }

        arc.endAngle = arc.startAngle + vm.circumference % TAU;
      }

      ctx.beginPath();
      ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
      ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
      ctx.closePath();
      ctx.fill();

      if (vm.borderWidth) {
        drawBorder(ctx, vm, arc);
      }

      ctx.restore();
    }
  });
  var valueOrDefault$1 = helpers$1.valueOrDefault;
  var defaultColor = core_defaults.global.defaultColor;

  core_defaults._set('global', {
    elements: {
      line: {
        tension: 0.4,
        backgroundColor: defaultColor,
        borderWidth: 3,
        borderColor: defaultColor,
        borderCapStyle: 'butt',
        borderDash: [],
        borderDashOffset: 0.0,
        borderJoinStyle: 'miter',
        capBezierPoints: true,
        fill: true // do we fill in the area between the line and its base axis

      }
    }
  });

  var element_line = core_element.extend({
    _type: 'line',
    draw: function draw() {
      var me = this;
      var vm = me._view;
      var ctx = me._chart.ctx;
      var spanGaps = vm.spanGaps;

      var points = me._children.slice(); // clone array


      var globalDefaults = core_defaults.global;
      var globalOptionLineElements = globalDefaults.elements.line;
      var lastDrawnIndex = -1;
      var closePath = me._loop;
      var index, previous, currentVM;

      if (!points.length) {
        return;
      }

      if (me._loop) {
        for (index = 0; index < points.length; ++index) {
          previous = helpers$1.previousItem(points, index); // If the line has an open path, shift the point array

          if (!points[index]._view.skip && previous._view.skip) {
            points = points.slice(index).concat(points.slice(0, index));
            closePath = spanGaps;
            break;
          }
        } // If the line has a close path, add the first point again


        if (closePath) {
          points.push(points[0]);
        }
      }

      ctx.save(); // Stroke Line Options

      ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle; // IE 9 and 10 do not support line dash

      if (ctx.setLineDash) {
        ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
      }

      ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
      ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
      ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
      ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor; // Stroke Line

      ctx.beginPath(); // First point moves to it's starting position no matter what

      currentVM = points[0]._view;

      if (!currentVM.skip) {
        ctx.moveTo(currentVM.x, currentVM.y);
        lastDrawnIndex = 0;
      }

      for (index = 1; index < points.length; ++index) {
        currentVM = points[index]._view;
        previous = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index) : points[lastDrawnIndex];

        if (!currentVM.skip) {
          if (lastDrawnIndex !== index - 1 && !spanGaps || lastDrawnIndex === -1) {
            // There was a gap and this is the first point after the gap
            ctx.moveTo(currentVM.x, currentVM.y);
          } else {
            // Line to next point
            helpers$1.canvas.lineTo(ctx, previous._view, currentVM);
          }

          lastDrawnIndex = index;
        }
      }

      if (closePath) {
        ctx.closePath();
      }

      ctx.stroke();
      ctx.restore();
    }
  });
  var valueOrDefault$2 = helpers$1.valueOrDefault;
  var defaultColor$1 = core_defaults.global.defaultColor;

  core_defaults._set('global', {
    elements: {
      point: {
        radius: 3,
        pointStyle: 'circle',
        backgroundColor: defaultColor$1,
        borderColor: defaultColor$1,
        borderWidth: 1,
        // Hover
        hitRadius: 1,
        hoverRadius: 4,
        hoverBorderWidth: 1
      }
    }
  });

  function xRange(mouseX) {
    var vm = this._view;
    return vm ? Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius : false;
  }

  function yRange(mouseY) {
    var vm = this._view;
    return vm ? Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius : false;
  }

  var element_point = core_element.extend({
    _type: 'point',
    inRange: function inRange(mouseX, mouseY) {
      var vm = this._view;
      return vm ? Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2) < Math.pow(vm.hitRadius + vm.radius, 2) : false;
    },
    inLabelRange: xRange,
    inXRange: xRange,
    inYRange: yRange,
    getCenterPoint: function getCenterPoint() {
      var vm = this._view;
      return {
        x: vm.x,
        y: vm.y
      };
    },
    getArea: function getArea() {
      return Math.PI * Math.pow(this._view.radius, 2);
    },
    tooltipPosition: function tooltipPosition() {
      var vm = this._view;
      return {
        x: vm.x,
        y: vm.y,
        padding: vm.radius + vm.borderWidth
      };
    },
    draw: function draw(chartArea) {
      var vm = this._view;
      var ctx = this._chart.ctx;
      var pointStyle = vm.pointStyle;
      var rotation = vm.rotation;
      var radius = vm.radius;
      var x = vm.x;
      var y = vm.y;
      var globalDefaults = core_defaults.global;
      var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow

      if (vm.skip) {
        return;
      } // Clipping for Points.


      if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {
        ctx.strokeStyle = vm.borderColor || defaultColor;
        ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
        ctx.fillStyle = vm.backgroundColor || defaultColor;
        helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
      }
    }
  });
  var defaultColor$2 = core_defaults.global.defaultColor;

  core_defaults._set('global', {
    elements: {
      rectangle: {
        backgroundColor: defaultColor$2,
        borderColor: defaultColor$2,
        borderSkipped: 'bottom',
        borderWidth: 0
      }
    }
  });

  function isVertical(vm) {
    return vm && vm.width !== undefined;
  }
  /**
   * Helper function to get the bounds of the bar regardless of the orientation
   * @param bar {Chart.Element.Rectangle} the bar
   * @return {Bounds} bounds of the bar
   * @private
   */


  function getBarBounds(vm) {
    var x1, x2, y1, y2, half;

    if (isVertical(vm)) {
      half = vm.width / 2;
      x1 = vm.x - half;
      x2 = vm.x + half;
      y1 = Math.min(vm.y, vm.base);
      y2 = Math.max(vm.y, vm.base);
    } else {
      half = vm.height / 2;
      x1 = Math.min(vm.x, vm.base);
      x2 = Math.max(vm.x, vm.base);
      y1 = vm.y - half;
      y2 = vm.y + half;
    }

    return {
      left: x1,
      top: y1,
      right: x2,
      bottom: y2
    };
  }

  function swap(orig, v1, v2) {
    return orig === v1 ? v2 : orig === v2 ? v1 : orig;
  }

  function parseBorderSkipped(vm) {
    var edge = vm.borderSkipped;
    var res = {};

    if (!edge) {
      return res;
    }

    if (vm.horizontal) {
      if (vm.base > vm.x) {
        edge = swap(edge, 'left', 'right');
      }
    } else if (vm.base < vm.y) {
      edge = swap(edge, 'bottom', 'top');
    }

    res[edge] = true;
    return res;
  }

  function parseBorderWidth(vm, maxW, maxH) {
    var value = vm.borderWidth;
    var skip = parseBorderSkipped(vm);
    var t, r, b, l;

    if (helpers$1.isObject(value)) {
      t = +value.top || 0;
      r = +value.right || 0;
      b = +value.bottom || 0;
      l = +value.left || 0;
    } else {
      t = r = b = l = +value || 0;
    }

    return {
      t: skip.top || t < 0 ? 0 : t > maxH ? maxH : t,
      r: skip.right || r < 0 ? 0 : r > maxW ? maxW : r,
      b: skip.bottom || b < 0 ? 0 : b > maxH ? maxH : b,
      l: skip.left || l < 0 ? 0 : l > maxW ? maxW : l
    };
  }

  function boundingRects(vm) {
    var bounds = getBarBounds(vm);
    var width = bounds.right - bounds.left;
    var height = bounds.bottom - bounds.top;
    var border = parseBorderWidth(vm, width / 2, height / 2);
    return {
      outer: {
        x: bounds.left,
        y: bounds.top,
        w: width,
        h: height
      },
      inner: {
        x: bounds.left + border.l,
        y: bounds.top + border.t,
        w: width - border.l - border.r,
        h: height - border.t - border.b
      }
    };
  }

  function _inRange(vm, x, y) {
    var skipX = x === null;
    var skipY = y === null;
    var bounds = !vm || skipX && skipY ? false : getBarBounds(vm);
    return bounds && (skipX || x >= bounds.left && x <= bounds.right) && (skipY || y >= bounds.top && y <= bounds.bottom);
  }

  var element_rectangle = core_element.extend({
    _type: 'rectangle',
    draw: function draw() {
      var ctx = this._chart.ctx;
      var vm = this._view;
      var rects = boundingRects(vm);
      var outer = rects.outer;
      var inner = rects.inner;
      ctx.fillStyle = vm.backgroundColor;
      ctx.fillRect(outer.x, outer.y, outer.w, outer.h);

      if (outer.w === inner.w && outer.h === inner.h) {
        return;
      }

      ctx.save();
      ctx.beginPath();
      ctx.rect(outer.x, outer.y, outer.w, outer.h);
      ctx.clip();
      ctx.fillStyle = vm.borderColor;
      ctx.rect(inner.x, inner.y, inner.w, inner.h);
      ctx.fill('evenodd');
      ctx.restore();
    },
    height: function height() {
      var vm = this._view;
      return vm.base - vm.y;
    },
    inRange: function inRange(mouseX, mouseY) {
      return _inRange(this._view, mouseX, mouseY);
    },
    inLabelRange: function inLabelRange(mouseX, mouseY) {
      var vm = this._view;
      return isVertical(vm) ? _inRange(vm, mouseX, null) : _inRange(vm, null, mouseY);
    },
    inXRange: function inXRange(mouseX) {
      return _inRange(this._view, mouseX, null);
    },
    inYRange: function inYRange(mouseY) {
      return _inRange(this._view, null, mouseY);
    },
    getCenterPoint: function getCenterPoint() {
      var vm = this._view;
      var x, y;

      if (isVertical(vm)) {
        x = vm.x;
        y = (vm.y + vm.base) / 2;
      } else {
        x = (vm.x + vm.base) / 2;
        y = vm.y;
      }

      return {
        x: x,
        y: y
      };
    },
    getArea: function getArea() {
      var vm = this._view;
      return isVertical(vm) ? vm.width * Math.abs(vm.y - vm.base) : vm.height * Math.abs(vm.x - vm.base);
    },
    tooltipPosition: function tooltipPosition() {
      var vm = this._view;
      return {
        x: vm.x,
        y: vm.y
      };
    }
  });
  var elements = {};
  var Arc = element_arc;
  var Line = element_line;
  var Point = element_point;
  var Rectangle = element_rectangle;
  elements.Arc = Arc;
  elements.Line = Line;
  elements.Point = Point;
  elements.Rectangle = Rectangle;
  var deprecated = helpers$1._deprecated;
  var valueOrDefault$3 = helpers$1.valueOrDefault;

  core_defaults._set('bar', {
    hover: {
      mode: 'label'
    },
    scales: {
      xAxes: [{
        type: 'category',
        offset: true,
        gridLines: {
          offsetGridLines: true
        }
      }],
      yAxes: [{
        type: 'linear'
      }]
    }
  });

  core_defaults._set('global', {
    datasets: {
      bar: {
        categoryPercentage: 0.8,
        barPercentage: 0.9
      }
    }
  });
  /**
   * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
   * @private
   */


  function computeMinSampleSize(scale, pixels) {
    var min = scale._length;
    var prev, curr, i, ilen;

    for (i = 1, ilen = pixels.length; i < ilen; ++i) {
      min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
    }

    for (i = 0, ilen = scale.getTicks().length; i < ilen; ++i) {
      curr = scale.getPixelForTick(i);
      min = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;
      prev = curr;
    }

    return min;
  }
  /**
   * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
   * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
   * mode currently always generates bars equally sized (until we introduce scriptable options?).
   * @private
   */


  function computeFitCategoryTraits(index, ruler, options) {
    var thickness = options.barThickness;
    var count = ruler.stackCount;
    var curr = ruler.pixels[index];
    var min = helpers$1.isNullOrUndef(thickness) ? computeMinSampleSize(ruler.scale, ruler.pixels) : -1;
    var size, ratio;

    if (helpers$1.isNullOrUndef(thickness)) {
      size = min * options.categoryPercentage;
      ratio = options.barPercentage;
    } else {
      // When bar thickness is enforced, category and bar percentages are ignored.
      // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
      // and deprecate barPercentage since this value is ignored when thickness is absolute.
      size = thickness * count;
      ratio = 1;
    }

    return {
      chunk: size / count,
      ratio: ratio,
      start: curr - size / 2
    };
  }
  /**
   * Computes an "optimal" category that globally arranges bars side by side (no gap when
   * percentage options are 1), based on the previous and following categories. This mode
   * generates bars with different widths when data are not evenly spaced.
   * @private
   */


  function computeFlexCategoryTraits(index, ruler, options) {
    var pixels = ruler.pixels;
    var curr = pixels[index];
    var prev = index > 0 ? pixels[index - 1] : null;
    var next = index < pixels.length - 1 ? pixels[index + 1] : null;
    var percent = options.categoryPercentage;
    var start, size;

    if (prev === null) {
      // first data: its size is double based on the next point or,
      // if it's also the last data, we use the scale size.
      prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
    }

    if (next === null) {
      // last data: its size is also double based on the previous point.
      next = curr + curr - prev;
    }

    start = curr - (curr - Math.min(prev, next)) / 2 * percent;
    size = Math.abs(next - prev) / 2 * percent;
    return {
      chunk: size / ruler.stackCount,
      ratio: options.barPercentage,
      start: start
    };
  }

  var controller_bar = core_datasetController.extend({
    dataElementType: elements.Rectangle,

    /**
     * @private
     */
    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth', 'barPercentage', 'barThickness', 'categoryPercentage', 'maxBarThickness', 'minBarLength'],
    initialize: function initialize() {
      var me = this;
      var meta, scaleOpts;
      core_datasetController.prototype.initialize.apply(me, arguments);
      meta = me.getMeta();
      meta.stack = me.getDataset().stack;
      meta.bar = true;
      scaleOpts = me._getIndexScale().options;
      deprecated('bar chart', scaleOpts.barPercentage, 'scales.[x/y]Axes.barPercentage', 'dataset.barPercentage');
      deprecated('bar chart', scaleOpts.barThickness, 'scales.[x/y]Axes.barThickness', 'dataset.barThickness');
      deprecated('bar chart', scaleOpts.categoryPercentage, 'scales.[x/y]Axes.categoryPercentage', 'dataset.categoryPercentage');
      deprecated('bar chart', me._getValueScale().options.minBarLength, 'scales.[x/y]Axes.minBarLength', 'dataset.minBarLength');
      deprecated('bar chart', scaleOpts.maxBarThickness, 'scales.[x/y]Axes.maxBarThickness', 'dataset.maxBarThickness');
    },
    update: function update(reset) {
      var me = this;
      var rects = me.getMeta().data;
      var i, ilen;
      me._ruler = me.getRuler();

      for (i = 0, ilen = rects.length; i < ilen; ++i) {
        me.updateElement(rects[i], i, reset);
      }
    },
    updateElement: function updateElement(rectangle, index, reset) {
      var me = this;
      var meta = me.getMeta();
      var dataset = me.getDataset();

      var options = me._resolveDataElementOptions(rectangle, index);

      rectangle._xScale = me.getScaleForId(meta.xAxisID);
      rectangle._yScale = me.getScaleForId(meta.yAxisID);
      rectangle._datasetIndex = me.index;
      rectangle._index = index;
      rectangle._model = {
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderSkipped: options.borderSkipped,
        borderWidth: options.borderWidth,
        datasetLabel: dataset.label,
        label: me.chart.data.labels[index]
      };

      if (helpers$1.isArray(dataset.data[index])) {
        rectangle._model.borderSkipped = null;
      }

      me._updateElementGeometry(rectangle, index, reset, options);

      rectangle.pivot();
    },

    /**
     * @private
     */
    _updateElementGeometry: function _updateElementGeometry(rectangle, index, reset, options) {
      var me = this;
      var model = rectangle._model;

      var vscale = me._getValueScale();

      var base = vscale.getBasePixel();
      var horizontal = vscale.isHorizontal();
      var ruler = me._ruler || me.getRuler();
      var vpixels = me.calculateBarValuePixels(me.index, index, options);
      var ipixels = me.calculateBarIndexPixels(me.index, index, ruler, options);
      model.horizontal = horizontal;
      model.base = reset ? base : vpixels.base;
      model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
      model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
      model.height = horizontal ? ipixels.size : undefined;
      model.width = horizontal ? undefined : ipixels.size;
    },

    /**
     * Returns the stacks based on groups and bar visibility.
     * @param {number} [last] - The dataset index
     * @returns {string[]} The list of stack IDs
     * @private
     */
    _getStacks: function _getStacks(last) {
      var me = this;

      var scale = me._getIndexScale();

      var metasets = scale._getMatchingVisibleMetas(me._type);

      var stacked = scale.options.stacked;
      var ilen = metasets.length;
      var stacks = [];
      var i, meta;

      for (i = 0; i < ilen; ++i) {
        meta = metasets[i]; // stacked   | meta.stack
        //           | found | not found | undefined
        // false     |   x   |     x     |     x
        // true      |       |     x     |
        // undefined |       |     x     |     x

        if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {
          stacks.push(meta.stack);
        }

        if (meta.index === last) {
          break;
        }
      }

      return stacks;
    },

    /**
     * Returns the effective number of stacks based on groups and bar visibility.
     * @private
     */
    getStackCount: function getStackCount() {
      return this._getStacks().length;
    },

    /**
     * Returns the stack index for the given dataset based on groups and bar visibility.
     * @param {number} [datasetIndex] - The dataset index
     * @param {string} [name] - The stack name to find
     * @returns {number} The stack index
     * @private
     */
    getStackIndex: function getStackIndex(datasetIndex, name) {
      var stacks = this._getStacks(datasetIndex);

      var index = name !== undefined ? stacks.indexOf(name) : -1; // indexOf returns -1 if element is not present

      return index === -1 ? stacks.length - 1 : index;
    },

    /**
     * @private
     */
    getRuler: function getRuler() {
      var me = this;

      var scale = me._getIndexScale();

      var pixels = [];
      var i, ilen;

      for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
        pixels.push(scale.getPixelForValue(null, i, me.index));
      }

      return {
        pixels: pixels,
        start: scale._startPixel,
        end: scale._endPixel,
        stackCount: me.getStackCount(),
        scale: scale
      };
    },

    /**
     * Note: pixel values are not clamped to the scale area.
     * @private
     */
    calculateBarValuePixels: function calculateBarValuePixels(datasetIndex, index, options) {
      var me = this;
      var chart = me.chart;

      var scale = me._getValueScale();

      var isHorizontal = scale.isHorizontal();
      var datasets = chart.data.datasets;

      var metasets = scale._getMatchingVisibleMetas(me._type);

      var value = scale._parseValue(datasets[datasetIndex].data[index]);

      var minBarLength = options.minBarLength;
      var stacked = scale.options.stacked;
      var stack = me.getMeta().stack;
      var start = value.start === undefined ? 0 : value.max >= 0 && value.min >= 0 ? value.min : value.max;
      var length = value.start === undefined ? value.end : value.max >= 0 && value.min >= 0 ? value.max - value.min : value.min - value.max;
      var ilen = metasets.length;
      var i, imeta, ivalue, base, head, size, stackLength;

      if (stacked || stacked === undefined && stack !== undefined) {
        for (i = 0; i < ilen; ++i) {
          imeta = metasets[i];

          if (imeta.index === datasetIndex) {
            break;
          }

          if (imeta.stack === stack) {
            stackLength = scale._parseValue(datasets[imeta.index].data[index]);
            ivalue = stackLength.start === undefined ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;

            if (value.min < 0 && ivalue < 0 || value.max >= 0 && ivalue > 0) {
              start += ivalue;
            }
          }
        }
      }

      base = scale.getPixelForValue(start);
      head = scale.getPixelForValue(start + length);
      size = head - base;

      if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
        size = minBarLength;

        if (length >= 0 && !isHorizontal || length < 0 && isHorizontal) {
          head = base - minBarLength;
        } else {
          head = base + minBarLength;
        }
      }

      return {
        size: size,
        base: base,
        head: head,
        center: head + size / 2
      };
    },

    /**
     * @private
     */
    calculateBarIndexPixels: function calculateBarIndexPixels(datasetIndex, index, ruler, options) {
      var me = this;
      var range = options.barThickness === 'flex' ? computeFlexCategoryTraits(index, ruler, options) : computeFitCategoryTraits(index, ruler, options);
      var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
      var center = range.start + range.chunk * stackIndex + range.chunk / 2;
      var size = Math.min(valueOrDefault$3(options.maxBarThickness, Infinity), range.chunk * range.ratio);
      return {
        base: center - size / 2,
        head: center + size / 2,
        center: center,
        size: size
      };
    },
    draw: function draw() {
      var me = this;
      var chart = me.chart;

      var scale = me._getValueScale();

      var rects = me.getMeta().data;
      var dataset = me.getDataset();
      var ilen = rects.length;
      var i = 0;
      helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);

      for (; i < ilen; ++i) {
        var val = scale._parseValue(dataset.data[i]);

        if (!isNaN(val.min) && !isNaN(val.max)) {
          rects[i].draw();
        }
      }

      helpers$1.canvas.unclipArea(chart.ctx);
    },

    /**
     * @private
     */
    _resolveDataElementOptions: function _resolveDataElementOptions() {
      var me = this;
      var values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments));

      var indexOpts = me._getIndexScale().options;

      var valueOpts = me._getValueScale().options;

      values.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values.barPercentage);
      values.barThickness = valueOrDefault$3(indexOpts.barThickness, values.barThickness);
      values.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values.categoryPercentage);
      values.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values.maxBarThickness);
      values.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values.minBarLength);
      return values;
    }
  });
  var valueOrDefault$4 = helpers$1.valueOrDefault;
  var resolve$1 = helpers$1.options.resolve;

  core_defaults._set('bubble', {
    hover: {
      mode: 'single'
    },
    scales: {
      xAxes: [{
        type: 'linear',
        // bubble should probably use a linear scale by default
        position: 'bottom',
        id: 'x-axis-0' // need an ID so datasets can reference the scale

      }],
      yAxes: [{
        type: 'linear',
        position: 'left',
        id: 'y-axis-0'
      }]
    },
    tooltips: {
      callbacks: {
        title: function title() {
          // Title doesn't make sense for scatter since we format the data as a point
          return '';
        },
        label: function label(item, data) {
          var datasetLabel = data.datasets[item.datasetIndex].label || '';
          var dataPoint = data.datasets[item.datasetIndex].data[item.index];
          return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
        }
      }
    }
  });

  var controller_bubble = core_datasetController.extend({
    /**
     * @protected
     */
    dataElementType: elements.Point,

    /**
     * @private
     */
    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'pointStyle', 'rotation'],

    /**
     * @protected
     */
    update: function update(reset) {
      var me = this;
      var meta = me.getMeta();
      var points = meta.data; // Update Points

      helpers$1.each(points, function (point, index) {
        me.updateElement(point, index, reset);
      });
    },

    /**
     * @protected
     */
    updateElement: function updateElement(point, index, reset) {
      var me = this;
      var meta = me.getMeta();
      var custom = point.custom || {};
      var xScale = me.getScaleForId(meta.xAxisID);
      var yScale = me.getScaleForId(meta.yAxisID);

      var options = me._resolveDataElementOptions(point, index);

      var data = me.getDataset().data[index];
      var dsIndex = me.index;
      var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
      var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);
      point._xScale = xScale;
      point._yScale = yScale;
      point._options = options;
      point._datasetIndex = dsIndex;
      point._index = index;
      point._model = {
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderWidth: options.borderWidth,
        hitRadius: options.hitRadius,
        pointStyle: options.pointStyle,
        rotation: options.rotation,
        radius: reset ? 0 : options.radius,
        skip: custom.skip || isNaN(x) || isNaN(y),
        x: x,
        y: y
      };
      point.pivot();
    },

    /**
     * @protected
     */
    setHoverStyle: function setHoverStyle(point) {
      var model = point._model;
      var options = point._options;
      var getHoverColor = helpers$1.getHoverColor;
      point.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth,
        radius: model.radius
      };
      model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
      model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
      model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
      model.radius = options.radius + options.hoverRadius;
    },

    /**
     * @private
     */
    _resolveDataElementOptions: function _resolveDataElementOptions(point, index) {
      var me = this;
      var chart = me.chart;
      var dataset = me.getDataset();
      var custom = point.custom || {};
      var data = dataset.data[index] || {};

      var values = core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments); // Scriptable options


      var context = {
        chart: chart,
        dataIndex: index,
        dataset: dataset,
        datasetIndex: me.index
      }; // In case values were cached (and thus frozen), we need to clone the values

      if (me._cachedDataOpts === values) {
        values = helpers$1.extend({}, values);
      } // Custom radius resolution


      values.radius = resolve$1([custom.radius, data.r, me._config.radius, chart.options.elements.point.radius], context, index);
      return values;
    }
  });
  var valueOrDefault$5 = helpers$1.valueOrDefault;
  var PI$1 = Math.PI;
  var DOUBLE_PI$1 = PI$1 * 2;
  var HALF_PI$1 = PI$1 / 2;

  core_defaults._set('doughnut', {
    animation: {
      // Boolean - Whether we animate the rotation of the Doughnut
      animateRotate: true,
      // Boolean - Whether we animate scaling the Doughnut from the centre
      animateScale: false
    },
    hover: {
      mode: 'single'
    },
    legendCallback: function legendCallback(chart) {
      var list = document.createElement('ul');
      var data = chart.data;
      var datasets = data.datasets;
      var labels = data.labels;
      var i, ilen, listItem, listItemSpan;
      list.setAttribute('class', chart.id + '-legend');

      if (datasets.length) {
        for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
          listItem = list.appendChild(document.createElement('li'));
          listItemSpan = listItem.appendChild(document.createElement('span'));
          listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];

          if (labels[i]) {
            listItem.appendChild(document.createTextNode(labels[i]));
          }
        }
      }

      return list.outerHTML;
    },
    legend: {
      labels: {
        generateLabels: function generateLabels(chart) {
          var data = chart.data;

          if (data.labels.length && data.datasets.length) {
            return data.labels.map(function (label, i) {
              var meta = chart.getDatasetMeta(0);
              var style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                // Extra data used for toggling the correct item
                index: i
              };
            });
          }

          return [];
        }
      },
      onClick: function onClick(e, legendItem) {
        var index = legendItem.index;
        var chart = this.chart;
        var i, ilen, meta;

        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
          meta = chart.getDatasetMeta(i); // toggle visibility of index if exists

          if (meta.data[index]) {
            meta.data[index].hidden = !meta.data[index].hidden;
          }
        }

        chart.update();
      }
    },
    // The percentage of the chart that we cut out of the middle.
    cutoutPercentage: 50,
    // The rotation of the chart, where the first data arc begins.
    rotation: -HALF_PI$1,
    // The total circumference of the chart.
    circumference: DOUBLE_PI$1,
    // Need to override these to give a nice default
    tooltips: {
      callbacks: {
        title: function title() {
          return '';
        },
        label: function label(tooltipItem, data) {
          var dataLabel = data.labels[tooltipItem.index];
          var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

          if (helpers$1.isArray(dataLabel)) {
            // show value on first line of multiline label
            // need to clone because we are changing the value
            dataLabel = dataLabel.slice();
            dataLabel[0] += value;
          } else {
            dataLabel += value;
          }

          return dataLabel;
        }
      }
    }
  });

  var controller_doughnut = core_datasetController.extend({
    dataElementType: elements.Arc,
    linkScales: helpers$1.noop,

    /**
     * @private
     */
    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'],
    // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
    getRingIndex: function getRingIndex(datasetIndex) {
      var ringIndex = 0;

      for (var j = 0; j < datasetIndex; ++j) {
        if (this.chart.isDatasetVisible(j)) {
          ++ringIndex;
        }
      }

      return ringIndex;
    },
    update: function update(reset) {
      var me = this;
      var chart = me.chart;
      var chartArea = chart.chartArea;
      var opts = chart.options;
      var ratioX = 1;
      var ratioY = 1;
      var offsetX = 0;
      var offsetY = 0;
      var meta = me.getMeta();
      var arcs = meta.data;
      var cutout = opts.cutoutPercentage / 100 || 0;
      var circumference = opts.circumference;

      var chartWeight = me._getRingWeight(me.index);

      var maxWidth, maxHeight, i, ilen; // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc

      if (circumference < DOUBLE_PI$1) {
        var startAngle = opts.rotation % DOUBLE_PI$1;
        startAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;
        var endAngle = startAngle + circumference;
        var startX = Math.cos(startAngle);
        var startY = Math.sin(startAngle);
        var endX = Math.cos(endAngle);
        var endY = Math.sin(endAngle);
        var contains0 = startAngle <= 0 && endAngle >= 0 || endAngle >= DOUBLE_PI$1;
        var contains90 = startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1 || endAngle >= DOUBLE_PI$1 + HALF_PI$1;
        var contains180 = startAngle === -PI$1 || endAngle >= PI$1;
        var contains270 = startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1 || endAngle >= PI$1 + HALF_PI$1;
        var minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);
        var minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);
        var maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);
        var maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);
        ratioX = (maxX - minX) / 2;
        ratioY = (maxY - minY) / 2;
        offsetX = -(maxX + minX) / 2;
        offsetY = -(maxY + minY) / 2;
      }

      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
      }

      chart.borderWidth = me.getMaxBorderWidth();
      maxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;
      maxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;
      chart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
      chart.innerRadius = Math.max(chart.outerRadius * cutout, 0);
      chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
      chart.offsetX = offsetX * chart.outerRadius;
      chart.offsetY = offsetY * chart.outerRadius;
      meta.total = me.calculateTotal();
      me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
      me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);

      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        me.updateElement(arcs[i], i, reset);
      }
    },
    updateElement: function updateElement(arc, index, reset) {
      var me = this;
      var chart = me.chart;
      var chartArea = chart.chartArea;
      var opts = chart.options;
      var animationOpts = opts.animation;
      var centerX = (chartArea.left + chartArea.right) / 2;
      var centerY = (chartArea.top + chartArea.bottom) / 2;
      var startAngle = opts.rotation; // non reset case handled later

      var endAngle = opts.rotation; // non reset case handled later

      var dataset = me.getDataset();
      var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / DOUBLE_PI$1);
      var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
      var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
      var options = arc._options || {};
      helpers$1.extend(arc, {
        // Utility
        _datasetIndex: me.index,
        _index: index,
        // Desired view properties
        _model: {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          borderAlign: options.borderAlign,
          x: centerX + chart.offsetX,
          y: centerY + chart.offsetY,
          startAngle: startAngle,
          endAngle: endAngle,
          circumference: circumference,
          outerRadius: outerRadius,
          innerRadius: innerRadius,
          label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
        }
      });
      var model = arc._model; // Set correct angles if not resetting

      if (!reset || !animationOpts.animateRotate) {
        if (index === 0) {
          model.startAngle = opts.rotation;
        } else {
          model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
        }

        model.endAngle = model.startAngle + model.circumference;
      }

      arc.pivot();
    },
    calculateTotal: function calculateTotal() {
      var dataset = this.getDataset();
      var meta = this.getMeta();
      var total = 0;
      var value;
      helpers$1.each(meta.data, function (element, index) {
        value = dataset.data[index];

        if (!isNaN(value) && !element.hidden) {
          total += Math.abs(value);
        }
      });
      /* if (total === 0) {
      	total = NaN;
      }*/

      return total;
    },
    calculateCircumference: function calculateCircumference(value) {
      var total = this.getMeta().total;

      if (total > 0 && !isNaN(value)) {
        return DOUBLE_PI$1 * (Math.abs(value) / total);
      }

      return 0;
    },
    // gets the max border or hover width to properly scale pie charts
    getMaxBorderWidth: function getMaxBorderWidth(arcs) {
      var me = this;
      var max = 0;
      var chart = me.chart;
      var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;

      if (!arcs) {
        // Find the outmost visible dataset
        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
          if (chart.isDatasetVisible(i)) {
            meta = chart.getDatasetMeta(i);
            arcs = meta.data;

            if (i !== me.index) {
              controller = meta.controller;
            }

            break;
          }
        }
      }

      if (!arcs) {
        return 0;
      }

      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        arc = arcs[i];

        if (controller) {
          controller._configure();

          options = controller._resolveDataElementOptions(arc, i);
        } else {
          options = arc._options;
        }

        if (options.borderAlign !== 'inner') {
          borderWidth = options.borderWidth;
          hoverWidth = options.hoverBorderWidth;
          max = borderWidth > max ? borderWidth : max;
          max = hoverWidth > max ? hoverWidth : max;
        }
      }

      return max;
    },

    /**
     * @protected
     */
    setHoverStyle: function setHoverStyle(arc) {
      var model = arc._model;
      var options = arc._options;
      var getHoverColor = helpers$1.getHoverColor;
      arc.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth
      };
      model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
      model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
      model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
    },

    /**
     * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly
     * @private
     */
    _getRingWeightOffset: function _getRingWeightOffset(datasetIndex) {
      var ringWeightOffset = 0;

      for (var i = 0; i < datasetIndex; ++i) {
        if (this.chart.isDatasetVisible(i)) {
          ringWeightOffset += this._getRingWeight(i);
        }
      }

      return ringWeightOffset;
    },

    /**
     * @private
     */
    _getRingWeight: function _getRingWeight(dataSetIndex) {
      return Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
    },

    /**
     * Returns the sum of all visibile data set weights.  This value can be 0.
     * @private
     */
    _getVisibleDatasetWeightTotal: function _getVisibleDatasetWeightTotal() {
      return this._getRingWeightOffset(this.chart.data.datasets.length);
    }
  });

  core_defaults._set('horizontalBar', {
    hover: {
      mode: 'index',
      axis: 'y'
    },
    scales: {
      xAxes: [{
        type: 'linear',
        position: 'bottom'
      }],
      yAxes: [{
        type: 'category',
        position: 'left',
        offset: true,
        gridLines: {
          offsetGridLines: true
        }
      }]
    },
    elements: {
      rectangle: {
        borderSkipped: 'left'
      }
    },
    tooltips: {
      mode: 'index',
      axis: 'y'
    }
  });

  core_defaults._set('global', {
    datasets: {
      horizontalBar: {
        categoryPercentage: 0.8,
        barPercentage: 0.9
      }
    }
  });

  var controller_horizontalBar = controller_bar.extend({
    /**
     * @private
     */
    _getValueScaleId: function _getValueScaleId() {
      return this.getMeta().xAxisID;
    },

    /**
     * @private
     */
    _getIndexScaleId: function _getIndexScaleId() {
      return this.getMeta().yAxisID;
    }
  });
  var valueOrDefault$6 = helpers$1.valueOrDefault;
  var resolve$2 = helpers$1.options.resolve;
  var isPointInArea = helpers$1.canvas._isPointInArea;

  core_defaults._set('line', {
    showLines: true,
    spanGaps: false,
    hover: {
      mode: 'label'
    },
    scales: {
      xAxes: [{
        type: 'category',
        id: 'x-axis-0'
      }],
      yAxes: [{
        type: 'linear',
        id: 'y-axis-0'
      }]
    }
  });

  function scaleClip(scale, halfBorderWidth) {
    var tickOpts = scale && scale.options.ticks || {};
    var reverse = tickOpts.reverse;
    var min = tickOpts.min === undefined ? halfBorderWidth : 0;
    var max = tickOpts.max === undefined ? halfBorderWidth : 0;
    return {
      start: reverse ? max : min,
      end: reverse ? min : max
    };
  }

  function defaultClip(xScale, yScale, borderWidth) {
    var halfBorderWidth = borderWidth / 2;
    var x = scaleClip(xScale, halfBorderWidth);
    var y = scaleClip(yScale, halfBorderWidth);
    return {
      top: y.end,
      right: x.end,
      bottom: y.start,
      left: x.start
    };
  }

  function toClip(value) {
    var t, r, b, l;

    if (helpers$1.isObject(value)) {
      t = value.top;
      r = value.right;
      b = value.bottom;
      l = value.left;
    } else {
      t = r = b = l = value;
    }

    return {
      top: t,
      right: r,
      bottom: b,
      left: l
    };
  }

  var controller_line = core_datasetController.extend({
    datasetElementType: elements.Line,
    dataElementType: elements.Point,

    /**
     * @private
     */
    _datasetElementOptions: ['backgroundColor', 'borderCapStyle', 'borderColor', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'borderWidth', 'cubicInterpolationMode', 'fill'],

    /**
     * @private
     */
    _dataElementOptions: {
      backgroundColor: 'pointBackgroundColor',
      borderColor: 'pointBorderColor',
      borderWidth: 'pointBorderWidth',
      hitRadius: 'pointHitRadius',
      hoverBackgroundColor: 'pointHoverBackgroundColor',
      hoverBorderColor: 'pointHoverBorderColor',
      hoverBorderWidth: 'pointHoverBorderWidth',
      hoverRadius: 'pointHoverRadius',
      pointStyle: 'pointStyle',
      radius: 'pointRadius',
      rotation: 'pointRotation'
    },
    update: function update(reset) {
      var me = this;
      var meta = me.getMeta();
      var line = meta.dataset;
      var points = meta.data || [];
      var options = me.chart.options;
      var config = me._config;
      var showLine = me._showLine = valueOrDefault$6(config.showLine, options.showLines);
      var i, ilen;
      me._xScale = me.getScaleForId(meta.xAxisID);
      me._yScale = me.getScaleForId(meta.yAxisID); // Update Line

      if (showLine) {
        // Compatibility: If the properties are defined with only the old name, use those values
        if (config.tension !== undefined && config.lineTension === undefined) {
          config.lineTension = config.tension;
        } // Utility


        line._scale = me._yScale;
        line._datasetIndex = me.index; // Data

        line._children = points; // Model

        line._model = me._resolveDatasetElementOptions(line);
        line.pivot();
      } // Update Points


      for (i = 0, ilen = points.length; i < ilen; ++i) {
        me.updateElement(points[i], i, reset);
      }

      if (showLine && line._model.tension !== 0) {
        me.updateBezierControlPoints();
      } // Now pivot the point for animation


      for (i = 0, ilen = points.length; i < ilen; ++i) {
        points[i].pivot();
      }
    },
    updateElement: function updateElement(point, index, reset) {
      var me = this;
      var meta = me.getMeta();
      var custom = point.custom || {};
      var dataset = me.getDataset();
      var datasetIndex = me.index;
      var value = dataset.data[index];
      var xScale = me._xScale;
      var yScale = me._yScale;
      var lineModel = meta.dataset._model;
      var x, y;

      var options = me._resolveDataElementOptions(point, index);

      x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
      y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility

      point._xScale = xScale;
      point._yScale = yScale;
      point._options = options;
      point._datasetIndex = datasetIndex;
      point._index = index; // Desired view properties

      point._model = {
        x: x,
        y: y,
        skip: custom.skip || isNaN(x) || isNaN(y),
        // Appearance
        radius: options.radius,
        pointStyle: options.pointStyle,
        rotation: options.rotation,
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderWidth: options.borderWidth,
        tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
        steppedLine: lineModel ? lineModel.steppedLine : false,
        // Tooltip
        hitRadius: options.hitRadius
      };
    },

    /**
     * @private
     */
    _resolveDatasetElementOptions: function _resolveDatasetElementOptions(element) {
      var me = this;
      var config = me._config;
      var custom = element.custom || {};
      var options = me.chart.options;
      var lineOptions = options.elements.line;

      var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments); // The default behavior of lines is to break at null values, according
      // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
      // This option gives lines the ability to span gaps


      values.spanGaps = valueOrDefault$6(config.spanGaps, options.spanGaps);
      values.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);
      values.steppedLine = resolve$2([custom.steppedLine, config.steppedLine, lineOptions.stepped]);
      values.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me._xScale, me._yScale, values.borderWidth)));
      return values;
    },
    calculatePointY: function calculatePointY(value, index, datasetIndex) {
      var me = this;
      var chart = me.chart;
      var yScale = me._yScale;
      var sumPos = 0;
      var sumNeg = 0;
      var i, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;

      if (yScale.options.stacked) {
        rightValue = +yScale.getRightValue(value);
        metasets = chart._getSortedVisibleDatasetMetas();
        ilen = metasets.length;

        for (i = 0; i < ilen; ++i) {
          dsMeta = metasets[i];

          if (dsMeta.index === datasetIndex) {
            break;
          }

          ds = chart.data.datasets[dsMeta.index];

          if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id) {
            stackedRightValue = +yScale.getRightValue(ds.data[index]);

            if (stackedRightValue < 0) {
              sumNeg += stackedRightValue || 0;
            } else {
              sumPos += stackedRightValue || 0;
            }
          }
        }

        if (rightValue < 0) {
          return yScale.getPixelForValue(sumNeg + rightValue);
        }

        return yScale.getPixelForValue(sumPos + rightValue);
      }

      return yScale.getPixelForValue(value);
    },
    updateBezierControlPoints: function updateBezierControlPoints() {
      var me = this;
      var chart = me.chart;
      var meta = me.getMeta();
      var lineModel = meta.dataset._model;
      var area = chart.chartArea;
      var points = meta.data || [];
      var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used

      if (lineModel.spanGaps) {
        points = points.filter(function (pt) {
          return !pt._model.skip;
        });
      }

      function capControlPoint(pt, min, max) {
        return Math.max(Math.min(pt, max), min);
      }

      if (lineModel.cubicInterpolationMode === 'monotone') {
        helpers$1.splineCurveMonotone(points);
      } else {
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          model = points[i]._model;
          controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i)._model, model, helpers$1.nextItem(points, i)._model, lineModel.tension);
          model.controlPointPreviousX = controlPoints.previous.x;
          model.controlPointPreviousY = controlPoints.previous.y;
          model.controlPointNextX = controlPoints.next.x;
          model.controlPointNextY = controlPoints.next.y;
        }
      }

      if (chart.options.elements.line.capBezierPoints) {
        for (i = 0, ilen = points.length; i < ilen; ++i) {
          model = points[i]._model;

          if (isPointInArea(model, area)) {
            if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
              model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
              model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
            }

            if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
              model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
              model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
            }
          }
        }
      }
    },
    draw: function draw() {
      var me = this;
      var chart = me.chart;
      var meta = me.getMeta();
      var points = meta.data || [];
      var area = chart.chartArea;
      var canvas = chart.canvas;
      var i = 0;
      var ilen = points.length;
      var clip;

      if (me._showLine) {
        clip = meta.dataset._model.clip;
        helpers$1.canvas.clipArea(chart.ctx, {
          left: clip.left === false ? 0 : area.left - clip.left,
          right: clip.right === false ? canvas.width : area.right + clip.right,
          top: clip.top === false ? 0 : area.top - clip.top,
          bottom: clip.bottom === false ? canvas.height : area.bottom + clip.bottom
        });
        meta.dataset.draw();
        helpers$1.canvas.unclipArea(chart.ctx);
      } // Draw the points


      for (; i < ilen; ++i) {
        points[i].draw(area);
      }
    },

    /**
     * @protected
     */
    setHoverStyle: function setHoverStyle(point) {
      var model = point._model;
      var options = point._options;
      var getHoverColor = helpers$1.getHoverColor;
      point.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth,
        radius: model.radius
      };
      model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
      model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
      model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
      model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
    }
  });
  var resolve$3 = helpers$1.options.resolve;

  core_defaults._set('polarArea', {
    scale: {
      type: 'radialLinear',
      angleLines: {
        display: false
      },
      gridLines: {
        circular: true
      },
      pointLabels: {
        display: false
      },
      ticks: {
        beginAtZero: true
      }
    },
    // Boolean - Whether to animate the rotation of the chart
    animation: {
      animateRotate: true,
      animateScale: true
    },
    startAngle: -0.5 * Math.PI,
    legendCallback: function legendCallback(chart) {
      var list = document.createElement('ul');
      var data = chart.data;
      var datasets = data.datasets;
      var labels = data.labels;
      var i, ilen, listItem, listItemSpan;
      list.setAttribute('class', chart.id + '-legend');

      if (datasets.length) {
        for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
          listItem = list.appendChild(document.createElement('li'));
          listItemSpan = listItem.appendChild(document.createElement('span'));
          listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];

          if (labels[i]) {
            listItem.appendChild(document.createTextNode(labels[i]));
          }
        }
      }

      return list.outerHTML;
    },
    legend: {
      labels: {
        generateLabels: function generateLabels(chart) {
          var data = chart.data;

          if (data.labels.length && data.datasets.length) {
            return data.labels.map(function (label, i) {
              var meta = chart.getDatasetMeta(0);
              var style = meta.controller.getStyle(i);
              return {
                text: label,
                fillStyle: style.backgroundColor,
                strokeStyle: style.borderColor,
                lineWidth: style.borderWidth,
                hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,
                // Extra data used for toggling the correct item
                index: i
              };
            });
          }

          return [];
        }
      },
      onClick: function onClick(e, legendItem) {
        var index = legendItem.index;
        var chart = this.chart;
        var i, ilen, meta;

        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
          meta = chart.getDatasetMeta(i);
          meta.data[index].hidden = !meta.data[index].hidden;
        }

        chart.update();
      }
    },
    // Need to override these to give a nice default
    tooltips: {
      callbacks: {
        title: function title() {
          return '';
        },
        label: function label(item, data) {
          return data.labels[item.index] + ': ' + item.yLabel;
        }
      }
    }
  });

  var controller_polarArea = core_datasetController.extend({
    dataElementType: elements.Arc,
    linkScales: helpers$1.noop,

    /**
     * @private
     */
    _dataElementOptions: ['backgroundColor', 'borderColor', 'borderWidth', 'borderAlign', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth'],

    /**
     * @private
     */
    _getIndexScaleId: function _getIndexScaleId() {
      return this.chart.scale.id;
    },

    /**
     * @private
     */
    _getValueScaleId: function _getValueScaleId() {
      return this.chart.scale.id;
    },
    update: function update(reset) {
      var me = this;
      var dataset = me.getDataset();
      var meta = me.getMeta();
      var start = me.chart.options.startAngle || 0;
      var starts = me._starts = [];
      var angles = me._angles = [];
      var arcs = meta.data;
      var i, ilen, angle;

      me._updateRadius();

      meta.count = me.countVisibleElements();

      for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
        starts[i] = start;
        angle = me._computeAngle(i);
        angles[i] = angle;
        start += angle;
      }

      for (i = 0, ilen = arcs.length; i < ilen; ++i) {
        arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
        me.updateElement(arcs[i], i, reset);
      }
    },

    /**
     * @private
     */
    _updateRadius: function _updateRadius() {
      var me = this;
      var chart = me.chart;
      var chartArea = chart.chartArea;
      var opts = chart.options;
      var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
      chart.outerRadius = Math.max(minSize / 2, 0);
      chart.innerRadius = Math.max(opts.cutoutPercentage ? chart.outerRadius / 100 * opts.cutoutPercentage : 1, 0);
      chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();
      me.outerRadius = chart.outerRadius - chart.radiusLength * me.index;
      me.innerRadius = me.outerRadius - chart.radiusLength;
    },
    updateElement: function updateElement(arc, index, reset) {
      var me = this;
      var chart = me.chart;
      var dataset = me.getDataset();
      var opts = chart.options;
      var animationOpts = opts.animation;
      var scale = chart.scale;
      var labels = chart.data.labels;
      var centerX = scale.xCenter;
      var centerY = scale.yCenter; // var negHalfPI = -0.5 * Math.PI;

      var datasetStartAngle = opts.startAngle;
      var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
      var startAngle = me._starts[index];
      var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);
      var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
      var options = arc._options || {};
      helpers$1.extend(arc, {
        // Utility
        _datasetIndex: me.index,
        _index: index,
        _scale: scale,
        // Desired view properties
        _model: {
          backgroundColor: options.backgroundColor,
          borderColor: options.borderColor,
          borderWidth: options.borderWidth,
          borderAlign: options.borderAlign,
          x: centerX,
          y: centerY,
          innerRadius: 0,
          outerRadius: reset ? resetRadius : distance,
          startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
          endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
          label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
        }
      });
      arc.pivot();
    },
    countVisibleElements: function countVisibleElements() {
      var dataset = this.getDataset();
      var meta = this.getMeta();
      var count = 0;
      helpers$1.each(meta.data, function (element, index) {
        if (!isNaN(dataset.data[index]) && !element.hidden) {
          count++;
        }
      });
      return count;
    },

    /**
     * @protected
     */
    setHoverStyle: function setHoverStyle(arc) {
      var model = arc._model;
      var options = arc._options;
      var getHoverColor = helpers$1.getHoverColor;
      var valueOrDefault = helpers$1.valueOrDefault;
      arc.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth
      };
      model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
      model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
      model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
    },

    /**
     * @private
     */
    _computeAngle: function _computeAngle(index) {
      var me = this;
      var count = this.getMeta().count;
      var dataset = me.getDataset();
      var meta = me.getMeta();

      if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
        return 0;
      } // Scriptable options


      var context = {
        chart: me.chart,
        dataIndex: index,
        dataset: dataset,
        datasetIndex: me.index
      };
      return resolve$3([me.chart.options.elements.arc.angle, 2 * Math.PI / count], context, index);
    }
  });

  core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));

  core_defaults._set('pie', {
    cutoutPercentage: 0
  }); // Pie charts are Doughnut chart with different defaults


  var controller_pie = controller_doughnut;
  var valueOrDefault$7 = helpers$1.valueOrDefault;

  core_defaults._set('radar', {
    spanGaps: false,
    scale: {
      type: 'radialLinear'
    },
    elements: {
      line: {
        fill: 'start',
        tension: 0 // no bezier in radar

      }
    }
  });

  var controller_radar = core_datasetController.extend({
    datasetElementType: elements.Line,
    dataElementType: elements.Point,
    linkScales: helpers$1.noop,

    /**
     * @private
     */
    _datasetElementOptions: ['backgroundColor', 'borderWidth', 'borderColor', 'borderCapStyle', 'borderDash', 'borderDashOffset', 'borderJoinStyle', 'fill'],

    /**
     * @private
     */
    _dataElementOptions: {
      backgroundColor: 'pointBackgroundColor',
      borderColor: 'pointBorderColor',
      borderWidth: 'pointBorderWidth',
      hitRadius: 'pointHitRadius',
      hoverBackgroundColor: 'pointHoverBackgroundColor',
      hoverBorderColor: 'pointHoverBorderColor',
      hoverBorderWidth: 'pointHoverBorderWidth',
      hoverRadius: 'pointHoverRadius',
      pointStyle: 'pointStyle',
      radius: 'pointRadius',
      rotation: 'pointRotation'
    },

    /**
     * @private
     */
    _getIndexScaleId: function _getIndexScaleId() {
      return this.chart.scale.id;
    },

    /**
     * @private
     */
    _getValueScaleId: function _getValueScaleId() {
      return this.chart.scale.id;
    },
    update: function update(reset) {
      var me = this;
      var meta = me.getMeta();
      var line = meta.dataset;
      var points = meta.data || [];
      var scale = me.chart.scale;
      var config = me._config;
      var i, ilen; // Compatibility: If the properties are defined with only the old name, use those values

      if (config.tension !== undefined && config.lineTension === undefined) {
        config.lineTension = config.tension;
      } // Utility


      line._scale = scale;
      line._datasetIndex = me.index; // Data

      line._children = points;
      line._loop = true; // Model

      line._model = me._resolveDatasetElementOptions(line);
      line.pivot(); // Update Points

      for (i = 0, ilen = points.length; i < ilen; ++i) {
        me.updateElement(points[i], i, reset);
      } // Update bezier control points


      me.updateBezierControlPoints(); // Now pivot the point for animation

      for (i = 0, ilen = points.length; i < ilen; ++i) {
        points[i].pivot();
      }
    },
    updateElement: function updateElement(point, index, reset) {
      var me = this;
      var custom = point.custom || {};
      var dataset = me.getDataset();
      var scale = me.chart.scale;
      var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);

      var options = me._resolveDataElementOptions(point, index);

      var lineModel = me.getMeta().dataset._model;

      var x = reset ? scale.xCenter : pointPosition.x;
      var y = reset ? scale.yCenter : pointPosition.y; // Utility

      point._scale = scale;
      point._options = options;
      point._datasetIndex = me.index;
      point._index = index; // Desired view properties

      point._model = {
        x: x,
        // value not used in dataset scale, but we want a consistent API between scales
        y: y,
        skip: custom.skip || isNaN(x) || isNaN(y),
        // Appearance
        radius: options.radius,
        pointStyle: options.pointStyle,
        rotation: options.rotation,
        backgroundColor: options.backgroundColor,
        borderColor: options.borderColor,
        borderWidth: options.borderWidth,
        tension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),
        // Tooltip
        hitRadius: options.hitRadius
      };
    },

    /**
     * @private
     */
    _resolveDatasetElementOptions: function _resolveDatasetElementOptions() {
      var me = this;
      var config = me._config;
      var options = me.chart.options;

      var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);

      values.spanGaps = valueOrDefault$7(config.spanGaps, options.spanGaps);
      values.tension = valueOrDefault$7(config.lineTension, options.elements.line.tension);
      return values;
    },
    updateBezierControlPoints: function updateBezierControlPoints() {
      var me = this;
      var meta = me.getMeta();
      var area = me.chart.chartArea;
      var points = meta.data || [];
      var i, ilen, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used

      if (meta.dataset._model.spanGaps) {
        points = points.filter(function (pt) {
          return !pt._model.skip;
        });
      }

      function capControlPoint(pt, min, max) {
        return Math.max(Math.min(pt, max), min);
      }

      for (i = 0, ilen = points.length; i < ilen; ++i) {
        model = points[i]._model;
        controlPoints = helpers$1.splineCurve(helpers$1.previousItem(points, i, true)._model, model, helpers$1.nextItem(points, i, true)._model, model.tension); // Prevent the bezier going outside of the bounds of the graph

        model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
        model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
        model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
        model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
      }
    },
    setHoverStyle: function setHoverStyle(point) {
      var model = point._model;
      var options = point._options;
      var getHoverColor = helpers$1.getHoverColor;
      point.$previousStyle = {
        backgroundColor: model.backgroundColor,
        borderColor: model.borderColor,
        borderWidth: model.borderWidth,
        radius: model.radius
      };
      model.backgroundColor = valueOrDefault$7(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
      model.borderColor = valueOrDefault$7(options.hoverBorderColor, getHoverColor(options.borderColor));
      model.borderWidth = valueOrDefault$7(options.hoverBorderWidth, options.borderWidth);
      model.radius = valueOrDefault$7(options.hoverRadius, options.radius);
    }
  });

  core_defaults._set('scatter', {
    hover: {
      mode: 'single'
    },
    scales: {
      xAxes: [{
        id: 'x-axis-1',
        // need an ID so datasets can reference the scale
        type: 'linear',
        // scatter should not use a category axis
        position: 'bottom'
      }],
      yAxes: [{
        id: 'y-axis-1',
        type: 'linear',
        position: 'left'
      }]
    },
    tooltips: {
      callbacks: {
        title: function title() {
          return ''; // doesn't make sense for scatter since data are formatted as a point
        },
        label: function label(item) {
          return '(' + item.xLabel + ', ' + item.yLabel + ')';
        }
      }
    }
  });

  core_defaults._set('global', {
    datasets: {
      scatter: {
        showLine: false
      }
    }
  }); // Scatter charts use line controllers


  var controller_scatter = controller_line; // NOTE export a map in which the key represents the controller type, not
  // the class, and so must be CamelCase in order to be correctly retrieved
  // by the controller in core.controller.js (`controllers[meta.type]`).

  var controllers = {
    bar: controller_bar,
    bubble: controller_bubble,
    doughnut: controller_doughnut,
    horizontalBar: controller_horizontalBar,
    line: controller_line,
    polarArea: controller_polarArea,
    pie: controller_pie,
    radar: controller_radar,
    scatter: controller_scatter
  };
  /**
   * Helper function to get relative position for an event
   * @param {Event|IEvent} event - The event to get the position for
   * @param {Chart} chart - The chart
   * @returns {object} the event position
   */

  function getRelativePosition(e, chart) {
    if (e["native"]) {
      return {
        x: e.x,
        y: e.y
      };
    }

    return helpers$1.getRelativePosition(e, chart);
  }
  /**
   * Helper function to traverse all of the visible elements in the chart
   * @param {Chart} chart - the chart
   * @param {function} handler - the callback to execute for each visible item
   */


  function parseVisibleItems(chart, handler) {
    var metasets = chart._getSortedVisibleDatasetMetas();

    var metadata, i, j, ilen, jlen, element;

    for (i = 0, ilen = metasets.length; i < ilen; ++i) {
      metadata = metasets[i].data;

      for (j = 0, jlen = metadata.length; j < jlen; ++j) {
        element = metadata[j];

        if (!element._view.skip) {
          handler(element);
        }
      }
    }
  }
  /**
   * Helper function to get the items that intersect the event position
   * @param {ChartElement[]} items - elements to filter
   * @param {object} position - the point to be nearest to
   * @return {ChartElement[]} the nearest items
   */


  function getIntersectItems(chart, position) {
    var elements = [];
    parseVisibleItems(chart, function (element) {
      if (element.inRange(position.x, position.y)) {
        elements.push(element);
      }
    });
    return elements;
  }
  /**
   * Helper function to get the items nearest to the event position considering all visible items in teh chart
   * @param {Chart} chart - the chart to look at elements from
   * @param {object} position - the point to be nearest to
   * @param {boolean} intersect - if true, only consider items that intersect the position
   * @param {function} distanceMetric - function to provide the distance between points
   * @return {ChartElement[]} the nearest items
   */


  function getNearestItems(chart, position, intersect, distanceMetric) {
    var minDistance = Number.POSITIVE_INFINITY;
    var nearestItems = [];
    parseVisibleItems(chart, function (element) {
      if (intersect && !element.inRange(position.x, position.y)) {
        return;
      }

      var center = element.getCenterPoint();
      var distance = distanceMetric(position, center);

      if (distance < minDistance) {
        nearestItems = [element];
        minDistance = distance;
      } else if (distance === minDistance) {
        // Can have multiple items at the same distance in which case we sort by size
        nearestItems.push(element);
      }
    });
    return nearestItems;
  }
  /**
   * Get a distance metric function for two points based on the
   * axis mode setting
   * @param {string} axis - the axis mode. x|y|xy
   */


  function getDistanceMetricForAxis(axis) {
    var useX = axis.indexOf('x') !== -1;
    var useY = axis.indexOf('y') !== -1;
    return function (pt1, pt2) {
      var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
      var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
      return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
    };
  }

  function indexMode(chart, e, options) {
    var position = getRelativePosition(e, chart); // Default axis for index mode is 'x' to match old behaviour

    options.axis = options.axis || 'x';
    var distanceMetric = getDistanceMetricForAxis(options.axis);
    var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
    var elements = [];

    if (!items.length) {
      return [];
    }

    chart._getSortedVisibleDatasetMetas().forEach(function (meta) {
      var element = meta.data[items[0]._index]; // don't count items that are skipped (null data)

      if (element && !element._view.skip) {
        elements.push(element);
      }
    });

    return elements;
  }
  /**
   * @interface IInteractionOptions
   */

  /**
   * If true, only consider items that intersect the point
   * @name IInterfaceOptions#boolean
   * @type Boolean
   */

  /**
   * Contains interaction related functions
   * @namespace Chart.Interaction
   */


  var core_interaction = {
    // Helper function for different modes
    modes: {
      single: function single(chart, e) {
        var position = getRelativePosition(e, chart);
        var elements = [];
        parseVisibleItems(chart, function (element) {
          if (element.inRange(position.x, position.y)) {
            elements.push(element);
            return elements;
          }
        });
        return elements.slice(0, 1);
      },

      /**
       * @function Chart.Interaction.modes.label
       * @deprecated since version 2.4.0
       * @todo remove at version 3
       * @private
       */
      label: indexMode,

      /**
       * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
       * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
       * @function Chart.Interaction.modes.index
       * @since v2.4.0
       * @param {Chart} chart - the chart we are returning items from
       * @param {Event} e - the event we are find things at
       * @param {IInteractionOptions} options - options to use during interaction
       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
       */
      index: indexMode,

      /**
       * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
       * If the options.intersect is false, we find the nearest item and return the items in that dataset
       * @function Chart.Interaction.modes.dataset
       * @param {Chart} chart - the chart we are returning items from
       * @param {Event} e - the event we are find things at
       * @param {IInteractionOptions} options - options to use during interaction
       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
       */
      dataset: function dataset(chart, e, options) {
        var position = getRelativePosition(e, chart);
        options.axis = options.axis || 'xy';
        var distanceMetric = getDistanceMetricForAxis(options.axis);
        var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

        if (items.length > 0) {
          items = chart.getDatasetMeta(items[0]._datasetIndex).data;
        }

        return items;
      },

      /**
       * @function Chart.Interaction.modes.x-axis
       * @deprecated since version 2.4.0. Use index mode and intersect == true
       * @todo remove at version 3
       * @private
       */
      'x-axis': function xAxis(chart, e) {
        return indexMode(chart, e, {
          intersect: false
        });
      },

      /**
       * Point mode returns all elements that hit test based on the event position
       * of the event
       * @function Chart.Interaction.modes.intersect
       * @param {Chart} chart - the chart we are returning items from
       * @param {Event} e - the event we are find things at
       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
       */
      point: function point(chart, e) {
        var position = getRelativePosition(e, chart);
        return getIntersectItems(chart, position);
      },

      /**
       * nearest mode returns the element closest to the point
       * @function Chart.Interaction.modes.intersect
       * @param {Chart} chart - the chart we are returning items from
       * @param {Event} e - the event we are find things at
       * @param {IInteractionOptions} options - options to use
       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
       */
      nearest: function nearest(chart, e, options) {
        var position = getRelativePosition(e, chart);
        options.axis = options.axis || 'xy';
        var distanceMetric = getDistanceMetricForAxis(options.axis);
        return getNearestItems(chart, position, options.intersect, distanceMetric);
      },

      /**
       * x mode returns the elements that hit-test at the current x coordinate
       * @function Chart.Interaction.modes.x
       * @param {Chart} chart - the chart we are returning items from
       * @param {Event} e - the event we are find things at
       * @param {IInteractionOptions} options - options to use
       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
       */
      x: function x(chart, e, options) {
        var position = getRelativePosition(e, chart);
        var items = [];
        var intersectsItem = false;
        parseVisibleItems(chart, function (element) {
          if (element.inXRange(position.x)) {
            items.push(element);
          }

          if (element.inRange(position.x, position.y)) {
            intersectsItem = true;
          }
        }); // If we want to trigger on an intersect and we don't have any items
        // that intersect the position, return nothing

        if (options.intersect && !intersectsItem) {
          items = [];
        }

        return items;
      },

      /**
       * y mode returns the elements that hit-test at the current y coordinate
       * @function Chart.Interaction.modes.y
       * @param {Chart} chart - the chart we are returning items from
       * @param {Event} e - the event we are find things at
       * @param {IInteractionOptions} options - options to use
       * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
       */
      y: function y(chart, e, options) {
        var position = getRelativePosition(e, chart);
        var items = [];
        var intersectsItem = false;
        parseVisibleItems(chart, function (element) {
          if (element.inYRange(position.y)) {
            items.push(element);
          }

          if (element.inRange(position.x, position.y)) {
            intersectsItem = true;
          }
        }); // If we want to trigger on an intersect and we don't have any items
        // that intersect the position, return nothing

        if (options.intersect && !intersectsItem) {
          items = [];
        }

        return items;
      }
    }
  };
  var extend = helpers$1.extend;

  function filterByPosition(array, position) {
    return helpers$1.where(array, function (v) {
      return v.pos === position;
    });
  }

  function sortByWeight(array, reverse) {
    return array.sort(function (a, b) {
      var v0 = reverse ? b : a;
      var v1 = reverse ? a : b;
      return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
    });
  }

  function wrapBoxes(boxes) {
    var layoutBoxes = [];
    var i, ilen, box;

    for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
      box = boxes[i];
      layoutBoxes.push({
        index: i,
        box: box,
        pos: box.position,
        horizontal: box.isHorizontal(),
        weight: box.weight
      });
    }

    return layoutBoxes;
  }

  function setLayoutDims(layouts, params) {
    var i, ilen, layout;

    for (i = 0, ilen = layouts.length; i < ilen; ++i) {
      layout = layouts[i]; // store width used instead of chartArea.w in fitBoxes

      layout.width = layout.horizontal ? layout.box.fullWidth && params.availableWidth : params.vBoxMaxWidth; // store height used instead of chartArea.h in fitBoxes

      layout.height = layout.horizontal && params.hBoxMaxHeight;
    }
  }

  function buildLayoutBoxes(boxes) {
    var layoutBoxes = wrapBoxes(boxes);
    var left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
    var right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
    var top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
    var bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
    return {
      leftAndTop: left.concat(top),
      rightAndBottom: right.concat(bottom),
      chartArea: filterByPosition(layoutBoxes, 'chartArea'),
      vertical: left.concat(right),
      horizontal: top.concat(bottom)
    };
  }

  function getCombinedMax(maxPadding, chartArea, a, b) {
    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
  }

  function updateDims(chartArea, params, layout) {
    var box = layout.box;
    var maxPadding = chartArea.maxPadding;
    var newWidth, newHeight;

    if (layout.size) {
      // this layout was already counted for, lets first reduce old size
      chartArea[layout.pos] -= layout.size;
    }

    layout.size = layout.horizontal ? box.height : box.width;
    chartArea[layout.pos] += layout.size;

    if (box.getPadding) {
      var boxPadding = box.getPadding();
      maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
      maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
      maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
      maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
    }

    newWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right');
    newHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom');

    if (newWidth !== chartArea.w || newHeight !== chartArea.h) {
      chartArea.w = newWidth;
      chartArea.h = newHeight; // return true if chart area changed in layout's direction

      var sizes = layout.horizontal ? [newWidth, chartArea.w] : [newHeight, chartArea.h];
      return sizes[0] !== sizes[1] && (!isNaN(sizes[0]) || !isNaN(sizes[1]));
    }
  }

  function handleMaxPadding(chartArea) {
    var maxPadding = chartArea.maxPadding;

    function updatePos(pos) {
      var change = Math.max(maxPadding[pos] - chartArea[pos], 0);
      chartArea[pos] += change;
      return change;
    }

    chartArea.y += updatePos('top');
    chartArea.x += updatePos('left');
    updatePos('right');
    updatePos('bottom');
  }

  function getMargins(horizontal, chartArea) {
    var maxPadding = chartArea.maxPadding;

    function marginForPositions(positions) {
      var margin = {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      };
      positions.forEach(function (pos) {
        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
      });
      return margin;
    }

    return horizontal ? marginForPositions(['left', 'right']) : marginForPositions(['top', 'bottom']);
  }

  function fitBoxes(boxes, chartArea, params) {
    var refitBoxes = [];
    var i, ilen, layout, box, refit, changed;

    for (i = 0, ilen = boxes.length; i < ilen; ++i) {
      layout = boxes[i];
      box = layout.box;
      box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));

      if (updateDims(chartArea, params, layout)) {
        changed = true;

        if (refitBoxes.length) {
          // Dimensions changed and there were non full width boxes before this
          // -> we have to refit those
          refit = true;
        }
      }

      if (!box.fullWidth) {
        // fullWidth boxes don't need to be re-fitted in any case
        refitBoxes.push(layout);
      }
    }

    return refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;
  }

  function placeBoxes(boxes, chartArea, params) {
    var userPadding = params.padding;
    var x = chartArea.x;
    var y = chartArea.y;
    var i, ilen, layout, box;

    for (i = 0, ilen = boxes.length; i < ilen; ++i) {
      layout = boxes[i];
      box = layout.box;

      if (layout.horizontal) {
        box.left = box.fullWidth ? userPadding.left : chartArea.left;
        box.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;
        box.top = y;
        box.bottom = y + box.height;
        box.width = box.right - box.left;
        y = box.bottom;
      } else {
        box.left = x;
        box.right = x + box.width;
        box.top = chartArea.top;
        box.bottom = chartArea.top + chartArea.h;
        box.height = box.bottom - box.top;
        x = box.right;
      }
    }

    chartArea.x = x;
    chartArea.y = y;
  }

  core_defaults._set('global', {
    layout: {
      padding: {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      }
    }
  });
  /**
   * @interface ILayoutItem
   * @prop {string} position - The position of the item in the chart layout. Possible values are
   * 'left', 'top', 'right', 'bottom', and 'chartArea'
   * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area
   * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
   * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
   * @prop {function} update - Takes two parameters: width and height. Returns size of item
   * @prop {function} getPadding -  Returns an object with padding on the edges
   * @prop {number} width - Width of item. Must be valid after update()
   * @prop {number} height - Height of item. Must be valid after update()
   * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update
   * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update
   * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update
   * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
   */
  // The layout service is very self explanatory.  It's responsible for the layout within a chart.
  // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
  // It is this service's responsibility of carrying out that layout.


  var core_layouts = {
    defaults: {},

    /**
     * Register a box to a chart.
     * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
     * @param {Chart} chart - the chart to use
     * @param {ILayoutItem} item - the item to add to be layed out
     */
    addBox: function addBox(chart, item) {
      if (!chart.boxes) {
        chart.boxes = [];
      } // initialize item with default values


      item.fullWidth = item.fullWidth || false;
      item.position = item.position || 'top';
      item.weight = item.weight || 0;

      item._layers = item._layers || function () {
        return [{
          z: 0,
          draw: function draw() {
            item.draw.apply(item, arguments);
          }
        }];
      };

      chart.boxes.push(item);
    },

    /**
     * Remove a layoutItem from a chart
     * @param {Chart} chart - the chart to remove the box from
     * @param {ILayoutItem} layoutItem - the item to remove from the layout
     */
    removeBox: function removeBox(chart, layoutItem) {
      var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;

      if (index !== -1) {
        chart.boxes.splice(index, 1);
      }
    },

    /**
     * Sets (or updates) options on the given `item`.
     * @param {Chart} chart - the chart in which the item lives (or will be added to)
     * @param {ILayoutItem} item - the item to configure with the given options
     * @param {object} options - the new item options.
     */
    configure: function configure(chart, item, options) {
      var props = ['fullWidth', 'position', 'weight'];
      var ilen = props.length;
      var i = 0;
      var prop;

      for (; i < ilen; ++i) {
        prop = props[i];

        if (options.hasOwnProperty(prop)) {
          item[prop] = options[prop];
        }
      }
    },

    /**
     * Fits boxes of the given chart into the given size by having each box measure itself
     * then running a fitting algorithm
     * @param {Chart} chart - the chart
     * @param {number} width - the width to fit into
     * @param {number} height - the height to fit into
     */
    update: function update(chart, width, height) {
      if (!chart) {
        return;
      }

      var layoutOptions = chart.options.layout || {};
      var padding = helpers$1.options.toPadding(layoutOptions.padding);
      var availableWidth = width - padding.width;
      var availableHeight = height - padding.height;
      var boxes = buildLayoutBoxes(chart.boxes);
      var verticalBoxes = boxes.vertical;
      var horizontalBoxes = boxes.horizontal; // Essentially we now have any number of boxes on each of the 4 sides.
      // Our canvas looks like the following.
      // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
      // B1 is the bottom axis
      // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
      // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
      // an error will be thrown.
      //
      // |----------------------------------------------------|
      // |                  T1 (Full Width)                   |
      // |----------------------------------------------------|
      // |    |    |                 T2                  |    |
      // |    |----|-------------------------------------|----|
      // |    |    | C1 |                           | C2 |    |
      // |    |    |----|                           |----|    |
      // |    |    |                                     |    |
      // | L1 | L2 |           ChartArea (C0)            | R1 |
      // |    |    |                                     |    |
      // |    |    |----|                           |----|    |
      // |    |    | C3 |                           | C4 |    |
      // |    |----|-------------------------------------|----|
      // |    |    |                 B1                  |    |
      // |----------------------------------------------------|
      // |                  B2 (Full Width)                   |
      // |----------------------------------------------------|
      //

      var params = Object.freeze({
        outerWidth: width,
        outerHeight: height,
        padding: padding,
        availableWidth: availableWidth,
        vBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,
        hBoxMaxHeight: availableHeight / 2
      });
      var chartArea = extend({
        maxPadding: extend({}, padding),
        w: availableWidth,
        h: availableHeight,
        x: padding.left,
        y: padding.top
      }, padding);
      setLayoutDims(verticalBoxes.concat(horizontalBoxes), params); // First fit vertical boxes

      fitBoxes(verticalBoxes, chartArea, params); // Then fit horizontal boxes

      if (fitBoxes(horizontalBoxes, chartArea, params)) {
        // if the area changed, re-fit vertical boxes
        fitBoxes(verticalBoxes, chartArea, params);
      }

      handleMaxPadding(chartArea); // Finally place the boxes to correct coordinates

      placeBoxes(boxes.leftAndTop, chartArea, params); // Move to opposite side of chart

      chartArea.x += chartArea.w;
      chartArea.y += chartArea.h;
      placeBoxes(boxes.rightAndBottom, chartArea, params);
      chart.chartArea = {
        left: chartArea.left,
        top: chartArea.top,
        right: chartArea.left + chartArea.w,
        bottom: chartArea.top + chartArea.h
      }; // Finally update boxes in chartArea (radial scale for example)

      helpers$1.each(boxes.chartArea, function (layout) {
        var box = layout.box;
        extend(box, chart.chartArea);
        box.update(chartArea.w, chartArea.h);
      });
    }
  };
  /**
   * Platform fallback implementation (minimal).
   * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
   */

  var platform_basic = {
    acquireContext: function acquireContext(item) {
      if (item && item.canvas) {
        // Support for any object associated to a canvas (including a context2d)
        item = item.canvas;
      }

      return item && item.getContext('2d') || null;
    }
  };
  var platform_dom = "/*\r\n * DOM element rendering detection\r\n * https://davidwalsh.name/detect-node-insertion\r\n */\r\n@keyframes chartjs-render-animation {\r\n\tfrom { opacity: 0.99; }\r\n\tto { opacity: 1; }\r\n}\r\n\r\n.chartjs-render-monitor {\r\n\tanimation: chartjs-render-animation 0.001s;\r\n}\r\n\r\n/*\r\n * DOM element resizing detection\r\n * https://github.com/marcj/css-element-queries\r\n */\r\n.chartjs-size-monitor,\r\n.chartjs-size-monitor-expand,\r\n.chartjs-size-monitor-shrink {\r\n\tposition: absolute;\r\n\tdirection: ltr;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\tright: 0;\r\n\tbottom: 0;\r\n\toverflow: hidden;\r\n\tpointer-events: none;\r\n\tvisibility: hidden;\r\n\tz-index: -1;\r\n}\r\n\r\n.chartjs-size-monitor-expand > div {\r\n\tposition: absolute;\r\n\twidth: 1000000px;\r\n\theight: 1000000px;\r\n\tleft: 0;\r\n\ttop: 0;\r\n}\r\n\r\n.chartjs-size-monitor-shrink > div {\r\n\tposition: absolute;\r\n\twidth: 200%;\r\n\theight: 200%;\r\n\tleft: 0;\r\n\ttop: 0;\r\n}\r\n";
  var platform_dom$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': platform_dom
  });
  var stylesheet = getCjsExportFromNamespace(platform_dom$1);
  var EXPANDO_KEY = '$chartjs';
  var CSS_PREFIX = 'chartjs-';
  var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';
  var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
  var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
  var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];
  /**
   * DOM event types -> Chart.js event types.
   * Note: only events with different types are mapped.
   * @see https://developer.mozilla.org/en-US/docs/Web/Events
   */

  var EVENT_TYPES = {
    touchstart: 'mousedown',
    touchmove: 'mousemove',
    touchend: 'mouseup',
    pointerenter: 'mouseenter',
    pointerdown: 'mousedown',
    pointermove: 'mousemove',
    pointerup: 'mouseup',
    pointerleave: 'mouseout',
    pointerout: 'mouseout'
  };
  /**
   * The "used" size is the final value of a dimension property after all calculations have
   * been performed. This method uses the computed style of `element` but returns undefined
   * if the computed style is not expressed in pixels. That can happen in some cases where
   * `element` has a size relative to its parent and this last one is not yet displayed,
   * for example because of `display: none` on a parent node.
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
   * @returns {number} Size in pixels or undefined if unknown.
   */

  function readUsedSize(element, property) {
    var value = helpers$1.getStyle(element, property);
    var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
    return matches ? Number(matches[1]) : undefined;
  }
  /**
   * Initializes the canvas style and render size without modifying the canvas display size,
   * since responsiveness is handled by the controller.resize() method. The config is used
   * to determine the aspect ratio to apply in case no explicit height has been specified.
   */


  function initCanvas(canvas, config) {
    var style = canvas.style; // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
    // returns null or '' if no explicit value has been set to the canvas attribute.

    var renderHeight = canvas.getAttribute('height');
    var renderWidth = canvas.getAttribute('width'); // Chart.js modifies some canvas values that we want to restore on destroy

    canvas[EXPANDO_KEY] = {
      initial: {
        height: renderHeight,
        width: renderWidth,
        style: {
          display: style.display,
          height: style.height,
          width: style.width
        }
      }
    }; // Force canvas to display as block to avoid extra space caused by inline
    // elements, which would interfere with the responsive resize process.
    // https://github.com/chartjs/Chart.js/issues/2538

    style.display = style.display || 'block';

    if (renderWidth === null || renderWidth === '') {
      var displayWidth = readUsedSize(canvas, 'width');

      if (displayWidth !== undefined) {
        canvas.width = displayWidth;
      }
    }

    if (renderHeight === null || renderHeight === '') {
      if (canvas.style.height === '') {
        // If no explicit render height and style height, let's apply the aspect ratio,
        // which one can be specified by the user but also by charts as default option
        // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
        canvas.height = canvas.width / (config.options.aspectRatio || 2);
      } else {
        var displayHeight = readUsedSize(canvas, 'height');

        if (displayWidth !== undefined) {
          canvas.height = displayHeight;
        }
      }
    }

    return canvas;
  }
  /**
   * Detects support for options object argument in addEventListener.
   * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
   * @private
   */


  var supportsEventListenerOptions = function () {
    var supports = false;

    try {
      var options = Object.defineProperty({}, 'passive', {
        // eslint-disable-next-line getter-return
        get: function get() {
          supports = true;
        }
      });
      window.addEventListener('e', null, options);
    } catch (e) {// continue regardless of error
    }

    return supports;
  }(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
  // https://github.com/chartjs/Chart.js/issues/4287


  var eventListenerOptions = supportsEventListenerOptions ? {
    passive: true
  } : false;

  function addListener(node, type, listener) {
    node.addEventListener(type, listener, eventListenerOptions);
  }

  function removeListener(node, type, listener) {
    node.removeEventListener(type, listener, eventListenerOptions);
  }

  function createEvent(type, chart, x, y, nativeEvent) {
    return {
      type: type,
      chart: chart,
      "native": nativeEvent || null,
      x: x !== undefined ? x : null,
      y: y !== undefined ? y : null
    };
  }

  function fromNativeEvent(event, chart) {
    var type = EVENT_TYPES[event.type] || event.type;
    var pos = helpers$1.getRelativePosition(event, chart);
    return createEvent(type, chart, pos.x, pos.y, event);
  }

  function throttled(fn, thisArg) {
    var ticking = false;
    var args = [];
    return function () {
      args = Array.prototype.slice.call(arguments);
      thisArg = thisArg || this;

      if (!ticking) {
        ticking = true;
        helpers$1.requestAnimFrame.call(window, function () {
          ticking = false;
          fn.apply(thisArg, args);
        });
      }
    };
  }

  function createDiv(cls) {
    var el = document.createElement('div');
    el.className = cls || '';
    return el;
  } // Implementation based on https://github.com/marcj/css-element-queries


  function createResizer(handler) {
    var maxSize = 1000000; // NOTE(SB) Don't use innerHTML because it could be considered unsafe.
    // https://github.com/chartjs/Chart.js/issues/5902

    var resizer = createDiv(CSS_SIZE_MONITOR);
    var expand = createDiv(CSS_SIZE_MONITOR + '-expand');
    var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');
    expand.appendChild(createDiv());
    shrink.appendChild(createDiv());
    resizer.appendChild(expand);
    resizer.appendChild(shrink);

    resizer._reset = function () {
      expand.scrollLeft = maxSize;
      expand.scrollTop = maxSize;
      shrink.scrollLeft = maxSize;
      shrink.scrollTop = maxSize;
    };

    var onScroll = function onScroll() {
      resizer._reset();

      handler();
    };

    addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
    addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));
    return resizer;
  } // https://davidwalsh.name/detect-node-insertion


  function watchForRender(node, handler) {
    var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

    var proxy = expando.renderProxy = function (e) {
      if (e.animationName === CSS_RENDER_ANIMATION) {
        handler();
      }
    };

    helpers$1.each(ANIMATION_START_EVENTS, function (type) {
      addListener(node, type, proxy);
    }); // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
    // is removed then added back immediately (same animation frame?). Accessing the
    // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
    // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
    // https://github.com/chartjs/Chart.js/issues/4737

    expando.reflow = !!node.offsetParent;
    node.classList.add(CSS_RENDER_MONITOR);
  }

  function unwatchForRender(node) {
    var expando = node[EXPANDO_KEY] || {};
    var proxy = expando.renderProxy;

    if (proxy) {
      helpers$1.each(ANIMATION_START_EVENTS, function (type) {
        removeListener(node, type, proxy);
      });
      delete expando.renderProxy;
    }

    node.classList.remove(CSS_RENDER_MONITOR);
  }

  function addResizeListener(node, listener, chart) {
    var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {}); // Let's keep track of this added resizer and thus avoid DOM query when removing it.

    var resizer = expando.resizer = createResizer(throttled(function () {
      if (expando.resizer) {
        var container = chart.options.maintainAspectRatio && node.parentNode;
        var w = container ? container.clientWidth : 0;
        listener(createEvent('resize', chart));

        if (container && container.clientWidth < w && chart.canvas) {
          // If the container size shrank during chart resize, let's assume
          // scrollbar appeared. So we resize again with the scrollbar visible -
          // effectively making chart smaller and the scrollbar hidden again.
          // Because we are inside `throttled`, and currently `ticking`, scroll
          // events are ignored during this whole 2 resize process.
          // If we assumed wrong and something else happened, we are resizing
          // twice in a frame (potential performance issue)
          listener(createEvent('resize', chart));
        }
      }
    })); // The resizer needs to be attached to the node parent, so we first need to be
    // sure that `node` is attached to the DOM before injecting the resizer element.

    watchForRender(node, function () {
      if (expando.resizer) {
        var container = node.parentNode;

        if (container && container !== resizer.parentNode) {
          container.insertBefore(resizer, container.firstChild);
        } // The container size might have changed, let's reset the resizer state.


        resizer._reset();
      }
    });
  }

  function removeResizeListener(node) {
    var expando = node[EXPANDO_KEY] || {};
    var resizer = expando.resizer;
    delete expando.resizer;
    unwatchForRender(node);

    if (resizer && resizer.parentNode) {
      resizer.parentNode.removeChild(resizer);
    }
  }
  /**
   * Injects CSS styles inline if the styles are not already present.
   * @param {HTMLDocument|ShadowRoot} rootNode - the node to contain the <style>.
   * @param {string} css - the CSS to be injected.
   */


  function injectCSS(rootNode, css) {
    // https://stackoverflow.com/q/3922139
    var expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});

    if (!expando.containsStyles) {
      expando.containsStyles = true;
      css = '/* Chart.js */\n' + css;
      var style = document.createElement('style');
      style.setAttribute('type', 'text/css');
      style.appendChild(document.createTextNode(css));
      rootNode.appendChild(style);
    }
  }

  var platform_dom$2 = {
    /**
     * When `true`, prevents the automatic injection of the stylesheet required to
     * correctly detect when the chart is added to the DOM and then resized. This
     * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)
     * to be manually imported to make this library compatible with any CSP.
     * See https://github.com/chartjs/Chart.js/issues/5208
     */
    disableCSSInjection: false,

    /**
     * This property holds whether this platform is enabled for the current environment.
     * Currently used by platform.js to select the proper implementation.
     * @private
     */
    _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

    /**
     * Initializes resources that depend on platform options.
     * @param {HTMLCanvasElement} canvas - The Canvas element.
     * @private
     */
    _ensureLoaded: function _ensureLoaded(canvas) {
      if (!this.disableCSSInjection) {
        // If the canvas is in a shadow DOM, then the styles must also be inserted
        // into the same shadow DOM.
        // https://github.com/chartjs/Chart.js/issues/5763
        var root = canvas.getRootNode ? canvas.getRootNode() : document;
        var targetNode = root.host ? root : document.head;
        injectCSS(targetNode, stylesheet);
      }
    },
    acquireContext: function acquireContext(item, config) {
      if (typeof item === 'string') {
        item = document.getElementById(item);
      } else if (item.length) {
        // Support for array based queries (such as jQuery)
        item = item[0];
      }

      if (item && item.canvas) {
        // Support for any object associated to a canvas (including a context2d)
        item = item.canvas;
      } // To prevent canvas fingerprinting, some add-ons undefine the getContext
      // method, for example: https://github.com/kkapsner/CanvasBlocker
      // https://github.com/chartjs/Chart.js/issues/2807


      var context = item && item.getContext && item.getContext('2d'); // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
      // inside an iframe or when running in a protected environment. We could guess the
      // types from their toString() value but let's keep things flexible and assume it's
      // a sufficient condition if the item has a context2D which has item as `canvas`.
      // https://github.com/chartjs/Chart.js/issues/3887
      // https://github.com/chartjs/Chart.js/issues/4102
      // https://github.com/chartjs/Chart.js/issues/4152

      if (context && context.canvas === item) {
        // Load platform resources on first chart creation, to make it possible to
        // import the library before setting platform options.
        this._ensureLoaded(item);

        initCanvas(item, config);
        return context;
      }

      return null;
    },
    releaseContext: function releaseContext(context) {
      var canvas = context.canvas;

      if (!canvas[EXPANDO_KEY]) {
        return;
      }

      var initial = canvas[EXPANDO_KEY].initial;
      ['height', 'width'].forEach(function (prop) {
        var value = initial[prop];

        if (helpers$1.isNullOrUndef(value)) {
          canvas.removeAttribute(prop);
        } else {
          canvas.setAttribute(prop, value);
        }
      });
      helpers$1.each(initial.style || {}, function (value, key) {
        canvas.style[key] = value;
      }); // The canvas render size might have been changed (and thus the state stack discarded),
      // we can't use save() and restore() to restore the initial state. So make sure that at
      // least the canvas context is reset to the default state by setting the canvas width.
      // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
      // eslint-disable-next-line no-self-assign

      canvas.width = canvas.width;
      delete canvas[EXPANDO_KEY];
    },
    addEventListener: function addEventListener(chart, type, listener) {
      var canvas = chart.canvas;

      if (type === 'resize') {
        // Note: the resize event is not supported on all browsers.
        addResizeListener(canvas, listener, chart);
        return;
      }

      var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
      var proxies = expando.proxies || (expando.proxies = {});

      var proxy = proxies[chart.id + '_' + type] = function (event) {
        listener(fromNativeEvent(event, chart));
      };

      addListener(canvas, type, proxy);
    },
    removeEventListener: function removeEventListener(chart, type, listener) {
      var canvas = chart.canvas;

      if (type === 'resize') {
        // Note: the resize event is not supported on all browsers.
        removeResizeListener(canvas);
        return;
      }

      var expando = listener[EXPANDO_KEY] || {};
      var proxies = expando.proxies || {};
      var proxy = proxies[chart.id + '_' + type];

      if (!proxy) {
        return;
      }

      removeListener(canvas, type, proxy);
    }
  }; // DEPRECATIONS

  /**
   * Provided for backward compatibility, use EventTarget.addEventListener instead.
   * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   * @function Chart.helpers.addEvent
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */

  helpers$1.addEvent = addListener;
  /**
   * Provided for backward compatibility, use EventTarget.removeEventListener instead.
   * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
   * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
   * @function Chart.helpers.removeEvent
   * @deprecated since version 2.7.0
   * @todo remove at version 3
   * @private
   */

  helpers$1.removeEvent = removeListener; // @TODO Make possible to select another platform at build time.

  var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;
  /**
   * @namespace Chart.platform
   * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
   * @since 2.4.0
   */

  var platform = helpers$1.extend({
    /**
     * @since 2.7.0
     */
    initialize: function initialize() {},

    /**
     * Called at chart construction time, returns a context2d instance implementing
     * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
     * @param {*} item - The native item from which to acquire context (platform specific)
     * @param {object} options - The chart options
     * @returns {CanvasRenderingContext2D} context2d instance
     */
    acquireContext: function acquireContext() {},

    /**
     * Called at chart destruction time, releases any resources associated to the context
     * previously returned by the acquireContext() method.
     * @param {CanvasRenderingContext2D} context - The context2d instance
     * @returns {boolean} true if the method succeeded, else false
     */
    releaseContext: function releaseContext() {},

    /**
     * Registers the specified listener on the given chart.
     * @param {Chart} chart - Chart from which to listen for event
     * @param {string} type - The ({@link IEvent}) type to listen for
     * @param {function} listener - Receives a notification (an object that implements
     * the {@link IEvent} interface) when an event of the specified type occurs.
     */
    addEventListener: function addEventListener() {},

    /**
     * Removes the specified listener previously registered with addEventListener.
     * @param {Chart} chart - Chart from which to remove the listener
     * @param {string} type - The ({@link IEvent}) type to remove
     * @param {function} listener - The listener function to remove from the event target.
     */
    removeEventListener: function removeEventListener() {}
  }, implementation);

  core_defaults._set('global', {
    plugins: {}
  });
  /**
   * The plugin service singleton
   * @namespace Chart.plugins
   * @since 2.1.0
   */


  var core_plugins = {
    /**
     * Globally registered plugins.
     * @private
     */
    _plugins: [],

    /**
     * This identifier is used to invalidate the descriptors cache attached to each chart
     * when a global plugin is registered or unregistered. In this case, the cache ID is
     * incremented and descriptors are regenerated during following API calls.
     * @private
     */
    _cacheId: 0,

    /**
     * Registers the given plugin(s) if not already registered.
     * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
     */
    register: function register(plugins) {
      var p = this._plugins;
      [].concat(plugins).forEach(function (plugin) {
        if (p.indexOf(plugin) === -1) {
          p.push(plugin);
        }
      });
      this._cacheId++;
    },

    /**
     * Unregisters the given plugin(s) only if registered.
     * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
     */
    unregister: function unregister(plugins) {
      var p = this._plugins;
      [].concat(plugins).forEach(function (plugin) {
        var idx = p.indexOf(plugin);

        if (idx !== -1) {
          p.splice(idx, 1);
        }
      });
      this._cacheId++;
    },

    /**
     * Remove all registered plugins.
     * @since 2.1.5
     */
    clear: function clear() {
      this._plugins = [];
      this._cacheId++;
    },

    /**
     * Returns the number of registered plugins?
     * @returns {number}
     * @since 2.1.5
     */
    count: function count() {
      return this._plugins.length;
    },

    /**
     * Returns all registered plugin instances.
     * @returns {IPlugin[]} array of plugin objects.
     * @since 2.1.5
     */
    getAll: function getAll() {
      return this._plugins;
    },

    /**
     * Calls enabled plugins for `chart` on the specified hook and with the given args.
     * This method immediately returns as soon as a plugin explicitly returns false. The
     * returned value can be used, for instance, to interrupt the current action.
     * @param {Chart} chart - The chart instance for which plugins should be called.
     * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
     * @param {Array} [args] - Extra arguments to apply to the hook call.
     * @returns {boolean} false if any of the plugins return false, else returns true.
     */
    notify: function notify(chart, hook, args) {
      var descriptors = this.descriptors(chart);
      var ilen = descriptors.length;
      var i, descriptor, plugin, params, method;

      for (i = 0; i < ilen; ++i) {
        descriptor = descriptors[i];
        plugin = descriptor.plugin;
        method = plugin[hook];

        if (typeof method === 'function') {
          params = [chart].concat(args || []);
          params.push(descriptor.options);

          if (method.apply(plugin, params) === false) {
            return false;
          }
        }
      }

      return true;
    },

    /**
     * Returns descriptors of enabled plugins for the given chart.
     * @returns {object[]} [{ plugin, options }]
     * @private
     */
    descriptors: function descriptors(chart) {
      var cache = chart.$plugins || (chart.$plugins = {});

      if (cache.id === this._cacheId) {
        return cache.descriptors;
      }

      var plugins = [];
      var descriptors = [];
      var config = chart && chart.config || {};
      var options = config.options && config.options.plugins || {};

      this._plugins.concat(config.plugins || []).forEach(function (plugin) {
        var idx = plugins.indexOf(plugin);

        if (idx !== -1) {
          return;
        }

        var id = plugin.id;
        var opts = options[id];

        if (opts === false) {
          return;
        }

        if (opts === true) {
          opts = helpers$1.clone(core_defaults.global.plugins[id]);
        }

        plugins.push(plugin);
        descriptors.push({
          plugin: plugin,
          options: opts || {}
        });
      });

      cache.descriptors = descriptors;
      cache.id = this._cacheId;
      return descriptors;
    },

    /**
     * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
     * but in some cases, this reference can be changed by the user when updating options.
     * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
     * @private
     */
    _invalidate: function _invalidate(chart) {
      delete chart.$plugins;
    }
  };
  var core_scaleService = {
    // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
    // use the new chart options to grab the correct scale
    constructors: {},
    // Use a registration function so that we can move to an ES6 map when we no longer need to support
    // old browsers
    // Scale config defaults
    defaults: {},
    registerScaleType: function registerScaleType(type, scaleConstructor, scaleDefaults) {
      this.constructors[type] = scaleConstructor;
      this.defaults[type] = helpers$1.clone(scaleDefaults);
    },
    getScaleConstructor: function getScaleConstructor(type) {
      return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
    },
    getScaleDefaults: function getScaleDefaults(type) {
      // Return the scale defaults merged with the global settings so that we always use the latest ones
      return this.defaults.hasOwnProperty(type) ? helpers$1.merge(Object.create(null), [core_defaults.scale, this.defaults[type]]) : {};
    },
    updateScaleDefaults: function updateScaleDefaults(type, additions) {
      var me = this;

      if (me.defaults.hasOwnProperty(type)) {
        me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
      }
    },
    addScalesToLayout: function addScalesToLayout(chart) {
      // Adds each scale to the chart.boxes array to be sized accordingly
      helpers$1.each(chart.scales, function (scale) {
        // Set ILayoutItem parameters for backwards compatibility
        scale.fullWidth = scale.options.fullWidth;
        scale.position = scale.options.position;
        scale.weight = scale.options.weight;
        core_layouts.addBox(chart, scale);
      });
    }
  };
  var valueOrDefault$8 = helpers$1.valueOrDefault;
  var getRtlHelper = helpers$1.rtl.getRtlAdapter;

  core_defaults._set('global', {
    tooltips: {
      enabled: true,
      custom: null,
      mode: 'nearest',
      position: 'average',
      intersect: true,
      backgroundColor: 'rgba(0,0,0,0.8)',
      titleFontStyle: 'bold',
      titleSpacing: 2,
      titleMarginBottom: 6,
      titleFontColor: '#fff',
      titleAlign: 'left',
      bodySpacing: 2,
      bodyFontColor: '#fff',
      bodyAlign: 'left',
      footerFontStyle: 'bold',
      footerSpacing: 2,
      footerMarginTop: 6,
      footerFontColor: '#fff',
      footerAlign: 'left',
      yPadding: 6,
      xPadding: 6,
      caretPadding: 2,
      caretSize: 5,
      cornerRadius: 6,
      multiKeyBackground: '#fff',
      displayColors: true,
      borderColor: 'rgba(0,0,0,0)',
      borderWidth: 0,
      callbacks: {
        // Args are: (tooltipItems, data)
        beforeTitle: helpers$1.noop,
        title: function title(tooltipItems, data) {
          var title = '';
          var labels = data.labels;
          var labelCount = labels ? labels.length : 0;

          if (tooltipItems.length > 0) {
            var item = tooltipItems[0];

            if (item.label) {
              title = item.label;
            } else if (item.xLabel) {
              title = item.xLabel;
            } else if (labelCount > 0 && item.index < labelCount) {
              title = labels[item.index];
            }
          }

          return title;
        },
        afterTitle: helpers$1.noop,
        // Args are: (tooltipItems, data)
        beforeBody: helpers$1.noop,
        // Args are: (tooltipItem, data)
        beforeLabel: helpers$1.noop,
        label: function label(tooltipItem, data) {
          var label = data.datasets[tooltipItem.datasetIndex].label || '';

          if (label) {
            label += ': ';
          }

          if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
            label += tooltipItem.value;
          } else {
            label += tooltipItem.yLabel;
          }

          return label;
        },
        labelColor: function labelColor(tooltipItem, chart) {
          var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
          var activeElement = meta.data[tooltipItem.index];
          var view = activeElement._view;
          return {
            borderColor: view.borderColor,
            backgroundColor: view.backgroundColor
          };
        },
        labelTextColor: function labelTextColor() {
          return this._options.bodyFontColor;
        },
        afterLabel: helpers$1.noop,
        // Args are: (tooltipItems, data)
        afterBody: helpers$1.noop,
        // Args are: (tooltipItems, data)
        beforeFooter: helpers$1.noop,
        footer: helpers$1.noop,
        afterFooter: helpers$1.noop
      }
    }
  });

  var positioners = {
    /**
     * Average mode places the tooltip at the average position of the elements shown
     * @function Chart.Tooltip.positioners.average
     * @param elements {ChartElement[]} the elements being displayed in the tooltip
     * @returns {object} tooltip position
     */
    average: function average(elements) {
      if (!elements.length) {
        return false;
      }

      var i, len;
      var x = 0;
      var y = 0;
      var count = 0;

      for (i = 0, len = elements.length; i < len; ++i) {
        var el = elements[i];

        if (el && el.hasValue()) {
          var pos = el.tooltipPosition();
          x += pos.x;
          y += pos.y;
          ++count;
        }
      }

      return {
        x: x / count,
        y: y / count
      };
    },

    /**
     * Gets the tooltip position nearest of the item nearest to the event position
     * @function Chart.Tooltip.positioners.nearest
     * @param elements {Chart.Element[]} the tooltip elements
     * @param eventPosition {object} the position of the event in canvas coordinates
     * @returns {object} the tooltip position
     */
    nearest: function nearest(elements, eventPosition) {
      var x = eventPosition.x;
      var y = eventPosition.y;
      var minDistance = Number.POSITIVE_INFINITY;
      var i, len, nearestElement;

      for (i = 0, len = elements.length; i < len; ++i) {
        var el = elements[i];

        if (el && el.hasValue()) {
          var center = el.getCenterPoint();
          var d = helpers$1.distanceBetweenPoints(eventPosition, center);

          if (d < minDistance) {
            minDistance = d;
            nearestElement = el;
          }
        }
      }

      if (nearestElement) {
        var tp = nearestElement.tooltipPosition();
        x = tp.x;
        y = tp.y;
      }

      return {
        x: x,
        y: y
      };
    }
  }; // Helper to push or concat based on if the 2nd parameter is an array or not

  function pushOrConcat(base, toPush) {
    if (toPush) {
      if (helpers$1.isArray(toPush)) {
        // base = base.concat(toPush);
        Array.prototype.push.apply(base, toPush);
      } else {
        base.push(toPush);
      }
    }

    return base;
  }
  /**
   * Returns array of strings split by newline
   * @param {string} value - The value to split by newline.
   * @returns {string[]} value if newline present - Returned from String split() method
   * @function
   */


  function splitNewlines(str) {
    if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
      return str.split('\n');
    }

    return str;
  }
  /**
   * Private helper to create a tooltip item model
   * @param element - the chart element (point, arc, bar) to create the tooltip item for
   * @return new tooltip item
   */


  function createTooltipItem(element) {
    var xScale = element._xScale;
    var yScale = element._yScale || element._scale; // handle radar || polarArea charts

    var index = element._index;
    var datasetIndex = element._datasetIndex;

    var controller = element._chart.getDatasetMeta(datasetIndex).controller;

    var indexScale = controller._getIndexScale();

    var valueScale = controller._getValueScale();

    return {
      xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
      yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
      label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',
      value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',
      index: index,
      datasetIndex: datasetIndex,
      x: element._model.x,
      y: element._model.y
    };
  }
  /**
   * Helper to get the reset model for the tooltip
   * @param tooltipOpts {object} the tooltip options
   */


  function getBaseModel(tooltipOpts) {
    var globalDefaults = core_defaults.global;
    return {
      // Positioning
      xPadding: tooltipOpts.xPadding,
      yPadding: tooltipOpts.yPadding,
      xAlign: tooltipOpts.xAlign,
      yAlign: tooltipOpts.yAlign,
      // Drawing direction and text direction
      rtl: tooltipOpts.rtl,
      textDirection: tooltipOpts.textDirection,
      // Body
      bodyFontColor: tooltipOpts.bodyFontColor,
      _bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
      _bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
      _bodyAlign: tooltipOpts.bodyAlign,
      bodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
      bodySpacing: tooltipOpts.bodySpacing,
      // Title
      titleFontColor: tooltipOpts.titleFontColor,
      _titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
      _titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
      titleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
      _titleAlign: tooltipOpts.titleAlign,
      titleSpacing: tooltipOpts.titleSpacing,
      titleMarginBottom: tooltipOpts.titleMarginBottom,
      // Footer
      footerFontColor: tooltipOpts.footerFontColor,
      _footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
      _footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
      footerFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
      _footerAlign: tooltipOpts.footerAlign,
      footerSpacing: tooltipOpts.footerSpacing,
      footerMarginTop: tooltipOpts.footerMarginTop,
      // Appearance
      caretSize: tooltipOpts.caretSize,
      cornerRadius: tooltipOpts.cornerRadius,
      backgroundColor: tooltipOpts.backgroundColor,
      opacity: 0,
      legendColorBackground: tooltipOpts.multiKeyBackground,
      displayColors: tooltipOpts.displayColors,
      borderColor: tooltipOpts.borderColor,
      borderWidth: tooltipOpts.borderWidth
    };
  }
  /**
   * Get the size of the tooltip
   */


  function getTooltipSize(tooltip, model) {
    var ctx = tooltip._chart.ctx;
    var height = model.yPadding * 2; // Tooltip Padding

    var width = 0; // Count of all lines in the body

    var body = model.body;
    var combinedBodyLength = body.reduce(function (count, bodyItem) {
      return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
    }, 0);
    combinedBodyLength += model.beforeBody.length + model.afterBody.length;
    var titleLineCount = model.title.length;
    var footerLineCount = model.footer.length;
    var titleFontSize = model.titleFontSize;
    var bodyFontSize = model.bodyFontSize;
    var footerFontSize = model.footerFontSize;
    height += titleLineCount * titleFontSize; // Title Lines

    height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing

    height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin

    height += combinedBodyLength * bodyFontSize; // Body Lines

    height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing

    height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin

    height += footerLineCount * footerFontSize; // Footer Lines

    height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing
    // Title width

    var widthPadding = 0;

    var maxLineWidth = function maxLineWidth(line) {
      width = Math.max(width, ctx.measureText(line).width + widthPadding);
    };

    ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
    helpers$1.each(model.title, maxLineWidth); // Body width

    ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
    helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth); // Body lines may include some extra width due to the color box

    widthPadding = model.displayColors ? bodyFontSize + 2 : 0;
    helpers$1.each(body, function (bodyItem) {
      helpers$1.each(bodyItem.before, maxLineWidth);
      helpers$1.each(bodyItem.lines, maxLineWidth);
      helpers$1.each(bodyItem.after, maxLineWidth);
    }); // Reset back to 0

    widthPadding = 0; // Footer width

    ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
    helpers$1.each(model.footer, maxLineWidth); // Add padding

    width += 2 * model.xPadding;
    return {
      width: width,
      height: height
    };
  }
  /**
   * Helper to get the alignment of a tooltip given the size
   */


  function determineAlignment(tooltip, size) {
    var model = tooltip._model;
    var chart = tooltip._chart;
    var chartArea = tooltip._chart.chartArea;
    var xAlign = 'center';
    var yAlign = 'center';

    if (model.y < size.height) {
      yAlign = 'top';
    } else if (model.y > chart.height - size.height) {
      yAlign = 'bottom';
    }

    var lf, rf; // functions to determine left, right alignment

    var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart

    var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges

    var midX = (chartArea.left + chartArea.right) / 2;
    var midY = (chartArea.top + chartArea.bottom) / 2;

    if (yAlign === 'center') {
      lf = function lf(x) {
        return x <= midX;
      };

      rf = function rf(x) {
        return x > midX;
      };
    } else {
      lf = function lf(x) {
        return x <= size.width / 2;
      };

      rf = function rf(x) {
        return x >= chart.width - size.width / 2;
      };
    }

    olf = function olf(x) {
      return x + size.width + model.caretSize + model.caretPadding > chart.width;
    };

    orf = function orf(x) {
      return x - size.width - model.caretSize - model.caretPadding < 0;
    };

    yf = function yf(y) {
      return y <= midY ? 'top' : 'bottom';
    };

    if (lf(model.x)) {
      xAlign = 'left'; // Is tooltip too wide and goes over the right side of the chart.?

      if (olf(model.x)) {
        xAlign = 'center';
        yAlign = yf(model.y);
      }
    } else if (rf(model.x)) {
      xAlign = 'right'; // Is tooltip too wide and goes outside left edge of canvas?

      if (orf(model.x)) {
        xAlign = 'center';
        yAlign = yf(model.y);
      }
    }

    var opts = tooltip._options;
    return {
      xAlign: opts.xAlign ? opts.xAlign : xAlign,
      yAlign: opts.yAlign ? opts.yAlign : yAlign
    };
  }
  /**
   * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
   */


  function getBackgroundPoint(vm, size, alignment, chart) {
    // Background Position
    var x = vm.x;
    var y = vm.y;
    var caretSize = vm.caretSize;
    var caretPadding = vm.caretPadding;
    var cornerRadius = vm.cornerRadius;
    var xAlign = alignment.xAlign;
    var yAlign = alignment.yAlign;
    var paddingAndSize = caretSize + caretPadding;
    var radiusAndPadding = cornerRadius + caretPadding;

    if (xAlign === 'right') {
      x -= size.width;
    } else if (xAlign === 'center') {
      x -= size.width / 2;

      if (x + size.width > chart.width) {
        x = chart.width - size.width;
      }

      if (x < 0) {
        x = 0;
      }
    }

    if (yAlign === 'top') {
      y += paddingAndSize;
    } else if (yAlign === 'bottom') {
      y -= size.height + paddingAndSize;
    } else {
      y -= size.height / 2;
    }

    if (yAlign === 'center') {
      if (xAlign === 'left') {
        x += paddingAndSize;
      } else if (xAlign === 'right') {
        x -= paddingAndSize;
      }
    } else if (xAlign === 'left') {
      x -= radiusAndPadding;
    } else if (xAlign === 'right') {
      x += radiusAndPadding;
    }

    return {
      x: x,
      y: y
    };
  }

  function getAlignedX(vm, align) {
    return align === 'center' ? vm.x + vm.width / 2 : align === 'right' ? vm.x + vm.width - vm.xPadding : vm.x + vm.xPadding;
  }
  /**
   * Helper to build before and after body lines
   */


  function getBeforeAfterBodyLines(callback) {
    return pushOrConcat([], splitNewlines(callback));
  }

  var exports$4 = core_element.extend({
    initialize: function initialize() {
      this._model = getBaseModel(this._options);
      this._lastActive = [];
    },
    // Get the title
    // Args are: (tooltipItem, data)
    getTitle: function getTitle() {
      var me = this;
      var opts = me._options;
      var callbacks = opts.callbacks;
      var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
      var title = callbacks.title.apply(me, arguments);
      var afterTitle = callbacks.afterTitle.apply(me, arguments);
      var lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeTitle));
      lines = pushOrConcat(lines, splitNewlines(title));
      lines = pushOrConcat(lines, splitNewlines(afterTitle));
      return lines;
    },
    // Args are: (tooltipItem, data)
    getBeforeBody: function getBeforeBody() {
      return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
    },
    // Args are: (tooltipItem, data)
    getBody: function getBody(tooltipItems, data) {
      var me = this;
      var callbacks = me._options.callbacks;
      var bodyItems = [];
      helpers$1.each(tooltipItems, function (tooltipItem) {
        var bodyItem = {
          before: [],
          lines: [],
          after: []
        };
        pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
        pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
        pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));
        bodyItems.push(bodyItem);
      });
      return bodyItems;
    },
    // Args are: (tooltipItem, data)
    getAfterBody: function getAfterBody() {
      return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
    },
    // Get the footer and beforeFooter and afterFooter lines
    // Args are: (tooltipItem, data)
    getFooter: function getFooter() {
      var me = this;
      var callbacks = me._options.callbacks;
      var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
      var footer = callbacks.footer.apply(me, arguments);
      var afterFooter = callbacks.afterFooter.apply(me, arguments);
      var lines = [];
      lines = pushOrConcat(lines, splitNewlines(beforeFooter));
      lines = pushOrConcat(lines, splitNewlines(footer));
      lines = pushOrConcat(lines, splitNewlines(afterFooter));
      return lines;
    },
    update: function update(changed) {
      var me = this;
      var opts = me._options; // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
      // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
      // which breaks any animations.

      var existingModel = me._model;
      var model = me._model = getBaseModel(opts);
      var active = me._active;
      var data = me._data; // In the case where active.length === 0 we need to keep these at existing values for good animations

      var alignment = {
        xAlign: existingModel.xAlign,
        yAlign: existingModel.yAlign
      };
      var backgroundPoint = {
        x: existingModel.x,
        y: existingModel.y
      };
      var tooltipSize = {
        width: existingModel.width,
        height: existingModel.height
      };
      var tooltipPosition = {
        x: existingModel.caretX,
        y: existingModel.caretY
      };
      var i, len;

      if (active.length) {
        model.opacity = 1;
        var labelColors = [];
        var labelTextColors = [];
        tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);
        var tooltipItems = [];

        for (i = 0, len = active.length; i < len; ++i) {
          tooltipItems.push(createTooltipItem(active[i]));
        } // If the user provided a filter function, use it to modify the tooltip items


        if (opts.filter) {
          tooltipItems = tooltipItems.filter(function (a) {
            return opts.filter(a, data);
          });
        } // If the user provided a sorting function, use it to modify the tooltip items


        if (opts.itemSort) {
          tooltipItems = tooltipItems.sort(function (a, b) {
            return opts.itemSort(a, b, data);
          });
        } // Determine colors for boxes


        helpers$1.each(tooltipItems, function (tooltipItem) {
          labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
          labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
        }); // Build the Text Lines

        model.title = me.getTitle(tooltipItems, data);
        model.beforeBody = me.getBeforeBody(tooltipItems, data);
        model.body = me.getBody(tooltipItems, data);
        model.afterBody = me.getAfterBody(tooltipItems, data);
        model.footer = me.getFooter(tooltipItems, data); // Initial positioning and colors

        model.x = tooltipPosition.x;
        model.y = tooltipPosition.y;
        model.caretPadding = opts.caretPadding;
        model.labelColors = labelColors;
        model.labelTextColors = labelTextColors; // data points

        model.dataPoints = tooltipItems; // We need to determine alignment of the tooltip

        tooltipSize = getTooltipSize(this, model);
        alignment = determineAlignment(this, tooltipSize); // Final Size and Position

        backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
      } else {
        model.opacity = 0;
      }

      model.xAlign = alignment.xAlign;
      model.yAlign = alignment.yAlign;
      model.x = backgroundPoint.x;
      model.y = backgroundPoint.y;
      model.width = tooltipSize.width;
      model.height = tooltipSize.height; // Point where the caret on the tooltip points to

      model.caretX = tooltipPosition.x;
      model.caretY = tooltipPosition.y;
      me._model = model;

      if (changed && opts.custom) {
        opts.custom.call(me, model);
      }

      return me;
    },
    drawCaret: function drawCaret(tooltipPoint, size) {
      var ctx = this._chart.ctx;
      var vm = this._view;
      var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);
      ctx.lineTo(caretPosition.x1, caretPosition.y1);
      ctx.lineTo(caretPosition.x2, caretPosition.y2);
      ctx.lineTo(caretPosition.x3, caretPosition.y3);
    },
    getCaretPosition: function getCaretPosition(tooltipPoint, size, vm) {
      var x1, x2, x3, y1, y2, y3;
      var caretSize = vm.caretSize;
      var cornerRadius = vm.cornerRadius;
      var xAlign = vm.xAlign;
      var yAlign = vm.yAlign;
      var ptX = tooltipPoint.x;
      var ptY = tooltipPoint.y;
      var width = size.width;
      var height = size.height;

      if (yAlign === 'center') {
        y2 = ptY + height / 2;

        if (xAlign === 'left') {
          x1 = ptX;
          x2 = x1 - caretSize;
          x3 = x1;
          y1 = y2 + caretSize;
          y3 = y2 - caretSize;
        } else {
          x1 = ptX + width;
          x2 = x1 + caretSize;
          x3 = x1;
          y1 = y2 - caretSize;
          y3 = y2 + caretSize;
        }
      } else {
        if (xAlign === 'left') {
          x2 = ptX + cornerRadius + caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else if (xAlign === 'right') {
          x2 = ptX + width - cornerRadius - caretSize;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        } else {
          x2 = vm.caretX;
          x1 = x2 - caretSize;
          x3 = x2 + caretSize;
        }

        if (yAlign === 'top') {
          y1 = ptY;
          y2 = y1 - caretSize;
          y3 = y1;
        } else {
          y1 = ptY + height;
          y2 = y1 + caretSize;
          y3 = y1; // invert drawing order

          var tmp = x3;
          x3 = x1;
          x1 = tmp;
        }
      }

      return {
        x1: x1,
        x2: x2,
        x3: x3,
        y1: y1,
        y2: y2,
        y3: y3
      };
    },
    drawTitle: function drawTitle(pt, vm, ctx) {
      var title = vm.title;
      var length = title.length;
      var titleFontSize, titleSpacing, i;

      if (length) {
        var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
        pt.x = getAlignedX(vm, vm._titleAlign);
        ctx.textAlign = rtlHelper.textAlign(vm._titleAlign);
        ctx.textBaseline = 'middle';
        titleFontSize = vm.titleFontSize;
        titleSpacing = vm.titleSpacing;
        ctx.fillStyle = vm.titleFontColor;
        ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

        for (i = 0; i < length; ++i) {
          ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);
          pt.y += titleFontSize + titleSpacing; // Line Height and spacing

          if (i + 1 === length) {
            pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
          }
        }
      }
    },
    drawBody: function drawBody(pt, vm, ctx) {
      var bodyFontSize = vm.bodyFontSize;
      var bodySpacing = vm.bodySpacing;
      var bodyAlign = vm._bodyAlign;
      var body = vm.body;
      var drawColorBoxes = vm.displayColors;
      var xLinePadding = 0;
      var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;
      var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);

      var fillLineOfText = function fillLineOfText(line) {
        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);
        pt.y += bodyFontSize + bodySpacing;
      };

      var bodyItem, textColor, labelColors, lines, i, j, ilen, jlen;
      var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
      ctx.textAlign = bodyAlign;
      ctx.textBaseline = 'middle';
      ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);
      pt.x = getAlignedX(vm, bodyAlignForCalculation); // Before body lines

      ctx.fillStyle = vm.bodyFontColor;
      helpers$1.each(vm.beforeBody, fillLineOfText);
      xLinePadding = drawColorBoxes && bodyAlignForCalculation !== 'right' ? bodyAlign === 'center' ? bodyFontSize / 2 + 1 : bodyFontSize + 2 : 0; // Draw body lines now

      for (i = 0, ilen = body.length; i < ilen; ++i) {
        bodyItem = body[i];
        textColor = vm.labelTextColors[i];
        labelColors = vm.labelColors[i];
        ctx.fillStyle = textColor;
        helpers$1.each(bodyItem.before, fillLineOfText);
        lines = bodyItem.lines;

        for (j = 0, jlen = lines.length; j < jlen; ++j) {
          // Draw Legend-like boxes if needed
          if (drawColorBoxes) {
            var rtlColorX = rtlHelper.x(colorX); // Fill a white rect so that colours merge nicely if the opacity is < 1

            ctx.fillStyle = vm.legendColorBackground;
            ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize); // Border

            ctx.lineWidth = 1;
            ctx.strokeStyle = labelColors.borderColor;
            ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize); // Inner square

            ctx.fillStyle = labelColors.backgroundColor;
            ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
            ctx.fillStyle = textColor;
          }

          fillLineOfText(lines[j]);
        }

        helpers$1.each(bodyItem.after, fillLineOfText);
      } // Reset back to 0 for after body


      xLinePadding = 0; // After body lines

      helpers$1.each(vm.afterBody, fillLineOfText);
      pt.y -= bodySpacing; // Remove last body spacing
    },
    drawFooter: function drawFooter(pt, vm, ctx) {
      var footer = vm.footer;
      var length = footer.length;
      var footerFontSize, i;

      if (length) {
        var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);
        pt.x = getAlignedX(vm, vm._footerAlign);
        pt.y += vm.footerMarginTop;
        ctx.textAlign = rtlHelper.textAlign(vm._footerAlign);
        ctx.textBaseline = 'middle';
        footerFontSize = vm.footerFontSize;
        ctx.fillStyle = vm.footerFontColor;
        ctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

        for (i = 0; i < length; ++i) {
          ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);
          pt.y += footerFontSize + vm.footerSpacing;
        }
      }
    },
    drawBackground: function drawBackground(pt, vm, ctx, tooltipSize) {
      ctx.fillStyle = vm.backgroundColor;
      ctx.strokeStyle = vm.borderColor;
      ctx.lineWidth = vm.borderWidth;
      var xAlign = vm.xAlign;
      var yAlign = vm.yAlign;
      var x = pt.x;
      var y = pt.y;
      var width = tooltipSize.width;
      var height = tooltipSize.height;
      var radius = vm.cornerRadius;
      ctx.beginPath();
      ctx.moveTo(x + radius, y);

      if (yAlign === 'top') {
        this.drawCaret(pt, tooltipSize);
      }

      ctx.lineTo(x + width - radius, y);
      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);

      if (yAlign === 'center' && xAlign === 'right') {
        this.drawCaret(pt, tooltipSize);
      }

      ctx.lineTo(x + width, y + height - radius);
      ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);

      if (yAlign === 'bottom') {
        this.drawCaret(pt, tooltipSize);
      }

      ctx.lineTo(x + radius, y + height);
      ctx.quadraticCurveTo(x, y + height, x, y + height - radius);

      if (yAlign === 'center' && xAlign === 'left') {
        this.drawCaret(pt, tooltipSize);
      }

      ctx.lineTo(x, y + radius);
      ctx.quadraticCurveTo(x, y, x + radius, y);
      ctx.closePath();
      ctx.fill();

      if (vm.borderWidth > 0) {
        ctx.stroke();
      }
    },
    draw: function draw() {
      var ctx = this._chart.ctx;
      var vm = this._view;

      if (vm.opacity === 0) {
        return;
      }

      var tooltipSize = {
        width: vm.width,
        height: vm.height
      };
      var pt = {
        x: vm.x,
        y: vm.y
      }; // IE11/Edge does not like very small opacities, so snap to 0

      var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity; // Truthy/falsey value for empty tooltip

      var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

      if (this._options.enabled && hasTooltipContent) {
        ctx.save();
        ctx.globalAlpha = opacity; // Draw Background

        this.drawBackground(pt, vm, ctx, tooltipSize); // Draw Title, Body, and Footer

        pt.y += vm.yPadding;
        helpers$1.rtl.overrideTextDirection(ctx, vm.textDirection); // Titles

        this.drawTitle(pt, vm, ctx); // Body

        this.drawBody(pt, vm, ctx); // Footer

        this.drawFooter(pt, vm, ctx);
        helpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);
        ctx.restore();
      }
    },

    /**
     * Handle an event
     * @private
     * @param {IEvent} event - The event to handle
     * @returns {boolean} true if the tooltip changed
     */
    handleEvent: function handleEvent(e) {
      var me = this;
      var options = me._options;
      var changed = false;
      me._lastActive = me._lastActive || []; // Find Active Elements for tooltips

      if (e.type === 'mouseout') {
        me._active = [];
      } else {
        me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);

        if (options.reverse) {
          me._active.reverse();
        }
      } // Remember Last Actives


      changed = !helpers$1.arrayEquals(me._active, me._lastActive); // Only handle target event on tooltip change

      if (changed) {
        me._lastActive = me._active;

        if (options.enabled || options.custom) {
          me._eventPosition = {
            x: e.x,
            y: e.y
          };
          me.update(true);
          me.pivot();
        }
      }

      return changed;
    }
  });
  /**
   * @namespace Chart.Tooltip.positioners
   */

  var positioners_1 = positioners;
  var core_tooltip = exports$4;
  core_tooltip.positioners = positioners_1;
  var valueOrDefault$9 = helpers$1.valueOrDefault;

  core_defaults._set('global', {
    elements: {},
    events: ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'],
    hover: {
      onHover: null,
      mode: 'nearest',
      intersect: true,
      animationDuration: 400
    },
    onClick: null,
    maintainAspectRatio: true,
    responsive: true,
    responsiveAnimationDuration: 0
  });
  /**
   * Recursively merge the given config objects representing the `scales` option
   * by incorporating scale defaults in `xAxes` and `yAxes` array items, then
   * returns a deep copy of the result, thus doesn't alter inputs.
   */


  function mergeScaleConfig()
  /* config objects ... */
  {
    return helpers$1.merge(Object.create(null), [].slice.call(arguments), {
      merger: function merger(key, target, source, options) {
        if (key === 'xAxes' || key === 'yAxes') {
          var slen = source[key].length;
          var i, type, scale;

          if (!target[key]) {
            target[key] = [];
          }

          for (i = 0; i < slen; ++i) {
            scale = source[key][i];
            type = valueOrDefault$9(scale.type, key === 'xAxes' ? 'category' : 'linear');

            if (i >= target[key].length) {
              target[key].push({});
            }

            if (!target[key][i].type || scale.type && scale.type !== target[key][i].type) {
              // new/untyped scale or type changed: let's apply the new defaults
              // then merge source scale to correctly overwrite the defaults.
              helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);
            } else {
              // scales type are the same
              helpers$1.merge(target[key][i], scale);
            }
          }
        } else {
          helpers$1._merger(key, target, source, options);
        }
      }
    });
  }
  /**
   * Recursively merge the given config objects as the root options by handling
   * default scale options for the `scales` and `scale` properties, then returns
   * a deep copy of the result, thus doesn't alter inputs.
   */


  function mergeConfig()
  /* config objects ... */
  {
    return helpers$1.merge(Object.create(null), [].slice.call(arguments), {
      merger: function merger(key, target, source, options) {
        var tval = target[key] || Object.create(null);
        var sval = source[key];

        if (key === 'scales') {
          // scale config merging is complex. Add our own function here for that
          target[key] = mergeScaleConfig(tval, sval);
        } else if (key === 'scale') {
          // used in polar area & radar charts since there is only one scale
          target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
        } else {
          helpers$1._merger(key, target, source, options);
        }
      }
    });
  }

  function initConfig(config) {
    config = config || Object.create(null); // Do NOT use mergeConfig for the data object because this method merges arrays
    // and so would change references to labels and datasets, preventing data updates.

    var data = config.data = config.data || {};
    data.datasets = data.datasets || [];
    data.labels = data.labels || [];
    config.options = mergeConfig(core_defaults.global, core_defaults[config.type], config.options || {});
    return config;
  }

  function updateConfig(chart) {
    var newOptions = chart.options;
    helpers$1.each(chart.scales, function (scale) {
      core_layouts.removeBox(chart, scale);
    });
    newOptions = mergeConfig(core_defaults.global, core_defaults[chart.config.type], newOptions);
    chart.options = chart.config.options = newOptions;
    chart.ensureScalesHaveIDs();
    chart.buildOrUpdateScales(); // Tooltip

    chart.tooltip._options = newOptions.tooltips;
    chart.tooltip.initialize();
  }

  function nextAvailableScaleId(axesOpts, prefix, index) {
    var id;

    var hasId = function hasId(obj) {
      return obj.id === id;
    };

    do {
      id = prefix + index++;
    } while (helpers$1.findIndex(axesOpts, hasId) >= 0);

    return id;
  }

  function positionIsHorizontal(position) {
    return position === 'top' || position === 'bottom';
  }

  function compare2Level(l1, l2) {
    return function (a, b) {
      return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
    };
  }

  var Chart = function Chart(item, config) {
    this.construct(item, config);
    return this;
  };

  helpers$1.extend(Chart.prototype,
  /** @lends Chart */
  {
    /**
     * @private
     */
    construct: function construct(item, config) {
      var me = this;
      config = initConfig(config);
      var context = platform.acquireContext(item, config);
      var canvas = context && context.canvas;
      var height = canvas && canvas.height;
      var width = canvas && canvas.width;
      me.id = helpers$1.uid();
      me.ctx = context;
      me.canvas = canvas;
      me.config = config;
      me.width = width;
      me.height = height;
      me.aspectRatio = height ? width / height : null;
      me.options = config.options;
      me._bufferedRender = false;
      me._layers = [];
      /**
       * Provided for backward compatibility, Chart and Chart.Controller have been merged,
       * the "instance" still need to be defined since it might be called from plugins.
       * @prop Chart#chart
       * @deprecated since version 2.6.0
       * @todo remove at version 3
       * @private
       */

      me.chart = me;
      me.controller = me; // chart.chart.controller #inception
      // Add the chart instance to the global namespace

      Chart.instances[me.id] = me; // Define alias to the config data: `chart.data === chart.config.data`

      Object.defineProperty(me, 'data', {
        get: function get() {
          return me.config.data;
        },
        set: function set(value) {
          me.config.data = value;
        }
      });

      if (!context || !canvas) {
        // The given item is not a compatible context2d element, let's return before finalizing
        // the chart initialization but after setting basic chart / controller properties that
        // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
        // https://github.com/chartjs/Chart.js/issues/2807
        console.error("Failed to create chart: can't acquire context from the given item");
        return;
      }

      me.initialize();
      me.update();
    },

    /**
     * @private
     */
    initialize: function initialize() {
      var me = this; // Before init plugin notification

      core_plugins.notify(me, 'beforeInit');
      helpers$1.retinaScale(me, me.options.devicePixelRatio);
      me.bindEvents();

      if (me.options.responsive) {
        // Initial resize before chart draws (must be silent to preserve initial animations).
        me.resize(true);
      }

      me.initToolTip(); // After init plugin notification

      core_plugins.notify(me, 'afterInit');
      return me;
    },
    clear: function clear() {
      helpers$1.canvas.clear(this);
      return this;
    },
    stop: function stop() {
      // Stops any current animation loop occurring
      core_animations.cancelAnimation(this);
      return this;
    },
    resize: function resize(silent) {
      var me = this;
      var options = me.options;
      var canvas = me.canvas;
      var aspectRatio = options.maintainAspectRatio && me.aspectRatio || null; // the canvas render width and height will be casted to integers so make sure that
      // the canvas display style uses the same integer values to avoid blurring effect.
      // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed

      var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
      var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));

      if (me.width === newWidth && me.height === newHeight) {
        return;
      }

      canvas.width = me.width = newWidth;
      canvas.height = me.height = newHeight;
      canvas.style.width = newWidth + 'px';
      canvas.style.height = newHeight + 'px';
      helpers$1.retinaScale(me, options.devicePixelRatio);

      if (!silent) {
        // Notify any plugins about the resize
        var newSize = {
          width: newWidth,
          height: newHeight
        };
        core_plugins.notify(me, 'resize', [newSize]); // Notify of resize

        if (options.onResize) {
          options.onResize(me, newSize);
        }

        me.stop();
        me.update({
          duration: options.responsiveAnimationDuration
        });
      }
    },
    ensureScalesHaveIDs: function ensureScalesHaveIDs() {
      var options = this.options;
      var scalesOptions = options.scales || {};
      var scaleOptions = options.scale;
      helpers$1.each(scalesOptions.xAxes, function (xAxisOptions, index) {
        if (!xAxisOptions.id) {
          xAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, 'x-axis-', index);
        }
      });
      helpers$1.each(scalesOptions.yAxes, function (yAxisOptions, index) {
        if (!yAxisOptions.id) {
          yAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, 'y-axis-', index);
        }
      });

      if (scaleOptions) {
        scaleOptions.id = scaleOptions.id || 'scale';
      }
    },

    /**
     * Builds a map of scale ID to scale object for future lookup.
     */
    buildOrUpdateScales: function buildOrUpdateScales() {
      var me = this;
      var options = me.options;
      var scales = me.scales || {};
      var items = [];
      var updated = Object.keys(scales).reduce(function (obj, id) {
        obj[id] = false;
        return obj;
      }, {});

      if (options.scales) {
        items = items.concat((options.scales.xAxes || []).map(function (xAxisOptions) {
          return {
            options: xAxisOptions,
            dtype: 'category',
            dposition: 'bottom'
          };
        }), (options.scales.yAxes || []).map(function (yAxisOptions) {
          return {
            options: yAxisOptions,
            dtype: 'linear',
            dposition: 'left'
          };
        }));
      }

      if (options.scale) {
        items.push({
          options: options.scale,
          dtype: 'radialLinear',
          isDefault: true,
          dposition: 'chartArea'
        });
      }

      helpers$1.each(items, function (item) {
        var scaleOptions = item.options;
        var id = scaleOptions.id;
        var scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);

        if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
          scaleOptions.position = item.dposition;
        }

        updated[id] = true;
        var scale = null;

        if (id in scales && scales[id].type === scaleType) {
          scale = scales[id];
          scale.options = scaleOptions;
          scale.ctx = me.ctx;
          scale.chart = me;
        } else {
          var scaleClass = core_scaleService.getScaleConstructor(scaleType);

          if (!scaleClass) {
            return;
          }

          scale = new scaleClass({
            id: id,
            type: scaleType,
            options: scaleOptions,
            ctx: me.ctx,
            chart: me
          });
          scales[scale.id] = scale;
        }

        scale.mergeTicksOptions(); // TODO(SB): I think we should be able to remove this custom case (options.scale)
        // and consider it as a regular scale part of the "scales"" map only! This would
        // make the logic easier and remove some useless? custom code.

        if (item.isDefault) {
          me.scale = scale;
        }
      }); // clear up discarded scales

      helpers$1.each(updated, function (hasUpdated, id) {
        if (!hasUpdated) {
          delete scales[id];
        }
      });
      me.scales = scales;
      core_scaleService.addScalesToLayout(this);
    },
    buildOrUpdateControllers: function buildOrUpdateControllers() {
      var me = this;
      var newControllers = [];
      var datasets = me.data.datasets;
      var i, ilen;

      for (i = 0, ilen = datasets.length; i < ilen; i++) {
        var dataset = datasets[i];
        var meta = me.getDatasetMeta(i);
        var type = dataset.type || me.config.type;

        if (meta.type && meta.type !== type) {
          me.destroyDatasetMeta(i);
          meta = me.getDatasetMeta(i);
        }

        meta.type = type;
        meta.order = dataset.order || 0;
        meta.index = i;

        if (meta.controller) {
          meta.controller.updateIndex(i);
          meta.controller.linkScales();
        } else {
          var ControllerClass = controllers[meta.type];

          if (ControllerClass === undefined) {
            throw new Error('"' + meta.type + '" is not a chart type.');
          }

          meta.controller = new ControllerClass(me, i);
          newControllers.push(meta.controller);
        }
      }

      return newControllers;
    },

    /**
     * Reset the elements of all datasets
     * @private
     */
    resetElements: function resetElements() {
      var me = this;
      helpers$1.each(me.data.datasets, function (dataset, datasetIndex) {
        me.getDatasetMeta(datasetIndex).controller.reset();
      }, me);
    },

    /**
    * Resets the chart back to it's state before the initial animation
    */
    reset: function reset() {
      this.resetElements();
      this.tooltip.initialize();
    },
    update: function update(config) {
      var me = this;
      var i, ilen;

      if (!config || typeof config !== 'object') {
        // backwards compatibility
        config = {
          duration: config,
          lazy: arguments[1]
        };
      }

      updateConfig(me); // plugins options references might have change, let's invalidate the cache
      // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167

      core_plugins._invalidate(me);

      if (core_plugins.notify(me, 'beforeUpdate') === false) {
        return;
      } // In case the entire data object changed


      me.tooltip._data = me.data; // Make sure dataset controllers are updated and new controllers are reset

      var newControllers = me.buildOrUpdateControllers(); // Make sure all dataset controllers have correct meta data counts

      for (i = 0, ilen = me.data.datasets.length; i < ilen; i++) {
        me.getDatasetMeta(i).controller.buildOrUpdateElements();
      }

      me.updateLayout(); // Can only reset the new controllers after the scales have been updated

      if (me.options.animation && me.options.animation.duration) {
        helpers$1.each(newControllers, function (controller) {
          controller.reset();
        });
      }

      me.updateDatasets(); // Need to reset tooltip in case it is displayed with elements that are removed
      // after update.

      me.tooltip.initialize(); // Last active contains items that were previously in the tooltip.
      // When we reset the tooltip, we need to clear it

      me.lastActive = []; // Do this before render so that any plugins that need final scale updates can use it

      core_plugins.notify(me, 'afterUpdate');

      me._layers.sort(compare2Level('z', '_idx'));

      if (me._bufferedRender) {
        me._bufferedRequest = {
          duration: config.duration,
          easing: config.easing,
          lazy: config.lazy
        };
      } else {
        me.render(config);
      }
    },

    /**
     * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
     * hook, in which case, plugins will not be called on `afterLayout`.
     * @private
     */
    updateLayout: function updateLayout() {
      var me = this;

      if (core_plugins.notify(me, 'beforeLayout') === false) {
        return;
      }

      core_layouts.update(this, this.width, this.height);
      me._layers = [];
      helpers$1.each(me.boxes, function (box) {
        // _configure is called twice, once in core.scale.update and once here.
        // Here the boxes are fully updated and at their final positions.
        if (box._configure) {
          box._configure();
        }

        me._layers.push.apply(me._layers, box._layers());
      }, me);

      me._layers.forEach(function (item, index) {
        item._idx = index;
      });
      /**
       * Provided for backward compatibility, use `afterLayout` instead.
       * @method IPlugin#afterScaleUpdate
       * @deprecated since version 2.5.0
       * @todo remove at version 3
       * @private
       */


      core_plugins.notify(me, 'afterScaleUpdate');
      core_plugins.notify(me, 'afterLayout');
    },

    /**
     * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
     * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
     * @private
     */
    updateDatasets: function updateDatasets() {
      var me = this;

      if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {
        return;
      }

      for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
        me.updateDataset(i);
      }

      core_plugins.notify(me, 'afterDatasetsUpdate');
    },

    /**
     * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
     * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
     * @private
     */
    updateDataset: function updateDataset(index) {
      var me = this;
      var meta = me.getDatasetMeta(index);
      var args = {
        meta: meta,
        index: index
      };

      if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
        return;
      }

      meta.controller._update();

      core_plugins.notify(me, 'afterDatasetUpdate', [args]);
    },
    render: function render(config) {
      var me = this;

      if (!config || typeof config !== 'object') {
        // backwards compatibility
        config = {
          duration: config,
          lazy: arguments[1]
        };
      }

      var animationOptions = me.options.animation;
      var duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);
      var lazy = config.lazy;

      if (core_plugins.notify(me, 'beforeRender') === false) {
        return;
      }

      var onComplete = function onComplete(animation) {
        core_plugins.notify(me, 'afterRender');
        helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);
      };

      if (animationOptions && duration) {
        var animation = new core_animation({
          numSteps: duration / 16.66,
          // 60 fps
          easing: config.easing || animationOptions.easing,
          render: function render(chart, animationObject) {
            var easingFunction = helpers$1.easing.effects[animationObject.easing];
            var currentStep = animationObject.currentStep;
            var stepDecimal = currentStep / animationObject.numSteps;
            chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
          },
          onAnimationProgress: animationOptions.onProgress,
          onAnimationComplete: onComplete
        });
        core_animations.addAnimation(me, animation, duration, lazy);
      } else {
        me.draw(); // See https://github.com/chartjs/Chart.js/issues/3781

        onComplete(new core_animation({
          numSteps: 0,
          chart: me
        }));
      }

      return me;
    },
    draw: function draw(easingValue) {
      var me = this;
      var i, layers;
      me.clear();

      if (helpers$1.isNullOrUndef(easingValue)) {
        easingValue = 1;
      }

      me.transition(easingValue);

      if (me.width <= 0 || me.height <= 0) {
        return;
      }

      if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
        return;
      } // Because of plugin hooks (before/afterDatasetsDraw), datasets can't
      // currently be part of layers. Instead, we draw
      // layers <= 0 before(default, backward compat), and the rest after


      layers = me._layers;

      for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
        layers[i].draw(me.chartArea);
      }

      me.drawDatasets(easingValue); // Rest of layers

      for (; i < layers.length; ++i) {
        layers[i].draw(me.chartArea);
      }

      me._drawTooltip(easingValue);

      core_plugins.notify(me, 'afterDraw', [easingValue]);
    },

    /**
     * @private
     */
    transition: function transition(easingValue) {
      var me = this;

      for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
        if (me.isDatasetVisible(i)) {
          me.getDatasetMeta(i).controller.transition(easingValue);
        }
      }

      me.tooltip.transition(easingValue);
    },

    /**
     * @private
     */
    _getSortedDatasetMetas: function _getSortedDatasetMetas(filterVisible) {
      var me = this;
      var datasets = me.data.datasets || [];
      var result = [];
      var i, ilen;

      for (i = 0, ilen = datasets.length; i < ilen; ++i) {
        if (!filterVisible || me.isDatasetVisible(i)) {
          result.push(me.getDatasetMeta(i));
        }
      }

      result.sort(compare2Level('order', 'index'));
      return result;
    },

    /**
     * @private
     */
    _getSortedVisibleDatasetMetas: function _getSortedVisibleDatasetMetas() {
      return this._getSortedDatasetMetas(true);
    },

    /**
     * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
     * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
     * @private
     */
    drawDatasets: function drawDatasets(easingValue) {
      var me = this;
      var metasets, i;

      if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
        return;
      }

      metasets = me._getSortedVisibleDatasetMetas();

      for (i = metasets.length - 1; i >= 0; --i) {
        me.drawDataset(metasets[i], easingValue);
      }

      core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
    },

    /**
     * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
     * hook, in which case, plugins will not be called on `afterDatasetDraw`.
     * @private
     */
    drawDataset: function drawDataset(meta, easingValue) {
      var me = this;
      var args = {
        meta: meta,
        index: meta.index,
        easingValue: easingValue
      };

      if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
        return;
      }

      meta.controller.draw(easingValue);
      core_plugins.notify(me, 'afterDatasetDraw', [args]);
    },

    /**
     * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
     * hook, in which case, plugins will not be called on `afterTooltipDraw`.
     * @private
     */
    _drawTooltip: function _drawTooltip(easingValue) {
      var me = this;
      var tooltip = me.tooltip;
      var args = {
        tooltip: tooltip,
        easingValue: easingValue
      };

      if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
        return;
      }

      tooltip.draw();
      core_plugins.notify(me, 'afterTooltipDraw', [args]);
    },

    /**
     * Get the single element that was clicked on
     * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
     */
    getElementAtEvent: function getElementAtEvent(e) {
      return core_interaction.modes.single(this, e);
    },
    getElementsAtEvent: function getElementsAtEvent(e) {
      return core_interaction.modes.label(this, e, {
        intersect: true
      });
    },
    getElementsAtXAxis: function getElementsAtXAxis(e) {
      return core_interaction.modes['x-axis'](this, e, {
        intersect: true
      });
    },
    getElementsAtEventForMode: function getElementsAtEventForMode(e, mode, options) {
      var method = core_interaction.modes[mode];

      if (typeof method === 'function') {
        return method(this, e, options);
      }

      return [];
    },
    getDatasetAtEvent: function getDatasetAtEvent(e) {
      return core_interaction.modes.dataset(this, e, {
        intersect: true
      });
    },
    getDatasetMeta: function getDatasetMeta(datasetIndex) {
      var me = this;
      var dataset = me.data.datasets[datasetIndex];

      if (!dataset._meta) {
        dataset._meta = {};
      }

      var meta = dataset._meta[me.id];

      if (!meta) {
        meta = dataset._meta[me.id] = {
          type: null,
          data: [],
          dataset: null,
          controller: null,
          hidden: null,
          // See isDatasetVisible() comment
          xAxisID: null,
          yAxisID: null,
          order: dataset.order || 0,
          index: datasetIndex
        };
      }

      return meta;
    },
    getVisibleDatasetCount: function getVisibleDatasetCount() {
      var count = 0;

      for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
        if (this.isDatasetVisible(i)) {
          count++;
        }
      }

      return count;
    },
    isDatasetVisible: function isDatasetVisible(datasetIndex) {
      var meta = this.getDatasetMeta(datasetIndex); // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
      // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.

      return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
    },
    generateLegend: function generateLegend() {
      return this.options.legendCallback(this);
    },

    /**
     * @private
     */
    destroyDatasetMeta: function destroyDatasetMeta(datasetIndex) {
      var id = this.id;
      var dataset = this.data.datasets[datasetIndex];
      var meta = dataset._meta && dataset._meta[id];

      if (meta) {
        meta.controller.destroy();
        delete dataset._meta[id];
      }
    },
    destroy: function destroy() {
      var me = this;
      var canvas = me.canvas;
      var i, ilen;
      me.stop(); // dataset controllers need to cleanup associated data

      for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
        me.destroyDatasetMeta(i);
      }

      if (canvas) {
        me.unbindEvents();
        helpers$1.canvas.clear(me);
        platform.releaseContext(me.ctx);
        me.canvas = null;
        me.ctx = null;
      }

      core_plugins.notify(me, 'destroy');
      delete Chart.instances[me.id];
    },
    toBase64Image: function toBase64Image() {
      return this.canvas.toDataURL.apply(this.canvas, arguments);
    },
    initToolTip: function initToolTip() {
      var me = this;
      me.tooltip = new core_tooltip({
        _chart: me,
        _chartInstance: me,
        // deprecated, backward compatibility
        _data: me.data,
        _options: me.options.tooltips
      }, me);
    },

    /**
     * @private
     */
    bindEvents: function bindEvents() {
      var me = this;
      var listeners = me._listeners = {};

      var listener = function listener() {
        me.eventHandler.apply(me, arguments);
      };

      helpers$1.each(me.options.events, function (type) {
        platform.addEventListener(me, type, listener);
        listeners[type] = listener;
      }); // Elements used to detect size change should not be injected for non responsive charts.
      // See https://github.com/chartjs/Chart.js/issues/2210

      if (me.options.responsive) {
        listener = function listener() {
          me.resize();
        };

        platform.addEventListener(me, 'resize', listener);
        listeners.resize = listener;
      }
    },

    /**
     * @private
     */
    unbindEvents: function unbindEvents() {
      var me = this;
      var listeners = me._listeners;

      if (!listeners) {
        return;
      }

      delete me._listeners;
      helpers$1.each(listeners, function (listener, type) {
        platform.removeEventListener(me, type, listener);
      });
    },
    updateHoverStyle: function updateHoverStyle(elements, mode, enabled) {
      var prefix = enabled ? 'set' : 'remove';
      var element, i, ilen;

      for (i = 0, ilen = elements.length; i < ilen; ++i) {
        element = elements[i];

        if (element) {
          this.getDatasetMeta(element._datasetIndex).controller[prefix + 'HoverStyle'](element);
        }
      }

      if (mode === 'dataset') {
        this.getDatasetMeta(elements[0]._datasetIndex).controller['_' + prefix + 'DatasetHoverStyle']();
      }
    },

    /**
     * @private
     */
    eventHandler: function eventHandler(e) {
      var me = this;
      var tooltip = me.tooltip;

      if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {
        return;
      } // Buffer any update calls so that renders do not occur


      me._bufferedRender = true;
      me._bufferedRequest = null;
      var changed = me.handleEvent(e); // for smooth tooltip animations issue #4989
      // the tooltip should be the source of change
      // Animation check workaround:
      // tooltip._start will be null when tooltip isn't animating

      if (tooltip) {
        changed = tooltip._start ? tooltip.handleEvent(e) : changed | tooltip.handleEvent(e);
      }

      core_plugins.notify(me, 'afterEvent', [e]);
      var bufferedRequest = me._bufferedRequest;

      if (bufferedRequest) {
        // If we have an update that was triggered, we need to do a normal render
        me.render(bufferedRequest);
      } else if (changed && !me.animating) {
        // If entering, leaving, or changing elements, animate the change via pivot
        me.stop(); // We only need to render at this point. Updating will cause scales to be
        // recomputed generating flicker & using more memory than necessary.

        me.render({
          duration: me.options.hover.animationDuration,
          lazy: true
        });
      }

      me._bufferedRender = false;
      me._bufferedRequest = null;
      return me;
    },

    /**
     * Handle an event
     * @private
     * @param {IEvent} event the event to handle
     * @return {boolean} true if the chart needs to re-render
     */
    handleEvent: function handleEvent(e) {
      var me = this;
      var options = me.options || {};
      var hoverOptions = options.hover;
      var changed = false;
      me.lastActive = me.lastActive || []; // Find Active Elements for hover and tooltips

      if (e.type === 'mouseout') {
        me.active = [];
      } else {
        me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
      } // Invoke onHover hook
      // Need to call with native event here to not break backwards compatibility


      helpers$1.callback(options.onHover || options.hover.onHover, [e["native"], me.active], me);

      if (e.type === 'mouseup' || e.type === 'click') {
        if (options.onClick) {
          // Use e.native here for backwards compatibility
          options.onClick.call(me, e["native"], me.active);
        }
      } // Remove styling for last active (even if it may still be active)


      if (me.lastActive.length) {
        me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
      } // Built in hover styling


      if (me.active.length && hoverOptions.mode) {
        me.updateHoverStyle(me.active, hoverOptions.mode, true);
      }

      changed = !helpers$1.arrayEquals(me.active, me.lastActive); // Remember Last Actives

      me.lastActive = me.active;
      return changed;
    }
  });
  /**
   * NOTE(SB) We actually don't use this container anymore but we need to keep it
   * for backward compatibility. Though, it can still be useful for plugins that
   * would need to work on multiple charts?!
   */

  Chart.instances = {};
  var core_controller = Chart; // DEPRECATIONS

  /**
   * Provided for backward compatibility, use Chart instead.
   * @class Chart.Controller
   * @deprecated since version 2.6
   * @todo remove at version 3
   * @private
   */

  Chart.Controller = Chart;
  /**
   * Provided for backward compatibility, not available anymore.
   * @namespace Chart
   * @deprecated since version 2.8
   * @todo remove at version 3
   * @private
   */

  Chart.types = {};
  /**
   * Provided for backward compatibility, not available anymore.
   * @namespace Chart.helpers.configMerge
   * @deprecated since version 2.8.0
   * @todo remove at version 3
   * @private
   */

  helpers$1.configMerge = mergeConfig;
  /**
   * Provided for backward compatibility, not available anymore.
   * @namespace Chart.helpers.scaleMerge
   * @deprecated since version 2.8.0
   * @todo remove at version 3
   * @private
   */

  helpers$1.scaleMerge = mergeScaleConfig;

  var core_helpers = function core_helpers() {
    // -- Basic js utility methods
    helpers$1.where = function (collection, filterCallback) {
      if (helpers$1.isArray(collection) && Array.prototype.filter) {
        return collection.filter(filterCallback);
      }

      var filtered = [];
      helpers$1.each(collection, function (item) {
        if (filterCallback(item)) {
          filtered.push(item);
        }
      });
      return filtered;
    };

    helpers$1.findIndex = Array.prototype.findIndex ? function (array, callback, scope) {
      return array.findIndex(callback, scope);
    } : function (array, callback, scope) {
      scope = scope === undefined ? array : scope;

      for (var i = 0, ilen = array.length; i < ilen; ++i) {
        if (callback.call(scope, array[i], i, array)) {
          return i;
        }
      }

      return -1;
    };

    helpers$1.findNextWhere = function (arrayToSearch, filterCallback, startIndex) {
      // Default to start of the array
      if (helpers$1.isNullOrUndef(startIndex)) {
        startIndex = -1;
      }

      for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
        var currentItem = arrayToSearch[i];

        if (filterCallback(currentItem)) {
          return currentItem;
        }
      }
    };

    helpers$1.findPreviousWhere = function (arrayToSearch, filterCallback, startIndex) {
      // Default to end of the array
      if (helpers$1.isNullOrUndef(startIndex)) {
        startIndex = arrayToSearch.length;
      }

      for (var i = startIndex - 1; i >= 0; i--) {
        var currentItem = arrayToSearch[i];

        if (filterCallback(currentItem)) {
          return currentItem;
        }
      }
    }; // -- Math methods


    helpers$1.isNumber = function (n) {
      return !isNaN(parseFloat(n)) && isFinite(n);
    };

    helpers$1.almostEquals = function (x, y, epsilon) {
      return Math.abs(x - y) < epsilon;
    };

    helpers$1.almostWhole = function (x, epsilon) {
      var rounded = Math.round(x);
      return rounded - epsilon <= x && rounded + epsilon >= x;
    };

    helpers$1.max = function (array) {
      return array.reduce(function (max, value) {
        if (!isNaN(value)) {
          return Math.max(max, value);
        }

        return max;
      }, Number.NEGATIVE_INFINITY);
    };

    helpers$1.min = function (array) {
      return array.reduce(function (min, value) {
        if (!isNaN(value)) {
          return Math.min(min, value);
        }

        return min;
      }, Number.POSITIVE_INFINITY);
    };

    helpers$1.sign = Math.sign ? function (x) {
      return Math.sign(x);
    } : function (x) {
      x = +x; // convert to a number

      if (x === 0 || isNaN(x)) {
        return x;
      }

      return x > 0 ? 1 : -1;
    };

    helpers$1.toRadians = function (degrees) {
      return degrees * (Math.PI / 180);
    };

    helpers$1.toDegrees = function (radians) {
      return radians * (180 / Math.PI);
    };
    /**
     * Returns the number of decimal places
     * i.e. the number of digits after the decimal point, of the value of this Number.
     * @param {number} x - A number.
     * @returns {number} The number of decimal places.
     * @private
     */


    helpers$1._decimalPlaces = function (x) {
      if (!helpers$1.isFinite(x)) {
        return;
      }

      var e = 1;
      var p = 0;

      while (Math.round(x * e) / e !== x) {
        e *= 10;
        p++;
      }

      return p;
    }; // Gets the angle from vertical upright to the point about a centre.


    helpers$1.getAngleFromPoint = function (centrePoint, anglePoint) {
      var distanceFromXCenter = anglePoint.x - centrePoint.x;
      var distanceFromYCenter = anglePoint.y - centrePoint.y;
      var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
      var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

      if (angle < -0.5 * Math.PI) {
        angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
      }

      return {
        angle: angle,
        distance: radialDistanceFromCenter
      };
    };

    helpers$1.distanceBetweenPoints = function (pt1, pt2) {
      return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
    };
    /**
     * Provided for backward compatibility, not available anymore
     * @function Chart.helpers.aliasPixel
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     */


    helpers$1.aliasPixel = function (pixelWidth) {
      return pixelWidth % 2 === 0 ? 0 : 0.5;
    };
    /**
     * Returns the aligned pixel value to avoid anti-aliasing blur
     * @param {Chart} chart - The chart instance.
     * @param {number} pixel - A pixel value.
     * @param {number} width - The width of the element.
     * @returns {number} The aligned pixel value.
     * @private
     */


    helpers$1._alignPixel = function (chart, pixel, width) {
      var devicePixelRatio = chart.currentDevicePixelRatio;
      var halfWidth = width / 2;
      return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
    };

    helpers$1.splineCurve = function (firstPoint, middlePoint, afterPoint, t) {
      // Props to Rob Spencer at scaled innovation for his post on splining between points
      // http://scaledinnovation.com/analytics/splines/aboutSplines.html
      // This function must also respect "skipped" points
      var previous = firstPoint.skip ? middlePoint : firstPoint;
      var current = middlePoint;
      var next = afterPoint.skip ? middlePoint : afterPoint;
      var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
      var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));
      var s01 = d01 / (d01 + d12);
      var s12 = d12 / (d01 + d12); // If all points are the same, s01 & s02 will be inf

      s01 = isNaN(s01) ? 0 : s01;
      s12 = isNaN(s12) ? 0 : s12;
      var fa = t * s01; // scaling factor for triangle Ta

      var fb = t * s12;
      return {
        previous: {
          x: current.x - fa * (next.x - previous.x),
          y: current.y - fa * (next.y - previous.y)
        },
        next: {
          x: current.x + fb * (next.x - previous.x),
          y: current.y + fb * (next.y - previous.y)
        }
      };
    };

    helpers$1.EPSILON = Number.EPSILON || 1e-14;

    helpers$1.splineCurveMonotone = function (points) {
      // This function calculates Bzier control points in a similar way than |splineCurve|,
      // but preserves monotonicity of the provided data and ensures no local extremums are added
      // between the dataset discrete points due to the interpolation.
      // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
      var pointsWithTangents = (points || []).map(function (point) {
        return {
          model: point._model,
          deltaK: 0,
          mK: 0
        };
      }); // Calculate slopes (deltaK) and initialize tangents (mK)

      var pointsLen = pointsWithTangents.length;
      var i, pointBefore, pointCurrent, pointAfter;

      for (i = 0; i < pointsLen; ++i) {
        pointCurrent = pointsWithTangents[i];

        if (pointCurrent.model.skip) {
          continue;
        }

        pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
        pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

        if (pointAfter && !pointAfter.model.skip) {
          var slopeDeltaX = pointAfter.model.x - pointCurrent.model.x; // In the case of two points that appear at the same x pixel, slopeDeltaX is 0

          pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
        }

        if (!pointBefore || pointBefore.model.skip) {
          pointCurrent.mK = pointCurrent.deltaK;
        } else if (!pointAfter || pointAfter.model.skip) {
          pointCurrent.mK = pointBefore.deltaK;
        } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
          pointCurrent.mK = 0;
        } else {
          pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
        }
      } // Adjust tangents to ensure monotonic properties


      var alphaK, betaK, tauK, squaredMagnitude;

      for (i = 0; i < pointsLen - 1; ++i) {
        pointCurrent = pointsWithTangents[i];
        pointAfter = pointsWithTangents[i + 1];

        if (pointCurrent.model.skip || pointAfter.model.skip) {
          continue;
        }

        if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
          pointCurrent.mK = pointAfter.mK = 0;
          continue;
        }

        alphaK = pointCurrent.mK / pointCurrent.deltaK;
        betaK = pointAfter.mK / pointCurrent.deltaK;
        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);

        if (squaredMagnitude <= 9) {
          continue;
        }

        tauK = 3 / Math.sqrt(squaredMagnitude);
        pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
        pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
      } // Compute control points


      var deltaX;

      for (i = 0; i < pointsLen; ++i) {
        pointCurrent = pointsWithTangents[i];

        if (pointCurrent.model.skip) {
          continue;
        }

        pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
        pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;

        if (pointBefore && !pointBefore.model.skip) {
          deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
          pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
          pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
        }

        if (pointAfter && !pointAfter.model.skip) {
          deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
          pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
          pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
        }
      }
    };

    helpers$1.nextItem = function (collection, index, loop) {
      if (loop) {
        return index >= collection.length - 1 ? collection[0] : collection[index + 1];
      }

      return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
    };

    helpers$1.previousItem = function (collection, index, loop) {
      if (loop) {
        return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
      }

      return index <= 0 ? collection[0] : collection[index - 1];
    }; // Implementation of the nice number algorithm used in determining where axis labels will go


    helpers$1.niceNum = function (range, round) {
      var exponent = Math.floor(helpers$1.log10(range));
      var fraction = range / Math.pow(10, exponent);
      var niceFraction;

      if (round) {
        if (fraction < 1.5) {
          niceFraction = 1;
        } else if (fraction < 3) {
          niceFraction = 2;
        } else if (fraction < 7) {
          niceFraction = 5;
        } else {
          niceFraction = 10;
        }
      } else if (fraction <= 1.0) {
        niceFraction = 1;
      } else if (fraction <= 2) {
        niceFraction = 2;
      } else if (fraction <= 5) {
        niceFraction = 5;
      } else {
        niceFraction = 10;
      }

      return niceFraction * Math.pow(10, exponent);
    }; // Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/


    helpers$1.requestAnimFrame = function () {
      if (typeof window === 'undefined') {
        return function (callback) {
          callback();
        };
      }

      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
        return window.setTimeout(callback, 1000 / 60);
      };
    }(); // -- DOM methods


    helpers$1.getRelativePosition = function (evt, chart) {
      var mouseX, mouseY;
      var e = evt.originalEvent || evt;
      var canvas = evt.target || evt.srcElement;
      var boundingRect = canvas.getBoundingClientRect();
      var touches = e.touches;

      if (touches && touches.length > 0) {
        mouseX = touches[0].clientX;
        mouseY = touches[0].clientY;
      } else {
        mouseX = e.clientX;
        mouseY = e.clientY;
      } // Scale mouse coordinates into canvas coordinates
      // by following the pattern laid out by 'jerryj' in the comments of
      // https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/


      var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));
      var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));
      var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));
      var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));
      var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
      var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom; // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
      // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here

      mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / width * canvas.width / chart.currentDevicePixelRatio);
      mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / height * canvas.height / chart.currentDevicePixelRatio);
      return {
        x: mouseX,
        y: mouseY
      };
    }; // Private helper function to convert max-width/max-height values that may be percentages into a number


    function parseMaxStyle(styleValue, node, parentProperty) {
      var valueInPixels;

      if (typeof styleValue === 'string') {
        valueInPixels = parseInt(styleValue, 10);

        if (styleValue.indexOf('%') !== -1) {
          // percentage * size in dimension
          valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
        }
      } else {
        valueInPixels = styleValue;
      }

      return valueInPixels;
    }
    /**
     * Returns if the given value contains an effective constraint.
     * @private
     */


    function isConstrainedValue(value) {
      return value !== undefined && value !== null && value !== 'none';
    }
    /**
     * Returns the max width or height of the given DOM node in a cross-browser compatible fashion
     * @param {HTMLElement} domNode - the node to check the constraint on
     * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')
     * @param {string} percentageProperty - property of parent to use when calculating width as a percentage
     * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}
     */


    function getConstraintDimension(domNode, maxStyle, percentageProperty) {
      var view = document.defaultView;

      var parentNode = helpers$1._getParentNode(domNode);

      var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
      var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
      var hasCNode = isConstrainedValue(constrainedNode);
      var hasCContainer = isConstrainedValue(constrainedContainer);
      var infinity = Number.POSITIVE_INFINITY;

      if (hasCNode || hasCContainer) {
        return Math.min(hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity, hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
      }

      return 'none';
    } // returns Number or undefined if no constraint


    helpers$1.getConstraintWidth = function (domNode) {
      return getConstraintDimension(domNode, 'max-width', 'clientWidth');
    }; // returns Number or undefined if no constraint


    helpers$1.getConstraintHeight = function (domNode) {
      return getConstraintDimension(domNode, 'max-height', 'clientHeight');
    };
    /**
     * @private
    	 */


    helpers$1._calculatePadding = function (container, padding, parentDimension) {
      padding = helpers$1.getStyle(container, padding);
      return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
    };
    /**
     * @private
     */


    helpers$1._getParentNode = function (domNode) {
      var parent = domNode.parentNode;

      if (parent && parent.toString() === '[object ShadowRoot]') {
        parent = parent.host;
      }

      return parent;
    };

    helpers$1.getMaximumWidth = function (domNode) {
      var container = helpers$1._getParentNode(domNode);

      if (!container) {
        return domNode.clientWidth;
      }

      var clientWidth = container.clientWidth;

      var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);

      var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);

      var w = clientWidth - paddingLeft - paddingRight;
      var cw = helpers$1.getConstraintWidth(domNode);
      return isNaN(cw) ? w : Math.min(w, cw);
    };

    helpers$1.getMaximumHeight = function (domNode) {
      var container = helpers$1._getParentNode(domNode);

      if (!container) {
        return domNode.clientHeight;
      }

      var clientHeight = container.clientHeight;

      var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);

      var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);

      var h = clientHeight - paddingTop - paddingBottom;
      var ch = helpers$1.getConstraintHeight(domNode);
      return isNaN(ch) ? h : Math.min(h, ch);
    };

    helpers$1.getStyle = function (el, property) {
      return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
    };

    helpers$1.retinaScale = function (chart, forceRatio) {
      var pixelRatio = chart.currentDevicePixelRatio = forceRatio || typeof window !== 'undefined' && window.devicePixelRatio || 1;

      if (pixelRatio === 1) {
        return;
      }

      var canvas = chart.canvas;
      var height = chart.height;
      var width = chart.width;
      canvas.height = height * pixelRatio;
      canvas.width = width * pixelRatio;
      chart.ctx.scale(pixelRatio, pixelRatio); // If no style has been set on the canvas, the render size is used as display size,
      // making the chart visually bigger, so let's enforce it to the "correct" values.
      // See https://github.com/chartjs/Chart.js/issues/3575

      if (!canvas.style.height && !canvas.style.width) {
        canvas.style.height = height + 'px';
        canvas.style.width = width + 'px';
      }
    }; // -- Canvas methods


    helpers$1.fontString = function (pixelSize, fontStyle, fontFamily) {
      return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
    };

    helpers$1.longestText = function (ctx, font, arrayOfThings, cache) {
      cache = cache || {};
      var data = cache.data = cache.data || {};
      var gc = cache.garbageCollect = cache.garbageCollect || [];

      if (cache.font !== font) {
        data = cache.data = {};
        gc = cache.garbageCollect = [];
        cache.font = font;
      }

      ctx.font = font;
      var longest = 0;
      var ilen = arrayOfThings.length;
      var i, j, jlen, thing, nestedThing;

      for (i = 0; i < ilen; i++) {
        thing = arrayOfThings[i]; // Undefined strings and arrays should not be measured

        if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {
          longest = helpers$1.measureText(ctx, data, gc, longest, thing);
        } else if (helpers$1.isArray(thing)) {
          // if it is an array lets measure each element
          // to do maybe simplify this function a bit so we can do this more recursively?
          for (j = 0, jlen = thing.length; j < jlen; j++) {
            nestedThing = thing[j]; // Undefined strings and arrays should not be measured

            if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
              longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
            }
          }
        }
      }

      var gcLen = gc.length / 2;

      if (gcLen > arrayOfThings.length) {
        for (i = 0; i < gcLen; i++) {
          delete data[gc[i]];
        }

        gc.splice(0, gcLen);
      }

      return longest;
    };

    helpers$1.measureText = function (ctx, data, gc, longest, string) {
      var textWidth = data[string];

      if (!textWidth) {
        textWidth = data[string] = ctx.measureText(string).width;
        gc.push(string);
      }

      if (textWidth > longest) {
        longest = textWidth;
      }

      return longest;
    };
    /**
     * @deprecated
     */


    helpers$1.numberOfLabelLines = function (arrayOfThings) {
      var numberOfLines = 1;
      helpers$1.each(arrayOfThings, function (thing) {
        if (helpers$1.isArray(thing)) {
          if (thing.length > numberOfLines) {
            numberOfLines = thing.length;
          }
        }
      });
      return numberOfLines;
    };

    helpers$1.color = !chartjsColor ? function (value) {
      console.error('Color.js not found!');
      return value;
    } : function (value) {
      /* global CanvasGradient */
      if (value instanceof CanvasGradient) {
        value = core_defaults.global.defaultColor;
      }

      return chartjsColor(value);
    };

    helpers$1.getHoverColor = function (colorValue) {
      /* global CanvasPattern */
      return colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient ? colorValue : helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
    };
  };

  function _abstract() {
    throw new Error('This method is not implemented: either no adapter can ' + 'be found or an incomplete integration was provided.');
  }
  /**
   * Date adapter (current used by the time scale)
   * @namespace Chart._adapters._date
   * @memberof Chart._adapters
   * @private
   */

  /**
   * Currently supported unit string values.
   * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}
   * @memberof Chart._adapters._date
   * @name Unit
   */

  /**
   * @class
   */


  function DateAdapter(options) {
    this.options = options || {};
  }

  helpers$1.extend(DateAdapter.prototype,
  /** @lends DateAdapter */
  {
    /**
     * Returns a map of time formats for the supported formatting units defined
     * in Unit as well as 'datetime' representing a detailed date/time string.
     * @returns {{string: string}}
     */
    formats: _abstract,

    /**
     * Parses the given `value` and return the associated timestamp.
     * @param {any} value - the value to parse (usually comes from the data)
     * @param {string} [format] - the expected data format
     * @returns {(number|null)}
     * @function
     */
    parse: _abstract,

    /**
     * Returns the formatted date in the specified `format` for a given `timestamp`.
     * @param {number} timestamp - the timestamp to format
     * @param {string} format - the date/time token
     * @return {string}
     * @function
     */
    format: _abstract,

    /**
     * Adds the specified `amount` of `unit` to the given `timestamp`.
     * @param {number} timestamp - the input timestamp
     * @param {number} amount - the amount to add
     * @param {Unit} unit - the unit as string
     * @return {number}
     * @function
     */
    add: _abstract,

    /**
     * Returns the number of `unit` between the given timestamps.
     * @param {number} max - the input timestamp (reference)
     * @param {number} min - the timestamp to substract
     * @param {Unit} unit - the unit as string
     * @return {number}
     * @function
     */
    diff: _abstract,

    /**
     * Returns start of `unit` for the given `timestamp`.
     * @param {number} timestamp - the input timestamp
     * @param {Unit} unit - the unit as string
     * @param {number} [weekday] - the ISO day of the week with 1 being Monday
     * and 7 being Sunday (only needed if param *unit* is `isoWeek`).
     * @function
     */
    startOf: _abstract,

    /**
     * Returns end of `unit` for the given `timestamp`.
     * @param {number} timestamp - the input timestamp
     * @param {Unit} unit - the unit as string
     * @function
     */
    endOf: _abstract,
    // DEPRECATIONS

    /**
     * Provided for backward compatibility for scale.getValueForPixel(),
     * this method should be overridden only by the moment adapter.
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */
    _create: function _create(value) {
      return value;
    }
  });

  DateAdapter.override = function (members) {
    helpers$1.extend(DateAdapter.prototype, members);
  };

  var _date = DateAdapter;
  var core_adapters = {
    _date: _date
  };
  /**
   * Namespace to hold static tick generation functions
   * @namespace Chart.Ticks
   */

  var core_ticks = {
    /**
     * Namespace to hold formatters for different types of ticks
     * @namespace Chart.Ticks.formatters
     */
    formatters: {
      /**
       * Formatter for value labels
       * @method Chart.Ticks.formatters.values
       * @param value the value to display
       * @return {string|string[]} the label to display
       */
      values: function values(value) {
        return helpers$1.isArray(value) ? value : '' + value;
      },

      /**
       * Formatter for linear numeric ticks
       * @method Chart.Ticks.formatters.linear
       * @param tickValue {number} the value to be formatted
       * @param index {number} the position of the tickValue parameter in the ticks array
       * @param ticks {number[]} the list of ticks being converted
       * @return {string} string representation of the tickValue parameter
       */
      linear: function linear(tickValue, index, ticks) {
        // If we have lots of ticks, don't use the ones
        var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need

        if (Math.abs(delta) > 1) {
          if (tickValue !== Math.floor(tickValue)) {
            // not an integer
            delta = tickValue - Math.floor(tickValue);
          }
        }

        var logDelta = helpers$1.log10(Math.abs(delta));
        var tickString = '';

        if (tickValue !== 0) {
          var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));

          if (maxTick < 1e-4) {
            // all ticks are small numbers; use scientific notation
            var logTick = helpers$1.log10(Math.abs(tickValue));
            var numExponential = Math.floor(logTick) - Math.floor(logDelta);
            numExponential = Math.max(Math.min(numExponential, 20), 0);
            tickString = tickValue.toExponential(numExponential);
          } else {
            var numDecimal = -1 * Math.floor(logDelta);
            numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places

            tickString = tickValue.toFixed(numDecimal);
          }
        } else {
          tickString = '0'; // never show decimal places for 0
        }

        return tickString;
      },
      logarithmic: function logarithmic(tickValue, index, ticks) {
        var remain = tickValue / Math.pow(10, Math.floor(helpers$1.log10(tickValue)));

        if (tickValue === 0) {
          return '0';
        } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
          return tickValue.toExponential();
        }

        return '';
      }
    }
  };
  var isArray = helpers$1.isArray;
  var isNullOrUndef = helpers$1.isNullOrUndef;
  var valueOrDefault$a = helpers$1.valueOrDefault;
  var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;

  core_defaults._set('scale', {
    display: true,
    position: 'left',
    offset: false,
    // grid line settings
    gridLines: {
      display: true,
      color: 'rgba(0,0,0,0.1)',
      lineWidth: 1,
      drawBorder: true,
      drawOnChartArea: true,
      drawTicks: true,
      tickMarkLength: 10,
      zeroLineWidth: 1,
      zeroLineColor: 'rgba(0,0,0,0.25)',
      zeroLineBorderDash: [],
      zeroLineBorderDashOffset: 0.0,
      offsetGridLines: false,
      borderDash: [],
      borderDashOffset: 0.0
    },
    // scale label
    scaleLabel: {
      // display property
      display: false,
      // actual label
      labelString: '',
      // top/bottom padding
      padding: {
        top: 4,
        bottom: 4
      }
    },
    // label settings
    ticks: {
      beginAtZero: false,
      minRotation: 0,
      maxRotation: 50,
      mirror: false,
      padding: 0,
      reverse: false,
      display: true,
      autoSkip: true,
      autoSkipPadding: 0,
      labelOffset: 0,
      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
      callback: core_ticks.formatters.values,
      minor: {},
      major: {}
    }
  });
  /** Returns a new array containing numItems from arr */


  function sample(arr, numItems) {
    var result = [];
    var increment = arr.length / numItems;
    var i = 0;
    var len = arr.length;

    for (; i < len; i += increment) {
      result.push(arr[Math.floor(i)]);
    }

    return result;
  }

  function getPixelForGridLine(scale, index, offsetGridLines) {
    var length = scale.getTicks().length;
    var validIndex = Math.min(index, length - 1);
    var lineValue = scale.getPixelForTick(validIndex);
    var start = scale._startPixel;
    var end = scale._endPixel;
    var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.

    var offset;

    if (offsetGridLines) {
      if (length === 1) {
        offset = Math.max(lineValue - start, end - lineValue);
      } else if (index === 0) {
        offset = (scale.getPixelForTick(1) - lineValue) / 2;
      } else {
        offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
      }

      lineValue += validIndex < index ? offset : -offset; // Return undefined if the pixel is out of the range

      if (lineValue < start - epsilon || lineValue > end + epsilon) {
        return;
      }
    }

    return lineValue;
  }

  function garbageCollect(caches, length) {
    helpers$1.each(caches, function (cache) {
      var gc = cache.gc;
      var gcLen = gc.length / 2;
      var i;

      if (gcLen > length) {
        for (i = 0; i < gcLen; ++i) {
          delete cache.data[gc[i]];
        }

        gc.splice(0, gcLen);
      }
    });
  }
  /**
   * Returns {width, height, offset} objects for the first, last, widest, highest tick
   * labels where offset indicates the anchor point offset from the top in pixels.
   */


  function computeLabelSizes(ctx, tickFonts, ticks, caches) {
    var length = ticks.length;
    var widths = [];
    var heights = [];
    var offsets = [];
    var widestLabelSize = 0;
    var highestLabelSize = 0;
    var i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel, widest, highest;

    for (i = 0; i < length; ++i) {
      label = ticks[i].label;
      tickFont = ticks[i].major ? tickFonts.major : tickFonts.minor;
      ctx.font = fontString = tickFont.string;
      cache = caches[fontString] = caches[fontString] || {
        data: {},
        gc: []
      };
      lineHeight = tickFont.lineHeight;
      width = height = 0; // Undefined labels and arrays should not be measured

      if (!isNullOrUndef(label) && !isArray(label)) {
        width = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);
        height = lineHeight;
      } else if (isArray(label)) {
        // if it is an array let's measure each element
        for (j = 0, jlen = label.length; j < jlen; ++j) {
          nestedLabel = label[j]; // Undefined labels and arrays should not be measured

          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
            width = helpers$1.measureText(ctx, cache.data, cache.gc, width, nestedLabel);
            height += lineHeight;
          }
        }
      }

      widths.push(width);
      heights.push(height);
      offsets.push(lineHeight / 2);
      widestLabelSize = Math.max(width, widestLabelSize);
      highestLabelSize = Math.max(height, highestLabelSize);
    }

    garbageCollect(caches, length);
    widest = widths.indexOf(widestLabelSize);
    highest = heights.indexOf(highestLabelSize);

    function valueAt(idx) {
      return {
        width: widths[idx] || 0,
        height: heights[idx] || 0,
        offset: offsets[idx] || 0
      };
    }

    return {
      first: valueAt(0),
      last: valueAt(length - 1),
      widest: valueAt(widest),
      highest: valueAt(highest)
    };
  }

  function getTickMarkLength(options) {
    return options.drawTicks ? options.tickMarkLength : 0;
  }

  function getScaleLabelHeight(options) {
    var font, padding;

    if (!options.display) {
      return 0;
    }

    font = helpers$1.options._parseFont(options);
    padding = helpers$1.options.toPadding(options.padding);
    return font.lineHeight + padding.height;
  }

  function parseFontOptions(options, nestedOpts) {
    return helpers$1.extend(helpers$1.options._parseFont({
      fontFamily: valueOrDefault$a(nestedOpts.fontFamily, options.fontFamily),
      fontSize: valueOrDefault$a(nestedOpts.fontSize, options.fontSize),
      fontStyle: valueOrDefault$a(nestedOpts.fontStyle, options.fontStyle),
      lineHeight: valueOrDefault$a(nestedOpts.lineHeight, options.lineHeight)
    }), {
      color: helpers$1.options.resolve([nestedOpts.fontColor, options.fontColor, core_defaults.global.defaultFontColor])
    });
  }

  function parseTickFontOptions(options) {
    var minor = parseFontOptions(options, options.minor);
    var major = options.major.enabled ? parseFontOptions(options, options.major) : minor;
    return {
      minor: minor,
      major: major
    };
  }

  function nonSkipped(ticksToFilter) {
    var filtered = [];
    var item, index, len;

    for (index = 0, len = ticksToFilter.length; index < len; ++index) {
      item = ticksToFilter[index];

      if (typeof item._index !== 'undefined') {
        filtered.push(item);
      }
    }

    return filtered;
  }

  function getEvenSpacing(arr) {
    var len = arr.length;
    var i, diff;

    if (len < 2) {
      return false;
    }

    for (diff = arr[0], i = 1; i < len; ++i) {
      if (arr[i] - arr[i - 1] !== diff) {
        return false;
      }
    }

    return diff;
  }

  function calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {
    var evenMajorSpacing = getEvenSpacing(majorIndices);
    var spacing = (ticks.length - 1) / ticksLimit;
    var factors, factor, i, ilen; // If the major ticks are evenly spaced apart, place the minor ticks
    // so that they divide the major ticks into even chunks

    if (!evenMajorSpacing) {
      return Math.max(spacing, 1);
    }

    factors = helpers$1.math._factorize(evenMajorSpacing);

    for (i = 0, ilen = factors.length - 1; i < ilen; i++) {
      factor = factors[i];

      if (factor > spacing) {
        return factor;
      }
    }

    return Math.max(spacing, 1);
  }

  function getMajorIndices(ticks) {
    var result = [];
    var i, ilen;

    for (i = 0, ilen = ticks.length; i < ilen; i++) {
      if (ticks[i].major) {
        result.push(i);
      }
    }

    return result;
  }

  function skipMajors(ticks, majorIndices, spacing) {
    var count = 0;
    var next = majorIndices[0];
    var i, tick;
    spacing = Math.ceil(spacing);

    for (i = 0; i < ticks.length; i++) {
      tick = ticks[i];

      if (i === next) {
        tick._index = i;
        count++;
        next = majorIndices[count * spacing];
      } else {
        delete tick.label;
      }
    }
  }

  function skip(ticks, spacing, majorStart, majorEnd) {
    var start = valueOrDefault$a(majorStart, 0);
    var end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);
    var count = 0;
    var length, i, tick, next;
    spacing = Math.ceil(spacing);

    if (majorEnd) {
      length = majorEnd - majorStart;
      spacing = length / Math.floor(length / spacing);
    }

    next = start;

    while (next < 0) {
      count++;
      next = Math.round(start + count * spacing);
    }

    for (i = Math.max(start, 0); i < end; i++) {
      tick = ticks[i];

      if (i === next) {
        tick._index = i;
        count++;
        next = Math.round(start + count * spacing);
      } else {
        delete tick.label;
      }
    }
  }

  var Scale = core_element.extend({
    zeroLineIndex: 0,

    /**
     * Get the padding needed for the scale
     * @method getPadding
     * @private
     * @returns {Padding} the necessary padding
     */
    getPadding: function getPadding() {
      var me = this;
      return {
        left: me.paddingLeft || 0,
        top: me.paddingTop || 0,
        right: me.paddingRight || 0,
        bottom: me.paddingBottom || 0
      };
    },

    /**
     * Returns the scale tick objects ({label, major})
     * @since 2.7
     */
    getTicks: function getTicks() {
      return this._ticks;
    },

    /**
    * @private
    */
    _getLabels: function _getLabels() {
      var data = this.chart.data;
      return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
    },
    // These methods are ordered by lifecyle. Utilities then follow.
    // Any function defined here is inherited by all scale types.
    // Any function can be extended by the scale type

    /**
     * Provided for backward compatibility, not available anymore
     * @function Chart.Scale.mergeTicksOptions
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     */
    mergeTicksOptions: function mergeTicksOptions() {// noop
    },
    beforeUpdate: function beforeUpdate() {
      helpers$1.callback(this.options.beforeUpdate, [this]);
    },

    /**
     * @param {number} maxWidth - the max width in pixels
     * @param {number} maxHeight - the max height in pixels
     * @param {object} margins - the space between the edge of the other scales and edge of the chart
     *   This space comes from two sources:
     *     - padding - space that's required to show the labels at the edges of the scale
     *     - thickness of scales or legends in another orientation
     */
    update: function update(maxWidth, maxHeight, margins) {
      var me = this;
      var tickOpts = me.options.ticks;
      var sampleSize = tickOpts.sampleSize;
      var i, ilen, labels, ticks, samplingEnabled; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

      me.beforeUpdate(); // Absorb the master measurements

      me.maxWidth = maxWidth;
      me.maxHeight = maxHeight;
      me.margins = helpers$1.extend({
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      }, margins);
      me._ticks = null;
      me.ticks = null;
      me._labelSizes = null;
      me._maxLabelLines = 0;
      me.longestLabelWidth = 0;
      me.longestTextCache = me.longestTextCache || {};
      me._gridLineItems = null;
      me._labelItems = null; // Dimensions

      me.beforeSetDimensions();
      me.setDimensions();
      me.afterSetDimensions(); // Data min/max

      me.beforeDataLimits();
      me.determineDataLimits();
      me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!
      // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
      // and must not be accessed directly from outside this class. `this.ticks` being
      // around for long time and not marked as private, we can't change its structure
      // without unexpected breaking changes. If you need to access the scale ticks,
      // use scale.getTicks() instead.

      me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,
      // we still support no return (`this.ticks` internally set by calling this method).

      ticks = me.buildTicks() || []; // Allow modification of ticks in callback.

      ticks = me.afterBuildTicks(ticks) || ticks; // Ensure ticks contains ticks in new tick format

      if ((!ticks || !ticks.length) && me.ticks) {
        ticks = [];

        for (i = 0, ilen = me.ticks.length; i < ilen; ++i) {
          ticks.push({
            value: me.ticks[i],
            major: false
          });
        }
      }

      me._ticks = ticks; // Compute tick rotation and fit using a sampled subset of labels
      // We generally don't need to compute the size of every single label for determining scale size

      samplingEnabled = sampleSize < ticks.length;
      labels = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks); // _configure is called twice, once here, once from core.controller.updateLayout.
      // Here we haven't been positioned yet, but dimensions are correct.
      // Variables set in _configure are needed for calculateTickRotation, and
      // it's ok that coordinates are not correct there, only dimensions matter.

      me._configure(); // Tick Rotation


      me.beforeCalculateTickRotation();
      me.calculateTickRotation();
      me.afterCalculateTickRotation();
      me.beforeFit();
      me.fit();
      me.afterFit(); // Auto-skip

      me._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto') ? me._autoSkip(ticks) : ticks;

      if (samplingEnabled) {
        // Generate labels using all non-skipped ticks
        labels = me._convertTicksToLabels(me._ticksToDraw);
      }

      me.ticks = labels; // BACKWARD COMPATIBILITY
      // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!

      me.afterUpdate(); // TODO(v3): remove minSize as a public property and return value from all layout boxes. It is unused
      // make maxWidth and maxHeight private

      return me.minSize;
    },

    /**
     * @private
     */
    _configure: function _configure() {
      var me = this;
      var reversePixels = me.options.ticks.reverse;
      var startPixel, endPixel;

      if (me.isHorizontal()) {
        startPixel = me.left;
        endPixel = me.right;
      } else {
        startPixel = me.top;
        endPixel = me.bottom; // by default vertical scales are from bottom to top, so pixels are reversed

        reversePixels = !reversePixels;
      }

      me._startPixel = startPixel;
      me._endPixel = endPixel;
      me._reversePixels = reversePixels;
      me._length = endPixel - startPixel;
    },
    afterUpdate: function afterUpdate() {
      helpers$1.callback(this.options.afterUpdate, [this]);
    },
    //
    beforeSetDimensions: function beforeSetDimensions() {
      helpers$1.callback(this.options.beforeSetDimensions, [this]);
    },
    setDimensions: function setDimensions() {
      var me = this; // Set the unconstrained dimension before label rotation

      if (me.isHorizontal()) {
        // Reset position before calculating rotation
        me.width = me.maxWidth;
        me.left = 0;
        me.right = me.width;
      } else {
        me.height = me.maxHeight; // Reset position before calculating rotation

        me.top = 0;
        me.bottom = me.height;
      } // Reset padding


      me.paddingLeft = 0;
      me.paddingTop = 0;
      me.paddingRight = 0;
      me.paddingBottom = 0;
    },
    afterSetDimensions: function afterSetDimensions() {
      helpers$1.callback(this.options.afterSetDimensions, [this]);
    },
    // Data limits
    beforeDataLimits: function beforeDataLimits() {
      helpers$1.callback(this.options.beforeDataLimits, [this]);
    },
    determineDataLimits: helpers$1.noop,
    afterDataLimits: function afterDataLimits() {
      helpers$1.callback(this.options.afterDataLimits, [this]);
    },
    //
    beforeBuildTicks: function beforeBuildTicks() {
      helpers$1.callback(this.options.beforeBuildTicks, [this]);
    },
    buildTicks: helpers$1.noop,
    afterBuildTicks: function afterBuildTicks(ticks) {
      var me = this; // ticks is empty for old axis implementations here

      if (isArray(ticks) && ticks.length) {
        return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
      } // Support old implementations (that modified `this.ticks` directly in buildTicks)


      me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
      return ticks;
    },
    beforeTickToLabelConversion: function beforeTickToLabelConversion() {
      helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
    },
    convertTicksToLabels: function convertTicksToLabels() {
      var me = this; // Convert ticks to strings

      var tickOpts = me.options.ticks;
      me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
    },
    afterTickToLabelConversion: function afterTickToLabelConversion() {
      helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
    },
    //
    beforeCalculateTickRotation: function beforeCalculateTickRotation() {
      helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
    },
    calculateTickRotation: function calculateTickRotation() {
      var me = this;
      var options = me.options;
      var tickOpts = options.ticks;
      var numTicks = me.getTicks().length;
      var minRotation = tickOpts.minRotation || 0;
      var maxRotation = tickOpts.maxRotation;
      var labelRotation = minRotation;
      var labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;

      if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {
        me.labelRotation = minRotation;
        return;
      }

      labelSizes = me._getLabelSizes();
      maxLabelWidth = labelSizes.widest.width;
      maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset; // Estimate the width of each grid based on the canvas width, the maximum
      // label width and the number of tick intervals

      maxWidth = Math.min(me.maxWidth, me.chart.width - maxLabelWidth);
      tickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1); // Allow 3 pixels x2 padding either side for label readability

      if (maxLabelWidth + 6 > tickWidth) {
        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
        maxHeight = me.maxHeight - getTickMarkLength(options.gridLines) - tickOpts.padding - getScaleLabelHeight(options.scaleLabel);
        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
        labelRotation = helpers$1.toDegrees(Math.min(Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)), Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)));
        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
      }

      me.labelRotation = labelRotation;
    },
    afterCalculateTickRotation: function afterCalculateTickRotation() {
      helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
    },
    //
    beforeFit: function beforeFit() {
      helpers$1.callback(this.options.beforeFit, [this]);
    },
    fit: function fit() {
      var me = this; // Reset

      var minSize = me.minSize = {
        width: 0,
        height: 0
      };
      var chart = me.chart;
      var opts = me.options;
      var tickOpts = opts.ticks;
      var scaleLabelOpts = opts.scaleLabel;
      var gridLineOpts = opts.gridLines;

      var display = me._isVisible();

      var isBottom = opts.position === 'bottom';
      var isHorizontal = me.isHorizontal(); // Width

      if (isHorizontal) {
        minSize.width = me.maxWidth;
      } else if (display) {
        minSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
      } // height


      if (!isHorizontal) {
        minSize.height = me.maxHeight; // fill all the height
      } else if (display) {
        minSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
      } // Don't bother fitting the ticks if we are not showing the labels


      if (tickOpts.display && display) {
        var tickFonts = parseTickFontOptions(tickOpts);

        var labelSizes = me._getLabelSizes();

        var firstLabelSize = labelSizes.first;
        var lastLabelSize = labelSizes.last;
        var widestLabelSize = labelSizes.widest;
        var highestLabelSize = labelSizes.highest;
        var lineSpace = tickFonts.minor.lineHeight * 0.4;
        var tickPadding = tickOpts.padding;

        if (isHorizontal) {
          // A horizontal axis is more constrained by the height.
          var isRotated = me.labelRotation !== 0;
          var angleRadians = helpers$1.toRadians(me.labelRotation);
          var cosRotation = Math.cos(angleRadians);
          var sinRotation = Math.sin(angleRadians);
          var labelHeight = sinRotation * widestLabelSize.width + cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0)) + (isRotated ? 0 : lineSpace); // padding

          minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);
          var offsetLeft = me.getPixelForTick(0) - me.left;
          var offsetRight = me.right - me.getPixelForTick(me.getTicks().length - 1);
          var paddingLeft, paddingRight; // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
          // which means that the right padding is dominated by the font height

          if (isRotated) {
            paddingLeft = isBottom ? cosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset : sinRotation * (firstLabelSize.height - firstLabelSize.offset);
            paddingRight = isBottom ? sinRotation * (lastLabelSize.height - lastLabelSize.offset) : cosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;
          } else {
            paddingLeft = firstLabelSize.width / 2;
            paddingRight = lastLabelSize.width / 2;
          } // Adjust padding taking into account changes in offsets
          // and add 3 px to move away from canvas edges


          me.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width / (me.width - offsetLeft), 0) + 3;
          me.paddingRight = Math.max((paddingRight - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;
        } else {
          // A vertical axis is more constrained by the width. Labels are the
          // dominant factor here, so get that length first and account for padding
          var labelWidth = tickOpts.mirror ? 0 : // use lineSpace for consistency with horizontal axis
          // tickPadding is not implemented for horizontal
          widestLabelSize.width + tickPadding + lineSpace;
          minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth);
          me.paddingTop = firstLabelSize.height / 2;
          me.paddingBottom = lastLabelSize.height / 2;
        }
      }

      me.handleMargins();

      if (isHorizontal) {
        me.width = me._length = chart.width - me.margins.left - me.margins.right;
        me.height = minSize.height;
      } else {
        me.width = minSize.width;
        me.height = me._length = chart.height - me.margins.top - me.margins.bottom;
      }
    },

    /**
     * Handle margins and padding interactions
     * @private
     */
    handleMargins: function handleMargins() {
      var me = this;

      if (me.margins) {
        me.margins.left = Math.max(me.paddingLeft, me.margins.left);
        me.margins.top = Math.max(me.paddingTop, me.margins.top);
        me.margins.right = Math.max(me.paddingRight, me.margins.right);
        me.margins.bottom = Math.max(me.paddingBottom, me.margins.bottom);
      }
    },
    afterFit: function afterFit() {
      helpers$1.callback(this.options.afterFit, [this]);
    },
    // Shared Methods
    isHorizontal: function isHorizontal() {
      var pos = this.options.position;
      return pos === 'top' || pos === 'bottom';
    },
    isFullWidth: function isFullWidth() {
      return this.options.fullWidth;
    },
    // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
    getRightValue: function getRightValue(rawValue) {
      // Null and undefined values first
      if (isNullOrUndef(rawValue)) {
        return NaN;
      } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values


      if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {
        return NaN;
      } // If it is in fact an object, dive in one more level


      if (rawValue) {
        if (this.isHorizontal()) {
          if (rawValue.x !== undefined) {
            return this.getRightValue(rawValue.x);
          }
        } else if (rawValue.y !== undefined) {
          return this.getRightValue(rawValue.y);
        }
      } // Value is good, return it


      return rawValue;
    },
    _convertTicksToLabels: function _convertTicksToLabels(ticks) {
      var me = this;
      var labels, i, ilen;
      me.ticks = ticks.map(function (tick) {
        return tick.value;
      });
      me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD
      // COMPAT, we still support no return (`this.ticks` internally changed by calling
      // this method and supposed to contain only string values).

      labels = me.convertTicksToLabels(ticks) || me.ticks;
      me.afterTickToLabelConversion(); // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        ticks[i].label = labels[i];
      }

      return labels;
    },

    /**
     * @private
     */
    _getLabelSizes: function _getLabelSizes() {
      var me = this;
      var labelSizes = me._labelSizes;

      if (!labelSizes) {
        me._labelSizes = labelSizes = computeLabelSizes(me.ctx, parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);
        me.longestLabelWidth = labelSizes.widest.width;
      }

      return labelSizes;
    },

    /**
     * @private
     */
    _parseValue: function _parseValue(value) {
      var start, end, min, max;

      if (isArray(value)) {
        start = +this.getRightValue(value[0]);
        end = +this.getRightValue(value[1]);
        min = Math.min(start, end);
        max = Math.max(start, end);
      } else {
        value = +this.getRightValue(value);
        start = undefined;
        end = value;
        min = value;
        max = value;
      }

      return {
        min: min,
        max: max,
        start: start,
        end: end
      };
    },

    /**
    * @private
    */
    _getScaleLabel: function _getScaleLabel(rawValue) {
      var v = this._parseValue(rawValue);

      if (v.start !== undefined) {
        return '[' + v.start + ', ' + v.end + ']';
      }

      return +this.getRightValue(rawValue);
    },

    /**
     * Used to get the value to display in the tooltip for the data at the given index
     * @param index
     * @param datasetIndex
     */
    getLabelForIndex: helpers$1.noop,

    /**
     * Returns the location of the given data point. Value can either be an index or a numerical value
     * The coordinate (0, 0) is at the upper-left corner of the canvas
     * @param value
     * @param index
     * @param datasetIndex
     */
    getPixelForValue: helpers$1.noop,

    /**
     * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
     * The coordinate (0, 0) is at the upper-left corner of the canvas
     * @param pixel
     */
    getValueForPixel: helpers$1.noop,

    /**
     * Returns the location of the tick at the given index
     * The coordinate (0, 0) is at the upper-left corner of the canvas
     */
    getPixelForTick: function getPixelForTick(index) {
      var me = this;
      var offset = me.options.offset;
      var numTicks = me._ticks.length;
      var tickWidth = 1 / Math.max(numTicks - (offset ? 0 : 1), 1);
      return index < 0 || index > numTicks - 1 ? null : me.getPixelForDecimal(index * tickWidth + (offset ? tickWidth / 2 : 0));
    },

    /**
     * Utility for getting the pixel location of a percentage of scale
     * The coordinate (0, 0) is at the upper-left corner of the canvas
     */
    getPixelForDecimal: function getPixelForDecimal(decimal) {
      var me = this;

      if (me._reversePixels) {
        decimal = 1 - decimal;
      }

      return me._startPixel + decimal * me._length;
    },
    getDecimalForPixel: function getDecimalForPixel(pixel) {
      var decimal = (pixel - this._startPixel) / this._length;
      return this._reversePixels ? 1 - decimal : decimal;
    },

    /**
     * Returns the pixel for the minimum chart value
     * The coordinate (0, 0) is at the upper-left corner of the canvas
     */
    getBasePixel: function getBasePixel() {
      return this.getPixelForValue(this.getBaseValue());
    },
    getBaseValue: function getBaseValue() {
      var me = this;
      var min = me.min;
      var max = me.max;
      return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
    },

    /**
     * Returns a subset of ticks to be plotted to avoid overlapping labels.
     * @private
     */
    _autoSkip: function _autoSkip(ticks) {
      var me = this;
      var tickOpts = me.options.ticks;
      var axisLength = me._length;
      var ticksLimit = tickOpts.maxTicksLimit || axisLength / me._tickSize() + 1;
      var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
      var numMajorIndices = majorIndices.length;
      var first = majorIndices[0];
      var last = majorIndices[numMajorIndices - 1];
      var i, ilen, spacing, avgMajorSpacing; // If there are too many major ticks to display them all

      if (numMajorIndices > ticksLimit) {
        skipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);
        return nonSkipped(ticks);
      }

      spacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);

      if (numMajorIndices > 0) {
        for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
          skip(ticks, spacing, majorIndices[i], majorIndices[i + 1]);
        }

        avgMajorSpacing = numMajorIndices > 1 ? (last - first) / (numMajorIndices - 1) : null;
        skip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
        skip(ticks, spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
        return nonSkipped(ticks);
      }

      skip(ticks, spacing);
      return nonSkipped(ticks);
    },

    /**
     * @private
     */
    _tickSize: function _tickSize() {
      var me = this;
      var optionTicks = me.options.ticks; // Calculate space needed by label in axis direction.

      var rot = helpers$1.toRadians(me.labelRotation);
      var cos = Math.abs(Math.cos(rot));
      var sin = Math.abs(Math.sin(rot));

      var labelSizes = me._getLabelSizes();

      var padding = optionTicks.autoSkipPadding || 0;
      var w = labelSizes ? labelSizes.widest.width + padding : 0;
      var h = labelSizes ? labelSizes.highest.height + padding : 0; // Calculate space needed for 1 tick in axis direction.

      return me.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
    },

    /**
     * @private
     */
    _isVisible: function _isVisible() {
      var me = this;
      var chart = me.chart;
      var display = me.options.display;
      var i, ilen, meta;

      if (display !== 'auto') {
        return !!display;
      } // When 'auto', the scale is visible if at least one associated dataset is visible.


      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          meta = chart.getDatasetMeta(i);

          if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
            return true;
          }
        }
      }

      return false;
    },

    /**
     * @private
     */
    _computeGridLineItems: function _computeGridLineItems(chartArea) {
      var me = this;
      var chart = me.chart;
      var options = me.options;
      var gridLines = options.gridLines;
      var position = options.position;
      var offsetGridLines = gridLines.offsetGridLines;
      var isHorizontal = me.isHorizontal();
      var ticks = me._ticksToDraw;
      var ticksLength = ticks.length + (offsetGridLines ? 1 : 0);
      var tl = getTickMarkLength(gridLines);
      var items = [];
      var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
      var axisHalfWidth = axisWidth / 2;
      var alignPixel = helpers$1._alignPixel;

      var alignBorderValue = function alignBorderValue(pixel) {
        return alignPixel(chart, pixel, axisWidth);
      };

      var borderValue, i, tick, lineValue, alignedLineValue;
      var tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;

      if (position === 'top') {
        borderValue = alignBorderValue(me.bottom);
        ty1 = me.bottom - tl;
        ty2 = borderValue - axisHalfWidth;
        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
        y2 = chartArea.bottom;
      } else if (position === 'bottom') {
        borderValue = alignBorderValue(me.top);
        y1 = chartArea.top;
        y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
        ty1 = borderValue + axisHalfWidth;
        ty2 = me.top + tl;
      } else if (position === 'left') {
        borderValue = alignBorderValue(me.right);
        tx1 = me.right - tl;
        tx2 = borderValue - axisHalfWidth;
        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
        x2 = chartArea.right;
      } else {
        borderValue = alignBorderValue(me.left);
        x1 = chartArea.left;
        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
        tx1 = borderValue + axisHalfWidth;
        tx2 = me.left + tl;
      }

      for (i = 0; i < ticksLength; ++i) {
        tick = ticks[i] || {}; // autoskipper skipped this tick (#4635)

        if (isNullOrUndef(tick.label) && i < ticks.length) {
          continue;
        }

        if (i === me.zeroLineIndex && options.offset === offsetGridLines) {
          // Draw the first index specially
          lineWidth = gridLines.zeroLineWidth;
          lineColor = gridLines.zeroLineColor;
          borderDash = gridLines.zeroLineBorderDash || [];
          borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;
        } else {
          lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);
          lineColor = valueAtIndexOrDefault(gridLines.color, i, 'rgba(0,0,0,0.1)');
          borderDash = gridLines.borderDash || [];
          borderDashOffset = gridLines.borderDashOffset || 0.0;
        }

        lineValue = getPixelForGridLine(me, tick._index || i, offsetGridLines); // Skip if the pixel is out of the range

        if (lineValue === undefined) {
          continue;
        }

        alignedLineValue = alignPixel(chart, lineValue, lineWidth);

        if (isHorizontal) {
          tx1 = tx2 = x1 = x2 = alignedLineValue;
        } else {
          ty1 = ty2 = y1 = y2 = alignedLineValue;
        }

        items.push({
          tx1: tx1,
          ty1: ty1,
          tx2: tx2,
          ty2: ty2,
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          width: lineWidth,
          color: lineColor,
          borderDash: borderDash,
          borderDashOffset: borderDashOffset
        });
      }

      items.ticksLength = ticksLength;
      items.borderValue = borderValue;
      return items;
    },

    /**
     * @private
     */
    _computeLabelItems: function _computeLabelItems() {
      var me = this;
      var options = me.options;
      var optionTicks = options.ticks;
      var position = options.position;
      var isMirrored = optionTicks.mirror;
      var isHorizontal = me.isHorizontal();
      var ticks = me._ticksToDraw;
      var fonts = parseTickFontOptions(optionTicks);
      var tickPadding = optionTicks.padding;
      var tl = getTickMarkLength(options.gridLines);
      var rotation = -helpers$1.toRadians(me.labelRotation);
      var items = [];
      var i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;

      if (position === 'top') {
        y = me.bottom - tl - tickPadding;
        textAlign = !rotation ? 'center' : 'left';
      } else if (position === 'bottom') {
        y = me.top + tl + tickPadding;
        textAlign = !rotation ? 'center' : 'right';
      } else if (position === 'left') {
        x = me.right - (isMirrored ? 0 : tl) - tickPadding;
        textAlign = isMirrored ? 'left' : 'right';
      } else {
        x = me.left + (isMirrored ? 0 : tl) + tickPadding;
        textAlign = isMirrored ? 'right' : 'left';
      }

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        tick = ticks[i];
        label = tick.label; // autoskipper skipped this tick (#4635)

        if (isNullOrUndef(label)) {
          continue;
        }

        pixel = me.getPixelForTick(tick._index || i) + optionTicks.labelOffset;
        font = tick.major ? fonts.major : fonts.minor;
        lineHeight = font.lineHeight;
        lineCount = isArray(label) ? label.length : 1;

        if (isHorizontal) {
          x = pixel;
          textOffset = position === 'top' ? ((!rotation ? 0.5 : 1) - lineCount) * lineHeight : (!rotation ? 0.5 : 0) * lineHeight;
        } else {
          y = pixel;
          textOffset = (1 - lineCount) * lineHeight / 2;
        }

        items.push({
          x: x,
          y: y,
          rotation: rotation,
          label: label,
          font: font,
          textOffset: textOffset,
          textAlign: textAlign
        });
      }

      return items;
    },

    /**
     * @private
     */
    _drawGrid: function _drawGrid(chartArea) {
      var me = this;
      var gridLines = me.options.gridLines;

      if (!gridLines.display) {
        return;
      }

      var ctx = me.ctx;
      var chart = me.chart;
      var alignPixel = helpers$1._alignPixel;
      var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;

      var items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));

      var width, color, i, ilen, item;

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];
        width = item.width;
        color = item.color;

        if (width && color) {
          ctx.save();
          ctx.lineWidth = width;
          ctx.strokeStyle = color;

          if (ctx.setLineDash) {
            ctx.setLineDash(item.borderDash);
            ctx.lineDashOffset = item.borderDashOffset;
          }

          ctx.beginPath();

          if (gridLines.drawTicks) {
            ctx.moveTo(item.tx1, item.ty1);
            ctx.lineTo(item.tx2, item.ty2);
          }

          if (gridLines.drawOnChartArea) {
            ctx.moveTo(item.x1, item.y1);
            ctx.lineTo(item.x2, item.y2);
          }

          ctx.stroke();
          ctx.restore();
        }
      }

      if (axisWidth) {
        // Draw the line at the edge of the axis
        var firstLineWidth = axisWidth;
        var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items.ticksLength - 1, 1);
        var borderValue = items.borderValue;
        var x1, x2, y1, y2;

        if (me.isHorizontal()) {
          x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
          x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
          y1 = y2 = borderValue;
        } else {
          y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
          y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
          x1 = x2 = borderValue;
        }

        ctx.lineWidth = axisWidth;
        ctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
    },

    /**
     * @private
     */
    _drawLabels: function _drawLabels() {
      var me = this;
      var optionTicks = me.options.ticks;

      if (!optionTicks.display) {
        return;
      }

      var ctx = me.ctx;

      var items = me._labelItems || (me._labelItems = me._computeLabelItems());

      var i, j, ilen, jlen, item, tickFont, label, y;

      for (i = 0, ilen = items.length; i < ilen; ++i) {
        item = items[i];
        tickFont = item.font; // Make sure we draw text in the correct color and font

        ctx.save();
        ctx.translate(item.x, item.y);
        ctx.rotate(item.rotation);
        ctx.font = tickFont.string;
        ctx.fillStyle = tickFont.color;
        ctx.textBaseline = 'middle';
        ctx.textAlign = item.textAlign;
        label = item.label;
        y = item.textOffset;

        if (isArray(label)) {
          for (j = 0, jlen = label.length; j < jlen; ++j) {
            // We just make sure the multiline element is a string here..
            ctx.fillText('' + label[j], 0, y);
            y += tickFont.lineHeight;
          }
        } else {
          ctx.fillText(label, 0, y);
        }

        ctx.restore();
      }
    },

    /**
     * @private
     */
    _drawTitle: function _drawTitle() {
      var me = this;
      var ctx = me.ctx;
      var options = me.options;
      var scaleLabel = options.scaleLabel;

      if (!scaleLabel.display) {
        return;
      }

      var scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);

      var scaleLabelFont = helpers$1.options._parseFont(scaleLabel);

      var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
      var halfLineHeight = scaleLabelFont.lineHeight / 2;
      var position = options.position;
      var rotation = 0;
      var scaleLabelX, scaleLabelY;

      if (me.isHorizontal()) {
        scaleLabelX = me.left + me.width / 2; // midpoint of the width

        scaleLabelY = position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;
      } else {
        var isLeft = position === 'left';
        scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;
        scaleLabelY = me.top + me.height / 2;
        rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
      }

      ctx.save();
      ctx.translate(scaleLabelX, scaleLabelY);
      ctx.rotate(rotation);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = scaleLabelFontColor; // render in correct colour

      ctx.font = scaleLabelFont.string;
      ctx.fillText(scaleLabel.labelString, 0, 0);
      ctx.restore();
    },
    draw: function draw(chartArea) {
      var me = this;

      if (!me._isVisible()) {
        return;
      }

      me._drawGrid(chartArea);

      me._drawTitle();

      me._drawLabels();
    },

    /**
     * @private
     */
    _layers: function _layers() {
      var me = this;
      var opts = me.options;
      var tz = opts.ticks && opts.ticks.z || 0;
      var gz = opts.gridLines && opts.gridLines.z || 0;

      if (!me._isVisible() || tz === gz || me.draw !== me._draw) {
        // backward compatibility: draw has been overridden by custom scale
        return [{
          z: tz,
          draw: function draw() {
            me.draw.apply(me, arguments);
          }
        }];
      }

      return [{
        z: gz,
        draw: function draw() {
          me._drawGrid.apply(me, arguments);

          me._drawTitle.apply(me, arguments);
        }
      }, {
        z: tz,
        draw: function draw() {
          me._drawLabels.apply(me, arguments);
        }
      }];
    },

    /**
     * @private
     */
    _getMatchingVisibleMetas: function _getMatchingVisibleMetas(type) {
      var me = this;
      var isHorizontal = me.isHorizontal();
      return me.chart._getSortedVisibleDatasetMetas().filter(function (meta) {
        return (!type || meta.type === type) && (isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id);
      });
    }
  });
  Scale.prototype._draw = Scale.prototype.draw;
  var core_scale = Scale;
  var isNullOrUndef$1 = helpers$1.isNullOrUndef;
  var defaultConfig = {
    position: 'bottom'
  };
  var scale_category = core_scale.extend({
    determineDataLimits: function determineDataLimits() {
      var me = this;

      var labels = me._getLabels();

      var ticksOpts = me.options.ticks;
      var min = ticksOpts.min;
      var max = ticksOpts.max;
      var minIndex = 0;
      var maxIndex = labels.length - 1;
      var findIndex;

      if (min !== undefined) {
        // user specified min value
        findIndex = labels.indexOf(min);

        if (findIndex >= 0) {
          minIndex = findIndex;
        }
      }

      if (max !== undefined) {
        // user specified max value
        findIndex = labels.indexOf(max);

        if (findIndex >= 0) {
          maxIndex = findIndex;
        }
      }

      me.minIndex = minIndex;
      me.maxIndex = maxIndex;
      me.min = labels[minIndex];
      me.max = labels[maxIndex];
    },
    buildTicks: function buildTicks() {
      var me = this;

      var labels = me._getLabels();

      var minIndex = me.minIndex;
      var maxIndex = me.maxIndex; // If we are viewing some subset of labels, slice the original array

      me.ticks = minIndex === 0 && maxIndex === labels.length - 1 ? labels : labels.slice(minIndex, maxIndex + 1);
    },
    getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
      var me = this;
      var chart = me.chart;

      if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
        return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
      }

      return me._getLabels()[index];
    },
    _configure: function _configure() {
      var me = this;
      var offset = me.options.offset;
      var ticks = me.ticks;

      core_scale.prototype._configure.call(me);

      if (!me.isHorizontal()) {
        // For backward compatibility, vertical category scale reverse is inverted.
        me._reversePixels = !me._reversePixels;
      }

      if (!ticks) {
        return;
      }

      me._startValue = me.minIndex - (offset ? 0.5 : 0);
      me._valueRange = Math.max(ticks.length - (offset ? 0 : 1), 1);
    },
    // Used to get data value locations.  Value can either be an index or a numerical value
    getPixelForValue: function getPixelForValue(value, index, datasetIndex) {
      var me = this;
      var valueCategory, labels, idx;

      if (!isNullOrUndef$1(index) && !isNullOrUndef$1(datasetIndex)) {
        value = me.chart.data.datasets[datasetIndex].data[index];
      } // If value is a data object, then index is the index in the data array,
      // not the index of the scale. We need to change that.


      if (!isNullOrUndef$1(value)) {
        valueCategory = me.isHorizontal() ? value.x : value.y;
      }

      if (valueCategory !== undefined || value !== undefined && isNaN(index)) {
        labels = me._getLabels();
        value = helpers$1.valueOrDefault(valueCategory, value);
        idx = labels.indexOf(value);
        index = idx !== -1 ? idx : index;

        if (isNaN(index)) {
          index = value;
        }
      }

      return me.getPixelForDecimal((index - me._startValue) / me._valueRange);
    },
    getPixelForTick: function getPixelForTick(index) {
      var ticks = this.ticks;
      return index < 0 || index > ticks.length - 1 ? null : this.getPixelForValue(ticks[index], index + this.minIndex);
    },
    getValueForPixel: function getValueForPixel(pixel) {
      var me = this;
      var value = Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);
      return Math.min(Math.max(value, 0), me.ticks.length - 1);
    },
    getBasePixel: function getBasePixel() {
      return this.bottom;
    }
  }); // INTERNAL: static default options, registered in src/index.js

  var _defaults = defaultConfig;
  scale_category._defaults = _defaults;
  var noop = helpers$1.noop;
  var isNullOrUndef$2 = helpers$1.isNullOrUndef;
  /**
   * Generate a set of linear ticks
   * @param generationOptions the options used to generate the ticks
   * @param dataRange the range of the data
   * @returns {number[]} array of tick values
   */

  function generateTicks(generationOptions, dataRange) {
    var ticks = []; // To get a "nice" value for the tick spacing, we will use the appropriately named
    // "nice number" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
    // for details.

    var MIN_SPACING = 1e-14;
    var stepSize = generationOptions.stepSize;
    var unit = stepSize || 1;
    var maxNumSpaces = generationOptions.maxTicks - 1;
    var min = generationOptions.min;
    var max = generationOptions.max;
    var precision = generationOptions.precision;
    var rmin = dataRange.min;
    var rmax = dataRange.max;
    var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
    var factor, niceMin, niceMax, numSpaces; // Beyond MIN_SPACING floating point numbers being to lose precision
    // such that we can't do the math necessary to generate ticks

    if (spacing < MIN_SPACING && isNullOrUndef$2(min) && isNullOrUndef$2(max)) {
      return [rmin, rmax];
    }

    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);

    if (numSpaces > maxNumSpaces) {
      // If the calculated num of spaces exceeds maxNumSpaces, recalculate it
      spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
    }

    if (stepSize || isNullOrUndef$2(precision)) {
      // If a precision is not specified, calculate factor based on spacing
      factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
    } else {
      // If the user specified a precision, round to that number of decimal places
      factor = Math.pow(10, precision);
      spacing = Math.ceil(spacing * factor) / factor;
    }

    niceMin = Math.floor(rmin / spacing) * spacing;
    niceMax = Math.ceil(rmax / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.

    if (stepSize) {
      // If very close to our whole number, use it.
      if (!isNullOrUndef$2(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {
        niceMin = min;
      }

      if (!isNullOrUndef$2(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {
        niceMax = max;
      }
    }

    numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.

    if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
      numSpaces = Math.round(numSpaces);
    } else {
      numSpaces = Math.ceil(numSpaces);
    }

    niceMin = Math.round(niceMin * factor) / factor;
    niceMax = Math.round(niceMax * factor) / factor;
    ticks.push(isNullOrUndef$2(min) ? niceMin : min);

    for (var j = 1; j < numSpaces; ++j) {
      ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
    }

    ticks.push(isNullOrUndef$2(max) ? niceMax : max);
    return ticks;
  }

  var scale_linearbase = core_scale.extend({
    getRightValue: function getRightValue(value) {
      if (typeof value === 'string') {
        return +value;
      }

      return core_scale.prototype.getRightValue.call(this, value);
    },
    handleTickRangeOptions: function handleTickRangeOptions() {
      var me = this;
      var opts = me.options;
      var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
      // do nothing since that would make the chart weird. If the user really wants a weird chart
      // axis, they can manually override it

      if (tickOpts.beginAtZero) {
        var minSign = helpers$1.sign(me.min);
        var maxSign = helpers$1.sign(me.max);

        if (minSign < 0 && maxSign < 0) {
          // move the top up to 0
          me.max = 0;
        } else if (minSign > 0 && maxSign > 0) {
          // move the bottom down to 0
          me.min = 0;
        }
      }

      var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
      var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

      if (tickOpts.min !== undefined) {
        me.min = tickOpts.min;
      } else if (tickOpts.suggestedMin !== undefined) {
        if (me.min === null) {
          me.min = tickOpts.suggestedMin;
        } else {
          me.min = Math.min(me.min, tickOpts.suggestedMin);
        }
      }

      if (tickOpts.max !== undefined) {
        me.max = tickOpts.max;
      } else if (tickOpts.suggestedMax !== undefined) {
        if (me.max === null) {
          me.max = tickOpts.suggestedMax;
        } else {
          me.max = Math.max(me.max, tickOpts.suggestedMax);
        }
      }

      if (setMin !== setMax) {
        // We set the min or the max but not both.
        // So ensure that our range is good
        // Inverted or 0 length range can happen when
        // ticks.min is set, and no datasets are visible
        if (me.min >= me.max) {
          if (setMin) {
            me.max = me.min + 1;
          } else {
            me.min = me.max - 1;
          }
        }
      }

      if (me.min === me.max) {
        me.max++;

        if (!tickOpts.beginAtZero) {
          me.min--;
        }
      }
    },
    getTickLimit: function getTickLimit() {
      var me = this;
      var tickOpts = me.options.ticks;
      var stepSize = tickOpts.stepSize;
      var maxTicksLimit = tickOpts.maxTicksLimit;
      var maxTicks;

      if (stepSize) {
        maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
      } else {
        maxTicks = me._computeTickLimit();
        maxTicksLimit = maxTicksLimit || 11;
      }

      if (maxTicksLimit) {
        maxTicks = Math.min(maxTicksLimit, maxTicks);
      }

      return maxTicks;
    },
    _computeTickLimit: function _computeTickLimit() {
      return Number.POSITIVE_INFINITY;
    },
    handleDirectionalChanges: noop,
    buildTicks: function buildTicks() {
      var me = this;
      var opts = me.options;
      var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of
      // the axis area. For now, we say that the minimum tick spacing in pixels must be 40
      // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
      // the graph. Make sure we always have at least 2 ticks

      var maxTicks = me.getTickLimit();
      maxTicks = Math.max(2, maxTicks);
      var numericGeneratorOptions = {
        maxTicks: maxTicks,
        min: tickOpts.min,
        max: tickOpts.max,
        precision: tickOpts.precision,
        stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
      };
      var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);
      me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the
      // range of the scale

      me.max = helpers$1.max(ticks);
      me.min = helpers$1.min(ticks);

      if (tickOpts.reverse) {
        ticks.reverse();
        me.start = me.max;
        me.end = me.min;
      } else {
        me.start = me.min;
        me.end = me.max;
      }
    },
    convertTicksToLabels: function convertTicksToLabels() {
      var me = this;
      me.ticksAsNumbers = me.ticks.slice();
      me.zeroLineIndex = me.ticks.indexOf(0);
      core_scale.prototype.convertTicksToLabels.call(me);
    },
    _configure: function _configure() {
      var me = this;
      var ticks = me.getTicks();
      var start = me.min;
      var end = me.max;
      var offset;

      core_scale.prototype._configure.call(me);

      if (me.options.offset && ticks.length) {
        offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
        start -= offset;
        end += offset;
      }

      me._startValue = start;
      me._endValue = end;
      me._valueRange = end - start;
    }
  });
  var defaultConfig$1 = {
    position: 'left',
    ticks: {
      callback: core_ticks.formatters.linear
    }
  };
  var DEFAULT_MIN = 0;
  var DEFAULT_MAX = 1;

  function getOrCreateStack(stacks, stacked, meta) {
    var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
    stacked === undefined && meta.stack === undefined ? meta.index : '', meta.stack].join('.');

    if (stacks[key] === undefined) {
      stacks[key] = {
        pos: [],
        neg: []
      };
    }

    return stacks[key];
  }

  function stackData(scale, stacks, meta, data) {
    var opts = scale.options;
    var stacked = opts.stacked;
    var stack = getOrCreateStack(stacks, stacked, meta);
    var pos = stack.pos;
    var neg = stack.neg;
    var ilen = data.length;
    var i, value;

    for (i = 0; i < ilen; ++i) {
      value = scale._parseValue(data[i]);

      if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
        continue;
      }

      pos[i] = pos[i] || 0;
      neg[i] = neg[i] || 0;

      if (opts.relativePoints) {
        pos[i] = 100;
      } else if (value.min < 0 || value.max < 0) {
        neg[i] += value.min;
      } else {
        pos[i] += value.max;
      }
    }
  }

  function updateMinMax(scale, meta, data) {
    var ilen = data.length;
    var i, value;

    for (i = 0; i < ilen; ++i) {
      value = scale._parseValue(data[i]);

      if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
        continue;
      }

      scale.min = Math.min(scale.min, value.min);
      scale.max = Math.max(scale.max, value.max);
    }
  }

  var scale_linear = scale_linearbase.extend({
    determineDataLimits: function determineDataLimits() {
      var me = this;
      var opts = me.options;
      var chart = me.chart;
      var datasets = chart.data.datasets;

      var metasets = me._getMatchingVisibleMetas();

      var hasStacks = opts.stacked;
      var stacks = {};
      var ilen = metasets.length;
      var i, meta, data, values;
      me.min = Number.POSITIVE_INFINITY;
      me.max = Number.NEGATIVE_INFINITY;

      if (hasStacks === undefined) {
        for (i = 0; !hasStacks && i < ilen; ++i) {
          meta = metasets[i];
          hasStacks = meta.stack !== undefined;
        }
      }

      for (i = 0; i < ilen; ++i) {
        meta = metasets[i];
        data = datasets[meta.index].data;

        if (hasStacks) {
          stackData(me, stacks, meta, data);
        } else {
          updateMinMax(me, meta, data);
        }
      }

      helpers$1.each(stacks, function (stackValues) {
        values = stackValues.pos.concat(stackValues.neg);
        me.min = Math.min(me.min, helpers$1.min(values));
        me.max = Math.max(me.max, helpers$1.max(values));
      });
      me.min = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
      me.max = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

      me.handleTickRangeOptions();
    },
    // Returns the maximum number of ticks based on the scale dimension
    _computeTickLimit: function _computeTickLimit() {
      var me = this;
      var tickFont;

      if (me.isHorizontal()) {
        return Math.ceil(me.width / 40);
      }

      tickFont = helpers$1.options._parseFont(me.options.ticks);
      return Math.ceil(me.height / tickFont.lineHeight);
    },
    // Called after the ticks are built. We need
    handleDirectionalChanges: function handleDirectionalChanges() {
      if (!this.isHorizontal()) {
        // We are in a vertical orientation. The top value is the highest. So reverse the array
        this.ticks.reverse();
      }
    },
    getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
      return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
    },
    // Utils
    getPixelForValue: function getPixelForValue(value) {
      var me = this;
      return me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);
    },
    getValueForPixel: function getValueForPixel(pixel) {
      return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
    },
    getPixelForTick: function getPixelForTick(index) {
      var ticks = this.ticksAsNumbers;

      if (index < 0 || index > ticks.length - 1) {
        return null;
      }

      return this.getPixelForValue(ticks[index]);
    }
  }); // INTERNAL: static default options, registered in src/index.js

  var _defaults$1 = defaultConfig$1;
  scale_linear._defaults = _defaults$1;
  var valueOrDefault$b = helpers$1.valueOrDefault;
  var log10 = helpers$1.math.log10;
  /**
   * Generate a set of logarithmic ticks
   * @param generationOptions the options used to generate the ticks
   * @param dataRange the range of the data
   * @returns {number[]} array of tick values
   */

  function generateTicks$1(generationOptions, dataRange) {
    var ticks = [];
    var tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));
    var endExp = Math.floor(log10(dataRange.max));
    var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
    var exp, significand;

    if (tickVal === 0) {
      exp = Math.floor(log10(dataRange.minNotZero));
      significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));
      ticks.push(tickVal);
      tickVal = significand * Math.pow(10, exp);
    } else {
      exp = Math.floor(log10(tickVal));
      significand = Math.floor(tickVal / Math.pow(10, exp));
    }

    var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

    do {
      ticks.push(tickVal);
      ++significand;

      if (significand === 10) {
        significand = 1;
        ++exp;
        precision = exp >= 0 ? 1 : precision;
      }

      tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
    } while (exp < endExp || exp === endExp && significand < endSignificand);

    var lastTick = valueOrDefault$b(generationOptions.max, tickVal);
    ticks.push(lastTick);
    return ticks;
  }

  var defaultConfig$2 = {
    position: 'left',
    // label settings
    ticks: {
      callback: core_ticks.formatters.logarithmic
    }
  }; // TODO(v3): change this to positiveOrDefault

  function nonNegativeOrDefault(value, defaultValue) {
    return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
  }

  var scale_logarithmic = core_scale.extend({
    determineDataLimits: function determineDataLimits() {
      var me = this;
      var opts = me.options;
      var chart = me.chart;
      var datasets = chart.data.datasets;
      var isHorizontal = me.isHorizontal();

      function IDMatches(meta) {
        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
      }

      var datasetIndex, meta, value, data, i, ilen; // Calculate Range

      me.min = Number.POSITIVE_INFINITY;
      me.max = Number.NEGATIVE_INFINITY;
      me.minNotZero = Number.POSITIVE_INFINITY;
      var hasStacks = opts.stacked;

      if (hasStacks === undefined) {
        for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
          meta = chart.getDatasetMeta(datasetIndex);

          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) && meta.stack !== undefined) {
            hasStacks = true;
            break;
          }
        }
      }

      if (opts.stacked || hasStacks) {
        var valuesPerStack = {};

        for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
          meta = chart.getDatasetMeta(datasetIndex);
          var key = [meta.type, // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
          opts.stacked === undefined && meta.stack === undefined ? datasetIndex : '', meta.stack].join('.');

          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
            if (valuesPerStack[key] === undefined) {
              valuesPerStack[key] = [];
            }

            data = datasets[datasetIndex].data;

            for (i = 0, ilen = data.length; i < ilen; i++) {
              var values = valuesPerStack[key];
              value = me._parseValue(data[i]); // invalid, hidden and negative values are ignored

              if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                continue;
              }

              values[i] = values[i] || 0;
              values[i] += value.max;
            }
          }
        }

        helpers$1.each(valuesPerStack, function (valuesForType) {
          if (valuesForType.length > 0) {
            var minVal = helpers$1.min(valuesForType);
            var maxVal = helpers$1.max(valuesForType);
            me.min = Math.min(me.min, minVal);
            me.max = Math.max(me.max, maxVal);
          }
        });
      } else {
        for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
          meta = chart.getDatasetMeta(datasetIndex);

          if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
            data = datasets[datasetIndex].data;

            for (i = 0, ilen = data.length; i < ilen; i++) {
              value = me._parseValue(data[i]); // invalid, hidden and negative values are ignored

              if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                continue;
              }

              me.min = Math.min(value.min, me.min);
              me.max = Math.max(value.max, me.max);

              if (value.min !== 0) {
                me.minNotZero = Math.min(value.min, me.minNotZero);
              }
            }
          }
        }
      }

      me.min = helpers$1.isFinite(me.min) ? me.min : null;
      me.max = helpers$1.isFinite(me.max) ? me.max : null;
      me.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero : null; // Common base implementation to handle ticks.min, ticks.max

      this.handleTickRangeOptions();
    },
    handleTickRangeOptions: function handleTickRangeOptions() {
      var me = this;
      var tickOpts = me.options.ticks;
      var DEFAULT_MIN = 1;
      var DEFAULT_MAX = 10;
      me.min = nonNegativeOrDefault(tickOpts.min, me.min);
      me.max = nonNegativeOrDefault(tickOpts.max, me.max);

      if (me.min === me.max) {
        if (me.min !== 0 && me.min !== null) {
          me.min = Math.pow(10, Math.floor(log10(me.min)) - 1);
          me.max = Math.pow(10, Math.floor(log10(me.max)) + 1);
        } else {
          me.min = DEFAULT_MIN;
          me.max = DEFAULT_MAX;
        }
      }

      if (me.min === null) {
        me.min = Math.pow(10, Math.floor(log10(me.max)) - 1);
      }

      if (me.max === null) {
        me.max = me.min !== 0 ? Math.pow(10, Math.floor(log10(me.min)) + 1) : DEFAULT_MAX;
      }

      if (me.minNotZero === null) {
        if (me.min > 0) {
          me.minNotZero = me.min;
        } else if (me.max < 1) {
          me.minNotZero = Math.pow(10, Math.floor(log10(me.max)));
        } else {
          me.minNotZero = DEFAULT_MIN;
        }
      }
    },
    buildTicks: function buildTicks() {
      var me = this;
      var tickOpts = me.options.ticks;
      var reverse = !me.isHorizontal();
      var generationOptions = {
        min: nonNegativeOrDefault(tickOpts.min),
        max: nonNegativeOrDefault(tickOpts.max)
      };
      var ticks = me.ticks = generateTicks$1(generationOptions, me); // At this point, we need to update our max and min given the tick values since we have expanded the
      // range of the scale

      me.max = helpers$1.max(ticks);
      me.min = helpers$1.min(ticks);

      if (tickOpts.reverse) {
        reverse = !reverse;
        me.start = me.max;
        me.end = me.min;
      } else {
        me.start = me.min;
        me.end = me.max;
      }

      if (reverse) {
        ticks.reverse();
      }
    },
    convertTicksToLabels: function convertTicksToLabels() {
      this.tickValues = this.ticks.slice();
      core_scale.prototype.convertTicksToLabels.call(this);
    },
    // Get the correct tooltip label
    getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
      return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
    },
    getPixelForTick: function getPixelForTick(index) {
      var ticks = this.tickValues;

      if (index < 0 || index > ticks.length - 1) {
        return null;
      }

      return this.getPixelForValue(ticks[index]);
    },

    /**
     * Returns the value of the first tick.
     * @param {number} value - The minimum not zero value.
     * @return {number} The first tick value.
     * @private
     */
    _getFirstTickValue: function _getFirstTickValue(value) {
      var exp = Math.floor(log10(value));
      var significand = Math.floor(value / Math.pow(10, exp));
      return significand * Math.pow(10, exp);
    },
    _configure: function _configure() {
      var me = this;
      var start = me.min;
      var offset = 0;

      core_scale.prototype._configure.call(me);

      if (start === 0) {
        start = me._getFirstTickValue(me.minNotZero);
        offset = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me._length;
      }

      me._startValue = log10(start);
      me._valueOffset = offset;
      me._valueRange = (log10(me.max) - log10(start)) / (1 - offset);
    },
    getPixelForValue: function getPixelForValue(value) {
      var me = this;
      var decimal = 0;
      value = +me.getRightValue(value);

      if (value > me.min && value > 0) {
        decimal = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;
      }

      return me.getPixelForDecimal(decimal);
    },
    getValueForPixel: function getValueForPixel(pixel) {
      var me = this;
      var decimal = me.getDecimalForPixel(pixel);
      return decimal === 0 && me.min === 0 ? 0 : Math.pow(10, me._startValue + (decimal - me._valueOffset) * me._valueRange);
    }
  }); // INTERNAL: static default options, registered in src/index.js

  var _defaults$2 = defaultConfig$2;
  scale_logarithmic._defaults = _defaults$2;
  var valueOrDefault$c = helpers$1.valueOrDefault;
  var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
  var resolve$4 = helpers$1.options.resolve;
  var defaultConfig$3 = {
    display: true,
    // Boolean - Whether to animate scaling the chart from the centre
    animate: true,
    position: 'chartArea',
    angleLines: {
      display: true,
      color: 'rgba(0,0,0,0.1)',
      lineWidth: 1,
      borderDash: [],
      borderDashOffset: 0.0
    },
    gridLines: {
      circular: false
    },
    // label settings
    ticks: {
      // Boolean - Show a backdrop to the scale label
      showLabelBackdrop: true,
      // String - The colour of the label backdrop
      backdropColor: 'rgba(255,255,255,0.75)',
      // Number - The backdrop padding above & below the label in pixels
      backdropPaddingY: 2,
      // Number - The backdrop padding to the side of the label in pixels
      backdropPaddingX: 2,
      callback: core_ticks.formatters.linear
    },
    pointLabels: {
      // Boolean - if true, show point labels
      display: true,
      // Number - Point label font size in pixels
      fontSize: 10,
      // Function - Used to convert point labels
      callback: function callback(label) {
        return label;
      }
    }
  };

  function getTickBackdropHeight(opts) {
    var tickOpts = opts.ticks;

    if (tickOpts.display && opts.display) {
      return valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
    }

    return 0;
  }

  function measureLabelSize(ctx, lineHeight, label) {
    if (helpers$1.isArray(label)) {
      return {
        w: helpers$1.longestText(ctx, ctx.font, label),
        h: label.length * lineHeight
      };
    }

    return {
      w: ctx.measureText(label).width,
      h: lineHeight
    };
  }

  function determineLimits(angle, pos, size, min, max) {
    if (angle === min || angle === max) {
      return {
        start: pos - size / 2,
        end: pos + size / 2
      };
    } else if (angle < min || angle > max) {
      return {
        start: pos - size,
        end: pos
      };
    }

    return {
      start: pos,
      end: pos + size
    };
  }
  /**
   * Helper function to fit a radial linear scale with point labels
   */


  function fitWithPointLabels(scale) {
    // Right, this is really confusing and there is a lot of maths going on here
    // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
    //
    // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
    //
    // Solution:
    //
    // We assume the radius of the polygon is half the size of the canvas at first
    // at each index we check if the text overlaps.
    //
    // Where it does, we store that angle and that index.
    //
    // After finding the largest index and angle we calculate how much we need to remove
    // from the shape radius to move the point inwards by that x.
    //
    // We average the left and right distances to get the maximum shape radius that can fit in the box
    // along with labels.
    //
    // Once we have that, we can find the centre point for the chart, by taking the x text protrusion
    // on each side, removing that from the size, halving it and adding the left x protrusion width.
    //
    // This will mean we have a shape fitted to the canvas, as large as it can be with the labels
    // and position it in the most space efficient manner
    //
    // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif
    var plFont = helpers$1.options._parseFont(scale.options.pointLabels); // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
    // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points


    var furthestLimits = {
      l: 0,
      r: scale.width,
      t: 0,
      b: scale.height - scale.paddingTop
    };
    var furthestAngles = {};
    var i, textSize, pointPosition;
    scale.ctx.font = plFont.string;
    scale._pointLabelSizes = [];
    var valueCount = scale.chart.data.labels.length;

    for (i = 0; i < valueCount; i++) {
      pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
      textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i]);
      scale._pointLabelSizes[i] = textSize; // Add quarter circle to make degree 0 mean top of circle

      var angleRadians = scale.getIndexAngle(i);
      var angle = helpers$1.toDegrees(angleRadians) % 360;
      var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
      var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

      if (hLimits.start < furthestLimits.l) {
        furthestLimits.l = hLimits.start;
        furthestAngles.l = angleRadians;
      }

      if (hLimits.end > furthestLimits.r) {
        furthestLimits.r = hLimits.end;
        furthestAngles.r = angleRadians;
      }

      if (vLimits.start < furthestLimits.t) {
        furthestLimits.t = vLimits.start;
        furthestAngles.t = angleRadians;
      }

      if (vLimits.end > furthestLimits.b) {
        furthestLimits.b = vLimits.end;
        furthestAngles.b = angleRadians;
      }
    }

    scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
  }

  function getTextAlignForAngle(angle) {
    if (angle === 0 || angle === 180) {
      return 'center';
    } else if (angle < 180) {
      return 'left';
    }

    return 'right';
  }

  function fillText(ctx, text, position, lineHeight) {
    var y = position.y + lineHeight / 2;
    var i, ilen;

    if (helpers$1.isArray(text)) {
      for (i = 0, ilen = text.length; i < ilen; ++i) {
        ctx.fillText(text[i], position.x, y);
        y += lineHeight;
      }
    } else {
      ctx.fillText(text, position.x, y);
    }
  }

  function adjustPointPositionForLabelHeight(angle, textSize, position) {
    if (angle === 90 || angle === 270) {
      position.y -= textSize.h / 2;
    } else if (angle > 270 || angle < 90) {
      position.y -= textSize.h;
    }
  }

  function drawPointLabels(scale) {
    var ctx = scale.ctx;
    var opts = scale.options;
    var pointLabelOpts = opts.pointLabels;
    var tickBackdropHeight = getTickBackdropHeight(opts);
    var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);

    var plFont = helpers$1.options._parseFont(pointLabelOpts);

    ctx.save();
    ctx.font = plFont.string;
    ctx.textBaseline = 'middle';

    for (var i = scale.chart.data.labels.length - 1; i >= 0; i--) {
      // Extra pixels out for some label spacing
      var extra = i === 0 ? tickBackdropHeight / 2 : 0;
      var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5); // Keep this in loop since we may support array properties here

      var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
      ctx.fillStyle = pointLabelFontColor;
      var angleRadians = scale.getIndexAngle(i);
      var angle = helpers$1.toDegrees(angleRadians);
      ctx.textAlign = getTextAlignForAngle(angle);
      adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
      fillText(ctx, scale.pointLabels[i], pointLabelPosition, plFont.lineHeight);
    }

    ctx.restore();
  }

  function drawRadiusLine(scale, gridLineOpts, radius, index) {
    var ctx = scale.ctx;
    var circular = gridLineOpts.circular;
    var valueCount = scale.chart.data.labels.length;
    var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
    var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
    var pointPosition;

    if (!circular && !valueCount || !lineColor || !lineWidth) {
      return;
    }

    ctx.save();
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = lineWidth;

    if (ctx.setLineDash) {
      ctx.setLineDash(gridLineOpts.borderDash || []);
      ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;
    }

    ctx.beginPath();

    if (circular) {
      // Draw circular arcs between the points
      ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
    } else {
      // Draw straight lines connecting each index
      pointPosition = scale.getPointPosition(0, radius);
      ctx.moveTo(pointPosition.x, pointPosition.y);

      for (var i = 1; i < valueCount; i++) {
        pointPosition = scale.getPointPosition(i, radius);
        ctx.lineTo(pointPosition.x, pointPosition.y);
      }
    }

    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  function numberOrZero(param) {
    return helpers$1.isNumber(param) ? param : 0;
  }

  var scale_radialLinear = scale_linearbase.extend({
    setDimensions: function setDimensions() {
      var me = this; // Set the unconstrained dimension before label rotation

      me.width = me.maxWidth;
      me.height = me.maxHeight;
      me.paddingTop = getTickBackdropHeight(me.options) / 2;
      me.xCenter = Math.floor(me.width / 2);
      me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
      me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
    },
    determineDataLimits: function determineDataLimits() {
      var me = this;
      var chart = me.chart;
      var min = Number.POSITIVE_INFINITY;
      var max = Number.NEGATIVE_INFINITY;
      helpers$1.each(chart.data.datasets, function (dataset, datasetIndex) {
        if (chart.isDatasetVisible(datasetIndex)) {
          var meta = chart.getDatasetMeta(datasetIndex);
          helpers$1.each(dataset.data, function (rawValue, index) {
            var value = +me.getRightValue(rawValue);

            if (isNaN(value) || meta.data[index].hidden) {
              return;
            }

            min = Math.min(value, min);
            max = Math.max(value, max);
          });
        }
      });
      me.min = min === Number.POSITIVE_INFINITY ? 0 : min;
      me.max = max === Number.NEGATIVE_INFINITY ? 0 : max; // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero

      me.handleTickRangeOptions();
    },
    // Returns the maximum number of ticks based on the scale dimension
    _computeTickLimit: function _computeTickLimit() {
      return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
    },
    convertTicksToLabels: function convertTicksToLabels() {
      var me = this;
      scale_linearbase.prototype.convertTicksToLabels.call(me); // Point labels

      me.pointLabels = me.chart.data.labels.map(function () {
        var label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);
        return label || label === 0 ? label : '';
      });
    },
    getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
      return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
    },
    fit: function fit() {
      var me = this;
      var opts = me.options;

      if (opts.display && opts.pointLabels.display) {
        fitWithPointLabels(me);
      } else {
        me.setCenterPoint(0, 0, 0, 0);
      }
    },

    /**
     * Set radius reductions and determine new radius and center point
     * @private
     */
    setReductions: function setReductions(largestPossibleRadius, furthestLimits, furthestAngles) {
      var me = this;
      var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
      var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
      var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
      var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);
      radiusReductionLeft = numberOrZero(radiusReductionLeft);
      radiusReductionRight = numberOrZero(radiusReductionRight);
      radiusReductionTop = numberOrZero(radiusReductionTop);
      radiusReductionBottom = numberOrZero(radiusReductionBottom);
      me.drawingArea = Math.min(Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2), Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
      me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
    },
    setCenterPoint: function setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
      var me = this;
      var maxRight = me.width - rightMovement - me.drawingArea;
      var maxLeft = leftMovement + me.drawingArea;
      var maxTop = topMovement + me.drawingArea;
      var maxBottom = me.height - me.paddingTop - bottomMovement - me.drawingArea;
      me.xCenter = Math.floor((maxLeft + maxRight) / 2 + me.left);
      me.yCenter = Math.floor((maxTop + maxBottom) / 2 + me.top + me.paddingTop);
    },
    getIndexAngle: function getIndexAngle(index) {
      var chart = this.chart;
      var angleMultiplier = 360 / chart.data.labels.length;
      var options = chart.options || {};
      var startAngle = options.startAngle || 0; // Start from the top instead of right, so remove a quarter of the circle

      var angle = (index * angleMultiplier + startAngle) % 360;
      return (angle < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;
    },
    getDistanceFromCenterForValue: function getDistanceFromCenterForValue(value) {
      var me = this;

      if (helpers$1.isNullOrUndef(value)) {
        return NaN;
      } // Take into account half font size + the yPadding of the top value


      var scalingFactor = me.drawingArea / (me.max - me.min);

      if (me.options.ticks.reverse) {
        return (me.max - value) * scalingFactor;
      }

      return (value - me.min) * scalingFactor;
    },
    getPointPosition: function getPointPosition(index, distanceFromCenter) {
      var me = this;
      var thisAngle = me.getIndexAngle(index) - Math.PI / 2;
      return {
        x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
        y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
      };
    },
    getPointPositionForValue: function getPointPositionForValue(index, value) {
      return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
    },
    getBasePosition: function getBasePosition(index) {
      var me = this;
      var min = me.min;
      var max = me.max;
      return me.getPointPositionForValue(index || 0, me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0);
    },

    /**
     * @private
     */
    _drawGrid: function _drawGrid() {
      var me = this;
      var ctx = me.ctx;
      var opts = me.options;
      var gridLineOpts = opts.gridLines;
      var angleLineOpts = opts.angleLines;
      var lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
      var lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);
      var i, offset, position;

      if (opts.pointLabels.display) {
        drawPointLabels(me);
      }

      if (gridLineOpts.display) {
        helpers$1.each(me.ticks, function (label, index) {
          if (index !== 0) {
            offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
            drawRadiusLine(me, gridLineOpts, offset, index);
          }
        });
      }

      if (angleLineOpts.display && lineWidth && lineColor) {
        ctx.save();
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = lineColor;

        if (ctx.setLineDash) {
          ctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
          ctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);
        }

        for (i = me.chart.data.labels.length - 1; i >= 0; i--) {
          offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);
          position = me.getPointPosition(i, offset);
          ctx.beginPath();
          ctx.moveTo(me.xCenter, me.yCenter);
          ctx.lineTo(position.x, position.y);
          ctx.stroke();
        }

        ctx.restore();
      }
    },

    /**
     * @private
     */
    _drawLabels: function _drawLabels() {
      var me = this;
      var ctx = me.ctx;
      var opts = me.options;
      var tickOpts = opts.ticks;

      if (!tickOpts.display) {
        return;
      }

      var startAngle = me.getIndexAngle(0);

      var tickFont = helpers$1.options._parseFont(tickOpts);

      var tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);
      var offset, width;
      ctx.save();
      ctx.font = tickFont.string;
      ctx.translate(me.xCenter, me.yCenter);
      ctx.rotate(startAngle);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      helpers$1.each(me.ticks, function (label, index) {
        if (index === 0 && !tickOpts.reverse) {
          return;
        }

        offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

        if (tickOpts.showLabelBackdrop) {
          width = ctx.measureText(label).width;
          ctx.fillStyle = tickOpts.backdropColor;
          ctx.fillRect(-width / 2 - tickOpts.backdropPaddingX, -offset - tickFont.size / 2 - tickOpts.backdropPaddingY, width + tickOpts.backdropPaddingX * 2, tickFont.size + tickOpts.backdropPaddingY * 2);
        }

        ctx.fillStyle = tickFontColor;
        ctx.fillText(label, 0, -offset);
      });
      ctx.restore();
    },

    /**
     * @private
     */
    _drawTitle: helpers$1.noop
  }); // INTERNAL: static default options, registered in src/index.js

  var _defaults$3 = defaultConfig$3;
  scale_radialLinear._defaults = _defaults$3;
  var deprecated$1 = helpers$1._deprecated;
  var resolve$5 = helpers$1.options.resolve;
  var valueOrDefault$d = helpers$1.valueOrDefault; // Integer constants are from the ES6 spec.

  var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
  var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var INTERVALS = {
    millisecond: {
      common: true,
      size: 1,
      steps: 1000
    },
    second: {
      common: true,
      size: 1000,
      steps: 60
    },
    minute: {
      common: true,
      size: 60000,
      steps: 60
    },
    hour: {
      common: true,
      size: 3600000,
      steps: 24
    },
    day: {
      common: true,
      size: 86400000,
      steps: 30
    },
    week: {
      common: false,
      size: 604800000,
      steps: 4
    },
    month: {
      common: true,
      size: 2.628e9,
      steps: 12
    },
    quarter: {
      common: false,
      size: 7.884e9,
      steps: 4
    },
    year: {
      common: true,
      size: 3.154e10
    }
  };
  var UNITS = Object.keys(INTERVALS);

  function sorter(a, b) {
    return a - b;
  }

  function arrayUnique(items) {
    var hash = {};
    var out = [];
    var i, ilen, item;

    for (i = 0, ilen = items.length; i < ilen; ++i) {
      item = items[i];

      if (!hash[item]) {
        hash[item] = true;
        out.push(item);
      }
    }

    return out;
  }

  function getMin(options) {
    return helpers$1.valueOrDefault(options.time.min, options.ticks.min);
  }

  function getMax(options) {
    return helpers$1.valueOrDefault(options.time.max, options.ticks.max);
  }
  /**
   * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
   * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
   * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
   * extremity (left + width or top + height). Note that it would be more optimized to directly
   * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
   * to create the lookup table. The table ALWAYS contains at least two items: min and max.
   *
   * @param {number[]} timestamps - timestamps sorted from lowest to highest.
   * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min
   * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
   * If 'series', timestamps will be positioned at the same distance from each other. In this
   * case, only timestamps that break the time linearity are registered, meaning that in the
   * best case, all timestamps are linear, the table contains only min and max.
   */


  function buildLookupTable(timestamps, min, max, distribution) {
    if (distribution === 'linear' || !timestamps.length) {
      return [{
        time: min,
        pos: 0
      }, {
        time: max,
        pos: 1
      }];
    }

    var table = [];
    var items = [min];
    var i, ilen, prev, curr, next;

    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
      curr = timestamps[i];

      if (curr > min && curr < max) {
        items.push(curr);
      }
    }

    items.push(max);

    for (i = 0, ilen = items.length; i < ilen; ++i) {
      next = items[i + 1];
      prev = items[i - 1];
      curr = items[i]; // only add points that breaks the scale linearity

      if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
        table.push({
          time: curr,
          pos: i / (ilen - 1)
        });
      }
    }

    return table;
  } // @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/


  function lookup(table, key, value) {
    var lo = 0;
    var hi = table.length - 1;
    var mid, i0, i1;

    while (lo >= 0 && lo <= hi) {
      mid = lo + hi >> 1;
      i0 = table[mid - 1] || null;
      i1 = table[mid];

      if (!i0) {
        // given value is outside table (before first item)
        return {
          lo: null,
          hi: i1
        };
      } else if (i1[key] < value) {
        lo = mid + 1;
      } else if (i0[key] > value) {
        hi = mid - 1;
      } else {
        return {
          lo: i0,
          hi: i1
        };
      }
    } // given value is outside table (after last item)


    return {
      lo: i1,
      hi: null
    };
  }
  /**
   * Linearly interpolates the given source `value` using the table items `skey` values and
   * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
   * returns the position for a timestamp equal to 42. If value is out of bounds, values at
   * index [0, 1] or [n - 1, n] are used for the interpolation.
   */


  function interpolate$1(table, skey, sval, tkey) {
    var range = lookup(table, skey, sval); // Note: the lookup table ALWAYS contains at least 2 items (min and max)

    var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
    var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;
    var span = next[skey] - prev[skey];
    var ratio = span ? (sval - prev[skey]) / span : 0;
    var offset = (next[tkey] - prev[tkey]) * ratio;
    return prev[tkey] + offset;
  }

  function toTimestamp(scale, input) {
    var adapter = scale._adapter;
    var options = scale.options.time;
    var parser = options.parser;
    var format = parser || options.format;
    var value = input;

    if (typeof parser === 'function') {
      value = parser(value);
    } // Only parse if its not a timestamp already


    if (!helpers$1.isFinite(value)) {
      value = typeof format === 'string' ? adapter.parse(value, format) : adapter.parse(value);
    }

    if (value !== null) {
      return +value;
    } // Labels are in an incompatible format and no `parser` has been provided.
    // The user might still use the deprecated `format` option for parsing.


    if (!parser && typeof format === 'function') {
      value = format(input); // `format` could return something else than a timestamp, if so, parse it

      if (!helpers$1.isFinite(value)) {
        value = adapter.parse(value);
      }
    }

    return value;
  }

  function parse(scale, input) {
    if (helpers$1.isNullOrUndef(input)) {
      return null;
    }

    var options = scale.options.time;
    var value = toTimestamp(scale, scale.getRightValue(input));

    if (value === null) {
      return value;
    }

    if (options.round) {
      value = +scale._adapter.startOf(value, options.round);
    }

    return value;
  }
  /**
   * Figures out what unit results in an appropriate number of auto-generated ticks
   */


  function determineUnitForAutoTicks(minUnit, min, max, capacity) {
    var ilen = UNITS.length;
    var i, interval, factor;

    for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
      interval = INTERVALS[UNITS[i]];
      factor = interval.steps ? interval.steps : MAX_INTEGER;

      if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
        return UNITS[i];
      }
    }

    return UNITS[ilen - 1];
  }
  /**
   * Figures out what unit to format a set of ticks with
   */


  function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
    var i, unit;

    for (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
      unit = UNITS[i];

      if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
        return unit;
      }
    }

    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
  }

  function determineMajorUnit(unit) {
    for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
      if (INTERVALS[UNITS[i]].common) {
        return UNITS[i];
      }
    }
  }
  /**
   * Generates a maximum of `capacity` timestamps between min and max, rounded to the
   * `minor` unit using the given scale time `options`.
   * Important: this method can return ticks outside the min and max range, it's the
   * responsibility of the calling code to clamp values if needed.
   */


  function generate(scale, min, max, capacity) {
    var adapter = scale._adapter;
    var options = scale.options;
    var timeOpts = options.time;
    var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
    var stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize, 1]);
    var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
    var first = min;
    var ticks = [];
    var time; // For 'week' unit, handle the first day of week option

    if (weekday) {
      first = +adapter.startOf(first, 'isoWeek', weekday);
    } // Align first ticks on unit


    first = +adapter.startOf(first, weekday ? 'day' : minor); // Prevent browser from freezing in case user options request millions of milliseconds

    if (adapter.diff(max, min, minor) > 100000 * stepSize) {
      throw min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor;
    }

    for (time = first; time < max; time = +adapter.add(time, stepSize, minor)) {
      ticks.push(time);
    }

    if (time === max || options.bounds === 'ticks') {
      ticks.push(time);
    }

    return ticks;
  }
  /**
   * Returns the start and end offsets from edges in the form of {start, end}
   * where each value is a relative width to the scale and ranges between 0 and 1.
   * They add extra margins on the both sides by scaling down the original scale.
   * Offsets are added when the `offset` option is true.
   */


  function computeOffsets(table, ticks, min, max, options) {
    var start = 0;
    var end = 0;
    var first, last;

    if (options.offset && ticks.length) {
      first = interpolate$1(table, 'time', ticks[0], 'pos');

      if (ticks.length === 1) {
        start = 1 - first;
      } else {
        start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;
      }

      last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');

      if (ticks.length === 1) {
        end = last;
      } else {
        end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;
      }
    }

    return {
      start: start,
      end: end,
      factor: 1 / (start + 1 + end)
    };
  }

  function setMajorTicks(scale, ticks, map, majorUnit) {
    var adapter = scale._adapter;
    var first = +adapter.startOf(ticks[0].value, majorUnit);
    var last = ticks[ticks.length - 1].value;
    var major, index;

    for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
      index = map[major];

      if (index >= 0) {
        ticks[index].major = true;
      }
    }

    return ticks;
  }

  function ticksFromTimestamps(scale, values, majorUnit) {
    var ticks = [];
    var map = {};
    var ilen = values.length;
    var i, value;

    for (i = 0; i < ilen; ++i) {
      value = values[i];
      map[value] = i;
      ticks.push({
        value: value,
        major: false
      });
    } // We set the major ticks separately from the above loop because calling startOf for every tick
    // is expensive when there is a large number of ticks


    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
  }

  var defaultConfig$4 = {
    position: 'bottom',

    /**
     * Data distribution along the scale:
     * - 'linear': data are spread according to their time (distances can vary),
     * - 'series': data are spread at the same distance from each other.
     * @see https://github.com/chartjs/Chart.js/pull/4507
     * @since 2.7.0
     */
    distribution: 'linear',

    /**
     * Scale boundary strategy (bypassed by min/max time options)
     * - `data`: make sure data are fully visible, ticks outside are removed
     * - `ticks`: make sure ticks are fully visible, data outside are truncated
     * @see https://github.com/chartjs/Chart.js/pull/4556
     * @since 2.7.0
     */
    bounds: 'data',
    adapters: {},
    time: {
      parser: false,
      // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
      unit: false,
      // false == automatic or override with week, month, year, etc.
      round: false,
      // none, or override with week, month, year, etc.
      displayFormat: false,
      // DEPRECATED
      isoWeekday: false,
      // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/
      minUnit: 'millisecond',
      displayFormats: {}
    },
    ticks: {
      autoSkip: false,

      /**
       * Ticks generation input values:
       * - 'auto': generates "optimal" ticks based on scale size and time options.
       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
       * - 'labels': generates ticks from user given `data.labels` values ONLY.
       * @see https://github.com/chartjs/Chart.js/pull/4507
       * @since 2.7.0
       */
      source: 'auto',
      major: {
        enabled: false
      }
    }
  };
  var scale_time = core_scale.extend({
    initialize: function initialize() {
      this.mergeTicksOptions();
      core_scale.prototype.initialize.call(this);
    },
    update: function update() {
      var me = this;
      var options = me.options;
      var time = options.time || (options.time = {});
      var adapter = me._adapter = new core_adapters._date(options.adapters.date); // DEPRECATIONS: output a message only one time per update

      deprecated$1('time scale', time.format, 'time.format', 'time.parser');
      deprecated$1('time scale', time.min, 'time.min', 'ticks.min');
      deprecated$1('time scale', time.max, 'time.max', 'ticks.max'); // Backward compatibility: before introducing adapter, `displayFormats` was
      // supposed to contain *all* unit/string pairs but this can't be resolved
      // when loading the scale (adapters are loaded afterward), so let's populate
      // missing formats on update

      helpers$1.mergeIf(time.displayFormats, adapter.formats());
      return core_scale.prototype.update.apply(me, arguments);
    },

    /**
     * Allows data to be referenced via 't' attribute
     */
    getRightValue: function getRightValue(rawValue) {
      if (rawValue && rawValue.t !== undefined) {
        rawValue = rawValue.t;
      }

      return core_scale.prototype.getRightValue.call(this, rawValue);
    },
    determineDataLimits: function determineDataLimits() {
      var me = this;
      var chart = me.chart;
      var adapter = me._adapter;
      var options = me.options;
      var unit = options.time.unit || 'day';
      var min = MAX_INTEGER;
      var max = MIN_INTEGER;
      var timestamps = [];
      var datasets = [];
      var labels = [];
      var i, j, ilen, jlen, data, timestamp, labelsAdded;

      var dataLabels = me._getLabels();

      for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
        labels.push(parse(me, dataLabels[i]));
      }

      for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
        if (chart.isDatasetVisible(i)) {
          data = chart.data.datasets[i].data; // Let's consider that all data have the same format.

          if (helpers$1.isObject(data[0])) {
            datasets[i] = [];

            for (j = 0, jlen = data.length; j < jlen; ++j) {
              timestamp = parse(me, data[j]);
              timestamps.push(timestamp);
              datasets[i][j] = timestamp;
            }
          } else {
            datasets[i] = labels.slice(0);

            if (!labelsAdded) {
              timestamps = timestamps.concat(labels);
              labelsAdded = true;
            }
          }
        } else {
          datasets[i] = [];
        }
      }

      if (labels.length) {
        min = Math.min(min, labels[0]);
        max = Math.max(max, labels[labels.length - 1]);
      }

      if (timestamps.length) {
        timestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);
        min = Math.min(min, timestamps[0]);
        max = Math.max(max, timestamps[timestamps.length - 1]);
      }

      min = parse(me, getMin(options)) || min;
      max = parse(me, getMax(options)) || max; // In case there is no valid min/max, set limits based on unit time option

      min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
      max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max; // Make sure that max is strictly higher than min (required by the lookup table)

      me.min = Math.min(min, max);
      me.max = Math.max(min + 1, max); // PRIVATE

      me._table = [];
      me._timestamps = {
        data: timestamps,
        datasets: datasets,
        labels: labels
      };
    },
    buildTicks: function buildTicks() {
      var me = this;
      var min = me.min;
      var max = me.max;
      var options = me.options;
      var tickOpts = options.ticks;
      var timeOpts = options.time;
      var timestamps = me._timestamps;
      var ticks = [];
      var capacity = me.getLabelCapacity(min);
      var source = tickOpts.source;
      var distribution = options.distribution;
      var i, ilen, timestamp;

      if (source === 'data' || source === 'auto' && distribution === 'series') {
        timestamps = timestamps.data;
      } else if (source === 'labels') {
        timestamps = timestamps.labels;
      } else {
        timestamps = generate(me, min, max, capacity);
      }

      if (options.bounds === 'ticks' && timestamps.length) {
        min = timestamps[0];
        max = timestamps[timestamps.length - 1];
      } // Enforce limits with user min/max options


      min = parse(me, getMin(options)) || min;
      max = parse(me, getMax(options)) || max; // Remove ticks outside the min/max range

      for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
        timestamp = timestamps[i];

        if (timestamp >= min && timestamp <= max) {
          ticks.push(timestamp);
        }
      }

      me.min = min;
      me.max = max; // PRIVATE
      // determineUnitForFormatting relies on the number of ticks so we don't use it when
      // autoSkip is enabled because we don't yet know what the final number of ticks will be

      me._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, capacity) : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));
      me._majorUnit = !tickOpts.major.enabled || me._unit === 'year' ? undefined : determineMajorUnit(me._unit);
      me._table = buildLookupTable(me._timestamps.data, min, max, distribution);
      me._offsets = computeOffsets(me._table, ticks, min, max, options);

      if (tickOpts.reverse) {
        ticks.reverse();
      }

      return ticksFromTimestamps(me, ticks, me._majorUnit);
    },
    getLabelForIndex: function getLabelForIndex(index, datasetIndex) {
      var me = this;
      var adapter = me._adapter;
      var data = me.chart.data;
      var timeOpts = me.options.time;
      var label = data.labels && index < data.labels.length ? data.labels[index] : '';
      var value = data.datasets[datasetIndex].data[index];

      if (helpers$1.isObject(value)) {
        label = me.getRightValue(value);
      }

      if (timeOpts.tooltipFormat) {
        return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
      }

      if (typeof label === 'string') {
        return label;
      }

      return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
    },

    /**
     * Function to format an individual tick mark
     * @private
     */
    tickFormatFunction: function tickFormatFunction(time, index, ticks, format) {
      var me = this;
      var adapter = me._adapter;
      var options = me.options;
      var formats = options.time.displayFormats;
      var minorFormat = formats[me._unit];
      var majorUnit = me._majorUnit;
      var majorFormat = formats[majorUnit];
      var tick = ticks[index];
      var tickOpts = options.ticks;
      var major = majorUnit && majorFormat && tick && tick.major;
      var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
      var nestedTickOpts = major ? tickOpts.major : tickOpts.minor;
      var formatter = resolve$5([nestedTickOpts.callback, nestedTickOpts.userCallback, tickOpts.callback, tickOpts.userCallback]);
      return formatter ? formatter(label, index, ticks) : label;
    },
    convertTicksToLabels: function convertTicksToLabels(ticks) {
      var labels = [];
      var i, ilen;

      for (i = 0, ilen = ticks.length; i < ilen; ++i) {
        labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
      }

      return labels;
    },

    /**
     * @private
     */
    getPixelForOffset: function getPixelForOffset(time) {
      var me = this;
      var offsets = me._offsets;
      var pos = interpolate$1(me._table, 'time', time, 'pos');
      return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);
    },
    getPixelForValue: function getPixelForValue(value, index, datasetIndex) {
      var me = this;
      var time = null;

      if (index !== undefined && datasetIndex !== undefined) {
        time = me._timestamps.datasets[datasetIndex][index];
      }

      if (time === null) {
        time = parse(me, value);
      }

      if (time !== null) {
        return me.getPixelForOffset(time);
      }
    },
    getPixelForTick: function getPixelForTick(index) {
      var ticks = this.getTicks();
      return index >= 0 && index < ticks.length ? this.getPixelForOffset(ticks[index].value) : null;
    },
    getValueForPixel: function getValueForPixel(pixel) {
      var me = this;
      var offsets = me._offsets;
      var pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
      var time = interpolate$1(me._table, 'pos', pos, 'time'); // DEPRECATION, we should return time directly

      return me._adapter._create(time);
    },

    /**
     * @private
     */
    _getLabelSize: function _getLabelSize(label) {
      var me = this;
      var ticksOpts = me.options.ticks;
      var tickLabelWidth = me.ctx.measureText(label).width;
      var angle = helpers$1.toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
      var cosRotation = Math.cos(angle);
      var sinRotation = Math.sin(angle);
      var tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);
      return {
        w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
        h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
      };
    },

    /**
     * Crude approximation of what the label width might be
     * @private
     */
    getLabelWidth: function getLabelWidth(label) {
      return this._getLabelSize(label).w;
    },

    /**
     * @private
     */
    getLabelCapacity: function getLabelCapacity(exampleTime) {
      var me = this;
      var timeOpts = me.options.time;
      var displayFormats = timeOpts.displayFormats; // pick the longest format (milliseconds) for guestimation

      var format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
      var exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);

      var size = me._getLabelSize(exampleLabel);

      var capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);

      if (me.options.offset) {
        capacity--;
      }

      return capacity > 0 ? capacity : 1;
    }
  }); // INTERNAL: static default options, registered in src/index.js

  var _defaults$4 = defaultConfig$4;
  scale_time._defaults = _defaults$4;
  var scales = {
    category: scale_category,
    linear: scale_linear,
    logarithmic: scale_logarithmic,
    radialLinear: scale_radialLinear,
    time: scale_time
  };
  var FORMATS = {
    datetime: 'MMM D, YYYY, h:mm:ss a',
    millisecond: 'h:mm:ss.SSS a',
    second: 'h:mm:ss a',
    minute: 'h:mm a',
    hour: 'hA',
    day: 'MMM D',
    week: 'll',
    month: 'MMM YYYY',
    quarter: '[Q]Q - YYYY',
    year: 'YYYY'
  };

  core_adapters._date.override(typeof moment === 'function' ? {
    _id: 'moment',
    // DEBUG ONLY
    formats: function formats() {
      return FORMATS;
    },
    parse: function parse(value, format) {
      if (typeof value === 'string' && typeof format === 'string') {
        value = moment(value, format);
      } else if (!(value instanceof moment)) {
        value = moment(value);
      }

      return value.isValid() ? value.valueOf() : null;
    },
    format: function format(time, _format) {
      return moment(time).format(_format);
    },
    add: function add(time, amount, unit) {
      return moment(time).add(amount, unit).valueOf();
    },
    diff: function diff(max, min, unit) {
      return moment(max).diff(moment(min), unit);
    },
    startOf: function startOf(time, unit, weekday) {
      time = moment(time);

      if (unit === 'isoWeek') {
        return time.isoWeekday(weekday).valueOf();
      }

      return time.startOf(unit).valueOf();
    },
    endOf: function endOf(time, unit) {
      return moment(time).endOf(unit).valueOf();
    },
    // DEPRECATIONS

    /**
     * Provided for backward compatibility with scale.getValueForPixel().
     * @deprecated since version 2.8.0
     * @todo remove at version 3
     * @private
     */
    _create: function _create(time) {
      return moment(time);
    }
  } : {});

  core_defaults._set('global', {
    plugins: {
      filler: {
        propagate: true
      }
    }
  });

  var mappers = {
    dataset: function dataset(source) {
      var index = source.fill;
      var chart = source.chart;
      var meta = chart.getDatasetMeta(index);
      var visible = meta && chart.isDatasetVisible(index);
      var points = visible && meta.dataset._children || [];
      var length = points.length || 0;
      return !length ? null : function (point, i) {
        return i < length && points[i]._view || null;
      };
    },
    boundary: function boundary(source) {
      var boundary = source.boundary;
      var x = boundary ? boundary.x : null;
      var y = boundary ? boundary.y : null;

      if (helpers$1.isArray(boundary)) {
        return function (point, i) {
          return boundary[i];
        };
      }

      return function (point) {
        return {
          x: x === null ? point.x : x,
          y: y === null ? point.y : y
        };
      };
    }
  }; // @todo if (fill[0] === '#')

  function decodeFill(el, index, count) {
    var model = el._model || {};
    var fill = model.fill;
    var target;

    if (fill === undefined) {
      fill = !!model.backgroundColor;
    }

    if (fill === false || fill === null) {
      return false;
    }

    if (fill === true) {
      return 'origin';
    }

    target = parseFloat(fill, 10);

    if (isFinite(target) && Math.floor(target) === target) {
      if (fill[0] === '-' || fill[0] === '+') {
        target = index + target;
      }

      if (target === index || target < 0 || target >= count) {
        return false;
      }

      return target;
    }

    switch (fill) {
      // compatibility
      case 'bottom':
        return 'start';

      case 'top':
        return 'end';

      case 'zero':
        return 'origin';
      // supported boundaries

      case 'origin':
      case 'start':
      case 'end':
        return fill;
      // invalid fill values

      default:
        return false;
    }
  }

  function computeLinearBoundary(source) {
    var model = source.el._model || {};
    var scale = source.el._scale || {};
    var fill = source.fill;
    var target = null;
    var horizontal;

    if (isFinite(fill)) {
      return null;
    } // Backward compatibility: until v3, we still need to support boundary values set on
    // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
    // controllers might still use it (e.g. the Smith chart).


    if (fill === 'start') {
      target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
    } else if (fill === 'end') {
      target = model.scaleTop === undefined ? scale.top : model.scaleTop;
    } else if (model.scaleZero !== undefined) {
      target = model.scaleZero;
    } else if (scale.getBasePixel) {
      target = scale.getBasePixel();
    }

    if (target !== undefined && target !== null) {
      if (target.x !== undefined && target.y !== undefined) {
        return target;
      }

      if (helpers$1.isFinite(target)) {
        horizontal = scale.isHorizontal();
        return {
          x: horizontal ? target : null,
          y: horizontal ? null : target
        };
      }
    }

    return null;
  }

  function computeCircularBoundary(source) {
    var scale = source.el._scale;
    var options = scale.options;
    var length = scale.chart.data.labels.length;
    var fill = source.fill;
    var target = [];
    var start, end, center, i, point;

    if (!length) {
      return null;
    }

    start = options.ticks.reverse ? scale.max : scale.min;
    end = options.ticks.reverse ? scale.min : scale.max;
    center = scale.getPointPositionForValue(0, start);

    for (i = 0; i < length; ++i) {
      point = fill === 'start' || fill === 'end' ? scale.getPointPositionForValue(i, fill === 'start' ? start : end) : scale.getBasePosition(i);

      if (options.gridLines.circular) {
        point.cx = center.x;
        point.cy = center.y;
        point.angle = scale.getIndexAngle(i) - Math.PI / 2;
      }

      target.push(point);
    }

    return target;
  }

  function computeBoundary(source) {
    var scale = source.el._scale || {};

    if (scale.getPointPositionForValue) {
      return computeCircularBoundary(source);
    }

    return computeLinearBoundary(source);
  }

  function resolveTarget(sources, index, propagate) {
    var source = sources[index];
    var fill = source.fill;
    var visited = [index];
    var target;

    if (!propagate) {
      return fill;
    }

    while (fill !== false && visited.indexOf(fill) === -1) {
      if (!isFinite(fill)) {
        return fill;
      }

      target = sources[fill];

      if (!target) {
        return false;
      }

      if (target.visible) {
        return fill;
      }

      visited.push(fill);
      fill = target.fill;
    }

    return false;
  }

  function createMapper(source) {
    var fill = source.fill;
    var type = 'dataset';

    if (fill === false) {
      return null;
    }

    if (!isFinite(fill)) {
      type = 'boundary';
    }

    return mappers[type](source);
  }

  function isDrawable(point) {
    return point && !point.skip;
  }

  function drawArea(ctx, curve0, curve1, len0, len1) {
    var i, cx, cy, r;

    if (!len0 || !len1) {
      return;
    } // building first area curve (normal)


    ctx.moveTo(curve0[0].x, curve0[0].y);

    for (i = 1; i < len0; ++i) {
      helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
    }

    if (curve1[0].angle !== undefined) {
      cx = curve1[0].cx;
      cy = curve1[0].cy;
      r = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));

      for (i = len1 - 1; i > 0; --i) {
        ctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);
      }

      return;
    } // joining the two area curves


    ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)

    for (i = len1 - 1; i > 0; --i) {
      helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
    }
  }

  function doFill(ctx, points, mapper, view, color, loop) {
    var count = points.length;
    var span = view.spanGaps;
    var curve0 = [];
    var curve1 = [];
    var len0 = 0;
    var len1 = 0;
    var i, ilen, index, p0, p1, d0, d1, loopOffset;
    ctx.beginPath();

    for (i = 0, ilen = count; i < ilen; ++i) {
      index = i % count;
      p0 = points[index]._view;
      p1 = mapper(p0, index, view);
      d0 = isDrawable(p0);
      d1 = isDrawable(p1);

      if (loop && loopOffset === undefined && d0) {
        loopOffset = i + 1;
        ilen = count + loopOffset;
      }

      if (d0 && d1) {
        len0 = curve0.push(p0);
        len1 = curve1.push(p1);
      } else if (len0 && len1) {
        if (!span) {
          drawArea(ctx, curve0, curve1, len0, len1);
          len0 = len1 = 0;
          curve0 = [];
          curve1 = [];
        } else {
          if (d0) {
            curve0.push(p0);
          }

          if (d1) {
            curve1.push(p1);
          }
        }
      }
    }

    drawArea(ctx, curve0, curve1, len0, len1);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
  }

  var plugin_filler = {
    id: 'filler',
    afterDatasetsUpdate: function afterDatasetsUpdate(chart, options) {
      var count = (chart.data.datasets || []).length;
      var propagate = options.propagate;
      var sources = [];
      var meta, i, el, source;

      for (i = 0; i < count; ++i) {
        meta = chart.getDatasetMeta(i);
        el = meta.dataset;
        source = null;

        if (el && el._model && el instanceof elements.Line) {
          source = {
            visible: chart.isDatasetVisible(i),
            fill: decodeFill(el, i, count),
            chart: chart,
            el: el
          };
        }

        meta.$filler = source;
        sources.push(source);
      }

      for (i = 0; i < count; ++i) {
        source = sources[i];

        if (!source) {
          continue;
        }

        source.fill = resolveTarget(sources, i, propagate);
        source.boundary = computeBoundary(source);
        source.mapper = createMapper(source);
      }
    },
    beforeDatasetsDraw: function beforeDatasetsDraw(chart) {
      var metasets = chart._getSortedVisibleDatasetMetas();

      var ctx = chart.ctx;
      var meta, i, el, view, points, mapper, color;

      for (i = metasets.length - 1; i >= 0; --i) {
        meta = metasets[i].$filler;

        if (!meta || !meta.visible) {
          continue;
        }

        el = meta.el;
        view = el._view;
        points = el._children || [];
        mapper = meta.mapper;
        color = view.backgroundColor || core_defaults.global.defaultColor;

        if (mapper && color && points.length) {
          helpers$1.canvas.clipArea(ctx, chart.chartArea);
          doFill(ctx, points, mapper, view, color, el._loop);
          helpers$1.canvas.unclipArea(ctx);
        }
      }
    }
  };
  var getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;
  var noop$1 = helpers$1.noop;
  var valueOrDefault$e = helpers$1.valueOrDefault;

  core_defaults._set('global', {
    legend: {
      display: true,
      position: 'top',
      align: 'center',
      fullWidth: true,
      reverse: false,
      weight: 1000,
      // a callback that will handle
      onClick: function onClick(e, legendItem) {
        var index = legendItem.datasetIndex;
        var ci = this.chart;
        var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment

        meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart

        ci.update();
      },
      onHover: null,
      onLeave: null,
      labels: {
        boxWidth: 40,
        padding: 10,
        // Generates labels shown in the legend
        // Valid properties to return:
        // text : text to display
        // fillStyle : fill of coloured box
        // strokeStyle: stroke of coloured box
        // hidden : if this legend item refers to a hidden item
        // lineCap : cap style for line
        // lineDash
        // lineDashOffset :
        // lineJoin :
        // lineWidth :
        generateLabels: function generateLabels(chart) {
          var datasets = chart.data.datasets;
          var options = chart.options.legend || {};
          var usePointStyle = options.labels && options.labels.usePointStyle;
          return chart._getSortedDatasetMetas().map(function (meta) {
            var style = meta.controller.getStyle(usePointStyle ? 0 : undefined);
            return {
              text: datasets[meta.index].label,
              fillStyle: style.backgroundColor,
              hidden: !chart.isDatasetVisible(meta.index),
              lineCap: style.borderCapStyle,
              lineDash: style.borderDash,
              lineDashOffset: style.borderDashOffset,
              lineJoin: style.borderJoinStyle,
              lineWidth: style.borderWidth,
              strokeStyle: style.borderColor,
              pointStyle: style.pointStyle,
              rotation: style.rotation,
              // Below is extra data used for toggling the datasets
              datasetIndex: meta.index
            };
          }, this);
        }
      }
    },
    legendCallback: function legendCallback(chart) {
      var list = document.createElement('ul');
      var datasets = chart.data.datasets;
      var i, ilen, listItem, listItemSpan;
      list.setAttribute('class', chart.id + '-legend');

      for (i = 0, ilen = datasets.length; i < ilen; i++) {
        listItem = list.appendChild(document.createElement('li'));
        listItemSpan = listItem.appendChild(document.createElement('span'));
        listItemSpan.style.backgroundColor = datasets[i].backgroundColor;

        if (datasets[i].label) {
          listItem.appendChild(document.createTextNode(datasets[i].label));
        }
      }

      return list.outerHTML;
    }
  });
  /**
   * Helper function to get the box width based on the usePointStyle option
   * @param {object} labelopts - the label options on the legend
   * @param {number} fontSize - the label font size
   * @return {number} width of the color box area
   */


  function getBoxWidth(labelOpts, fontSize) {
    return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ? fontSize : labelOpts.boxWidth;
  }
  /**
   * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
   */


  var Legend = core_element.extend({
    initialize: function initialize(config) {
      var me = this;
      helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)

      me.legendHitBoxes = [];
      /**
      	 * @private
      	 */

      me._hoveredItem = null; // Are we in doughnut mode which has a different data type

      me.doughnutMode = false;
    },
    // These methods are ordered by lifecycle. Utilities then follow.
    // Any function defined here is inherited by all legend types.
    // Any function can be extended by the legend type
    beforeUpdate: noop$1,
    update: function update(maxWidth, maxHeight, margins) {
      var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

      me.beforeUpdate(); // Absorb the master measurements

      me.maxWidth = maxWidth;
      me.maxHeight = maxHeight;
      me.margins = margins; // Dimensions

      me.beforeSetDimensions();
      me.setDimensions();
      me.afterSetDimensions(); // Labels

      me.beforeBuildLabels();
      me.buildLabels();
      me.afterBuildLabels(); // Fit

      me.beforeFit();
      me.fit();
      me.afterFit(); //

      me.afterUpdate();
      return me.minSize;
    },
    afterUpdate: noop$1,
    //
    beforeSetDimensions: noop$1,
    setDimensions: function setDimensions() {
      var me = this; // Set the unconstrained dimension before label rotation

      if (me.isHorizontal()) {
        // Reset position before calculating rotation
        me.width = me.maxWidth;
        me.left = 0;
        me.right = me.width;
      } else {
        me.height = me.maxHeight; // Reset position before calculating rotation

        me.top = 0;
        me.bottom = me.height;
      } // Reset padding


      me.paddingLeft = 0;
      me.paddingTop = 0;
      me.paddingRight = 0;
      me.paddingBottom = 0; // Reset minSize

      me.minSize = {
        width: 0,
        height: 0
      };
    },
    afterSetDimensions: noop$1,
    //
    beforeBuildLabels: noop$1,
    buildLabels: function buildLabels() {
      var me = this;
      var labelOpts = me.options.labels || {};
      var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];

      if (labelOpts.filter) {
        legendItems = legendItems.filter(function (item) {
          return labelOpts.filter(item, me.chart.data);
        });
      }

      if (me.options.reverse) {
        legendItems.reverse();
      }

      me.legendItems = legendItems;
    },
    afterBuildLabels: noop$1,
    //
    beforeFit: noop$1,
    fit: function fit() {
      var me = this;
      var opts = me.options;
      var labelOpts = opts.labels;
      var display = opts.display;
      var ctx = me.ctx;

      var labelFont = helpers$1.options._parseFont(labelOpts);

      var fontSize = labelFont.size; // Reset hit boxes

      var hitboxes = me.legendHitBoxes = [];
      var minSize = me.minSize;
      var isHorizontal = me.isHorizontal();

      if (isHorizontal) {
        minSize.width = me.maxWidth; // fill all the width

        minSize.height = display ? 10 : 0;
      } else {
        minSize.width = display ? 10 : 0;
        minSize.height = me.maxHeight; // fill all the height
      } // Increase sizes here


      if (!display) {
        me.width = minSize.width = me.height = minSize.height = 0;
        return;
      }

      ctx.font = labelFont.string;

      if (isHorizontal) {
        // Labels
        // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
        var lineWidths = me.lineWidths = [0];
        var totalHeight = 0;
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';
        helpers$1.each(me.legendItems, function (legendItem, i) {
          var boxWidth = getBoxWidth(labelOpts, fontSize);
          var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;

          if (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {
            totalHeight += fontSize + labelOpts.padding;
            lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
          } // Store the hitbox width and height here. Final position will be updated in `draw`


          hitboxes[i] = {
            left: 0,
            top: 0,
            width: width,
            height: fontSize
          };
          lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
        });
        minSize.height += totalHeight;
      } else {
        var vPadding = labelOpts.padding;
        var columnWidths = me.columnWidths = [];
        var columnHeights = me.columnHeights = [];
        var totalWidth = labelOpts.padding;
        var currentColWidth = 0;
        var currentColHeight = 0;
        helpers$1.each(me.legendItems, function (legendItem, i) {
          var boxWidth = getBoxWidth(labelOpts, fontSize);
          var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column

          if (i > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {
            totalWidth += currentColWidth + labelOpts.padding;
            columnWidths.push(currentColWidth); // previous column width

            columnHeights.push(currentColHeight);
            currentColWidth = 0;
            currentColHeight = 0;
          } // Get max width


          currentColWidth = Math.max(currentColWidth, itemWidth);
          currentColHeight += fontSize + vPadding; // Store the hitbox width and height here. Final position will be updated in `draw`

          hitboxes[i] = {
            left: 0,
            top: 0,
            width: itemWidth,
            height: fontSize
          };
        });
        totalWidth += currentColWidth;
        columnWidths.push(currentColWidth);
        columnHeights.push(currentColHeight);
        minSize.width += totalWidth;
      }

      me.width = minSize.width;
      me.height = minSize.height;
    },
    afterFit: noop$1,
    // Shared Methods
    isHorizontal: function isHorizontal() {
      return this.options.position === 'top' || this.options.position === 'bottom';
    },
    // Actually draw the legend on the canvas
    draw: function draw() {
      var me = this;
      var opts = me.options;
      var labelOpts = opts.labels;
      var globalDefaults = core_defaults.global;
      var defaultColor = globalDefaults.defaultColor;
      var lineDefault = globalDefaults.elements.line;
      var legendHeight = me.height;
      var columnHeights = me.columnHeights;
      var legendWidth = me.width;
      var lineWidths = me.lineWidths;

      if (!opts.display) {
        return;
      }

      var rtlHelper = getRtlHelper$1(opts.rtl, me.left, me.minSize.width);
      var ctx = me.ctx;
      var fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);

      var labelFont = helpers$1.options._parseFont(labelOpts);

      var fontSize = labelFont.size;
      var cursor; // Canvas setup

      ctx.textAlign = rtlHelper.textAlign('left');
      ctx.textBaseline = 'middle';
      ctx.lineWidth = 0.5;
      ctx.strokeStyle = fontColor; // for strikethrough effect

      ctx.fillStyle = fontColor; // render in correct colour

      ctx.font = labelFont.string;
      var boxWidth = getBoxWidth(labelOpts, fontSize);
      var hitboxes = me.legendHitBoxes; // current position

      var drawLegendBox = function drawLegendBox(x, y, legendItem) {
        if (isNaN(boxWidth) || boxWidth <= 0) {
          return;
        } // Set the ctx for the box


        ctx.save();
        var lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);
        ctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor);
        ctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);
        ctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);
        ctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor);

        if (ctx.setLineDash) {
          // IE 9 and 10 do not support line dash
          ctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));
        }

        if (labelOpts && labelOpts.usePointStyle) {
          // Recalculate x and y for drawPoint() because its expecting
          // x and y to be center of figure (instead of top left)
          var radius = boxWidth * Math.SQRT2 / 2;
          var centerX = rtlHelper.xPlus(x, boxWidth / 2);
          var centerY = y + fontSize / 2; // Draw pointStyle as legend symbol

          helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);
        } else {
          // Draw box as legend symbol
          ctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);

          if (lineWidth !== 0) {
            ctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
          }
        }

        ctx.restore();
      };

      var fillText = function fillText(x, y, legendItem, textWidth) {
        var halfFontSize = fontSize / 2;
        var xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);
        var yMiddle = y + halfFontSize;
        ctx.fillText(legendItem.text, xLeft, yMiddle);

        if (legendItem.hidden) {
          // Strikethrough the text if hidden
          ctx.beginPath();
          ctx.lineWidth = 2;
          ctx.moveTo(xLeft, yMiddle);
          ctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);
          ctx.stroke();
        }
      };

      var alignmentOffset = function alignmentOffset(dimension, blockSize) {
        switch (opts.align) {
          case 'start':
            return labelOpts.padding;

          case 'end':
            return dimension - blockSize;

          default:
            // center
            return (dimension - blockSize + labelOpts.padding) / 2;
        }
      }; // Horizontal


      var isHorizontal = me.isHorizontal();

      if (isHorizontal) {
        cursor = {
          x: me.left + alignmentOffset(legendWidth, lineWidths[0]),
          y: me.top + labelOpts.padding,
          line: 0
        };
      } else {
        cursor = {
          x: me.left + labelOpts.padding,
          y: me.top + alignmentOffset(legendHeight, columnHeights[0]),
          line: 0
        };
      }

      helpers$1.rtl.overrideTextDirection(me.ctx, opts.textDirection);
      var itemHeight = fontSize + labelOpts.padding;
      helpers$1.each(me.legendItems, function (legendItem, i) {
        var textWidth = ctx.measureText(legendItem.text).width;
        var width = boxWidth + fontSize / 2 + textWidth;
        var x = cursor.x;
        var y = cursor.y;
        rtlHelper.setWidth(me.minSize.width); // Use (me.left + me.minSize.width) and (me.top + me.minSize.height)
        // instead of me.right and me.bottom because me.width and me.height
        // may have been changed since me.minSize was calculated

        if (isHorizontal) {
          if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
            y = cursor.y += itemHeight;
            cursor.line++;
            x = cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);
          }
        } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
          x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
          cursor.line++;
          y = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);
        }

        var realX = rtlHelper.x(x);
        drawLegendBox(realX, y, legendItem);
        hitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);
        hitboxes[i].top = y; // Fill the actual label

        fillText(realX, y, legendItem, textWidth);

        if (isHorizontal) {
          cursor.x += width + labelOpts.padding;
        } else {
          cursor.y += itemHeight;
        }
      });
      helpers$1.rtl.restoreTextDirection(me.ctx, opts.textDirection);
    },

    /**
     * @private
     */
    _getLegendItemAt: function _getLegendItemAt(x, y) {
      var me = this;
      var i, hitBox, lh;

      if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
        // See if we are touching one of the dataset boxes
        lh = me.legendHitBoxes;

        for (i = 0; i < lh.length; ++i) {
          hitBox = lh[i];

          if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
            // Touching an element
            return me.legendItems[i];
          }
        }
      }

      return null;
    },

    /**
     * Handle an event
     * @private
     * @param {IEvent} event - The event to handle
     */
    handleEvent: function handleEvent(e) {
      var me = this;
      var opts = me.options;
      var type = e.type === 'mouseup' ? 'click' : e.type;
      var hoveredItem;

      if (type === 'mousemove') {
        if (!opts.onHover && !opts.onLeave) {
          return;
        }
      } else if (type === 'click') {
        if (!opts.onClick) {
          return;
        }
      } else {
        return;
      } // Chart event already has relative position in it


      hoveredItem = me._getLegendItemAt(e.x, e.y);

      if (type === 'click') {
        if (hoveredItem && opts.onClick) {
          // use e.native for backwards compatibility
          opts.onClick.call(me, e["native"], hoveredItem);
        }
      } else {
        if (opts.onLeave && hoveredItem !== me._hoveredItem) {
          if (me._hoveredItem) {
            opts.onLeave.call(me, e["native"], me._hoveredItem);
          }

          me._hoveredItem = hoveredItem;
        }

        if (opts.onHover && hoveredItem) {
          // use e.native for backwards compatibility
          opts.onHover.call(me, e["native"], hoveredItem);
        }
      }
    }
  });

  function createNewLegendAndAttach(chart, legendOpts) {
    var legend = new Legend({
      ctx: chart.ctx,
      options: legendOpts,
      chart: chart
    });
    core_layouts.configure(chart, legend, legendOpts);
    core_layouts.addBox(chart, legend);
    chart.legend = legend;
  }

  var plugin_legend = {
    id: 'legend',

    /**
     * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
     * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
     * the plugin, which one will be re-exposed in the chart.js file.
     * https://github.com/chartjs/Chart.js/pull/2640
     * @private
     */
    _element: Legend,
    beforeInit: function beforeInit(chart) {
      var legendOpts = chart.options.legend;

      if (legendOpts) {
        createNewLegendAndAttach(chart, legendOpts);
      }
    },
    beforeUpdate: function beforeUpdate(chart) {
      var legendOpts = chart.options.legend;
      var legend = chart.legend;

      if (legendOpts) {
        helpers$1.mergeIf(legendOpts, core_defaults.global.legend);

        if (legend) {
          core_layouts.configure(chart, legend, legendOpts);
          legend.options = legendOpts;
        } else {
          createNewLegendAndAttach(chart, legendOpts);
        }
      } else if (legend) {
        core_layouts.removeBox(chart, legend);
        delete chart.legend;
      }
    },
    afterEvent: function afterEvent(chart, e) {
      var legend = chart.legend;

      if (legend) {
        legend.handleEvent(e);
      }
    }
  };
  var noop$2 = helpers$1.noop;

  core_defaults._set('global', {
    title: {
      display: false,
      fontStyle: 'bold',
      fullWidth: true,
      padding: 10,
      position: 'top',
      text: '',
      weight: 2000 // by default greater than legend (1000) to be above

    }
  });
  /**
   * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
   */


  var Title = core_element.extend({
    initialize: function initialize(config) {
      var me = this;
      helpers$1.extend(me, config); // Contains hit boxes for each dataset (in dataset order)

      me.legendHitBoxes = [];
    },
    // These methods are ordered by lifecycle. Utilities then follow.
    beforeUpdate: noop$2,
    update: function update(maxWidth, maxHeight, margins) {
      var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)

      me.beforeUpdate(); // Absorb the master measurements

      me.maxWidth = maxWidth;
      me.maxHeight = maxHeight;
      me.margins = margins; // Dimensions

      me.beforeSetDimensions();
      me.setDimensions();
      me.afterSetDimensions(); // Labels

      me.beforeBuildLabels();
      me.buildLabels();
      me.afterBuildLabels(); // Fit

      me.beforeFit();
      me.fit();
      me.afterFit(); //

      me.afterUpdate();
      return me.minSize;
    },
    afterUpdate: noop$2,
    //
    beforeSetDimensions: noop$2,
    setDimensions: function setDimensions() {
      var me = this; // Set the unconstrained dimension before label rotation

      if (me.isHorizontal()) {
        // Reset position before calculating rotation
        me.width = me.maxWidth;
        me.left = 0;
        me.right = me.width;
      } else {
        me.height = me.maxHeight; // Reset position before calculating rotation

        me.top = 0;
        me.bottom = me.height;
      } // Reset padding


      me.paddingLeft = 0;
      me.paddingTop = 0;
      me.paddingRight = 0;
      me.paddingBottom = 0; // Reset minSize

      me.minSize = {
        width: 0,
        height: 0
      };
    },
    afterSetDimensions: noop$2,
    //
    beforeBuildLabels: noop$2,
    buildLabels: noop$2,
    afterBuildLabels: noop$2,
    //
    beforeFit: noop$2,
    fit: function fit() {
      var me = this;
      var opts = me.options;
      var minSize = me.minSize = {};
      var isHorizontal = me.isHorizontal();
      var lineCount, textSize;

      if (!opts.display) {
        me.width = minSize.width = me.height = minSize.height = 0;
        return;
      }

      lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;
      textSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + opts.padding * 2;
      me.width = minSize.width = isHorizontal ? me.maxWidth : textSize;
      me.height = minSize.height = isHorizontal ? textSize : me.maxHeight;
    },
    afterFit: noop$2,
    // Shared Methods
    isHorizontal: function isHorizontal() {
      var pos = this.options.position;
      return pos === 'top' || pos === 'bottom';
    },
    // Actually draw the title block on the canvas
    draw: function draw() {
      var me = this;
      var ctx = me.ctx;
      var opts = me.options;

      if (!opts.display) {
        return;
      }

      var fontOpts = helpers$1.options._parseFont(opts);

      var lineHeight = fontOpts.lineHeight;
      var offset = lineHeight / 2 + opts.padding;
      var rotation = 0;
      var top = me.top;
      var left = me.left;
      var bottom = me.bottom;
      var right = me.right;
      var maxWidth, titleX, titleY;
      ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour

      ctx.font = fontOpts.string; // Horizontal

      if (me.isHorizontal()) {
        titleX = left + (right - left) / 2; // midpoint of the width

        titleY = top + offset;
        maxWidth = right - left;
      } else {
        titleX = opts.position === 'left' ? left + offset : right - offset;
        titleY = top + (bottom - top) / 2;
        maxWidth = bottom - top;
        rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
      }

      ctx.save();
      ctx.translate(titleX, titleY);
      ctx.rotate(rotation);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      var text = opts.text;

      if (helpers$1.isArray(text)) {
        var y = 0;

        for (var i = 0; i < text.length; ++i) {
          ctx.fillText(text[i], 0, y, maxWidth);
          y += lineHeight;
        }
      } else {
        ctx.fillText(text, 0, 0, maxWidth);
      }

      ctx.restore();
    }
  });

  function createNewTitleBlockAndAttach(chart, titleOpts) {
    var title = new Title({
      ctx: chart.ctx,
      options: titleOpts,
      chart: chart
    });
    core_layouts.configure(chart, title, titleOpts);
    core_layouts.addBox(chart, title);
    chart.titleBlock = title;
  }

  var plugin_title = {
    id: 'title',

    /**
     * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
     * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
     * the plugin, which one will be re-exposed in the chart.js file.
     * https://github.com/chartjs/Chart.js/pull/2640
     * @private
     */
    _element: Title,
    beforeInit: function beforeInit(chart) {
      var titleOpts = chart.options.title;

      if (titleOpts) {
        createNewTitleBlockAndAttach(chart, titleOpts);
      }
    },
    beforeUpdate: function beforeUpdate(chart) {
      var titleOpts = chart.options.title;
      var titleBlock = chart.titleBlock;

      if (titleOpts) {
        helpers$1.mergeIf(titleOpts, core_defaults.global.title);

        if (titleBlock) {
          core_layouts.configure(chart, titleBlock, titleOpts);
          titleBlock.options = titleOpts;
        } else {
          createNewTitleBlockAndAttach(chart, titleOpts);
        }
      } else if (titleBlock) {
        core_layouts.removeBox(chart, titleBlock);
        delete chart.titleBlock;
      }
    }
  };
  var plugins = {};
  var filler = plugin_filler;
  var legend = plugin_legend;
  var title = plugin_title;
  plugins.filler = filler;
  plugins.legend = legend;
  plugins.title = title;
  /**
   * @namespace Chart
   */

  core_controller.helpers = helpers$1; // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!

  core_helpers();
  core_controller._adapters = core_adapters;
  core_controller.Animation = core_animation;
  core_controller.animationService = core_animations;
  core_controller.controllers = controllers;
  core_controller.DatasetController = core_datasetController;
  core_controller.defaults = core_defaults;
  core_controller.Element = core_element;
  core_controller.elements = elements;
  core_controller.Interaction = core_interaction;
  core_controller.layouts = core_layouts;
  core_controller.platform = platform;
  core_controller.plugins = core_plugins;
  core_controller.Scale = core_scale;
  core_controller.scaleService = core_scaleService;
  core_controller.Ticks = core_ticks;
  core_controller.Tooltip = core_tooltip; // Register built-in scales

  core_controller.helpers.each(scales, function (scale, type) {
    core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
  }); // Load to register built-in adapters (as side effects)
  // Loading built-in plugins

  for (var k in plugins) {
    if (plugins.hasOwnProperty(k)) {
      core_controller.plugins.register(plugins[k]);
    }
  }

  core_controller.platform.initialize();
  var src = core_controller;

  if (typeof window !== 'undefined') {
    window.Chart = core_controller;
  } // DEPRECATIONS

  /**
   * Provided for backward compatibility, not available anymore
   * @namespace Chart.Chart
   * @deprecated since version 2.8.0
   * @todo remove at version 3
   * @private
   */


  core_controller.Chart = core_controller;
  /**
   * Provided for backward compatibility, not available anymore
   * @namespace Chart.Legend
   * @deprecated since version 2.1.5
   * @todo remove at version 3
   * @private
   */

  core_controller.Legend = plugins.legend._element;
  /**
   * Provided for backward compatibility, not available anymore
   * @namespace Chart.Title
   * @deprecated since version 2.1.5
   * @todo remove at version 3
   * @private
   */

  core_controller.Title = plugins.title._element;
  /**
   * Provided for backward compatibility, use Chart.plugins instead
   * @namespace Chart.pluginService
   * @deprecated since version 2.1.5
   * @todo remove at version 3
   * @private
   */

  core_controller.pluginService = core_controller.plugins;
  /**
   * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
   * effect, instead simply create/register plugins via plain JavaScript objects.
   * @interface Chart.PluginBase
   * @deprecated since version 2.5.0
   * @todo remove at version 3
   * @private
   */

  core_controller.PluginBase = core_controller.Element.extend({});
  /**
   * Provided for backward compatibility, use Chart.helpers.canvas instead.
   * @namespace Chart.canvasHelpers
   * @deprecated since version 2.6.0
   * @todo remove at version 3
   * @private
   */

  core_controller.canvasHelpers = core_controller.helpers.canvas;
  /**
   * Provided for backward compatibility, use Chart.layouts instead.
   * @namespace Chart.layoutService
   * @deprecated since version 2.7.3
   * @todo remove at version 3
   * @private
   */

  core_controller.layoutService = core_controller.layouts;
  /**
   * Provided for backward compatibility, not available anymore.
   * @namespace Chart.LinearScaleBase
   * @deprecated since version 2.8
   * @todo remove at version 3
   * @private
   */

  core_controller.LinearScaleBase = scale_linearbase;
  /**
   * Provided for backward compatibility, instead we should create a new Chart
   * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).
   * @deprecated since version 2.8.0
   * @todo remove at version 3
   */

  core_controller.helpers.each(['Bar', 'Bubble', 'Doughnut', 'Line', 'PolarArea', 'Radar', 'Scatter'], function (klass) {
    core_controller[klass] = function (ctx, cfg) {
      return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
        type: klass.charAt(0).toLowerCase() + klass.slice(1)
      }));
    };
  });
  return src;
});

/***/ }),

/***/ 58226:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(73346);

__webpack_require__(16655);

__webpack_require__(25377);

__webpack_require__(75487);

__webpack_require__(80581);

__webpack_require__(14133);

__webpack_require__(32845);

__webpack_require__(8751);

__webpack_require__(45970);

__webpack_require__(50863);

__webpack_require__(40055);

__webpack_require__(56995);

__webpack_require__(84032);

__webpack_require__(5498);

__webpack_require__(38144);

__webpack_require__(53523);

__webpack_require__(40979);

__webpack_require__(50347);

__webpack_require__(88854);

__webpack_require__(29074);

__webpack_require__(74772);

__webpack_require__(60843);

__webpack_require__(98434);

__webpack_require__(15911);

__webpack_require__(33365);

__webpack_require__(1169);

__webpack_require__(91709);

__webpack_require__(432);

__webpack_require__(37174);

__webpack_require__(98820);

__webpack_require__(48953);

__webpack_require__(39264);

__webpack_require__(26433);

__webpack_require__(74443);

__webpack_require__(36189);

__webpack_require__(9851);

__webpack_require__(82145);

__webpack_require__(93034);

__webpack_require__(6925);

__webpack_require__(97378);

__webpack_require__(62874);

__webpack_require__(94963);

__webpack_require__(15857);

__webpack_require__(93484);

__webpack_require__(66668);

__webpack_require__(58981);

__webpack_require__(72876);

__webpack_require__(45934);

__webpack_require__(26850);

__webpack_require__(56252);

__webpack_require__(66760);

__webpack_require__(1127);

__webpack_require__(6499);

__webpack_require__(97448);

__webpack_require__(21386);

__webpack_require__(21292);

__webpack_require__(22929);

__webpack_require__(90803);

__webpack_require__(71994);

__webpack_require__(8889);

__webpack_require__(610);

__webpack_require__(28400);

__webpack_require__(36217);

__webpack_require__(76262);

__webpack_require__(6939);

__webpack_require__(6143);

__webpack_require__(66932);

__webpack_require__(76265);

__webpack_require__(58482);

__webpack_require__(47163);

__webpack_require__(72380);

__webpack_require__(17625);

__webpack_require__(69151);

__webpack_require__(69547);

__webpack_require__(51409);

__webpack_require__(34828);

__webpack_require__(82394);

__webpack_require__(23920);

__webpack_require__(7498);

__webpack_require__(33419);

__webpack_require__(19945);

__webpack_require__(24522);

__webpack_require__(37692);

__webpack_require__(15868);

__webpack_require__(11035);

__webpack_require__(85021);

__webpack_require__(51174);

__webpack_require__(52560);

__webpack_require__(12660);

__webpack_require__(37039);

__webpack_require__(79055);

__webpack_require__(46222);

__webpack_require__(92574);

__webpack_require__(13195);

__webpack_require__(4831);

__webpack_require__(48168);

__webpack_require__(74451);

__webpack_require__(89332);

__webpack_require__(24904);

__webpack_require__(79947);

__webpack_require__(14332);

__webpack_require__(81356);

__webpack_require__(42548);

__webpack_require__(95896);

__webpack_require__(67155);

__webpack_require__(97740);

__webpack_require__(88513);

__webpack_require__(30144);

__webpack_require__(73357);

__webpack_require__(79393);

__webpack_require__(44261);

__webpack_require__(6408);

__webpack_require__(17325);

__webpack_require__(76642);

__webpack_require__(88458);

__webpack_require__(98072);

__webpack_require__(30593);

__webpack_require__(25408);

__webpack_require__(15496);

__webpack_require__(59987);

__webpack_require__(29117);

__webpack_require__(4962);

__webpack_require__(56785);

__webpack_require__(72282);

__webpack_require__(26486);

__webpack_require__(4346);

__webpack_require__(65129);

__webpack_require__(35433);

__webpack_require__(79313);

__webpack_require__(28081);

__webpack_require__(4292);

__webpack_require__(53019);

__webpack_require__(36832);

__webpack_require__(30435);

__webpack_require__(5123);

__webpack_require__(6217);

__webpack_require__(83093);

__webpack_require__(58674);

__webpack_require__(23618);

__webpack_require__(22720);

__webpack_require__(89040);

__webpack_require__(19998);

__webpack_require__(9583);

__webpack_require__(2010);

__webpack_require__(68289);

__webpack_require__(37329);

__webpack_require__(15640);

__webpack_require__(82248);

__webpack_require__(1198);

__webpack_require__(44750);

__webpack_require__(37703);

__webpack_require__(33739);

__webpack_require__(8872);

__webpack_require__(85603);

__webpack_require__(29282);

__webpack_require__(27253);

__webpack_require__(90760);

__webpack_require__(19070);

__webpack_require__(14677);

__webpack_require__(27803);

__webpack_require__(54995);

__webpack_require__(41017);

__webpack_require__(15536);

__webpack_require__(4631);

__webpack_require__(8264);

__webpack_require__(25227);

__webpack_require__(18599);

__webpack_require__(47678);

__webpack_require__(29001);

__webpack_require__(35160);

__webpack_require__(19371);

__webpack_require__(18923);

__webpack_require__(25259);

__webpack_require__(50481);

__webpack_require__(42398);

__webpack_require__(41153);

__webpack_require__(40986);

__webpack_require__(89865);

__webpack_require__(13927);

__webpack_require__(24393);

__webpack_require__(48334);

__webpack_require__(36457);

__webpack_require__(97282);

__webpack_require__(69608);

__webpack_require__(83411);

__webpack_require__(33474);

__webpack_require__(55339);

__webpack_require__(79845);

__webpack_require__(79336);

__webpack_require__(42528);

__webpack_require__(94343);

__webpack_require__(66963);

__webpack_require__(78579);

__webpack_require__(86063);

__webpack_require__(63605);

__webpack_require__(90483);

__webpack_require__(88780);

__webpack_require__(89755);

__webpack_require__(60669);

__webpack_require__(91921);

__webpack_require__(433);

__webpack_require__(97004);

__webpack_require__(32402);

__webpack_require__(62066);

__webpack_require__(56071);

__webpack_require__(71058);

__webpack_require__(93292);

__webpack_require__(18961);

__webpack_require__(89869);

__webpack_require__(58055);

__webpack_require__(22071);

var path = __webpack_require__(87526);

module.exports = path;

/***/ }),

/***/ 27709:
/***/ ((module) => {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  }

  return it;
};

/***/ }),

/***/ 21892:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(74194);

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  }

  return it;
};

/***/ }),

/***/ 9360:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(65373);

var create = __webpack_require__(1578);

var definePropertyModule = __webpack_require__(45070);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype; // Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
} // add a key to Array.prototype[@@unscopables]


module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};

/***/ }),

/***/ 59607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var charAt = __webpack_require__(36726).charAt; // `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex


module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};

/***/ }),

/***/ 6441:
/***/ ((module) => {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  }

  return it;
};

/***/ }),

/***/ 52943:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(74194);

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  }

  return it;
};

/***/ }),

/***/ 10477:
/***/ ((module) => {

module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

/***/ }),

/***/ 82094:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var NATIVE_ARRAY_BUFFER = __webpack_require__(10477);

var DESCRIPTORS = __webpack_require__(9811);

var global = __webpack_require__(52586);

var isObject = __webpack_require__(74194);

var has = __webpack_require__(38928);

var classof = __webpack_require__(84368);

var createNonEnumerableProperty = __webpack_require__(91705);

var redefine = __webpack_require__(44469);

var defineProperty = __webpack_require__(45070).f;

var getPrototypeOf = __webpack_require__(35651);

var setPrototypeOf = __webpack_require__(40616);

var wellKnownSymbol = __webpack_require__(65373);

var uid = __webpack_require__(97214);

var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG'); // Fixing native typed arrays in Opera Presto crashes the browser, see #595

var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;
var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};
var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView' || has(TypedArrayConstructorsList, klass) || has(BigIntArrayConstructorsList, klass);
};

var isTypedArray = function isTypedArray(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return has(TypedArrayConstructorsList, klass) || has(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function aTypedArray(it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function aTypedArrayConstructor(C) {
  if (setPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) {
    if (has(TypedArrayConstructorsList, NAME)) {
      var TypedArrayConstructor = global[ARRAY];

      if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
        return C;
      }
    }
  }

  throw TypeError('Target is not a typed array constructor');
};

var exportTypedArrayMethod = function exportTypedArrayMethod(KEY, property, forced) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];

    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }

  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportTypedArrayStaticMethod = function exportTypedArrayStaticMethod(KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;

  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];

      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }

    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);
      } catch (error) {
        /* empty */
      }
    } else return;
  }

  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];

    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
} // WebKit bug - typed arrays constructors prototype is Object.prototype


if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };

  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
} // WebKit bug - one more object in Uint8ClampedArray prototype chain


if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, {
    get: function get() {
      return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
    }
  });

  for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) {
      createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
    }
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};

/***/ }),

/***/ 2091:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var global = __webpack_require__(52586);

var DESCRIPTORS = __webpack_require__(9811);

var NATIVE_ARRAY_BUFFER = __webpack_require__(10477);

var createNonEnumerableProperty = __webpack_require__(91705);

var redefineAll = __webpack_require__(3067);

var fails = __webpack_require__(45200);

var anInstance = __webpack_require__(6441);

var toInteger = __webpack_require__(1324);

var toLength = __webpack_require__(49152);

var toIndex = __webpack_require__(55476);

var IEEE754 = __webpack_require__(19500);

var getPrototypeOf = __webpack_require__(35651);

var setPrototypeOf = __webpack_require__(40616);

var getOwnPropertyNames = __webpack_require__(72205).f;

var defineProperty = __webpack_require__(45070).f;

var arrayFill = __webpack_require__(81);

var setToStringTag = __webpack_require__(46736);

var InternalStateModule = __webpack_require__(59351);

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global[DATA_VIEW];
var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var RangeError = global.RangeError;
var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;

var packInt8 = function packInt8(number) {
  return [number & 0xFF];
};

var packInt16 = function packInt16(number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function packInt32(number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function unpackInt32(buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function packFloat32(number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function packFloat64(number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function addGetter(Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, {
    get: function get() {
      return getInternalState(this)[key];
    }
  });
};

var get = function get(view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set = function set(view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);

  for (var i = 0; i < count; i++) {
    bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
  }
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });

    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset
    /* , littleEndian */
    ) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset
    /* , littleEndian */
    ) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  /* eslint-disable no-new -- required for testing */
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1);
  }) || fails(function () {
    new NativeArrayBuffer();
    new NativeArrayBuffer(1.5);
    new NativeArrayBuffer(NaN);
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
    /* eslint-enable no-new -- required for testing */
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };

    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];

    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }

    ArrayBufferPrototype.constructor = $ArrayBuffer;
  } // WebKit bug - the same parent prototype for typed arrays and data view


  if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {
    setPrototypeOf($DataViewPrototype, ObjectPrototype);
  } // iOS Safari 7.x bug


  var testView = new $DataView(new $ArrayBuffer(2));
  var nativeSetInt8 = $DataViewPrototype.setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, {
    unsafe: true
  });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
module.exports = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};

/***/ }),

/***/ 30707:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toObject = __webpack_require__(25769);

var toAbsoluteIndex = __webpack_require__(11652);

var toLength = __webpack_require__(49152);

var min = Math.min; // `Array.prototype.copyWithin` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.copywithin

module.exports = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

/***/ }),

/***/ 81:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toObject = __webpack_require__(25769);

var toAbsoluteIndex = __webpack_require__(11652);

var toLength = __webpack_require__(49152); // `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill


module.exports = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) {
    O[index++] = value;
  }

  return O;
};

/***/ }),

/***/ 80980:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $forEach = __webpack_require__(11729).forEach;

var arrayMethodIsStrict = __webpack_require__(75891);

var STRICT_METHOD = arrayMethodIsStrict('forEach'); // `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach

module.exports = !STRICT_METHOD ? function forEach(callbackfn
/* , thisArg */
) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;

/***/ }),

/***/ 4789:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(81801);

var toObject = __webpack_require__(25769);

var callWithSafeIterationClosing = __webpack_require__(37473);

var isArrayIteratorMethod = __webpack_require__(93061);

var toLength = __webpack_require__(49152);

var createProperty = __webpack_require__(27042);

var getIteratorMethod = __webpack_require__(82093); // `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from


module.exports = function from(arrayLike
/* , mapfn = undefined, thisArg = undefined */
) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2); // if the target is not iterable or it's an array with the default iterator - use a simple case

  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();

    for (; !(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);

    for (; length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }

  result.length = index;
  return result;
};

/***/ }),

/***/ 7255:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(20829);

var toLength = __webpack_require__(49152);

var toAbsoluteIndex = __webpack_require__(11652); // `Array.prototype.{ indexOf, includes }` methods implementation


var createMethod = function createMethod(IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare -- NaN check

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    }
    return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};

/***/ }),

/***/ 11729:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var bind = __webpack_require__(81801);

var IndexedObject = __webpack_require__(68813);

var toObject = __webpack_require__(25769);

var toLength = __webpack_require__(49152);

var arraySpeciesCreate = __webpack_require__(30388);

var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation

var createMethod = function createMethod(TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_OUT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
    var value, result;

    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        value = self[index];
        result = boundFunction(value, index, O);

        if (TYPE) {
          if (IS_MAP) target[index] = result; // map
          else if (result) switch (TYPE) {
              case 3:
                return true;
              // some

              case 5:
                return value;
              // find

              case 6:
                return index;
              // findIndex

              case 2:
                push.call(target, value);
              // filter
            } else switch (TYPE) {
              case 4:
                return false;
              // every

              case 7:
                push.call(target, value);
              // filterOut
            }
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterOut` method
  // https://github.com/tc39/proposal-array-filtering
  filterOut: createMethod(7)
};

/***/ }),

/***/ 58792:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toIndexedObject = __webpack_require__(20829);

var toInteger = __webpack_require__(1324);

var toLength = __webpack_require__(49152);

var arrayMethodIsStrict = __webpack_require__(75891);

var min = Math.min;
var nativeLastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD; // `Array.prototype.lastIndexOf` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof

module.exports = FORCED ? function lastIndexOf(searchElement
/* , fromIndex = @[*-1] */
) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;

  for (; index >= 0; index--) {
    if (index in O && O[index] === searchElement) return index || 0;
  }

  return -1;
} : nativeLastIndexOf;

/***/ }),

/***/ 24188:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(45200);

var wellKnownSymbol = __webpack_require__(65373);

var V8_VERSION = __webpack_require__(54875);

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};

    constructor[SPECIES] = function () {
      return {
        foo: 1
      };
    };

    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};

/***/ }),

/***/ 75891:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fails = __webpack_require__(45200);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
    method.call(null, argument || function () {
      throw 1;
    }, 1);
  });
};

/***/ }),

/***/ 59892:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aFunction = __webpack_require__(27709);

var toObject = __webpack_require__(25769);

var IndexedObject = __webpack_require__(68813);

var toLength = __webpack_require__(49152); // `Array.prototype.{ reduce, reduceRight }` methods implementation


var createMethod = function createMethod(IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }

      index += i;

      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }

    for (; IS_RIGHT ? index >= 0 : length > index; index += i) {
      if (index in self) {
        memo = callbackfn(memo, self[index], index, O);
      }
    }

    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};

/***/ }),

/***/ 30388:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(74194);

var isArray = __webpack_require__(96306);

var wellKnownSymbol = __webpack_require__(65373);

var SPECIES = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate

module.exports = function (originalArray, length) {
  var C;

  if (isArray(originalArray)) {
    C = originalArray.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};

/***/ }),

/***/ 37473:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(52943);

var iteratorClose = __webpack_require__(85636); // call something on iterator step with safe closing on error


module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    iteratorClose(iterator);
    throw error;
  }
};

/***/ }),

/***/ 33469:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(65373);

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function next() {
      return {
        done: !!called++
      };
    },
    'return': function _return() {
      SAFE_CLOSING = true;
    }
  };

  iteratorWithReturn[ITERATOR] = function () {
    return this;
  }; // eslint-disable-next-line no-throw-literal -- required for testing


  Array.from(iteratorWithReturn, function () {
    throw 2;
  });
} catch (error) {
  /* empty */
}

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;

  try {
    var object = {};

    object[ITERATOR] = function () {
      return {
        next: function next() {
          return {
            done: ITERATION_SUPPORT = true
          };
        }
      };
    };

    exec(object);
  } catch (error) {
    /* empty */
  }

  return ITERATION_SUPPORT;
};

/***/ }),

/***/ 700:
/***/ ((module) => {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ 84368:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(14947);

var classofRaw = __webpack_require__(700);

var wellKnownSymbol = __webpack_require__(65373);

var TO_STRING_TAG = wellKnownSymbol('toStringTag'); // ES3 wrong here

var CORRECT_ARGUMENTS = classofRaw(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (error) {
    /* empty */
  }
}; // getting tag from ES6+ `Object.prototype.toString`


module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag // builtinTag case
  : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
  : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

/***/ }),

/***/ 76702:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var defineProperty = __webpack_require__(45070).f;

var create = __webpack_require__(1578);

var redefineAll = __webpack_require__(3067);

var bind = __webpack_require__(81801);

var anInstance = __webpack_require__(6441);

var iterate = __webpack_require__(63244);

var defineIterator = __webpack_require__(64079);

var setSpecies = __webpack_require__(94847);

var DESCRIPTORS = __webpack_require__(9811);

var fastKey = __webpack_require__(60648).fastKey;

var InternalStateModule = __webpack_require__(59351);

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
module.exports = {
  getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate(iterable, that[ADDER], {
        that: that,
        AS_ENTRIES: IS_MAP
      });
    });
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function define(that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index; // change existing entry

      if (entry) {
        entry.value = value; // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;else that.size++; // add to index

        if (index !== 'F') state.index[index] = entry;
      }

      return that;
    };

    var getEntry = function getEntry(that, key) {
      var state = getInternalState(that); // fast case

      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index]; // frozen object case

      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;

        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }

        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;else that.size--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this); // revert to the last existing entry

          while (entry && entry.removed) {
            entry = entry.previous;
          }
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });
    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
      get: function get() {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function setStrong(C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME); // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11

    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last; // revert to the last existing entry

      while (entry && entry.removed) {
        entry = entry.previous;
      } // get next entry


      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      } // return step by kind


      if (kind == 'keys') return {
        value: entry.key,
        done: false
      };
      if (kind == 'values') return {
        value: entry.value,
        done: false
      };
      return {
        value: [entry.key, entry.value],
        done: false
      };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(CONSTRUCTOR_NAME);
  }
};

/***/ }),

/***/ 19026:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var redefineAll = __webpack_require__(3067);

var getWeakData = __webpack_require__(60648).getWeakData;

var anObject = __webpack_require__(52943);

var isObject = __webpack_require__(74194);

var anInstance = __webpack_require__(6441);

var iterate = __webpack_require__(63244);

var ArrayIterationModule = __webpack_require__(11729);

var $has = __webpack_require__(38928);

var InternalStateModule = __webpack_require__(59351);

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function uncaughtFrozenStore(store) {
  return store.frozen || (store.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.entries = [];
};

var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function get(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function has(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.entries.push([key, value]);
  },
  'delete': function _delete(key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) this.entries.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (iterable != undefined) iterate(iterable, that[ADDER], {
        that: that,
        AS_ENTRIES: IS_MAP
      });
    });
    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function define(that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;
      return that;
    };

    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function _delete(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && $has(data, state.id) && delete data[state.id];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && $has(data, state.id);
      }
    });
    redefineAll(C.prototype, IS_MAP ? {
      // 23.3.3.3 WeakMap.prototype.get(key)
      get: function get(key) {
        var state = getInternalState(this);

        if (isObject(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // 23.3.3.5 WeakMap.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // 23.4.3.1 WeakSet.prototype.add(value)
      add: function add(value) {
        return define(this, value, true);
      }
    });
    return C;
  }
};

/***/ }),

/***/ 79524:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var global = __webpack_require__(52586);

var isForced = __webpack_require__(40695);

var redefine = __webpack_require__(44469);

var InternalMetadataModule = __webpack_require__(60648);

var iterate = __webpack_require__(63244);

var anInstance = __webpack_require__(6441);

var isObject = __webpack_require__(74194);

var fails = __webpack_require__(45200);

var checkCorrectnessOfIteration = __webpack_require__(33469);

var setToStringTag = __webpack_require__(46736);

var inheritIfRequired = __webpack_require__(57170);

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function fixMethod(KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
      nativeMethod.call(this, value === 0 ? 0 : value);
      return this;
    } : KEY == 'delete' ? function (key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'get' ? function get(key) {
      return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
    } : KEY == 'has' ? function has(key) {
      return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
    } : function set(key, value) {
      nativeMethod.call(this, key === 0 ? 0 : key, value);
      return this;
    });
  };

  var REPLACE = isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })));

  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.REQUIRED = true;
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing

    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
      new NativeConstructor(iterable);
    }); // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;

      while (index--) {
        $instance[ADDER](index, index);
      }

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], {
          that: that,
          AS_ENTRIES: IS_MAP
        });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({
    global: true,
    forced: Constructor != NativeConstructor
  }, exported);
  setToStringTag(Constructor, CONSTRUCTOR_NAME);
  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
  return Constructor;
};

/***/ }),

/***/ 58376:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(38928);

var ownKeys = __webpack_require__(15732);

var getOwnPropertyDescriptorModule = __webpack_require__(22130);

var definePropertyModule = __webpack_require__(45070);

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};

/***/ }),

/***/ 23264:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(65373);

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;

  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) {
      /* empty */
    }
  }

  return false;
};

/***/ }),

/***/ 20457:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(45200);

module.exports = !fails(function () {
  function F() {
    /* empty */
  }

  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});

/***/ }),

/***/ 9015:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(20877);

var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)
// https://tc39.es/ecma262/#sec-createhtml

module.exports = function (string, tag, attribute, value) {
  var S = String(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

/***/ }),

/***/ 22006:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var IteratorPrototype = __webpack_require__(84239).IteratorPrototype;

var create = __webpack_require__(1578);

var createPropertyDescriptor = __webpack_require__(22424);

var setToStringTag = __webpack_require__(46736);

var Iterators = __webpack_require__(9806);

var returnThis = function returnThis() {
  return this;
};

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, {
    next: createPropertyDescriptor(1, next)
  });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};

/***/ }),

/***/ 91705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(9811);

var definePropertyModule = __webpack_require__(45070);

var createPropertyDescriptor = __webpack_require__(22424);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ 22424:
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ 27042:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toPrimitive = __webpack_require__(36238);

var definePropertyModule = __webpack_require__(45070);

var createPropertyDescriptor = __webpack_require__(22424);

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
};

/***/ }),

/***/ 45611:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fails = __webpack_require__(45200);

var padStart = __webpack_require__(72594).start;

var abs = Math.abs;
var DatePrototype = Date.prototype;
var getTime = DatePrototype.getTime;
var nativeDateToISOString = DatePrototype.toISOString; // `Date.prototype.toISOString` method implementation
// https://tc39.es/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit fails here:

module.exports = fails(function () {
  return nativeDateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  nativeDateToISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var date = this;
  var year = date.getUTCFullYear();
  var milliseconds = date.getUTCMilliseconds();
  var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
  return sign + padStart(abs(year), sign ? 6 : 4, 0) + '-' + padStart(date.getUTCMonth() + 1, 2, 0) + '-' + padStart(date.getUTCDate(), 2, 0) + 'T' + padStart(date.getUTCHours(), 2, 0) + ':' + padStart(date.getUTCMinutes(), 2, 0) + ':' + padStart(date.getUTCSeconds(), 2, 0) + '.' + padStart(milliseconds, 3, 0) + 'Z';
} : nativeDateToISOString;

/***/ }),

/***/ 57368:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var anObject = __webpack_require__(52943);

var toPrimitive = __webpack_require__(36238);

module.exports = function (hint) {
  if (hint !== 'string' && hint !== 'number' && hint !== 'default') {
    throw TypeError('Incorrect hint');
  }

  return toPrimitive(anObject(this), hint !== 'number');
};

/***/ }),

/***/ 64079:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createIteratorConstructor = __webpack_require__(22006);

var getPrototypeOf = __webpack_require__(35651);

var setPrototypeOf = __webpack_require__(40616);

var setToStringTag = __webpack_require__(46736);

var createNonEnumerableProperty = __webpack_require__(91705);

var redefine = __webpack_require__(44469);

var wellKnownSymbol = __webpack_require__(65373);

var IS_PURE = __webpack_require__(58855);

var Iterators = __webpack_require__(9806);

var IteratorsCore = __webpack_require__(84239);

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function returnThis() {
  return this;
};

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function getIterationMethod(KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];

    switch (KIND) {
      case KEYS:
        return function keys() {
          return new IteratorConstructor(this, KIND);
        };

      case VALUES:
        return function values() {
          return new IteratorConstructor(this, KIND);
        };

      case ENTRIES:
        return function entries() {
          return new IteratorConstructor(this, KIND);
        };
    }

    return function () {
      return new IteratorConstructor(this);
    };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY; // fix native

  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));

    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      } // Set @@toStringTag to native iterators


      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;

    defaultIterator = function values() {
      return nativeIterator.call(this);
    };
  } // define iterator


  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }

  Iterators[NAME] = defaultIterator; // export additional methods

  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({
      target: NAME,
      proto: true,
      forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
    }, methods);
  }

  return methods;
};

/***/ }),

/***/ 56564:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(87526);

var has = __webpack_require__(38928);

var wrappedWellKnownSymbolModule = __webpack_require__(12002);

var defineProperty = __webpack_require__(45070).f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};

/***/ }),

/***/ 9811:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(45200); // Detect IE8's incomplete defineProperty implementation


module.exports = !fails(function () {
  return Object.defineProperty({}, 1, {
    get: function get() {
      return 7;
    }
  })[1] != 7;
});

/***/ }),

/***/ 3677:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var isObject = __webpack_require__(74194);

var document = global.document; // typeof document.createElement is 'object' in old IE

var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};

/***/ }),

/***/ 15399:
/***/ ((module) => {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};

/***/ }),

/***/ 5236:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(62060);

module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);

/***/ }),

/***/ 31292:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(700);

var global = __webpack_require__(52586);

module.exports = classof(global.process) == 'process';

/***/ }),

/***/ 9378:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var userAgent = __webpack_require__(62060);

module.exports = /web0s(?!.*chrome)/i.test(userAgent);

/***/ }),

/***/ 62060:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(40866);

module.exports = getBuiltIn('navigator', 'userAgent') || '';

/***/ }),

/***/ 54875:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var userAgent = __webpack_require__(62060);

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);

  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;

/***/ }),

/***/ 63148:
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];

/***/ }),

/***/ 53064:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var getOwnPropertyDescriptor = __webpack_require__(22130).f;

var createNonEnumerableProperty = __webpack_require__(91705);

var redefine = __webpack_require__(44469);

var setGlobal = __webpack_require__(33640);

var copyConstructorProperties = __webpack_require__(58376);

var isForced = __webpack_require__(40695);
/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/


module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;

  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }

  if (target) for (key in source) {
    sourceProperty = source[key];

    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];

    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    } // add a flag to not completely full polyfills


    if (options.sham || targetProperty && targetProperty.sham) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    } // extend global


    redefine(target, key, sourceProperty, options);
  }
};

/***/ }),

/***/ 45200:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};

/***/ }),

/***/ 54059:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // TODO: Remove from `core-js@4` since it's moved to entry points

__webpack_require__(30144);

var redefine = __webpack_require__(44469);

var fails = __webpack_require__(45200);

var wellKnownSymbol = __webpack_require__(65373);

var regexpExec = __webpack_require__(34646);

var createNonEnumerableProperty = __webpack_require__(91705);

var SPECIES = wellKnownSymbol('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
}); // IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0

var REPLACE_KEEPS_$0 = function () {
  return 'a'.replace(/./, '$0') === '$0';
}();

var REPLACE = wellKnownSymbol('replace'); // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string

var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }

  return false;
}(); // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper


var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  // eslint-disable-next-line regexp/no-empty-group -- required for testing
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {}; // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.

      re.constructor = {};

      re.constructor[SPECIES] = function () {
        return re;
      };

      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () {
      execCalled = true;
      return null;
    };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];
    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return regexMethod.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return regexMethod.call(string, this);
    });
  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};

/***/ }),

/***/ 45541:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isArray = __webpack_require__(96306);

var toLength = __webpack_require__(49152);

var bind = __webpack_require__(81801); // `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray


var flattenIntoArray = function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
  var element;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
};

module.exports = flattenIntoArray;

/***/ }),

/***/ 10940:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(45200);

module.exports = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});

/***/ }),

/***/ 81801:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aFunction = __webpack_require__(27709); // optional / simple context binding


module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 0:
      return function () {
        return fn.call(that);
      };

    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ 89723:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var aFunction = __webpack_require__(27709);

var isObject = __webpack_require__(74194);

var slice = [].slice;
var factories = {};

var construct = function construct(C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) {
      list[i] = 'a[' + i + ']';
    } // eslint-disable-next-line no-new-func -- we have no proper alternatives, IE8- only


    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  }

  return factories[argsLength](C, args);
}; // `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind


module.exports = Function.bind || function bind(that
/* , ...args */
) {
  var fn = aFunction(this);
  var partArgs = slice.call(arguments, 1);

  var boundFunction = function bound()
  /* args... */
  {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };

  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};

/***/ }),

/***/ 40866:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var path = __webpack_require__(87526);

var global = __webpack_require__(52586);

var aFunction = function aFunction(variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};

/***/ }),

/***/ 82093:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(84368);

var Iterators = __webpack_require__(9806);

var wellKnownSymbol = __webpack_require__(65373);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ 25221:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(52943);

var getIteratorMethod = __webpack_require__(82093);

module.exports = function (it) {
  var iteratorMethod = getIteratorMethod(it);

  if (typeof iteratorMethod != 'function') {
    throw TypeError(String(it) + ' is not iterable');
  }

  return anObject(iteratorMethod.call(it));
};

/***/ }),

/***/ 79854:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toObject = __webpack_require__(25769);

var floor = Math.floor;
var replace = ''.replace;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g; // https://tc39.es/ecma262/#sec-getsubstitution

module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }

  return replace.call(replacement, symbols, function (match, ch) {
    var capture;

    switch (ch.charAt(0)) {
      case '$':
        return '$';

      case '&':
        return matched;

      case '`':
        return str.slice(0, position);

      case "'":
        return str.slice(tailPos);

      case '<':
        capture = namedCaptures[ch.slice(1, -1)];
        break;

      default:
        // \d\d?
        var n = +ch;
        if (n === 0) return match;

        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
          return match;
        }

        capture = captures[n - 1];
    }

    return capture === undefined ? '' : capture;
  });
};

/***/ }),

/***/ 52586:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var check = function check(it) {
  return it && it.Math == Math && it;
}; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


module.exports =
/* global globalThis -- safe */
check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) || // eslint-disable-next-line no-new-func -- fallback
function () {
  return this;
}() || Function('return this')();

/***/ }),

/***/ 38928:
/***/ ((module) => {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ 29841:
/***/ ((module) => {

module.exports = {};

/***/ }),

/***/ 19239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

module.exports = function (a, b) {
  var console = global.console;

  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};

/***/ }),

/***/ 74809:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(40866);

module.exports = getBuiltIn('document', 'documentElement');

/***/ }),

/***/ 30385:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(9811);

var fails = __webpack_require__(45200);

var createElement = __webpack_require__(3677); // Thank's IE8 for his funny defineProperty


module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ 19500:
/***/ ((module) => {

// IEEE754 conversions based on https://github.com/feross/ieee754
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function pack(number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number); // eslint-disable-next-line no-self-compare -- NaN check

  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare -- NaN check
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);

    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }

    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }

    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }

    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }

  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8) {
    ;
  }

  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;

  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8) {
    ;
  }

  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function unpack(buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;

  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8) {
    ;
  }

  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;

  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8) {
    ;
  }

  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  }

  return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

module.exports = {
  pack: pack,
  unpack: unpack
};

/***/ }),

/***/ 68813:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(45200);

var classof = __webpack_require__(700);

var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

/***/ }),

/***/ 57170:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(74194);

var setPrototypeOf = __webpack_require__(40616); // makes subclassing work correct for wrapped built-ins


module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if ( // it can work only with native `setPrototypeOf`
  setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
  typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};

/***/ }),

/***/ 60735:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var store = __webpack_require__(2950);

var functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper

if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;

/***/ }),

/***/ 60648:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hiddenKeys = __webpack_require__(29841);

var isObject = __webpack_require__(74194);

var has = __webpack_require__(38928);

var defineProperty = __webpack_require__(45070).f;

var uid = __webpack_require__(97214);

var FREEZING = __webpack_require__(10940);

var METADATA = uid('meta');
var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var setMetadata = function setMetadata(it) {
  defineProperty(it, METADATA, {
    value: {
      objectID: 'O' + ++id,
      // object ID
      weakData: {} // weak collections IDs

    }
  });
};

var fastKey = function fastKey(it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMetadata(it); // return object ID
  }

  return it[METADATA].objectID;
};

var getWeakData = function getWeakData(it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMetadata(it); // return the store of weak collections IDs
  }

  return it[METADATA].weakData;
}; // add metadata on freeze-family methods calling


var onFreeze = function onFreeze(it) {
  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};

var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};
hiddenKeys[METADATA] = true;

/***/ }),

/***/ 59351:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_WEAK_MAP = __webpack_require__(7740);

var global = __webpack_require__(52586);

var isObject = __webpack_require__(74194);

var createNonEnumerableProperty = __webpack_require__(91705);

var objectHas = __webpack_require__(38928);

var shared = __webpack_require__(2950);

var sharedKey = __webpack_require__(60759);

var hiddenKeys = __webpack_require__(29841);

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function enforce(it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function getterFor(TYPE) {
  return function (it) {
    var state;

    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    }

    return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;

  set = function set(it, metadata) {
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };

  get = function get(it) {
    return wmget.call(store, it) || {};
  };

  has = function has(it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;

  set = function set(it, metadata) {
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };

  get = function get(it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };

  has = function has(it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};

/***/ }),

/***/ 93061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(65373);

var Iterators = __webpack_require__(9806);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype; // check on default Array iterator

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};

/***/ }),

/***/ 96306:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(700); // `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray


module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};

/***/ }),

/***/ 40695:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(45200);

var replacement = /#|\.prototype\./;

var isForced = function isForced(feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';
module.exports = isForced;

/***/ }),

/***/ 56616:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(74194);

var floor = Math.floor; // `Number.isInteger` method implementation
// https://tc39.es/ecma262/#sec-number.isinteger

module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),

/***/ 74194:
/***/ ((module) => {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ 58855:
/***/ ((module) => {

module.exports = false;

/***/ }),

/***/ 26582:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(74194);

var classof = __webpack_require__(700);

var wellKnownSymbol = __webpack_require__(65373);

var MATCH = wellKnownSymbol('match'); // `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp

module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};

/***/ }),

/***/ 63244:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(52943);

var isArrayIteratorMethod = __webpack_require__(93061);

var toLength = __webpack_require__(49152);

var bind = __webpack_require__(81801);

var getIteratorMethod = __webpack_require__(82093);

var iteratorClose = __webpack_require__(85636);

var Result = function Result(stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function stop(condition) {
    if (iterator) iteratorClose(iterator);
    return new Result(true, condition);
  };

  var callFn = function callFn(value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    }

    return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators

    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && result instanceof Result) return result;
      }

      return new Result(false);
    }

    iterator = iterFn.call(iterable);
  }

  next = iterator.next;

  while (!(step = next.call(iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator);
      throw error;
    }

    if (typeof result == 'object' && result && result instanceof Result) return result;
  }

  return new Result(false);
};

/***/ }),

/***/ 85636:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(52943);

module.exports = function (iterator) {
  var returnMethod = iterator['return'];

  if (returnMethod !== undefined) {
    return anObject(returnMethod.call(iterator)).value;
  }
};

/***/ }),

/***/ 84239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fails = __webpack_require__(45200);

var getPrototypeOf = __webpack_require__(35651);

var createNonEnumerableProperty = __webpack_require__(91705);

var has = __webpack_require__(38928);

var wellKnownSymbol = __webpack_require__(65373);

var IS_PURE = __webpack_require__(58855);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function returnThis() {
  return this;
}; // `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object


var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
  var test = {}; // FF44- legacy iterators case

  return IteratorPrototype[ITERATOR].call(test) !== test;
});
if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};

/***/ }),

/***/ 9806:
/***/ ((module) => {

module.exports = {};

/***/ }),

/***/ 91437:
/***/ ((module) => {

var nativeExpm1 = Math.expm1;
var exp = Math.exp; // `Math.expm1` method implementation
// https://tc39.es/ecma262/#sec-math.expm1

module.exports = !nativeExpm1 // Old FF bug
|| nativeExpm1(10) > 22025.465794806719 || nativeExpm1(10) < 22025.4657948067165168 // Tor Browser bug
|| nativeExpm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
} : nativeExpm1;

/***/ }),

/***/ 72896:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var sign = __webpack_require__(31874);

var abs = Math.abs;
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function roundTiesToEven(n) {
  return n + 1 / EPSILON - 1 / EPSILON;
}; // `Math.fround` method implementation
// https://tc39.es/ecma262/#sec-math.fround


module.exports = Math.fround || function fround(x) {
  var $abs = abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs); // eslint-disable-next-line no-self-compare -- NaN check

  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

/***/ }),

/***/ 32599:
/***/ ((module) => {

var log = Math.log; // `Math.log1p` method implementation
// https://tc39.es/ecma262/#sec-math.log1p

module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
};

/***/ }),

/***/ 31874:
/***/ ((module) => {

// `Math.sign` method implementation
// https://tc39.es/ecma262/#sec-math.sign
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare -- NaN check
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),

/***/ 50119:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var getOwnPropertyDescriptor = __webpack_require__(22130).f;

var macrotask = __webpack_require__(39250).set;

var IS_IOS = __webpack_require__(5236);

var IS_WEBOS_WEBKIT = __webpack_require__(9378);

var IS_NODE = __webpack_require__(31292);

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var document = global.document;
var process = global.process;
var Promise = global.Promise; // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`

var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
var flush, head, last, notify, toggle, node, promise, then; // modern engines have queueMicrotask method

if (!queueMicrotask) {
  flush = function flush() {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (error) {
        if (head) notify();else last = undefined;
        throw error;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898


  if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver && document) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, {
      characterData: true
    });

    notify = function notify() {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    then = promise.then;

    notify = function notify() {
      then.call(promise, flush);
    }; // Node.js without promises

  } else if (IS_NODE) {
    notify = function notify() {
      process.nextTick(flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function notify() {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = {
    fn: fn,
    next: undefined
  };
  if (last) last.next = task;

  if (!head) {
    head = task;
    notify();
  }

  last = task;
};

/***/ }),

/***/ 17088:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

module.exports = global.Promise;

/***/ }),

/***/ 67893:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_NODE = __webpack_require__(31292);

var V8_VERSION = __webpack_require__(54875);

var fails = __webpack_require__(45200);

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  /* global Symbol -- required for testing */
  return !Symbol.sham && ( // Chrome 38 Symbol has incorrect toString conversion
  // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  IS_NODE ? V8_VERSION === 38 : V8_VERSION > 37 && V8_VERSION < 41);
});

/***/ }),

/***/ 21486:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(45200);

var wellKnownSymbol = __webpack_require__(65373);

var IS_PURE = __webpack_require__(58855);

var ITERATOR = wellKnownSymbol('iterator');
module.exports = !fails(function () {
  var url = new URL('b?a=1&b=2&c=3', 'http://a');
  var searchParams = url.searchParams;
  var result = '';
  url.pathname = 'c%20d';
  searchParams.forEach(function (value, key) {
    searchParams['delete']('b');
    result += key + value;
  });
  return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR] // throws in Edge
  || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b' // not punycoded in Edge
  || new URL('http://').host !== 'xn--e1aybc' // not escaped in Chrome 62-
  || new URL('http://a#').hash !== '#%D0%B1' // fails in Chrome 66-
  || result !== 'a1c3' // throws in Safari
  || new URL('http://x', undefined).host !== 'x';
});

/***/ }),

/***/ 7740:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var inspectSource = __webpack_require__(60735);

var WeakMap = global.WeakMap;
module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

/***/ }),

/***/ 16593:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var aFunction = __webpack_require__(27709);

var PromiseCapability = function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}; // 25.4.1.5 NewPromiseCapability(C)


module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),

/***/ 41029:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isRegExp = __webpack_require__(26582);

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  }

  return it;
};

/***/ }),

/***/ 84247:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var globalIsFinite = global.isFinite; // `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite

module.exports = Number.isFinite || function isFinite(it) {
  return typeof it == 'number' && globalIsFinite(it);
};

/***/ }),

/***/ 99722:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var trim = __webpack_require__(86392).trim;

var whitespaces = __webpack_require__(2429);

var $parseFloat = global.parseFloat;
var FORCED = 1 / $parseFloat(whitespaces + '-0') !== -Infinity; // `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string

module.exports = FORCED ? function parseFloat(string) {
  var trimmedString = trim(String(string));
  var result = $parseFloat(trimmedString);
  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),

/***/ 87148:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var trim = __webpack_require__(86392).trim;

var whitespaces = __webpack_require__(2429);

var $parseInt = global.parseInt;
var hex = /^[+-]?0[Xx]/;
var FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22; // `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix

module.exports = FORCED ? function parseInt(string, radix) {
  var S = trim(String(string));
  return $parseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));
} : $parseInt;

/***/ }),

/***/ 99103:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var DESCRIPTORS = __webpack_require__(9811);

var fails = __webpack_require__(45200);

var objectKeys = __webpack_require__(12656);

var getOwnPropertySymbolsModule = __webpack_require__(32693);

var propertyIsEnumerableModule = __webpack_require__(2962);

var toObject = __webpack_require__(25769);

var IndexedObject = __webpack_require__(68813);

var nativeAssign = Object.assign;
var defineProperty = Object.defineProperty; // `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign

module.exports = !nativeAssign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && nativeAssign({
    b: 1
  }, nativeAssign(defineProperty({}, 'a', {
    enumerable: true,
    get: function get() {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), {
    b: 2
  })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)

  var A = {};
  var B = {};
  /* global Symbol -- required for testing */

  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) {
    B[chr] = chr;
  });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars -- required for `.length`
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;

  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  }

  return T;
} : nativeAssign;

/***/ }),

/***/ 1578:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(52943);

var defineProperties = __webpack_require__(70984);

var enumBugKeys = __webpack_require__(63148);

var hiddenKeys = __webpack_require__(29841);

var html = __webpack_require__(74809);

var documentCreateElement = __webpack_require__(3677);

var sharedKey = __webpack_require__(60759);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function EmptyConstructor() {
  /* empty */
};

var scriptTag = function scriptTag(content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
}; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX(activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak

  return temp;
}; // Create object with fake `null` prototype: use iframe Object with cleared prototype


var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
}; // Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug


var activeXDocument;

var _NullProtoObject = function NullProtoObject() {
  try {
    /* global ActiveXObject -- old IE */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) {
    /* ignore */
  }

  _NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;

  while (length--) {
    delete _NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  }

  return _NullProtoObject();
};

hiddenKeys[IE_PROTO] = true; // `Object.create` method
// https://tc39.es/ecma262/#sec-object.create

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = _NullProtoObject();

  return Properties === undefined ? result : defineProperties(result, Properties);
};

/***/ }),

/***/ 70984:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(9811);

var definePropertyModule = __webpack_require__(45070);

var anObject = __webpack_require__(52943);

var objectKeys = __webpack_require__(12656); // `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties


module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;

  while (length > index) {
    definePropertyModule.f(O, key = keys[index++], Properties[key]);
  }

  return O;
};

/***/ }),

/***/ 45070:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(9811);

var IE8_DOM_DEFINE = __webpack_require__(30385);

var anObject = __webpack_require__(52943);

var toPrimitive = __webpack_require__(36238);

var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty

exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ 22130:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(9811);

var propertyIsEnumerableModule = __webpack_require__(2962);

var createPropertyDescriptor = __webpack_require__(22424);

var toIndexedObject = __webpack_require__(20829);

var toPrimitive = __webpack_require__(36238);

var has = __webpack_require__(38928);

var IE8_DOM_DEFINE = __webpack_require__(30385);

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) {
    /* empty */
  }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};

/***/ }),

/***/ 62020:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toIndexedObject = __webpack_require__(20829);

var nativeGetOwnPropertyNames = __webpack_require__(72205).f;

var toString = {}.toString;
var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
}; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
};

/***/ }),

/***/ 72205:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(67178);

var enumBugKeys = __webpack_require__(63148);

var hiddenKeys = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};

/***/ }),

/***/ 32693:
/***/ ((__unused_webpack_module, exports) => {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ 35651:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(38928);

var toObject = __webpack_require__(25769);

var sharedKey = __webpack_require__(60759);

var CORRECT_PROTOTYPE_GETTER = __webpack_require__(20457);

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype; // `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof

module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectPrototype : null;
};

/***/ }),

/***/ 67178:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var has = __webpack_require__(38928);

var toIndexedObject = __webpack_require__(20829);

var indexOf = __webpack_require__(7255).indexOf;

var hiddenKeys = __webpack_require__(29841);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) {
    !has(hiddenKeys, key) && has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys


  while (names.length > i) {
    if (has(O, key = names[i++])) {
      ~indexOf(result, key) || result.push(key);
    }
  }

  return result;
};

/***/ }),

/***/ 12656:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var internalObjectKeys = __webpack_require__(67178);

var enumBugKeys = __webpack_require__(63148); // `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys


module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};

/***/ }),

/***/ 2962:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
  1: 2
}, 1); // `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable

exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

/***/ }),

/***/ 70629:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var IS_PURE = __webpack_require__(58855);

var global = __webpack_require__(52586);

var fails = __webpack_require__(45200); // Forced replacement object prototype accessors methods


module.exports = IS_PURE || !fails(function () {
  var key = Math.random(); // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call -- required for testing

  __defineSetter__.call(null, key, function () {
    /* empty */
  });

  delete global[key];
});

/***/ }),

/***/ 40616:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-proto -- safe */
var anObject = __webpack_require__(52943);

var aPossiblePrototype = __webpack_require__(21892); // `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.


module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;

  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) {
    /* empty */
  }

  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
    return O;
  };
}() : undefined);

/***/ }),

/***/ 27758:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(9811);

var objectKeys = __webpack_require__(12656);

var toIndexedObject = __webpack_require__(20829);

var propertyIsEnumerable = __webpack_require__(2962).f; // `Object.{ entries, values }` methods implementation


var createMethod = function createMethod(TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod(false)
};

/***/ }),

/***/ 43024:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var TO_STRING_TAG_SUPPORT = __webpack_require__(14947);

var classof = __webpack_require__(84368); // `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring


module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};

/***/ }),

/***/ 15732:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getBuiltIn = __webpack_require__(40866);

var getOwnPropertyNamesModule = __webpack_require__(72205);

var getOwnPropertySymbolsModule = __webpack_require__(32693);

var anObject = __webpack_require__(52943); // all object keys, includes non-enumerable and symbols


module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

/***/ }),

/***/ 87526:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

module.exports = global;

/***/ }),

/***/ 32780:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return {
      error: false,
      value: exec()
    };
  } catch (error) {
    return {
      error: true,
      value: error
    };
  }
};

/***/ }),

/***/ 28982:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(52943);

var isObject = __webpack_require__(74194);

var newPromiseCapability = __webpack_require__(16593);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),

/***/ 3067:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var redefine = __webpack_require__(44469);

module.exports = function (target, src, options) {
  for (var key in src) {
    redefine(target, key, src[key], options);
  }

  return target;
};

/***/ }),

/***/ 44469:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var createNonEnumerableProperty = __webpack_require__(91705);

var has = __webpack_require__(38928);

var setGlobal = __webpack_require__(33640);

var inspectSource = __webpack_require__(60735);

var InternalStateModule = __webpack_require__(59351);

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');
(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;

  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }

    state = enforceInternalState(value);

    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }

  if (O === global) {
    if (simple) O[key] = value;else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }

  if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});

/***/ }),

/***/ 3414:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(700);

var regexpExec = __webpack_require__(34646); // `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec


module.exports = function (R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};

/***/ }),

/***/ 34646:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var regexpFlags = __webpack_require__(61089);

var stickyHelpers = __webpack_require__(11426);

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
}();

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET; // nonparticipating capturing group, copied from es5-shim's String#split patch.
// eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing

var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');

      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex); // Support anchored sticky behavior.

      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      } // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.


      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

/***/ }),

/***/ 61089:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var anObject = __webpack_require__(52943); // `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags


module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),

/***/ 11426:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var fails = __webpack_require__(45200); // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.


function RE(s, f) {
  return RegExp(s, f);
}

exports.UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});
exports.BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});

/***/ }),

/***/ 20877:
/***/ ((module) => {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};

/***/ }),

/***/ 70871:
/***/ ((module) => {

// `SameValue` abstract operation
// https://tc39.es/ecma262/#sec-samevalue
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare -- NaN check
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),

/***/ 33640:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var createNonEnumerableProperty = __webpack_require__(91705);

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  }

  return value;
};

/***/ }),

/***/ 94847:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var getBuiltIn = __webpack_require__(40866);

var definePropertyModule = __webpack_require__(45070);

var wellKnownSymbol = __webpack_require__(65373);

var DESCRIPTORS = __webpack_require__(9811);

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function get() {
        return this;
      }
    });
  }
};

/***/ }),

/***/ 46736:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(45070).f;

var has = __webpack_require__(38928);

var wellKnownSymbol = __webpack_require__(65373);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, {
      configurable: true,
      value: TAG
    });
  }
};

/***/ }),

/***/ 60759:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var shared = __webpack_require__(14707);

var uid = __webpack_require__(97214);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};

/***/ }),

/***/ 2950:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var setGlobal = __webpack_require__(33640);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});
module.exports = store;

/***/ }),

/***/ 14707:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var IS_PURE = __webpack_require__(58855);

var store = __webpack_require__(2950);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.9.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ 30646:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var anObject = __webpack_require__(52943);

var aFunction = __webpack_require__(27709);

var wellKnownSymbol = __webpack_require__(65373);

var SPECIES = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor

module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};

/***/ }),

/***/ 28234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(45200); // check the existence of a method, lowercase
// of a tag and escaping quotes in arguments


module.exports = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};

/***/ }),

/***/ 36726:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(1324);

var requireObjectCoercible = __webpack_require__(20877); // `String.prototype.{ codePointAt, at }` methods implementation


var createMethod = function createMethod(CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};

/***/ }),

/***/ 82898:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/zloirock/core-js/issues/280
var userAgent = __webpack_require__(62060); // eslint-disable-next-line unicorn/no-unsafe-regex -- safe


module.exports = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);

/***/ }),

/***/ 72594:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(49152);

var repeat = __webpack_require__(90971);

var requireObjectCoercible = __webpack_require__(20877);

var ceil = Math.ceil; // `String.prototype.{ padStart, padEnd }` methods implementation

var createMethod = function createMethod(IS_END) {
  return function ($this, maxLength, fillString) {
    var S = String(requireObjectCoercible($this));
    var stringLength = S.length;
    var fillStr = fillString === undefined ? ' ' : String(fillString);
    var intMaxLength = toLength(maxLength);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr == '') return S;
    fillLen = intMaxLength - stringLength;
    stringFiller = repeat.call(fillStr, ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
    return IS_END ? S + stringFiller : stringFiller + S;
  };
};

module.exports = {
  // `String.prototype.padStart` method
  // https://tc39.es/ecma262/#sec-string.prototype.padstart
  start: createMethod(false),
  // `String.prototype.padEnd` method
  // https://tc39.es/ecma262/#sec-string.prototype.padend
  end: createMethod(true)
};

/***/ }),

/***/ 97983:
/***/ ((module) => {

"use strict";
 // based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80

var delimiter = '-'; // '\x2D'

var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars

var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;
/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */

var ucs2decode = function ucs2decode(string) {
  var output = [];
  var counter = 0;
  var length = string.length;

  while (counter < length) {
    var value = string.charCodeAt(counter++);

    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = string.charCodeAt(counter++);

      if ((extra & 0xFC00) == 0xDC00) {
        // Low surrogate.
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }

  return output;
};
/**
 * Converts a digit/integer into a basic code point.
 */


var digitToBasic = function digitToBasic(digit) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26);
};
/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */


var adapt = function adapt(delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);

  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }

  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};
/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */
// eslint-disable-next-line max-statements -- TODO


var encode = function encode(input) {
  var output = []; // Convert the input in UCS-2 to an array of Unicode code points.

  input = ucs2decode(input); // Cache the length.

  var inputLength = input.length; // Initialize the state.

  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue; // Handle the basic code points.

  for (i = 0; i < input.length; i++) {
    currentValue = input[i];

    if (currentValue < 0x80) {
      output.push(stringFromCharCode(currentValue));
    }
  }

  var basicLength = output.length; // number of basic code points.

  var handledCPCount = basicLength; // number of code points that have been handled;
  // Finish the basic string with a delimiter unless it's empty.

  if (basicLength) {
    output.push(delimiter);
  } // Main encoding loop:


  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next larger one:
    var m = maxInt;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];

      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.


    var handledCPCountPlusOne = handledCPCount + 1;

    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      throw RangeError(OVERFLOW_ERROR);
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];

      if (currentValue < n && ++delta > maxInt) {
        throw RangeError(OVERFLOW_ERROR);
      }

      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer.
        var q = delta;

        for (var k = base;;
        /* no condition */
        k += base) {
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q < t) break;
          var qMinusT = q - t;
          var baseMinusT = base - t;
          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor(qMinusT / baseMinusT);
        }

        output.push(stringFromCharCode(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }

    ++delta;
    ++n;
  }

  return output.join('');
};

module.exports = function (input) {
  var encoded = [];
  var labels = input.toLowerCase().replace(regexSeparators, ".").split('.');
  var i, label;

  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
  }

  return encoded.join('.');
};

/***/ }),

/***/ 90971:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toInteger = __webpack_require__(1324);

var requireObjectCoercible = __webpack_require__(20877); // `String.prototype.repeat` method implementation
// https://tc39.es/ecma262/#sec-string.prototype.repeat


module.exports = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');

  for (; n > 0; (n >>>= 1) && (str += str)) {
    if (n & 1) result += str;
  }

  return result;
};

/***/ }),

/***/ 17273:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fails = __webpack_require__(45200);

var whitespaces = __webpack_require__(2429);

var non = "\u200B\x85\u180E"; // check that a method works with the correct list
// of whitespaces and has a correct name

module.exports = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};

/***/ }),

/***/ 86392:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(20877);

var whitespaces = __webpack_require__(2429);

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

var createMethod = function createMethod(TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};

/***/ }),

/***/ 39250:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var fails = __webpack_require__(45200);

var bind = __webpack_require__(81801);

var html = __webpack_require__(74809);

var createElement = __webpack_require__(3677);

var IS_IOS = __webpack_require__(5236);

var IS_NODE = __webpack_require__(31292);

var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function run(id) {
  // eslint-disable-next-line no-prototype-builtins -- safe
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function runner(id) {
  return function () {
    run(id);
  };
};

var listener = function listener(event) {
  run(event.data);
};

var post = function post(id) {
  // old engines have not location.origin
  global.postMessage(id + '', location.protocol + '//' + location.host);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func -- spec requirement
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };

    defer(counter);
    return counter;
  };

  clear = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (IS_NODE) {
    defer = function defer(id) {
      process.nextTick(runner(id));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function defer(id) {
      Dispatch.now(runner(id));
    }; // Browsers with MessageChannel, includes WebWorkers
    // except iOS - https://github.com/zloirock/core-js/issues/624

  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && location && location.protocol !== 'file:' && !fails(post)) {
    defer = post;
    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function defer(id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    }; // Rest old browsers

  } else {
    defer = function defer(id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};

/***/ }),

/***/ 84353:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classof = __webpack_require__(700); // `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue


module.exports = function (value) {
  if (typeof value != 'number' && classof(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }

  return +value;
};

/***/ }),

/***/ 11652:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(1324);

var max = Math.max;
var min = Math.min; // Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

/***/ }),

/***/ 55476:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(1324);

var toLength = __webpack_require__(49152); // `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex


module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};

/***/ }),

/***/ 20829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(68813);

var requireObjectCoercible = __webpack_require__(20877);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};

/***/ }),

/***/ 1324:
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor; // `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger

module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

/***/ }),

/***/ 49152:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(1324);

var min = Math.min; // `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength

module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

/***/ }),

/***/ 25769:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var requireObjectCoercible = __webpack_require__(20877); // `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject


module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};

/***/ }),

/***/ 29575:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toPositiveInteger = __webpack_require__(27895);

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};

/***/ }),

/***/ 27895:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toInteger = __webpack_require__(1324);

module.exports = function (it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};

/***/ }),

/***/ 36238:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(74194); // `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ 14947:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(65373);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};
test[TO_STRING_TAG] = 'z';
module.exports = String(test) === '[object z]';

/***/ }),

/***/ 81767:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var global = __webpack_require__(52586);

var DESCRIPTORS = __webpack_require__(9811);

var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(59225);

var ArrayBufferViewCore = __webpack_require__(82094);

var ArrayBufferModule = __webpack_require__(2091);

var anInstance = __webpack_require__(6441);

var createPropertyDescriptor = __webpack_require__(22424);

var createNonEnumerableProperty = __webpack_require__(91705);

var toLength = __webpack_require__(49152);

var toIndex = __webpack_require__(55476);

var toOffset = __webpack_require__(29575);

var toPrimitive = __webpack_require__(36238);

var has = __webpack_require__(38928);

var classof = __webpack_require__(84368);

var isObject = __webpack_require__(74194);

var create = __webpack_require__(1578);

var setPrototypeOf = __webpack_require__(40616);

var getOwnPropertyNames = __webpack_require__(72205).f;

var typedArrayFrom = __webpack_require__(22524);

var forEach = __webpack_require__(11729).forEach;

var setSpecies = __webpack_require__(94847);

var definePropertyModule = __webpack_require__(45070);

var getOwnPropertyDescriptorModule = __webpack_require__(22130);

var InternalStateModule = __webpack_require__(59351);

var inheritIfRequired = __webpack_require__(57170);

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError = global.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function fromList(C, list) {
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);

  while (length > index) {
    result[index] = list[index++];
  }

  return result;
};

var addGetter = function addGetter(it, key) {
  nativeDefineProperty(it, key, {
    get: function get() {
      return getInternalState(this)[key];
    }
  });
};

var isArrayBuffer = function isArrayBuffer(it) {
  var klass;
  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function isTypedArrayIndex(target, key) {
  return isTypedArray(target) && typeof key != 'symbol' && key in target && String(+key) == String(key);
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  return isTypedArrayIndex(target, key = toPrimitive(key, true)) ? createPropertyDescriptor(2, target[key]) : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  if (isTypedArrayIndex(target, key = toPrimitive(key, true)) && isObject(descriptor) && has(descriptor, 'value') && !has(descriptor, 'get') && !has(descriptor, 'set') // TODO: add validation descriptor w/o calling accessors
  && !descriptor.configurable && (!has(descriptor, 'writable') || descriptor.writable) && (!has(descriptor, 'enumerable') || descriptor.enumerable)) {
    target[key] = descriptor.value;
    return target;
  }

  return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $({
    target: 'Object',
    stat: true,
    forced: !NATIVE_ARRAY_BUFFER_VIEWS
  }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  module.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+$/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function getter(that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function setter(that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function addElement(that, index) {
      nativeDefineProperty(that, index, {
        get: function get() {
          return getter(this, index);
        },
        set: function set(value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;

        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;

          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }

          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }

        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });

        while (index < length) {
          addElement(that, index++);
        }
      });
      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
        return inheritIfRequired(function () {
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length) : typedArrayOffset !== undefined ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES)) : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });
      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;
    $({
      global: true,
      forced: TypedArrayConstructor != NativeTypedArrayConstructor,
      sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () {
  /* empty */
};

/***/ }),

/***/ 59225:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint-disable no-new -- required for testing */
var global = __webpack_require__(52586);

var fails = __webpack_require__(45200);

var checkCorrectnessOfIteration = __webpack_require__(33469);

var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__(82094).NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;
module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});

/***/ }),

/***/ 28939:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var aTypedArrayConstructor = __webpack_require__(82094).aTypedArrayConstructor;

var speciesConstructor = __webpack_require__(30646);

module.exports = function (instance, list) {
  var C = speciesConstructor(instance, instance.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);

  while (length > index) {
    result[index] = list[index++];
  }

  return result;
};

/***/ }),

/***/ 22524:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toObject = __webpack_require__(25769);

var toLength = __webpack_require__(49152);

var getIteratorMethod = __webpack_require__(82093);

var isArrayIteratorMethod = __webpack_require__(93061);

var bind = __webpack_require__(81801);

var aTypedArrayConstructor = __webpack_require__(82094).aTypedArrayConstructor;

module.exports = function from(source
/* , mapfn, thisArg */
) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;

  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    O = [];

    while (!(step = next.call(iterator)).done) {
      O.push(step.value);
    }
  }

  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2], 2);
  }

  length = toLength(O.length);
  result = new (aTypedArrayConstructor(this))(length);

  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }

  return result;
};

/***/ }),

/***/ 97214:
/***/ ((module) => {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

/***/ }),

/***/ 93880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var NATIVE_SYMBOL = __webpack_require__(67893);

module.exports = NATIVE_SYMBOL
/* global Symbol -- safe */
&& !Symbol.sham && typeof Symbol.iterator == 'symbol';

/***/ }),

/***/ 12002:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var wellKnownSymbol = __webpack_require__(65373);

exports.f = wellKnownSymbol;

/***/ }),

/***/ 65373:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var shared = __webpack_require__(14707);

var has = __webpack_require__(38928);

var uid = __webpack_require__(97214);

var NATIVE_SYMBOL = __webpack_require__(67893);

var USE_SYMBOL_AS_UID = __webpack_require__(93880);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (NATIVE_SYMBOL && has(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  }

  return WellKnownSymbolsStore[name];
};

/***/ }),

/***/ 2429:
/***/ ((module) => {

// a string of all valid unicode whitespaces
module.exports = "\t\n\x0B\f\r \xA0\u1680\u2000\u2001\u2002" + "\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";

/***/ }),

/***/ 53523:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var getPrototypeOf = __webpack_require__(35651);

var setPrototypeOf = __webpack_require__(40616);

var create = __webpack_require__(1578);

var createNonEnumerableProperty = __webpack_require__(91705);

var createPropertyDescriptor = __webpack_require__(22424);

var iterate = __webpack_require__(63244);

var $AggregateError = function AggregateError(errors, message) {
  var that = this;
  if (!(that instanceof $AggregateError)) return new $AggregateError(errors, message);

  if (setPrototypeOf) {
    // eslint-disable-next-line unicorn/error-message -- expected
    that = setPrototypeOf(new Error(undefined), getPrototypeOf(that));
  }

  if (message !== undefined) createNonEnumerableProperty(that, 'message', String(message));
  var errorsArray = [];
  iterate(errors, errorsArray.push, {
    that: errorsArray
  });
  createNonEnumerableProperty(that, 'errors', errorsArray);
  return that;
};

$AggregateError.prototype = create(Error.prototype, {
  constructor: createPropertyDescriptor(5, $AggregateError),
  message: createPropertyDescriptor(5, ''),
  name: createPropertyDescriptor(5, 'AggregateError')
}); // `AggregateError` constructor
// https://tc39.es/ecma262/#sec-aggregate-error-constructor

$({
  global: true
}, {
  AggregateError: $AggregateError
});

/***/ }),

/***/ 27803:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var global = __webpack_require__(52586);

var arrayBufferModule = __webpack_require__(2091);

var setSpecies = __webpack_require__(94847);

var ARRAY_BUFFER = 'ArrayBuffer';
var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
var NativeArrayBuffer = global[ARRAY_BUFFER]; // `ArrayBuffer` constructor
// https://tc39.es/ecma262/#sec-arraybuffer-constructor

$({
  global: true,
  forced: NativeArrayBuffer !== ArrayBuffer
}, {
  ArrayBuffer: ArrayBuffer
});
setSpecies(ARRAY_BUFFER);

/***/ }),

/***/ 54995:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var ArrayBufferViewCore = __webpack_require__(82094);

var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS; // `ArrayBuffer.isView` method
// https://tc39.es/ecma262/#sec-arraybuffer.isview

$({
  target: 'ArrayBuffer',
  stat: true,
  forced: !NATIVE_ARRAY_BUFFER_VIEWS
}, {
  isView: ArrayBufferViewCore.isView
});

/***/ }),

/***/ 41017:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var ArrayBufferModule = __webpack_require__(2091);

var anObject = __webpack_require__(52943);

var toAbsoluteIndex = __webpack_require__(11652);

var toLength = __webpack_require__(49152);

var speciesConstructor = __webpack_require__(30646);

var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var nativeArrayBufferSlice = ArrayBuffer.prototype.slice;
var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
}); // `ArrayBuffer.prototype.slice` method
// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice

$({
  target: 'ArrayBuffer',
  proto: true,
  unsafe: true,
  forced: INCORRECT_SLICE
}, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }

    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
    var viewSource = new DataView(this);
    var viewTarget = new DataView(result);
    var index = 0;

    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    }

    return result;
  }
});

/***/ }),

/***/ 29074:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var isArray = __webpack_require__(96306);

var isObject = __webpack_require__(74194);

var toObject = __webpack_require__(25769);

var toLength = __webpack_require__(49152);

var createProperty = __webpack_require__(27042);

var arraySpeciesCreate = __webpack_require__(30388);

var arrayMethodHasSpeciesSupport = __webpack_require__(24188);

var wellKnownSymbol = __webpack_require__(65373);

var V8_VERSION = __webpack_require__(54875);

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded'; // We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679

var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});
var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function isConcatSpreadable(O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species

$({
  target: 'Array',
  proto: true,
  forced: FORCED
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;

    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];

      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

        for (k = 0; k < len; k++, n++) {
          if (k in E) createProperty(A, n, E[k]);
        }
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }

    A.length = n;
    return A;
  }
});

/***/ }),

/***/ 74772:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var copyWithin = __webpack_require__(30707);

var addToUnscopables = __webpack_require__(9360); // `Array.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-array.prototype.copywithin


$({
  target: 'Array',
  proto: true
}, {
  copyWithin: copyWithin
}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('copyWithin');

/***/ }),

/***/ 60843:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $every = __webpack_require__(11729).every;

var arrayMethodIsStrict = __webpack_require__(75891);

var STRICT_METHOD = arrayMethodIsStrict('every'); // `Array.prototype.every` method
// https://tc39.es/ecma262/#sec-array.prototype.every

$({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD
}, {
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ 98434:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var fill = __webpack_require__(81);

var addToUnscopables = __webpack_require__(9360); // `Array.prototype.fill` method
// https://tc39.es/ecma262/#sec-array.prototype.fill


$({
  target: 'Array',
  proto: true
}, {
  fill: fill
}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('fill');

/***/ }),

/***/ 15911:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $filter = __webpack_require__(11729).filter;

var arrayMethodHasSpeciesSupport = __webpack_require__(24188);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter'); // `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species

$({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT
}, {
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ 1169:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $findIndex = __webpack_require__(11729).findIndex;

var addToUnscopables = __webpack_require__(9360);

var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true; // Shouldn't skip holes

if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () {
  SKIPS_HOLES = false;
}); // `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findindex

$({
  target: 'Array',
  proto: true,
  forced: SKIPS_HOLES
}, {
  findIndex: function findIndex(callbackfn
  /* , that = undefined */
  ) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables(FIND_INDEX);

/***/ }),

/***/ 33365:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $find = __webpack_require__(11729).find;

var addToUnscopables = __webpack_require__(9360);

var FIND = 'find';
var SKIPS_HOLES = true; // Shouldn't skip holes

if (FIND in []) Array(1)[FIND](function () {
  SKIPS_HOLES = false;
}); // `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find

$({
  target: 'Array',
  proto: true,
  forced: SKIPS_HOLES
}, {
  find: function find(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables(FIND);

/***/ }),

/***/ 432:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var flattenIntoArray = __webpack_require__(45541);

var toObject = __webpack_require__(25769);

var toLength = __webpack_require__(49152);

var aFunction = __webpack_require__(27709);

var arraySpeciesCreate = __webpack_require__(30388); // `Array.prototype.flatMap` method
// https://tc39.es/ecma262/#sec-array.prototype.flatmap


$({
  target: 'Array',
  proto: true
}, {
  flatMap: function flatMap(callbackfn
  /* , thisArg */
  ) {
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A;
    aFunction(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});

/***/ }),

/***/ 91709:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var flattenIntoArray = __webpack_require__(45541);

var toObject = __webpack_require__(25769);

var toLength = __webpack_require__(49152);

var toInteger = __webpack_require__(1324);

var arraySpeciesCreate = __webpack_require__(30388); // `Array.prototype.flat` method
// https://tc39.es/ecma262/#sec-array.prototype.flat


$({
  target: 'Array',
  proto: true
}, {
  flat: function flat()
  /* depthArg = 1 */
  {
    var depthArg = arguments.length ? arguments[0] : undefined;
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

/***/ }),

/***/ 37174:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var forEach = __webpack_require__(80980); // `Array.prototype.forEach` method
// https://tc39.es/ecma262/#sec-array.prototype.foreach


$({
  target: 'Array',
  proto: true,
  forced: [].forEach != forEach
}, {
  forEach: forEach
});

/***/ }),

/***/ 40979:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var from = __webpack_require__(4789);

var checkCorrectnessOfIteration = __webpack_require__(33469);

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
}); // `Array.from` method
// https://tc39.es/ecma262/#sec-array.from

$({
  target: 'Array',
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  from: from
});

/***/ }),

/***/ 98820:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $includes = __webpack_require__(7255).includes;

var addToUnscopables = __webpack_require__(9360); // `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes


$({
  target: 'Array',
  proto: true
}, {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
}); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('includes');

/***/ }),

/***/ 48953:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $indexOf = __webpack_require__(7255).indexOf;

var arrayMethodIsStrict = __webpack_require__(75891);

var nativeIndexOf = [].indexOf;
var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('indexOf'); // `Array.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.indexof

$({
  target: 'Array',
  proto: true,
  forced: NEGATIVE_ZERO || !STRICT_METHOD
}, {
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ 50347:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var isArray = __webpack_require__(96306); // `Array.isArray` method
// https://tc39.es/ecma262/#sec-array.isarray


$({
  target: 'Array',
  stat: true
}, {
  isArray: isArray
});

/***/ }),

/***/ 66668:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var toIndexedObject = __webpack_require__(20829);

var addToUnscopables = __webpack_require__(9360);

var Iterators = __webpack_require__(9806);

var InternalStateModule = __webpack_require__(59351);

var defineIterator = __webpack_require__(64079);

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator

module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated),
    // target
    index: 0,
    // next index
    kind: kind // kind

  }); // `%ArrayIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;

  if (!target || index >= target.length) {
    state.target = undefined;
    return {
      value: undefined,
      done: true
    };
  }

  if (kind == 'keys') return {
    value: index,
    done: false
  };
  if (kind == 'values') return {
    value: target[index],
    done: false
  };
  return {
    value: [index, target[index]],
    done: false
  };
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject

Iterators.Arguments = Iterators.Array; // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ 39264:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var IndexedObject = __webpack_require__(68813);

var toIndexedObject = __webpack_require__(20829);

var arrayMethodIsStrict = __webpack_require__(75891);

var nativeJoin = [].join;
var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict('join', ','); // `Array.prototype.join` method
// https://tc39.es/ecma262/#sec-array.prototype.join

$({
  target: 'Array',
  proto: true,
  forced: ES3_STRINGS || !STRICT_METHOD
}, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),

/***/ 26433:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var lastIndexOf = __webpack_require__(58792); // `Array.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof


$({
  target: 'Array',
  proto: true,
  forced: lastIndexOf !== [].lastIndexOf
}, {
  lastIndexOf: lastIndexOf
});

/***/ }),

/***/ 74443:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $map = __webpack_require__(11729).map;

var arrayMethodHasSpeciesSupport = __webpack_require__(24188);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map'); // `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species

$({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT
}, {
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ 88854:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var createProperty = __webpack_require__(27042);

var ISNT_GENERIC = fails(function () {
  function F() {
    /* empty */
  }

  return !(Array.of.call(F) instanceof F);
}); // `Array.of` method
// https://tc39.es/ecma262/#sec-array.of
// WebKit Array.of isn't generic

$({
  target: 'Array',
  stat: true,
  forced: ISNT_GENERIC
}, {
  of: function of()
  /* ...args */
  {
    var index = 0;
    var argumentsLength = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(argumentsLength);

    while (argumentsLength > index) {
      createProperty(result, index, arguments[index++]);
    }

    result.length = argumentsLength;
    return result;
  }
});

/***/ }),

/***/ 9851:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $reduceRight = __webpack_require__(59892).right;

var arrayMethodIsStrict = __webpack_require__(75891);

var CHROME_VERSION = __webpack_require__(54875);

var IS_NODE = __webpack_require__(31292);

var STRICT_METHOD = arrayMethodIsStrict('reduceRight'); // Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982

var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83; // `Array.prototype.reduceRight` method
// https://tc39.es/ecma262/#sec-array.prototype.reduceright

$({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD || CHROME_BUG
}, {
  reduceRight: function reduceRight(callbackfn
  /* , initialValue */
  ) {
    return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ 36189:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $reduce = __webpack_require__(59892).left;

var arrayMethodIsStrict = __webpack_require__(75891);

var CHROME_VERSION = __webpack_require__(54875);

var IS_NODE = __webpack_require__(31292);

var STRICT_METHOD = arrayMethodIsStrict('reduce'); // Chrome 80-82 has a critical bug
// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982

var CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83; // `Array.prototype.reduce` method
// https://tc39.es/ecma262/#sec-array.prototype.reduce

$({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD || CHROME_BUG
}, {
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ 82145:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var isArray = __webpack_require__(96306);

var nativeReverse = [].reverse;
var test = [1, 2]; // `Array.prototype.reverse` method
// https://tc39.es/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794

$({
  target: 'Array',
  proto: true,
  forced: String(test) === String(test.reverse())
}, {
  reverse: function reverse() {
    // eslint-disable-next-line no-self-assign -- dirty hack
    if (isArray(this)) this.length = this.length;
    return nativeReverse.call(this);
  }
});

/***/ }),

/***/ 93034:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var isObject = __webpack_require__(74194);

var isArray = __webpack_require__(96306);

var toAbsoluteIndex = __webpack_require__(11652);

var toLength = __webpack_require__(49152);

var toIndexedObject = __webpack_require__(20829);

var createProperty = __webpack_require__(27042);

var wellKnownSymbol = __webpack_require__(65373);

var arrayMethodHasSpeciesSupport = __webpack_require__(24188);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max; // `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects

$({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT
}, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

    var Constructor, result, n;

    if (isArray(O)) {
      Constructor = O.constructor; // cross-realm fallback

      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }

      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }

    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));

    for (n = 0; k < fin; k++, n++) {
      if (k in O) createProperty(result, n, O[k]);
    }

    result.length = n;
    return result;
  }
});

/***/ }),

/***/ 6925:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $some = __webpack_require__(11729).some;

var arrayMethodIsStrict = __webpack_require__(75891);

var STRICT_METHOD = arrayMethodIsStrict('some'); // `Array.prototype.some` method
// https://tc39.es/ecma262/#sec-array.prototype.some

$({
  target: 'Array',
  proto: true,
  forced: !STRICT_METHOD
}, {
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ 97378:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var aFunction = __webpack_require__(27709);

var toObject = __webpack_require__(25769);

var fails = __webpack_require__(45200);

var arrayMethodIsStrict = __webpack_require__(75891);

var test = [];
var nativeSort = test.sort; // IE8-

var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
}); // V8 bug

var FAILS_ON_NULL = fails(function () {
  test.sort(null);
}); // Old WebKit

var STRICT_METHOD = arrayMethodIsStrict('sort');
var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD; // `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort

$({
  target: 'Array',
  proto: true,
  forced: FORCED
}, {
  sort: function sort(comparefn) {
    return comparefn === undefined ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),

/***/ 94963:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var setSpecies = __webpack_require__(94847); // `Array[@@species]` getter
// https://tc39.es/ecma262/#sec-get-array-@@species


setSpecies('Array');

/***/ }),

/***/ 62874:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var toAbsoluteIndex = __webpack_require__(11652);

var toInteger = __webpack_require__(1324);

var toLength = __webpack_require__(49152);

var toObject = __webpack_require__(25769);

var arraySpeciesCreate = __webpack_require__(30388);

var createProperty = __webpack_require__(27042);

var arrayMethodHasSpeciesSupport = __webpack_require__(24188);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species

$({
  target: 'Array',
  proto: true,
  forced: !HAS_SPECIES_SUPPORT
}, {
  splice: function splice(start, deleteCount
  /* , ...items */
  ) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;

    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }

    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }

    A = arraySpeciesCreate(O, actualDeleteCount);

    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }

    A.length = actualDeleteCount;

    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];else delete O[to];
      }

      for (k = len; k > len - actualDeleteCount + insertCount; k--) {
        delete O[k - 1];
      }
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];else delete O[to];
      }
    }

    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }

    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});

/***/ }),

/***/ 93484:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(9360); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables


addToUnscopables('flatMap');

/***/ }),

/***/ 15857:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(9360); // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables


addToUnscopables('flat');

/***/ }),

/***/ 15536:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var ArrayBufferModule = __webpack_require__(2091);

var NATIVE_ARRAY_BUFFER = __webpack_require__(10477); // `DataView` constructor
// https://tc39.es/ecma262/#sec-dataview-constructor


$({
  global: true,
  forced: !NATIVE_ARRAY_BUFFER
}, {
  DataView: ArrayBufferModule.DataView
});

/***/ }),

/***/ 68289:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064); // `Date.now` method
// https://tc39.es/ecma262/#sec-date.now


$({
  target: 'Date',
  stat: true
}, {
  now: function now() {
    return new Date().getTime();
  }
});

/***/ }),

/***/ 15640:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var toISOString = __webpack_require__(45611); // `Date.prototype.toISOString` method
// https://tc39.es/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit has a broken implementations


$({
  target: 'Date',
  proto: true,
  forced: Date.prototype.toISOString !== toISOString
}, {
  toISOString: toISOString
});

/***/ }),

/***/ 37329:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var toObject = __webpack_require__(25769);

var toPrimitive = __webpack_require__(36238);

var FORCED = fails(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function toISOString() {
      return 1;
    }
  }) !== 1;
}); // `Date.prototype.toJSON` method
// https://tc39.es/ecma262/#sec-date.prototype.tojson

$({
  target: 'Date',
  proto: true,
  forced: FORCED
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),

/***/ 1198:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var createNonEnumerableProperty = __webpack_require__(91705);

var dateToPrimitive = __webpack_require__(57368);

var wellKnownSymbol = __webpack_require__(65373);

var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var DatePrototype = Date.prototype; // `Date.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-date.prototype-@@toprimitive

if (!(TO_PRIMITIVE in DatePrototype)) {
  createNonEnumerableProperty(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
}

/***/ }),

/***/ 82248:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var redefine = __webpack_require__(44469);

var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = DatePrototype[TO_STRING];
var getTime = DatePrototype.getTime; // `Date.prototype.toString` method
// https://tc39.es/ecma262/#sec-date.prototype.tostring

if (new Date(NaN) + '' != INVALID_DATE) {
  redefine(DatePrototype, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare -- NaN check

    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
  });
}

/***/ }),

/***/ 58981:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var bind = __webpack_require__(89723); // `Function.prototype.bind` method
// https://tc39.es/ecma262/#sec-function.prototype.bind


$({
  target: 'Function',
  proto: true
}, {
  bind: bind
});

/***/ }),

/***/ 45934:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var isObject = __webpack_require__(74194);

var definePropertyModule = __webpack_require__(45070);

var getPrototypeOf = __webpack_require__(35651);

var wellKnownSymbol = __webpack_require__(65373);

var HAS_INSTANCE = wellKnownSymbol('hasInstance');
var FunctionPrototype = Function.prototype; // `Function.prototype[@@hasInstance]` method
// https://tc39.es/ecma262/#sec-function.prototype-@@hasinstance

if (!(HAS_INSTANCE in FunctionPrototype)) {
  definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, {
    value: function value(O) {
      if (typeof this != 'function' || !isObject(O)) return false;
      if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

      while (O = getPrototypeOf(O)) {
        if (this.prototype === O) return true;
      }

      return false;
    }
  });
}

/***/ }),

/***/ 72876:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(9811);

var defineProperty = __webpack_require__(45070).f;

var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // Function instances `.name` property
// https://tc39.es/ecma262/#sec-function-instances-name

if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function get() {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}

/***/ }),

/***/ 26850:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var global = __webpack_require__(52586); // `globalThis` object
// https://tc39.es/ecma262/#sec-globalthis


$({
  global: true
}, {
  globalThis: global
});

/***/ }),

/***/ 44750:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var getBuiltIn = __webpack_require__(40866);

var fails = __webpack_require__(45200);

var $stringify = getBuiltIn('JSON', 'stringify');
var re = /[\uD800-\uDFFF]/g;
var low = /^[\uD800-\uDBFF]$/;
var hi = /^[\uDC00-\uDFFF]$/;

var fix = function fix(match, offset, string) {
  var prev = string.charAt(offset - 1);
  var next = string.charAt(offset + 1);

  if (low.test(match) && !hi.test(next) || hi.test(match) && !low.test(prev)) {
    return "\\u" + match.charCodeAt(0).toString(16);
  }

  return match;
};

var FORCED = fails(function () {
  return $stringify("\uDF06\uD834") !== "\"\\udf06\\ud834\"" || $stringify("\uDEAD") !== "\"\\udead\"";
});

if ($stringify) {
  // `JSON.stringify` method
  // https://tc39.es/ecma262/#sec-json.stringify
  // https://github.com/tc39/proposal-well-formed-stringify
  $({
    target: 'JSON',
    stat: true,
    forced: FORCED
  }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var result = $stringify.apply(null, arguments);
      return typeof result == 'string' ? result.replace(re, fix) : result;
    }
  });
}

/***/ }),

/***/ 37703:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var setToStringTag = __webpack_require__(46736); // JSON[@@toStringTag] property
// https://tc39.es/ecma262/#sec-json-@@tostringtag


setToStringTag(global.JSON, 'JSON', true);

/***/ }),

/***/ 27253:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var collection = __webpack_require__(79524);

var collectionStrong = __webpack_require__(76702); // `Map` constructor
// https://tc39.es/ecma262/#sec-map-objects


module.exports = collection('Map', function (init) {
  return function Map() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong);

/***/ }),

/***/ 65129:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var log1p = __webpack_require__(32599);

var nativeAcosh = Math.acosh;
var log = Math.log;
var sqrt = Math.sqrt;
var LN2 = Math.LN2;
var FORCED = !nativeAcosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
|| Math.floor(nativeAcosh(Number.MAX_VALUE)) != 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
|| nativeAcosh(Infinity) != Infinity; // `Math.acosh` method
// https://tc39.es/ecma262/#sec-math.acosh

$({
  target: 'Math',
  stat: true,
  forced: FORCED
}, {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? log(x) + LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),

/***/ 35433:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var nativeAsinh = Math.asinh;
var log = Math.log;
var sqrt = Math.sqrt;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
} // `Math.asinh` method
// https://tc39.es/ecma262/#sec-math.asinh
// Tor Browser bug: Math.asinh(0) -> -0


$({
  target: 'Math',
  stat: true,
  forced: !(nativeAsinh && 1 / nativeAsinh(0) > 0)
}, {
  asinh: asinh
});

/***/ }),

/***/ 79313:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var nativeAtanh = Math.atanh;
var log = Math.log; // `Math.atanh` method
// https://tc39.es/ecma262/#sec-math.atanh
// Tor Browser bug: Math.atanh(-0) -> 0

$({
  target: 'Math',
  stat: true,
  forced: !(nativeAtanh && 1 / nativeAtanh(-0) < 0)
}, {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),

/***/ 28081:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var sign = __webpack_require__(31874);

var abs = Math.abs;
var pow = Math.pow; // `Math.cbrt` method
// https://tc39.es/ecma262/#sec-math.cbrt

$({
  target: 'Math',
  stat: true
}, {
  cbrt: function cbrt(x) {
    return sign(x = +x) * pow(abs(x), 1 / 3);
  }
});

/***/ }),

/***/ 4292:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var floor = Math.floor;
var log = Math.log;
var LOG2E = Math.LOG2E; // `Math.clz32` method
// https://tc39.es/ecma262/#sec-math.clz32

$({
  target: 'Math',
  stat: true
}, {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - floor(log(x + 0.5) * LOG2E) : 32;
  }
});

/***/ }),

/***/ 53019:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var expm1 = __webpack_require__(91437);

var nativeCosh = Math.cosh;
var abs = Math.abs;
var E = Math.E; // `Math.cosh` method
// https://tc39.es/ecma262/#sec-math.cosh

$({
  target: 'Math',
  stat: true,
  forced: !nativeCosh || nativeCosh(710) === Infinity
}, {
  cosh: function cosh(x) {
    var t = expm1(abs(x) - 1) + 1;
    return (t + 1 / (t * E * E)) * (E / 2);
  }
});

/***/ }),

/***/ 36832:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var expm1 = __webpack_require__(91437); // `Math.expm1` method
// https://tc39.es/ecma262/#sec-math.expm1


$({
  target: 'Math',
  stat: true,
  forced: expm1 != Math.expm1
}, {
  expm1: expm1
});

/***/ }),

/***/ 30435:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var fround = __webpack_require__(72896); // `Math.fround` method
// https://tc39.es/ecma262/#sec-math.fround


$({
  target: 'Math',
  stat: true
}, {
  fround: fround
});

/***/ }),

/***/ 5123:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var $hypot = Math.hypot;
var abs = Math.abs;
var sqrt = Math.sqrt; // Chrome 77 bug
// https://bugs.chromium.org/p/v8/issues/detail?id=9546

var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity; // `Math.hypot` method
// https://tc39.es/ecma262/#sec-math.hypot

$({
  target: 'Math',
  stat: true,
  forced: BUGGY
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  hypot: function hypot(value1, value2) {
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * sqrt(sum);
  }
});

/***/ }),

/***/ 6217:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var nativeImul = Math.imul;
var FORCED = fails(function () {
  return nativeImul(0xFFFFFFFF, 5) != -5 || nativeImul.length != 2;
}); // `Math.imul` method
// https://tc39.es/ecma262/#sec-math.imul
// some WebKit versions fails with big numbers, some has wrong arity

$({
  target: 'Math',
  stat: true,
  forced: FORCED
}, {
  imul: function imul(x, y) {
    var UINT16 = 0xFFFF;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),

/***/ 83093:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var log = Math.log;
var LOG10E = Math.LOG10E; // `Math.log10` method
// https://tc39.es/ecma262/#sec-math.log10

$({
  target: 'Math',
  stat: true
}, {
  log10: function log10(x) {
    return log(x) * LOG10E;
  }
});

/***/ }),

/***/ 58674:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var log1p = __webpack_require__(32599); // `Math.log1p` method
// https://tc39.es/ecma262/#sec-math.log1p


$({
  target: 'Math',
  stat: true
}, {
  log1p: log1p
});

/***/ }),

/***/ 23618:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var log = Math.log;
var LN2 = Math.LN2; // `Math.log2` method
// https://tc39.es/ecma262/#sec-math.log2

$({
  target: 'Math',
  stat: true
}, {
  log2: function log2(x) {
    return log(x) / LN2;
  }
});

/***/ }),

/***/ 22720:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var sign = __webpack_require__(31874); // `Math.sign` method
// https://tc39.es/ecma262/#sec-math.sign


$({
  target: 'Math',
  stat: true
}, {
  sign: sign
});

/***/ }),

/***/ 89040:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var expm1 = __webpack_require__(91437);

var abs = Math.abs;
var exp = Math.exp;
var E = Math.E;
var FORCED = fails(function () {
  return Math.sinh(-2e-17) != -2e-17;
}); // `Math.sinh` method
// https://tc39.es/ecma262/#sec-math.sinh
// V8 near Chromium 38 has a problem with very small numbers

$({
  target: 'Math',
  stat: true,
  forced: FORCED
}, {
  sinh: function sinh(x) {
    return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
  }
});

/***/ }),

/***/ 19998:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var expm1 = __webpack_require__(91437);

var exp = Math.exp; // `Math.tanh` method
// https://tc39.es/ecma262/#sec-math.tanh

$({
  target: 'Math',
  stat: true
}, {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),

/***/ 9583:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var setToStringTag = __webpack_require__(46736); // Math[@@toStringTag] property
// https://tc39.es/ecma262/#sec-math-@@tostringtag


setToStringTag(Math, 'Math', true);

/***/ }),

/***/ 2010:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var ceil = Math.ceil;
var floor = Math.floor; // `Math.trunc` method
// https://tc39.es/ecma262/#sec-math.trunc

$({
  target: 'Math',
  stat: true
}, {
  trunc: function trunc(it) {
    return (it > 0 ? floor : ceil)(it);
  }
});

/***/ }),

/***/ 88458:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var DESCRIPTORS = __webpack_require__(9811);

var global = __webpack_require__(52586);

var isForced = __webpack_require__(40695);

var redefine = __webpack_require__(44469);

var has = __webpack_require__(38928);

var classof = __webpack_require__(700);

var inheritIfRequired = __webpack_require__(57170);

var toPrimitive = __webpack_require__(36238);

var fails = __webpack_require__(45200);

var create = __webpack_require__(1578);

var getOwnPropertyNames = __webpack_require__(72205).f;

var getOwnPropertyDescriptor = __webpack_require__(22130).f;

var defineProperty = __webpack_require__(45070).f;

var trim = __webpack_require__(86392).trim;

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype; // Opera ~12 has broken Object#toString

var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER; // `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber

var toNumber = function toNumber(argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;

  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal of /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal of /^0o[0-7]+$/i

        default:
          return +it;
      }

      digits = it.slice(2);
      length = digits.length;

      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
}; // `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor


if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper // check on 1..constructor(foo) case
    && (BROKEN_CLASSOF ? fails(function () {
      NumberPrototype.valueOf.call(dummy);
    }) : classof(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };

  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES2015 (in case, if modules with ES2015 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,' + // ESNext
  'fromString,range').split(','), j = 0, key; keys.length > j; j++) {
    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }

  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}

/***/ }),

/***/ 98072:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064); // `Number.EPSILON` constant
// https://tc39.es/ecma262/#sec-number.epsilon


$({
  target: 'Number',
  stat: true
}, {
  EPSILON: Math.pow(2, -52)
});

/***/ }),

/***/ 30593:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var numberIsFinite = __webpack_require__(84247); // `Number.isFinite` method
// https://tc39.es/ecma262/#sec-number.isfinite


$({
  target: 'Number',
  stat: true
}, {
  isFinite: numberIsFinite
});

/***/ }),

/***/ 25408:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var isInteger = __webpack_require__(56616); // `Number.isInteger` method
// https://tc39.es/ecma262/#sec-number.isinteger


$({
  target: 'Number',
  stat: true
}, {
  isInteger: isInteger
});

/***/ }),

/***/ 15496:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064); // `Number.isNaN` method
// https://tc39.es/ecma262/#sec-number.isnan


$({
  target: 'Number',
  stat: true
}, {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare -- NaN check
    return number != number;
  }
});

/***/ }),

/***/ 59987:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var isInteger = __webpack_require__(56616);

var abs = Math.abs; // `Number.isSafeInteger` method
// https://tc39.es/ecma262/#sec-number.issafeinteger

$({
  target: 'Number',
  stat: true
}, {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1FFFFFFFFFFFFF;
  }
});

/***/ }),

/***/ 29117:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064); // `Number.MAX_SAFE_INTEGER` constant
// https://tc39.es/ecma262/#sec-number.max_safe_integer


$({
  target: 'Number',
  stat: true
}, {
  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
});

/***/ }),

/***/ 4962:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064); // `Number.MIN_SAFE_INTEGER` constant
// https://tc39.es/ecma262/#sec-number.min_safe_integer


$({
  target: 'Number',
  stat: true
}, {
  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
});

/***/ }),

/***/ 56785:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var parseFloat = __webpack_require__(99722); // `Number.parseFloat` method
// https://tc39.es/ecma262/#sec-number.parseFloat


$({
  target: 'Number',
  stat: true,
  forced: Number.parseFloat != parseFloat
}, {
  parseFloat: parseFloat
});

/***/ }),

/***/ 72282:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var parseInt = __webpack_require__(87148); // `Number.parseInt` method
// https://tc39.es/ecma262/#sec-number.parseint


$({
  target: 'Number',
  stat: true,
  forced: Number.parseInt != parseInt
}, {
  parseInt: parseInt
});

/***/ }),

/***/ 26486:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var toInteger = __webpack_require__(1324);

var thisNumberValue = __webpack_require__(84353);

var repeat = __webpack_require__(90971);

var fails = __webpack_require__(45200);

var nativeToFixed = 1.0.toFixed;
var floor = Math.floor;

var pow = function pow(x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function log(x) {
  var n = 0;
  var x2 = x;

  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }

  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }

  return n;
};

var multiply = function multiply(data, n, c) {
  var index = -1;
  var c2 = c;

  while (++index < 6) {
    c2 += n * data[index];
    data[index] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function divide(data, n) {
  var index = 6;
  var c = 0;

  while (--index >= 0) {
    c += data[index];
    data[index] = floor(c / n);
    c = c % n * 1e7;
  }
};

var dataToString = function dataToString(data) {
  var index = 6;
  var s = '';

  while (--index >= 0) {
    if (s !== '' || index === 0 || data[index] !== 0) {
      var t = String(data[index]);
      s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
    }
  }

  return s;
};

var FORCED = nativeToFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
}); // `Number.prototype.toFixed` method
// https://tc39.es/ecma262/#sec-number.prototype.tofixed

$({
  target: 'Number',
  proto: true,
  forced: FORCED
}, {
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toInteger(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;
    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits'); // eslint-disable-next-line no-self-compare -- NaN check

    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);

    if (number < 0) {
      sign = '-';
      number = -number;
    }

    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;

      if (e > 0) {
        multiply(data, 0, z);
        j = fractDigits;

        while (j >= 7) {
          multiply(data, 1e7, 0);
          j -= 7;
        }

        multiply(data, pow(10, j, 1), 0);
        j = e - 1;

        while (j >= 23) {
          divide(data, 1 << 23);
          j -= 23;
        }

        divide(data, 1 << j);
        multiply(data, 1, 1);
        divide(data, 2);
        result = dataToString(data);
      } else {
        multiply(data, 0, z);
        multiply(data, 1 << -e, 0);
        result = dataToString(data) + repeat.call('0', fractDigits);
      }
    }

    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits ? '0.' + repeat.call('0', fractDigits - k) + result : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
    } else {
      result = sign + result;
    }

    return result;
  }
});

/***/ }),

/***/ 4346:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var thisNumberValue = __webpack_require__(84353);

var nativeToPrecision = 1.0.toPrecision;
var FORCED = fails(function () {
  // IE7-
  return nativeToPrecision.call(1, undefined) !== '1';
}) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToPrecision.call({});
}); // `Number.prototype.toPrecision` method
// https://tc39.es/ecma262/#sec-number.prototype.toprecision

$({
  target: 'Number',
  proto: true,
  forced: FORCED
}, {
  toPrecision: function toPrecision(precision) {
    return precision === undefined ? nativeToPrecision.call(thisNumberValue(this)) : nativeToPrecision.call(thisNumberValue(this), precision);
  }
});

/***/ }),

/***/ 56252:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var assign = __webpack_require__(99103); // `Object.assign` method
// https://tc39.es/ecma262/#sec-object.assign


$({
  target: 'Object',
  stat: true,
  forced: Object.assign !== assign
}, {
  assign: assign
});

/***/ }),

/***/ 66760:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var DESCRIPTORS = __webpack_require__(9811);

var create = __webpack_require__(1578); // `Object.create` method
// https://tc39.es/ecma262/#sec-object.create


$({
  target: 'Object',
  stat: true,
  sham: !DESCRIPTORS
}, {
  create: create
});

/***/ }),

/***/ 72380:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var DESCRIPTORS = __webpack_require__(9811);

var FORCED = __webpack_require__(70629);

var toObject = __webpack_require__(25769);

var aFunction = __webpack_require__(27709);

var definePropertyModule = __webpack_require__(45070); // `Object.prototype.__defineGetter__` method
// https://tc39.es/ecma262/#sec-object.prototype.__defineGetter__


if (DESCRIPTORS) {
  $({
    target: 'Object',
    proto: true,
    forced: FORCED
  }, {
    __defineGetter__: function __defineGetter__(P, getter) {
      definePropertyModule.f(toObject(this), P, {
        get: aFunction(getter),
        enumerable: true,
        configurable: true
      });
    }
  });
}

/***/ }),

/***/ 6499:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var DESCRIPTORS = __webpack_require__(9811);

var defineProperties = __webpack_require__(70984); // `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties


$({
  target: 'Object',
  stat: true,
  forced: !DESCRIPTORS,
  sham: !DESCRIPTORS
}, {
  defineProperties: defineProperties
});

/***/ }),

/***/ 1127:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var DESCRIPTORS = __webpack_require__(9811);

var objectDefinePropertyModile = __webpack_require__(45070); // `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty


$({
  target: 'Object',
  stat: true,
  forced: !DESCRIPTORS,
  sham: !DESCRIPTORS
}, {
  defineProperty: objectDefinePropertyModile.f
});

/***/ }),

/***/ 17625:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var DESCRIPTORS = __webpack_require__(9811);

var FORCED = __webpack_require__(70629);

var toObject = __webpack_require__(25769);

var aFunction = __webpack_require__(27709);

var definePropertyModule = __webpack_require__(45070); // `Object.prototype.__defineSetter__` method
// https://tc39.es/ecma262/#sec-object.prototype.__defineSetter__


if (DESCRIPTORS) {
  $({
    target: 'Object',
    proto: true,
    forced: FORCED
  }, {
    __defineSetter__: function __defineSetter__(P, setter) {
      definePropertyModule.f(toObject(this), P, {
        set: aFunction(setter),
        enumerable: true,
        configurable: true
      });
    }
  });
}

/***/ }),

/***/ 97448:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var $entries = __webpack_require__(27758).entries; // `Object.entries` method
// https://tc39.es/ecma262/#sec-object.entries


$({
  target: 'Object',
  stat: true
}, {
  entries: function entries(O) {
    return $entries(O);
  }
});

/***/ }),

/***/ 21386:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var FREEZING = __webpack_require__(10940);

var fails = __webpack_require__(45200);

var isObject = __webpack_require__(74194);

var onFreeze = __webpack_require__(60648).onFreeze;

var nativeFreeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () {
  nativeFreeze(1);
}); // `Object.freeze` method
// https://tc39.es/ecma262/#sec-object.freeze

$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES,
  sham: !FREEZING
}, {
  freeze: function freeze(it) {
    return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
  }
});

/***/ }),

/***/ 21292:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var iterate = __webpack_require__(63244);

var createProperty = __webpack_require__(27042); // `Object.fromEntries` method
// https://github.com/tc39/proposal-object-from-entries


$({
  target: 'Object',
  stat: true
}, {
  fromEntries: function fromEntries(iterable) {
    var obj = {};
    iterate(iterable, function (k, v) {
      createProperty(obj, k, v);
    }, {
      AS_ENTRIES: true
    });
    return obj;
  }
});

/***/ }),

/***/ 22929:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var toIndexedObject = __webpack_require__(20829);

var nativeGetOwnPropertyDescriptor = __webpack_require__(22130).f;

var DESCRIPTORS = __webpack_require__(9811);

var FAILS_ON_PRIMITIVES = fails(function () {
  nativeGetOwnPropertyDescriptor(1);
});
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES; // `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor

$({
  target: 'Object',
  stat: true,
  forced: FORCED,
  sham: !DESCRIPTORS
}, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});

/***/ }),

/***/ 90803:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var DESCRIPTORS = __webpack_require__(9811);

var ownKeys = __webpack_require__(15732);

var toIndexedObject = __webpack_require__(20829);

var getOwnPropertyDescriptorModule = __webpack_require__(22130);

var createProperty = __webpack_require__(27042); // `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors


$({
  target: 'Object',
  stat: true,
  sham: !DESCRIPTORS
}, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;

    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }

    return result;
  }
});

/***/ }),

/***/ 71994:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var nativeGetOwnPropertyNames = __webpack_require__(62020).f;

var FAILS_ON_PRIMITIVES = fails(function () {
  return !Object.getOwnPropertyNames(1);
}); // `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames

$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  getOwnPropertyNames: nativeGetOwnPropertyNames
});

/***/ }),

/***/ 8889:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var toObject = __webpack_require__(25769);

var nativeGetPrototypeOf = __webpack_require__(35651);

var CORRECT_PROTOTYPE_GETTER = __webpack_require__(20457);

var FAILS_ON_PRIMITIVES = fails(function () {
  nativeGetPrototypeOf(1);
}); // `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof

$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES,
  sham: !CORRECT_PROTOTYPE_GETTER
}, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});

/***/ }),

/***/ 28400:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var isObject = __webpack_require__(74194);

var nativeIsExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () {
  nativeIsExtensible(1);
}); // `Object.isExtensible` method
// https://tc39.es/ecma262/#sec-object.isextensible

$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  isExtensible: function isExtensible(it) {
    return isObject(it) ? nativeIsExtensible ? nativeIsExtensible(it) : true : false;
  }
});

/***/ }),

/***/ 36217:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var isObject = __webpack_require__(74194);

var nativeIsFrozen = Object.isFrozen;
var FAILS_ON_PRIMITIVES = fails(function () {
  nativeIsFrozen(1);
}); // `Object.isFrozen` method
// https://tc39.es/ecma262/#sec-object.isfrozen

$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  isFrozen: function isFrozen(it) {
    return isObject(it) ? nativeIsFrozen ? nativeIsFrozen(it) : false : true;
  }
});

/***/ }),

/***/ 76262:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var fails = __webpack_require__(45200);

var isObject = __webpack_require__(74194);

var nativeIsSealed = Object.isSealed;
var FAILS_ON_PRIMITIVES = fails(function () {
  nativeIsSealed(1);
}); // `Object.isSealed` method
// https://tc39.es/ecma262/#sec-object.issealed

$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  isSealed: function isSealed(it) {
    return isObject(it) ? nativeIsSealed ? nativeIsSealed(it) : false : true;
  }
});

/***/ }),

/***/ 610:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var is = __webpack_require__(70871); // `Object.is` method
// https://tc39.es/ecma262/#sec-object.is


$({
  target: 'Object',
  stat: true
}, {
  is: is
});

/***/ }),

/***/ 6939:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var toObject = __webpack_require__(25769);

var nativeKeys = __webpack_require__(12656);

var fails = __webpack_require__(45200);

var FAILS_ON_PRIMITIVES = fails(function () {
  nativeKeys(1);
}); // `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys

$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES
}, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});

/***/ }),

/***/ 69151:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var DESCRIPTORS = __webpack_require__(9811);

var FORCED = __webpack_require__(70629);

var toObject = __webpack_require__(25769);

var toPrimitive = __webpack_require__(36238);

var getPrototypeOf = __webpack_require__(35651);

var getOwnPropertyDescriptor = __webpack_require__(22130).f; // `Object.prototype.__lookupGetter__` method
// https://tc39.es/ecma262/#sec-object.prototype.__lookupGetter__


if (DESCRIPTORS) {
  $({
    target: 'Object',
    proto: true,
    forced: FORCED
  }, {
    __lookupGetter__: function __lookupGetter__(P) {
      var O = toObject(this);
      var key = toPrimitive(P, true);
      var desc;

      do {
        if (desc = getOwnPropertyDescriptor(O, key)) return desc.get;
      } while (O = getPrototypeOf(O));
    }
  });
}

/***/ }),

/***/ 69547:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var DESCRIPTORS = __webpack_require__(9811);

var FORCED = __webpack_require__(70629);

var toObject = __webpack_require__(25769);

var toPrimitive = __webpack_require__(36238);

var getPrototypeOf = __webpack_require__(35651);

var getOwnPropertyDescriptor = __webpack_require__(22130).f; // `Object.prototype.__lookupSetter__` method
// https://tc39.es/ecma262/#sec-object.prototype.__lookupSetter__


if (DESCRIPTORS) {
  $({
    target: 'Object',
    proto: true,
    forced: FORCED
  }, {
    __lookupSetter__: function __lookupSetter__(P) {
      var O = toObject(this);
      var key = toPrimitive(P, true);
      var desc;

      do {
        if (desc = getOwnPropertyDescriptor(O, key)) return desc.set;
      } while (O = getPrototypeOf(O));
    }
  });
}

/***/ }),

/***/ 6143:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var isObject = __webpack_require__(74194);

var onFreeze = __webpack_require__(60648).onFreeze;

var FREEZING = __webpack_require__(10940);

var fails = __webpack_require__(45200);

var nativePreventExtensions = Object.preventExtensions;
var FAILS_ON_PRIMITIVES = fails(function () {
  nativePreventExtensions(1);
}); // `Object.preventExtensions` method
// https://tc39.es/ecma262/#sec-object.preventextensions

$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES,
  sham: !FREEZING
}, {
  preventExtensions: function preventExtensions(it) {
    return nativePreventExtensions && isObject(it) ? nativePreventExtensions(onFreeze(it)) : it;
  }
});

/***/ }),

/***/ 66932:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var isObject = __webpack_require__(74194);

var onFreeze = __webpack_require__(60648).onFreeze;

var FREEZING = __webpack_require__(10940);

var fails = __webpack_require__(45200);

var nativeSeal = Object.seal;
var FAILS_ON_PRIMITIVES = fails(function () {
  nativeSeal(1);
}); // `Object.seal` method
// https://tc39.es/ecma262/#sec-object.seal

$({
  target: 'Object',
  stat: true,
  forced: FAILS_ON_PRIMITIVES,
  sham: !FREEZING
}, {
  seal: function seal(it) {
    return nativeSeal && isObject(it) ? nativeSeal(onFreeze(it)) : it;
  }
});

/***/ }),

/***/ 76265:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var setPrototypeOf = __webpack_require__(40616); // `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof


$({
  target: 'Object',
  stat: true
}, {
  setPrototypeOf: setPrototypeOf
});

/***/ }),

/***/ 47163:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var TO_STRING_TAG_SUPPORT = __webpack_require__(14947);

var redefine = __webpack_require__(44469);

var toString = __webpack_require__(43024); // `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring


if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, {
    unsafe: true
  });
}

/***/ }),

/***/ 58482:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var $values = __webpack_require__(27758).values; // `Object.values` method
// https://tc39.es/ecma262/#sec-object.values


$({
  target: 'Object',
  stat: true
}, {
  values: function values(O) {
    return $values(O);
  }
});

/***/ }),

/***/ 76642:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var parseFloatImplementation = __webpack_require__(99722); // `parseFloat` method
// https://tc39.es/ecma262/#sec-parsefloat-string


$({
  global: true,
  forced: parseFloat != parseFloatImplementation
}, {
  parseFloat: parseFloatImplementation
});

/***/ }),

/***/ 17325:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var parseIntImplementation = __webpack_require__(87148); // `parseInt` method
// https://tc39.es/ecma262/#sec-parseint-string-radix


$({
  global: true,
  forced: parseInt != parseIntImplementation
}, {
  parseInt: parseIntImplementation
});

/***/ }),

/***/ 8872:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var aFunction = __webpack_require__(27709);

var newPromiseCapabilityModule = __webpack_require__(16593);

var perform = __webpack_require__(32780);

var iterate = __webpack_require__(63244); // `Promise.allSettled` method
// https://tc39.es/ecma262/#sec-promise.allsettled


$({
  target: 'Promise',
  stat: true
}, {
  allSettled: function allSettled(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = {
            status: 'fulfilled',
            value: value
          };
          --remaining || resolve(values);
        }, function (error) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = {
            status: 'rejected',
            reason: error
          };
          --remaining || resolve(values);
        });
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

/***/ }),

/***/ 85603:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var aFunction = __webpack_require__(27709);

var getBuiltIn = __webpack_require__(40866);

var newPromiseCapabilityModule = __webpack_require__(16593);

var perform = __webpack_require__(32780);

var iterate = __webpack_require__(63244);

var PROMISE_ANY_ERROR = 'No one promise resolved'; // `Promise.any` method
// https://tc39.es/ecma262/#sec-promise.any

$({
  target: 'Promise',
  stat: true
}, {
  any: function any(iterable) {
    var C = this;
    var capability = newPromiseCapabilityModule.f(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var promiseResolve = aFunction(C.resolve);
      var errors = [];
      var counter = 0;
      var remaining = 1;
      var alreadyResolved = false;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyRejected = false;
        errors.push(undefined);
        remaining++;
        promiseResolve.call(C, promise).then(function (value) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyResolved = true;
          resolve(value);
        }, function (error) {
          if (alreadyRejected || alreadyResolved) return;
          alreadyRejected = true;
          errors[index] = error;
          --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
        });
      });
      --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

/***/ }),

/***/ 29282:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var IS_PURE = __webpack_require__(58855);

var NativePromise = __webpack_require__(17088);

var fails = __webpack_require__(45200);

var getBuiltIn = __webpack_require__(40866);

var speciesConstructor = __webpack_require__(30646);

var promiseResolve = __webpack_require__(28982);

var redefine = __webpack_require__(44469); // Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829


var NON_GENERIC = !!NativePromise && fails(function () {
  NativePromise.prototype['finally'].call({
    then: function then() {
      /* empty */
    }
  }, function () {
    /* empty */
  });
}); // `Promise.prototype.finally` method
// https://tc39.es/ecma262/#sec-promise.prototype.finally

$({
  target: 'Promise',
  proto: true,
  real: true,
  forced: NON_GENERIC
}, {
  'finally': function _finally(onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
}); // patch native Promise.prototype for native async functions

if (!IS_PURE && typeof NativePromise == 'function' && !NativePromise.prototype['finally']) {
  redefine(NativePromise.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);
}

/***/ }),

/***/ 33739:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var IS_PURE = __webpack_require__(58855);

var global = __webpack_require__(52586);

var getBuiltIn = __webpack_require__(40866);

var NativePromise = __webpack_require__(17088);

var redefine = __webpack_require__(44469);

var redefineAll = __webpack_require__(3067);

var setToStringTag = __webpack_require__(46736);

var setSpecies = __webpack_require__(94847);

var isObject = __webpack_require__(74194);

var aFunction = __webpack_require__(27709);

var anInstance = __webpack_require__(6441);

var inspectSource = __webpack_require__(60735);

var iterate = __webpack_require__(63244);

var checkCorrectnessOfIteration = __webpack_require__(33469);

var speciesConstructor = __webpack_require__(30646);

var task = __webpack_require__(39250).set;

var microtask = __webpack_require__(50119);

var promiseResolve = __webpack_require__(28982);

var hostReportErrors = __webpack_require__(19239);

var newPromiseCapabilityModule = __webpack_require__(16593);

var perform = __webpack_require__(32780);

var InternalStateModule = __webpack_require__(59351);

var isForced = __webpack_require__(40695);

var wellKnownSymbol = __webpack_require__(65373);

var IS_NODE = __webpack_require__(31292);

var V8_VERSION = __webpack_require__(54875);

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
var FORCED = isForced(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);

  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (V8_VERSION === 66) return true; // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test

    if (!IS_NODE && !NATIVE_REJECTION_EVENT) return true;
  } // We need Promise#finally in the pure version for preventing prototype pollution


  if (IS_PURE && !PromiseConstructor.prototype['finally']) return true; // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679

  if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false; // Detect correctness of subclassing with @@species support

  var promise = PromiseConstructor.resolve(1);

  var FakePromise = function FakePromise(exec) {
    exec(function () {
      /* empty */
    }, function () {
      /* empty */
    });
  };

  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  return !(promise.then(function () {
    /* empty */
  }) instanceof FakePromise);
});
var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () {
    /* empty */
  });
}); // helpers

var isThenable = function isThenable(it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function notify(state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0; // variable length - can't use forEach

    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
            state.rejection = HANDLED;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // can throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }

    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(state);
  });
};

var dispatchEvent = function dispatchEvent(name, promise, reason) {
  var event, handler;

  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = {
    promise: promise,
    reason: reason
  };

  if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name])) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function onUnhandled(state) {
  task.call(global, function () {
    var promise = state.facade;
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;

    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function isUnhandled(state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function onHandleUnhandled(state) {
  task.call(global, function () {
    var promise = state.facade;

    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function bind(fn, state, unwrap) {
  return function (value) {
    fn(state, value, unwrap);
  };
};

var internalReject = function internalReject(state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(state, true);
};

var internalResolve = function internalResolve(state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;

  try {
    if (state.facade === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);

    if (then) {
      microtask(function () {
        var wrapper = {
          done: false
        };

        try {
          then.call(value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state));
        } catch (error) {
          internalReject(wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(state, false);
    }
  } catch (error) {
    internalReject({
      done: false
    }, error, state);
  }
}; // constructor polyfill


if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);

    try {
      executor(bind(internalResolve, state), bind(internalReject, state));
    } catch (error) {
      internalReject(state, error);
    }
  }; // eslint-disable-next-line no-unused-vars -- required for `.length`


  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };

  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.es/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.es/ecma262/#sec-promise.prototype.catch
    'catch': function _catch(onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function OwnPromiseCapability() {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, state);
    this.reject = bind(internalReject, state);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
    return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && typeof NativePromise == 'function') {
    nativeThen = NativePromise.prototype.then; // wrap native Promise#then for native async functions

    redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected); // https://github.com/zloirock/core-js/issues/640
    }, {
      unsafe: true
    }); // wrap fetch result

    if (typeof $fetch == 'function') $({
      global: true,
      enumerable: true,
      forced: true
    }, {
      // eslint-disable-next-line no-unused-vars -- required for `.length`
      fetch: function fetch(input
      /* , init */
      ) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
      }
    });
  }
}

$({
  global: true,
  wrap: true,
  forced: FORCED
}, {
  Promise: PromiseConstructor
});
setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);
PromiseWrapper = getBuiltIn(PROMISE); // statics

$({
  target: PROMISE,
  stat: true,
  forced: FORCED
}, {
  // `Promise.reject` method
  // https://tc39.es/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});
$({
  target: PROMISE,
  stat: true,
  forced: IS_PURE || FORCED
}, {
  // `Promise.resolve` method
  // https://tc39.es/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});
$({
  target: PROMISE,
  stat: true,
  forced: INCORRECT_ITERATION
}, {
  // `Promise.all` method
  // https://tc39.es/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.es/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});

/***/ }),

/***/ 89755:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var getBuiltIn = __webpack_require__(40866);

var aFunction = __webpack_require__(27709);

var anObject = __webpack_require__(52943);

var fails = __webpack_require__(45200);

var nativeApply = getBuiltIn('Reflect', 'apply');
var functionApply = Function.apply; // MS Edge argumentsList argument is optional

var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
  nativeApply(function () {
    /* empty */
  });
}); // `Reflect.apply` method
// https://tc39.es/ecma262/#sec-reflect.apply

$({
  target: 'Reflect',
  stat: true,
  forced: OPTIONAL_ARGUMENTS_LIST
}, {
  apply: function apply(target, thisArgument, argumentsList) {
    aFunction(target);
    anObject(argumentsList);
    return nativeApply ? nativeApply(target, thisArgument, argumentsList) : functionApply.call(target, thisArgument, argumentsList);
  }
});

/***/ }),

/***/ 60669:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var getBuiltIn = __webpack_require__(40866);

var aFunction = __webpack_require__(27709);

var anObject = __webpack_require__(52943);

var isObject = __webpack_require__(74194);

var create = __webpack_require__(1578);

var bind = __webpack_require__(89723);

var fails = __webpack_require__(45200);

var nativeConstruct = getBuiltIn('Reflect', 'construct'); // `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails(function () {
  function F() {
    /* empty */
  }

  return !(nativeConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  nativeConstruct(function () {
    /* empty */
  });
});
var FORCED = NEW_TARGET_BUG || ARGS_BUG;
$({
  target: 'Reflect',
  stat: true,
  forced: FORCED,
  sham: FORCED
}, {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),

/***/ 91921:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var DESCRIPTORS = __webpack_require__(9811);

var anObject = __webpack_require__(52943);

var toPrimitive = __webpack_require__(36238);

var definePropertyModule = __webpack_require__(45070);

var fails = __webpack_require__(45200); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


var ERROR_INSTEAD_OF_FALSE = fails(function () {
  /* global Reflect -- required for testing */
  Reflect.defineProperty(definePropertyModule.f({}, 1, {
    value: 1
  }), 1, {
    value: 2
  });
}); // `Reflect.defineProperty` method
// https://tc39.es/ecma262/#sec-reflect.defineproperty

$({
  target: 'Reflect',
  stat: true,
  forced: ERROR_INSTEAD_OF_FALSE,
  sham: !DESCRIPTORS
}, {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    var key = toPrimitive(propertyKey, true);
    anObject(attributes);

    try {
      definePropertyModule.f(target, key, attributes);
      return true;
    } catch (error) {
      return false;
    }
  }
});

/***/ }),

/***/ 433:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var anObject = __webpack_require__(52943);

var getOwnPropertyDescriptor = __webpack_require__(22130).f; // `Reflect.deleteProperty` method
// https://tc39.es/ecma262/#sec-reflect.deleteproperty


$({
  target: 'Reflect',
  stat: true
}, {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
    return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),

/***/ 32402:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var DESCRIPTORS = __webpack_require__(9811);

var anObject = __webpack_require__(52943);

var getOwnPropertyDescriptorModule = __webpack_require__(22130); // `Reflect.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-reflect.getownpropertydescriptor


$({
  target: 'Reflect',
  stat: true,
  sham: !DESCRIPTORS
}, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
  }
});

/***/ }),

/***/ 62066:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var anObject = __webpack_require__(52943);

var objectGetPrototypeOf = __webpack_require__(35651);

var CORRECT_PROTOTYPE_GETTER = __webpack_require__(20457); // `Reflect.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-reflect.getprototypeof


$({
  target: 'Reflect',
  stat: true,
  sham: !CORRECT_PROTOTYPE_GETTER
}, {
  getPrototypeOf: function getPrototypeOf(target) {
    return objectGetPrototypeOf(anObject(target));
  }
});

/***/ }),

/***/ 97004:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var isObject = __webpack_require__(74194);

var anObject = __webpack_require__(52943);

var has = __webpack_require__(38928);

var getOwnPropertyDescriptorModule = __webpack_require__(22130);

var getPrototypeOf = __webpack_require__(35651); // `Reflect.get` method
// https://tc39.es/ecma262/#sec-reflect.get


function get(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  if (descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey)) return has(descriptor, 'value') ? descriptor.value : descriptor.get === undefined ? undefined : descriptor.get.call(receiver);
  if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}

$({
  target: 'Reflect',
  stat: true
}, {
  get: get
});

/***/ }),

/***/ 56071:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064); // `Reflect.has` method
// https://tc39.es/ecma262/#sec-reflect.has


$({
  target: 'Reflect',
  stat: true
}, {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

/***/ }),

/***/ 71058:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var anObject = __webpack_require__(52943);

var objectIsExtensible = Object.isExtensible; // `Reflect.isExtensible` method
// https://tc39.es/ecma262/#sec-reflect.isextensible

$({
  target: 'Reflect',
  stat: true
}, {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return objectIsExtensible ? objectIsExtensible(target) : true;
  }
});

/***/ }),

/***/ 93292:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var ownKeys = __webpack_require__(15732); // `Reflect.ownKeys` method
// https://tc39.es/ecma262/#sec-reflect.ownkeys


$({
  target: 'Reflect',
  stat: true
}, {
  ownKeys: ownKeys
});

/***/ }),

/***/ 18961:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var getBuiltIn = __webpack_require__(40866);

var anObject = __webpack_require__(52943);

var FREEZING = __webpack_require__(10940); // `Reflect.preventExtensions` method
// https://tc39.es/ecma262/#sec-reflect.preventextensions


$({
  target: 'Reflect',
  stat: true,
  sham: !FREEZING
}, {
  preventExtensions: function preventExtensions(target) {
    anObject(target);

    try {
      var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
      if (objectPreventExtensions) objectPreventExtensions(target);
      return true;
    } catch (error) {
      return false;
    }
  }
});

/***/ }),

/***/ 58055:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var anObject = __webpack_require__(52943);

var aPossiblePrototype = __webpack_require__(21892);

var objectSetPrototypeOf = __webpack_require__(40616); // `Reflect.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-reflect.setprototypeof


if (objectSetPrototypeOf) $({
  target: 'Reflect',
  stat: true
}, {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    anObject(target);
    aPossiblePrototype(proto);

    try {
      objectSetPrototypeOf(target, proto);
      return true;
    } catch (error) {
      return false;
    }
  }
});

/***/ }),

/***/ 89869:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var anObject = __webpack_require__(52943);

var isObject = __webpack_require__(74194);

var has = __webpack_require__(38928);

var fails = __webpack_require__(45200);

var definePropertyModule = __webpack_require__(45070);

var getOwnPropertyDescriptorModule = __webpack_require__(22130);

var getPrototypeOf = __webpack_require__(35651);

var createPropertyDescriptor = __webpack_require__(22424); // `Reflect.set` method
// https://tc39.es/ecma262/#sec-reflect.set


function set(target, propertyKey, V
/* , receiver */
) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
  var existingDescriptor, prototype;

  if (!ownDescriptor) {
    if (isObject(prototype = getPrototypeOf(target))) {
      return set(prototype, propertyKey, V, receiver);
    }

    ownDescriptor = createPropertyDescriptor(0);
  }

  if (has(ownDescriptor, 'value')) {
    if (ownDescriptor.writable === false || !isObject(receiver)) return false;

    if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      definePropertyModule.f(receiver, propertyKey, existingDescriptor);
    } else definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V));

    return true;
  }

  return ownDescriptor.set === undefined ? false : (ownDescriptor.set.call(receiver, V), true);
} // MS Edge 17-18 Reflect.set allows setting the property to object
// with non-writable property on the prototype


var MS_EDGE_BUG = fails(function () {
  var Constructor = function Constructor() {
    /* empty */
  };

  var object = definePropertyModule.f(new Constructor(), 'a', {
    configurable: true
  });
  /* global Reflect -- required for testing */

  return Reflect.set(Constructor.prototype, 'a', 1, object) !== false;
});
$({
  target: 'Reflect',
  stat: true,
  forced: MS_EDGE_BUG
}, {
  set: set
});

/***/ }),

/***/ 22071:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var global = __webpack_require__(52586);

var setToStringTag = __webpack_require__(46736);

$({
  global: true
}, {
  Reflect: {}
}); // Reflect[@@toStringTag] property
// https://tc39.es/ecma262/#sec-reflect-@@tostringtag

setToStringTag(global.Reflect, 'Reflect', true);

/***/ }),

/***/ 88513:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(9811);

var global = __webpack_require__(52586);

var isForced = __webpack_require__(40695);

var inheritIfRequired = __webpack_require__(57170);

var defineProperty = __webpack_require__(45070).f;

var getOwnPropertyNames = __webpack_require__(72205).f;

var isRegExp = __webpack_require__(26582);

var getFlags = __webpack_require__(61089);

var stickyHelpers = __webpack_require__(11426);

var redefine = __webpack_require__(44469);

var fails = __webpack_require__(45200);

var setInternalState = __webpack_require__(59351).set;

var setSpecies = __webpack_require__(94847);

var wellKnownSymbol = __webpack_require__(65373);

var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" should create a new object, old webkit bug

var CORRECT_NEW = new NativeRegExp(re1) !== re1;
var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var FORCED = DESCRIPTORS && isForced('RegExp', !CORRECT_NEW || UNSUPPORTED_Y || fails(function () {
  re2[MATCH] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})); // `RegExp` constructor
// https://tc39.es/ecma262/#sec-regexp-constructor

if (FORCED) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    var sticky;

    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
      return pattern;
    }

    if (CORRECT_NEW) {
      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
    } else if (pattern instanceof RegExpWrapper) {
      if (flagsAreUndefined) flags = getFlags.call(pattern);
      pattern = pattern.source;
    }

    if (UNSUPPORTED_Y) {
      sticky = !!flags && flags.indexOf('y') > -1;
      if (sticky) flags = flags.replace(/y/g, '');
    }

    var result = inheritIfRequired(CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
    if (UNSUPPORTED_Y && sticky) setInternalState(result, {
      sticky: sticky
    });
    return result;
  };

  var proxy = function proxy(key) {
    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
      configurable: true,
      get: function get() {
        return NativeRegExp[key];
      },
      set: function set(it) {
        NativeRegExp[key] = it;
      }
    });
  };

  var keys = getOwnPropertyNames(NativeRegExp);
  var index = 0;

  while (keys.length > index) {
    proxy(keys[index++]);
  }

  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  redefine(global, 'RegExp', RegExpWrapper);
} // https://tc39.es/ecma262/#sec-get-regexp-@@species


setSpecies('RegExp');

/***/ }),

/***/ 30144:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var exec = __webpack_require__(34646); // `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec


$({
  target: 'RegExp',
  proto: true,
  forced: /./.exec !== exec
}, {
  exec: exec
});

/***/ }),

/***/ 73357:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(9811);

var objectDefinePropertyModule = __webpack_require__(45070);

var regExpFlags = __webpack_require__(61089);

var UNSUPPORTED_Y = __webpack_require__(11426).UNSUPPORTED_Y; // `RegExp.prototype.flags` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags


if (DESCRIPTORS && (/./g.flags != 'g' || UNSUPPORTED_Y)) {
  objectDefinePropertyModule.f(RegExp.prototype, 'flags', {
    configurable: true,
    get: regExpFlags
  });
}

/***/ }),

/***/ 79393:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var DESCRIPTORS = __webpack_require__(9811);

var UNSUPPORTED_Y = __webpack_require__(11426).UNSUPPORTED_Y;

var defineProperty = __webpack_require__(45070).f;

var getInternalState = __webpack_require__(59351).get;

var RegExpPrototype = RegExp.prototype; // `RegExp.prototype.sticky` getter
// https://tc39.es/ecma262/#sec-get-regexp.prototype.sticky

if (DESCRIPTORS && UNSUPPORTED_Y) {
  defineProperty(RegExp.prototype, 'sticky', {
    configurable: true,
    get: function get() {
      if (this === RegExpPrototype) return undefined; // We can't use InternalStateModule.getterFor because
      // we don't add metadata for regexps created by a literal.

      if (this instanceof RegExp) {
        return !!getInternalState(this).sticky;
      }

      throw TypeError('Incompatible receiver, RegExp required');
    }
  });
}

/***/ }),

/***/ 44261:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // TODO: Remove from `core-js@4` since it's moved to entry points

__webpack_require__(30144);

var $ = __webpack_require__(53064);

var isObject = __webpack_require__(74194);

var DELEGATES_TO_EXEC = function () {
  var execCalled = false;
  var re = /[ac]/;

  re.exec = function () {
    execCalled = true;
    return /./.exec.apply(this, arguments);
  };

  return re.test('abc') === true && execCalled;
}();

var nativeTest = /./.test; // `RegExp.prototype.test` method
// https://tc39.es/ecma262/#sec-regexp.prototype.test

$({
  target: 'RegExp',
  proto: true,
  forced: !DELEGATES_TO_EXEC
}, {
  test: function test(str) {
    if (typeof this.exec !== 'function') {
      return nativeTest.call(this, str);
    }

    var result = this.exec(str);

    if (result !== null && !isObject(result)) {
      throw new Error('RegExp exec method returned something other than an Object or null');
    }

    return !!result;
  }
});

/***/ }),

/***/ 6408:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var redefine = __webpack_require__(44469);

var anObject = __webpack_require__(52943);

var fails = __webpack_require__(45200);

var flags = __webpack_require__(61089);

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];
var NOT_GENERIC = fails(function () {
  return nativeToString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
}); // FF44- RegExp#toString has a wrong name

var INCORRECT_NAME = nativeToString.name != TO_STRING; // `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring

if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
    return '/' + p + '/' + f;
  }, {
    unsafe: true
  });
}

/***/ }),

/***/ 90760:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var collection = __webpack_require__(79524);

var collectionStrong = __webpack_require__(76702); // `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects


module.exports = collection('Set', function (init) {
  return function Set() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionStrong);

/***/ }),

/***/ 92574:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.anchor` method
// https://tc39.es/ecma262/#sec-string.prototype.anchor


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('anchor')
}, {
  anchor: function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  }
});

/***/ }),

/***/ 13195:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.big` method
// https://tc39.es/ecma262/#sec-string.prototype.big


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('big')
}, {
  big: function big() {
    return createHTML(this, 'big', '', '');
  }
});

/***/ }),

/***/ 4831:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.blink` method
// https://tc39.es/ecma262/#sec-string.prototype.blink


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('blink')
}, {
  blink: function blink() {
    return createHTML(this, 'blink', '', '');
  }
});

/***/ }),

/***/ 48168:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.bold` method
// https://tc39.es/ecma262/#sec-string.prototype.bold


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('bold')
}, {
  bold: function bold() {
    return createHTML(this, 'b', '', '');
  }
});

/***/ }),

/***/ 82394:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var codeAt = __webpack_require__(36726).codeAt; // `String.prototype.codePointAt` method
// https://tc39.es/ecma262/#sec-string.prototype.codepointat


$({
  target: 'String',
  proto: true
}, {
  codePointAt: function codePointAt(pos) {
    return codeAt(this, pos);
  }
});

/***/ }),

/***/ 23920:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var getOwnPropertyDescriptor = __webpack_require__(22130).f;

var toLength = __webpack_require__(49152);

var notARegExp = __webpack_require__(41029);

var requireObjectCoercible = __webpack_require__(20877);

var correctIsRegExpLogic = __webpack_require__(23264);

var IS_PURE = __webpack_require__(58855);

var nativeEndsWith = ''.endsWith;
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('endsWith'); // https://github.com/zloirock/core-js/pull/702

var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
  return descriptor && !descriptor.writable;
}(); // `String.prototype.endsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.endswith

$({
  target: 'String',
  proto: true,
  forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
  endsWith: function endsWith(searchString
  /* , endPosition = @length */
  ) {
    var that = String(requireObjectCoercible(this));
    notARegExp(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : min(toLength(endPosition), len);
    var search = String(searchString);
    return nativeEndsWith ? nativeEndsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),

/***/ 74451:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.fixed` method
// https://tc39.es/ecma262/#sec-string.prototype.fixed


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('fixed')
}, {
  fixed: function fixed() {
    return createHTML(this, 'tt', '', '');
  }
});

/***/ }),

/***/ 89332:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.fontcolor` method
// https://tc39.es/ecma262/#sec-string.prototype.fontcolor


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('fontcolor')
}, {
  fontcolor: function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  }
});

/***/ }),

/***/ 24904:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.fontsize` method
// https://tc39.es/ecma262/#sec-string.prototype.fontsize


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('fontsize')
}, {
  fontsize: function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  }
});

/***/ }),

/***/ 51409:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var toAbsoluteIndex = __webpack_require__(11652);

var fromCharCode = String.fromCharCode;
var nativeFromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1; // `String.fromCodePoint` method
// https://tc39.es/ecma262/#sec-string.fromcodepoint

$({
  target: 'String',
  stat: true,
  forced: INCORRECT_LENGTH
}, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  fromCodePoint: function fromCodePoint(x) {
    var elements = [];
    var length = arguments.length;
    var i = 0;
    var code;

    while (length > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError(code + ' is not a valid code point');
      elements.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00));
    }

    return elements.join('');
  }
});

/***/ }),

/***/ 7498:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var notARegExp = __webpack_require__(41029);

var requireObjectCoercible = __webpack_require__(20877);

var correctIsRegExpLogic = __webpack_require__(23264); // `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes


$({
  target: 'String',
  proto: true,
  forced: !correctIsRegExpLogic('includes')
}, {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~String(requireObjectCoercible(this)).indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ 79947:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.italics` method
// https://tc39.es/ecma262/#sec-string.prototype.italics


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('italics')
}, {
  italics: function italics() {
    return createHTML(this, 'i', '', '');
  }
});

/***/ }),

/***/ 46222:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var charAt = __webpack_require__(36726).charAt;

var InternalStateModule = __webpack_require__(59351);

var defineIterator = __webpack_require__(64079);

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator

defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  }); // `%StringIteratorPrototype%.next` method
  // https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return {
    value: undefined,
    done: true
  };
  point = charAt(string, index);
  state.index += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),

/***/ 14332:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.link` method
// https://tc39.es/ecma262/#sec-string.prototype.link


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('link')
}, {
  link: function link(url) {
    return createHTML(this, 'a', 'href', url);
  }
});

/***/ }),

/***/ 19945:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createIteratorConstructor = __webpack_require__(22006);

var requireObjectCoercible = __webpack_require__(20877);

var toLength = __webpack_require__(49152);

var aFunction = __webpack_require__(27709);

var anObject = __webpack_require__(52943);

var classof = __webpack_require__(700);

var isRegExp = __webpack_require__(26582);

var getRegExpFlags = __webpack_require__(61089);

var createNonEnumerableProperty = __webpack_require__(91705);

var fails = __webpack_require__(45200);

var wellKnownSymbol = __webpack_require__(65373);

var speciesConstructor = __webpack_require__(30646);

var advanceStringIndex = __webpack_require__(59607);

var InternalStateModule = __webpack_require__(59351);

var IS_PURE = __webpack_require__(58855);

var MATCH_ALL = wellKnownSymbol('matchAll');
var REGEXP_STRING = 'RegExp String';
var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
var RegExpPrototype = RegExp.prototype;
var regExpBuiltinExec = RegExpPrototype.exec;
var nativeMatchAll = ''.matchAll;
var WORKS_WITH_NON_GLOBAL_REGEX = !!nativeMatchAll && !fails(function () {
  'a'.matchAll(/./);
});

var regExpExec = function regExpExec(R, S) {
  var exec = R.exec;
  var result;

  if (typeof exec == 'function') {
    result = exec.call(R, S);
    if (typeof result != 'object') throw TypeError('Incorrect exec result');
    return result;
  }

  return regExpBuiltinExec.call(R, S);
}; // eslint-disable-next-line max-len -- ignore


var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, global, fullUnicode) {
  setInternalState(this, {
    type: REGEXP_STRING_ITERATOR,
    regexp: regexp,
    string: string,
    global: global,
    unicode: fullUnicode,
    done: false
  });
}, REGEXP_STRING, function next() {
  var state = getInternalState(this);
  if (state.done) return {
    value: undefined,
    done: true
  };
  var R = state.regexp;
  var S = state.string;
  var match = regExpExec(R, S);
  if (match === null) return {
    value: undefined,
    done: state.done = true
  };

  if (state.global) {
    if (String(match[0]) == '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
    return {
      value: match,
      done: false
    };
  }

  state.done = true;
  return {
    value: match,
    done: false
  };
});

var $matchAll = function $matchAll(string) {
  var R = anObject(this);
  var S = String(string);
  var C, flagsValue, flags, matcher, global, fullUnicode;
  C = speciesConstructor(R, RegExp);
  flagsValue = R.flags;

  if (flagsValue === undefined && R instanceof RegExp && !('flags' in RegExpPrototype)) {
    flagsValue = getRegExpFlags.call(R);
  }

  flags = flagsValue === undefined ? '' : String(flagsValue);
  matcher = new C(C === RegExp ? R.source : R, flags);
  global = !!~flags.indexOf('g');
  fullUnicode = !!~flags.indexOf('u');
  matcher.lastIndex = toLength(R.lastIndex);
  return new $RegExpStringIterator(matcher, S, global, fullUnicode);
}; // `String.prototype.matchAll` method
// https://tc39.es/ecma262/#sec-string.prototype.matchall


$({
  target: 'String',
  proto: true,
  forced: WORKS_WITH_NON_GLOBAL_REGEX
}, {
  matchAll: function matchAll(regexp) {
    var O = requireObjectCoercible(this);
    var flags, S, matcher, rx;

    if (regexp != null) {
      if (isRegExp(regexp)) {
        flags = String(requireObjectCoercible('flags' in RegExpPrototype ? regexp.flags : getRegExpFlags.call(regexp)));
        if (!~flags.indexOf('g')) throw TypeError('`.matchAll` does not allow non-global regexes');
      }

      if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll.apply(O, arguments);
      matcher = regexp[MATCH_ALL];
      if (matcher === undefined && IS_PURE && classof(regexp) == 'RegExp') matcher = $matchAll;
      if (matcher != null) return aFunction(matcher).call(regexp, O);
    } else if (WORKS_WITH_NON_GLOBAL_REGEX) return nativeMatchAll.apply(O, arguments);

    S = String(O);
    rx = new RegExp(regexp, 'g');
    return IS_PURE ? $matchAll.call(rx, S) : rx[MATCH_ALL](S);
  }
});
IS_PURE || MATCH_ALL in RegExpPrototype || createNonEnumerableProperty(RegExpPrototype, MATCH_ALL, $matchAll);

/***/ }),

/***/ 33419:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fixRegExpWellKnownSymbolLogic = __webpack_require__(54059);

var anObject = __webpack_require__(52943);

var toLength = __webpack_require__(49152);

var requireObjectCoercible = __webpack_require__(20877);

var advanceStringIndex = __webpack_require__(59607);

var regExpExec = __webpack_require__(3414); // @@match logic


fixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.es/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = requireObjectCoercible(this);
    var matcher = regexp == undefined ? undefined : regexp[MATCH];
    return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative(nativeMatch, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regExpExec(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regExpExec(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

/***/ }),

/***/ 24522:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $padEnd = __webpack_require__(72594).end;

var WEBKIT_BUG = __webpack_require__(82898); // `String.prototype.padEnd` method
// https://tc39.es/ecma262/#sec-string.prototype.padend


$({
  target: 'String',
  proto: true,
  forced: WEBKIT_BUG
}, {
  padEnd: function padEnd(maxLength
  /* , fillString = ' ' */
  ) {
    return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ 37692:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $padStart = __webpack_require__(72594).start;

var WEBKIT_BUG = __webpack_require__(82898); // `String.prototype.padStart` method
// https://tc39.es/ecma262/#sec-string.prototype.padstart


$({
  target: 'String',
  proto: true,
  forced: WEBKIT_BUG
}, {
  padStart: function padStart(maxLength
  /* , fillString = ' ' */
  ) {
    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ 34828:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var toIndexedObject = __webpack_require__(20829);

var toLength = __webpack_require__(49152); // `String.raw` method
// https://tc39.es/ecma262/#sec-string.raw


$({
  target: 'String',
  stat: true
}, {
  raw: function raw(template) {
    var rawTemplate = toIndexedObject(template.raw);
    var literalSegments = toLength(rawTemplate.length);
    var argumentsLength = arguments.length;
    var elements = [];
    var i = 0;

    while (literalSegments > i) {
      elements.push(String(rawTemplate[i++]));
      if (i < argumentsLength) elements.push(String(arguments[i]));
    }

    return elements.join('');
  }
});

/***/ }),

/***/ 15868:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var repeat = __webpack_require__(90971); // `String.prototype.repeat` method
// https://tc39.es/ecma262/#sec-string.prototype.repeat


$({
  target: 'String',
  proto: true
}, {
  repeat: repeat
});

/***/ }),

/***/ 97740:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var requireObjectCoercible = __webpack_require__(20877);

var isRegExp = __webpack_require__(26582);

var getRegExpFlags = __webpack_require__(61089);

var getSubstitution = __webpack_require__(79854);

var wellKnownSymbol = __webpack_require__(65373);

var IS_PURE = __webpack_require__(58855);

var REPLACE = wellKnownSymbol('replace');
var RegExpPrototype = RegExp.prototype;
var max = Math.max;

var stringIndexOf = function stringIndexOf(string, searchValue, fromIndex) {
  if (fromIndex > string.length) return -1;
  if (searchValue === '') return fromIndex;
  return string.indexOf(searchValue, fromIndex);
}; // `String.prototype.replaceAll` method
// https://tc39.es/ecma262/#sec-string.prototype.replaceall


$({
  target: 'String',
  proto: true
}, {
  replaceAll: function replaceAll(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var IS_REG_EXP, flags, replacer, string, searchString, functionalReplace, searchLength, advanceBy, replacement;
    var position = 0;
    var endOfLastMatch = 0;
    var result = '';

    if (searchValue != null) {
      IS_REG_EXP = isRegExp(searchValue);

      if (IS_REG_EXP) {
        flags = String(requireObjectCoercible('flags' in RegExpPrototype ? searchValue.flags : getRegExpFlags.call(searchValue)));
        if (!~flags.indexOf('g')) throw TypeError('`.replaceAll` does not allow non-global regexes');
      }

      replacer = searchValue[REPLACE];

      if (replacer !== undefined) {
        return replacer.call(searchValue, O, replaceValue);
      } else if (IS_PURE && IS_REG_EXP) {
        return String(O).replace(searchValue, replaceValue);
      }
    }

    string = String(O);
    searchString = String(searchValue);
    functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    searchLength = searchString.length;
    advanceBy = max(1, searchLength);
    position = stringIndexOf(string, searchString, 0);

    while (position !== -1) {
      if (functionalReplace) {
        replacement = String(replaceValue(searchString, position, string));
      } else {
        replacement = getSubstitution(searchString, string, position, [], undefined, replaceValue);
      }

      result += string.slice(endOfLastMatch, position) + replacement;
      endOfLastMatch = position + searchLength;
      position = stringIndexOf(string, searchString, position + advanceBy);
    }

    if (endOfLastMatch < string.length) {
      result += string.slice(endOfLastMatch);
    }

    return result;
  }
});

/***/ }),

/***/ 11035:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fixRegExpWellKnownSymbolLogic = __webpack_require__(54059);

var anObject = __webpack_require__(52943);

var toLength = __webpack_require__(49152);

var toInteger = __webpack_require__(1324);

var requireObjectCoercible = __webpack_require__(20877);

var advanceStringIndex = __webpack_require__(59607);

var getSubstitution = __webpack_require__(79854);

var regExpExec = __webpack_require__(3414);

var max = Math.max;
var min = Math.min;

var maybeToString = function maybeToString(it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
  return [// `String.prototype.replace` method
  // https://tc39.es/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = requireObjectCoercible(this);
    var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
    return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
      var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
      if (res.done) return res.value;
    }

    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regExpExec(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max(min(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) {
        captures.push(maybeToString(result[j]));
      }

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }];
});

/***/ }),

/***/ 85021:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fixRegExpWellKnownSymbolLogic = __webpack_require__(54059);

var anObject = __webpack_require__(52943);

var requireObjectCoercible = __webpack_require__(20877);

var sameValue = __webpack_require__(70871);

var regExpExec = __webpack_require__(3414); // @@search logic


fixRegExpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
  return [// `String.prototype.search` method
  // https://tc39.es/ecma262/#sec-string.prototype.search
  function search(regexp) {
    var O = requireObjectCoercible(this);
    var searcher = regexp == undefined ? undefined : regexp[SEARCH];
    return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, // `RegExp.prototype[@@search]` method
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
  function (regexp) {
    var res = maybeCallNative(nativeSearch, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var previousLastIndex = rx.lastIndex;
    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
    var result = regExpExec(rx, S);
    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
    return result === null ? -1 : result.index;
  }];
});

/***/ }),

/***/ 81356:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.small` method
// https://tc39.es/ecma262/#sec-string.prototype.small


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('small')
}, {
  small: function small() {
    return createHTML(this, 'small', '', '');
  }
});

/***/ }),

/***/ 51174:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var fixRegExpWellKnownSymbolLogic = __webpack_require__(54059);

var isRegExp = __webpack_require__(26582);

var anObject = __webpack_require__(52943);

var requireObjectCoercible = __webpack_require__(20877);

var speciesConstructor = __webpack_require__(30646);

var advanceStringIndex = __webpack_require__(59607);

var toLength = __webpack_require__(49152);

var callRegExpExec = __webpack_require__(3414);

var regexpExec = __webpack_require__(34646);

var fails = __webpack_require__(45200);

var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 0xFFFFFFFF; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

var SUPPORTS_Y = !fails(function () {
  return !RegExp(MAX_UINT32, 'y');
}); // @@split logic

fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;

  if ('abbc'.split(/(b)*/)[1] == 'c' || // eslint-disable-next-line regexp/no-empty-group -- required for testing
  'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
  '.'.split(/()()/).length > 1 || ''.split(/.?/).length) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function internalSplit(separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string]; // If `separator` is not a regex, use native split

      if (!isRegExp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }

      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }

        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }

      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output.length > lim ? output.slice(0, lim) : output;
    }; // Chakra, V8

  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function internalSplit(separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [// `String.prototype.split` method
  // https://tc39.es/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = requireObjectCoercible(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
}, !SUPPORTS_Y);

/***/ }),

/***/ 52560:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var getOwnPropertyDescriptor = __webpack_require__(22130).f;

var toLength = __webpack_require__(49152);

var notARegExp = __webpack_require__(41029);

var requireObjectCoercible = __webpack_require__(20877);

var correctIsRegExpLogic = __webpack_require__(23264);

var IS_PURE = __webpack_require__(58855);

var nativeStartsWith = ''.startsWith;
var min = Math.min;
var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith'); // https://github.com/zloirock/core-js/pull/702

var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
  return descriptor && !descriptor.writable;
}(); // `String.prototype.startsWith` method
// https://tc39.es/ecma262/#sec-string.prototype.startswith

$({
  target: 'String',
  proto: true,
  forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
}, {
  startsWith: function startsWith(searchString
  /* , position = 0 */
  ) {
    var that = String(requireObjectCoercible(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return nativeStartsWith ? nativeStartsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),

/***/ 42548:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.strike` method
// https://tc39.es/ecma262/#sec-string.prototype.strike


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('strike')
}, {
  strike: function strike() {
    return createHTML(this, 'strike', '', '');
  }
});

/***/ }),

/***/ 95896:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.sub` method
// https://tc39.es/ecma262/#sec-string.prototype.sub


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('sub')
}, {
  sub: function sub() {
    return createHTML(this, 'sub', '', '');
  }
});

/***/ }),

/***/ 67155:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var createHTML = __webpack_require__(9015);

var forcedStringHTMLMethod = __webpack_require__(28234); // `String.prototype.sup` method
// https://tc39.es/ecma262/#sec-string.prototype.sup


$({
  target: 'String',
  proto: true,
  forced: forcedStringHTMLMethod('sup')
}, {
  sup: function sup() {
    return createHTML(this, 'sup', '', '');
  }
});

/***/ }),

/***/ 79055:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $trimEnd = __webpack_require__(86392).end;

var forcedStringTrimMethod = __webpack_require__(17273);

var FORCED = forcedStringTrimMethod('trimEnd');
var trimEnd = FORCED ? function trimEnd() {
  return $trimEnd(this);
} : ''.trimEnd; // `String.prototype.{ trimEnd, trimRight }` methods
// https://tc39.es/ecma262/#sec-string.prototype.trimend
// https://tc39.es/ecma262/#String.prototype.trimright

$({
  target: 'String',
  proto: true,
  forced: FORCED
}, {
  trimEnd: trimEnd,
  trimRight: trimEnd
});

/***/ }),

/***/ 37039:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $trimStart = __webpack_require__(86392).start;

var forcedStringTrimMethod = __webpack_require__(17273);

var FORCED = forcedStringTrimMethod('trimStart');
var trimStart = FORCED ? function trimStart() {
  return $trimStart(this);
} : ''.trimStart; // `String.prototype.{ trimStart, trimLeft }` methods
// https://tc39.es/ecma262/#sec-string.prototype.trimstart
// https://tc39.es/ecma262/#String.prototype.trimleft

$({
  target: 'String',
  proto: true,
  forced: FORCED
}, {
  trimStart: trimStart,
  trimLeft: trimStart
});

/***/ }),

/***/ 12660:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var $trim = __webpack_require__(86392).trim;

var forcedStringTrimMethod = __webpack_require__(17273); // `String.prototype.trim` method
// https://tc39.es/ecma262/#sec-string.prototype.trim


$({
  target: 'String',
  proto: true,
  forced: forcedStringTrimMethod('trim')
}, {
  trim: function trim() {
    return $trim(this);
  }
});

/***/ }),

/***/ 16655:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.asyncIterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.asynciterator


defineWellKnownSymbol('asyncIterator');

/***/ }),

/***/ 25377:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description


var $ = __webpack_require__(53064);

var DESCRIPTORS = __webpack_require__(9811);

var global = __webpack_require__(52586);

var has = __webpack_require__(38928);

var isObject = __webpack_require__(74194);

var defineProperty = __webpack_require__(45070).f;

var copyConstructorProperties = __webpack_require__(58376);

var NativeSymbol = global.Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) || // Safari 12 bug
NativeSymbol().description !== undefined)) {
  var EmptyStringDescriptionStore = {}; // wrap Symbol constructor for correct work with undefined description

  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper ? new NativeSymbol(description) // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
    : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };

  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;
  var symbolToString = symbolPrototype.toString;

  var _native = String(NativeSymbol('test')) == 'Symbol(test)';

  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = _native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });
  $({
    global: true,
    forced: true
  }, {
    Symbol: SymbolWrapper
  });
}

/***/ }),

/***/ 75487:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.hasInstance` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.hasinstance


defineWellKnownSymbol('hasInstance');

/***/ }),

/***/ 80581:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable


defineWellKnownSymbol('isConcatSpreadable');

/***/ }),

/***/ 14133:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator


defineWellKnownSymbol('iterator');

/***/ }),

/***/ 73346:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064);

var global = __webpack_require__(52586);

var getBuiltIn = __webpack_require__(40866);

var IS_PURE = __webpack_require__(58855);

var DESCRIPTORS = __webpack_require__(9811);

var NATIVE_SYMBOL = __webpack_require__(67893);

var USE_SYMBOL_AS_UID = __webpack_require__(93880);

var fails = __webpack_require__(45200);

var has = __webpack_require__(38928);

var isArray = __webpack_require__(96306);

var isObject = __webpack_require__(74194);

var anObject = __webpack_require__(52943);

var toObject = __webpack_require__(25769);

var toIndexedObject = __webpack_require__(20829);

var toPrimitive = __webpack_require__(36238);

var createPropertyDescriptor = __webpack_require__(22424);

var nativeObjectCreate = __webpack_require__(1578);

var objectKeys = __webpack_require__(12656);

var getOwnPropertyNamesModule = __webpack_require__(72205);

var getOwnPropertyNamesExternal = __webpack_require__(62020);

var getOwnPropertySymbolsModule = __webpack_require__(32693);

var getOwnPropertyDescriptorModule = __webpack_require__(22130);

var definePropertyModule = __webpack_require__(45070);

var propertyIsEnumerableModule = __webpack_require__(2962);

var createNonEnumerableProperty = __webpack_require__(91705);

var redefine = __webpack_require__(44469);

var shared = __webpack_require__(14707);

var sharedKey = __webpack_require__(60759);

var hiddenKeys = __webpack_require__(29841);

var uid = __webpack_require__(97214);

var wellKnownSymbol = __webpack_require__(65373);

var wrappedWellKnownSymbolModule = __webpack_require__(12002);

var defineWellKnownSymbol = __webpack_require__(56564);

var setToStringTag = __webpack_require__(46736);

var InternalStateModule = __webpack_require__(59351);

var $forEach = __webpack_require__(11729).forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function get() {
      return nativeDefineProperty(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);

  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function wrap(tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);

  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, {
        enumerable: createPropertyDescriptor(0, false)
      });
    }

    return setSymbolDescriptor(O, key, Attributes);
  }

  return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);

  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }

  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
}; // `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor


if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);

    var setter = function setter(value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };

    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
      configurable: true,
      set: setter
    });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });
  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });
  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });

    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
        unsafe: true
      });
    }
  }
}

$({
  global: true,
  wrap: true,
  forced: !NATIVE_SYMBOL,
  sham: !NATIVE_SYMBOL
}, {
  Symbol: $Symbol
});
$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});
$({
  target: SYMBOL,
  stat: true,
  forced: !NATIVE_SYMBOL
}, {
  // `Symbol.for` method
  // https://tc39.es/ecma262/#sec-symbol.for
  'for': function _for(key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.es/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function useSetter() {
    USE_SETTER = true;
  },
  useSimple: function useSimple() {
    USE_SETTER = false;
  }
});
$({
  target: 'Object',
  stat: true,
  forced: !NATIVE_SYMBOL,
  sham: !DESCRIPTORS
}, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});
$({
  target: 'Object',
  stat: true,
  forced: !NATIVE_SYMBOL
}, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443

$({
  target: 'Object',
  stat: true,
  forced: fails(function () {
    getOwnPropertySymbolsModule.f(1);
  })
}, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule.f(toObject(it));
  }
}); // `JSON.stringify` method behavior with symbols
// https://tc39.es/ecma262/#sec-json.stringify

if ($stringify) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
    var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

    return $stringify([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
    || $stringify({
      a: symbol
    }) != '{}' // V8 throws on boxed symbols
    || $stringify(Object(symbol)) != '{}';
  });
  $({
    target: 'JSON',
    stat: true,
    forced: FORCED_JSON_STRINGIFY
  }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;

      while (arguments.length > index) {
        args.push(arguments[index++]);
      }

      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

      if (!isArray(replacer)) replacer = function replacer(key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
} // `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive


if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
} // `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag


setToStringTag($Symbol, SYMBOL);
hiddenKeys[HIDDEN] = true;

/***/ }),

/***/ 8751:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.matchAll` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.matchall


defineWellKnownSymbol('matchAll');

/***/ }),

/***/ 32845:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.match` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.match


defineWellKnownSymbol('match');

/***/ }),

/***/ 45970:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.replace` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.replace


defineWellKnownSymbol('replace');

/***/ }),

/***/ 50863:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.search` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.search


defineWellKnownSymbol('search');

/***/ }),

/***/ 40055:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.species` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.species


defineWellKnownSymbol('species');

/***/ }),

/***/ 56995:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.split` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.split


defineWellKnownSymbol('split');

/***/ }),

/***/ 84032:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.toPrimitive` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.toprimitive


defineWellKnownSymbol('toPrimitive');

/***/ }),

/***/ 5498:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.toStringTag` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.tostringtag


defineWellKnownSymbol('toStringTag');

/***/ }),

/***/ 38144:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var defineWellKnownSymbol = __webpack_require__(56564); // `Symbol.unscopables` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.unscopables


defineWellKnownSymbol('unscopables');

/***/ }),

/***/ 42398:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $copyWithin = __webpack_require__(30707);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin

exportTypedArrayMethod('copyWithin', function copyWithin(target, start
/* , end */
) {
  return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});

/***/ }),

/***/ 41153:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $every = __webpack_require__(11729).every;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.every` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every

exportTypedArrayMethod('every', function every(callbackfn
/* , thisArg */
) {
  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

/***/ }),

/***/ 40986:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $fill = __webpack_require__(81);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.fill` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars -- required for `.length`

exportTypedArrayMethod('fill', function fill(value
/* , start, end */
) {
  return $fill.apply(aTypedArray(this), arguments);
});

/***/ }),

/***/ 89865:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $filter = __webpack_require__(11729).filter;

var fromSpeciesAndList = __webpack_require__(28939);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.filter` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter

exportTypedArrayMethod('filter', function filter(callbackfn
/* , thisArg */
) {
  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  return fromSpeciesAndList(this, list);
});

/***/ }),

/***/ 24393:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $findIndex = __webpack_require__(11729).findIndex;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex

exportTypedArrayMethod('findIndex', function findIndex(predicate
/* , thisArg */
) {
  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

/***/ }),

/***/ 13927:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $find = __webpack_require__(11729).find;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.find` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find

exportTypedArrayMethod('find', function find(predicate
/* , thisArg */
) {
  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});

/***/ }),

/***/ 19371:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var createTypedArrayConstructor = __webpack_require__(81767); // `Float32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects


createTypedArrayConstructor('Float32', function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ 18923:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var createTypedArrayConstructor = __webpack_require__(81767); // `Float64Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects


createTypedArrayConstructor('Float64', function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ 48334:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $forEach = __webpack_require__(11729).forEach;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.forEach` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach

exportTypedArrayMethod('forEach', function forEach(callbackfn
/* , thisArg */
) {
  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

/***/ }),

/***/ 25259:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(59225);

var exportTypedArrayStaticMethod = __webpack_require__(82094).exportTypedArrayStaticMethod;

var typedArrayFrom = __webpack_require__(22524); // `%TypedArray%.from` method
// https://tc39.es/ecma262/#sec-%typedarray%.from


exportTypedArrayStaticMethod('from', typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);

/***/ }),

/***/ 36457:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $includes = __webpack_require__(7255).includes;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.includes` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes

exportTypedArrayMethod('includes', function includes(searchElement
/* , fromIndex */
) {
  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

/***/ }),

/***/ 97282:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $indexOf = __webpack_require__(7255).indexOf;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof

exportTypedArrayMethod('indexOf', function indexOf(searchElement
/* , fromIndex */
) {
  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});

/***/ }),

/***/ 18599:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var createTypedArrayConstructor = __webpack_require__(81767); // `Int16Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects


createTypedArrayConstructor('Int16', function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ 29001:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var createTypedArrayConstructor = __webpack_require__(81767); // `Int32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects


createTypedArrayConstructor('Int32', function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ 4631:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var createTypedArrayConstructor = __webpack_require__(81767); // `Int8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects


createTypedArrayConstructor('Int8', function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ 69608:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var global = __webpack_require__(52586);

var ArrayBufferViewCore = __webpack_require__(82094);

var ArrayIterators = __webpack_require__(66668);

var wellKnownSymbol = __webpack_require__(65373);

var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array = global.Uint8Array;
var arrayValues = ArrayIterators.values;
var arrayKeys = ArrayIterators.keys;
var arrayEntries = ArrayIterators.entries;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];
var CORRECT_ITER_NAME = !!nativeTypedArrayIterator && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray(this));
}; // `%TypedArray%.prototype.entries` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries


exportTypedArrayMethod('entries', function entries() {
  return arrayEntries.call(aTypedArray(this));
}); // `%TypedArray%.prototype.keys` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys

exportTypedArrayMethod('keys', function keys() {
  return arrayKeys.call(aTypedArray(this));
}); // `%TypedArray%.prototype.values` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values

exportTypedArrayMethod('values', typedArrayValues, !CORRECT_ITER_NAME); // `%TypedArray%.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator

exportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);

/***/ }),

/***/ 83411:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $join = [].join; // `%TypedArray%.prototype.join` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars -- required for `.length`

exportTypedArrayMethod('join', function join(separator) {
  return $join.apply(aTypedArray(this), arguments);
});

/***/ }),

/***/ 33474:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $lastIndexOf = __webpack_require__(58792);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars -- required for `.length`

exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement
/* , fromIndex */
) {
  return $lastIndexOf.apply(aTypedArray(this), arguments);
});

/***/ }),

/***/ 55339:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $map = __webpack_require__(11729).map;

var speciesConstructor = __webpack_require__(30646);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.map` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map

exportTypedArrayMethod('map', function map(mapfn
/* , thisArg */
) {
  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
  });
});

/***/ }),

/***/ 50481:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(59225);

var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayStaticMethod = ArrayBufferViewCore.exportTypedArrayStaticMethod; // `%TypedArray%.of` method
// https://tc39.es/ecma262/#sec-%typedarray%.of

exportTypedArrayStaticMethod('of', function of()
/* ...items */
{
  var index = 0;
  var length = arguments.length;
  var result = new (aTypedArrayConstructor(this))(length);

  while (length > index) {
    result[index] = arguments[index++];
  }

  return result;
}, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);

/***/ }),

/***/ 79336:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $reduceRight = __webpack_require__(59892).right;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduceRicht` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright

exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn
/* , initialValue */
) {
  return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

/***/ }),

/***/ 79845:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $reduce = __webpack_require__(59892).left;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.reduce` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce

exportTypedArrayMethod('reduce', function reduce(callbackfn
/* , initialValue */
) {
  return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});

/***/ }),

/***/ 42528:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var floor = Math.floor; // `%TypedArray%.prototype.reverse` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse

exportTypedArrayMethod('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = floor(length / 2);
  var index = 0;
  var value;

  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  }

  return that;
});

/***/ }),

/***/ 94343:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var toLength = __webpack_require__(49152);

var toOffset = __webpack_require__(29575);

var toObject = __webpack_require__(25769);

var fails = __webpack_require__(45200);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var FORCED = fails(function () {
  /* global Int8Array -- safe */
  new Int8Array(1).set({});
}); // `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set

exportTypedArrayMethod('set', function set(arrayLike
/* , offset */
) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');

  while (index < len) {
    this[offset + index] = src[index++];
  }
}, FORCED);

/***/ }),

/***/ 66963:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var speciesConstructor = __webpack_require__(30646);

var fails = __webpack_require__(45200);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $slice = [].slice;
var FORCED = fails(function () {
  /* global Int8Array -- safe */
  new Int8Array(1).slice();
}); // `%TypedArray%.prototype.slice` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice

exportTypedArrayMethod('slice', function slice(start, end) {
  var list = $slice.call(aTypedArray(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);

  while (length > index) {
    result[index] = list[index++];
  }

  return result;
}, FORCED);

/***/ }),

/***/ 78579:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var $some = __webpack_require__(11729).some;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.some` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some

exportTypedArrayMethod('some', function some(callbackfn
/* , thisArg */
) {
  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});

/***/ }),

/***/ 86063:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $sort = [].sort; // `%TypedArray%.prototype.sort` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort

exportTypedArrayMethod('sort', function sort(comparefn) {
  return $sort.call(aTypedArray(this), comparefn);
});

/***/ }),

/***/ 63605:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var ArrayBufferViewCore = __webpack_require__(82094);

var toLength = __webpack_require__(49152);

var toAbsoluteIndex = __webpack_require__(11652);

var speciesConstructor = __webpack_require__(30646);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; // `%TypedArray%.prototype.subarray` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray

exportTypedArrayMethod('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(O.buffer, O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex));
});

/***/ }),

/***/ 90483:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var global = __webpack_require__(52586);

var ArrayBufferViewCore = __webpack_require__(82094);

var fails = __webpack_require__(45200);

var Int8Array = global.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var $slice = [].slice; // iOS Safari 6.x fails here

var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
  $toLocaleString.call(new Int8Array(1));
});
var FORCED = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
}); // `%TypedArray%.prototype.toLocaleString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring

exportTypedArrayMethod('toLocaleString', function toLocaleString() {
  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
}, FORCED);

/***/ }),

/***/ 88780:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var exportTypedArrayMethod = __webpack_require__(82094).exportTypedArrayMethod;

var fails = __webpack_require__(45200);

var global = __webpack_require__(52586);

var Uint8Array = global.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
var arrayToString = [].toString;
var arrayJoin = [].join;

if (fails(function () {
  arrayToString.call({});
})) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}

var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString; // `%TypedArray%.prototype.toString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring

exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);

/***/ }),

/***/ 47678:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var createTypedArrayConstructor = __webpack_require__(81767); // `Uint16Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects


createTypedArrayConstructor('Uint16', function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ 35160:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var createTypedArrayConstructor = __webpack_require__(81767); // `Uint32Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects


createTypedArrayConstructor('Uint32', function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ 8264:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var createTypedArrayConstructor = __webpack_require__(81767); // `Uint8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects


createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ 25227:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var createTypedArrayConstructor = __webpack_require__(81767); // `Uint8ClampedArray` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects


createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),

/***/ 19070:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var global = __webpack_require__(52586);

var redefineAll = __webpack_require__(3067);

var InternalMetadataModule = __webpack_require__(60648);

var collection = __webpack_require__(79524);

var collectionWeak = __webpack_require__(19026);

var isObject = __webpack_require__(74194);

var enforceIternalState = __webpack_require__(59351).enforce;

var NATIVE_WEAK_MAP = __webpack_require__(7740);

var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var isExtensible = Object.isExtensible;
var InternalWeakMap;

var wrapper = function wrapper(init) {
  return function WeakMap() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}; // `WeakMap` constructor
// https://tc39.es/ecma262/#sec-weakmap-constructor


var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak); // IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485

if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.REQUIRED = true;
  var WeakMapPrototype = $WeakMap.prototype;
  var nativeDelete = WeakMapPrototype['delete'];
  var nativeHas = WeakMapPrototype.has;
  var nativeGet = WeakMapPrototype.get;
  var nativeSet = WeakMapPrototype.set;
  redefineAll(WeakMapPrototype, {
    'delete': function _delete(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete.call(this, key) || state.frozen['delete'](key);
      }

      return nativeDelete.call(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas.call(this, key) || state.frozen.has(key);
      }

      return nativeHas.call(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
      }

      return nativeGet.call(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
      } else nativeSet.call(this, key, value);

      return this;
    }
  });
}

/***/ }),

/***/ 14677:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var collection = __webpack_require__(79524);

var collectionWeak = __webpack_require__(19026); // `WeakSet` constructor
// https://tc39.es/ecma262/#sec-weakset-constructor


collection('WeakSet', function (init) {
  return function WeakSet() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
}, collectionWeak);

/***/ }),

/***/ 16141:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var DOMIterables = __webpack_require__(15399);

var forEach = __webpack_require__(80980);

var createNonEnumerableProperty = __webpack_require__(91705);

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype; // some Chrome versions have non-configurable methods on DOMTokenList

  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}

/***/ }),

/***/ 75706:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var global = __webpack_require__(52586);

var DOMIterables = __webpack_require__(15399);

var ArrayIteratorMethods = __webpack_require__(66668);

var createNonEnumerableProperty = __webpack_require__(91705);

var wellKnownSymbol = __webpack_require__(65373);

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;

  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }

    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }

    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}

/***/ }),

/***/ 56573:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var global = __webpack_require__(52586);

var task = __webpack_require__(39250);

var FORCED = !global.setImmediate || !global.clearImmediate; // http://w3c.github.io/setImmediate/

$({
  global: true,
  bind: true,
  enumerable: true,
  forced: FORCED
}, {
  // `setImmediate` method
  // http://w3c.github.io/setImmediate/#si-setImmediate
  setImmediate: task.set,
  // `clearImmediate` method
  // http://w3c.github.io/setImmediate/#si-clearImmediate
  clearImmediate: task.clear
});

/***/ }),

/***/ 27273:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var global = __webpack_require__(52586);

var microtask = __webpack_require__(50119);

var IS_NODE = __webpack_require__(31292);

var process = global.process; // `queueMicrotask` method
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask

$({
  global: true,
  enumerable: true,
  noTargetGet: true
}, {
  queueMicrotask: function queueMicrotask(fn) {
    var domain = IS_NODE && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

/***/ }),

/***/ 43531:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(53064);

var global = __webpack_require__(52586);

var userAgent = __webpack_require__(62060);

var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function wrap(scheduler) {
  return function (handler, timeout
  /* , ...arguments */
  ) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : undefined;
    return scheduler(boundArgs ? function () {
      // eslint-disable-next-line no-new-func -- spec requirement
      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
    } : handler, timeout);
  };
}; // ie9- setTimeout & setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers


$({
  global: true,
  bind: true,
  forced: MSIE
}, {
  // `setTimeout` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
  setTimeout: wrap(global.setTimeout),
  // `setInterval` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
  setInterval: wrap(global.setInterval)
});

/***/ }),

/***/ 26253:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`

__webpack_require__(66668);

var $ = __webpack_require__(53064);

var getBuiltIn = __webpack_require__(40866);

var USE_NATIVE_URL = __webpack_require__(21486);

var redefine = __webpack_require__(44469);

var redefineAll = __webpack_require__(3067);

var setToStringTag = __webpack_require__(46736);

var createIteratorConstructor = __webpack_require__(22006);

var InternalStateModule = __webpack_require__(59351);

var anInstance = __webpack_require__(6441);

var hasOwn = __webpack_require__(38928);

var bind = __webpack_require__(81801);

var classof = __webpack_require__(84368);

var anObject = __webpack_require__(52943);

var isObject = __webpack_require__(74194);

var create = __webpack_require__(1578);

var createPropertyDescriptor = __webpack_require__(22424);

var getIterator = __webpack_require__(25221);

var getIteratorMethod = __webpack_require__(82093);

var wellKnownSymbol = __webpack_require__(65373);

var $fetch = getBuiltIn('fetch');
var Headers = getBuiltIn('Headers');
var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
var plus = /\+/g;
var sequences = Array(4);

var percentSequence = function percentSequence(bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};

var percentDecode = function percentDecode(sequence) {
  try {
    return decodeURIComponent(sequence);
  } catch (error) {
    return sequence;
  }
};

var deserialize = function deserialize(it) {
  var result = it.replace(plus, ' ');
  var bytes = 4;

  try {
    return decodeURIComponent(result);
  } catch (error) {
    while (bytes) {
      result = result.replace(percentSequence(bytes--), percentDecode);
    }

    return result;
  }
};

var find = /[!'()~]|%20/g;
var replace = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function replacer(match) {
  return replace[match];
};

var serialize = function serialize(it) {
  return encodeURIComponent(it).replace(find, replacer);
};

var parseSearchParams = function parseSearchParams(result, query) {
  if (query) {
    var attributes = query.split('&');
    var index = 0;
    var attribute, entry;

    while (index < attributes.length) {
      attribute = attributes[index++];

      if (attribute.length) {
        entry = attribute.split('=');
        result.push({
          key: deserialize(entry.shift()),
          value: deserialize(entry.join('='))
        });
      }
    }
  }
};

var updateSearchParams = function updateSearchParams(query) {
  this.entries.length = 0;
  parseSearchParams(this.entries, query);
};

var validateArgumentsLength = function validateArgumentsLength(passed, required) {
  if (passed < required) throw TypeError('Not enough arguments');
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind: kind
  });
}, 'Iterator', function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;

  if (!step.done) {
    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
  }

  return step;
}); // `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams

var URLSearchParamsConstructor = function URLSearchParams()
/* init */
{
  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  var that = this;
  var entries = [];
  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
  setInternalState(that, {
    type: URL_SEARCH_PARAMS,
    entries: entries,
    updateURL: function updateURL() {
      /* empty */
    },
    updateSearchParams: updateSearchParams
  });

  if (init !== undefined) {
    if (isObject(init)) {
      iteratorMethod = getIteratorMethod(init);

      if (typeof iteratorMethod === 'function') {
        iterator = iteratorMethod.call(init);
        next = iterator.next;

        while (!(step = next.call(iterator)).done) {
          entryIterator = getIterator(anObject(step.value));
          entryNext = entryIterator.next;
          if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done) throw TypeError('Expected sequence with length 2');
          entries.push({
            key: first.value + '',
            value: second.value + ''
          });
        }
      } else for (key in init) {
        if (hasOwn(init, key)) entries.push({
          key: key,
          value: init[key] + ''
        });
      }
    } else {
      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
    }
  }
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
redefineAll(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.append` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    validateArgumentsLength(arguments.length, 2);
    var state = getInternalParamsState(this);
    state.entries.push({
      key: name + '',
      value: value + ''
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function _delete(name) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var key = name + '';
    var index = 0;

    while (index < entries.length) {
      if (entries[index].key === key) entries.splice(index, 1);else index++;
    }

    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var index = 0;

    for (; index < entries.length; index++) {
      if (entries[index].key === key) return entries[index].value;
    }

    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var result = [];
    var index = 0;

    for (; index < entries.length; index++) {
      if (entries[index].key === key) result.push(entries[index].value);
    }

    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var index = 0;

    while (index < entries.length) {
      if (entries[index++].key === key) return true;
    }

    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var found = false;
    var key = name + '';
    var val = value + '';
    var index = 0;
    var entry;

    for (; index < entries.length; index++) {
      entry = entries[index];

      if (entry.key === key) {
        if (found) entries.splice(index--, 1);else {
          found = true;
          entry.value = val;
        }
      }
    }

    if (!found) entries.push({
      key: key,
      value: val
    });
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    var entries = state.entries; // Array#sort is not stable in some engines

    var slice = entries.slice();
    var entry, entriesIndex, sliceIndex;
    entries.length = 0;

    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
      entry = slice[sliceIndex];

      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
        if (entries[entriesIndex].key > entry.key) {
          entries.splice(entriesIndex, 0, entry);
          break;
        }
      }

      if (entriesIndex === sliceIndex) entries.push(entry);
    }

    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback
  /* , thisArg */
  ) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
    var index = 0;
    var entry;

    while (index < entries.length) {
      entry = entries[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, {
  enumerable: true
}); // `URLSearchParams.prototype[@@iterator]` method

redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries); // `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior

redefine(URLSearchParamsPrototype, 'toString', function toString() {
  var entries = getInternalParamsState(this).entries;
  var result = [];
  var index = 0;
  var entry;

  while (index < entries.length) {
    entry = entries[index++];
    result.push(serialize(entry.key) + '=' + serialize(entry.value));
  }

  return result.join('&');
}, {
  enumerable: true
});
setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
$({
  global: true,
  forced: !USE_NATIVE_URL
}, {
  URLSearchParams: URLSearchParamsConstructor
}); // Wrap `fetch` for correct work with polyfilled `URLSearchParams`
// https://github.com/zloirock/core-js/issues/674

if (!USE_NATIVE_URL && typeof $fetch == 'function' && typeof Headers == 'function') {
  $({
    global: true,
    enumerable: true,
    forced: true
  }, {
    fetch: function fetch(input
    /* , init */
    ) {
      var args = [input];
      var init, body, headers;

      if (arguments.length > 1) {
        init = arguments[1];

        if (isObject(init)) {
          body = init.body;

          if (classof(body) === URL_SEARCH_PARAMS) {
            headers = init.headers ? new Headers(init.headers) : new Headers();

            if (!headers.has('content-type')) {
              headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
            }

            init = create(init, {
              body: createPropertyDescriptor(0, String(body)),
              headers: createPropertyDescriptor(0, headers)
            });
          }
        }

        args.push(init);
      }

      return $fetch.apply(this, args);
    }
  });
}

module.exports = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};

/***/ }),

/***/ 74589:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
 // TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`

__webpack_require__(46222);

var $ = __webpack_require__(53064);

var DESCRIPTORS = __webpack_require__(9811);

var USE_NATIVE_URL = __webpack_require__(21486);

var global = __webpack_require__(52586);

var defineProperties = __webpack_require__(70984);

var redefine = __webpack_require__(44469);

var anInstance = __webpack_require__(6441);

var has = __webpack_require__(38928);

var assign = __webpack_require__(99103);

var arrayFrom = __webpack_require__(4789);

var codeAt = __webpack_require__(36726).codeAt;

var toASCII = __webpack_require__(97983);

var setToStringTag = __webpack_require__(46736);

var URLSearchParamsModule = __webpack_require__(26253);

var InternalStateModule = __webpack_require__(59351);

var NativeURL = global.URL;
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var floor = Math.floor;
var pow = Math.pow;
var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';
var ALPHA = /[A-Za-z]/;
var ALPHANUMERIC = /[\d+-.A-Za-z]/;
var DIGIT = /\d/;
var HEX_START = /^(0x|0X)/;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\dA-Fa-f]+$/;
/* eslint-disable no-control-regex -- safe */

var FORBIDDEN_HOST_CODE_POINT = /[\u0000\t\u000A\u000D #%/:?@[\\]]/;
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\t\u000A\u000D #/:?@[\\]]/;
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
var TAB_AND_NEW_LINE = /[\t\u000A\u000D]/g;
/* eslint-enable no-control-regex -- safe */

var EOF;

var parseHost = function parseHost(url, input) {
  var result, codePoints, index;

  if (input.charAt(0) == '[') {
    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
    result = parseIPv6(input.slice(1, -1));
    if (!result) return INVALID_HOST;
    url.host = result; // opaque host
  } else if (!isSpecial(url)) {
    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
    result = '';
    codePoints = arrayFrom(input);

    for (index = 0; index < codePoints.length; index++) {
      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
    }

    url.host = result;
  } else {
    input = toASCII(input);
    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
    result = parseIPv4(input);
    if (result === null) return INVALID_HOST;
    url.host = result;
  }
};

var parseIPv4 = function parseIPv4(input) {
  var parts = input.split('.');
  var partsLength, numbers, index, part, radix, number, ipv4;

  if (parts.length && parts[parts.length - 1] == '') {
    parts.pop();
  }

  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];

  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part == '') return input;
    radix = 10;

    if (part.length > 1 && part.charAt(0) == '0') {
      radix = HEX_START.test(part) ? 16 : 8;
      part = part.slice(radix == 8 ? 1 : 2);
    }

    if (part === '') {
      number = 0;
    } else {
      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
      number = parseInt(part, radix);
    }

    numbers.push(number);
  }

  for (index = 0; index < partsLength; index++) {
    number = numbers[index];

    if (index == partsLength - 1) {
      if (number >= pow(256, 5 - partsLength)) return null;
    } else if (number > 255) return null;
  }

  ipv4 = numbers.pop();

  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow(256, 3 - index);
  }

  return ipv4;
}; // eslint-disable-next-line max-statements -- TODO


var parseIPv6 = function parseIPv6(input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

  var _char = function _char() {
    return input.charAt(pointer);
  };

  if (_char() == ':') {
    if (input.charAt(1) != ':') return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }

  while (_char()) {
    if (pieceIndex == 8) return;

    if (_char() == ':') {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }

    value = length = 0;

    while (length < 4 && HEX.test(_char())) {
      value = value * 16 + parseInt(_char(), 16);
      pointer++;
      length++;
    }

    if (_char() == '.') {
      if (length == 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;

      while (_char()) {
        ipv4Piece = null;

        if (numbersSeen > 0) {
          if (_char() == '.' && numbersSeen < 4) pointer++;else return;
        }

        if (!DIGIT.test(_char())) return;

        while (DIGIT.test(_char())) {
          number = parseInt(_char(), 10);
          if (ipv4Piece === null) ipv4Piece = number;else if (ipv4Piece == 0) return;else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }

        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
      }

      if (numbersSeen != 4) return;
      break;
    } else if (_char() == ':') {
      pointer++;
      if (!_char()) return;
    } else if (_char()) return;

    address[pieceIndex++] = value;
  }

  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;

    while (pieceIndex != 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex != 8) return;

  return address;
};

var findLongestZeroSequence = function findLongestZeroSequence(ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;

  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }

      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }

  if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
  }

  return maxIndex;
};

var serializeHost = function serializeHost(host) {
  var result, index, compress, ignore0; // ipv4

  if (typeof host == 'number') {
    result = [];

    for (index = 0; index < 4; index++) {
      result.unshift(host % 256);
      host = floor(host / 256);
    }

    return result.join('.'); // ipv6
  } else if (typeof host == 'object') {
    result = '';
    compress = findLongestZeroSequence(host);

    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0) continue;
      if (ignore0) ignore0 = false;

      if (compress === index) {
        result += index ? ':' : '::';
        ignore0 = true;
      } else {
        result += host[index].toString(16);
        if (index < 7) result += ':';
      }
    }

    return '[' + result + ']';
  }

  return host;
};

var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
  ' ': 1,
  '"': 1,
  '<': 1,
  '>': 1,
  '`': 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
  '#': 1,
  '?': 1,
  '{': 1,
  '}': 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
  '/': 1,
  ':': 1,
  ';': 1,
  '=': 1,
  '@': 1,
  '[': 1,
  '\\': 1,
  ']': 1,
  '^': 1,
  '|': 1
});

var percentEncode = function percentEncode(_char2, set) {
  var code = codeAt(_char2, 0);
  return code > 0x20 && code < 0x7F && !has(set, _char2) ? _char2 : encodeURIComponent(_char2);
};

var specialSchemes = {
  ftp: 21,
  file: null,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

var isSpecial = function isSpecial(url) {
  return has(specialSchemes, url.scheme);
};

var includesCredentials = function includesCredentials(url) {
  return url.username != '' || url.password != '';
};

var cannotHaveUsernamePasswordPort = function cannotHaveUsernamePasswordPort(url) {
  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
};

var isWindowsDriveLetter = function isWindowsDriveLetter(string, normalized) {
  var second;
  return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ':' || !normalized && second == '|');
};

var startsWithWindowsDriveLetter = function startsWithWindowsDriveLetter(string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || (third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#');
};

var shortenURLsPath = function shortenURLsPath(url) {
  var path = url.path;
  var pathSize = path.length;

  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
    path.pop();
  }
};

var isSingleDot = function isSingleDot(segment) {
  return segment === '.' || segment.toLowerCase() === '%2e';
};

var isDoubleDot = function isDoubleDot(segment) {
  segment = segment.toLowerCase();
  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
}; // States:


var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {}; // eslint-disable-next-line max-statements -- TODO

var parseURL = function parseURL(url, input, stateOverride, base) {
  var state = stateOverride || SCHEME_START;
  var pointer = 0;
  var buffer = '';
  var seenAt = false;
  var seenBracket = false;
  var seenPasswordToken = false;

  var codePoints, _char3, bufferCodePoints, failure;

  if (!stateOverride) {
    url.scheme = '';
    url.username = '';
    url.password = '';
    url.host = null;
    url.port = null;
    url.path = [];
    url.query = null;
    url.fragment = null;
    url.cannotBeABaseURL = false;
    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
  }

  input = input.replace(TAB_AND_NEW_LINE, '');
  codePoints = arrayFrom(input);

  while (pointer <= codePoints.length) {
    _char3 = codePoints[pointer];

    switch (state) {
      case SCHEME_START:
        if (_char3 && ALPHA.test(_char3)) {
          buffer += _char3.toLowerCase();
          state = SCHEME;
        } else if (!stateOverride) {
          state = NO_SCHEME;
          continue;
        } else return INVALID_SCHEME;

        break;

      case SCHEME:
        if (_char3 && (ALPHANUMERIC.test(_char3) || _char3 == '+' || _char3 == '-' || _char3 == '.')) {
          buffer += _char3.toLowerCase();
        } else if (_char3 == ':') {
          if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == 'file' && (includesCredentials(url) || url.port !== null) || url.scheme == 'file' && !url.host)) return;
          url.scheme = buffer;

          if (stateOverride) {
            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
            return;
          }

          buffer = '';

          if (url.scheme == 'file') {
            state = FILE;
          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
            state = SPECIAL_RELATIVE_OR_AUTHORITY;
          } else if (isSpecial(url)) {
            state = SPECIAL_AUTHORITY_SLASHES;
          } else if (codePoints[pointer + 1] == '/') {
            state = PATH_OR_AUTHORITY;
            pointer++;
          } else {
            url.cannotBeABaseURL = true;
            url.path.push('');
            state = CANNOT_BE_A_BASE_URL_PATH;
          }
        } else if (!stateOverride) {
          buffer = '';
          state = NO_SCHEME;
          pointer = 0;
          continue;
        } else return INVALID_SCHEME;

        break;

      case NO_SCHEME:
        if (!base || base.cannotBeABaseURL && _char3 != '#') return INVALID_SCHEME;

        if (base.cannotBeABaseURL && _char3 == '#') {
          url.scheme = base.scheme;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          url.cannotBeABaseURL = true;
          state = FRAGMENT;
          break;
        }

        state = base.scheme == 'file' ? FILE : RELATIVE;
        continue;

      case SPECIAL_RELATIVE_OR_AUTHORITY:
        if (_char3 == '/' && codePoints[pointer + 1] == '/') {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          pointer++;
        } else {
          state = RELATIVE;
          continue;
        }

        break;

      case PATH_OR_AUTHORITY:
        if (_char3 == '/') {
          state = AUTHORITY;
          break;
        } else {
          state = PATH;
          continue;
        }

      case RELATIVE:
        url.scheme = base.scheme;

        if (_char3 == EOF) {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
        } else if (_char3 == '/' || _char3 == '\\' && isSpecial(url)) {
          state = RELATIVE_SLASH;
        } else if (_char3 == '?') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = '';
          state = QUERY;
        } else if (_char3 == '#') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          state = FRAGMENT;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.path.pop();
          state = PATH;
          continue;
        }

        break;

      case RELATIVE_SLASH:
        if (isSpecial(url) && (_char3 == '/' || _char3 == '\\')) {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        } else if (_char3 == '/') {
          state = AUTHORITY;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          state = PATH;
          continue;
        }

        break;

      case SPECIAL_AUTHORITY_SLASHES:
        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        if (_char3 != '/' || buffer.charAt(pointer + 1) != '/') continue;
        pointer++;
        break;

      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
        if (_char3 != '/' && _char3 != '\\') {
          state = AUTHORITY;
          continue;
        }

        break;

      case AUTHORITY:
        if (_char3 == '@') {
          if (seenAt) buffer = '%40' + buffer;
          seenAt = true;
          bufferCodePoints = arrayFrom(buffer);

          for (var i = 0; i < bufferCodePoints.length; i++) {
            var codePoint = bufferCodePoints[i];

            if (codePoint == ':' && !seenPasswordToken) {
              seenPasswordToken = true;
              continue;
            }

            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
            if (seenPasswordToken) url.password += encodedCodePoints;else url.username += encodedCodePoints;
          }

          buffer = '';
        } else if (_char3 == EOF || _char3 == '/' || _char3 == '?' || _char3 == '#' || _char3 == '\\' && isSpecial(url)) {
          if (seenAt && buffer == '') return INVALID_AUTHORITY;
          pointer -= arrayFrom(buffer).length + 1;
          buffer = '';
          state = HOST;
        } else buffer += _char3;

        break;

      case HOST:
      case HOSTNAME:
        if (stateOverride && url.scheme == 'file') {
          state = FILE_HOST;
          continue;
        } else if (_char3 == ':' && !seenBracket) {
          if (buffer == '') return INVALID_HOST;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PORT;
          if (stateOverride == HOSTNAME) return;
        } else if (_char3 == EOF || _char3 == '/' || _char3 == '?' || _char3 == '#' || _char3 == '\\' && isSpecial(url)) {
          if (isSpecial(url) && buffer == '') return INVALID_HOST;
          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PATH_START;
          if (stateOverride) return;
          continue;
        } else {
          if (_char3 == '[') seenBracket = true;else if (_char3 == ']') seenBracket = false;
          buffer += _char3;
        }

        break;

      case PORT:
        if (DIGIT.test(_char3)) {
          buffer += _char3;
        } else if (_char3 == EOF || _char3 == '/' || _char3 == '?' || _char3 == '#' || _char3 == '\\' && isSpecial(url) || stateOverride) {
          if (buffer != '') {
            var port = parseInt(buffer, 10);
            if (port > 0xFFFF) return INVALID_PORT;
            url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;
            buffer = '';
          }

          if (stateOverride) return;
          state = PATH_START;
          continue;
        } else return INVALID_PORT;

        break;

      case FILE:
        url.scheme = 'file';
        if (_char3 == '/' || _char3 == '\\') state = FILE_SLASH;else if (base && base.scheme == 'file') {
          if (_char3 == EOF) {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
          } else if (_char3 == '?') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = '';
            state = QUERY;
          } else if (_char3 == '#') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
              url.host = base.host;
              url.path = base.path.slice();
              shortenURLsPath(url);
            }

            state = PATH;
            continue;
          }
        } else {
          state = PATH;
          continue;
        }
        break;

      case FILE_SLASH:
        if (_char3 == '/' || _char3 == '\\') {
          state = FILE_HOST;
          break;
        }

        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);else url.host = base.host;
        }

        state = PATH;
        continue;

      case FILE_HOST:
        if (_char3 == EOF || _char3 == '/' || _char3 == '\\' || _char3 == '?' || _char3 == '#') {
          if (!stateOverride && isWindowsDriveLetter(buffer)) {
            state = PATH;
          } else if (buffer == '') {
            url.host = '';
            if (stateOverride) return;
            state = PATH_START;
          } else {
            failure = parseHost(url, buffer);
            if (failure) return failure;
            if (url.host == 'localhost') url.host = '';
            if (stateOverride) return;
            buffer = '';
            state = PATH_START;
          }

          continue;
        } else buffer += _char3;

        break;

      case PATH_START:
        if (isSpecial(url)) {
          state = PATH;
          if (_char3 != '/' && _char3 != '\\') continue;
        } else if (!stateOverride && _char3 == '?') {
          url.query = '';
          state = QUERY;
        } else if (!stateOverride && _char3 == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (_char3 != EOF) {
          state = PATH;
          if (_char3 != '/') continue;
        }

        break;

      case PATH:
        if (_char3 == EOF || _char3 == '/' || _char3 == '\\' && isSpecial(url) || !stateOverride && (_char3 == '?' || _char3 == '#')) {
          if (isDoubleDot(buffer)) {
            shortenURLsPath(url);

            if (_char3 != '/' && !(_char3 == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else if (isSingleDot(buffer)) {
            if (_char3 != '/' && !(_char3 == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else {
            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
              if (url.host) url.host = '';
              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
            }

            url.path.push(buffer);
          }

          buffer = '';

          if (url.scheme == 'file' && (_char3 == EOF || _char3 == '?' || _char3 == '#')) {
            while (url.path.length > 1 && url.path[0] === '') {
              url.path.shift();
            }
          }

          if (_char3 == '?') {
            url.query = '';
            state = QUERY;
          } else if (_char3 == '#') {
            url.fragment = '';
            state = FRAGMENT;
          }
        } else {
          buffer += percentEncode(_char3, pathPercentEncodeSet);
        }

        break;

      case CANNOT_BE_A_BASE_URL_PATH:
        if (_char3 == '?') {
          url.query = '';
          state = QUERY;
        } else if (_char3 == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (_char3 != EOF) {
          url.path[0] += percentEncode(_char3, C0ControlPercentEncodeSet);
        }

        break;

      case QUERY:
        if (!stateOverride && _char3 == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (_char3 != EOF) {
          if (_char3 == "'" && isSpecial(url)) url.query += '%27';else if (_char3 == '#') url.query += '%23';else url.query += percentEncode(_char3, C0ControlPercentEncodeSet);
        }

        break;

      case FRAGMENT:
        if (_char3 != EOF) url.fragment += percentEncode(_char3, fragmentPercentEncodeSet);
        break;
    }

    pointer++;
  }
}; // `URL` constructor
// https://url.spec.whatwg.org/#url-class


var URLConstructor = function URL(url
/* , base */
) {
  var that = anInstance(this, URLConstructor, 'URL');
  var base = arguments.length > 1 ? arguments[1] : undefined;
  var urlString = String(url);
  var state = setInternalState(that, {
    type: 'URL'
  });
  var baseState, failure;

  if (base !== undefined) {
    if (base instanceof URLConstructor) baseState = getInternalURLState(base);else {
      failure = parseURL(baseState = {}, String(base));
      if (failure) throw TypeError(failure);
    }
  }

  failure = parseURL(state, urlString, null, baseState);
  if (failure) throw TypeError(failure);
  var searchParams = state.searchParams = new URLSearchParams();
  var searchParamsState = getInternalSearchParamsState(searchParams);
  searchParamsState.updateSearchParams(state.query);

  searchParamsState.updateURL = function () {
    state.query = String(searchParams) || null;
  };

  if (!DESCRIPTORS) {
    that.href = serializeURL.call(that);
    that.origin = getOrigin.call(that);
    that.protocol = getProtocol.call(that);
    that.username = getUsername.call(that);
    that.password = getPassword.call(that);
    that.host = getHost.call(that);
    that.hostname = getHostname.call(that);
    that.port = getPort.call(that);
    that.pathname = getPathname.call(that);
    that.search = getSearch.call(that);
    that.searchParams = getSearchParams.call(that);
    that.hash = getHash.call(that);
  }
};

var URLPrototype = URLConstructor.prototype;

var serializeURL = function serializeURL() {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var username = url.username;
  var password = url.password;
  var host = url.host;
  var port = url.port;
  var path = url.path;
  var query = url.query;
  var fragment = url.fragment;
  var output = scheme + ':';

  if (host !== null) {
    output += '//';

    if (includesCredentials(url)) {
      output += username + (password ? ':' + password : '') + '@';
    }

    output += serializeHost(host);
    if (port !== null) output += ':' + port;
  } else if (scheme == 'file') output += '//';

  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
  if (query !== null) output += '?' + query;
  if (fragment !== null) output += '#' + fragment;
  return output;
};

var getOrigin = function getOrigin() {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var port = url.port;
  if (scheme == 'blob') try {
    return new URL(scheme.path[0]).origin;
  } catch (error) {
    return 'null';
  }
  if (scheme == 'file' || !isSpecial(url)) return 'null';
  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
};

var getProtocol = function getProtocol() {
  return getInternalURLState(this).scheme + ':';
};

var getUsername = function getUsername() {
  return getInternalURLState(this).username;
};

var getPassword = function getPassword() {
  return getInternalURLState(this).password;
};

var getHost = function getHost() {
  var url = getInternalURLState(this);
  var host = url.host;
  var port = url.port;
  return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;
};

var getHostname = function getHostname() {
  var host = getInternalURLState(this).host;
  return host === null ? '' : serializeHost(host);
};

var getPort = function getPort() {
  var port = getInternalURLState(this).port;
  return port === null ? '' : String(port);
};

var getPathname = function getPathname() {
  var url = getInternalURLState(this);
  var path = url.path;
  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
};

var getSearch = function getSearch() {
  var query = getInternalURLState(this).query;
  return query ? '?' + query : '';
};

var getSearchParams = function getSearchParams() {
  return getInternalURLState(this).searchParams;
};

var getHash = function getHash() {
  var fragment = getInternalURLState(this).fragment;
  return fragment ? '#' + fragment : '';
};

var accessorDescriptor = function accessorDescriptor(getter, setter) {
  return {
    get: getter,
    set: setter,
    configurable: true,
    enumerable: true
  };
};

if (DESCRIPTORS) {
  defineProperties(URLPrototype, {
    // `URL.prototype.href` accessors pair
    // https://url.spec.whatwg.org/#dom-url-href
    href: accessorDescriptor(serializeURL, function (href) {
      var url = getInternalURLState(this);
      var urlString = String(href);
      var failure = parseURL(url, urlString);
      if (failure) throw TypeError(failure);
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.origin` getter
    // https://url.spec.whatwg.org/#dom-url-origin
    origin: accessorDescriptor(getOrigin),
    // `URL.prototype.protocol` accessors pair
    // https://url.spec.whatwg.org/#dom-url-protocol
    protocol: accessorDescriptor(getProtocol, function (protocol) {
      var url = getInternalURLState(this);
      parseURL(url, String(protocol) + ':', SCHEME_START);
    }),
    // `URL.prototype.username` accessors pair
    // https://url.spec.whatwg.org/#dom-url-username
    username: accessorDescriptor(getUsername, function (username) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(username));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.username = '';

      for (var i = 0; i < codePoints.length; i++) {
        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.password` accessors pair
    // https://url.spec.whatwg.org/#dom-url-password
    password: accessorDescriptor(getPassword, function (password) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(password));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.password = '';

      for (var i = 0; i < codePoints.length; i++) {
        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.host` accessors pair
    // https://url.spec.whatwg.org/#dom-url-host
    host: accessorDescriptor(getHost, function (host) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(host), HOST);
    }),
    // `URL.prototype.hostname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hostname
    hostname: accessorDescriptor(getHostname, function (hostname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(hostname), HOSTNAME);
    }),
    // `URL.prototype.port` accessors pair
    // https://url.spec.whatwg.org/#dom-url-port
    port: accessorDescriptor(getPort, function (port) {
      var url = getInternalURLState(this);
      if (cannotHaveUsernamePasswordPort(url)) return;
      port = String(port);
      if (port == '') url.port = null;else parseURL(url, port, PORT);
    }),
    // `URL.prototype.pathname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-pathname
    pathname: accessorDescriptor(getPathname, function (pathname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      url.path = [];
      parseURL(url, pathname + '', PATH_START);
    }),
    // `URL.prototype.search` accessors pair
    // https://url.spec.whatwg.org/#dom-url-search
    search: accessorDescriptor(getSearch, function (search) {
      var url = getInternalURLState(this);
      search = String(search);

      if (search == '') {
        url.query = null;
      } else {
        if ('?' == search.charAt(0)) search = search.slice(1);
        url.query = '';
        parseURL(url, search, QUERY);
      }

      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.searchParams` getter
    // https://url.spec.whatwg.org/#dom-url-searchparams
    searchParams: accessorDescriptor(getSearchParams),
    // `URL.prototype.hash` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hash
    hash: accessorDescriptor(getHash, function (hash) {
      var url = getInternalURLState(this);
      hash = String(hash);

      if (hash == '') {
        url.fragment = null;
        return;
      }

      if ('#' == hash.charAt(0)) hash = hash.slice(1);
      url.fragment = '';
      parseURL(url, hash, FRAGMENT);
    })
  });
} // `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson


redefine(URLPrototype, 'toJSON', function toJSON() {
  return serializeURL.call(this);
}, {
  enumerable: true
}); // `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior

redefine(URLPrototype, 'toString', function toString() {
  return serializeURL.call(this);
}, {
  enumerable: true
});

if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL; // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  // eslint-disable-next-line no-unused-vars -- required for `.length`

  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
    return nativeCreateObjectURL.apply(NativeURL, arguments);
  }); // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  // eslint-disable-next-line no-unused-vars -- required for `.length`

  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
    return nativeRevokeObjectURL.apply(NativeURL, arguments);
  });
}

setToStringTag(URLConstructor, 'URL');
$({
  global: true,
  forced: !USE_NATIVE_URL,
  sham: !DESCRIPTORS
}, {
  URL: URLConstructor
});

/***/ }),

/***/ 72781:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $ = __webpack_require__(53064); // `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson


$({
  target: 'URL',
  proto: true,
  enumerable: true
}, {
  toJSON: function toJSON() {
    return URL.prototype.toString.call(this);
  }
});

/***/ }),

/***/ 74160:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(58226);

__webpack_require__(66558);

var path = __webpack_require__(87526);

module.exports = path;

/***/ }),

/***/ 66558:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(16141);

__webpack_require__(75706);

__webpack_require__(56573);

__webpack_require__(27273);

__webpack_require__(43531);

__webpack_require__(74589);

__webpack_require__(72781);

__webpack_require__(26253);

var path = __webpack_require__(87526);

module.exports = path;

/***/ }),

/***/ 68704:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Afrikaans [af]
//! author : Werner Mollentze : https://github.com/wernerm
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var af = moment.defineLocale('af', {
    months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
    weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
    weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
    meridiemParse: /vm|nm/i,
    isPM: function isPM(input) {
      return /^nm$/i.test(input);
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? 'vm' : 'VM';
      } else {
        return isLower ? 'nm' : 'NM';
      }
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Vandag om] LT',
      nextDay: '[Mre om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[Gister om] LT',
      lastWeek: '[Laas] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'oor %s',
      past: '%s gelede',
      s: "'n paar sekondes",
      ss: '%d sekondes',
      m: "'n minuut",
      mm: '%d minute',
      h: "'n uur",
      hh: '%d ure',
      d: "'n dag",
      dd: '%d dae',
      M: "'n maand",
      MM: '%d maande',
      y: "'n jaar",
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function ordinal(number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
    },
    week: {
      dow: 1,
      // Maandag is die eerste dag van die week.
      doy: 4 // Die week wat die 4de Januarie bevat is die eerste week van die jaar.

    }
  });
  return af;
});

/***/ }),

/***/ 42642:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Algeria) [ar-dz]
//! author : Amine Roukh: https://github.com/Amine27
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi
//! author : Noureddine LOUAHEDJ : https://github.com/noureddinem
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var pluralForm = function pluralForm(n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
  },
      plurals = {
    s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
  },
      pluralize = function pluralize(u) {
    return function (number, withoutSuffix, string, isFuture) {
      var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];

      if (f === 2) {
        str = str[withoutSuffix ? 0 : 1];
      }

      return str.replace(/%d/i, number);
    };
  },
      months = ['', '', '', '', '', '', '', '', '', '', '', ''];

  var arDz = moment.defineLocale('ar-dz', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: "D/\u200FM/\u200FYYYY",
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    postformat: function postformat(string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return arDz;
});

/***/ }),

/***/ 20640:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Kuwait) [ar-kw]
//! author : Nusret Parlak: https://github.com/nusretparlak
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var arKw = moment.defineLocale('ar-kw', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return arKw;
});

/***/ }),

/***/ 82641:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Lybia) [ar-ly]
//! author : Ali Hmer: https://github.com/kikoanis
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '1',
    2: '2',
    3: '3',
    4: '4',
    5: '5',
    6: '6',
    7: '7',
    8: '8',
    9: '9',
    0: '0'
  },
      pluralForm = function pluralForm(n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
  },
      plurals = {
    s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
  },
      pluralize = function pluralize(u) {
    return function (number, withoutSuffix, string, isFuture) {
      var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];

      if (f === 2) {
        str = str[withoutSuffix ? 0 : 1];
      }

      return str.replace(/%d/i, number);
    };
  },
      months = ['', '', '', '', '', '', '', '', '', '', '', ''];

  var arLy = moment.defineLocale('ar-ly', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: "D/\u200FM/\u200FYYYY",
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    preparse: function preparse(string) {
      return string.replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return arLy;
});

/***/ }),

/***/ 52750:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Morocco) [ar-ma]
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var arMa = moment.defineLocale('ar-ma', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return arMa;
});

/***/ }),

/***/ 43697:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Saudi Arabia) [ar-sa]
//! author : Suhail Alkowaileet : https://github.com/xsoh
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var arSa = moment.defineLocale('ar-sa', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return arSa;
});

/***/ }),

/***/ 60667:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale  :  Arabic (Tunisia) [ar-tn]
//! author : Nader Toukabri : https://github.com/naderio
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var arTn = moment.defineLocale('ar-tn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return arTn;
});

/***/ }),

/***/ 27156:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic [ar]
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  },
      pluralForm = function pluralForm(n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
  },
      plurals = {
    s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
  },
      pluralize = function pluralize(u) {
    return function (number, withoutSuffix, string, isFuture) {
      var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];

      if (f === 2) {
        str = str[withoutSuffix ? 0 : 1];
      }

      return str.replace(/%d/i, number);
    };
  },
      months = ['', '', '', '', '', '', '', '', '', '', '', ''];

  var ar = moment.defineLocale('ar', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: "D/\u200FM/\u200FYYYY",
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return ar;
});

/***/ }),

/***/ 33899:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Azerbaijani [az]
//! author : topchiyev : https://github.com/topchiyev
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var suffixes = {
    1: '-inci',
    5: '-inci',
    8: '-inci',
    70: '-inci',
    80: '-inci',
    2: '-nci',
    7: '-nci',
    20: '-nci',
    50: '-nci',
    3: '-nc',
    4: '-nc',
    100: '-nc',
    6: '-nc',
    9: '-uncu',
    10: '-uncu',
    30: '-uncu',
    60: '-nc',
    90: '-nc'
  };
  var az = moment.defineLocale('az', {
    months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
    monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
    weekdays: 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
    weekdaysShort: 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
    weekdaysMin: 'Bz_BE_A__CA_C_'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugn saat] LT',
      nextDay: '[sabah saat] LT',
      nextWeek: '[gln hft] dddd [saat] LT',
      lastDay: '[dnn] LT',
      lastWeek: '[ken hft] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s sonra',
      past: '%s vvl',
      s: 'bir ne saniy',
      ss: '%d saniy',
      m: 'bir dqiq',
      mm: '%d dqiq',
      h: 'bir saat',
      hh: '%d saat',
      d: 'bir gn',
      dd: '%d gn',
      M: 'bir ay',
      MM: '%d ay',
      y: 'bir il',
      yy: '%d il'
    },
    meridiemParse: /gec|shr|gndz|axam/,
    isPM: function isPM(input) {
      return /^(gndz|axam)$/.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return 'gec';
      } else if (hour < 12) {
        return 'shr';
      } else if (hour < 17) {
        return 'gndz';
      } else {
        return 'axam';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
    ordinal: function ordinal(number) {
      if (number === 0) {
        // special case for zero
        return number + '-nc';
      }

      var a = number % 10,
          b = number % 100 - a,
          c = number >= 100 ? 100 : null;
      return number + (suffixes[a] || suffixes[b] || suffixes[c]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return az;
});

/***/ }),

/***/ 55777:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Belarusian [be]
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensle : https://github.com/Oire
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      ss: withoutSuffix ? '__' : '__',
      mm: withoutSuffix ? '__' : '__',
      hh: withoutSuffix ? '__' : '__',
      dd: '__',
      MM: '__',
      yy: '__'
    };

    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else if (key === 'h') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }

  var be = moment.defineLocale('be', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: {
      format: '______'.split('_'),
      standalone: '______'.split('_'),
      isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
    },
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      lastDay: '[ ] LT',
      nextWeek: function nextWeek() {
        return '[] dddd [] LT';
      },
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
          case 3:
          case 5:
          case 6:
            return '[ ] dddd [] LT';

          case 1:
          case 2:
          case 4:
            return '[ ] dddd [] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: relativeTimeWithPlural,
      hh: relativeTimeWithPlural,
      d: '',
      dd: relativeTimeWithPlural,
      M: '',
      MM: relativeTimeWithPlural,
      y: '',
      yy: relativeTimeWithPlural
    },
    meridiemParse: /|||/,
    isPM: function isPM(input) {
      return /^(|)$/.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
        case 'w':
        case 'W':
          return (number % 10 === 2 || number % 10 === 3) && number % 100 !== 12 && number % 100 !== 13 ? number + '-' : number + '-';

        case 'D':
          return number + '-';

        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return be;
});

/***/ }),

/***/ 26429:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bulgarian [bg]
//! author : Krasen Borisov : https://github.com/kraz
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var bg = moment.defineLocale('bg', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
          case 3:
          case 6:
            return '[] dddd [] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[] dddd [] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      w: '',
      ww: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal: function ordinal(number) {
      var lastDigit = number % 10,
          last2Digits = number % 100;

      if (number === 0) {
        return number + '-';
      } else if (last2Digits === 0) {
        return number + '-';
      } else if (last2Digits > 10 && last2Digits < 20) {
        return number + '-';
      } else if (lastDigit === 1) {
        return number + '-';
      } else if (lastDigit === 2) {
        return number + '-';
      } else if (lastDigit === 7 || lastDigit === 8) {
        return number + '-';
      } else {
        return number + '-';
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return bg;
});

/***/ }),

/***/ 18337:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bambara [bm]
//! author : Estelle Comment : https://github.com/estellecomment
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var bm = moment.defineLocale('bm', {
    months: 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),
    monthsShort: 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),
    weekdays: 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
    weekdaysShort: 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),
    weekdaysMin: 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'MMMM [tile] D [san] YYYY',
      LLL: 'MMMM [tile] D [san] YYYY [lr] HH:mm',
      LLLL: 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'
    },
    calendar: {
      sameDay: '[Bi lr] LT',
      nextDay: '[Sini lr] LT',
      nextWeek: 'dddd [don lr] LT',
      lastDay: '[Kunu lr] LT',
      lastWeek: 'dddd [tmnen lr] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s kn',
      past: 'a b %s b',
      s: 'sanga dama dama',
      ss: 'sekondi %d',
      m: 'miniti kelen',
      mm: 'miniti %d',
      h: 'lr kelen',
      hh: 'lr %d',
      d: 'tile kelen',
      dd: 'tile %d',
      M: 'kalo kelen',
      MM: 'kalo %d',
      y: 'san kelen',
      yy: 'san %d'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return bm;
});

/***/ }),

/***/ 36843:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali (Bangladesh) [bn-bd]
//! author : Asraf Hossain Patoary : https://github.com/ashwoolford
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var bnBd = moment.defineLocale('bn-bd', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 3 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 6) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 15) {
        return '';
      } else if (hour < 18) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return bnBd;
});

/***/ }),

/***/ 91379:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali [bn]
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var bn = moment.defineLocale('bn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' && hour >= 4 || meridiem === '' && hour < 5 || meridiem === '') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return bn;
});

/***/ }),

/***/ 71798:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tibetan [bo]
//! author : Thupten N. Chakrishar : https://github.com/vajradog
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var bo = moment.defineLocale('bo', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShortRegex: /^(\d{1,2})/,
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[], LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' && hour >= 4 || meridiem === '' && hour < 5 || meridiem === '') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return bo;
});

/***/ }),

/***/ 50706:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Breton [br]
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function relativeTimeWithMutation(number, withoutSuffix, key) {
    var format = {
      mm: 'munutenn',
      MM: 'miz',
      dd: 'devezh'
    };
    return number + ' ' + mutation(format[key], number);
  }

  function specialMutationForYears(number) {
    switch (lastNumber(number)) {
      case 1:
      case 3:
      case 4:
      case 5:
      case 9:
        return number + ' bloaz';

      default:
        return number + ' vloaz';
    }
  }

  function lastNumber(number) {
    if (number > 9) {
      return lastNumber(number % 10);
    }

    return number;
  }

  function mutation(text, number) {
    if (number === 2) {
      return softMutation(text);
    }

    return text;
  }

  function softMutation(text) {
    var mutationTable = {
      m: 'v',
      b: 'v',
      d: 'z'
    };

    if (mutationTable[text.charAt(0)] === undefined) {
      return text;
    }

    return mutationTable[text.charAt(0)] + text.substring(1);
  }

  var monthsParse = [/^gen/i, /^c[\']hwe/i, /^meu/i, /^ebr/i, /^mae/i, /^(mez|eve)/i, /^gou/i, /^eos/i, /^gwe/i, /^her/i, /^du/i, /^ker/i],
      monthsRegex = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
      monthsStrictRegex = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i,
      monthsShortStrictRegex = /^(gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
      fullWeekdaysParse = [/^sul/i, /^lun/i, /^meurzh/i, /^merc[\']her/i, /^yaou/i, /^gwener/i, /^sadorn/i],
      shortWeekdaysParse = [/^Sul/i, /^Lun/i, /^Meu/i, /^Mer/i, /^Yao/i, /^Gwe/i, /^Sad/i],
      minWeekdaysParse = [/^Su/i, /^Lu/i, /^Me([^r]|$)/i, /^Mer/i, /^Ya/i, /^Gw/i, /^Sa/i];
  var br = moment.defineLocale('br', {
    months: 'Genver_Chwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
    monthsShort: 'Gen_Chwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
    weekdays: 'Sul_Lun_Meurzh_Mercher_Yaou_Gwener_Sadorn'.split('_'),
    weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
    weekdaysParse: minWeekdaysParse,
    fullWeekdaysParse: fullWeekdaysParse,
    shortWeekdaysParse: shortWeekdaysParse,
    minWeekdaysParse: minWeekdaysParse,
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: monthsStrictRegex,
    monthsShortStrictRegex: monthsShortStrictRegex,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [a viz] MMMM YYYY',
      LLL: 'D [a viz] MMMM YYYY HH:mm',
      LLLL: 'dddd, D [a viz] MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hiziv da] LT',
      nextDay: '[Warchoazh da] LT',
      nextWeek: 'dddd [da] LT',
      lastDay: '[Dech da] LT',
      lastWeek: 'dddd [paset da] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'a-benn %s',
      past: '%s zo',
      s: 'un nebeud segondenno',
      ss: '%d eilenn',
      m: 'ur vunutenn',
      mm: relativeTimeWithMutation,
      h: 'un eur',
      hh: '%d eur',
      d: 'un devezh',
      dd: relativeTimeWithMutation,
      M: 'ur miz',
      MM: relativeTimeWithMutation,
      y: 'ur bloaz',
      yy: specialMutationForYears
    },
    dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
    ordinal: function ordinal(number) {
      var output = number === 1 ? 'a' : 'vet';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    },
    meridiemParse: /a.m.|g.m./,
    // goude merenn | a-raok merenn
    isPM: function isPM(token) {
      return token === 'g.m.';
    },
    meridiem: function meridiem(hour, minute, isLower) {
      return hour < 12 ? 'a.m.' : 'g.m.';
    }
  });
  return br;
});

/***/ }),

/***/ 60158:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bosnian [bs]
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Markovi
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function translate(number, withoutSuffix, key) {
    var result = number + ' ';

    switch (key) {
      case 'ss':
        if (number === 1) {
          result += 'sekunda';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sekunde';
        } else {
          result += 'sekundi';
        }

        return result;

      case 'm':
        return withoutSuffix ? 'jedna minuta' : 'jedne minute';

      case 'mm':
        if (number === 1) {
          result += 'minuta';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'minute';
        } else {
          result += 'minuta';
        }

        return result;

      case 'h':
        return withoutSuffix ? 'jedan sat' : 'jednog sata';

      case 'hh':
        if (number === 1) {
          result += 'sat';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sata';
        } else {
          result += 'sati';
        }

        return result;

      case 'dd':
        if (number === 1) {
          result += 'dan';
        } else {
          result += 'dana';
        }

        return result;

      case 'MM':
        if (number === 1) {
          result += 'mjesec';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'mjeseca';
        } else {
          result += 'mjeseci';
        }

        return result;

      case 'yy':
        if (number === 1) {
          result += 'godina';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'godine';
        } else {
          result += 'godina';
        }

        return result;
    }
  }

  var bs = moment.defineLocale('bs', {
    months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';

          case 3:
            return '[u] [srijedu] [u] LT';

          case 6:
            return '[u] [subotu] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[juer u] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
          case 3:
            return '[prolu] dddd [u] LT';

          case 6:
            return '[prole] [subote] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[proli] dddd [u] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'par sekundi',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: 'dan',
      dd: translate,
      M: 'mjesec',
      MM: translate,
      y: 'godinu',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return bs;
});

/***/ }),

/***/ 10191:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Catalan [ca]
//! author : Juan G. Hurtado : https://github.com/juanghurtado
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ca = moment.defineLocale('ca', {
    months: {
      standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
      format: "de gener_de febrer_de mar_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split('_'),
      isFormat: /D[oD]?(\s)+MMMM/
    },
    monthsShort: 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
    weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
    weekdaysMin: 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [de] YYYY',
      ll: 'D MMM YYYY',
      LLL: 'D MMMM [de] YYYY [a les] H:mm',
      lll: 'D MMM YYYY, H:mm',
      LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
      llll: 'ddd D MMM YYYY, H:mm'
    },
    calendar: {
      sameDay: function sameDay() {
        return '[avui a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      nextDay: function nextDay() {
        return '[dem a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      nextWeek: function nextWeek() {
        return 'dddd [a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      lastDay: function lastDay() {
        return '[ahir a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      lastWeek: function lastWeek() {
        return '[el] dddd [passat a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: "d'aqu %s",
      past: 'fa %s',
      s: 'uns segons',
      ss: '%d segons',
      m: 'un minut',
      mm: '%d minuts',
      h: 'una hora',
      hh: '%d hores',
      d: 'un dia',
      dd: '%d dies',
      M: 'un mes',
      MM: '%d mesos',
      y: 'un any',
      yy: '%d anys'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
    ordinal: function ordinal(number, period) {
      var output = number === 1 ? 'r' : number === 2 ? 'n' : number === 3 ? 'r' : number === 4 ? 't' : '';

      if (period === 'w' || period === 'W') {
        output = 'a';
      }

      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ca;
});

/***/ }),

/***/ 41958:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Czech [cs]
//! author : petrbela : https://github.com/petrbela
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
      monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_'),
      monthsParse = [/^led/i, /^no/i, /^be/i, /^dub/i, /^kv/i, /^(vn|erven$|ervna)/i, /^(vc|ervenec|ervence)/i, /^srp/i, /^z/i, /^j/i, /^lis/i, /^pro/i],
      // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
  // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
  monthsRegex = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;

  function plural(n) {
    return n > 1 && n < 5 && ~~(n / 10) !== 1;
  }

  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    switch (key) {
      case 's':
        // a few seconds / in a few seconds / a few seconds ago
        return withoutSuffix || isFuture ? 'pr sekund' : 'pr sekundami';

      case 'ss':
        // 9 seconds / in 9 seconds / 9 seconds ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'sekundy' : 'sekund');
        } else {
          return result + 'sekundami';
        }

      case 'm':
        // a minute / in a minute / a minute ago
        return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';

      case 'mm':
        // 9 minutes / in 9 minutes / 9 minutes ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'minuty' : 'minut');
        } else {
          return result + 'minutami';
        }

      case 'h':
        // an hour / in an hour / an hour ago
        return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';

      case 'hh':
        // 9 hours / in 9 hours / 9 hours ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'hodiny' : 'hodin');
        } else {
          return result + 'hodinami';
        }

      case 'd':
        // a day / in a day / a day ago
        return withoutSuffix || isFuture ? 'den' : 'dnem';

      case 'dd':
        // 9 days / in 9 days / 9 days ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'dny' : 'dn');
        } else {
          return result + 'dny';
        }

      case 'M':
        // a month / in a month / a month ago
        return withoutSuffix || isFuture ? 'msc' : 'mscem';

      case 'MM':
        // 9 months / in 9 months / 9 months ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'msce' : 'msc');
        } else {
          return result + 'msci';
        }

      case 'y':
        // a year / in a year / a year ago
        return withoutSuffix || isFuture ? 'rok' : 'rokem';

      case 'yy':
        // 9 years / in 9 years / 9 years ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'roky' : 'let');
        } else {
          return result + 'lety';
        }

    }
  }

  var cs = moment.defineLocale('cs', {
    months: months,
    monthsShort: monthsShort,
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
    // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
    monthsStrictRegex: /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
    monthsShortStrictRegex: /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
    weekdaysShort: 'ne_po_t_st_t_p_so'.split('_'),
    weekdaysMin: 'ne_po_t_st_t_p_so'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd D. MMMM YYYY H:mm',
      l: 'D. M. YYYY'
    },
    calendar: {
      sameDay: '[dnes v] LT',
      nextDay: '[ztra v] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[v nedli v] LT';

          case 1:
          case 2:
            return '[v] dddd [v] LT';

          case 3:
            return '[ve stedu v] LT';

          case 4:
            return '[ve tvrtek v] LT';

          case 5:
            return '[v ptek v] LT';

          case 6:
            return '[v sobotu v] LT';
        }
      },
      lastDay: '[vera v] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[minulou nedli v] LT';

          case 1:
          case 2:
            return '[minul] dddd [v] LT';

          case 3:
            return '[minulou stedu v] LT';

          case 4:
          case 5:
            return '[minul] dddd [v] LT';

          case 6:
            return '[minulou sobotu v] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'ped %s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return cs;
});

/***/ }),

/***/ 54139:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chuvash [cv]
//! author : Anatoly Mironov : https://github.com/mirontoli
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var cv = moment.defineLocale('cv', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'YYYY [] MMMM [] D[-]',
      LLL: 'YYYY [] MMMM [] D[-], HH:mm',
      LLLL: 'dddd, YYYY [] MMMM [] D[-], HH:mm'
    },
    calendar: {
      sameDay: '[] LT []',
      nextDay: '[] LT []',
      lastDay: '[] LT []',
      nextWeek: '[] dddd LT []',
      lastWeek: '[] dddd LT []',
      sameElse: 'L'
    },
    relativeTime: {
      future: function future(output) {
        var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
        return output + affix;
      },
      past: '%s ',
      s: '- ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-/,
    ordinal: '%d-',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return cv;
});

/***/ }),

/***/ 99673:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Welsh [cy]
//! author : Robert Allen : https://github.com/robgallen
//! author : https://github.com/ryangreaves
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var cy = moment.defineLocale('cy', {
    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
    weekdaysParseExact: true,
    // time formats are the same as en-gb
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Heddiw am] LT',
      nextDay: '[Yfory am] LT',
      nextWeek: 'dddd [am] LT',
      lastDay: '[Ddoe am] LT',
      lastWeek: 'dddd [diwethaf am] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'mewn %s',
      past: '%s yn l',
      s: 'ychydig eiliadau',
      ss: '%d eiliad',
      m: 'munud',
      mm: '%d munud',
      h: 'awr',
      hh: '%d awr',
      d: 'diwrnod',
      dd: '%d diwrnod',
      M: 'mis',
      MM: '%d mis',
      y: 'blwyddyn',
      yy: '%d flynedd'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
    ordinal: function ordinal(number) {
      var b = number,
          output = '',
          lookup = ['', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
      'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
      ];

      if (b > 20) {
        if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
          output = 'fed'; // not 30ain, 70ain or 90ain
        } else {
          output = 'ain';
        }
      } else if (b > 0) {
        output = lookup[b];
      }

      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return cy;
});

/***/ }),

/***/ 48845:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Danish [da]
//! author : Ulrik Nielsen : https://github.com/mrbase
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var da = moment.defineLocale('da', {
    months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort: 'sn_man_tir_ons_tor_fre_lr'.split('_'),
    weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[i dag kl.] LT',
      nextDay: '[i morgen kl.] LT',
      nextWeek: 'p dddd [kl.] LT',
      lastDay: '[i gr kl.] LT',
      lastWeek: '[i] dddd[s kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s siden',
      s: 'f sekunder',
      ss: '%d sekunder',
      m: 'et minut',
      mm: '%d minutter',
      h: 'en time',
      hh: '%d timer',
      d: 'en dag',
      dd: '%d dage',
      M: 'en mned',
      MM: '%d mneder',
      y: 'et r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return da;
});

/***/ }),

/***/ 1477:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Austria) [de-at]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      m: ['eine Minute', 'einer Minute'],
      h: ['eine Stunde', 'einer Stunde'],
      d: ['ein Tag', 'einem Tag'],
      dd: [number + ' Tage', number + ' Tagen'],
      w: ['eine Woche', 'einer Woche'],
      M: ['ein Monat', 'einem Monat'],
      MM: [number + ' Monate', number + ' Monaten'],
      y: ['ein Jahr', 'einem Jahr'],
      yy: [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  var deAt = moment.defineLocale('de-at', {
    months: 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: '%d Wochen',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return deAt;
});

/***/ }),

/***/ 64025:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Switzerland) [de-ch]
//! author : sschueller : https://github.com/sschueller
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      m: ['eine Minute', 'einer Minute'],
      h: ['eine Stunde', 'einer Stunde'],
      d: ['ein Tag', 'einem Tag'],
      dd: [number + ' Tage', number + ' Tagen'],
      w: ['eine Woche', 'einer Woche'],
      M: ['ein Monat', 'einem Monat'],
      MM: [number + ' Monate', number + ' Monaten'],
      y: ['ein Jahr', 'einem Jahr'],
      yy: [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  var deCh = moment.defineLocale('de-ch', {
    months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: '%d Wochen',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return deCh;
});

/***/ }),

/***/ 50940:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German [de]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      m: ['eine Minute', 'einer Minute'],
      h: ['eine Stunde', 'einer Stunde'],
      d: ['ein Tag', 'einem Tag'],
      dd: [number + ' Tage', number + ' Tagen'],
      w: ['eine Woche', 'einer Woche'],
      M: ['ein Monat', 'einem Monat'],
      MM: [number + ' Monate', number + ' Monaten'],
      y: ['ein Jahr', 'einem Jahr'],
      yy: [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  var de = moment.defineLocale('de', {
    months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: '%d Wochen',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return de;
});

/***/ }),

/***/ 72684:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maldivian [dv]
//! author : Jawish Hameed : https://github.com/jawish
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = ['', '', '', '', '', '', '', '', '', '', '', ''],
      weekdays = ['', '', '', '', '', '', ''];
  var dv = moment.defineLocale('dv', {
    months: months,
    monthsShort: months,
    weekdays: weekdays,
    weekdaysShort: weekdays,
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/M/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: 'd% ',
      m: '',
      mm: ' %d',
      h: '',
      hh: ' %d',
      d: '',
      dd: ' %d',
      M: '',
      MM: ' %d',
      y: '',
      yy: ' %d'
    },
    preparse: function preparse(string) {
      return string.replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 7,
      // Sunday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return dv;
});

/***/ }),

/***/ 1672:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Greek [el]
//! author : Aggelos Karalias : https://github.com/mehiel
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function isFunction(input) {
    return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }

  var el = moment.defineLocale('el', {
    monthsNominativeEl: '___________'.split('_'),
    monthsGenitiveEl: '___________'.split('_'),
    months: function months(momentToFormat, format) {
      if (!momentToFormat) {
        return this._monthsNominativeEl;
      } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) {
        // if there is a day number before 'MMMM'
        return this._monthsGenitiveEl[momentToFormat.month()];
      } else {
        return this._monthsNominativeEl[momentToFormat.month()];
      }
    },
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? '' : '';
      } else {
        return isLower ? '' : '';
      }
    },
    isPM: function isPM(input) {
      return (input + '').toLowerCase()[0] === '';
    },
    meridiemParse: /[]\.??\.?/i,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendarEl: {
      sameDay: '[ {}] LT',
      nextDay: '[ {}] LT',
      nextWeek: 'dddd [{}] LT',
      lastDay: '[ {}] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 6:
            return '[ ] dddd [{}] LT';

          default:
            return '[ ] dddd [{}] LT';
        }
      },
      sameElse: 'L'
    },
    calendar: function calendar(key, mom) {
      var output = this._calendarEl[key],
          hours = mom && mom.hours();

      if (isFunction(output)) {
        output = output.apply(mom);
      }

      return output.replace('{}', hours % 12 === 1 ? '' : '');
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4st is the first week of the year.

    }
  });
  return el;
});

/***/ }),

/***/ 62979:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Australia) [en-au]
//! author : Jared Morse : https://github.com/jarcoal
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enAu = moment.defineLocale('en-au', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enAu;
});

/***/ }),

/***/ 67149:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Canada) [en-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enCa = moment.defineLocale('en-ca', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'YYYY-MM-DD',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });
  return enCa;
});

/***/ }),

/***/ 35595:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (United Kingdom) [en-gb]
//! author : Chris Gedrim : https://github.com/chrisgedrim
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enGb = moment.defineLocale('en-gb', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enGb;
});

/***/ }),

/***/ 62994:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Ireland) [en-ie]
//! author : Chris Cartlidge : https://github.com/chriscartlidge
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enIe = moment.defineLocale('en-ie', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enIe;
});

/***/ }),

/***/ 86866:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Israel) [en-il]
//! author : Chris Gedrim : https://github.com/chrisgedrim
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enIl = moment.defineLocale('en-il', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });
  return enIl;
});

/***/ }),

/***/ 82260:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (India) [en-in]
//! author : Jatin Agrawal : https://github.com/jatinag22
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enIn = moment.defineLocale('en-in', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 1st is the first week of the year.

    }
  });
  return enIn;
});

/***/ }),

/***/ 59993:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (New Zealand) [en-nz]
//! author : Luke McGregor : https://github.com/lukemcgregor
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enNz = moment.defineLocale('en-nz', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enNz;
});

/***/ }),

/***/ 94434:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Singapore) [en-sg]
//! author : Matthew Castrillon-Madrigal : https://github.com/techdimension
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enSg = moment.defineLocale('en-sg', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enSg;
});

/***/ }),

/***/ 40996:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Esperanto [eo]
//! author : Colin Dean : https://github.com/colindean
//! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
//! comment : miestasmia corrected the translation by colindean
//! comment : Vivakvo corrected the translation by colindean and miestasmia
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var eo = moment.defineLocale('eo', {
    months: 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
    monthsShort: 'jan_feb_mart_apr_maj_jun_jul_ag_sept_okt_nov_dec'.split('_'),
    weekdays: 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
    weekdaysShort: 'dim_lun_mard_merk_a_ven_sab'.split('_'),
    weekdaysMin: 'di_lu_ma_me_a_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: '[la] D[-an de] MMMM, YYYY',
      LLL: '[la] D[-an de] MMMM, YYYY HH:mm',
      LLLL: 'dddd[n], [la] D[-an de] MMMM, YYYY HH:mm',
      llll: 'ddd, [la] D[-an de] MMM, YYYY HH:mm'
    },
    meridiemParse: /[ap]\.t\.m/i,
    isPM: function isPM(input) {
      return input.charAt(0).toLowerCase() === 'p';
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'p.t.m.' : 'P.T.M.';
      } else {
        return isLower ? 'a.t.m.' : 'A.T.M.';
      }
    },
    calendar: {
      sameDay: '[Hodia je] LT',
      nextDay: '[Morga je] LT',
      nextWeek: 'dddd[n je] LT',
      lastDay: '[Hiera je] LT',
      lastWeek: '[pasintan] dddd[n je] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'post %s',
      past: 'anta %s',
      s: 'kelkaj sekundoj',
      ss: '%d sekundoj',
      m: 'unu minuto',
      mm: '%d minutoj',
      h: 'unu horo',
      hh: '%d horoj',
      d: 'unu tago',
      //ne 'diurno', ar estas uzita por proksimumo
      dd: '%d tagoj',
      M: 'unu monato',
      MM: '%d monatoj',
      y: 'unu jaro',
      yy: '%d jaroj'
    },
    dayOfMonthOrdinalParse: /\d{1,2}a/,
    ordinal: '%da',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return eo;
});

/***/ }),

/***/ 99749:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (Dominican Republic) [es-do]
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      _monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
      monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

  var esDo = moment.defineLocale('es-do', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return _monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY h:mm A',
      LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar: {
      sameDay: function sameDay() {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function nextDay() {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function nextWeek() {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function lastDay() {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function lastWeek() {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      w: 'una semana',
      ww: '%d semanas',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return esDo;
});

/***/ }),

/***/ 29604:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (Mexico) [es-mx]
//! author : JC Franco : https://github.com/jcfranco
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      _monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
      monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

  var esMx = moment.defineLocale('es-mx', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return _monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function sameDay() {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function nextDay() {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function nextWeek() {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function lastDay() {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function lastWeek() {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      w: 'una semana',
      ww: '%d semanas',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    },
    invalidDate: 'Fecha invlida'
  });
  return esMx;
});

/***/ }),

/***/ 57034:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (United States) [es-us]
//! author : bustta : https://github.com/bustta
//! author : chrisrodz : https://github.com/chrisrodz
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      _monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
      monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

  var esUs = moment.defineLocale('es-us', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return _monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'MM/DD/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY h:mm A',
      LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar: {
      sameDay: function sameDay() {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function nextDay() {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function nextWeek() {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function lastDay() {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function lastWeek() {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      w: 'una semana',
      ww: '%d semanas',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return esUs;
});

/***/ }),

/***/ 59314:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish [es]
//! author : Julio Napur : https://github.com/julionc
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      _monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
      monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;

  var es = moment.defineLocale('es', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return _monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function sameDay() {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function nextDay() {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function nextWeek() {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function lastDay() {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function lastWeek() {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      w: 'una semana',
      ww: '%d semanas',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    },
    invalidDate: 'Fecha invlida'
  });
  return es;
});

/***/ }),

/***/ 75366:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Estonian [et]
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      s: ['mne sekundi', 'mni sekund', 'paar sekundit'],
      ss: [number + 'sekundi', number + 'sekundit'],
      m: ['he minuti', 'ks minut'],
      mm: [number + ' minuti', number + ' minutit'],
      h: ['he tunni', 'tund aega', 'ks tund'],
      hh: [number + ' tunni', number + ' tundi'],
      d: ['he peva', 'ks pev'],
      M: ['kuu aja', 'kuu aega', 'ks kuu'],
      MM: [number + ' kuu', number + ' kuud'],
      y: ['he aasta', 'aasta', 'ks aasta'],
      yy: [number + ' aasta', number + ' aastat']
    };

    if (withoutSuffix) {
      return format[key][2] ? format[key][2] : format[key][1];
    }

    return isFuture ? format[key][0] : format[key][1];
  }

  var et = moment.defineLocale('et', {
    months: 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
    monthsShort: 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
    weekdays: 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
    weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
    weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[Tna,] LT',
      nextDay: '[Homme,] LT',
      nextWeek: '[Jrgmine] dddd LT',
      lastDay: '[Eile,] LT',
      lastWeek: '[Eelmine] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s prast',
      past: '%s tagasi',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: '%d peva',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return et;
});

/***/ }),

/***/ 95121:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Basque [eu]
//! author : Eneko Illarramendi : https://github.com/eillarra
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var eu = moment.defineLocale('eu', {
    months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
    monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
    monthsParseExact: true,
    weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
    weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
    weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY[ko] MMMM[ren] D[a]',
      LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
      LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
      l: 'YYYY-M-D',
      ll: 'YYYY[ko] MMM D[a]',
      lll: 'YYYY[ko] MMM D[a] HH:mm',
      llll: 'ddd, YYYY[ko] MMM D[a] HH:mm'
    },
    calendar: {
      sameDay: '[gaur] LT[etan]',
      nextDay: '[bihar] LT[etan]',
      nextWeek: 'dddd LT[etan]',
      lastDay: '[atzo] LT[etan]',
      lastWeek: '[aurreko] dddd LT[etan]',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s barru',
      past: 'duela %s',
      s: 'segundo batzuk',
      ss: '%d segundo',
      m: 'minutu bat',
      mm: '%d minutu',
      h: 'ordu bat',
      hh: '%d ordu',
      d: 'egun bat',
      dd: '%d egun',
      M: 'hilabete bat',
      MM: '%d hilabete',
      y: 'urte bat',
      yy: '%d urte'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return eu;
});

/***/ }),

/***/ 55851:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Persian [fa]
//! author : Ebrahim Byagowi : https://github.com/ebraminio
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var fa = moment.defineLocale('fa', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: "\u06CC\u06A9\u200C\u0634\u0646\u0628\u0647_\u062F\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200C\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067E\u0646\u062C\u200C\u0634\u0646\u0628\u0647_\u062C\u0645\u0639\u0647_\u0634\u0646\u0628\u0647".split('_'),
    weekdaysShort: "\u06CC\u06A9\u200C\u0634\u0646\u0628\u0647_\u062F\u0648\u0634\u0646\u0628\u0647_\u0633\u0647\u200C\u0634\u0646\u0628\u0647_\u0686\u0647\u0627\u0631\u0634\u0646\u0628\u0647_\u067E\u0646\u062C\u200C\u0634\u0646\u0628\u0647_\u062C\u0645\u0639\u0647_\u0634\u0646\u0628\u0647".split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /  |  /,
    isPM: function isPM(input) {
      return /  /.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '  ';
      } else {
        return '  ';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[-]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return fa;
});

/***/ }),

/***/ 89785:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Finnish [fi]
//! author : Tarmo Aidantausta : https://github.com/bleadof
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
      numbersFuture = ['nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden', numbersPast[7], numbersPast[8], numbersPast[9]];

  function translate(number, withoutSuffix, key, isFuture) {
    var result = '';

    switch (key) {
      case 's':
        return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';

      case 'ss':
        result = isFuture ? 'sekunnin' : 'sekuntia';
        break;

      case 'm':
        return isFuture ? 'minuutin' : 'minuutti';

      case 'mm':
        result = isFuture ? 'minuutin' : 'minuuttia';
        break;

      case 'h':
        return isFuture ? 'tunnin' : 'tunti';

      case 'hh':
        result = isFuture ? 'tunnin' : 'tuntia';
        break;

      case 'd':
        return isFuture ? 'pivn' : 'piv';

      case 'dd':
        result = isFuture ? 'pivn' : 'piv';
        break;

      case 'M':
        return isFuture ? 'kuukauden' : 'kuukausi';

      case 'MM':
        result = isFuture ? 'kuukauden' : 'kuukautta';
        break;

      case 'y':
        return isFuture ? 'vuoden' : 'vuosi';

      case 'yy':
        result = isFuture ? 'vuoden' : 'vuotta';
        break;
    }

    result = verbalNumber(number, isFuture) + ' ' + result;
    return result;
  }

  function verbalNumber(number, isFuture) {
    return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
  }

  var fi = moment.defineLocale('fi', {
    months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
    monthsShort: 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
    weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
    weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
    weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD.MM.YYYY',
      LL: 'Do MMMM[ta] YYYY',
      LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
      LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
      l: 'D.M.YYYY',
      ll: 'Do MMM YYYY',
      lll: 'Do MMM YYYY, [klo] HH.mm',
      llll: 'ddd, Do MMM YYYY, [klo] HH.mm'
    },
    calendar: {
      sameDay: '[tnn] [klo] LT',
      nextDay: '[huomenna] [klo] LT',
      nextWeek: 'dddd [klo] LT',
      lastDay: '[eilen] [klo] LT',
      lastWeek: '[viime] dddd[na] [klo] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s pst',
      past: '%s sitten',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fi;
});

/***/ }),

/***/ 62830:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Filipino [fil]
//! author : Dan Hagman : https://github.com/hagmandan
//! author : Matthew Co : https://github.com/matthewdeeco
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var fil = moment.defineLocale('fil', {
    months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
    monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
    weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
    weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
    weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'MM/D/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY HH:mm',
      LLLL: 'dddd, MMMM DD, YYYY HH:mm'
    },
    calendar: {
      sameDay: 'LT [ngayong araw]',
      nextDay: '[Bukas ng] LT',
      nextWeek: 'LT [sa susunod na] dddd',
      lastDay: 'LT [kahapon]',
      lastWeek: 'LT [noong nakaraang] dddd',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'sa loob ng %s',
      past: '%s ang nakalipas',
      s: 'ilang segundo',
      ss: '%d segundo',
      m: 'isang minuto',
      mm: '%d minuto',
      h: 'isang oras',
      hh: '%d oras',
      d: 'isang araw',
      dd: '%d araw',
      M: 'isang buwan',
      MM: '%d buwan',
      y: 'isang taon',
      yy: '%d taon'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function ordinal(number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fil;
});

/***/ }),

/***/ 74933:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Faroese [fo]
//! author : Ragnar Johannesen : https://github.com/ragnar123
//! author : Kristian Sakarisson : https://github.com/sakarisson
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var fo = moment.defineLocale('fo', {
    months: 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays: 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
    weekdaysShort: 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
    weekdaysMin: 'su_m_t_mi_h_fr_le'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D. MMMM, YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ dag kl.] LT',
      nextDay: '[ morgin kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[ gjr kl.] LT',
      lastWeek: '[sstu] dddd [kl] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'um %s',
      past: '%s sani',
      s: 'f sekund',
      ss: '%d sekundir',
      m: 'ein minuttur',
      mm: '%d minuttir',
      h: 'ein tmi',
      hh: '%d tmar',
      d: 'ein dagur',
      dd: '%d dagar',
      M: 'ein mnaur',
      MM: '%d mnair',
      y: 'eitt r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fo;
});

/***/ }),

/***/ 36979:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Canada) [fr-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var frCa = moment.defineLocale('fr-ca', {
    months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourdhui ] LT',
      nextDay: '[Demain ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[Hier ] LT',
      lastWeek: 'dddd [dernier ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        // Words with masculine grammatical gender: mois, trimestre, jour
        default:
        case 'M':
        case 'Q':
        case 'D':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');
        // Words with feminine grammatical gender: semaine

        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    }
  });
  return frCa;
});

/***/ }),

/***/ 62466:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Switzerland) [fr-ch]
//! author : Gaspard Bucher : https://github.com/gaspard
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var frCh = moment.defineLocale('fr-ch', {
    months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourdhui ] LT',
      nextDay: '[Demain ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[Hier ] LT',
      lastWeek: 'dddd [dernier ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        // Words with masculine grammatical gender: mois, trimestre, jour
        default:
        case 'M':
        case 'Q':
        case 'D':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');
        // Words with feminine grammatical gender: semaine

        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return frCh;
});

/***/ }),

/***/ 92051:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French [fr]
//! author : John Fischer : https://github.com/jfroffice
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsStrictRegex = /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i,
      monthsShortStrictRegex = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?)/i,
      monthsRegex = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?|janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i,
      monthsParse = [/^janv/i, /^fvr/i, /^mars/i, /^avr/i, /^mai/i, /^juin/i, /^juil/i, /^aot/i, /^sept/i, /^oct/i, /^nov/i, /^dc/i];
  var fr = moment.defineLocale('fr', {
    months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: monthsStrictRegex,
    monthsShortStrictRegex: monthsShortStrictRegex,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourdhui ] LT',
      nextDay: '[Demain ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[Hier ] LT',
      lastWeek: 'dddd [dernier ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      w: 'une semaine',
      ww: '%d semaines',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        // TODO: Return 'e' when day of month > 1. Move this case inside
        // block for masculine words below.
        // See https://github.com/moment/moment/issues/3375
        case 'D':
          return number + (number === 1 ? 'er' : '');
        // Words with masculine grammatical gender: mois, trimestre, jour

        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');
        // Words with feminine grammatical gender: semaine

        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fr;
});

/***/ }),

/***/ 57389:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Frisian [fy]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
      monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');
  var fy = moment.defineLocale('fy', {
    months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsParseExact: true,
    weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
    weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
    weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[hjoed om] LT',
      nextDay: '[moarn om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[juster om] LT',
      lastWeek: '[frne] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'oer %s',
      past: '%s lyn',
      s: 'in pear sekonden',
      ss: '%d sekonden',
      m: 'ien mint',
      mm: '%d minuten',
      h: 'ien oere',
      hh: '%d oeren',
      d: 'ien dei',
      dd: '%d dagen',
      M: 'ien moanne',
      MM: '%d moannen',
      y: 'ien jier',
      yy: '%d jierren'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function ordinal(number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fy;
});

/***/ }),

/***/ 44060:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Irish or Irish Gaelic [ga]
//! author : Andr Silva : https://github.com/askpt
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = ['Eanir', 'Feabhra', 'Mrta', 'Aibren', 'Bealtaine', 'Meitheamh', 'Iil', 'Lnasa', 'Men Fmhair', 'Deireadh Fmhair', 'Samhain', 'Nollaig'],
      monthsShort = ['Ean', 'Feabh', 'Mrt', 'Aib', 'Beal', 'Meith', 'Iil', 'Ln', 'M.F.', 'D.F.', 'Samh', 'Noll'],
      weekdays = ['D Domhnaigh', 'D Luain', 'D Mirt', 'D Cadaoin', 'Dardaoin', 'D hAoine', 'D Sathairn'],
      weekdaysShort = ['Domh', 'Luan', 'Mirt', 'Cad', 'Dar', 'Aoine', 'Sath'],
      weekdaysMin = ['Do', 'Lu', 'M', 'C', 'D', 'A', 'Sa'];
  var ga = moment.defineLocale('ga', {
    months: months,
    monthsShort: monthsShort,
    monthsParseExact: true,
    weekdays: weekdays,
    weekdaysShort: weekdaysShort,
    weekdaysMin: weekdaysMin,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Inniu ag] LT',
      nextDay: '[Amrach ag] LT',
      nextWeek: 'dddd [ag] LT',
      lastDay: '[Inn ag] LT',
      lastWeek: 'dddd [seo caite] [ag] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'i %s',
      past: '%s  shin',
      s: 'cpla soicind',
      ss: '%d soicind',
      m: 'nimad',
      mm: '%d nimad',
      h: 'uair an chloig',
      hh: '%d uair an chloig',
      d: 'l',
      dd: '%d l',
      M: 'm',
      MM: '%d monna',
      y: 'bliain',
      yy: '%d bliain'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
    ordinal: function ordinal(number) {
      var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ga;
});

/***/ }),

/***/ 44640:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Scottish Gaelic [gd]
//! author : Jon Ashdown : https://github.com/jonashdown
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = ['Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'],
      monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'],
      weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'],
      weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'],
      weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];
  var gd = moment.defineLocale('gd', {
    months: months,
    monthsShort: monthsShort,
    monthsParseExact: true,
    weekdays: weekdays,
    weekdaysShort: weekdaysShort,
    weekdaysMin: weekdaysMin,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[An-diugh aig] LT',
      nextDay: '[A-mireach aig] LT',
      nextWeek: 'dddd [aig] LT',
      lastDay: '[An-d aig] LT',
      lastWeek: 'dddd [seo chaidh] [aig] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ann an %s',
      past: 'bho chionn %s',
      s: 'beagan diogan',
      ss: '%d diogan',
      m: 'mionaid',
      mm: '%d mionaidean',
      h: 'uair',
      hh: '%d uairean',
      d: 'latha',
      dd: '%d latha',
      M: 'mos',
      MM: '%d mosan',
      y: 'bliadhna',
      yy: '%d bliadhna'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
    ordinal: function ordinal(number) {
      var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return gd;
});

/***/ }),

/***/ 85090:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Galician [gl]
//! author : Juan G. Hurtado : https://github.com/juanghurtado
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var gl = moment.defineLocale('gl', {
    months: 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
    monthsShort: 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_m_xo_ve_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function sameDay() {
        return '[hoxe ' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function nextDay() {
        return '[ma ' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function nextWeek() {
        return 'dddd [' + (this.hours() !== 1 ? 's' : 'a') + '] LT';
      },
      lastDay: function lastDay() {
        return '[onte ' + (this.hours() !== 1 ? '' : 'a') + '] LT';
      },
      lastWeek: function lastWeek() {
        return '[o] dddd [pasado ' + (this.hours() !== 1 ? 's' : 'a') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: function future(str) {
        if (str.indexOf('un') === 0) {
          return 'n' + str;
        }

        return 'en ' + str;
      },
      past: 'hai %s',
      s: 'uns segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'unha hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return gl;
});

/***/ }),

/***/ 22927:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Konkani Devanagari script [gom-deva]
//! author : The Discoverer : https://github.com/WikiDiscoverer
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      s: [' ', ' '],
      ss: [number + ' ', number + ' '],
      m: [' ', ' '],
      mm: [number + ' ', number + ' '],
      h: [' ', ' '],
      hh: [number + ' ', number + ' '],
      d: [' ', ' '],
      dd: [number + ' ', number + ' '],
      M: [' ', ' '],
      MM: [number + ' ', number + ' '],
      y: [' ', ' '],
      yy: [number + ' ', number + ' ']
    };
    return isFuture ? format[key][0] : format[key][1];
  }

  var gomDeva = moment.defineLocale('gom-deva', {
    months: {
      standalone: '___________'.split('_'),
      format: '___________'.split('_'),
      isFormat: /MMMM(\s)+D[oD]?/
    },
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'A h:mm []',
      LTS: 'A h:mm:ss []',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY A h:mm []',
      LLLL: 'dddd, MMMM Do, YYYY, A h:mm []',
      llll: 'ddd, D MMM YYYY, A h:mm []'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd[,] LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s ',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}()/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        // the ordinal '' only applies to day of the month
        case 'D':
          return number + '';

        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
        case 'w':
        case 'W':
          return number;
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week
      doy: 3 // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)

    },
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour > 12 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 16) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    }
  });
  return gomDeva;
});

/***/ }),

/***/ 73602:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Konkani Latin script [gom-latn]
//! author : The Discoverer : https://github.com/WikiDiscoverer
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      s: ['thoddea sekondamni', 'thodde sekond'],
      ss: [number + ' sekondamni', number + ' sekond'],
      m: ['eka mintan', 'ek minut'],
      mm: [number + ' mintamni', number + ' mintam'],
      h: ['eka voran', 'ek vor'],
      hh: [number + ' voramni', number + ' voram'],
      d: ['eka disan', 'ek dis'],
      dd: [number + ' disamni', number + ' dis'],
      M: ['eka mhoinean', 'ek mhoino'],
      MM: [number + ' mhoineamni', number + ' mhoine'],
      y: ['eka vorsan', 'ek voros'],
      yy: [number + ' vorsamni', number + ' vorsam']
    };
    return isFuture ? format[key][0] : format[key][1];
  }

  var gomLatn = moment.defineLocale('gom-latn', {
    months: {
      standalone: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
      format: 'Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea'.split('_'),
      isFormat: /MMMM(\s)+D[oD]?/
    },
    monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split('_'),
    weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
    weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'A h:mm [vazta]',
      LTS: 'A h:mm:ss [vazta]',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY A h:mm [vazta]',
      LLLL: 'dddd, MMMM Do, YYYY, A h:mm [vazta]',
      llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
    },
    calendar: {
      sameDay: '[Aiz] LT',
      nextDay: '[Faleam] LT',
      nextWeek: '[Fuddlo] dddd[,] LT',
      lastDay: '[Kal] LT',
      lastWeek: '[Fattlo] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s adim',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        // the ordinal 'er' only applies to day of the month
        case 'D':
          return number + 'er';

        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
        case 'w':
        case 'W':
          return number;
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week
      doy: 3 // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)

    },
    meridiemParse: /rati|sokallim|donparam|sanje/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'rati') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'sokallim') {
        return hour;
      } else if (meridiem === 'donparam') {
        return hour > 12 ? hour : hour + 12;
      } else if (meridiem === 'sanje') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return 'rati';
      } else if (hour < 12) {
        return 'sokallim';
      } else if (hour < 16) {
        return 'donparam';
      } else if (hour < 20) {
        return 'sanje';
      } else {
        return 'rati';
      }
    }
  });
  return gomLatn;
});

/***/ }),

/***/ 20486:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Gujarati [gu]
//! author : Kaushik Thanki : https://github.com/Kaushik1987
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var gu = moment.defineLocale('gu', {
    months: '___________'.split('_'),
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return gu;
});

/***/ }),

/***/ 19023:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hebrew [he]
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var he = moment.defineLocale('he', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D []MMMM YYYY',
      LLL: 'D []MMMM YYYY HH:mm',
      LLLL: 'dddd, D []MMMM YYYY HH:mm',
      l: 'D/M/YYYY',
      ll: 'D MMM YYYY',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd, D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ]LT',
      nextDay: '[ ]LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ]LT',
      lastWeek: '[] dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: function hh(number) {
        if (number === 2) {
          return '';
        }

        return number + ' ';
      },
      d: '',
      dd: function dd(number) {
        if (number === 2) {
          return '';
        }

        return number + ' ';
      },
      M: '',
      MM: function MM(number) {
        if (number === 2) {
          return '';
        }

        return number + ' ';
      },
      y: '',
      yy: function yy(number) {
        if (number === 2) {
          return '';
        } else if (number % 10 === 0 && number !== 10) {
          return number + ' ';
        }

        return number + ' ';
      }
    },
    meridiemParse: /"|"| | | ||/i,
    isPM: function isPM(input) {
      return /^("| |)$/.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 5) {
        return ' ';
      } else if (hour < 10) {
        return '';
      } else if (hour < 12) {
        return isLower ? '"' : ' ';
      } else if (hour < 18) {
        return isLower ? '"' : ' ';
      } else {
        return '';
      }
    }
  });
  return he;
});

/***/ }),

/***/ 79435:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hindi [hi]
//! author : Mayank Singhal : https://github.com/mayanksinghal
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  },
      monthsParse = [/^/i, /^|/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^|/i, /^/i, /^|/i, /^|/i],
      shortMonthsParse = [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];
  var hi = moment.defineLocale('hi', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '._.__.___._._._._._.'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: shortMonthsParse,
    monthsRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
    monthsShortRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
    monthsStrictRegex: /^(?||?|?|?|?|?|?|?|||?\.?||\.?||?||?)/i,
    monthsShortStrictRegex: /^(\.?|\.?|?|\.?|?|?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '  ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return hi;
});

/***/ }),

/***/ 96345:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Croatian [hr]
//! author : Bojan Markovi : https://github.com/bmarkovic
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function translate(number, withoutSuffix, key) {
    var result = number + ' ';

    switch (key) {
      case 'ss':
        if (number === 1) {
          result += 'sekunda';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sekunde';
        } else {
          result += 'sekundi';
        }

        return result;

      case 'm':
        return withoutSuffix ? 'jedna minuta' : 'jedne minute';

      case 'mm':
        if (number === 1) {
          result += 'minuta';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'minute';
        } else {
          result += 'minuta';
        }

        return result;

      case 'h':
        return withoutSuffix ? 'jedan sat' : 'jednog sata';

      case 'hh':
        if (number === 1) {
          result += 'sat';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sata';
        } else {
          result += 'sati';
        }

        return result;

      case 'dd':
        if (number === 1) {
          result += 'dan';
        } else {
          result += 'dana';
        }

        return result;

      case 'MM':
        if (number === 1) {
          result += 'mjesec';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'mjeseca';
        } else {
          result += 'mjeseci';
        }

        return result;

      case 'yy':
        if (number === 1) {
          result += 'godina';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'godine';
        } else {
          result += 'godina';
        }

        return result;
    }
  }

  var hr = moment.defineLocale('hr', {
    months: {
      format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
      standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
    },
    monthsShort: 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'Do MMMM YYYY',
      LLL: 'Do MMMM YYYY H:mm',
      LLLL: 'dddd, Do MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';

          case 3:
            return '[u] [srijedu] [u] LT';

          case 6:
            return '[u] [subotu] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[juer u] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[prolu] [nedjelju] [u] LT';

          case 3:
            return '[prolu] [srijedu] [u] LT';

          case 6:
            return '[prole] [subote] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[proli] dddd [u] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'par sekundi',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: 'dan',
      dd: translate,
      M: 'mjesec',
      MM: translate,
      y: 'godinu',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return hr;
});

/***/ }),

/***/ 47492:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hungarian [hu]
//! author : Adam Brunner : https://github.com/adambrunner
//! author : Peter Viszt  : https://github.com/passatgt
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');

  function translate(number, withoutSuffix, key, isFuture) {
    var num = number;

    switch (key) {
      case 's':
        return isFuture || withoutSuffix ? 'nhny msodperc' : 'nhny msodperce';

      case 'ss':
        return num + (isFuture || withoutSuffix) ? ' msodperc' : ' msodperce';

      case 'm':
        return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');

      case 'mm':
        return num + (isFuture || withoutSuffix ? ' perc' : ' perce');

      case 'h':
        return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');

      case 'hh':
        return num + (isFuture || withoutSuffix ? ' ra' : ' rja');

      case 'd':
        return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');

      case 'dd':
        return num + (isFuture || withoutSuffix ? ' nap' : ' napja');

      case 'M':
        return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');

      case 'MM':
        return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');

      case 'y':
        return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');

      case 'yy':
        return num + (isFuture || withoutSuffix ? ' v' : ' ve');
    }

    return '';
  }

  function week(isFuture) {
    return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
  }

  var hu = moment.defineLocale('hu', {
    months: 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
    monthsShort: 'jan._feb._mrc._pr._mj._jn._jl._aug._szept._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
    weekdaysShort: 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
    weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'YYYY.MM.DD.',
      LL: 'YYYY. MMMM D.',
      LLL: 'YYYY. MMMM D. H:mm',
      LLLL: 'YYYY. MMMM D., dddd H:mm'
    },
    meridiemParse: /de|du/i,
    isPM: function isPM(input) {
      return input.charAt(1).toLowerCase() === 'u';
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 12) {
        return isLower === true ? 'de' : 'DE';
      } else {
        return isLower === true ? 'du' : 'DU';
      }
    },
    calendar: {
      sameDay: '[ma] LT[-kor]',
      nextDay: '[holnap] LT[-kor]',
      nextWeek: function nextWeek() {
        return week.call(this, true);
      },
      lastDay: '[tegnap] LT[-kor]',
      lastWeek: function lastWeek() {
        return week.call(this, false);
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s mlva',
      past: '%s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return hu;
});

/***/ }),

/***/ 24585:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Armenian [hy-am]
//! author : Armendarabyan : https://github.com/armendarabyan
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var hyAm = moment.defineLocale('hy-am', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      lastDay: '[] LT',
      nextWeek: function nextWeek() {
        return 'dddd [ ] LT';
      },
      lastWeek: function lastWeek() {
        return '[] dddd [ ] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '  ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    meridiemParse: /|||/,
    isPM: function isPM(input) {
      return /^(|)$/.test(input);
    },
    meridiem: function meridiem(hour) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'DDD':
        case 'w':
        case 'W':
        case 'DDDo':
          if (number === 1) {
            return number + '-';
          }

          return number + '-';

        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return hyAm;
});

/***/ }),

/***/ 96701:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Indonesian [id]
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var id = moment.defineLocale('id', {
    months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
    weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
    weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|siang|sore|malam/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'siang') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'sore' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'siang';
      } else if (hours < 19) {
        return 'sore';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Besok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kemarin pukul] LT',
      lastWeek: 'dddd [lalu pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lalu',
      s: 'beberapa detik',
      ss: '%d detik',
      m: 'semenit',
      mm: '%d menit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return id;
});

/***/ }),

/***/ 65276:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Icelandic [is]
//! author : Hinrik rn Sigursson : https://github.com/hinrik
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function plural(n) {
    if (n % 100 === 11) {
      return true;
    } else if (n % 10 === 1) {
      return false;
    }

    return true;
  }

  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    switch (key) {
      case 's':
        return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';

      case 'ss':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'sekndur' : 'sekndum');
        }

        return result + 'seknda';

      case 'm':
        return withoutSuffix ? 'mnta' : 'mntu';

      case 'mm':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
        } else if (withoutSuffix) {
          return result + 'mnta';
        }

        return result + 'mntu';

      case 'hh':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
        }

        return result + 'klukkustund';

      case 'd':
        if (withoutSuffix) {
          return 'dagur';
        }

        return isFuture ? 'dag' : 'degi';

      case 'dd':
        if (plural(number)) {
          if (withoutSuffix) {
            return result + 'dagar';
          }

          return result + (isFuture ? 'daga' : 'dgum');
        } else if (withoutSuffix) {
          return result + 'dagur';
        }

        return result + (isFuture ? 'dag' : 'degi');

      case 'M':
        if (withoutSuffix) {
          return 'mnuur';
        }

        return isFuture ? 'mnu' : 'mnui';

      case 'MM':
        if (plural(number)) {
          if (withoutSuffix) {
            return result + 'mnuir';
          }

          return result + (isFuture ? 'mnui' : 'mnuum');
        } else if (withoutSuffix) {
          return result + 'mnuur';
        }

        return result + (isFuture ? 'mnu' : 'mnui');

      case 'y':
        return withoutSuffix || isFuture ? 'r' : 'ri';

      case 'yy':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'r' : 'rum');
        }

        return result + (withoutSuffix || isFuture ? 'r' : 'ri');
    }
  }

  var is = moment.defineLocale('is', {
    months: 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
    monthsShort: 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
    weekdays: 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
    weekdaysShort: 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
    weekdaysMin: 'Su_M_r_Mi_Fi_F_La'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] H:mm',
      LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm'
    },
    calendar: {
      sameDay: '[ dag kl.] LT',
      nextDay: '[ morgun kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[ gr kl.] LT',
      lastWeek: '[sasta] dddd [kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'eftir %s',
      past: 'fyrir %s san',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: 'klukkustund',
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return is;
});

/***/ }),

/***/ 75062:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian (Switzerland) [it-ch]
//! author : xfh : https://github.com/xfh
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var itCh = moment.defineLocale('it-ch', {
    months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
    weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Oggi alle] LT',
      nextDay: '[Domani alle] LT',
      nextWeek: 'dddd [alle] LT',
      lastDay: '[Ieri alle] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[la scorsa] dddd [alle] LT';

          default:
            return '[lo scorso] dddd [alle] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: function future(s) {
        return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
      },
      past: '%s fa',
      s: 'alcuni secondi',
      ss: '%d secondi',
      m: 'un minuto',
      mm: '%d minuti',
      h: "un'ora",
      hh: '%d ore',
      d: 'un giorno',
      dd: '%d giorni',
      M: 'un mese',
      MM: '%d mesi',
      y: 'un anno',
      yy: '%d anni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return itCh;
});

/***/ }),

/***/ 23602:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian [it]
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz
//! author: Marco : https://github.com/Manfre98
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var it = moment.defineLocale('it', {
    months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
    weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: function sameDay() {
        return '[Oggi a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
      },
      nextDay: function nextDay() {
        return '[Domani a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
      },
      nextWeek: function nextWeek() {
        return 'dddd [a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
      },
      lastDay: function lastDay() {
        return '[Ieri a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
      },
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[La scorsa] dddd [a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';

          default:
            return '[Lo scorso] dddd [a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'tra %s',
      past: '%s fa',
      s: 'alcuni secondi',
      ss: '%d secondi',
      m: 'un minuto',
      mm: '%d minuti',
      h: "un'ora",
      hh: '%d ore',
      d: 'un giorno',
      dd: '%d giorni',
      w: 'una settimana',
      ww: '%d settimane',
      M: 'un mese',
      MM: '%d mesi',
      y: 'un anno',
      yy: '%d anni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return it;
});

/***/ }),

/***/ 90987:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Japanese [ja]
//! author : LI Long : https://github.com/baryon
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ja = moment.defineLocale('ja', {
    eras: [{
      since: '2019-05-01',
      offset: 1,
      name: '',
      narrow: '',
      abbr: 'R'
    }, {
      since: '1989-01-08',
      until: '2019-04-30',
      offset: 1,
      name: '',
      narrow: '',
      abbr: 'H'
    }, {
      since: '1926-12-25',
      until: '1989-01-07',
      offset: 1,
      name: '',
      narrow: '',
      abbr: 'S'
    }, {
      since: '1912-07-30',
      until: '1926-12-24',
      offset: 1,
      name: '',
      narrow: '',
      abbr: 'T'
    }, {
      since: '1873-01-01',
      until: '1912-07-29',
      offset: 6,
      name: '',
      narrow: '',
      abbr: 'M'
    }, {
      since: '0001-01-01',
      until: '1873-12-31',
      offset: 1,
      name: '',
      narrow: 'AD',
      abbr: 'AD'
    }, {
      since: '0000-12-31',
      until: -Infinity,
      offset: 1,
      name: '',
      narrow: 'BC',
      abbr: 'BC'
    }],
    eraYearOrdinalRegex: /(|\d+)/,
    eraYearOrdinalParse: function eraYearOrdinalParse(input, match) {
      return match[1] === '' ? 1 : parseInt(match[1] || input, 10);
    },
    months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMD dddd HH:mm',
      l: 'YYYY/MM/DD',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMD(ddd) HH:mm'
    },
    meridiemParse: /|/i,
    isPM: function isPM(input) {
      return input === '';
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: function nextWeek(now) {
        if (now.week() !== this.week()) {
          return '[]dddd LT';
        } else {
          return 'dddd LT';
        }
      },
      lastDay: '[] LT',
      lastWeek: function lastWeek(now) {
        if (this.week() !== now.week()) {
          return '[]dddd LT';
        } else {
          return 'dddd LT';
        }
      },
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'y':
          return number === 1 ? '' : number + '';

        case 'd':
        case 'D':
        case 'DDD':
          return number + '';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d',
      m: '1',
      mm: '%d',
      h: '1',
      hh: '%d',
      d: '1',
      dd: '%d',
      M: '1',
      MM: '%d',
      y: '1',
      yy: '%d'
    }
  });
  return ja;
});

/***/ }),

/***/ 35485:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Javanese [jv]
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var jv = moment.defineLocale('jv', {
    months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
    weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
    weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
    weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /enjing|siyang|sonten|ndalu/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'enjing') {
        return hour;
      } else if (meridiem === 'siyang') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 11) {
        return 'enjing';
      } else if (hours < 15) {
        return 'siyang';
      } else if (hours < 19) {
        return 'sonten';
      } else {
        return 'ndalu';
      }
    },
    calendar: {
      sameDay: '[Dinten puniko pukul] LT',
      nextDay: '[Mbenjang pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kala wingi pukul] LT',
      lastWeek: 'dddd [kepengker pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'wonten ing %s',
      past: '%s ingkang kepengker',
      s: 'sawetawis detik',
      ss: '%d detik',
      m: 'setunggal menit',
      mm: '%d menit',
      h: 'setunggal jam',
      hh: '%d jam',
      d: 'sedinten',
      dd: '%d dinten',
      M: 'sewulan',
      MM: '%d wulan',
      y: 'setaun',
      yy: '%d taun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return jv;
});

/***/ }),

/***/ 13048:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Georgian [ka]
//! author : Irakli Janiashvili : https://github.com/IrakliJani
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ka = moment.defineLocale('ka', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: {
      standalone: '______'.split('_'),
      format: '______'.split('_'),
      isFormat: /(|)/
    },
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[] LT[-]',
      nextDay: '[] LT[-]',
      lastDay: '[] LT[-]',
      nextWeek: '[] dddd LT[-]',
      lastWeek: '[] dddd LT-',
      sameElse: 'L'
    },
    relativeTime: {
      future: function future(s) {
        return s.replace(/(|||||)(|)/, function ($0, $1, $2) {
          return $2 === '' ? $1 + '' : $1 + $2 + '';
        });
      },
      past: function past(s) {
        if (/(||||)/.test(s)) {
          return s.replace(/(|)$/, ' ');
        }

        if (//.test(s)) {
          return s.replace(/$/, ' ');
        }

        return s;
      },
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
    ordinal: function ordinal(number) {
      if (number === 0) {
        return number;
      }

      if (number === 1) {
        return number + '-';
      }

      if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) {
        return '-' + number;
      }

      return number + '-';
    },
    week: {
      dow: 1,
      doy: 7
    }
  });
  return ka;
});

/***/ }),

/***/ 12664:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kazakh [kk]
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
  };
  var kk = moment.defineLocale('kk', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: '[ ] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function ordinal(number) {
      var a = number % 10,
          b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return kk;
});

/***/ }),

/***/ 12681:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Cambodian [km]
//! author : Kruy Vanna : https://github.com/kruyvanna
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var km = moment.defineLocale('km', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return input === '';
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return km;
});

/***/ }),

/***/ 45263:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kannada [kn]
//! author : Rajeev Naik : https://github.com/rajeevnaikte
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var kn = moment.defineLocale('kn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}()/,
    ordinal: function ordinal(number) {
      return number + '';
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return kn;
});

/***/ }),

/***/ 36023:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Korean [ko]
//! author : Kyungwook, Park : https://github.com/kyungw00k
//! author : Jeeeyul Lee <jeeeyul@gmail.com>
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ko = moment.defineLocale('ko', {
    months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'YYYY.MM.DD.',
      LL: 'YYYY MMMM D',
      LLL: 'YYYY MMMM D A h:mm',
      LLLL: 'YYYY MMMM D dddd A h:mm',
      l: 'YYYY.MM.DD.',
      ll: 'YYYY MMMM D',
      lll: 'YYYY MMMM D A h:mm',
      llll: 'YYYY MMMM D dddd A h:mm'
    },
    calendar: {
      sameDay: ' LT',
      nextDay: ' LT',
      nextWeek: 'dddd LT',
      lastDay: ' LT',
      lastWeek: ' dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d',
      m: '1',
      mm: '%d',
      h: ' ',
      hh: '%d',
      d: '',
      dd: '%d',
      M: ' ',
      MM: '%d',
      y: ' ',
      yy: '%d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';

        case 'M':
          return number + '';

        case 'w':
        case 'W':
          return number + '';

        default:
          return number;
      }
    },
    meridiemParse: /|/,
    isPM: function isPM(token) {
      return token === '';
    },
    meridiem: function meridiem(hour, minute, isUpper) {
      return hour < 12 ? '' : '';
    }
  });
  return ko;
});

/***/ }),

/***/ 34839:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kurdish [ku]
//! author : Shahram Mebashar : https://github.com/ShahramMebashar
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  },
      months = [' ', '', '', '', '', '', '', '', '', ' ', ' ', ' '];
  var ku = moment.defineLocale('ku', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return //.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s',
      s: ' ',
      ss: ' %d',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return ku;
});

/***/ }),

/***/ 77750:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kyrgyz [ky]
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
  };
  var ky = moment.defineLocale('ky', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: '[ ] dddd [] [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
    ordinal: function ordinal(number) {
      var a = number % 10,
          b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return ky;
});

/***/ }),

/***/ 77223:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Luxembourgish [lb]
//! author : mweimerskirch : https://github.com/mweimerskirch
//! author : David Raison : https://github.com/kwisatz
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      m: ['eng Minutt', 'enger Minutt'],
      h: ['eng Stonn', 'enger Stonn'],
      d: ['een Dag', 'engem Dag'],
      M: ['ee Mount', 'engem Mount'],
      y: ['ee Joer', 'engem Joer']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  function processFutureTime(string) {
    var number = string.substr(0, string.indexOf(' '));

    if (eifelerRegelAppliesToNumber(number)) {
      return 'a ' + string;
    }

    return 'an ' + string;
  }

  function processPastTime(string) {
    var number = string.substr(0, string.indexOf(' '));

    if (eifelerRegelAppliesToNumber(number)) {
      return 'viru ' + string;
    }

    return 'virun ' + string;
  }
  /**
   * Returns true if the word before the given number loses the '-n' ending.
   * e.g. 'an 10 Deeg' but 'a 5 Deeg'
   *
   * @param number {integer}
   * @returns {boolean}
   */


  function eifelerRegelAppliesToNumber(number) {
    number = parseInt(number, 10);

    if (isNaN(number)) {
      return false;
    }

    if (number < 0) {
      // Negative Number --> always true
      return true;
    } else if (number < 10) {
      // Only 1 digit
      if (4 <= number && number <= 7) {
        return true;
      }

      return false;
    } else if (number < 100) {
      // 2 digits
      var lastDigit = number % 10,
          firstDigit = number / 10;

      if (lastDigit === 0) {
        return eifelerRegelAppliesToNumber(firstDigit);
      }

      return eifelerRegelAppliesToNumber(lastDigit);
    } else if (number < 10000) {
      // 3 or 4 digits --> recursively check first digit
      while (number >= 10) {
        number = number / 10;
      }

      return eifelerRegelAppliesToNumber(number);
    } else {
      // Anything larger than 4 digits: recursively check first n-3 digits
      number = number / 1000;
      return eifelerRegelAppliesToNumber(number);
    }
  }

  var lb = moment.defineLocale('lb', {
    months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
    weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm [Auer]',
      LTS: 'H:mm:ss [Auer]',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm [Auer]',
      LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
    },
    calendar: {
      sameDay: '[Haut um] LT',
      sameElse: 'L',
      nextDay: '[Muer um] LT',
      nextWeek: 'dddd [um] LT',
      lastDay: '[Gschter um] LT',
      lastWeek: function lastWeek() {
        // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
        switch (this.day()) {
          case 2:
          case 4:
            return '[Leschten] dddd [um] LT';

          default:
            return '[Leschte] dddd [um] LT';
        }
      }
    },
    relativeTime: {
      future: processFutureTime,
      past: processPastTime,
      s: 'e puer Sekonnen',
      ss: '%d Sekonnen',
      m: processRelativeTime,
      mm: '%d Minutten',
      h: processRelativeTime,
      hh: '%d Stonnen',
      d: processRelativeTime,
      dd: '%d Deeg',
      M: processRelativeTime,
      MM: '%d Mint',
      y: processRelativeTime,
      yy: '%d Joer'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return lb;
});

/***/ }),

/***/ 81906:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lao [lo]
//! author : Ryan Hart : https://github.com/ryanhart2
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var lo = moment.defineLocale('lo', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return input === '';
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[]dddd[] LT',
      lastDay: '[] LT',
      lastWeek: '[]dddd[] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /()\d{1,2}/,
    ordinal: function ordinal(number) {
      return '' + number;
    }
  });
  return lo;
});

/***/ }),

/***/ 64837:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lithuanian [lt]
//! author : Mindaugas Mozras : https://github.com/mmozuras
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var units = {
    ss: 'sekund_sekundi_sekundes',
    m: 'minut_minuts_minut',
    mm: 'minuts_minui_minutes',
    h: 'valanda_valandos_valand',
    hh: 'valandos_valand_valandas',
    d: 'diena_dienos_dien',
    dd: 'dienos_dien_dienas',
    M: 'mnuo_mnesio_mnes',
    MM: 'mnesiai_mnesi_mnesius',
    y: 'metai_met_metus',
    yy: 'metai_met_metus'
  };

  function translateSeconds(number, withoutSuffix, key, isFuture) {
    if (withoutSuffix) {
      return 'kelios sekunds';
    } else {
      return isFuture ? 'keli sekundi' : 'kelias sekundes';
    }
  }

  function translateSingular(number, withoutSuffix, key, isFuture) {
    return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
  }

  function special(number) {
    return number % 10 === 0 || number > 10 && number < 20;
  }

  function forms(key) {
    return units[key].split('_');
  }

  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    if (number === 1) {
      return result + translateSingular(number, withoutSuffix, key[0], isFuture);
    } else if (withoutSuffix) {
      return result + (special(number) ? forms(key)[1] : forms(key)[0]);
    } else {
      if (isFuture) {
        return result + forms(key)[1];
      } else {
        return result + (special(number) ? forms(key)[1] : forms(key)[2]);
      }
    }
  }

  var lt = moment.defineLocale('lt', {
    months: {
      format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
      standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
      isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
    },
    monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
    weekdays: {
      format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
      standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
      isFormat: /dddd HH:mm/
    },
    weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
    weekdaysMin: 'S_P_A_T_K_Pn_'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY [m.] MMMM D [d.]',
      LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
      LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
      l: 'YYYY-MM-DD',
      ll: 'YYYY [m.] MMMM D [d.]',
      lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
      llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
    },
    calendar: {
      sameDay: '[iandien] LT',
      nextDay: '[Rytoj] LT',
      nextWeek: 'dddd LT',
      lastDay: '[Vakar] LT',
      lastWeek: '[Prajus] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'po %s',
      past: 'prie %s',
      s: translateSeconds,
      ss: translate,
      m: translateSingular,
      mm: translate,
      h: translateSingular,
      hh: translate,
      d: translateSingular,
      dd: translate,
      M: translateSingular,
      MM: translate,
      y: translateSingular,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
    ordinal: function ordinal(number) {
      return number + '-oji';
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return lt;
});

/***/ }),

/***/ 18656:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Latvian [lv]
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jnis Elmeris : https://github.com/JanisE
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var units = {
    ss: 'sekundes_sekundm_sekunde_sekundes'.split('_'),
    m: 'mintes_mintm_minte_mintes'.split('_'),
    mm: 'mintes_mintm_minte_mintes'.split('_'),
    h: 'stundas_stundm_stunda_stundas'.split('_'),
    hh: 'stundas_stundm_stunda_stundas'.split('_'),
    d: 'dienas_dienm_diena_dienas'.split('_'),
    dd: 'dienas_dienm_diena_dienas'.split('_'),
    M: 'mnea_mneiem_mnesis_mnei'.split('_'),
    MM: 'mnea_mneiem_mnesis_mnei'.split('_'),
    y: 'gada_gadiem_gads_gadi'.split('_'),
    yy: 'gada_gadiem_gads_gadi'.split('_')
  };
  /**
   * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
   */

  function format(forms, number, withoutSuffix) {
    if (withoutSuffix) {
      // E.g. "21 minte", "3 mintes".
      return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
    } else {
      // E.g. "21 mintes" as in "pc 21 mintes".
      // E.g. "3 mintm" as in "pc 3 mintm".
      return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
    }
  }

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    return number + ' ' + format(units[key], number, withoutSuffix);
  }

  function relativeTimeWithSingular(number, withoutSuffix, key) {
    return format(units[key], number, withoutSuffix);
  }

  function relativeSeconds(number, withoutSuffix) {
    return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
  }

  var lv = moment.defineLocale('lv', {
    months: 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
    monthsShort: 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
    weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY.',
      LL: 'YYYY. [gada] D. MMMM',
      LLL: 'YYYY. [gada] D. MMMM, HH:mm',
      LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm'
    },
    calendar: {
      sameDay: '[odien pulksten] LT',
      nextDay: '[Rt pulksten] LT',
      nextWeek: 'dddd [pulksten] LT',
      lastDay: '[Vakar pulksten] LT',
      lastWeek: '[Pagju] dddd [pulksten] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'pc %s',
      past: 'pirms %s',
      s: relativeSeconds,
      ss: relativeTimeWithPlural,
      m: relativeTimeWithSingular,
      mm: relativeTimeWithPlural,
      h: relativeTimeWithSingular,
      hh: relativeTimeWithPlural,
      d: relativeTimeWithSingular,
      dd: relativeTimeWithPlural,
      M: relativeTimeWithSingular,
      MM: relativeTimeWithPlural,
      y: relativeTimeWithSingular,
      yy: relativeTimeWithPlural
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return lv;
});

/***/ }),

/***/ 48331:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Montenegrin [me]
//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var translator = {
    words: {
      //Different grammatical cases
      ss: ['sekund', 'sekunda', 'sekundi'],
      m: ['jedan minut', 'jednog minuta'],
      mm: ['minut', 'minuta', 'minuta'],
      h: ['jedan sat', 'jednog sata'],
      hh: ['sat', 'sata', 'sati'],
      dd: ['dan', 'dana', 'dana'],
      MM: ['mjesec', 'mjeseca', 'mjeseci'],
      yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function correctGrammaticalCase(number, wordKey) {
      return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
    },
    translate: function translate(number, withoutSuffix, key) {
      var wordKey = translator.words[key];

      if (key.length === 1) {
        return withoutSuffix ? wordKey[0] : wordKey[1];
      } else {
        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
      }
    }
  };
  var me = moment.defineLocale('me', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sjutra u] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';

          case 3:
            return '[u] [srijedu] [u] LT';

          case 6:
            return '[u] [subotu] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[jue u] LT',
      lastWeek: function lastWeek() {
        var lastWeekDays = ['[prole] [nedjelje] [u] LT', '[prolog] [ponedjeljka] [u] LT', '[prolog] [utorka] [u] LT', '[prole] [srijede] [u] LT', '[prolog] [etvrtka] [u] LT', '[prolog] [petka] [u] LT', '[prole] [subote] [u] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'nekoliko sekundi',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: 'dan',
      dd: translator.translate,
      M: 'mjesec',
      MM: translator.translate,
      y: 'godinu',
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return me;
});

/***/ }),

/***/ 97645:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maori [mi]
//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var mi = moment.defineLocale('mi', {
    months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
    weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
    weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [i] HH:mm',
      LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
    },
    calendar: {
      sameDay: '[i teie mahana, i] LT',
      nextDay: '[apopo i] LT',
      nextWeek: 'dddd [i] LT',
      lastDay: '[inanahi i] LT',
      lastWeek: 'dddd [whakamutunga i] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'i roto i %s',
      past: '%s i mua',
      s: 'te hkona ruarua',
      ss: '%d hkona',
      m: 'he meneti',
      mm: '%d meneti',
      h: 'te haora',
      hh: '%d haora',
      d: 'he ra',
      dd: '%d ra',
      M: 'he marama',
      MM: '%d marama',
      y: 'he tau',
      yy: '%d tau'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return mi;
});

/***/ }),

/***/ 2963:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Macedonian [mk]
//! author : Borislav Mickov : https://github.com/B0k0
//! author : Sashko Todorov : https://github.com/bkyceh
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var mk = moment.defineLocale('mk', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: 'e_o_____a'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: '[] dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
          case 3:
          case 6:
            return '[] dddd [] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[] dddd [] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal: function ordinal(number) {
      var lastDigit = number % 10,
          last2Digits = number % 100;

      if (number === 0) {
        return number + '-';
      } else if (last2Digits === 0) {
        return number + '-';
      } else if (last2Digits > 10 && last2Digits < 20) {
        return number + '-';
      } else if (lastDigit === 1) {
        return number + '-';
      } else if (lastDigit === 2) {
        return number + '-';
      } else if (lastDigit === 7 || lastDigit === 8) {
        return number + '-';
      } else {
        return number + '-';
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return mk;
});

/***/ }),

/***/ 44744:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malayalam [ml]
//! author : Floyd Pink : https://github.com/floydpink
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ml = moment.defineLocale('ml', {
    months: '___________'.split('_'),
    monthsShort: '._._._.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm -',
      LTS: 'A h:mm:ss -',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm -',
      LLLL: 'dddd, D MMMM YYYY, A h:mm -'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    meridiemParse: /|| ||/i,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' && hour >= 4 || meridiem === ' ' || meridiem === '') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return ' ';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    }
  });
  return ml;
});

/***/ }),

/***/ 3296:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Mongolian [mn]
//! author : Javkhlantugs Nyamdorj : https://github.com/javkhaanj7
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function translate(number, withoutSuffix, key, isFuture) {
    switch (key) {
      case 's':
        return withoutSuffix ? ' ' : ' ';

      case 'ss':
        return number + (withoutSuffix ? ' ' : ' ');

      case 'm':
      case 'mm':
        return number + (withoutSuffix ? ' ' : ' ');

      case 'h':
      case 'hh':
        return number + (withoutSuffix ? ' ' : ' ');

      case 'd':
      case 'dd':
        return number + (withoutSuffix ? ' ' : ' ');

      case 'M':
      case 'MM':
        return number + (withoutSuffix ? ' ' : ' ');

      case 'y':
      case 'yy':
        return number + (withoutSuffix ? ' ' : ' ');

      default:
        return number;
    }
  }

  var mn = moment.defineLocale('mn', {
    months: ' _ _ _ _ _ _ _ _ _ _  _  '.split('_'),
    monthsShort: '1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 '.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY  MMMM D',
      LLL: 'YYYY  MMMM D HH:mm',
      LLLL: 'dddd, YYYY  MMMM D HH:mm'
    },
    meridiemParse: /|/i,
    isPM: function isPM(input) {
      return input === '';
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2} /,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + ' ';

        default:
          return number;
      }
    }
  });
  return mn;
});

/***/ }),

/***/ 62448:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Marathi [mr]
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };

  function relativeTimeMr(number, withoutSuffix, string, isFuture) {
    var output = '';

    if (withoutSuffix) {
      switch (string) {
        case 's':
          output = ' ';
          break;

        case 'ss':
          output = '%d ';
          break;

        case 'm':
          output = ' ';
          break;

        case 'mm':
          output = '%d ';
          break;

        case 'h':
          output = ' ';
          break;

        case 'hh':
          output = '%d ';
          break;

        case 'd':
          output = ' ';
          break;

        case 'dd':
          output = '%d ';
          break;

        case 'M':
          output = ' ';
          break;

        case 'MM':
          output = '%d ';
          break;

        case 'y':
          output = ' ';
          break;

        case 'yy':
          output = '%d ';
          break;
      }
    } else {
      switch (string) {
        case 's':
          output = ' ';
          break;

        case 'ss':
          output = '%d ';
          break;

        case 'm':
          output = ' ';
          break;

        case 'mm':
          output = '%d ';
          break;

        case 'h':
          output = ' ';
          break;

        case 'hh':
          output = '%d ';
          break;

        case 'd':
          output = ' ';
          break;

        case 'dd':
          output = '%d ';
          break;

        case 'M':
          output = ' ';
          break;

        case 'MM':
          output = '%d ';
          break;

        case 'y':
          output = ' ';
          break;

        case 'yy':
          output = '%d ';
          break;
      }
    }

    return output.replace(/%d/i, number);
  }

  var mr = moment.defineLocale('mr', {
    months: '___________'.split('_'),
    monthsShort: '._._._._._._._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: relativeTimeMr,
      ss: relativeTimeMr,
      m: relativeTimeMr,
      mm: relativeTimeMr,
      h: relativeTimeMr,
      hh: relativeTimeMr,
      d: relativeTimeMr,
      dd: relativeTimeMr,
      M: relativeTimeMr,
      MM: relativeTimeMr,
      y: relativeTimeMr,
      yy: relativeTimeMr
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour >= 12 ? hour : hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour >= 0 && hour < 6) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return mr;
});

/***/ }),

/***/ 23814:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms-my]
//! note : DEPRECATED, the correct one is [ms]
//! author : Weldan Jamili : https://github.com/weldan
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var msMy = moment.defineLocale('ms-my', {
    months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'tengahari') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'petang' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'tengahari';
      } else if (hours < 19) {
        return 'petang';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Esok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kelmarin pukul] LT',
      lastWeek: 'dddd [lepas pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lepas',
      s: 'beberapa saat',
      ss: '%d saat',
      m: 'seminit',
      mm: '%d minit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return msMy;
});

/***/ }),

/***/ 406:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms]
//! author : Weldan Jamili : https://github.com/weldan
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ms = moment.defineLocale('ms', {
    months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'tengahari') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'petang' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'tengahari';
      } else if (hours < 19) {
        return 'petang';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Esok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kelmarin pukul] LT',
      lastWeek: 'dddd [lepas pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lepas',
      s: 'beberapa saat',
      ss: '%d saat',
      m: 'seminit',
      mm: '%d minit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return ms;
});

/***/ }),

/***/ 28957:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maltese (Malta) [mt]
//! author : Alessandro Maruccia : https://github.com/alesma
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var mt = moment.defineLocale('mt', {
    months: 'Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru'.split('_'),
    monthsShort: 'Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di'.split('_'),
    weekdays: 'Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt'.split('_'),
    weekdaysShort: 'ad_Tne_Tli_Erb_am_im_Sib'.split('_'),
    weekdaysMin: 'a_Tn_Tl_Er_a_i_Si'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Illum fil-]LT',
      nextDay: '[Gada fil-]LT',
      nextWeek: 'dddd [fil-]LT',
      lastDay: '[Il-biera fil-]LT',
      lastWeek: 'dddd [li gadda] [fil-]LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'f %s',
      past: '%s ilu',
      s: 'ftit sekondi',
      ss: '%d sekondi',
      m: 'minuta',
      mm: '%d minuti',
      h: 'siega',
      hh: '%d siegat',
      d: 'urnata',
      dd: '%d ranet',
      M: 'xahar',
      MM: '%d xhur',
      y: 'sena',
      yy: '%d sni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return mt;
});

/***/ }),

/***/ 18940:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Burmese [my]
//! author : Squar team, mysquar.com
//! author : David Rossellat : https://github.com/gholadr
//! author : Tin Aung Lin : https://github.com/thanyawzinmin
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var my = moment.defineLocale('my', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[.] LT []',
      nextDay: '[] LT []',
      nextWeek: 'dddd LT []',
      lastDay: '[.] LT []',
      lastWeek: '[] dddd LT []',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s ',
      past: ' %s ',
      s: '.',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return my;
});

/***/ }),

/***/ 37127:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Norwegian Bokml [nb]
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga
//!           Stephen Ramthun : https://github.com/stephenramthun
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var nb = moment.defineLocale('nb', {
    months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort: 's._ma._ti._on._to._fr._l.'.split('_'),
    weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] HH:mm',
      LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[i dag kl.] LT',
      nextDay: '[i morgen kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[i gr kl.] LT',
      lastWeek: '[forrige] dddd [kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s siden',
      s: 'noen sekunder',
      ss: '%d sekunder',
      m: 'ett minutt',
      mm: '%d minutter',
      h: 'en time',
      hh: '%d timer',
      d: 'en dag',
      dd: '%d dager',
      w: 'en uke',
      ww: '%d uker',
      M: 'en mned',
      MM: '%d mneder',
      y: 'ett r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return nb;
});

/***/ }),

/***/ 43285:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nepalese [ne]
//! author : suvash : https://github.com/suvash
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var ne = moment.defineLocale('ne', {
    months: '___________'.split('_'),
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '._._._._._._.'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 3) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 16) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd[,] LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return ne;
});

/***/ }),

/***/ 77243:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch (Belgium) [nl-be]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
      monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_'),
      monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i],
      monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
  var nlBe = moment.defineLocale('nl-be', {
    months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[vandaag om] LT',
      nextDay: '[morgen om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[gisteren om] LT',
      lastWeek: '[afgelopen] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'over %s',
      past: '%s geleden',
      s: 'een paar seconden',
      ss: '%d seconden',
      m: 'n minuut',
      mm: '%d minuten',
      h: 'n uur',
      hh: '%d uur',
      d: 'n dag',
      dd: '%d dagen',
      M: 'n maand',
      MM: '%d maanden',
      y: 'n jaar',
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function ordinal(number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return nlBe;
});

/***/ }),

/***/ 75835:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch [nl]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
      monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_'),
      monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i],
      monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
  var nl = moment.defineLocale('nl', {
    months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort: function monthsShort(m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[vandaag om] LT',
      nextDay: '[morgen om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[gisteren om] LT',
      lastWeek: '[afgelopen] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'over %s',
      past: '%s geleden',
      s: 'een paar seconden',
      ss: '%d seconden',
      m: 'n minuut',
      mm: '%d minuten',
      h: 'n uur',
      hh: '%d uur',
      d: 'n dag',
      dd: '%d dagen',
      w: 'n week',
      ww: '%d weken',
      M: 'n maand',
      MM: '%d maanden',
      y: 'n jaar',
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function ordinal(number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return nl;
});

/***/ }),

/***/ 32802:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nynorsk [nn]
//! authors : https://github.com/mechuwind
//!           Stephen Ramthun : https://github.com/stephenramthun
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var nn = moment.defineLocale('nn', {
    months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
    weekdaysShort: 'su._m._ty._on._to._fr._lau.'.split('_'),
    weekdaysMin: 'su_m_ty_on_to_fr_la'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] H:mm',
      LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[I dag klokka] LT',
      nextDay: '[I morgon klokka] LT',
      nextWeek: 'dddd [klokka] LT',
      lastDay: '[I gr klokka] LT',
      lastWeek: '[Fregande] dddd [klokka] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s sidan',
      s: 'nokre sekund',
      ss: '%d sekund',
      m: 'eit minutt',
      mm: '%d minutt',
      h: 'ein time',
      hh: '%d timar',
      d: 'ein dag',
      dd: '%d dagar',
      w: 'ei veke',
      ww: '%d veker',
      M: 'ein mnad',
      MM: '%d mnader',
      y: 'eit r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return nn;
});

/***/ }),

/***/ 87282:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Occitan, lengadocian dialecte [oc-lnc]
//! author : Quentin PAGS : https://github.com/Quenty31
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ocLnc = moment.defineLocale('oc-lnc', {
    months: {
      standalone: 'genir_febrir_mar_abril_mai_junh_julhet_agost_setembre_octbre_novembre_decembre'.split('_'),
      format: "de genir_de febrir_de mar_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octbre_de novembre_de decembre".split('_'),
      isFormat: /D[oD]?(\s)+MMMM/
    },
    monthsShort: 'gen._febr._mar_abr._mai_junh_julh._ago._set._oct._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimenge_diluns_dimars_dimcres_dijus_divendres_dissabte'.split('_'),
    weekdaysShort: 'dg._dl._dm._dc._dj._dv._ds.'.split('_'),
    weekdaysMin: 'dg_dl_dm_dc_dj_dv_ds'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [de] YYYY',
      ll: 'D MMM YYYY',
      LLL: 'D MMMM [de] YYYY [a] H:mm',
      lll: 'D MMM YYYY, H:mm',
      LLLL: 'dddd D MMMM [de] YYYY [a] H:mm',
      llll: 'ddd D MMM YYYY, H:mm'
    },
    calendar: {
      sameDay: '[ui a] LT',
      nextDay: '[deman a] LT',
      nextWeek: 'dddd [a] LT',
      lastDay: '[ir a] LT',
      lastWeek: 'dddd [passat a] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: "d'aqu %s",
      past: 'fa %s',
      s: 'unas segondas',
      ss: '%d segondas',
      m: 'una minuta',
      mm: '%d minutas',
      h: 'una ora',
      hh: '%d oras',
      d: 'un jorn',
      dd: '%d jorns',
      M: 'un mes',
      MM: '%d meses',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
    ordinal: function ordinal(number, period) {
      var output = number === 1 ? 'r' : number === 2 ? 'n' : number === 3 ? 'r' : number === 4 ? 't' : '';

      if (period === 'w' || period === 'W') {
        output = 'a';
      }

      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4
    }
  });
  return ocLnc;
});

/***/ }),

/***/ 53424:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Punjabi (India) [pa-in]
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var paIn = moment.defineLocale('pa-in', {
    // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return paIn;
});

/***/ }),

/***/ 83696:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Polish [pl]
//! author : Rafal Hirsz : https://github.com/evoL
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
      monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_'),
      monthsParse = [/^sty/i, /^lut/i, /^mar/i, /^kwi/i, /^maj/i, /^cze/i, /^lip/i, /^sie/i, /^wrz/i, /^pa/i, /^lis/i, /^gru/i];

  function plural(n) {
    return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
  }

  function translate(number, withoutSuffix, key) {
    var result = number + ' ';

    switch (key) {
      case 'ss':
        return result + (plural(number) ? 'sekundy' : 'sekund');

      case 'm':
        return withoutSuffix ? 'minuta' : 'minut';

      case 'mm':
        return result + (plural(number) ? 'minuty' : 'minut');

      case 'h':
        return withoutSuffix ? 'godzina' : 'godzin';

      case 'hh':
        return result + (plural(number) ? 'godziny' : 'godzin');

      case 'ww':
        return result + (plural(number) ? 'tygodnie' : 'tygodni');

      case 'MM':
        return result + (plural(number) ? 'miesice' : 'miesicy');

      case 'yy':
        return result + (plural(number) ? 'lata' : 'lat');
    }
  }

  var pl = moment.defineLocale('pl', {
    months: function months(momentToFormat, format) {
      if (!momentToFormat) {
        return monthsNominative;
      } else if (/D MMMM/.test(format)) {
        return monthsSubjective[momentToFormat.month()];
      } else {
        return monthsNominative[momentToFormat.month()];
      }
    },
    monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
    weekdaysShort: 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
    weekdaysMin: 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Dzi o] LT',
      nextDay: '[Jutro o] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[W niedziel o] LT';

          case 2:
            return '[We wtorek o] LT';

          case 3:
            return '[W rod o] LT';

          case 6:
            return '[W sobot o] LT';

          default:
            return '[W] dddd [o] LT';
        }
      },
      lastDay: '[Wczoraj o] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[W zesz niedziel o] LT';

          case 3:
            return '[W zesz rod o] LT';

          case 6:
            return '[W zesz sobot o] LT';

          default:
            return '[W zeszy] dddd [o] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: '%s temu',
      s: 'kilka sekund',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: '1 dzie',
      dd: '%d dni',
      w: 'tydzie',
      ww: translate,
      M: 'miesic',
      MM: translate,
      y: 'rok',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return pl;
});

/***/ }),

/***/ 61657:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ptBr = moment.defineLocale('pt-br', {
    months: 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
    monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
    weekdays: 'domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado'.split('_'),
    weekdaysShort: 'dom_seg_ter_qua_qui_sex_sb'.split('_'),
    weekdaysMin: 'do_2_3_4_5_6_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY [s] HH:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
    },
    calendar: {
      sameDay: '[Hoje s] LT',
      nextDay: '[Amanh s] LT',
      nextWeek: 'dddd [s] LT',
      lastDay: '[Ontem s] LT',
      lastWeek: function lastWeek() {
        return this.day() === 0 || this.day() === 6 ? '[ltimo] dddd [s] LT' // Saturday + Sunday
        : '[ltima] dddd [s] LT'; // Monday - Friday
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'em %s',
      past: 'h %s',
      s: 'poucos segundos',
      ss: '%d segundos',
      m: 'um minuto',
      mm: '%d minutos',
      h: 'uma hora',
      hh: '%d horas',
      d: 'um dia',
      dd: '%d dias',
      M: 'um ms',
      MM: '%d meses',
      y: 'um ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    invalidDate: 'Data invlida'
  });
  return ptBr;
});

/***/ }),

/***/ 61551:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese [pt]
//! author : Jefferson : https://github.com/jalex79
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var pt = moment.defineLocale('pt', {
    months: 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
    monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
    weekdays: 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
    weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
    weekdaysMin: 'Do_2_3_4_5_6_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY HH:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hoje s] LT',
      nextDay: '[Amanh s] LT',
      nextWeek: 'dddd [s] LT',
      lastDay: '[Ontem s] LT',
      lastWeek: function lastWeek() {
        return this.day() === 0 || this.day() === 6 ? '[ltimo] dddd [s] LT' // Saturday + Sunday
        : '[ltima] dddd [s] LT'; // Monday - Friday
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'em %s',
      past: 'h %s',
      s: 'segundos',
      ss: '%d segundos',
      m: 'um minuto',
      mm: '%d minutos',
      h: 'uma hora',
      hh: '%d horas',
      d: 'um dia',
      dd: '%d dias',
      w: 'uma semana',
      ww: '%d semanas',
      M: 'um ms',
      MM: '%d meses',
      y: 'um ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return pt;
});

/***/ }),

/***/ 29199:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Romanian [ro]
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly
//! author : Emanuel Cepoi : https://github.com/cepem
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      ss: 'secunde',
      mm: 'minute',
      hh: 'ore',
      dd: 'zile',
      ww: 'sptmni',
      MM: 'luni',
      yy: 'ani'
    },
        separator = ' ';

    if (number % 100 >= 20 || number >= 100 && number % 100 === 0) {
      separator = ' de ';
    }

    return number + separator + format[key];
  }

  var ro = moment.defineLocale('ro', {
    months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
    monthsShort: 'ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
    weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
    weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[azi la] LT',
      nextDay: '[mine la] LT',
      nextWeek: 'dddd [la] LT',
      lastDay: '[ieri la] LT',
      lastWeek: '[fosta] dddd [la] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'peste %s',
      past: '%s n urm',
      s: 'cteva secunde',
      ss: relativeTimeWithPlural,
      m: 'un minut',
      mm: relativeTimeWithPlural,
      h: 'o or',
      hh: relativeTimeWithPlural,
      d: 'o zi',
      dd: relativeTimeWithPlural,
      w: 'o sptmn',
      ww: relativeTimeWithPlural,
      M: 'o lun',
      MM: relativeTimeWithPlural,
      y: 'un an',
      yy: relativeTimeWithPlural
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return ro;
});

/***/ }),

/***/ 88217:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Russian [ru]
//! author : Viktorminator : https://github.com/Viktorminator
//! author : Menelion Elensle : https://github.com/Oire
//! author :   : https://github.com/socketpair
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      ss: withoutSuffix ? '__' : '__',
      mm: withoutSuffix ? '__' : '__',
      hh: '__',
      dd: '__',
      ww: '__',
      MM: '__',
      yy: '__'
    };

    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }

  var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]; // http://new.gramota.ru/spravka/rules/139-prop :  103
  //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
  // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753

  var ru = moment.defineLocale('ru', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: {
      //  CLDR  "."  ".",       ?
      format: '._._._.____._._._._.'.split('_'),
      standalone: '._.__.____._._._._.'.split('_')
    },
    weekdays: {
      standalone: '______'.split('_'),
      format: '______'.split('_'),
      isFormat: /\[ ?[] ?(?:||)? ?] ?dddd/
    },
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    //    ,   ,  ,  4 ,      
    monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
    //  
    monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
    //    
    monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
    // ,     
    monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., H:mm',
      LLLL: 'dddd, D MMMM YYYY ., H:mm'
    },
    calendar: {
      sameDay: '[, ] LT',
      nextDay: '[, ] LT',
      lastDay: '[, ] LT',
      nextWeek: function nextWeek(now) {
        if (now.week() !== this.week()) {
          switch (this.day()) {
            case 0:
              return '[ ] dddd, [] LT';

            case 1:
            case 2:
            case 4:
              return '[ ] dddd, [] LT';

            case 3:
            case 5:
            case 6:
              return '[ ] dddd, [] LT';
          }
        } else {
          if (this.day() === 2) {
            return '[] dddd, [] LT';
          } else {
            return '[] dddd, [] LT';
          }
        }
      },
      lastWeek: function lastWeek(now) {
        if (now.week() !== this.week()) {
          switch (this.day()) {
            case 0:
              return '[ ] dddd, [] LT';

            case 1:
            case 2:
            case 4:
              return '[ ] dddd, [] LT';

            case 3:
            case 5:
            case 6:
              return '[ ] dddd, [] LT';
          }
        } else {
          if (this.day() === 2) {
            return '[] dddd, [] LT';
          } else {
            return '[] dddd, [] LT';
          }
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: relativeTimeWithPlural,
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: '',
      hh: relativeTimeWithPlural,
      d: '',
      dd: relativeTimeWithPlural,
      w: '',
      ww: relativeTimeWithPlural,
      M: '',
      MM: relativeTimeWithPlural,
      y: '',
      yy: relativeTimeWithPlural
    },
    meridiemParse: /|||/i,
    isPM: function isPM(input) {
      return /^(|)$/.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
          return number + '-';

        case 'D':
          return number + '-';

        case 'w':
        case 'W':
          return number + '-';

        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ru;
});

/***/ }),

/***/ 14817:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sindhi [sd]
//! author : Narain Sagar : https://github.com/narainsagar
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = ['', '', '', '', '', '', '', '', '', '', '', ''],
      days = ['', '', '', '', '', '', ''];
  var sd = moment.defineLocale('sd', {
    months: months,
    monthsShort: months,
    weekdays: days,
    weekdaysShort: days,
    weekdaysMin: days,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      }

      return '';
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd [  ] LT',
      lastDay: '[] LT',
      lastWeek: '[ ] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return sd;
});

/***/ }),

/***/ 91403:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Northern Sami [se]
//! authors : Brd Rolstad Henriksen : https://github.com/karamell
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var se = moment.defineLocale('se', {
    months: 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
    monthsShort: 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
    weekdays: 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
    weekdaysShort: 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
    weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'MMMM D. [b.] YYYY',
      LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
      LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
    },
    calendar: {
      sameDay: '[otne ti] LT',
      nextDay: '[ihttin ti] LT',
      nextWeek: 'dddd [ti] LT',
      lastDay: '[ikte ti] LT',
      lastWeek: '[ovddit] dddd [ti] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s geaes',
      past: 'mait %s',
      s: 'moadde sekunddat',
      ss: '%d sekunddat',
      m: 'okta minuhta',
      mm: '%d minuhtat',
      h: 'okta diimmu',
      hh: '%d diimmut',
      d: 'okta beaivi',
      dd: '%d beaivvit',
      M: 'okta mnnu',
      MM: '%d mnut',
      y: 'okta jahki',
      yy: '%d jagit'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return se;
});

/***/ }),

/***/ 18446:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sinhalese [si]
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  /*jshint -W100*/

  var si = moment.defineLocale('si', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'a h:mm',
      LTS: 'a h:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYY MMMM D',
      LLL: 'YYYY MMMM D, a h:mm',
      LLLL: 'YYYY MMMM D [] dddd, a h:mm:ss'
    },
    calendar: {
      sameDay: '[] LT[]',
      nextDay: '[] LT[]',
      nextWeek: 'dddd LT[]',
      lastDay: '[] LT[]',
      lastWeek: '[] dddd LT[]',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s ',
      s: ' ',
      ss: ' %d',
      m: '',
      mm: ' %d',
      h: '',
      hh: ' %d',
      d: '',
      dd: ' %d',
      M: '',
      MM: ' %d',
      y: '',
      yy: ' %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2} /,
    ordinal: function ordinal(number) {
      return number + ' ';
    },
    meridiemParse: / | |.|../,
    isPM: function isPM(input) {
      return input === '..' || input === ' ';
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? '..' : ' ';
      } else {
        return isLower ? '..' : ' ';
      }
    }
  });
  return si;
});

/***/ }),

/***/ 21098:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovak [sk]
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
      monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');

  function plural(n) {
    return n > 1 && n < 5;
  }

  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    switch (key) {
      case 's':
        // a few seconds / in a few seconds / a few seconds ago
        return withoutSuffix || isFuture ? 'pr seknd' : 'pr sekundami';

      case 'ss':
        // 9 seconds / in 9 seconds / 9 seconds ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'sekundy' : 'seknd');
        } else {
          return result + 'sekundami';
        }

      case 'm':
        // a minute / in a minute / a minute ago
        return withoutSuffix ? 'minta' : isFuture ? 'mintu' : 'mintou';

      case 'mm':
        // 9 minutes / in 9 minutes / 9 minutes ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'minty' : 'mint');
        } else {
          return result + 'mintami';
        }

      case 'h':
        // an hour / in an hour / an hour ago
        return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';

      case 'hh':
        // 9 hours / in 9 hours / 9 hours ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'hodiny' : 'hodn');
        } else {
          return result + 'hodinami';
        }

      case 'd':
        // a day / in a day / a day ago
        return withoutSuffix || isFuture ? 'de' : 'dom';

      case 'dd':
        // 9 days / in 9 days / 9 days ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'dni' : 'dn');
        } else {
          return result + 'dami';
        }

      case 'M':
        // a month / in a month / a month ago
        return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';

      case 'MM':
        // 9 months / in 9 months / 9 months ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'mesiace' : 'mesiacov');
        } else {
          return result + 'mesiacmi';
        }

      case 'y':
        // a year / in a year / a year ago
        return withoutSuffix || isFuture ? 'rok' : 'rokom';

      case 'yy':
        // 9 years / in 9 years / 9 years ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'roky' : 'rokov');
        } else {
          return result + 'rokmi';
        }

    }
  }

  var sk = moment.defineLocale('sk', {
    months: months,
    monthsShort: monthsShort,
    weekdays: 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
    weekdaysShort: 'ne_po_ut_st_t_pi_so'.split('_'),
    weekdaysMin: 'ne_po_ut_st_t_pi_so'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[dnes o] LT',
      nextDay: '[zajtra o] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[v nedeu o] LT';

          case 1:
          case 2:
            return '[v] dddd [o] LT';

          case 3:
            return '[v stredu o] LT';

          case 4:
            return '[vo tvrtok o] LT';

          case 5:
            return '[v piatok o] LT';

          case 6:
            return '[v sobotu o] LT';
        }
      },
      lastDay: '[vera o] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[minul nedeu o] LT';

          case 1:
          case 2:
            return '[minul] dddd [o] LT';

          case 3:
            return '[minul stredu o] LT';

          case 4:
          case 5:
            return '[minul] dddd [o] LT';

          case 6:
            return '[minul sobotu o] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'pred %s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return sk;
});

/***/ }),

/***/ 48805:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovenian [sl]
//! author : Robert Sedovek : https://github.com/sedovsek
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    switch (key) {
      case 's':
        return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';

      case 'ss':
        if (number === 1) {
          result += withoutSuffix ? 'sekundo' : 'sekundi';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
        } else {
          result += 'sekund';
        }

        return result;

      case 'm':
        return withoutSuffix ? 'ena minuta' : 'eno minuto';

      case 'mm':
        if (number === 1) {
          result += withoutSuffix ? 'minuta' : 'minuto';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'minute' : 'minutami';
        } else {
          result += withoutSuffix || isFuture ? 'minut' : 'minutami';
        }

        return result;

      case 'h':
        return withoutSuffix ? 'ena ura' : 'eno uro';

      case 'hh':
        if (number === 1) {
          result += withoutSuffix ? 'ura' : 'uro';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'uri' : 'urama';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'ure' : 'urami';
        } else {
          result += withoutSuffix || isFuture ? 'ur' : 'urami';
        }

        return result;

      case 'd':
        return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';

      case 'dd':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'dan' : 'dnem';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
        } else {
          result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
        }

        return result;

      case 'M':
        return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';

      case 'MM':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
        } else {
          result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
        }

        return result;

      case 'y':
        return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';

      case 'yy':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'leto' : 'letom';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'leti' : 'letoma';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'leta' : 'leti';
        } else {
          result += withoutSuffix || isFuture ? 'let' : 'leti';
        }

        return result;
    }
  }

  var sl = moment.defineLocale('sl', {
    months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
    weekdaysShort: 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
    weekdaysMin: 'ne_po_to_sr_e_pe_so'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD. MM. YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danes ob] LT',
      nextDay: '[jutri ob] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[v] [nedeljo] [ob] LT';

          case 3:
            return '[v] [sredo] [ob] LT';

          case 6:
            return '[v] [soboto] [ob] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[v] dddd [ob] LT';
        }
      },
      lastDay: '[veraj ob] LT',
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
            return '[prejnjo] [nedeljo] [ob] LT';

          case 3:
            return '[prejnjo] [sredo] [ob] LT';

          case 6:
            return '[prejnjo] [soboto] [ob] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[prejnji] dddd [ob] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ez %s',
      past: 'pred %s',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return sl;
});

/***/ }),

/***/ 47718:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Albanian [sq]
//! author : Flakrim Ismani : https://github.com/flakerimi
//! author : Menelion Elensle : https://github.com/Oire
//! author : Oerd Cukalla : https://github.com/oerd
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var sq = moment.defineLocale('sq', {
    months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
    monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
    weekdays: 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
    weekdaysShort: 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
    weekdaysMin: 'D_H_Ma_M_E_P_Sh'.split('_'),
    weekdaysParseExact: true,
    meridiemParse: /PD|MD/,
    isPM: function isPM(input) {
      return input.charAt(0) === 'M';
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      return hours < 12 ? 'PD' : 'MD';
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Sot n] LT',
      nextDay: '[Nesr n] LT',
      nextWeek: 'dddd [n] LT',
      lastDay: '[Dje n] LT',
      lastWeek: 'dddd [e kaluar n] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'n %s',
      past: '%s m par',
      s: 'disa sekonda',
      ss: '%d sekonda',
      m: 'nj minut',
      mm: '%d minuta',
      h: 'nj or',
      hh: '%d or',
      d: 'nj dit',
      dd: '%d dit',
      M: 'nj muaj',
      MM: '%d muaj',
      y: 'nj vit',
      yy: '%d vite'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return sq;
});

/***/ }),

/***/ 86925:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian Cyrillic [sr-cyrl]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j
//! author : Stefan Crnjakovi <stefan@hotmail.rs> : https://github.com/crnjakovic
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var translator = {
    words: {
      //Different grammatical cases
      ss: ['', '', ''],
      m: [' ', ' '],
      mm: ['', '', ''],
      h: [' ', ' '],
      hh: ['', '', ''],
      dd: ['', '', ''],
      MM: ['', '', ''],
      yy: ['', '', '']
    },
    correctGrammaticalCase: function correctGrammaticalCase(number, wordKey) {
      return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
    },
    translate: function translate(number, withoutSuffix, key) {
      var wordKey = translator.words[key];

      if (key.length === 1) {
        return withoutSuffix ? wordKey[0] : wordKey[1];
      } else {
        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
      }
    }
  };
  var srCyrl = moment.defineLocale('sr-cyrl', {
    months: '___________'.split('_'),
    monthsShort: '._._._.____._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D. M. YYYY.',
      LL: 'D. MMMM YYYY.',
      LLL: 'D. MMMM YYYY. H:mm',
      LLLL: 'dddd, D. MMMM YYYY. H:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[] [] [] LT';

          case 3:
            return '[] [] [] LT';

          case 6:
            return '[] [] [] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[] dddd [] LT';
        }
      },
      lastDay: '[ ] LT',
      lastWeek: function lastWeek() {
        var lastWeekDays = ['[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: '',
      dd: translator.translate,
      M: '',
      MM: translator.translate,
      y: '',
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1st is the first week of the year.

    }
  });
  return srCyrl;
});

/***/ }),

/***/ 52003:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian [sr]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j
//! author : Stefan Crnjakovi <stefan@hotmail.rs> : https://github.com/crnjakovic
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var translator = {
    words: {
      //Different grammatical cases
      ss: ['sekunda', 'sekunde', 'sekundi'],
      m: ['jedan minut', 'jedne minute'],
      mm: ['minut', 'minute', 'minuta'],
      h: ['jedan sat', 'jednog sata'],
      hh: ['sat', 'sata', 'sati'],
      dd: ['dan', 'dana', 'dana'],
      MM: ['mesec', 'meseca', 'meseci'],
      yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function correctGrammaticalCase(number, wordKey) {
      return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
    },
    translate: function translate(number, withoutSuffix, key) {
      var wordKey = translator.words[key];

      if (key.length === 1) {
        return withoutSuffix ? wordKey[0] : wordKey[1];
      } else {
        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
      }
    }
  };
  var sr = moment.defineLocale('sr', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D. M. YYYY.',
      LL: 'D. MMMM YYYY.',
      LLL: 'D. MMMM YYYY. H:mm',
      LLLL: 'dddd, D. MMMM YYYY. H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function nextWeek() {
        switch (this.day()) {
          case 0:
            return '[u] [nedelju] [u] LT';

          case 3:
            return '[u] [sredu] [u] LT';

          case 6:
            return '[u] [subotu] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[jue u] LT',
      lastWeek: function lastWeek() {
        var lastWeekDays = ['[prole] [nedelje] [u] LT', '[prolog] [ponedeljka] [u] LT', '[prolog] [utorka] [u] LT', '[prole] [srede] [u] LT', '[prolog] [etvrtka] [u] LT', '[prolog] [petka] [u] LT', '[prole] [subote] [u] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'pre %s',
      s: 'nekoliko sekundi',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: 'dan',
      dd: translator.translate,
      M: 'mesec',
      MM: translator.translate,
      y: 'godinu',
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return sr;
});

/***/ }),

/***/ 83707:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : siSwati [ss]
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ss = moment.defineLocale('ss', {
    months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
    monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
    weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
    weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
    weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Namuhla nga] LT',
      nextDay: '[Kusasa nga] LT',
      nextWeek: 'dddd [nga] LT',
      lastDay: '[Itolo nga] LT',
      lastWeek: 'dddd [leliphelile] [nga] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'nga %s',
      past: 'wenteka nga %s',
      s: 'emizuzwana lomcane',
      ss: '%d mzuzwana',
      m: 'umzuzu',
      mm: '%d emizuzu',
      h: 'lihora',
      hh: '%d emahora',
      d: 'lilanga',
      dd: '%d emalanga',
      M: 'inyanga',
      MM: '%d tinyanga',
      y: 'umnyaka',
      yy: '%d iminyaka'
    },
    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 11) {
        return 'ekuseni';
      } else if (hours < 15) {
        return 'emini';
      } else if (hours < 19) {
        return 'entsambama';
      } else {
        return 'ebusuku';
      }
    },
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'ekuseni') {
        return hour;
      } else if (meridiem === 'emini') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
        if (hour === 0) {
          return 0;
        }

        return hour + 12;
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ss;
});

/***/ }),

/***/ 80643:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swedish [sv]
//! author : Jens Alm : https://github.com/ulmus
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var sv = moment.defineLocale('sv', {
    months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort: 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
    weekdaysMin: 's_m_ti_on_to_fr_l'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [kl.] HH:mm',
      LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Idag] LT',
      nextDay: '[Imorgon] LT',
      lastDay: '[Igr] LT',
      nextWeek: '[P] dddd LT',
      lastWeek: '[I] dddd[s] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: 'fr %s sedan',
      s: 'ngra sekunder',
      ss: '%d sekunder',
      m: 'en minut',
      mm: '%d minuter',
      h: 'en timme',
      hh: '%d timmar',
      d: 'en dag',
      dd: '%d dagar',
      M: 'en mnad',
      MM: '%d mnader',
      y: 'ett r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? ':e' : b === 1 ? ':a' : b === 2 ? ':a' : b === 3 ? ':e' : ':e';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return sv;
});

/***/ }),

/***/ 46250:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swahili [sw]
//! author : Fahad Kassim : https://github.com/fadsel
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var sw = moment.defineLocale('sw', {
    months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
    weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
    weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'hh:mm A',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[leo saa] LT',
      nextDay: '[kesho saa] LT',
      nextWeek: '[wiki ijayo] dddd [saat] LT',
      lastDay: '[jana] LT',
      lastWeek: '[wiki iliyopita] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s baadaye',
      past: 'tokea %s',
      s: 'hivi punde',
      ss: 'sekunde %d',
      m: 'dakika moja',
      mm: 'dakika %d',
      h: 'saa limoja',
      hh: 'masaa %d',
      d: 'siku moja',
      dd: 'siku %d',
      M: 'mwezi mmoja',
      MM: 'miezi %d',
      y: 'mwaka mmoja',
      yy: 'miaka %d'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return sw;
});

/***/ }),

/***/ 52550:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tamil [ta]
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var ta = moment.defineLocale('ta', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, HH:mm',
      LLLL: 'dddd, D MMMM YYYY, HH:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[ ] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '  ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: '  ',
      hh: '%d  ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function ordinal(number) {
      return number + '';
    },
    preparse: function preparse(string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function postformat(string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // refer http://ta.wikipedia.org/s/1er1
    meridiemParse: /|||||/,
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 2) {
        return ' ';
      } else if (hour < 6) {
        return ' '; // 
      } else if (hour < 10) {
        return ' '; // 
      } else if (hour < 14) {
        return ' '; // 
      } else if (hour < 18) {
        return ' '; // 
      } else if (hour < 22) {
        return ' '; // 
      } else {
        return ' ';
      }
    },
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 2 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else {
        return hour + 12;
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return ta;
});

/***/ }),

/***/ 5558:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Telugu [te]
//! author : Krishna Chaitanya Thota : https://github.com/kcthota
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var te = moment.defineLocale('te', {
    months: '___________'.split('_'),
    monthsShort: '._.__.____._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return te;
});

/***/ }),

/***/ 63503:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tetun Dili (East Timor) [tet]
//! author : Joshua Brooks : https://github.com/joshbrooks
//! author : Onorio De J. Afonso : https://github.com/marobo
//! author : Sonia Simoes : https://github.com/soniasimoes
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var tet = moment.defineLocale('tet', {
    months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
    monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
    weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
    weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
    weekdaysMin: 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Ohin iha] LT',
      nextDay: '[Aban iha] LT',
      nextWeek: 'dddd [iha] LT',
      lastDay: '[Horiseik iha] LT',
      lastWeek: 'dddd [semana kotuk] [iha] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'iha %s',
      past: '%s liuba',
      s: 'segundu balun',
      ss: 'segundu %d',
      m: 'minutu ida',
      mm: 'minutu %d',
      h: 'oras ida',
      hh: 'oras %d',
      d: 'loron ida',
      dd: 'loron %d',
      M: 'fulan ida',
      MM: 'fulan %d',
      y: 'tinan ida',
      yy: 'tinan %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return tet;
});

/***/ }),

/***/ 87711:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tajik [tg]
//! author : Orif N. Jr. : https://github.com/orif-jr
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    12: '-',
    13: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
  };
  var tg = moment.defineLocale('tg', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      lastDay: '[ ] LT',
      nextWeek: 'dddd[] [  ] LT',
      lastWeek: 'dddd[] [  ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    meridiemParse: /|||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 11) {
        return '';
      } else if (hour < 16) {
        return '';
      } else if (hour < 19) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function ordinal(number) {
      var a = number % 10,
          b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1th is the first week of the year.

    }
  });
  return tg;
});

/***/ }),

/***/ 95626:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Thai [th]
//! author : Kridsada Thanabulpong : https://github.com/sirn
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var th = moment.defineLocale('th', {
    months: '___________'.split('_'),
    monthsShort: '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    // yes, three characters difference
    weekdaysMin: '._._._._._._.'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY  H:mm',
      LLLL: 'dddd D MMMM YYYY  H:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return input === '';
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd[ ] LT',
      lastDay: '[ ] LT',
      lastWeek: '[]dddd[ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      w: '1 ',
      ww: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return th;
});

/***/ }),

/***/ 60727:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Turkmen [tk]
//! author : Atamyrat Abdyrahmanov : https://github.com/atamyratabdy
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var suffixes = {
    1: "'inji",
    5: "'inji",
    8: "'inji",
    70: "'inji",
    80: "'inji",
    2: "'nji",
    7: "'nji",
    20: "'nji",
    50: "'nji",
    3: "'nji",
    4: "'nji",
    100: "'nji",
    6: "'njy",
    9: "'unjy",
    10: "'unjy",
    30: "'unjy",
    60: "'ynjy",
    90: "'ynjy"
  };
  var tk = moment.defineLocale('tk', {
    months: 'anwar_Fewral_Mart_Aprel_Ma_Iun_Iul_Awgust_Sentabr_Oktabr_Noabr_Dekabr'.split('_'),
    monthsShort: 'an_Few_Mar_Apr_Ma_In_Il_Awg_Sen_Okt_No_Dek'.split('_'),
    weekdays: 'ekenbe_Duenbe_Sienbe_arenbe_Penenbe_Anna_enbe'.split('_'),
    weekdaysShort: 'ek_Du_Si_ar_Pen_Ann_en'.split('_'),
    weekdaysMin: 'k_D_S_r_Pn_An_n'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugn sagat] LT',
      nextDay: '[ertir sagat] LT',
      nextWeek: '[indiki] dddd [sagat] LT',
      lastDay: '[dn] LT',
      lastWeek: '[geen] dddd [sagat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s so',
      past: '%s ',
      s: 'birne sekunt',
      m: 'bir minut',
      mm: '%d minut',
      h: 'bir sagat',
      hh: '%d sagat',
      d: 'bir gn',
      dd: '%d gn',
      M: 'bir a',
      MM: '%d a',
      y: 'bir yl',
      yy: '%d yl'
    },
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'Do':
        case 'DD':
          return number;

        default:
          if (number === 0) {
            // special case for zero
            return number + "'unjy";
          }

          var a = number % 10,
              b = number % 100 - a,
              c = number >= 100 ? 100 : null;
          return number + (suffixes[a] || suffixes[b] || suffixes[c]);
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return tk;
});

/***/ }),

/***/ 97568:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tagalog (Philippines) [tl-ph]
//! author : Dan Hagman : https://github.com/hagmandan
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var tlPh = moment.defineLocale('tl-ph', {
    months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
    monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
    weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
    weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
    weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'MM/D/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY HH:mm',
      LLLL: 'dddd, MMMM DD, YYYY HH:mm'
    },
    calendar: {
      sameDay: 'LT [ngayong araw]',
      nextDay: '[Bukas ng] LT',
      nextWeek: 'LT [sa susunod na] dddd',
      lastDay: 'LT [kahapon]',
      lastWeek: 'LT [noong nakaraang] dddd',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'sa loob ng %s',
      past: '%s ang nakalipas',
      s: 'ilang segundo',
      ss: '%d segundo',
      m: 'isang minuto',
      mm: '%d minuto',
      h: 'isang oras',
      hh: '%d oras',
      d: 'isang araw',
      dd: '%d araw',
      M: 'isang buwan',
      MM: '%d buwan',
      y: 'isang taon',
      yy: '%d taon'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function ordinal(number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return tlPh;
});

/***/ }),

/***/ 71682:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Klingon [tlh]
//! author : Dominika Kruk : https://github.com/amaranthrose
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

  function translateFuture(output) {
    var time = output;
    time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'leS' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'waQ' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'nem' : time + ' pIq';
    return time;
  }

  function translatePast(output) {
    var time = output;
    time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'Hu' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'wen' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'ben' : time + ' ret';
    return time;
  }

  function translate(number, withoutSuffix, string, isFuture) {
    var numberNoun = numberAsNoun(number);

    switch (string) {
      case 'ss':
        return numberNoun + ' lup';

      case 'mm':
        return numberNoun + ' tup';

      case 'hh':
        return numberNoun + ' rep';

      case 'dd':
        return numberNoun + ' jaj';

      case 'MM':
        return numberNoun + ' jar';

      case 'yy':
        return numberNoun + ' DIS';
    }
  }

  function numberAsNoun(number) {
    var hundred = Math.floor(number % 1000 / 100),
        ten = Math.floor(number % 100 / 10),
        one = number % 10,
        word = '';

    if (hundred > 0) {
      word += numbersNouns[hundred] + 'vatlh';
    }

    if (ten > 0) {
      word += (word !== '' ? ' ' : '') + numbersNouns[ten] + 'maH';
    }

    if (one > 0) {
      word += (word !== '' ? ' ' : '') + numbersNouns[one];
    }

    return word === '' ? 'pagh' : word;
  }

  var tlh = moment.defineLocale('tlh', {
    months: 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
    monthsShort: 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
    monthsParseExact: true,
    weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[DaHjaj] LT',
      nextDay: '[waleS] LT',
      nextWeek: 'LLL',
      lastDay: '[waHu] LT',
      lastWeek: 'LLL',
      sameElse: 'L'
    },
    relativeTime: {
      future: translateFuture,
      past: translatePast,
      s: 'puS lup',
      ss: translate,
      m: 'wa tup',
      mm: translate,
      h: 'wa rep',
      hh: translate,
      d: 'wa jaj',
      dd: translate,
      M: 'wa jar',
      MM: translate,
      y: 'wa DIS',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return tlh;
});

/***/ }),

/***/ 53538:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Turkish [tr]
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiit Kaya: https://github.com/BYK
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var suffixes = {
    1: "'inci",
    5: "'inci",
    8: "'inci",
    70: "'inci",
    80: "'inci",
    2: "'nci",
    7: "'nci",
    20: "'nci",
    50: "'nci",
    3: "'nc",
    4: "'nc",
    100: "'nc",
    6: "'nc",
    9: "'uncu",
    10: "'uncu",
    30: "'uncu",
    60: "'nc",
    90: "'nc"
  };
  var tr = moment.defineLocale('tr', {
    months: 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
    monthsShort: 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
    weekdays: 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
    weekdaysShort: 'Paz_Pts_Sal_ar_Per_Cum_Cts'.split('_'),
    weekdaysMin: 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? '' : '';
      } else {
        return isLower ? 's' : 'S';
      }
    },
    meridiemParse: /||s|S/,
    isPM: function isPM(input) {
      return input === 's' || input === 'S';
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugn saat] LT',
      nextDay: '[yarn saat] LT',
      nextWeek: '[gelecek] dddd [saat] LT',
      lastDay: '[dn] LT',
      lastWeek: '[geen] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s sonra',
      past: '%s nce',
      s: 'birka saniye',
      ss: '%d saniye',
      m: 'bir dakika',
      mm: '%d dakika',
      h: 'bir saat',
      hh: '%d saat',
      d: 'bir gn',
      dd: '%d gn',
      w: 'bir hafta',
      ww: '%d hafta',
      M: 'bir ay',
      MM: '%d ay',
      y: 'bir yl',
      yy: '%d yl'
    },
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'Do':
        case 'DD':
          return number;

        default:
          if (number === 0) {
            // special case for zero
            return number + "'nc";
          }

          var a = number % 10,
              b = number % 100 - a,
              c = number >= 100 ? 100 : null;
          return number + (suffixes[a] || suffixes[b] || suffixes[c]);
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return tr;
});

/***/ }),

/***/ 83614:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Talossan [tzl]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
//! author : Iust Canun
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration
  // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
  // This is currently too difficult (maybe even impossible) to add.

  var tzl = moment.defineLocale('tzl', {
    months: 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
    monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
    weekdays: 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
    weekdaysShort: 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
    weekdaysMin: 'S_L_Ma_M_Xh_Vi_S'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM [dallas] YYYY',
      LLL: 'D. MMMM [dallas] YYYY HH.mm',
      LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
    },
    meridiemParse: /d\'o|d\'a/i,
    isPM: function isPM(input) {
      return "d'o" === input.toLowerCase();
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? "d'o" : "D'O";
      } else {
        return isLower ? "d'a" : "D'A";
      }
    },
    calendar: {
      sameDay: '[oxhi ] LT',
      nextDay: '[dem ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ieiri ] LT',
      lastWeek: '[sr el] dddd [lasteu ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'osprei %s',
      past: 'ja%s',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      s: ['viensas secunds', "'iensas secunds"],
      ss: [number + ' secunds', '' + number + ' secunds'],
      m: ["'n mut", "'iens mut"],
      mm: [number + ' muts', '' + number + ' muts'],
      h: ["'n ora", "'iensa ora"],
      hh: [number + ' oras', '' + number + ' oras'],
      d: ["'n ziua", "'iensa ziua"],
      dd: [number + ' ziuas', '' + number + ' ziuas'],
      M: ["'n mes", "'iens mes"],
      MM: [number + ' mesen', '' + number + ' mesen'],
      y: ["'n ar", "'iens ar"],
      yy: [number + ' ars', '' + number + ' ars']
    };
    return isFuture ? format[key][0] : withoutSuffix ? format[key][0] : format[key][1];
  }

  return tzl;
});

/***/ }),

/***/ 77828:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight Latin [tzm-latn]
//! author : Abdel Said : https://github.com/abdelsaid
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var tzmLatn = moment.defineLocale('tzm-latn', {
    months: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    monthsShort: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[asdkh g] LT',
      nextDay: '[aska g] LT',
      nextWeek: 'dddd [g] LT',
      lastDay: '[assant g] LT',
      lastWeek: 'dddd [g] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dadkh s yan %s',
      past: 'yan %s',
      s: 'imik',
      ss: '%d imik',
      m: 'minu',
      mm: '%d minu',
      h: 'saa',
      hh: '%d tassain',
      d: 'ass',
      dd: '%d ossan',
      M: 'ayowr',
      MM: '%d iyyirn',
      y: 'asgas',
      yy: '%d isgasn'
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return tzmLatn;
});

/***/ }),

/***/ 77706:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight [tzm]
//! author : Abdel Said : https://github.com/abdelsaid
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var tzm = moment.defineLocale('tzm', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '   %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d o',
      M: 'o',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return tzm;
});

/***/ }),

/***/ 86550:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uyghur (China) [ug-cn]
//! author: boyaq : https://github.com/boyaq
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ugCn = moment.defineLocale('ug-cn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY-M-D-',
      LLL: 'YYYY-M-D- HH:mm',
      LLLL: 'dddd YYYY-M-D- HH:mm'
    },
    meridiemParse: / || || |/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === ' ' || meridiem === '' || meridiem === ' ') {
        return hour;
      } else if (meridiem === ' ' || meridiem === '') {
        return hour + 12;
      } else {
        return hour >= 11 ? hour : hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return ' ';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return ' ';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return ' ';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: '[] dddd [] LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '-';

        case 'w':
        case 'W':
          return number + '-';

        default:
          return number;
      }
    },
    preparse: function preparse(string) {
      return string.replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/,/g, '');
    },
    week: {
      // GB/T 7408-1994ISO 8601:1988
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1st is the first week of the year.

    }
  });
  return ugCn;
});

/***/ }),

/***/ 75509:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Ukrainian [uk]
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensle : https://github.com/Oire
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      ss: withoutSuffix ? '__' : '__',
      mm: withoutSuffix ? '__' : '__',
      hh: withoutSuffix ? '__' : '__',
      dd: '__',
      MM: '__',
      yy: '__'
    };

    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else if (key === 'h') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }

  function weekdaysCaseReplace(m, format) {
    var weekdays = {
      nominative: '______'.split('_'),
      accusative: '______'.split('_'),
      genitive: '______'.split('_')
    },
        nounCase;

    if (m === true) {
      return weekdays['nominative'].slice(1, 7).concat(weekdays['nominative'].slice(0, 1));
    }

    if (!m) {
      return weekdays['nominative'];
    }

    nounCase = /(\[[]\]) ?dddd/.test(format) ? 'accusative' : /\[?(?:|)? ?\] ?dddd/.test(format) ? 'genitive' : 'nominative';
    return weekdays[nounCase][m.day()];
  }

  function processHoursFunction(str) {
    return function () {
      return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
    };
  }

  var uk = moment.defineLocale('uk', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: weekdaysCaseReplace,
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar: {
      sameDay: processHoursFunction('[ '),
      nextDay: processHoursFunction('[ '),
      lastDay: processHoursFunction('[ '),
      nextWeek: processHoursFunction('[] dddd ['),
      lastWeek: function lastWeek() {
        switch (this.day()) {
          case 0:
          case 3:
          case 5:
          case 6:
            return processHoursFunction('[] dddd [').call(this);

          case 1:
          case 2:
          case 4:
            return processHoursFunction('[] dddd [').call(this);
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: relativeTimeWithPlural,
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: '',
      hh: relativeTimeWithPlural,
      d: '',
      dd: relativeTimeWithPlural,
      M: '',
      MM: relativeTimeWithPlural,
      y: '',
      yy: relativeTimeWithPlural
    },
    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
    meridiemParse: /|||/,
    isPM: function isPM(input) {
      return /^(|)$/.test(input);
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
        case 'w':
        case 'W':
          return number + '-';

        case 'D':
          return number + '-';

        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return uk;
});

/***/ }),

/***/ 912:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Urdu [ur]
//! author : Sawood Alam : https://github.com/ibnesayeed
//! author : Zack : https://github.com/ZackVision
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = ['', '', '', '', '', '', '', '', '', '', '', ''],
      days = ['', '', '', '', '', '', ''];
  var ur = moment.defineLocale('ur', {
    months: months,
    monthsShort: months,
    weekdays: days,
    weekdaysShort: days,
    weekdaysMin: days,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function isPM(input) {
      return '' === input;
    },
    meridiem: function meridiem(hour, minute, isLower) {
      if (hour < 12) {
        return '';
      }

      return '';
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[  ] LT',
      lastWeek: '[] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function preparse(string) {
      return string.replace(//g, ',');
    },
    postformat: function postformat(string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ur;
});

/***/ }),

/***/ 67537:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek Latin [uz-latn]
//! author : Rasulbek Mirzayev : github.com/Rasulbeeek
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var uzLatn = moment.defineLocale('uz-latn', {
    months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
    monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
    weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
    weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
    weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'D MMMM YYYY, dddd HH:mm'
    },
    calendar: {
      sameDay: '[Bugun soat] LT [da]',
      nextDay: '[Ertaga] LT [da]',
      nextWeek: 'dddd [kuni soat] LT [da]',
      lastDay: '[Kecha soat] LT [da]',
      lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
      sameElse: 'L'
    },
    relativeTime: {
      future: 'Yaqin %s ichida',
      past: 'Bir necha %s oldin',
      s: 'soniya',
      ss: '%d soniya',
      m: 'bir daqiqa',
      mm: '%d daqiqa',
      h: 'bir soat',
      hh: '%d soat',
      d: 'bir kun',
      dd: '%d kun',
      M: 'bir oy',
      MM: '%d oy',
      y: 'bir yil',
      yy: '%d yil'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return uzLatn;
});

/***/ }),

/***/ 23725:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek [uz]
//! author : Sardor Muminov : https://github.com/muminoff
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var uz = moment.defineLocale('uz', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'D MMMM YYYY, dddd HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT []',
      nextDay: '[] LT []',
      nextWeek: 'dddd [ ] LT []',
      lastDay: '[ ] LT []',
      lastWeek: '[] dddd [ ] LT []',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s ',
      past: '  %s ',
      s: '',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return uz;
});

/***/ }),

/***/ 53285:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Vietnamese [vi]
//! author : Bang Nguyen : https://github.com/bangnk
//! author : Chien Kira : https://github.com/chienkira
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var vi = moment.defineLocale('vi', {
    months: 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
    monthsShort: 'Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12'.split('_'),
    monthsParseExact: true,
    weekdays: 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
    weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysParseExact: true,
    meridiemParse: /sa|ch/i,
    isPM: function isPM(input) {
      return /^ch$/i.test(input);
    },
    meridiem: function meridiem(hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? 'sa' : 'SA';
      } else {
        return isLower ? 'ch' : 'CH';
      }
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [nm] YYYY',
      LLL: 'D MMMM [nm] YYYY HH:mm',
      LLLL: 'dddd, D MMMM [nm] YYYY HH:mm',
      l: 'DD/M/YYYY',
      ll: 'D MMM YYYY',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd, D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hm nay lc] LT',
      nextDay: '[Ngy mai lc] LT',
      nextWeek: 'dddd [tun ti lc] LT',
      lastDay: '[Hm qua lc] LT',
      lastWeek: 'dddd [tun trc lc] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ti',
      past: '%s trc',
      s: 'vi giy',
      ss: '%d giy',
      m: 'mt pht',
      mm: '%d pht',
      h: 'mt gi',
      hh: '%d gi',
      d: 'mt ngy',
      dd: '%d ngy',
      w: 'mt tun',
      ww: '%d tun',
      M: 'mt thng',
      MM: '%d thng',
      y: 'mt nm',
      yy: '%d nm'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function ordinal(number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return vi;
});

/***/ }),

/***/ 69201:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Pseudo [x-pseudo]
//! author : Andrew Hood : https://github.com/andrewhood125
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var xPseudo = moment.defineLocale('x-pseudo', {
    months: 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
    monthsShort: 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
    monthsParseExact: true,
    weekdays: 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
    weekdaysShort: 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
    weekdaysMin: 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[T~d~ t] LT',
      nextDay: '[T~m~rr~w t] LT',
      nextWeek: 'dddd [t] LT',
      lastDay: '[~st~rd~ t] LT',
      lastWeek: '[L~st] dddd [t] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '~ %s',
      past: '%s ~g',
      s: ' ~fw ~sc~ds',
      ss: '%d s~c~ds',
      m: ' ~m~t',
      mm: '%d m~~ts',
      h: '~ h~r',
      hh: '%d h~rs',
      d: ' ~d',
      dd: '%d d~s',
      M: ' ~m~th',
      MM: '%d m~t~hs',
      y: ' ~r',
      yy: '%d ~rs'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return xPseudo;
});

/***/ }),

/***/ 90392:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Yoruba Nigeria [yo]
//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var yo = moment.defineLocale('yo', {
    months: 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
    monthsShort: 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
    weekdays: 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
    weekdaysShort: 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
    weekdaysMin: 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Oni ni] LT',
      nextDay: '[la ni] LT',
      nextWeek: "dddd [s ton'b] [ni] LT",
      lastDay: '[Ana ni] LT',
      lastWeek: 'dddd [s tol] [ni] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ni %s',
      past: '%s kja',
      s: 'isju aaya die',
      ss: 'aaya %d',
      m: 'isju kan',
      mm: 'isju %d',
      h: 'wakati kan',
      hh: 'wakati %d',
      d: 'j kan',
      dd: 'j %d',
      M: 'osu kan',
      MM: 'osu %d',
      y: 'dun kan',
      yy: 'dun %d'
    },
    dayOfMonthOrdinalParse: /j\s\d{1,2}/,
    ordinal: 'j %d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return yo;
});

/***/ }),

/***/ 98914:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (China) [zh-cn]
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng
//! author : uu109 : https://github.com/uu109
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var zhCn = moment.defineLocale('zh-cn', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMDAhmm',
      LLLL: 'YYYYMDddddAhmm',
      l: 'YYYY/M/D',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      } else {
        // ''
        return hour >= 11 ? hour : hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return '';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[]LT',
      nextDay: '[]LT',
      nextWeek: function nextWeek(now) {
        if (now.week() !== this.week()) {
          return '[]dddLT';
        } else {
          return '[]dddLT';
        }
      },
      lastDay: '[]LT',
      lastWeek: function lastWeek(now) {
        if (this.week() !== now.week()) {
          return '[]dddLT';
        } else {
          return '[]dddLT';
        }
      },
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';

        case 'M':
          return number + '';

        case 'w':
        case 'W':
          return number + '';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      w: '1 ',
      ww: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    },
    week: {
      // GB/T 7408-1994ISO 8601:1988
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return zhCn;
});

/***/ }),

/***/ 8229:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Hong Kong) [zh-hk]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Konstantin : https://github.com/skfd
//! author : Anthony : https://github.com/anthonylau
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var zhHk = moment.defineLocale('zh-hk', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMDdddd HH:mm',
      l: 'YYYY/M/D',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1200) {
        return '';
      } else if (hm === 1200) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[]LT',
      nextDay: '[]LT',
      nextWeek: '[]ddddLT',
      lastDay: '[]LT',
      lastWeek: '[]ddddLT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';

        case 'M':
          return number + '';

        case 'w':
        case 'W':
          return number + '';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return zhHk;
});

/***/ }),

/***/ 59735:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Macau) [zh-mo]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Tan Yuanhong : https://github.com/le0tan
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var zhMo = moment.defineLocale('zh-mo', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMDdddd HH:mm',
      l: 'D/M/YYYY',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return '';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[]dddd LT',
      lastDay: '[] LT',
      lastWeek: '[]dddd LT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';

        case 'M':
          return number + '';

        case 'w':
        case 'W':
          return number + '';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return zhMo;
});

/***/ }),

/***/ 55786:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Taiwan) [zh-tw]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
;

(function (global, factory) {
   true ? factory(__webpack_require__(74329)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var zhTw = moment.defineLocale('zh-tw', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMDdddd HH:mm',
      l: 'YYYY/M/D',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function meridiemHour(hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function meridiem(hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return '';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[]dddd LT',
      lastDay: '[] LT',
      lastWeek: '[]dddd LT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function ordinal(number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';

        case 'M':
          return number + '';

        case 'w':
        case 'W':
          return number + '';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return zhTw;
});

/***/ }),

/***/ 74329:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
//! moment.js
//! version : 2.29.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
;

(function (global, factory) {
   true ? module.exports = factory() : 0;
})(this, function () {
  'use strict';

  var hookCallback;

  function hooks() {
    return hookCallback.apply(null, arguments);
  } // This is done to register the method called with moment()
  // without creating circular dependencies.


  function setHookCallback(callback) {
    hookCallback = callback;
  }

  function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
  }

  function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
  }

  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }

  function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
      return Object.getOwnPropertyNames(obj).length === 0;
    } else {
      var k;

      for (k in obj) {
        if (hasOwnProp(obj, k)) {
          return false;
        }
      }

      return true;
    }
  }

  function isUndefined(input) {
    return input === void 0;
  }

  function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
  }

  function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
  }

  function map(arr, fn) {
    var res = [],
        i;

    for (i = 0; i < arr.length; ++i) {
      res.push(fn(arr[i], i));
    }

    return res;
  }

  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }

    if (hasOwnProp(b, 'toString')) {
      a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
      a.valueOf = b.valueOf;
    }

    return a;
  }

  function createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }

  function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidEra: null,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
      parsedDateParts: [],
      era: null,
      meridiem: null,
      rfc2822: false,
      weekdayMismatch: false
    };
  }

  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }

    return m._pf;
  }

  var some;

  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function some(fun) {
      var t = Object(this),
          len = t.length >>> 0,
          i;

      for (i = 0; i < len; i++) {
        if (i in t && fun.call(this, t[i], i, t)) {
          return true;
        }
      }

      return false;
    };
  }

  function isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m),
          parsedParts = some.call(flags.parsedDateParts, function (i) {
        return i != null;
      }),
          isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

      if (m._strict) {
        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
      }

      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
    }

    return m._isValid;
  }

  function createInvalid(flags) {
    var m = createUTC(NaN);

    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }

    return m;
  } // Plugins that add properties should also add the key here (null value),
  // so we can properly clone ourselves.


  var momentProperties = hooks.momentProperties = [],
      updateInProgress = false;

  function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
      to._isAMomentObject = from._isAMomentObject;
    }

    if (!isUndefined(from._i)) {
      to._i = from._i;
    }

    if (!isUndefined(from._f)) {
      to._f = from._f;
    }

    if (!isUndefined(from._l)) {
      to._l = from._l;
    }

    if (!isUndefined(from._strict)) {
      to._strict = from._strict;
    }

    if (!isUndefined(from._tzm)) {
      to._tzm = from._tzm;
    }

    if (!isUndefined(from._isUTC)) {
      to._isUTC = from._isUTC;
    }

    if (!isUndefined(from._offset)) {
      to._offset = from._offset;
    }

    if (!isUndefined(from._pf)) {
      to._pf = getParsingFlags(from);
    }

    if (!isUndefined(from._locale)) {
      to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
      for (i = 0; i < momentProperties.length; i++) {
        prop = momentProperties[i];
        val = from[prop];

        if (!isUndefined(val)) {
          to[prop] = val;
        }
      }
    }

    return to;
  } // Moment prototype object


  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);

    if (!this.isValid()) {
      this._d = new Date(NaN);
    } // Prevent infinite loop in case updateOffset creates new moment
    // objects.


    if (updateInProgress === false) {
      updateInProgress = true;
      hooks.updateOffset(this);
      updateInProgress = false;
    }
  }

  function isMoment(obj) {
    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
  }

  function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
      console.warn('Deprecation warning: ' + msg);
    }
  }

  function deprecate(msg, fn) {
    var firstTime = true;
    return extend(function () {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(null, msg);
      }

      if (firstTime) {
        var args = [],
            arg,
            i,
            key;

        for (i = 0; i < arguments.length; i++) {
          arg = '';

          if (typeof arguments[i] === 'object') {
            arg += '\n[' + i + '] ';

            for (key in arguments[0]) {
              if (hasOwnProp(arguments[0], key)) {
                arg += key + ': ' + arguments[0][key] + ', ';
              }
            }

            arg = arg.slice(0, -2); // Remove trailing comma and space
          } else {
            arg = arguments[i];
          }

          args.push(arg);
        }

        warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
        firstTime = false;
      }

      return fn.apply(this, arguments);
    }, fn);
  }

  var deprecations = {};

  function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(name, msg);
    }

    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }

  hooks.suppressDeprecationWarnings = false;
  hooks.deprecationHandler = null;

  function isFunction(input) {
    return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }

  function set(config) {
    var prop, i;

    for (i in config) {
      if (hasOwnProp(config, i)) {
        prop = config[i];

        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }
    }

    this._config = config; // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.

    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
  }

  function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig),
        prop;

    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
          res[prop] = {};
          extend(res[prop], parentConfig[prop]);
          extend(res[prop], childConfig[prop]);
        } else if (childConfig[prop] != null) {
          res[prop] = childConfig[prop];
        } else {
          delete res[prop];
        }
      }
    }

    for (prop in parentConfig) {
      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
        // make sure changes to properties don't modify parent config
        res[prop] = extend({}, res[prop]);
      }
    }

    return res;
  }

  function Locale(config) {
    if (config != null) {
      this.set(config);
    }
  }

  var keys;

  if (Object.keys) {
    keys = Object.keys;
  } else {
    keys = function keys(obj) {
      var i,
          res = [];

      for (i in obj) {
        if (hasOwnProp(obj, i)) {
          res.push(i);
        }
      }

      return res;
    };
  }

  var defaultCalendar = {
    sameDay: '[Today at] LT',
    nextDay: '[Tomorrow at] LT',
    nextWeek: 'dddd [at] LT',
    lastDay: '[Yesterday at] LT',
    lastWeek: '[Last] dddd [at] LT',
    sameElse: 'L'
  };

  function calendar(key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
  }

  function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }

  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
      localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
      formatFunctions = {},
      formatTokenFunctions = {}; // token:    'M'
  // padded:   ['MM', 2]
  // ordinal:  'Mo'
  // callback: function () { this.month() + 1 }

  function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;

    if (typeof callback === 'string') {
      func = function func() {
        return this[callback]();
      };
    }

    if (token) {
      formatTokenFunctions[token] = func;
    }

    if (padded) {
      formatTokenFunctions[padded[0]] = function () {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }

    if (ordinal) {
      formatTokenFunctions[ordinal] = function () {
        return this.localeData().ordinal(func.apply(this, arguments), token);
      };
    }
  }

  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, '');
    }

    return input.replace(/\\/g, '');
  }

  function makeFormatFunction(format) {
    var array = format.match(formattingTokens),
        i,
        length;

    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }

    return function (mom) {
      var output = '',
          i;

      for (i = 0; i < length; i++) {
        output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
      }

      return output;
    };
  } // format date using native date object


  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
    return formatFunctions[format](m);
  }

  function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;

    while (i >= 0 && localFormattingTokens.test(format)) {
      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }

    return format;
  }

  var defaultLongDateFormat = {
    LTS: 'h:mm:ss A',
    LT: 'h:mm A',
    L: 'MM/DD/YYYY',
    LL: 'MMMM D, YYYY',
    LLL: 'MMMM D, YYYY h:mm A',
    LLLL: 'dddd, MMMM D, YYYY h:mm A'
  };

  function longDateFormat(key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
      return format;
    }

    this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {
      if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {
        return tok.slice(1);
      }

      return tok;
    }).join('');
    return this._longDateFormat[key];
  }

  var defaultInvalidDate = 'Invalid date';

  function invalidDate() {
    return this._invalidDate;
  }

  var defaultOrdinal = '%d',
      defaultDayOfMonthOrdinalParse = /\d{1,2}/;

  function ordinal(number) {
    return this._ordinal.replace('%d', number);
  }

  var defaultRelativeTime = {
    future: 'in %s',
    past: '%s ago',
    s: 'a few seconds',
    ss: '%d seconds',
    m: 'a minute',
    mm: '%d minutes',
    h: 'an hour',
    hh: '%d hours',
    d: 'a day',
    dd: '%d days',
    w: 'a week',
    ww: '%d weeks',
    M: 'a month',
    MM: '%d months',
    y: 'a year',
    yy: '%d years'
  };

  function relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
  }

  function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  }

  var aliases = {};

  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
  }

  function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
  }

  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);

        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }

    return normalizedInput;
  }

  var priorities = {};

  function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
  }

  function getPrioritizedUnits(unitsObj) {
    var units = [],
        u;

    for (u in unitsObj) {
      if (hasOwnProp(unitsObj, u)) {
        units.push({
          unit: u,
          priority: priorities[u]
        });
      }
    }

    units.sort(function (a, b) {
      return a.priority - b.priority;
    });
    return units;
  }

  function isLeapYear(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  }

  function absFloor(number) {
    if (number < 0) {
      // -0 -> 0
      return Math.ceil(number) || 0;
    } else {
      return Math.floor(number);
    }
  }

  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }

    return value;
  }

  function makeGetSet(unit, keepTime) {
    return function (value) {
      if (value != null) {
        set$1(this, unit, value);
        hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get(this, unit);
      }
    };
  }

  function get(mom, unit) {
    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
  }

  function set$1(mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
      if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
        value = toInt(value);

        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
      } else {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
      }
    }
  } // MOMENTS


  function stringGet(units) {
    units = normalizeUnits(units);

    if (isFunction(this[units])) {
      return this[units]();
    }

    return this;
  }

  function stringSet(units, value) {
    if (typeof units === 'object') {
      units = normalizeObjectUnits(units);
      var prioritized = getPrioritizedUnits(units),
          i;

      for (i = 0; i < prioritized.length; i++) {
        this[prioritized[i].unit](units[prioritized[i].unit]);
      }
    } else {
      units = normalizeUnits(units);

      if (isFunction(this[units])) {
        return this[units](value);
      }
    }

    return this;
  }

  var match1 = /\d/,
      //       0 - 9
  match2 = /\d\d/,
      //      00 - 99
  match3 = /\d{3}/,
      //     000 - 999
  match4 = /\d{4}/,
      //    0000 - 9999
  match6 = /[+-]?\d{6}/,
      // -999999 - 999999
  match1to2 = /\d\d?/,
      //       0 - 99
  match3to4 = /\d\d\d\d?/,
      //     999 - 9999
  match5to6 = /\d\d\d\d\d\d?/,
      //   99999 - 999999
  match1to3 = /\d{1,3}/,
      //       0 - 999
  match1to4 = /\d{1,4}/,
      //       0 - 9999
  match1to6 = /[+-]?\d{1,6}/,
      // -999999 - 999999
  matchUnsigned = /\d+/,
      //       0 - inf
  matchSigned = /[+-]?\d+/,
      //    -inf - inf
  matchOffset = /Z|[+-]\d\d:?\d\d/gi,
      // +00:00 -00:00 +0000 -0000 or Z
  matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
      // +00 -00 +00:00 -00:00 +0000 -0000 or Z
  matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
      // 123456789 123456789.123
  // any word (or two) characters or numbers including two/three word month in arabic.
  // includes scottish gaelic two word and hyphenated months
  matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
      regexes;
  regexes = {};

  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
      return isStrict && strictRegex ? strictRegex : regex;
    };
  }

  function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
      return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
  } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


  function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
      return p1 || p2 || p3 || p4;
    }));
  }

  function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }

  var tokens = {};

  function addParseToken(token, callback) {
    var i,
        func = callback;

    if (typeof token === 'string') {
      token = [token];
    }

    if (isNumber(callback)) {
      func = function func(input, array) {
        array[callback] = toInt(input);
      };
    }

    for (i = 0; i < token.length; i++) {
      tokens[token[i]] = func;
    }
  }

  function addWeekParseToken(token, callback) {
    addParseToken(token, function (input, array, config, token) {
      config._w = config._w || {};
      callback(input, config._w, config, token);
    });
  }

  function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
      tokens[token](input, config._a, config, token);
    }
  }

  var YEAR = 0,
      MONTH = 1,
      DATE = 2,
      HOUR = 3,
      MINUTE = 4,
      SECOND = 5,
      MILLISECOND = 6,
      WEEK = 7,
      WEEKDAY = 8;

  function mod(n, x) {
    return (n % x + x) % x;
  }

  var indexOf;

  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function indexOf(o) {
      // I know
      var i;

      for (i = 0; i < this.length; ++i) {
        if (this[i] === o) {
          return i;
        }
      }

      return -1;
    };
  }

  function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
      return NaN;
    }

    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
  } // FORMATTING


  addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
  });
  addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
  }); // ALIASES

  addUnitAlias('month', 'M'); // PRIORITY

  addUnitPriority('month', 8); // PARSING

  addRegexToken('M', match1to2);
  addRegexToken('MM', match1to2, match2);
  addRegexToken('MMM', function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
  });
  addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
  });
  addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  }); // LOCALES

  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
      defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
      defaultMonthsShortRegex = matchWord,
      defaultMonthsRegex = matchWord;

  function localeMonths(m, format) {
    if (!m) {
      return isArray(this._months) ? this._months : this._months['standalone'];
    }

    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
  }

  function localeMonthsShort(m, format) {
    if (!m) {
      return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
    }

    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
  }

  function handleStrictParse(monthName, format, strict) {
    var i,
        ii,
        mom,
        llc = monthName.toLocaleLowerCase();

    if (!this._monthsParse) {
      // this is not used
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];

      for (i = 0; i < 12; ++i) {
        mom = createUTC([2000, i]);
        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
      }
    }

    if (strict) {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }

  function localeMonthsParse(monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
      return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    } // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse


    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, i]);

      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
      }

      if (!strict && !this._monthsParse[i]) {
        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
      } // test the regex


      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
        return i;
      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  } // MOMENTS


  function setMonth(mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
      // No op
      return mom;
    }

    if (typeof value === 'string') {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

        if (!isNumber(value)) {
          return mom;
        }
      }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

    return mom;
  }

  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      hooks.updateOffset(this, true);
      return this;
    } else {
      return get(this, 'Month');
    }
  }

  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }

  function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }

      if (isStrict) {
        return this._monthsShortStrictRegex;
      } else {
        return this._monthsShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsShortRegex')) {
        this._monthsShortRegex = defaultMonthsShortRegex;
      }

      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
    }
  }

  function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }

      if (isStrict) {
        return this._monthsStrictRegex;
      } else {
        return this._monthsRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsRegex')) {
        this._monthsRegex = defaultMonthsRegex;
      }

      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
    }
  }

  function computeMonthsParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }

    var shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom;

    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, i]);
      shortPieces.push(this.monthsShort(mom, ''));
      longPieces.push(this.months(mom, ''));
      mixedPieces.push(this.months(mom, ''));
      mixedPieces.push(this.monthsShort(mom, ''));
    } // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.


    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);

    for (i = 0; i < 12; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
    }

    for (i = 0; i < 24; i++) {
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
  } // FORMATTING


  addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? zeroFill(y, 4) : '+' + y;
  });
  addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
  });
  addFormatToken(0, ['YYYY', 4], 0, 'year');
  addFormatToken(0, ['YYYYY', 5], 0, 'year');
  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

  addUnitAlias('year', 'y'); // PRIORITIES

  addUnitPriority('year', 1); // PARSING

  addRegexToken('Y', matchSigned);
  addRegexToken('YY', match1to2, match2);
  addRegexToken('YYYY', match1to4, match4);
  addRegexToken('YYYYY', match1to6, match6);
  addRegexToken('YYYYYY', match1to6, match6);
  addParseToken(['YYYYY', 'YYYYYY'], YEAR);
  addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
  }); // HELPERS

  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  } // HOOKS


  hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  }; // MOMENTS


  var getSetYear = makeGetSet('FullYear', true);

  function getIsLeapYear() {
    return isLeapYear(this.year());
  }

  function createDate(y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date; // the date constructor remaps years 0-99 to 1900-1999

    if (y < 100 && y >= 0) {
      // preserve leap years using a full 400 year cycle, then reset
      date = new Date(y + 400, m, d, h, M, s, ms);

      if (isFinite(date.getFullYear())) {
        date.setFullYear(y);
      }
    } else {
      date = new Date(y, m, d, h, M, s, ms);
    }

    return date;
  }

  function createUTCDate(y) {
    var date, args; // the Date.UTC function remaps years 0-99 to 1900-1999

    if (y < 100 && y >= 0) {
      args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

      args[0] = y + 400;
      date = new Date(Date.UTC.apply(null, args));

      if (isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
      }
    } else {
      date = new Date(Date.UTC.apply(null, arguments));
    }

    return date;
  } // start-of-first-week - start-of-year


  function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
    fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
    fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear,
        resDayOfYear;

    if (dayOfYear <= 0) {
      resYear = year - 1;
      resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
      resYear = year + 1;
      resDayOfYear = dayOfYear - daysInYear(year);
    } else {
      resYear = year;
      resDayOfYear = dayOfYear;
    }

    return {
      year: resYear,
      dayOfYear: resDayOfYear
    };
  }

  function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek,
        resYear;

    if (week < 1) {
      resYear = mom.year() - 1;
      resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
      resWeek = week - weeksInYear(mom.year(), dow, doy);
      resYear = mom.year() + 1;
    } else {
      resYear = mom.year();
      resWeek = week;
    }

    return {
      week: resWeek,
      year: resYear
    };
  }

  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  } // FORMATTING


  addFormatToken('w', ['ww', 2], 'wo', 'week');
  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

  addUnitAlias('week', 'w');
  addUnitAlias('isoWeek', 'W'); // PRIORITIES

  addUnitPriority('week', 5);
  addUnitPriority('isoWeek', 5); // PARSING

  addRegexToken('w', match1to2);
  addRegexToken('ww', match1to2, match2);
  addRegexToken('W', match1to2);
  addRegexToken('WW', match1to2, match2);
  addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
  }); // HELPERS
  // LOCALES

  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }

  var defaultLocaleWeek = {
    dow: 0,
    // Sunday is the first day of the week.
    doy: 6 // The week that contains Jan 6th is the first week of the year.

  };

  function localeFirstDayOfWeek() {
    return this._week.dow;
  }

  function localeFirstDayOfYear() {
    return this._week.doy;
  } // MOMENTS


  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
  }

  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
  } // FORMATTING


  addFormatToken('d', 0, 'do', 'day');
  addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken('e', 0, 0, 'weekday');
  addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

  addUnitAlias('day', 'd');
  addUnitAlias('weekday', 'e');
  addUnitAlias('isoWeekday', 'E'); // PRIORITY

  addUnitPriority('day', 11);
  addUnitPriority('weekday', 11);
  addUnitPriority('isoWeekday', 11); // PARSING

  addRegexToken('d', match1to2);
  addRegexToken('e', match1to2);
  addRegexToken('E', match1to2);
  addRegexToken('dd', function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken('ddd', function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken('dddd', function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
  });
  addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
  }); // HELPERS

  function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
      return input;
    }

    if (!isNaN(input)) {
      return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);

    if (typeof input === 'number') {
      return input;
    }

    return null;
  }

  function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
      return locale.weekdaysParse(input) % 7 || 7;
    }

    return isNaN(input) ? null : input;
  } // LOCALES


  function shiftWeekdays(ws, n) {
    return ws.slice(n, 7).concat(ws.slice(0, n));
  }

  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
      defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
      defaultWeekdaysRegex = matchWord,
      defaultWeekdaysShortRegex = matchWord,
      defaultWeekdaysMinRegex = matchWord;

  function localeWeekdays(m, format) {
    var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
    return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
  }

  function localeWeekdaysShort(m) {
    return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
  }

  function localeWeekdaysMin(m) {
    return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
  }

  function handleStrictParse$1(weekdayName, format, strict) {
    var i,
        ii,
        mom,
        llc = weekdayName.toLocaleLowerCase();

    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._minWeekdaysParse = [];

      for (i = 0; i < 7; ++i) {
        mom = createUTC([2000, 1]).day(i);
        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
      }
    }

    if (strict) {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._shortWeekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._weekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._weekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }

  function localeWeekdaysParse(weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
      return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._minWeekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, 1]).day(i);

      if (strict && !this._fullWeekdaysParse[i]) {
        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
      }

      if (!this._weekdaysParse[i]) {
        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
      } // test the regex


      if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  } // MOMENTS


  function getSetDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, 'd');
    } else {
      return day;
    }
  }

  function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
  }

  function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    } // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.


    if (input != null) {
      var weekday = parseIsoWeekday(input, this.localeData());
      return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
      return this.day() || 7;
    }
  }

  function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }

      if (isStrict) {
        return this._weekdaysStrictRegex;
      } else {
        return this._weekdaysRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        this._weekdaysRegex = defaultWeekdaysRegex;
      }

      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
    }
  }

  function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }

      if (isStrict) {
        return this._weekdaysShortStrictRegex;
      } else {
        return this._weekdaysShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysShortRegex')) {
        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
      }

      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
  }

  function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }

      if (isStrict) {
        return this._weekdaysMinStrictRegex;
      } else {
        return this._weekdaysMinRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysMinRegex')) {
        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
      }

      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
  }

  function computeWeekdaysParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }

    var minPieces = [],
        shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom,
        minp,
        shortp,
        longp;

    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, 1]).day(i);
      minp = regexEscape(this.weekdaysMin(mom, ''));
      shortp = regexEscape(this.weekdaysShort(mom, ''));
      longp = regexEscape(this.weekdays(mom, ''));
      minPieces.push(minp);
      shortPieces.push(shortp);
      longPieces.push(longp);
      mixedPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
    } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.


    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;
    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
  } // FORMATTING


  function hFormat() {
    return this.hours() % 12 || 12;
  }

  function kFormat() {
    return this.hours() || 24;
  }

  addFormatToken('H', ['HH', 2], 0, 'hour');
  addFormatToken('h', ['hh', 2], 0, hFormat);
  addFormatToken('k', ['kk', 2], 0, kFormat);
  addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });

  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function () {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
  }

  meridiem('a', true);
  meridiem('A', false); // ALIASES

  addUnitAlias('hour', 'h'); // PRIORITY

  addUnitPriority('hour', 13); // PARSING

  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }

  addRegexToken('a', matchMeridiem);
  addRegexToken('A', matchMeridiem);
  addRegexToken('H', match1to2);
  addRegexToken('h', match1to2);
  addRegexToken('k', match1to2);
  addRegexToken('HH', match1to2, match2);
  addRegexToken('hh', match1to2, match2);
  addRegexToken('kk', match1to2, match2);
  addRegexToken('hmm', match3to4);
  addRegexToken('hmmss', match5to6);
  addRegexToken('Hmm', match3to4);
  addRegexToken('Hmmss', match5to6);
  addParseToken(['H', 'HH'], HOUR);
  addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
  });
  addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4,
        pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4,
        pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
  }); // LOCALES

  function localeIsPM(input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return (input + '').toLowerCase().charAt(0) === 'p';
  }

  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
      // Setting the hour should keep the time, because the user explicitly
  // specified which hour they want. So trying to maintain the same hour (in
  // a new timezone) makes sense. Adding/subtracting hours does not follow
  // this rule.
  getSetHour = makeGetSet('Hours', true);

  function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
      return isLower ? 'pm' : 'PM';
    } else {
      return isLower ? 'am' : 'AM';
    }
  }

  var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,
    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,
    week: defaultLocaleWeek,
    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,
    meridiemParse: defaultLocaleMeridiemParse
  }; // internal storage for locale config files

  var locales = {},
      localeFamilies = {},
      globalLocale;

  function commonPrefix(arr1, arr2) {
    var i,
        minl = Math.min(arr1.length, arr2.length);

    for (i = 0; i < minl; i += 1) {
      if (arr1[i] !== arr2[i]) {
        return i;
      }
    }

    return minl;
  }

  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
  } // pick the locale from the array
  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


  function chooseLocale(names) {
    var i = 0,
        j,
        next,
        locale,
        split;

    while (i < names.length) {
      split = normalizeLocale(names[i]).split('-');
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split('-') : null;

      while (j > 0) {
        locale = loadLocale(split.slice(0, j).join('-'));

        if (locale) {
          return locale;
        }

        if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
          //the next array item is better than a shallower substring of this one
          break;
        }

        j--;
      }

      i++;
    }

    return globalLocale;
  }

  function loadLocale(name) {
    var oldLocale = null,
        aliasedRequire; // TODO: Find a better way to register and load all the locales in Node

    if (locales[name] === undefined && "object" !== 'undefined' && module && module.exports) {
      try {
        oldLocale = globalLocale._abbr;
        aliasedRequire = undefined;
        __webpack_require__(46700)("./" + name);
        getSetGlobalLocale(oldLocale);
      } catch (e) {
        // mark as not found to avoid repeating expensive file require call causing high CPU
        // when trying to find en-US, en_US, en-us for every format call
        locales[name] = null; // null means not found
      }
    }

    return locales[name];
  } // This function will load locale and then set the global locale.  If
  // no arguments are passed in, it will simply return the current global
  // locale key.


  function getSetGlobalLocale(key, values) {
    var data;

    if (key) {
      if (isUndefined(values)) {
        data = getLocale(key);
      } else {
        data = defineLocale(key, values);
      }

      if (data) {
        // moment.duration._locale = moment._locale = data;
        globalLocale = data;
      } else {
        if (typeof console !== 'undefined' && console.warn) {
          //warn user if arguments are passed but the locale could not be set
          console.warn('Locale ' + key + ' not found. Did you forget to load it?');
        }
      }
    }

    return globalLocale._abbr;
  }

  function defineLocale(name, config) {
    if (config !== null) {
      var locale,
          parentConfig = baseConfig;
      config.abbr = name;

      if (locales[name] != null) {
        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
        parentConfig = locales[name]._config;
      } else if (config.parentLocale != null) {
        if (locales[config.parentLocale] != null) {
          parentConfig = locales[config.parentLocale]._config;
        } else {
          locale = loadLocale(config.parentLocale);

          if (locale != null) {
            parentConfig = locale._config;
          } else {
            if (!localeFamilies[config.parentLocale]) {
              localeFamilies[config.parentLocale] = [];
            }

            localeFamilies[config.parentLocale].push({
              name: name,
              config: config
            });
            return null;
          }
        }
      }

      locales[name] = new Locale(mergeConfigs(parentConfig, config));

      if (localeFamilies[name]) {
        localeFamilies[name].forEach(function (x) {
          defineLocale(x.name, x.config);
        });
      } // backwards compat for now: also set the locale
      // make sure we set the locale AFTER all child locales have been
      // created, so we won't end up with the child locale set.


      getSetGlobalLocale(name);
      return locales[name];
    } else {
      // useful for testing
      delete locales[name];
      return null;
    }
  }

  function updateLocale(name, config) {
    if (config != null) {
      var locale,
          tmpLocale,
          parentConfig = baseConfig;

      if (locales[name] != null && locales[name].parentLocale != null) {
        // Update existing child locale in-place to avoid memory-leaks
        locales[name].set(mergeConfigs(locales[name]._config, config));
      } else {
        // MERGE
        tmpLocale = loadLocale(name);

        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }

        config = mergeConfigs(parentConfig, config);

        if (tmpLocale == null) {
          // updateLocale is called for creating a new locale
          // Set abbr so it will have a name (getters return
          // undefined otherwise).
          config.abbr = name;
        }

        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;
      } // backwards compat for now: also set the locale


      getSetGlobalLocale(name);
    } else {
      // pass null for config to unupdate, useful for tests
      if (locales[name] != null) {
        if (locales[name].parentLocale != null) {
          locales[name] = locales[name].parentLocale;

          if (name === getSetGlobalLocale()) {
            getSetGlobalLocale(name);
          }
        } else if (locales[name] != null) {
          delete locales[name];
        }
      }
    }

    return locales[name];
  } // returns locale data


  function getLocale(key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }

    if (!key) {
      return globalLocale;
    }

    if (!isArray(key)) {
      //short-circuit everything else
      locale = loadLocale(key);

      if (locale) {
        return locale;
      }

      key = [key];
    }

    return chooseLocale(key);
  }

  function listLocales() {
    return keys(locales);
  }

  function checkOverflow(m) {
    var overflow,
        a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
        overflow = DATE;
      }

      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
        overflow = WEEK;
      }

      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
        overflow = WEEKDAY;
      }

      getParsingFlags(m).overflow = overflow;
    }

    return m;
  } // iso 8601 regex
  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
      basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
      tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
      isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/], ['YYYYMM', /\d{6}/, false], ['YYYY', /\d{4}/, false]],
      // iso time formats and regexes
  isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]],
      aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
      // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
  rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
      obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  }; // date from iso format

  function configFromISO(config) {
    var i,
        l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime,
        dateFormat,
        timeFormat,
        tzFormat;

    if (match) {
      getParsingFlags(config).iso = true;

      for (i = 0, l = isoDates.length; i < l; i++) {
        if (isoDates[i][1].exec(match[1])) {
          dateFormat = isoDates[i][0];
          allowTime = isoDates[i][2] !== false;
          break;
        }
      }

      if (dateFormat == null) {
        config._isValid = false;
        return;
      }

      if (match[3]) {
        for (i = 0, l = isoTimes.length; i < l; i++) {
          if (isoTimes[i][1].exec(match[3])) {
            // match[2] should be 'T' or space
            timeFormat = (match[2] || ' ') + isoTimes[i][0];
            break;
          }
        }

        if (timeFormat == null) {
          config._isValid = false;
          return;
        }
      }

      if (!allowTime && timeFormat != null) {
        config._isValid = false;
        return;
      }

      if (match[4]) {
        if (tzRegex.exec(match[4])) {
          tzFormat = 'Z';
        } else {
          config._isValid = false;
          return;
        }
      }

      config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }

  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

    if (secondStr) {
      result.push(parseInt(secondStr, 10));
    }

    return result;
  }

  function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);

    if (year <= 49) {
      return 2000 + year;
    } else if (year <= 999) {
      return 1900 + year;
    }

    return year;
  }

  function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  }

  function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
      // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
          weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

      if (weekdayProvided !== weekdayActual) {
        getParsingFlags(config).weekdayMismatch = true;
        config._isValid = false;
        return false;
      }
    }

    return true;
  }

  function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
      return obsOffsets[obsOffset];
    } else if (militaryOffset) {
      // the only allowed military tz is Z
      return 0;
    } else {
      var hm = parseInt(numOffset, 10),
          m = hm % 100,
          h = (hm - m) / 100;
      return h * 60 + m;
    }
  } // date and time from ref 2822 format


  function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i)),
        parsedArray;

    if (match) {
      parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

      if (!checkWeekday(match[1], parsedArray, config)) {
        return;
      }

      config._a = parsedArray;
      config._tzm = calculateOffset(match[8], match[9], match[10]);
      config._d = createUTCDate.apply(null, config._a);

      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

      getParsingFlags(config).rfc2822 = true;
    } else {
      config._isValid = false;
    }
  } // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict


  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
      config._d = new Date(+matched[1]);
      return;
    }

    configFromISO(config);

    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }

    configFromRFC2822(config);

    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }

    if (config._strict) {
      config._isValid = false;
    } else {
      // Final attempt, use Input Fallback
      hooks.createFromInputFallback(config);
    }
  }

  hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
  }); // Pick the first defined of two or three arguments.

  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }

    if (b != null) {
      return b;
    }

    return c;
  }

  function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());

    if (config._useUTC) {
      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }

    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  } // convert an array to a date.
  // the array should mirror the parameters below
  // note: all values past the year are optional and will default to the lowest possible value.
  // [year, month, day , hour, minute, second, millisecond]


  function configFromArray(config) {
    var i,
        date,
        input = [],
        currentDate,
        expectedWeekday,
        yearToUse;

    if (config._d) {
      return;
    }

    currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    } //if the day of the year is set, figure out what it is


    if (config._dayOfYear != null) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

      if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }

      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    } // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything


    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    } // Zero out whatever was not defaulted, including time


    for (; i < 7; i++) {
      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
    } // Check for 24:00:00.000


    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.

    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
      config._a[HOUR] = 24;
    } // check for mismatching day of week


    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
      getParsingFlags(config).weekdayMismatch = true;
    }
  }

  function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
    w = config._w;

    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
      // how we interpret now (local, utc, fixed offset). So create
      // a now version of current config (take local/utc/offset flags, and
      // create now).

      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);

      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      curWeek = weekOfYear(createLocal(), dow, doy);
      weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

      week = defaults(w.w, curWeek.week);

      if (w.d != null) {
        // weekday -- low day numbers are considered next week
        weekday = w.d;

        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w.e != null) {
        // local weekday -- counting starts from beginning of week
        weekday = w.e + dow;

        if (w.e < 0 || w.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        // default to beginning of week
        weekday = dow;
      }
    }

    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
      getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      getParsingFlags(config)._overflowWeekday = true;
    } else {
      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
  } // constant that refers to the ISO standard


  hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


  hooks.RFC_2822 = function () {}; // date from string and format string


  function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
      configFromISO(config);
      return;
    }

    if (config._f === hooks.RFC_2822) {
      configFromRFC2822(config);
      return;
    }

    config._a = [];
    getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

    var string = '' + config._i,
        i,
        parsedInput,
        tokens,
        token,
        skipped,
        stringLength = string.length,
        totalParsedInputLength = 0,
        era;
    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];

      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));

        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }

        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      } // don't parse if it's not a known token


      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token);
        }

        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token);
      }
    } // add remaining unparsed input length to the string


    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    } // clear _12h flag if hour is <= 12


    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
      getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem); // handle era

    era = getParsingFlags(config).era;

    if (era !== null) {
      config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
    }

    configFromArray(config);
    checkOverflow(config);
  }

  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
      // nothing to do
      return hour;
    }

    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      // Fallback
      isPm = locale.isPM(meridiem);

      if (isPm && hour < 12) {
        hour += 12;
      }

      if (!isPm && hour === 12) {
        hour = 0;
      }

      return hour;
    } else {
      // this is not supposed to happen
      return hour;
    }
  } // date from string and array of format strings


  function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,
        scoreToBeat,
        i,
        currentScore,
        validFormatFound,
        bestFormatIsValid = false;

    if (config._f.length === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }

    for (i = 0; i < config._f.length; i++) {
      currentScore = 0;
      validFormatFound = false;
      tempConfig = copyConfig({}, config);

      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }

      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);

      if (isValid(tempConfig)) {
        validFormatFound = true;
      } // if there is any input that was not parsed add a penalty for that format


      currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;

      if (!bestFormatIsValid) {
        if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;

          if (validFormatFound) {
            bestFormatIsValid = true;
          }
        }
      } else {
        if (currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }
    }

    extend(config, bestMoment || tempConfig);
  }

  function configFromObject(config) {
    if (config._d) {
      return;
    }

    var i = normalizeObjectUnits(config._i),
        dayOrDate = i.day === undefined ? i.date : i.day;
    config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {
      return obj && parseInt(obj, 10);
    });
    configFromArray(config);
  }

  function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));

    if (res._nextDay) {
      // Adding is smart enough around DST
      res.add(1, 'd');
      res._nextDay = undefined;
    }

    return res;
  }

  function prepareConfig(config) {
    var input = config._i,
        format = config._f;
    config._locale = config._locale || getLocale(config._l);

    if (input === null || format === undefined && input === '') {
      return createInvalid({
        nullInput: true
      });
    }

    if (typeof input === 'string') {
      config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
      config._d = input;
    } else if (isArray(format)) {
      configFromStringAndArray(config);
    } else if (format) {
      configFromStringAndFormat(config);
    } else {
      configFromInput(config);
    }

    if (!isValid(config)) {
      config._d = null;
    }

    return config;
  }

  function configFromInput(config) {
    var input = config._i;

    if (isUndefined(input)) {
      config._d = new Date(hooks.now());
    } else if (isDate(input)) {
      config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
      configFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function (obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (isObject(input)) {
      configFromObject(config);
    } else if (isNumber(input)) {
      // from milliseconds
      config._d = new Date(input);
    } else {
      hooks.createFromInputFallback(config);
    }
  }

  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};

    if (format === true || format === false) {
      strict = format;
      format = undefined;
    }

    if (locale === true || locale === false) {
      strict = locale;
      locale = undefined;
    }

    if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
      input = undefined;
    } // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423


    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;
    return createFromConfig(c);
  }

  function createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }

  var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
    var other = createLocal.apply(null, arguments);

    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }),
      prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
    var other = createLocal.apply(null, arguments);

    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }); // Pick a moment m from moments so that m[fn](other) is true for all
  // other. This relies on the function fn to be transitive.
  //
  // moments should either be an array of moment objects or an array, whose
  // first element is an array of moment objects.

  function pickBy(fn, moments) {
    var res, i;

    if (moments.length === 1 && isArray(moments[0])) {
      moments = moments[0];
    }

    if (!moments.length) {
      return createLocal();
    }

    res = moments[0];

    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }

    return res;
  } // TODO: Use [].sort instead?


  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isBefore', args);
  }

  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isAfter', args);
  }

  var now = function now() {
    return Date.now ? Date.now() : +new Date();
  };

  var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

  function isDurationValid(m) {
    var key,
        unitHasDecimal = false,
        i;

    for (key in m) {
      if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
        return false;
      }
    }

    for (i = 0; i < ordering.length; ++i) {
      if (m[ordering[i]]) {
        if (unitHasDecimal) {
          return false; // only allow non-integers for smallest unit
        }

        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
          unitHasDecimal = true;
        }
      }
    }

    return true;
  }

  function isValid$1() {
    return this._isValid;
  }

  function createInvalid$1() {
    return createDuration(NaN);
  }

  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;
    this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

    this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
    minutes * 6e4 + // 1000 * 60
    hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately

    this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.

    this._months = +months + quarters * 3 + years * 12;
    this._data = {};
    this._locale = getLocale();

    this._bubble();
  }

  function isDuration(obj) {
    return obj instanceof Duration;
  }

  function absRound(number) {
    if (number < 0) {
      return Math.round(-1 * number) * -1;
    } else {
      return Math.round(number);
    }
  } // compare two arrays, return the number of differences


  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;

    for (i = 0; i < len; i++) {
      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
        diffs++;
      }
    }

    return diffs + lengthDiff;
  } // FORMATTING


  function offset(token, separator) {
    addFormatToken(token, 0, 0, function () {
      var offset = this.utcOffset(),
          sign = '+';

      if (offset < 0) {
        offset = -offset;
        sign = '-';
      }

      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
    });
  }

  offset('Z', ':');
  offset('ZZ', ''); // PARSING

  addRegexToken('Z', matchShortOffset);
  addRegexToken('ZZ', matchShortOffset);
  addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  }); // HELPERS
  // timezone chunker
  // '+10:00' > ['10',  '00']
  // '-1530'  > ['-15', '30']

  var chunkOffset = /([\+\-]|\d\d)/gi;

  function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher),
        chunk,
        parts,
        minutes;

    if (matches === null) {
      return null;
    }

    chunk = matches[matches.length - 1] || [];
    parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    minutes = +(parts[1] * 60) + toInt(parts[2]);
    return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
  } // Return a moment from input, that is local/utc/zone equivalent to model.


  function cloneWithOffset(input, model) {
    var res, diff;

    if (model._isUTC) {
      res = model.clone();
      diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

      res._d.setTime(res._d.valueOf() + diff);

      hooks.updateOffset(res, false);
      return res;
    } else {
      return createLocal(input).local();
    }
  }

  function getDateOffset(m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset());
  } // HOOKS
  // This function will be called whenever a moment is mutated.
  // It is intended to keep the offset in sync with the timezone.


  hooks.updateOffset = function () {}; // MOMENTS
  // keepLocalTime = true means only change the timezone, without
  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
  // +0200, so we adjust the time as needed, to be valid.
  //
  // Keeping the time actually adds/subtracts (one hour)
  // from the actual represented time. That is why we call updateOffset
  // a second time. In case it wants us to change the offset again
  // _changeInProgress == true case, then we have to adjust, because
  // there is no such time in the given timezone.


  function getSetOffset(input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;

    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    if (input != null) {
      if (typeof input === 'string') {
        input = offsetFromString(matchShortOffset, input);

        if (input === null) {
          return this;
        }
      } else if (Math.abs(input) < 16 && !keepMinutes) {
        input = input * 60;
      }

      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }

      this._offset = input;
      this._isUTC = true;

      if (localAdjust != null) {
        this.add(localAdjust, 'm');
      }

      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          addSubtract(this, createDuration(input - offset, 'm'), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }

      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }

  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== 'string') {
        input = -input;
      }

      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }

  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }

  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;

      if (keepLocalTime) {
        this.subtract(getDateOffset(this), 'm');
      }
    }

    return this;
  }

  function setOffsetToParsedOffset() {
    if (this._tzm != null) {
      this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
      var tZone = offsetFromString(matchOffset, this._i);

      if (tZone != null) {
        this.utcOffset(tZone);
      } else {
        this.utcOffset(0, true);
      }
    }

    return this;
  }

  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }

    input = input ? createLocal(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }

  function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  }

  function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted)) {
      return this._isDSTShifted;
    }

    var c = {},
        other;
    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
      other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }

    return this._isDSTShifted;
  }

  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }

  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }

  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  } // ASP.NET json date format regex


  var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
  // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
  // and further modified to allow for strings containing both week and day
  isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

  function createDuration(input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
    match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (isNumber(input) || !isNaN(+input)) {
      duration = {};

      if (key) {
        duration[key] = +input;
      } else {
        duration.milliseconds = +input;
      }
    } else if (match = aspNetRegex.exec(input)) {
      sign = match[1] === '-' ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

      };
    } else if (match = isoRegex.exec(input)) {
      sign = match[1] === '-' ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign),
        M: parseIso(match[3], sign),
        w: parseIso(match[4], sign),
        d: parseIso(match[5], sign),
        h: parseIso(match[6], sign),
        m: parseIso(match[7], sign),
        s: parseIso(match[8], sign)
      };
    } else if (duration == null) {
      // checks for null or undefined
      duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
      diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
      ret._locale = input._locale;
    }

    if (isDuration(input) && hasOwnProp(input, '_isValid')) {
      ret._isValid = input._isValid;
    }

    return ret;
  }

  createDuration.fn = Duration.prototype;
  createDuration.invalid = createInvalid$1;

  function parseIso(inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

    return (isNaN(res) ? 0 : res) * sign;
  }

  function positiveMomentsDifference(base, other) {
    var res = {};
    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

    if (base.clone().add(res.months, 'M').isAfter(other)) {
      --res.months;
    }

    res.milliseconds = +other - +base.clone().add(res.months, 'M');
    return res;
  }

  function momentsDifference(base, other) {
    var res;

    if (!(base.isValid() && other.isValid())) {
      return {
        milliseconds: 0,
        months: 0
      };
    }

    other = cloneWithOffset(other, base);

    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }

    return res;
  } // TODO: remove 'name' arg after deprecation is removed


  function createAdder(direction, name) {
    return function (val, period) {
      var dur, tmp; //invert the arguments, but complain about it

      if (period !== null && !isNaN(+period)) {
        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
        tmp = val;
        val = period;
        period = tmp;
      }

      dur = createDuration(val, period);
      addSubtract(this, dur, direction);
      return this;
    };
  }

  function addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
      // No op
      return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
      setMonth(mom, get(mom, 'Month') + months * isAdding);
    }

    if (days) {
      set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }

    if (milliseconds) {
      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }

    if (updateOffset) {
      hooks.updateOffset(mom, days || months);
    }
  }

  var add = createAdder(1, 'add'),
      subtract = createAdder(-1, 'subtract');

  function isString(input) {
    return typeof input === 'string' || input instanceof String;
  } // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined


  function isMomentInput(input) {
    return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
  }

  function isMomentInputObject(input) {
    var objectTest = isObject(input) && !isObjectEmpty(input),
        propertyTest = false,
        properties = ['years', 'year', 'y', 'months', 'month', 'M', 'days', 'day', 'd', 'dates', 'date', 'D', 'hours', 'hour', 'h', 'minutes', 'minute', 'm', 'seconds', 'second', 's', 'milliseconds', 'millisecond', 'ms'],
        i,
        property;

    for (i = 0; i < properties.length; i += 1) {
      property = properties[i];
      propertyTest = propertyTest || hasOwnProp(input, property);
    }

    return objectTest && propertyTest;
  }

  function isNumberOrStringArray(input) {
    var arrayTest = isArray(input),
        dataTypeTest = false;

    if (arrayTest) {
      dataTypeTest = input.filter(function (item) {
        return !isNumber(item) && isString(input);
      }).length === 0;
    }

    return arrayTest && dataTypeTest;
  }

  function isCalendarSpec(input) {
    var objectTest = isObject(input) && !isObjectEmpty(input),
        propertyTest = false,
        properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],
        i,
        property;

    for (i = 0; i < properties.length; i += 1) {
      property = properties[i];
      propertyTest = propertyTest || hasOwnProp(input, property);
    }

    return objectTest && propertyTest;
  }

  function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
  }

  function calendar$1(time, formats) {
    // Support for single parameter, formats only overload to the calendar function
    if (arguments.length === 1) {
      if (!arguments[0]) {
        time = undefined;
        formats = undefined;
      } else if (isMomentInput(arguments[0])) {
        time = arguments[0];
        formats = undefined;
      } else if (isCalendarSpec(arguments[0])) {
        formats = arguments[0];
        time = undefined;
      }
    } // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.


    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse',
        output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
  }

  function clone() {
    return new Moment(this);
  }

  function isAfter(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);

    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }

    units = normalizeUnits(units) || 'millisecond';

    if (units === 'millisecond') {
      return this.valueOf() > localInput.valueOf();
    } else {
      return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
  }

  function isBefore(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);

    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }

    units = normalizeUnits(units) || 'millisecond';

    if (units === 'millisecond') {
      return this.valueOf() < localInput.valueOf();
    } else {
      return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
  }

  function isBetween(from, to, units, inclusivity) {
    var localFrom = isMoment(from) ? from : createLocal(from),
        localTo = isMoment(to) ? to : createLocal(to);

    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
      return false;
    }

    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
  }

  function isSame(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;

    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }

    units = normalizeUnits(units) || 'millisecond';

    if (units === 'millisecond') {
      return this.valueOf() === localInput.valueOf();
    } else {
      inputMs = localInput.valueOf();
      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
  }

  function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  }

  function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  }

  function diff(input, units, asFloat) {
    var that, zoneDelta, output;

    if (!this.isValid()) {
      return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
      return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
    units = normalizeUnits(units);

    switch (units) {
      case 'year':
        output = monthDiff(this, that) / 12;
        break;

      case 'month':
        output = monthDiff(this, that);
        break;

      case 'quarter':
        output = monthDiff(this, that) / 3;
        break;

      case 'second':
        output = (this - that) / 1e3;
        break;
      // 1000

      case 'minute':
        output = (this - that) / 6e4;
        break;
      // 1000 * 60

      case 'hour':
        output = (this - that) / 36e5;
        break;
      // 1000 * 60 * 60

      case 'day':
        output = (this - that - zoneDelta) / 864e5;
        break;
      // 1000 * 60 * 60 * 24, negate dst

      case 'week':
        output = (this - that - zoneDelta) / 6048e5;
        break;
      // 1000 * 60 * 60 * 24 * 7, negate dst

      default:
        output = this - that;
    }

    return asFloat ? output : absFloor(output);
  }

  function monthDiff(a, b) {
    if (a.date() < b.date()) {
      // end-of-month calculations work correct when the start month has more
      // days than the end month.
      return -monthDiff(b, a);
    } // difference in months


    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
    anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2,
        adjust;

    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

      adjust = (b - anchor) / (anchor2 - anchor);
    } //check for negative zero, return zero if negative zero


    return -(wholeMonthDiff + adjust) || 0;
  }

  hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
  hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

  function toString() {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
  }

  function toISOString(keepOffset) {
    if (!this.isValid()) {
      return null;
    }

    var utc = keepOffset !== true,
        m = utc ? this.clone().utc() : this;

    if (m.year() < 0 || m.year() > 9999) {
      return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    if (isFunction(Date.prototype.toISOString)) {
      // native implementation is ~50x faster, use it when we can
      if (utc) {
        return this.toDate().toISOString();
      } else {
        return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
      }
    }

    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
  }
  /**
   * Return a human readable representation of a moment that can
   * also be evaluated to get a new moment which is the same
   *
   * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
   */


  function inspect() {
    if (!this.isValid()) {
      return 'moment.invalid(/* ' + this._i + ' */)';
    }

    var func = 'moment',
        zone = '',
        prefix,
        year,
        datetime,
        suffix;

    if (!this.isLocal()) {
      func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
      zone = 'Z';
    }

    prefix = '[' + func + '("]';
    year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
    datetime = '-MM-DD[T]HH:mm:ss.SSS';
    suffix = zone + '[")]';
    return this.format(prefix + year + datetime + suffix);
  }

  function format(inputString) {
    if (!inputString) {
      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }

    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
  }

  function from(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({
        to: this,
        from: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }

  function fromNow(withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
  }

  function to(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({
        from: this,
        to: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }

  function toNow(withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
  } // If passed a locale key, it will set the locale for this
  // instance.  Otherwise, it will return the locale configuration
  // variables for this instance.


  function locale(key) {
    var newLocaleData;

    if (key === undefined) {
      return this._locale._abbr;
    } else {
      newLocaleData = getLocale(key);

      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }

      return this;
    }
  }

  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
    if (key === undefined) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  });

  function localeData() {
    return this._locale;
  }

  var MS_PER_SECOND = 1000,
      MS_PER_MINUTE = 60 * MS_PER_SECOND,
      MS_PER_HOUR = 60 * MS_PER_MINUTE,
      MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

  function mod$1(dividend, divisor) {
    return (dividend % divisor + divisor) % divisor;
  }

  function localStartOfDate(y, m, d) {
    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
      // preserve leap years using a full 400 year cycle, then reset
      return new Date(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
      return new Date(y, m, d).valueOf();
    }
  }

  function utcStartOfDate(y, m, d) {
    // Date.UTC remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
      // preserve leap years using a full 400 year cycle, then reset
      return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
      return Date.UTC(y, m, d);
    }
  }

  function startOf(units) {
    var time, startOfDate;
    units = normalizeUnits(units);

    if (units === undefined || units === 'millisecond' || !this.isValid()) {
      return this;
    }

    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

    switch (units) {
      case 'year':
        time = startOfDate(this.year(), 0, 1);
        break;

      case 'quarter':
        time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
        break;

      case 'month':
        time = startOfDate(this.year(), this.month(), 1);
        break;

      case 'week':
        time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
        break;

      case 'isoWeek':
        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
        break;

      case 'day':
      case 'date':
        time = startOfDate(this.year(), this.month(), this.date());
        break;

      case 'hour':
        time = this._d.valueOf();
        time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
        break;

      case 'minute':
        time = this._d.valueOf();
        time -= mod$1(time, MS_PER_MINUTE);
        break;

      case 'second':
        time = this._d.valueOf();
        time -= mod$1(time, MS_PER_SECOND);
        break;
    }

    this._d.setTime(time);

    hooks.updateOffset(this, true);
    return this;
  }

  function endOf(units) {
    var time, startOfDate;
    units = normalizeUnits(units);

    if (units === undefined || units === 'millisecond' || !this.isValid()) {
      return this;
    }

    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

    switch (units) {
      case 'year':
        time = startOfDate(this.year() + 1, 0, 1) - 1;
        break;

      case 'quarter':
        time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
        break;

      case 'month':
        time = startOfDate(this.year(), this.month() + 1, 1) - 1;
        break;

      case 'week':
        time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
        break;

      case 'isoWeek':
        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
        break;

      case 'day':
      case 'date':
        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
        break;

      case 'hour':
        time = this._d.valueOf();
        time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
        break;

      case 'minute':
        time = this._d.valueOf();
        time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
        break;

      case 'second':
        time = this._d.valueOf();
        time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
        break;
    }

    this._d.setTime(time);

    hooks.updateOffset(this, true);
    return this;
  }

  function valueOf() {
    return this._d.valueOf() - (this._offset || 0) * 60000;
  }

  function unix() {
    return Math.floor(this.valueOf() / 1000);
  }

  function toDate() {
    return new Date(this.valueOf());
  }

  function toArray() {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
  }

  function toObject() {
    var m = this;
    return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds()
    };
  }

  function toJSON() {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
  }

  function isValid$2() {
    return isValid(this);
  }

  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }

  function invalidAt() {
    return getParsingFlags(this).overflow;
  }

  function creationData() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    };
  }

  addFormatToken('N', 0, 0, 'eraAbbr');
  addFormatToken('NN', 0, 0, 'eraAbbr');
  addFormatToken('NNN', 0, 0, 'eraAbbr');
  addFormatToken('NNNN', 0, 0, 'eraName');
  addFormatToken('NNNNN', 0, 0, 'eraNarrow');
  addFormatToken('y', ['y', 1], 'yo', 'eraYear');
  addFormatToken('y', ['yy', 2], 0, 'eraYear');
  addFormatToken('y', ['yyy', 3], 0, 'eraYear');
  addFormatToken('y', ['yyyy', 4], 0, 'eraYear');
  addRegexToken('N', matchEraAbbr);
  addRegexToken('NN', matchEraAbbr);
  addRegexToken('NNN', matchEraAbbr);
  addRegexToken('NNNN', matchEraName);
  addRegexToken('NNNNN', matchEraNarrow);
  addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {
    var era = config._locale.erasParse(input, token, config._strict);

    if (era) {
      getParsingFlags(config).era = era;
    } else {
      getParsingFlags(config).invalidEra = input;
    }
  });
  addRegexToken('y', matchUnsigned);
  addRegexToken('yy', matchUnsigned);
  addRegexToken('yyy', matchUnsigned);
  addRegexToken('yyyy', matchUnsigned);
  addRegexToken('yo', matchEraYearOrdinal);
  addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
  addParseToken(['yo'], function (input, array, config, token) {
    var match;

    if (config._locale._eraYearOrdinalRegex) {
      match = input.match(config._locale._eraYearOrdinalRegex);
    }

    if (config._locale.eraYearOrdinalParse) {
      array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
    } else {
      array[YEAR] = parseInt(input, 10);
    }
  });

  function localeEras(m, format) {
    var i,
        l,
        date,
        eras = this._eras || getLocale('en')._eras;

    for (i = 0, l = eras.length; i < l; ++i) {
      switch (typeof eras[i].since) {
        case 'string':
          // truncate time
          date = hooks(eras[i].since).startOf('day');
          eras[i].since = date.valueOf();
          break;
      }

      switch (typeof eras[i].until) {
        case 'undefined':
          eras[i].until = +Infinity;
          break;

        case 'string':
          // truncate time
          date = hooks(eras[i].until).startOf('day').valueOf();
          eras[i].until = date.valueOf();
          break;
      }
    }

    return eras;
  }

  function localeErasParse(eraName, format, strict) {
    var i,
        l,
        eras = this.eras(),
        name,
        abbr,
        narrow;
    eraName = eraName.toUpperCase();

    for (i = 0, l = eras.length; i < l; ++i) {
      name = eras[i].name.toUpperCase();
      abbr = eras[i].abbr.toUpperCase();
      narrow = eras[i].narrow.toUpperCase();

      if (strict) {
        switch (format) {
          case 'N':
          case 'NN':
          case 'NNN':
            if (abbr === eraName) {
              return eras[i];
            }

            break;

          case 'NNNN':
            if (name === eraName) {
              return eras[i];
            }

            break;

          case 'NNNNN':
            if (narrow === eraName) {
              return eras[i];
            }

            break;
        }
      } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
        return eras[i];
      }
    }
  }

  function localeErasConvertYear(era, year) {
    var dir = era.since <= era.until ? +1 : -1;

    if (year === undefined) {
      return hooks(era.since).year();
    } else {
      return hooks(era.since).year() + (year - era.offset) * dir;
    }
  }

  function getEraName() {
    var i,
        l,
        val,
        eras = this.localeData().eras();

    for (i = 0, l = eras.length; i < l; ++i) {
      // truncate time
      val = this.clone().startOf('day').valueOf();

      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].name;
      }

      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].name;
      }
    }

    return '';
  }

  function getEraNarrow() {
    var i,
        l,
        val,
        eras = this.localeData().eras();

    for (i = 0, l = eras.length; i < l; ++i) {
      // truncate time
      val = this.clone().startOf('day').valueOf();

      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].narrow;
      }

      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].narrow;
      }
    }

    return '';
  }

  function getEraAbbr() {
    var i,
        l,
        val,
        eras = this.localeData().eras();

    for (i = 0, l = eras.length; i < l; ++i) {
      // truncate time
      val = this.clone().startOf('day').valueOf();

      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].abbr;
      }

      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].abbr;
      }
    }

    return '';
  }

  function getEraYear() {
    var i,
        l,
        dir,
        val,
        eras = this.localeData().eras();

    for (i = 0, l = eras.length; i < l; ++i) {
      dir = eras[i].since <= eras[i].until ? +1 : -1; // truncate time

      val = this.clone().startOf('day').valueOf();

      if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
        return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
      }
    }

    return this.year();
  }

  function erasNameRegex(isStrict) {
    if (!hasOwnProp(this, '_erasNameRegex')) {
      computeErasParse.call(this);
    }

    return isStrict ? this._erasNameRegex : this._erasRegex;
  }

  function erasAbbrRegex(isStrict) {
    if (!hasOwnProp(this, '_erasAbbrRegex')) {
      computeErasParse.call(this);
    }

    return isStrict ? this._erasAbbrRegex : this._erasRegex;
  }

  function erasNarrowRegex(isStrict) {
    if (!hasOwnProp(this, '_erasNarrowRegex')) {
      computeErasParse.call(this);
    }

    return isStrict ? this._erasNarrowRegex : this._erasRegex;
  }

  function matchEraAbbr(isStrict, locale) {
    return locale.erasAbbrRegex(isStrict);
  }

  function matchEraName(isStrict, locale) {
    return locale.erasNameRegex(isStrict);
  }

  function matchEraNarrow(isStrict, locale) {
    return locale.erasNarrowRegex(isStrict);
  }

  function matchEraYearOrdinal(isStrict, locale) {
    return locale._eraYearOrdinalRegex || matchUnsigned;
  }

  function computeErasParse() {
    var abbrPieces = [],
        namePieces = [],
        narrowPieces = [],
        mixedPieces = [],
        i,
        l,
        eras = this.eras();

    for (i = 0, l = eras.length; i < l; ++i) {
      namePieces.push(regexEscape(eras[i].name));
      abbrPieces.push(regexEscape(eras[i].abbr));
      narrowPieces.push(regexEscape(eras[i].narrow));
      mixedPieces.push(regexEscape(eras[i].name));
      mixedPieces.push(regexEscape(eras[i].abbr));
      mixedPieces.push(regexEscape(eras[i].narrow));
    }

    this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
    this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
    this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');
  } // FORMATTING


  addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
  });

  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
  }

  addWeekYearFormatToken('gggg', 'weekYear');
  addWeekYearFormatToken('ggggg', 'weekYear');
  addWeekYearFormatToken('GGGG', 'isoWeekYear');
  addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

  addUnitAlias('weekYear', 'gg');
  addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

  addUnitPriority('weekYear', 1);
  addUnitPriority('isoWeekYear', 1); // PARSING

  addRegexToken('G', matchSigned);
  addRegexToken('g', matchSigned);
  addRegexToken('GG', match1to2, match2);
  addRegexToken('gg', match1to2, match2);
  addRegexToken('GGGG', match1to4, match4);
  addRegexToken('gggg', match1to4, match4);
  addRegexToken('GGGGG', match1to6, match6);
  addRegexToken('ggggg', match1to6, match6);
  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
  }); // MOMENTS

  function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
  }

  function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
  }

  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }

  function getISOWeeksInISOWeekYear() {
    return weeksInYear(this.isoWeekYear(), 1, 4);
  }

  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;

    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }

  function getWeeksInWeekYear() {
    var weekInfo = this.localeData()._week;

    return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
  }

  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;

    if (input == null) {
      return weekOfYear(this, dow, doy).year;
    } else {
      weeksTarget = weeksInYear(input, dow, doy);

      if (week > weeksTarget) {
        week = weeksTarget;
      }

      return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
  }

  function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
  } // FORMATTING


  addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

  addUnitAlias('quarter', 'Q'); // PRIORITY

  addUnitPriority('quarter', 7); // PARSING

  addRegexToken('Q', match1);
  addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  }); // MOMENTS

  function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  } // FORMATTING


  addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

  addUnitAlias('date', 'D'); // PRIORITY

  addUnitPriority('date', 9); // PARSING

  addRegexToken('D', match1to2);
  addRegexToken('DD', match1to2, match2);
  addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
  });
  addParseToken(['D', 'DD'], DATE);
  addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
  }); // MOMENTS

  var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

  addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

  addUnitPriority('dayOfYear', 4); // PARSING

  addRegexToken('DDD', match1to3);
  addRegexToken('DDDD', match3);
  addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
  }); // HELPERS
  // MOMENTS

  function getSetDayOfYear(input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
  } // FORMATTING


  addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

  addUnitAlias('minute', 'm'); // PRIORITY

  addUnitPriority('minute', 14); // PARSING

  addRegexToken('m', match1to2);
  addRegexToken('mm', match1to2, match2);
  addParseToken(['m', 'mm'], MINUTE); // MOMENTS

  var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

  addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

  addUnitAlias('second', 's'); // PRIORITY

  addUnitPriority('second', 15); // PARSING

  addRegexToken('s', match1to2);
  addRegexToken('ss', match1to2, match2);
  addParseToken(['s', 'ss'], SECOND); // MOMENTS

  var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

  addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ['SSS', 3], 0, 'millisecond');
  addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
  });
  addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
  });
  addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
  });
  addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
  }); // ALIASES

  addUnitAlias('millisecond', 'ms'); // PRIORITY

  addUnitPriority('millisecond', 16); // PARSING

  addRegexToken('S', match1to3, match1);
  addRegexToken('SS', match1to3, match2);
  addRegexToken('SSS', match1to3, match3);
  var token, getSetMillisecond;

  for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
  }

  function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
  }

  for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
  }

  getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

  addFormatToken('z', 0, 0, 'zoneAbbr');
  addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

  function getZoneAbbr() {
    return this._isUTC ? 'UTC' : '';
  }

  function getZoneName() {
    return this._isUTC ? 'Coordinated Universal Time' : '';
  }

  var proto = Moment.prototype;
  proto.add = add;
  proto.calendar = calendar$1;
  proto.clone = clone;
  proto.diff = diff;
  proto.endOf = endOf;
  proto.format = format;
  proto.from = from;
  proto.fromNow = fromNow;
  proto.to = to;
  proto.toNow = toNow;
  proto.get = stringGet;
  proto.invalidAt = invalidAt;
  proto.isAfter = isAfter;
  proto.isBefore = isBefore;
  proto.isBetween = isBetween;
  proto.isSame = isSame;
  proto.isSameOrAfter = isSameOrAfter;
  proto.isSameOrBefore = isSameOrBefore;
  proto.isValid = isValid$2;
  proto.lang = lang;
  proto.locale = locale;
  proto.localeData = localeData;
  proto.max = prototypeMax;
  proto.min = prototypeMin;
  proto.parsingFlags = parsingFlags;
  proto.set = stringSet;
  proto.startOf = startOf;
  proto.subtract = subtract;
  proto.toArray = toArray;
  proto.toObject = toObject;
  proto.toDate = toDate;
  proto.toISOString = toISOString;
  proto.inspect = inspect;

  if (typeof Symbol !== 'undefined' && Symbol["for"] != null) {
    proto[Symbol["for"]('nodejs.util.inspect.custom')] = function () {
      return 'Moment<' + this.format() + '>';
    };
  }

  proto.toJSON = toJSON;
  proto.toString = toString;
  proto.unix = unix;
  proto.valueOf = valueOf;
  proto.creationData = creationData;
  proto.eraName = getEraName;
  proto.eraNarrow = getEraNarrow;
  proto.eraAbbr = getEraAbbr;
  proto.eraYear = getEraYear;
  proto.year = getSetYear;
  proto.isLeapYear = getIsLeapYear;
  proto.weekYear = getSetWeekYear;
  proto.isoWeekYear = getSetISOWeekYear;
  proto.quarter = proto.quarters = getSetQuarter;
  proto.month = getSetMonth;
  proto.daysInMonth = getDaysInMonth;
  proto.week = proto.weeks = getSetWeek;
  proto.isoWeek = proto.isoWeeks = getSetISOWeek;
  proto.weeksInYear = getWeeksInYear;
  proto.weeksInWeekYear = getWeeksInWeekYear;
  proto.isoWeeksInYear = getISOWeeksInYear;
  proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
  proto.date = getSetDayOfMonth;
  proto.day = proto.days = getSetDayOfWeek;
  proto.weekday = getSetLocaleDayOfWeek;
  proto.isoWeekday = getSetISODayOfWeek;
  proto.dayOfYear = getSetDayOfYear;
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  proto.utcOffset = getSetOffset;
  proto.utc = setOffsetToUTC;
  proto.local = setOffsetToLocal;
  proto.parseZone = setOffsetToParsedOffset;
  proto.hasAlignedHourOffset = hasAlignedHourOffset;
  proto.isDST = isDaylightSavingTime;
  proto.isLocal = isLocal;
  proto.isUtcOffset = isUtcOffset;
  proto.isUtc = isUtc;
  proto.isUTC = isUtc;
  proto.zoneAbbr = getZoneAbbr;
  proto.zoneName = getZoneName;
  proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
  proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
  proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
  proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
  proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

  function createUnix(input) {
    return createLocal(input * 1000);
  }

  function createInZone() {
    return createLocal.apply(null, arguments).parseZone();
  }

  function preParsePostFormat(string) {
    return string;
  }

  var proto$1 = Locale.prototype;
  proto$1.calendar = calendar;
  proto$1.longDateFormat = longDateFormat;
  proto$1.invalidDate = invalidDate;
  proto$1.ordinal = ordinal;
  proto$1.preparse = preParsePostFormat;
  proto$1.postformat = preParsePostFormat;
  proto$1.relativeTime = relativeTime;
  proto$1.pastFuture = pastFuture;
  proto$1.set = set;
  proto$1.eras = localeEras;
  proto$1.erasParse = localeErasParse;
  proto$1.erasConvertYear = localeErasConvertYear;
  proto$1.erasAbbrRegex = erasAbbrRegex;
  proto$1.erasNameRegex = erasNameRegex;
  proto$1.erasNarrowRegex = erasNarrowRegex;
  proto$1.months = localeMonths;
  proto$1.monthsShort = localeMonthsShort;
  proto$1.monthsParse = localeMonthsParse;
  proto$1.monthsRegex = monthsRegex;
  proto$1.monthsShortRegex = monthsShortRegex;
  proto$1.week = localeWeek;
  proto$1.firstDayOfYear = localeFirstDayOfYear;
  proto$1.firstDayOfWeek = localeFirstDayOfWeek;
  proto$1.weekdays = localeWeekdays;
  proto$1.weekdaysMin = localeWeekdaysMin;
  proto$1.weekdaysShort = localeWeekdaysShort;
  proto$1.weekdaysParse = localeWeekdaysParse;
  proto$1.weekdaysRegex = weekdaysRegex;
  proto$1.weekdaysShortRegex = weekdaysShortRegex;
  proto$1.weekdaysMinRegex = weekdaysMinRegex;
  proto$1.isPM = localeIsPM;
  proto$1.meridiem = localeMeridiem;

  function get$1(format, index, field, setter) {
    var locale = getLocale(),
        utc = createUTC().set(setter, index);
    return locale[field](utc, format);
  }

  function listMonthsImpl(format, index, field) {
    if (isNumber(format)) {
      index = format;
      format = undefined;
    }

    format = format || '';

    if (index != null) {
      return get$1(format, index, field, 'month');
    }

    var i,
        out = [];

    for (i = 0; i < 12; i++) {
      out[i] = get$1(format, i, field, 'month');
    }

    return out;
  } // ()
  // (5)
  // (fmt, 5)
  // (fmt)
  // (true)
  // (true, 5)
  // (true, fmt, 5)
  // (true, fmt)


  function listWeekdaysImpl(localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';
    } else {
      format = localeSorted;
      index = format;
      localeSorted = false;

      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0,
        i,
        out = [];

    if (index != null) {
      return get$1(format, (index + shift) % 7, field, 'day');
    }

    for (i = 0; i < 7; i++) {
      out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }

    return out;
  }

  function listMonths(format, index) {
    return listMonthsImpl(format, index, 'months');
  }

  function listMonthsShort(format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
  }

  function listWeekdays(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
  }

  function listWeekdaysShort(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
  }

  function listWeekdaysMin(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
  }

  getSetGlobalLocale('en', {
    eras: [{
      since: '0001-01-01',
      until: +Infinity,
      offset: 1,
      name: 'Anno Domini',
      narrow: 'AD',
      abbr: 'AD'
    }, {
      since: '0000-12-31',
      until: -Infinity,
      offset: 1,
      name: 'Before Christ',
      narrow: 'BC',
      abbr: 'BC'
    }],
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function ordinal(number) {
      var b = number % 10,
          output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  }); // Side effect imports

  hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
  hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
  var mathAbs = Math.abs;

  function abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }

  function addSubtract$1(duration, input, value, direction) {
    var other = createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  } // supports only 2.0-style add(1, 's') or add(duration)


  function add$1(input, value) {
    return addSubtract$1(this, input, value, 1);
  } // supports only 2.0-style subtract(1, 's') or subtract(duration)


  function subtract$1(input, value) {
    return addSubtract$1(this, input, value, -1);
  }

  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }

  function bubble() {
    var milliseconds = this._milliseconds,
        days = this._days,
        months = this._months,
        data = this._data,
        seconds,
        minutes,
        hours,
        years,
        monthsFromDays; // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166

    if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
      days = 0;
      months = 0;
    } // The following code bubbles up values, see the tests for
    // examples of what that means.


    data.milliseconds = milliseconds % 1000;
    seconds = absFloor(milliseconds / 1000);
    data.seconds = seconds % 60;
    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;
    hours = absFloor(minutes / 60);
    data.hours = hours % 24;
    days += absFloor(hours / 24); // convert days to months

    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

    years = absFloor(months / 12);
    months %= 12;
    data.days = days;
    data.months = months;
    data.years = years;
    return this;
  }

  function daysToMonths(days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
  }

  function monthsToDays(months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
  }

  function as(units) {
    if (!this.isValid()) {
      return NaN;
    }

    var days,
        months,
        milliseconds = this._milliseconds;
    units = normalizeUnits(units);

    if (units === 'month' || units === 'quarter' || units === 'year') {
      days = this._days + milliseconds / 864e5;
      months = this._months + daysToMonths(days);

      switch (units) {
        case 'month':
          return months;

        case 'quarter':
          return months / 3;

        case 'year':
          return months / 12;
      }
    } else {
      // handle milliseconds separately because of floating point math errors (issue #1867)
      days = this._days + Math.round(monthsToDays(this._months));

      switch (units) {
        case 'week':
          return days / 7 + milliseconds / 6048e5;

        case 'day':
          return days + milliseconds / 864e5;

        case 'hour':
          return days * 24 + milliseconds / 36e5;

        case 'minute':
          return days * 1440 + milliseconds / 6e4;

        case 'second':
          return days * 86400 + milliseconds / 1000;
        // Math.floor prevents floating point math errors here

        case 'millisecond':
          return Math.floor(days * 864e5) + milliseconds;

        default:
          throw new Error('Unknown unit ' + units);
      }
    }
  } // TODO: Use this.as('ms')?


  function valueOf$1() {
    if (!this.isValid()) {
      return NaN;
    }

    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
  }

  function makeAs(alias) {
    return function () {
      return this.as(alias);
    };
  }

  var asMilliseconds = makeAs('ms'),
      asSeconds = makeAs('s'),
      asMinutes = makeAs('m'),
      asHours = makeAs('h'),
      asDays = makeAs('d'),
      asWeeks = makeAs('w'),
      asMonths = makeAs('M'),
      asQuarters = makeAs('Q'),
      asYears = makeAs('y');

  function clone$1() {
    return createDuration(this);
  }

  function get$2(units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
  }

  function makeGetter(name) {
    return function () {
      return this.isValid() ? this._data[name] : NaN;
    };
  }

  var milliseconds = makeGetter('milliseconds'),
      seconds = makeGetter('seconds'),
      minutes = makeGetter('minutes'),
      hours = makeGetter('hours'),
      days = makeGetter('days'),
      months = makeGetter('months'),
      years = makeGetter('years');

  function weeks() {
    return absFloor(this.days() / 7);
  }

  var round = Math.round,
      thresholds = {
    ss: 44,
    // a few seconds to seconds
    s: 45,
    // seconds to minute
    m: 45,
    // minutes to hour
    h: 22,
    // hours to day
    d: 26,
    // days to month/week
    w: null,
    // weeks to month
    M: 11 // months to year

  }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }

  function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
    var duration = createDuration(posNegDuration).abs(),
        seconds = round(duration.as('s')),
        minutes = round(duration.as('m')),
        hours = round(duration.as('h')),
        days = round(duration.as('d')),
        months = round(duration.as('M')),
        weeks = round(duration.as('w')),
        years = round(duration.as('y')),
        a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days];

    if (thresholds.w != null) {
      a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && ['ww', weeks];
    }

    a = a || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
  } // This function allows you to set the rounding function for relative time strings


  function getSetRelativeTimeRounding(roundingFunction) {
    if (roundingFunction === undefined) {
      return round;
    }

    if (typeof roundingFunction === 'function') {
      round = roundingFunction;
      return true;
    }

    return false;
  } // This function allows you to set a threshold for relative time strings


  function getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === undefined) {
      return false;
    }

    if (limit === undefined) {
      return thresholds[threshold];
    }

    thresholds[threshold] = limit;

    if (threshold === 's') {
      thresholds.ss = limit - 1;
    }

    return true;
  }

  function humanize(argWithSuffix, argThresholds) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }

    var withSuffix = false,
        th = thresholds,
        locale,
        output;

    if (typeof argWithSuffix === 'object') {
      argThresholds = argWithSuffix;
      argWithSuffix = false;
    }

    if (typeof argWithSuffix === 'boolean') {
      withSuffix = argWithSuffix;
    }

    if (typeof argThresholds === 'object') {
      th = Object.assign({}, thresholds, argThresholds);

      if (argThresholds.s != null && argThresholds.ss == null) {
        th.ss = argThresholds.s - 1;
      }
    }

    locale = this.localeData();
    output = relativeTime$1(this, !withSuffix, th, locale);

    if (withSuffix) {
      output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
  }

  var abs$1 = Math.abs;

  function sign(x) {
    return (x > 0) - (x < 0) || +x;
  }

  function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000,
        days = abs$1(this._days),
        months = abs$1(this._months),
        minutes,
        hours,
        years,
        s,
        total = this.asSeconds(),
        totalSign,
        ymSign,
        daysSign,
        hmsSign;

    if (!total) {
      // this is the same as C#'s (Noda) and python (isodate)...
      // but not other JS (goog.date)
      return 'P0D';
    } // 3600 seconds -> 60 minutes -> 1 hour


    minutes = absFloor(seconds / 60);
    hours = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60; // 12 months -> 1 year

    years = absFloor(months / 12);
    months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

    s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    totalSign = total < 0 ? '-' : '';
    ymSign = sign(this._months) !== sign(total) ? '-' : '';
    daysSign = sign(this._days) !== sign(total) ? '-' : '';
    hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
    return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');
  }

  var proto$2 = Duration.prototype;
  proto$2.isValid = isValid$1;
  proto$2.abs = abs;
  proto$2.add = add$1;
  proto$2.subtract = subtract$1;
  proto$2.as = as;
  proto$2.asMilliseconds = asMilliseconds;
  proto$2.asSeconds = asSeconds;
  proto$2.asMinutes = asMinutes;
  proto$2.asHours = asHours;
  proto$2.asDays = asDays;
  proto$2.asWeeks = asWeeks;
  proto$2.asMonths = asMonths;
  proto$2.asQuarters = asQuarters;
  proto$2.asYears = asYears;
  proto$2.valueOf = valueOf$1;
  proto$2._bubble = bubble;
  proto$2.clone = clone$1;
  proto$2.get = get$2;
  proto$2.milliseconds = milliseconds;
  proto$2.seconds = seconds;
  proto$2.minutes = minutes;
  proto$2.hours = hours;
  proto$2.days = days;
  proto$2.weeks = weeks;
  proto$2.months = months;
  proto$2.years = years;
  proto$2.humanize = humanize;
  proto$2.toISOString = toISOString$1;
  proto$2.toString = toISOString$1;
  proto$2.toJSON = toISOString$1;
  proto$2.locale = locale;
  proto$2.localeData = localeData;
  proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
  proto$2.lang = lang; // FORMATTING

  addFormatToken('X', 0, 0, 'unix');
  addFormatToken('x', 0, 0, 'valueOf'); // PARSING

  addRegexToken('x', matchSigned);
  addRegexToken('X', matchTimestamp);
  addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input) * 1000);
  });
  addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
  }); //! moment.js

  hooks.version = '2.29.1';
  setHookCallback(createLocal);
  hooks.fn = proto;
  hooks.min = min;
  hooks.max = max;
  hooks.now = now;
  hooks.utc = createUTC;
  hooks.unix = createUnix;
  hooks.months = listMonths;
  hooks.isDate = isDate;
  hooks.locale = getSetGlobalLocale;
  hooks.invalid = createInvalid;
  hooks.duration = createDuration;
  hooks.isMoment = isMoment;
  hooks.weekdays = listWeekdays;
  hooks.parseZone = createInZone;
  hooks.localeData = getLocale;
  hooks.isDuration = isDuration;
  hooks.monthsShort = listMonthsShort;
  hooks.weekdaysMin = listWeekdaysMin;
  hooks.defineLocale = defineLocale;
  hooks.updateLocale = updateLocale;
  hooks.locales = listLocales;
  hooks.weekdaysShort = listWeekdaysShort;
  hooks.normalizeUnits = normalizeUnits;
  hooks.relativeTimeRounding = getSetRelativeTimeRounding;
  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
  hooks.calendarFormat = getCalendarFormat;
  hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

  hooks.HTML5_FMT = {
    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
    // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
    // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
    // <input type="datetime-local" step="0.001" />
    DATE: 'YYYY-MM-DD',
    // <input type="date" />
    TIME: 'HH:mm',
    // <input type="time" />
    TIME_SECONDS: 'HH:mm:ss',
    // <input type="time" step="1" />
    TIME_MS: 'HH:mm:ss.SSS',
    // <input type="time" step="0.001" />
    WEEK: 'GGGG-[W]WW',
    // <input type="week" />
    MONTH: 'YYYY-MM' // <input type="month" />

  };
  return hooks;
});

/***/ }),

/***/ 39945:
/***/ ((module) => {

"use strict";


var ensureCallable = function ensureCallable(fn) {
  if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
  return fn;
};

var byObserver = function byObserver(Observer) {
  var node = document.createTextNode(''),
      queue,
      currentQueue,
      i = 0;
  new Observer(function () {
    var callback;

    if (!queue) {
      if (!currentQueue) return;
      queue = currentQueue;
    } else if (currentQueue) {
      queue = currentQueue.concat(queue);
    }

    currentQueue = queue;
    queue = null;

    if (typeof currentQueue === 'function') {
      callback = currentQueue;
      currentQueue = null;
      callback();
      return;
    }

    node.data = i = ++i % 2; // Invoke other batch, to handle leftover callbacks in case of crash

    while (currentQueue) {
      callback = currentQueue.shift();
      if (!currentQueue.length) currentQueue = null;
      callback();
    }
  }).observe(node, {
    characterData: true
  });
  return function (fn) {
    ensureCallable(fn);

    if (queue) {
      if (typeof queue === 'function') queue = [queue, fn];else queue.push(fn);
      return;
    }

    queue = fn;
    node.data = i = ++i % 2;
  };
};

module.exports = function () {
  // Node.js
  if (typeof process === 'object' && process && typeof process.nextTick === 'function') {
    return process.nextTick;
  } // queueMicrotask


  if (typeof queueMicrotask === "function") {
    return function (cb) {
      queueMicrotask(ensureCallable(cb));
    };
  } // MutationObserver


  if (typeof document === 'object' && document) {
    if (typeof MutationObserver === 'function') return byObserver(MutationObserver);
    if (typeof WebKitMutationObserver === 'function') return byObserver(WebKitMutationObserver);
  } // W3C Draft
  // http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html


  if (typeof setImmediate === 'function') {
    return function (cb) {
      setImmediate(ensureCallable(cb));
    };
  } // Wide available standard


  if (typeof setTimeout === 'function' || typeof setTimeout === 'object') {
    return function (cb) {
      setTimeout(ensureCallable(cb), 0);
    };
  }

  return null;
}();

/***/ }),

/***/ 62967:
/***/ ((module) => {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),

/***/ 18727:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var PENDING = 'pending';
var SETTLED = 'settled';
var FULFILLED = 'fulfilled';
var REJECTED = 'rejected';

var NOOP = function NOOP() {};

var isNode = typeof __webpack_require__.g !== 'undefined' && typeof __webpack_require__.g.process !== 'undefined' && typeof __webpack_require__.g.process.emit === 'function';
var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
var asyncQueue = [];
var asyncTimer;

function asyncFlush() {
  // run promise callbacks
  for (var i = 0; i < asyncQueue.length; i++) {
    asyncQueue[i][0](asyncQueue[i][1]);
  } // reset async asyncQueue


  asyncQueue = [];
  asyncTimer = false;
}

function asyncCall(callback, arg) {
  asyncQueue.push([callback, arg]);

  if (!asyncTimer) {
    asyncTimer = true;
    asyncSetTimer(asyncFlush, 0);
  }
}

function invokeResolver(resolver, promise) {
  function resolvePromise(value) {
    resolve(promise, value);
  }

  function rejectPromise(reason) {
    reject(promise, reason);
  }

  try {
    resolver(resolvePromise, rejectPromise);
  } catch (e) {
    rejectPromise(e);
  }
}

function invokeCallback(subscriber) {
  var owner = subscriber.owner;
  var settled = owner._state;
  var value = owner._data;
  var callback = subscriber[settled];
  var promise = subscriber.then;

  if (typeof callback === 'function') {
    settled = FULFILLED;

    try {
      value = callback(value);
    } catch (e) {
      reject(promise, e);
    }
  }

  if (!handleThenable(promise, value)) {
    if (settled === FULFILLED) {
      resolve(promise, value);
    }

    if (settled === REJECTED) {
      reject(promise, value);
    }
  }
}

function handleThenable(promise, value) {
  var resolved;

  try {
    if (promise === value) {
      throw new TypeError('A promises callback cannot return that same promise.');
    }

    if (value && (typeof value === 'function' || typeof value === 'object')) {
      // then should be retrieved only once
      var then = value.then;

      if (typeof then === 'function') {
        then.call(value, function (val) {
          if (!resolved) {
            resolved = true;

            if (value === val) {
              fulfill(promise, val);
            } else {
              resolve(promise, val);
            }
          }
        }, function (reason) {
          if (!resolved) {
            resolved = true;
            reject(promise, reason);
          }
        });
        return true;
      }
    }
  } catch (e) {
    if (!resolved) {
      reject(promise, e);
    }

    return true;
  }

  return false;
}

function resolve(promise, value) {
  if (promise === value || !handleThenable(promise, value)) {
    fulfill(promise, value);
  }
}

function fulfill(promise, value) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = value;
    asyncCall(publishFulfillment, promise);
  }
}

function reject(promise, reason) {
  if (promise._state === PENDING) {
    promise._state = SETTLED;
    promise._data = reason;
    asyncCall(publishRejection, promise);
  }
}

function publish(promise) {
  promise._then = promise._then.forEach(invokeCallback);
}

function publishFulfillment(promise) {
  promise._state = FULFILLED;
  publish(promise);
}

function publishRejection(promise) {
  promise._state = REJECTED;
  publish(promise);

  if (!promise._handled && isNode) {
    __webpack_require__.g.process.emit('unhandledRejection', promise._data, promise);
  }
}

function notifyRejectionHandled(promise) {
  __webpack_require__.g.process.emit('rejectionHandled', promise);
}
/**
 * @class
 */


function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('Promise resolver ' + resolver + ' is not a function');
  }

  if (this instanceof Promise === false) {
    throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
  }

  this._then = [];
  invokeResolver(resolver, this);
}

Promise.prototype = {
  constructor: Promise,
  _state: PENDING,
  _then: null,
  _data: undefined,
  _handled: false,
  then: function then(onFulfillment, onRejection) {
    var subscriber = {
      owner: this,
      then: new this.constructor(NOOP),
      fulfilled: onFulfillment,
      rejected: onRejection
    };

    if ((onRejection || onFulfillment) && !this._handled) {
      this._handled = true;

      if (this._state === REJECTED && isNode) {
        asyncCall(notifyRejectionHandled, this);
      }
    }

    if (this._state === FULFILLED || this._state === REJECTED) {
      // already resolved, call callback async
      asyncCall(invokeCallback, subscriber);
    } else {
      // subscribe
      this._then.push(subscriber);
    }

    return subscriber.then;
  },
  "catch": function _catch(onRejection) {
    return this.then(null, onRejection);
  }
};

Promise.all = function (promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError('You must pass an array to Promise.all().');
  }

  return new Promise(function (resolve, reject) {
    var results = [];
    var remaining = 0;

    function resolver(index) {
      remaining++;
      return function (value) {
        results[index] = value;

        if (! --remaining) {
          resolve(results);
        }
      };
    }

    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];

      if (promise && typeof promise.then === 'function') {
        promise.then(resolver(i), reject);
      } else {
        results[i] = promise;
      }
    }

    if (!remaining) {
      resolve(results);
    }
  });
};

Promise.race = function (promises) {
  if (!Array.isArray(promises)) {
    throw new TypeError('You must pass an array to Promise.race().');
  }

  return new Promise(function (resolve, reject) {
    for (var i = 0, promise; i < promises.length; i++) {
      promise = promises[i];

      if (promise && typeof promise.then === 'function') {
        promise.then(resolve, reject);
      } else {
        resolve(promise);
      }
    }
  });
};

Promise.resolve = function (value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function (resolve) {
    resolve(value);
  });
};

Promise.reject = function (reason) {
  return new Promise(function (resolve, reject) {
    reject(reason);
  });
};

module.exports = Promise;

/***/ }),

/***/ 31730:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var aa = __webpack_require__(43745),
    m = __webpack_require__(62967),
    r = __webpack_require__(79409);

function y(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) {
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  }

  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}

if (!aa) throw Error(y(227));
var ba = new Set(),
    ca = {};

function da(a, b) {
  ea(a, b);
  ea(a + "Capture", b);
}

function ea(a, b) {
  ca[a] = b;

  for (a = 0; a < b.length; a++) {
    ba.add(b[a]);
  }
}

var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
    ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    ia = Object.prototype.hasOwnProperty,
    ja = {},
    ka = {};

function la(a) {
  if (ia.call(ka, a)) return !0;
  if (ia.call(ja, a)) return !1;
  if (ha.test(a)) return ka[a] = !0;
  ja[a] = !0;
  return !1;
}

function ma(a, b, c, d) {
  if (null !== c && 0 === c.type) return !1;

  switch (typeof b) {
    case "function":
    case "symbol":
      return !0;

    case "boolean":
      if (d) return !1;
      if (null !== c) return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return "data-" !== a && "aria-" !== a;

    default:
      return !1;
  }
}

function na(a, b, c, d) {
  if (null === b || "undefined" === typeof b || ma(a, b, c, d)) return !0;
  if (d) return !1;
  if (null !== c) switch (c.type) {
    case 3:
      return !b;

    case 4:
      return !1 === b;

    case 5:
      return isNaN(b);

    case 6:
      return isNaN(b) || 1 > b;
  }
  return !1;
}

function B(a, b, c, d, e, f, g) {
  this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f;
  this.removeEmptyString = g;
}

var D = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
  D[a] = new B(a, 0, !1, a, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
  var b = a[0];
  D[b] = new B(b, 1, !1, a[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
  D[a] = new B(a, 2, !1, a.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
  D[a] = new B(a, 2, !1, a, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
  D[a] = new B(a, 3, !1, a.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function (a) {
  D[a] = new B(a, 3, !0, a, null, !1, !1);
});
["capture", "download"].forEach(function (a) {
  D[a] = new B(a, 4, !1, a, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (a) {
  D[a] = new B(a, 6, !1, a, null, !1, !1);
});
["rowSpan", "start"].forEach(function (a) {
  D[a] = new B(a, 5, !1, a.toLowerCase(), null, !1, !1);
});
var oa = /[\-:]([a-z])/g;

function pa(a) {
  return a[1].toUpperCase();
}

"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, !1, a, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (a) {
  D[a] = new B(a, 1, !1, a.toLowerCase(), null, !1, !1);
});
D.xlinkHref = new B("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function (a) {
  D[a] = new B(a, 1, !1, a.toLowerCase(), null, !0, !0);
});

function qa(a, b, c, d) {
  var e = D.hasOwnProperty(b) ? D[b] : null;
  var f = null !== e ? 0 === e.type : d ? !1 : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? !1 : !0;
  f || (na(b, c, e, d) && (c = null), d || null === e ? la(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && !0 === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
}

var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    sa = 60103,
    ta = 60106,
    ua = 60107,
    wa = 60108,
    xa = 60114,
    ya = 60109,
    za = 60110,
    Aa = 60112,
    Ba = 60113,
    Ca = 60120,
    Da = 60115,
    Ea = 60116,
    Fa = 60121,
    Ga = 60128,
    Ha = 60129,
    Ia = 60130,
    Ja = 60131;

if ("function" === typeof Symbol && Symbol["for"]) {
  var E = Symbol["for"];
  sa = E("react.element");
  ta = E("react.portal");
  ua = E("react.fragment");
  wa = E("react.strict_mode");
  xa = E("react.profiler");
  ya = E("react.provider");
  za = E("react.context");
  Aa = E("react.forward_ref");
  Ba = E("react.suspense");
  Ca = E("react.suspense_list");
  Da = E("react.memo");
  Ea = E("react.lazy");
  Fa = E("react.block");
  E("react.scope");
  Ga = E("react.opaque.id");
  Ha = E("react.debug_trace_mode");
  Ia = E("react.offscreen");
  Ja = E("react.legacy_hidden");
}

var Ka = "function" === typeof Symbol && Symbol.iterator;

function La(a) {
  if (null === a || "object" !== typeof a) return null;
  a = Ka && a[Ka] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}

var Ma;

function Na(a) {
  if (void 0 === Ma) try {
    throw Error();
  } catch (c) {
    var b = c.stack.trim().match(/\n( *(at )?)/);
    Ma = b && b[1] || "";
  }
  return "\n" + Ma + a;
}

var Oa = !1;

function Pa(a, b) {
  if (!a || Oa) return "";
  Oa = !0;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;

  try {
    if (b) {
      if (b = function b() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", {
        set: function set() {
          throw Error();
        }
      }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (k) {
          var d = k;
        }

        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (k) {
          d = k;
        }

        a.call(b.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (k) {
        d = k;
      }

      a();
    }
  } catch (k) {
    if (k && d && "string" === typeof k.stack) {
      for (var e = k.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h];) {
        h--;
      }

      for (; 1 <= g && 0 <= h; g--, h--) {
        if (e[g] !== f[h]) {
          if (1 !== g || 1 !== h) {
            do {
              if (g--, h--, 0 > h || e[g] !== f[h]) return "\n" + e[g].replace(" at new ", " at ");
            } while (1 <= g && 0 <= h);
          }

          break;
        }
      }
    }
  } finally {
    Oa = !1, Error.prepareStackTrace = c;
  }

  return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
}

function Qa(a) {
  switch (a.tag) {
    case 5:
      return Na(a.type);

    case 16:
      return Na("Lazy");

    case 13:
      return Na("Suspense");

    case 19:
      return Na("SuspenseList");

    case 0:
    case 2:
    case 15:
      return a = Pa(a.type, !1), a;

    case 11:
      return a = Pa(a.type.render, !1), a;

    case 22:
      return a = Pa(a.type._render, !1), a;

    case 1:
      return a = Pa(a.type, !0), a;

    default:
      return "";
  }
}

function Ra(a) {
  if (null == a) return null;
  if ("function" === typeof a) return a.displayName || a.name || null;
  if ("string" === typeof a) return a;

  switch (a) {
    case ua:
      return "Fragment";

    case ta:
      return "Portal";

    case xa:
      return "Profiler";

    case wa:
      return "StrictMode";

    case Ba:
      return "Suspense";

    case Ca:
      return "SuspenseList";
  }

  if ("object" === typeof a) switch (a.$$typeof) {
    case za:
      return (a.displayName || "Context") + ".Consumer";

    case ya:
      return (a._context.displayName || "Context") + ".Provider";

    case Aa:
      var b = a.render;
      b = b.displayName || b.name || "";
      return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");

    case Da:
      return Ra(a.type);

    case Fa:
      return Ra(a._render);

    case Ea:
      b = a._payload;
      a = a._init;

      try {
        return Ra(a(b));
      } catch (c) {}

  }
  return null;
}

function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a;

    default:
      return "";
  }
}

function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}

function Ua(a) {
  var b = Ta(a) ? "checked" : "value",
      c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
      d = "" + a[b];

  if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
    var e = c.get,
        f = c.set;
    Object.defineProperty(a, b, {
      configurable: !0,
      get: function get() {
        return e.call(this);
      },
      set: function set(a) {
        d = "" + a;
        f.call(this, a);
      }
    });
    Object.defineProperty(a, b, {
      enumerable: c.enumerable
    });
    return {
      getValue: function getValue() {
        return d;
      },
      setValue: function setValue(a) {
        d = "" + a;
      },
      stopTracking: function stopTracking() {
        a._valueTracker = null;
        delete a[b];
      }
    };
  }
}

function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}

function Wa(a) {
  if (!a) return !1;
  var b = a._valueTracker;
  if (!b) return !0;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), !0) : !1;
}

function Xa(a) {
  a = a || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a) return null;

  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}

function Ya(a, b) {
  var c = b.checked;
  return m({}, b, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: null != c ? c : a._wrapperState.initialChecked
  });
}

function Za(a, b) {
  var c = null == b.defaultValue ? "" : b.defaultValue,
      d = null != b.checked ? b.checked : b.defaultChecked;
  c = Sa(null != b.value ? b.value : c);
  a._wrapperState = {
    initialChecked: d,
    initialValue: c,
    controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
  };
}

function $a(a, b) {
  b = b.checked;
  null != b && qa(a, "checked", b, !1);
}

function ab(a, b) {
  $a(a, b);
  var c = Sa(b.value),
      d = b.type;
  if (null != c) {
    if ("number" === d) {
      if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
  } else if ("submit" === d || "reset" === d) {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
  null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}

function cb(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }

  c = a.name;
  "" !== c && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  "" !== c && (a.name = c);
}

function bb(a, b, c) {
  if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}

function db(a) {
  var b = "";
  aa.Children.forEach(a, function (a) {
    null != a && (b += a);
  });
  return b;
}

function eb(a, b) {
  a = m({
    children: void 0
  }, b);
  if (b = db(b.children)) a.children = b;
  return a;
}

function fb(a, b, c, d) {
  a = a.options;

  if (b) {
    b = {};

    for (var e = 0; e < c.length; e++) {
      b["$" + c[e]] = !0;
    }

    for (c = 0; c < a.length; c++) {
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
    }
  } else {
    c = "" + Sa(c);
    b = null;

    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = !0;
        d && (a[e].defaultSelected = !0);
        return;
      }

      null !== b || a[e].disabled || (b = a[e]);
    }

    null !== b && (b.selected = !0);
  }
}

function gb(a, b) {
  if (null != b.dangerouslySetInnerHTML) throw Error(y(91));
  return m({}, b, {
    value: void 0,
    defaultValue: void 0,
    children: "" + a._wrapperState.initialValue
  });
}

function hb(a, b) {
  var c = b.value;

  if (null == c) {
    c = b.children;
    b = b.defaultValue;

    if (null != c) {
      if (null != b) throw Error(y(92));

      if (Array.isArray(c)) {
        if (!(1 >= c.length)) throw Error(y(93));
        c = c[0];
      }

      b = c;
    }

    null == b && (b = "");
    c = b;
  }

  a._wrapperState = {
    initialValue: Sa(c)
  };
}

function ib(a, b) {
  var c = Sa(b.value),
      d = Sa(b.defaultValue);
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
  null != d && (a.defaultValue = "" + d);
}

function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
}

var kb = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg"
};

function lb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";

    case "math":
      return "http://www.w3.org/1998/Math/MathML";

    default:
      return "http://www.w3.org/1999/xhtml";
  }
}

function mb(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? lb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}

var nb,
    ob = function (a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function () {
      return a(b, c, d, e);
    });
  } : a;
}(function (a, b) {
  if (a.namespaceURI !== kb.svg || "innerHTML" in a) a.innerHTML = b;else {
    nb = nb || document.createElement("div");
    nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";

    for (b = nb.firstChild; a.firstChild;) {
      a.removeChild(a.firstChild);
    }

    for (; b.firstChild;) {
      a.appendChild(b.firstChild);
    }
  }
});

function pb(a, b) {
  if (b) {
    var c = a.firstChild;

    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }

  a.textContent = b;
}

var qb = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
},
    rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function (a) {
  rb.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    qb[b] = qb[a];
  });
});

function sb(a, b, c) {
  return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
}

function tb(a, b) {
  a = a.style;

  for (var c in b) {
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"),
          e = sb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
  }
}

var ub = m({
  menuitem: !0
}, {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
});

function vb(a, b) {
  if (b) {
    if (ub[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(y(137, a));

    if (null != b.dangerouslySetInnerHTML) {
      if (null != b.children) throw Error(y(60));
      if (!("object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML)) throw Error(y(61));
    }

    if (null != b.style && "object" !== typeof b.style) throw Error(y(62));
  }
}

function wb(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;

  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;

    default:
      return !0;
  }
}

function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}

var yb = null,
    zb = null,
    Ab = null;

function Bb(a) {
  if (a = Cb(a)) {
    if ("function" !== typeof yb) throw Error(y(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}

function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}

function Fb() {
  if (zb) {
    var a = zb,
        b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b) for (a = 0; a < b.length; a++) {
      Bb(b[a]);
    }
  }
}

function Gb(a, b) {
  return a(b);
}

function Hb(a, b, c, d, e) {
  return a(b, c, d, e);
}

function Ib() {}

var Jb = Gb,
    Kb = !1,
    Lb = !1;

function Mb() {
  if (null !== zb || null !== Ab) Ib(), Fb();
}

function Nb(a, b, c) {
  if (Lb) return a(b, c);
  Lb = !0;

  try {
    return Jb(a, b, c);
  } finally {
    Lb = !1, Mb();
  }
}

function Ob(a, b) {
  var c = a.stateNode;
  if (null === c) return null;
  var d = Db(c);
  if (null === d) return null;
  c = d[b];

  a: switch (b) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
      a = !d;
      break a;

    default:
      a = !1;
  }

  if (a) return null;
  if (c && "function" !== typeof c) throw Error(y(231, b, typeof c));
  return c;
}

var Pb = !1;
if (fa) try {
  var Qb = {};
  Object.defineProperty(Qb, "passive", {
    get: function get() {
      Pb = !0;
    }
  });
  window.addEventListener("test", Qb, Qb);
  window.removeEventListener("test", Qb, Qb);
} catch (a) {
  Pb = !1;
}

function Rb(a, b, c, d, e, f, g, h, k) {
  var l = Array.prototype.slice.call(arguments, 3);

  try {
    b.apply(c, l);
  } catch (n) {
    this.onError(n);
  }
}

var Sb = !1,
    Tb = null,
    Ub = !1,
    Vb = null,
    Wb = {
  onError: function onError(a) {
    Sb = !0;
    Tb = a;
  }
};

function Xb(a, b, c, d, e, f, g, h, k) {
  Sb = !1;
  Tb = null;
  Rb.apply(Wb, arguments);
}

function Yb(a, b, c, d, e, f, g, h, k) {
  Xb.apply(this, arguments);

  if (Sb) {
    if (Sb) {
      var l = Tb;
      Sb = !1;
      Tb = null;
    } else throw Error(y(198));

    Ub || (Ub = !0, Vb = l);
  }
}

function Zb(a) {
  var b = a,
      c = a;
  if (a.alternate) for (; b["return"];) {
    b = b["return"];
  } else {
    a = b;

    do {
      b = a, 0 !== (b.flags & 1026) && (c = b["return"]), a = b["return"];
    } while (a);
  }
  return 3 === b.tag ? c : null;
}

function $b(a) {
  if (13 === a.tag) {
    var b = a.memoizedState;
    null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
    if (null !== b) return b.dehydrated;
  }

  return null;
}

function ac(a) {
  if (Zb(a) !== a) throw Error(y(188));
}

function bc(a) {
  var b = a.alternate;

  if (!b) {
    b = Zb(a);
    if (null === b) throw Error(y(188));
    return b !== a ? null : a;
  }

  for (var c = a, d = b;;) {
    var e = c["return"];
    if (null === e) break;
    var f = e.alternate;

    if (null === f) {
      d = e["return"];

      if (null !== d) {
        c = d;
        continue;
      }

      break;
    }

    if (e.child === f.child) {
      for (f = e.child; f;) {
        if (f === c) return ac(e), a;
        if (f === d) return ac(e), b;
        f = f.sibling;
      }

      throw Error(y(188));
    }

    if (c["return"] !== d["return"]) c = e, d = f;else {
      for (var g = !1, h = e.child; h;) {
        if (h === c) {
          g = !0;
          c = e;
          d = f;
          break;
        }

        if (h === d) {
          g = !0;
          d = e;
          c = f;
          break;
        }

        h = h.sibling;
      }

      if (!g) {
        for (h = f.child; h;) {
          if (h === c) {
            g = !0;
            c = f;
            d = e;
            break;
          }

          if (h === d) {
            g = !0;
            d = f;
            c = e;
            break;
          }

          h = h.sibling;
        }

        if (!g) throw Error(y(189));
      }
    }
    if (c.alternate !== d) throw Error(y(190));
  }

  if (3 !== c.tag) throw Error(y(188));
  return c.stateNode.current === c ? a : b;
}

function cc(a) {
  a = bc(a);
  if (!a) return null;

  for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;
    if (b.child) b.child["return"] = b, b = b.child;else {
      if (b === a) break;

      for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;
        b = b["return"];
      }

      b.sibling["return"] = b["return"];
      b = b.sibling;
    }
  }

  return null;
}

function dc(a, b) {
  for (var c = a.alternate; null !== b;) {
    if (b === a || b === c) return !0;
    b = b["return"];
  }

  return !1;
}

var ec,
    fc,
    gc,
    hc,
    ic = !1,
    jc = [],
    kc = null,
    lc = null,
    mc = null,
    nc = new Map(),
    oc = new Map(),
    pc = [],
    qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

function rc(a, b, c, d, e) {
  return {
    blockedOn: a,
    domEventName: b,
    eventSystemFlags: c | 16,
    nativeEvent: e,
    targetContainers: [d]
  };
}

function sc(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      kc = null;
      break;

    case "dragenter":
    case "dragleave":
      lc = null;
      break;

    case "mouseover":
    case "mouseout":
      mc = null;
      break;

    case "pointerover":
    case "pointerout":
      nc["delete"](b.pointerId);
      break;

    case "gotpointercapture":
    case "lostpointercapture":
      oc["delete"](b.pointerId);
  }
}

function tc(a, b, c, d, e, f) {
  if (null === a || a.nativeEvent !== f) return a = rc(b, c, d, e, f), null !== b && (b = Cb(b), null !== b && fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  null !== e && -1 === b.indexOf(e) && b.push(e);
  return a;
}

function uc(a, b, c, d, e) {
  switch (b) {
    case "focusin":
      return kc = tc(kc, a, b, c, d, e), !0;

    case "dragenter":
      return lc = tc(lc, a, b, c, d, e), !0;

    case "mouseover":
      return mc = tc(mc, a, b, c, d, e), !0;

    case "pointerover":
      var f = e.pointerId;
      nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));
      return !0;

    case "gotpointercapture":
      return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), !0;
  }

  return !1;
}

function vc(a) {
  var b = wc(a.target);

  if (null !== b) {
    var c = Zb(b);
    if (null !== c) if (b = c.tag, 13 === b) {
      if (b = $b(c), null !== b) {
        a.blockedOn = b;
        hc(a.lanePriority, function () {
          r.unstable_runWithPriority(a.priority, function () {
            gc(c);
          });
        });
        return;
      }
    } else if (3 === b && c.stateNode.hydrate) {
      a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
      return;
    }
  }

  a.blockedOn = null;
}

function xc(a) {
  if (null !== a.blockedOn) return !1;

  for (var b = a.targetContainers; 0 < b.length;) {
    var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (null !== c) return b = Cb(c), null !== b && fc(b), a.blockedOn = c, !1;
    b.shift();
  }

  return !0;
}

function zc(a, b, c) {
  xc(a) && c["delete"](b);
}

function Ac() {
  for (ic = !1; 0 < jc.length;) {
    var a = jc[0];

    if (null !== a.blockedOn) {
      a = Cb(a.blockedOn);
      null !== a && ec(a);
      break;
    }

    for (var b = a.targetContainers; 0 < b.length;) {
      var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);

      if (null !== c) {
        a.blockedOn = c;
        break;
      }

      b.shift();
    }

    null === a.blockedOn && jc.shift();
  }

  null !== kc && xc(kc) && (kc = null);
  null !== lc && xc(lc) && (lc = null);
  null !== mc && xc(mc) && (mc = null);
  nc.forEach(zc);
  oc.forEach(zc);
}

function Bc(a, b) {
  a.blockedOn === b && (a.blockedOn = null, ic || (ic = !0, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ac)));
}

function Cc(a) {
  function b(b) {
    return Bc(b, a);
  }

  if (0 < jc.length) {
    Bc(jc[0], a);

    for (var c = 1; c < jc.length; c++) {
      var d = jc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }

  null !== kc && Bc(kc, a);
  null !== lc && Bc(lc, a);
  null !== mc && Bc(mc, a);
  nc.forEach(b);
  oc.forEach(b);

  for (c = 0; c < pc.length; c++) {
    d = pc[c], d.blockedOn === a && (d.blockedOn = null);
  }

  for (; 0 < pc.length && (c = pc[0], null === c.blockedOn);) {
    vc(c), null === c.blockedOn && pc.shift();
  }
}

function Dc(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}

var Ec = {
  animationend: Dc("Animation", "AnimationEnd"),
  animationiteration: Dc("Animation", "AnimationIteration"),
  animationstart: Dc("Animation", "AnimationStart"),
  transitionend: Dc("Transition", "TransitionEnd")
},
    Fc = {},
    Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);

function Hc(a) {
  if (Fc[a]) return Fc[a];
  if (!Ec[a]) return a;
  var b = Ec[a],
      c;

  for (c in b) {
    if (b.hasOwnProperty(c) && c in Gc) return Fc[a] = b[c];
  }

  return a;
}

var Ic = Hc("animationend"),
    Jc = Hc("animationiteration"),
    Kc = Hc("animationstart"),
    Lc = Hc("transitionend"),
    Mc = new Map(),
    Nc = new Map(),
    Oc = ["abort", "abort", Ic, "animationEnd", Jc, "animationIteration", Kc, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", Lc, "transitionEnd", "waiting", "waiting"];

function Pc(a, b) {
  for (var c = 0; c < a.length; c += 2) {
    var d = a[c],
        e = a[c + 1];
    e = "on" + (e[0].toUpperCase() + e.slice(1));
    Nc.set(d, b);
    Mc.set(d, e);
    da(e, [d]);
  }
}

var Qc = r.unstable_now;
Qc();
var F = 8;

function Rc(a) {
  if (0 !== (1 & a)) return F = 15, 1;
  if (0 !== (2 & a)) return F = 14, 2;
  if (0 !== (4 & a)) return F = 13, 4;
  var b = 24 & a;
  if (0 !== b) return F = 12, b;
  if (0 !== (a & 32)) return F = 11, 32;
  b = 192 & a;
  if (0 !== b) return F = 10, b;
  if (0 !== (a & 256)) return F = 9, 256;
  b = 3584 & a;
  if (0 !== b) return F = 8, b;
  if (0 !== (a & 4096)) return F = 7, 4096;
  b = 4186112 & a;
  if (0 !== b) return F = 6, b;
  b = 62914560 & a;
  if (0 !== b) return F = 5, b;
  if (a & 67108864) return F = 4, 67108864;
  if (0 !== (a & 134217728)) return F = 3, 134217728;
  b = 805306368 & a;
  if (0 !== b) return F = 2, b;
  if (0 !== (1073741824 & a)) return F = 1, 1073741824;
  F = 8;
  return a;
}

function Sc(a) {
  switch (a) {
    case 99:
      return 15;

    case 98:
      return 10;

    case 97:
    case 96:
      return 8;

    case 95:
      return 2;

    default:
      return 0;
  }
}

function Tc(a) {
  switch (a) {
    case 15:
    case 14:
      return 99;

    case 13:
    case 12:
    case 11:
    case 10:
      return 98;

    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;

    case 3:
    case 2:
    case 1:
      return 95;

    case 0:
      return 90;

    default:
      throw Error(y(358, a));
  }
}

function Uc(a, b) {
  var c = a.pendingLanes;
  if (0 === c) return F = 0;
  var d = 0,
      e = 0,
      f = a.expiredLanes,
      g = a.suspendedLanes,
      h = a.pingedLanes;
  if (0 !== f) d = f, e = F = 15;else if (f = c & 134217727, 0 !== f) {
    var k = f & ~g;
    0 !== k ? (d = Rc(k), e = F) : (h &= f, 0 !== h && (d = Rc(h), e = F));
  } else f = c & ~g, 0 !== f ? (d = Rc(f), e = F) : 0 !== h && (d = Rc(h), e = F);
  if (0 === d) return 0;
  d = 31 - Vc(d);
  d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;

  if (0 !== b && b !== d && 0 === (b & g)) {
    Rc(b);
    if (e <= F) return b;
    F = e;
  }

  b = a.entangledLanes;
  if (0 !== b) for (a = a.entanglements, b &= d; 0 < b;) {
    c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
  }
  return d;
}

function Wc(a) {
  a = a.pendingLanes & -1073741825;
  return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
}

function Xc(a, b) {
  switch (a) {
    case 15:
      return 1;

    case 14:
      return 2;

    case 12:
      return a = Yc(24 & ~b), 0 === a ? Xc(10, b) : a;

    case 10:
      return a = Yc(192 & ~b), 0 === a ? Xc(8, b) : a;

    case 8:
      return a = Yc(3584 & ~b), 0 === a && (a = Yc(4186112 & ~b), 0 === a && (a = 512)), a;

    case 2:
      return b = Yc(805306368 & ~b), 0 === b && (b = 268435456), b;
  }

  throw Error(y(358, a));
}

function Yc(a) {
  return a & -a;
}

function Zc(a) {
  for (var b = [], c = 0; 31 > c; c++) {
    b.push(a);
  }

  return b;
}

function $c(a, b, c) {
  a.pendingLanes |= b;
  var d = b - 1;
  a.suspendedLanes &= d;
  a.pingedLanes &= d;
  a = a.eventTimes;
  b = 31 - Vc(b);
  a[b] = c;
}

var Vc = Math.clz32 ? Math.clz32 : ad,
    bd = Math.log,
    cd = Math.LN2;

function ad(a) {
  return 0 === a ? 32 : 31 - (bd(a) / cd | 0) | 0;
}

var dd = r.unstable_UserBlockingPriority,
    ed = r.unstable_runWithPriority,
    fd = !0;

function gd(a, b, c, d) {
  Kb || Ib();
  var e = hd,
      f = Kb;
  Kb = !0;

  try {
    Hb(e, a, b, c, d);
  } finally {
    (Kb = f) || Mb();
  }
}

function id(a, b, c, d) {
  ed(dd, hd.bind(null, a, b, c, d));
}

function hd(a, b, c, d) {
  if (fd) {
    var e;
    if ((e = 0 === (b & 4)) && 0 < jc.length && -1 < qc.indexOf(a)) a = rc(null, a, b, c, d), jc.push(a);else {
      var f = yc(a, b, c, d);
      if (null === f) e && sc(a, d);else {
        if (e) {
          if (-1 < qc.indexOf(a)) {
            a = rc(f, a, b, c, d);
            jc.push(a);
            return;
          }

          if (uc(f, a, b, c, d)) return;
          sc(a, d);
        }

        jd(a, b, d, null, c);
      }
    }
  }
}

function yc(a, b, c, d) {
  var e = xb(d);
  e = wc(e);

  if (null !== e) {
    var f = Zb(e);
    if (null === f) e = null;else {
      var g = f.tag;

      if (13 === g) {
        e = $b(f);
        if (null !== e) return e;
        e = null;
      } else if (3 === g) {
        if (f.stateNode.hydrate) return 3 === f.tag ? f.stateNode.containerInfo : null;
        e = null;
      } else f !== e && (e = null);
    }
  }

  jd(a, b, d, e, c);
  return null;
}

var kd = null,
    ld = null,
    md = null;

function nd() {
  if (md) return md;
  var a,
      b = ld,
      c = b.length,
      d,
      e = "value" in kd ? kd.value : kd.textContent,
      f = e.length;

  for (a = 0; a < c && b[a] === e[a]; a++) {
    ;
  }

  var g = c - a;

  for (d = 1; d <= g && b[c - d] === e[f - d]; d++) {
    ;
  }

  return md = e.slice(a, 1 < d ? 1 - d : void 0);
}

function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  10 === a && (a = 13);
  return 32 <= a || 13 === a ? a : 0;
}

function pd() {
  return !0;
}

function qd() {
  return !1;
}

function rd(a) {
  function b(b, d, e, f, g) {
    this._reactName = b;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f;
    this.target = g;
    this.currentTarget = null;

    for (var c in a) {
      a.hasOwnProperty(c) && (b = a[c], this[c] = b ? b(f) : f[c]);
    }

    this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : !1 === f.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }

  m(b.prototype, {
    preventDefault: function preventDefault() {
      this.defaultPrevented = !0;
      var a = this.nativeEvent;
      a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = pd);
    },
    stopPropagation: function stopPropagation() {
      var a = this.nativeEvent;
      a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = pd);
    },
    persist: function persist() {},
    isPersistent: pd
  });
  return b;
}

var sd = {
  eventPhase: 0,
  bubbles: 0,
  cancelable: 0,
  timeStamp: function timeStamp(a) {
    return a.timeStamp || Date.now();
  },
  defaultPrevented: 0,
  isTrusted: 0
},
    td = rd(sd),
    ud = m({}, sd, {
  view: 0,
  detail: 0
}),
    vd = rd(ud),
    wd,
    xd,
    yd,
    Ad = m({}, ud, {
  screenX: 0,
  screenY: 0,
  clientX: 0,
  clientY: 0,
  pageX: 0,
  pageY: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  getModifierState: zd,
  button: 0,
  buttons: 0,
  relatedTarget: function relatedTarget(a) {
    return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  },
  movementX: function movementX(a) {
    if ("movementX" in a) return a.movementX;
    a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
    return wd;
  },
  movementY: function movementY(a) {
    return "movementY" in a ? a.movementY : xd;
  }
}),
    Bd = rd(Ad),
    Cd = m({}, Ad, {
  dataTransfer: 0
}),
    Dd = rd(Cd),
    Ed = m({}, ud, {
  relatedTarget: 0
}),
    Fd = rd(Ed),
    Gd = m({}, sd, {
  animationName: 0,
  elapsedTime: 0,
  pseudoElement: 0
}),
    Hd = rd(Gd),
    Id = m({}, sd, {
  clipboardData: function clipboardData(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  }
}),
    Jd = rd(Id),
    Kd = m({}, sd, {
  data: 0
}),
    Ld = rd(Kd),
    Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
},
    Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
},
    Od = {
  Alt: "altKey",
  Control: "ctrlKey",
  Meta: "metaKey",
  Shift: "shiftKey"
};

function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : !1;
}

function zd() {
  return Pd;
}

var Qd = m({}, ud, {
  key: function key(a) {
    if (a.key) {
      var b = Md[a.key] || a.key;
      if ("Unidentified" !== b) return b;
    }

    return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
  },
  code: 0,
  location: 0,
  ctrlKey: 0,
  shiftKey: 0,
  altKey: 0,
  metaKey: 0,
  repeat: 0,
  locale: 0,
  getModifierState: zd,
  charCode: function charCode(a) {
    return "keypress" === a.type ? od(a) : 0;
  },
  keyCode: function keyCode(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  },
  which: function which(a) {
    return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }
}),
    Rd = rd(Qd),
    Sd = m({}, Ad, {
  pointerId: 0,
  width: 0,
  height: 0,
  pressure: 0,
  tangentialPressure: 0,
  tiltX: 0,
  tiltY: 0,
  twist: 0,
  pointerType: 0,
  isPrimary: 0
}),
    Td = rd(Sd),
    Ud = m({}, ud, {
  touches: 0,
  targetTouches: 0,
  changedTouches: 0,
  altKey: 0,
  metaKey: 0,
  ctrlKey: 0,
  shiftKey: 0,
  getModifierState: zd
}),
    Vd = rd(Ud),
    Wd = m({}, sd, {
  propertyName: 0,
  elapsedTime: 0,
  pseudoElement: 0
}),
    Xd = rd(Wd),
    Yd = m({}, Ad, {
  deltaX: function deltaX(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function deltaY(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}),
    Zd = rd(Yd),
    $d = [9, 13, 27, 32],
    ae = fa && "CompositionEvent" in window,
    be = null;
fa && "documentMode" in document && (be = document.documentMode);
var ce = fa && "TextEvent" in window && !be,
    de = fa && (!ae || be && 8 < be && 11 >= be),
    ee = String.fromCharCode(32),
    fe = !1;

function ge(a, b) {
  switch (a) {
    case "keyup":
      return -1 !== $d.indexOf(b.keyCode);

    case "keydown":
      return 229 !== b.keyCode;

    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;

    default:
      return !1;
  }
}

function he(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}

var ie = !1;

function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);

    case "keypress":
      if (32 !== b.which) return null;
      fe = !0;
      return ee;

    case "textInput":
      return a = b.data, a === ee && fe ? null : a;

    default:
      return null;
  }
}

function ke(a, b) {
  if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = !1, a) : null;

  switch (a) {
    case "paste":
      return null;

    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b["char"] && 1 < b["char"].length) return b["char"];
        if (b.which) return String.fromCharCode(b.which);
      }

      return null;

    case "compositionend":
      return de && "ko" !== b.locale ? null : b.data;

    default:
      return null;
  }
}

var le = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};

function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!le[a.type] : "textarea" === b ? !0 : !1;
}

function ne(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({
    event: c,
    listeners: b
  }));
}

var pe = null,
    qe = null;

function re(a) {
  se(a, 0);
}

function te(a) {
  var b = ue(a);
  if (Wa(b)) return a;
}

function ve(a, b) {
  if ("change" === a) return b;
}

var we = !1;

if (fa) {
  var xe;

  if (fa) {
    var ye = ("oninput" in document);

    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }

    xe = ye;
  } else xe = !1;

  we = xe && (!document.documentMode || 9 < document.documentMode);
}

function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}

function Be(a) {
  if ("value" === a.propertyName && te(qe)) {
    var b = [];
    ne(b, qe, a, xb(a));
    a = re;
    if (Kb) a(b);else {
      Kb = !0;

      try {
        Gb(a, b);
      } finally {
        Kb = !1, Mb();
      }
    }
  }
}

function Ce(a, b, c) {
  "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
}

function De(a) {
  if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
}

function Ee(a, b) {
  if ("click" === a) return te(b);
}

function Fe(a, b) {
  if ("input" === a || "change" === a) return te(b);
}

function Ge(a, b) {
  return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
}

var He = "function" === typeof Object.is ? Object.is : Ge,
    Ie = Object.prototype.hasOwnProperty;

function Je(a, b) {
  if (He(a, b)) return !0;
  if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return !1;
  var c = Object.keys(a),
      d = Object.keys(b);
  if (c.length !== d.length) return !1;

  for (d = 0; d < c.length; d++) {
    if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]])) return !1;
  }

  return !0;
}

function Ke(a) {
  for (; a && a.firstChild;) {
    a = a.firstChild;
  }

  return a;
}

function Le(a, b) {
  var c = Ke(a);
  a = 0;

  for (var d; c;) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b && d >= b) return {
        node: c,
        offset: b - a
      };
      a = d;
    }

    a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }

        c = c.parentNode;
      }

      c = void 0;
    }

    c = Ke(c);
  }
}

function Me(a, b) {
  return a && b ? a === b ? !0 : a && 3 === a.nodeType ? !1 : b && 3 === b.nodeType ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
}

function Ne() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement;) {
    try {
      var c = "string" === typeof b.contentWindow.location.href;
    } catch (d) {
      c = !1;
    }

    if (c) a = b.contentWindow;else break;
    b = Xa(a.document);
  }

  return b;
}

function Oe(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
}

var Pe = fa && "documentMode" in document && 11 >= document.documentMode,
    Qe = null,
    Re = null,
    Se = null,
    Te = !1;

function Ue(a, b, c) {
  var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
  Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = {
    start: d.selectionStart,
    end: d.selectionEnd
  } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
    anchorNode: d.anchorNode,
    anchorOffset: d.anchorOffset,
    focusNode: d.focusNode,
    focusOffset: d.focusOffset
  }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({
    event: b,
    listeners: d
  }), b.target = Qe)));
}

Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc(Oc, 2);

for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++) {
  Nc.set(Ve[We], 0);
}

ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);
ea("onPointerEnter", ["pointerout", "pointerover"]);
ea("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
    Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));

function Ze(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Yb(d, b, void 0, a);
  a.currentTarget = null;
}

function se(a, b) {
  b = 0 !== (b & 4);

  for (var c = 0; c < a.length; c++) {
    var d = a[c],
        e = d.event;
    d = d.listeners;

    a: {
      var f = void 0;
      if (b) for (var g = d.length - 1; 0 <= g; g--) {
        var h = d[g],
            k = h.instance,
            l = h.currentTarget;
        h = h.listener;
        if (k !== f && e.isPropagationStopped()) break a;
        Ze(e, h, l);
        f = k;
      } else for (g = 0; g < d.length; g++) {
        h = d[g];
        k = h.instance;
        l = h.currentTarget;
        h = h.listener;
        if (k !== f && e.isPropagationStopped()) break a;
        Ze(e, h, l);
        f = k;
      }
    }
  }

  if (Ub) throw a = Vb, Ub = !1, Vb = null, a;
}

function G(a, b) {
  var c = $e(b),
      d = a + "__bubble";
  c.has(d) || (af(b, a, 2, !1), c.add(d));
}

var bf = "_reactListening" + Math.random().toString(36).slice(2);

function cf(a) {
  a[bf] || (a[bf] = !0, ba.forEach(function (b) {
    Ye.has(b) || df(b, !1, a, null);
    df(b, !0, a, null);
  }));
}

function df(a, b, c, d) {
  var e = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0,
      f = c;
  "selectionchange" === a && 9 !== c.nodeType && (f = c.ownerDocument);

  if (null !== d && !b && Ye.has(a)) {
    if ("scroll" !== a) return;
    e |= 2;
    f = d;
  }

  var g = $e(f),
      h = a + "__" + (b ? "capture" : "bubble");
  g.has(h) || (b && (e |= 4), af(f, a, e, b), g.add(h));
}

function af(a, b, c, d) {
  var e = Nc.get(b);

  switch (void 0 === e ? 2 : e) {
    case 0:
      e = gd;
      break;

    case 1:
      e = id;
      break;

    default:
      e = hd;
  }

  c = e.bind(null, b, c, a);
  e = void 0;
  !Pb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = !0);
  d ? void 0 !== e ? a.addEventListener(b, c, {
    capture: !0,
    passive: e
  }) : a.addEventListener(b, c, !0) : void 0 !== e ? a.addEventListener(b, c, {
    passive: e
  }) : a.addEventListener(b, c, !1);
}

function jd(a, b, c, d, e) {
  var f = d;
  if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (;;) {
    if (null === d) return;
    var g = d.tag;

    if (3 === g || 4 === g) {
      var h = d.stateNode.containerInfo;
      if (h === e || 8 === h.nodeType && h.parentNode === e) break;
      if (4 === g) for (g = d["return"]; null !== g;) {
        var k = g.tag;
        if (3 === k || 4 === k) if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
        g = g["return"];
      }

      for (; null !== h;) {
        g = wc(h);
        if (null === g) return;
        k = g.tag;

        if (5 === k || 6 === k) {
          d = f = g;
          continue a;
        }

        h = h.parentNode;
      }
    }

    d = d["return"];
  }
  Nb(function () {
    var d = f,
        e = xb(c),
        g = [];

    a: {
      var h = Mc.get(a);

      if (void 0 !== h) {
        var k = td,
            x = a;

        switch (a) {
          case "keypress":
            if (0 === od(c)) break a;

          case "keydown":
          case "keyup":
            k = Rd;
            break;

          case "focusin":
            x = "focus";
            k = Fd;
            break;

          case "focusout":
            x = "blur";
            k = Fd;
            break;

          case "beforeblur":
          case "afterblur":
            k = Fd;
            break;

          case "click":
            if (2 === c.button) break a;

          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k = Bd;
            break;

          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k = Dd;
            break;

          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k = Vd;
            break;

          case Ic:
          case Jc:
          case Kc:
            k = Hd;
            break;

          case Lc:
            k = Xd;
            break;

          case "scroll":
            k = vd;
            break;

          case "wheel":
            k = Zd;
            break;

          case "copy":
          case "cut":
          case "paste":
            k = Jd;
            break;

          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k = Td;
        }

        var w = 0 !== (b & 4),
            z = !w && "scroll" === a,
            u = w ? null !== h ? h + "Capture" : null : h;
        w = [];

        for (var t = d, q; null !== t;) {
          q = t;
          var v = q.stateNode;
          5 === q.tag && null !== v && (q = v, null !== u && (v = Ob(t, u), null != v && w.push(ef(t, v, q))));
          if (z) break;
          t = t["return"];
        }

        0 < w.length && (h = new k(h, x, null, c, e), g.push({
          event: h,
          listeners: w
        }));
      }
    }

    if (0 === (b & 7)) {
      a: {
        h = "mouseover" === a || "pointerover" === a;
        k = "mouseout" === a || "pointerout" === a;
        if (h && 0 === (b & 16) && (x = c.relatedTarget || c.fromElement) && (wc(x) || x[ff])) break a;

        if (k || h) {
          h = e.window === e ? e : (h = e.ownerDocument) ? h.defaultView || h.parentWindow : window;

          if (k) {
            if (x = c.relatedTarget || c.toElement, k = d, x = x ? wc(x) : null, null !== x && (z = Zb(x), x !== z || 5 !== x.tag && 6 !== x.tag)) x = null;
          } else k = null, x = d;

          if (k !== x) {
            w = Bd;
            v = "onMouseLeave";
            u = "onMouseEnter";
            t = "mouse";
            if ("pointerout" === a || "pointerover" === a) w = Td, v = "onPointerLeave", u = "onPointerEnter", t = "pointer";
            z = null == k ? h : ue(k);
            q = null == x ? h : ue(x);
            h = new w(v, t + "leave", k, c, e);
            h.target = z;
            h.relatedTarget = q;
            v = null;
            wc(e) === d && (w = new w(u, t + "enter", x, c, e), w.target = q, w.relatedTarget = z, v = w);
            z = v;
            if (k && x) b: {
              w = k;
              u = x;
              t = 0;

              for (q = w; q; q = gf(q)) {
                t++;
              }

              q = 0;

              for (v = u; v; v = gf(v)) {
                q++;
              }

              for (; 0 < t - q;) {
                w = gf(w), t--;
              }

              for (; 0 < q - t;) {
                u = gf(u), q--;
              }

              for (; t--;) {
                if (w === u || null !== u && w === u.alternate) break b;
                w = gf(w);
                u = gf(u);
              }

              w = null;
            } else w = null;
            null !== k && hf(g, h, k, w, !1);
            null !== x && null !== z && hf(g, z, x, w, !0);
          }
        }
      }

      a: {
        h = d ? ue(d) : window;
        k = h.nodeName && h.nodeName.toLowerCase();
        if ("select" === k || "input" === k && "file" === h.type) var J = ve;else if (me(h)) {
          if (we) J = Fe;else {
            J = De;
            var K = Ce;
          }
        } else (k = h.nodeName) && "input" === k.toLowerCase() && ("checkbox" === h.type || "radio" === h.type) && (J = Ee);

        if (J && (J = J(a, d))) {
          ne(g, J, c, e);
          break a;
        }

        K && K(a, h, d);
        "focusout" === a && (K = h._wrapperState) && K.controlled && "number" === h.type && bb(h, "number", h.value);
      }

      K = d ? ue(d) : window;

      switch (a) {
        case "focusin":
          if (me(K) || "true" === K.contentEditable) Qe = K, Re = d, Se = null;
          break;

        case "focusout":
          Se = Re = Qe = null;
          break;

        case "mousedown":
          Te = !0;
          break;

        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = !1;
          Ue(g, c, e);
          break;

        case "selectionchange":
          if (Pe) break;

        case "keydown":
        case "keyup":
          Ue(g, c, e);
      }

      var Q;
      if (ae) b: {
        switch (a) {
          case "compositionstart":
            var L = "onCompositionStart";
            break b;

          case "compositionend":
            L = "onCompositionEnd";
            break b;

          case "compositionupdate":
            L = "onCompositionUpdate";
            break b;
        }

        L = void 0;
      } else ie ? ge(a, c) && (L = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (L = "onCompositionStart");
      L && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== L ? "onCompositionEnd" === L && ie && (Q = nd()) : (kd = e, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), K = oe(d, L), 0 < K.length && (L = new Ld(L, a, null, c, e), g.push({
        event: L,
        listeners: K
      }), Q ? L.data = Q : (Q = he(c), null !== Q && (L.data = Q))));
      if (Q = ce ? je(a, c) : ke(a, c)) d = oe(d, "onBeforeInput"), 0 < d.length && (e = new Ld("onBeforeInput", "beforeinput", null, c, e), g.push({
        event: e,
        listeners: d
      }), e.data = Q);
    }

    se(g, b);
  });
}

function ef(a, b, c) {
  return {
    instance: a,
    listener: b,
    currentTarget: c
  };
}

function oe(a, b) {
  for (var c = b + "Capture", d = []; null !== a;) {
    var e = a,
        f = e.stateNode;
    5 === e.tag && null !== f && (e = f, f = Ob(a, c), null != f && d.unshift(ef(a, f, e)), f = Ob(a, b), null != f && d.push(ef(a, f, e)));
    a = a["return"];
  }

  return d;
}

function gf(a) {
  if (null === a) return null;

  do {
    a = a["return"];
  } while (a && 5 !== a.tag);

  return a ? a : null;
}

function hf(a, b, c, d, e) {
  for (var f = b._reactName, g = []; null !== c && c !== d;) {
    var h = c,
        k = h.alternate,
        l = h.stateNode;
    if (null !== k && k === d) break;
    5 === h.tag && null !== l && (h = l, e ? (k = Ob(c, f), null != k && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), null != k && g.push(ef(c, k, h))));
    c = c["return"];
  }

  0 !== g.length && a.push({
    event: b,
    listeners: g
  });
}

function jf() {}

var kf = null,
    lf = null;

function mf(a, b) {
  switch (a) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b.autoFocus;
  }

  return !1;
}

function nf(a, b) {
  return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
}

var of = "function" === typeof setTimeout ? setTimeout : void 0,
    pf = "function" === typeof clearTimeout ? clearTimeout : void 0;

function qf(a) {
  1 === a.nodeType ? a.textContent = "" : 9 === a.nodeType && (a = a.body, null != a && (a.textContent = ""));
}

function rf(a) {
  for (; null != a; a = a.nextSibling) {
    var b = a.nodeType;
    if (1 === b || 3 === b) break;
  }

  return a;
}

function sf(a) {
  a = a.previousSibling;

  for (var b = 0; a;) {
    if (8 === a.nodeType) {
      var c = a.data;

      if ("$" === c || "$!" === c || "$?" === c) {
        if (0 === b) return a;
        b--;
      } else "/$" === c && b++;
    }

    a = a.previousSibling;
  }

  return null;
}

var tf = 0;

function uf(a) {
  return {
    $$typeof: Ga,
    toString: a,
    valueOf: a
  };
}

var vf = Math.random().toString(36).slice(2),
    wf = "__reactFiber$" + vf,
    xf = "__reactProps$" + vf,
    ff = "__reactContainer$" + vf,
    yf = "__reactEvents$" + vf;

function wc(a) {
  var b = a[wf];
  if (b) return b;

  for (var c = a.parentNode; c;) {
    if (b = c[ff] || c[wf]) {
      c = b.alternate;
      if (null !== b.child || null !== c && null !== c.child) for (a = sf(a); null !== a;) {
        if (c = a[wf]) return c;
        a = sf(a);
      }
      return b;
    }

    a = c;
    c = a.parentNode;
  }

  return null;
}

function Cb(a) {
  a = a[wf] || a[ff];
  return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
}

function ue(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;
  throw Error(y(33));
}

function Db(a) {
  return a[xf] || null;
}

function $e(a) {
  var b = a[yf];
  void 0 === b && (b = a[yf] = new Set());
  return b;
}

var zf = [],
    Af = -1;

function Bf(a) {
  return {
    current: a
  };
}

function H(a) {
  0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
}

function I(a, b) {
  Af++;
  zf[Af] = a.current;
  a.current = b;
}

var Cf = {},
    M = Bf(Cf),
    N = Bf(!1),
    Df = Cf;

function Ef(a, b) {
  var c = a.type.contextTypes;
  if (!c) return Cf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
  var e = {},
      f;

  for (f in c) {
    e[f] = b[f];
  }

  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}

function Ff(a) {
  a = a.childContextTypes;
  return null !== a && void 0 !== a;
}

function Gf() {
  H(N);
  H(M);
}

function Hf(a, b, c) {
  if (M.current !== Cf) throw Error(y(168));
  I(M, b);
  I(N, c);
}

function If(a, b, c) {
  var d = a.stateNode;
  a = b.childContextTypes;
  if ("function" !== typeof d.getChildContext) return c;
  d = d.getChildContext();

  for (var e in d) {
    if (!(e in a)) throw Error(y(108, Ra(b) || "Unknown", e));
  }

  return m({}, c, d);
}

function Jf(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
  Df = M.current;
  I(M, a);
  I(N, N.current);
  return !0;
}

function Kf(a, b, c) {
  var d = a.stateNode;
  if (!d) throw Error(y(169));
  c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);
  I(N, c);
}

var Lf = null,
    Mf = null,
    Nf = r.unstable_runWithPriority,
    Of = r.unstable_scheduleCallback,
    Pf = r.unstable_cancelCallback,
    Qf = r.unstable_shouldYield,
    Rf = r.unstable_requestPaint,
    Sf = r.unstable_now,
    Tf = r.unstable_getCurrentPriorityLevel,
    Uf = r.unstable_ImmediatePriority,
    Vf = r.unstable_UserBlockingPriority,
    Wf = r.unstable_NormalPriority,
    Xf = r.unstable_LowPriority,
    Yf = r.unstable_IdlePriority,
    Zf = {},
    $f = void 0 !== Rf ? Rf : function () {},
    ag = null,
    bg = null,
    cg = !1,
    dg = Sf(),
    O = 1E4 > dg ? Sf : function () {
  return Sf() - dg;
};

function eg() {
  switch (Tf()) {
    case Uf:
      return 99;

    case Vf:
      return 98;

    case Wf:
      return 97;

    case Xf:
      return 96;

    case Yf:
      return 95;

    default:
      throw Error(y(332));
  }
}

function fg(a) {
  switch (a) {
    case 99:
      return Uf;

    case 98:
      return Vf;

    case 97:
      return Wf;

    case 96:
      return Xf;

    case 95:
      return Yf;

    default:
      throw Error(y(332));
  }
}

function gg(a, b) {
  a = fg(a);
  return Nf(a, b);
}

function hg(a, b, c) {
  a = fg(a);
  return Of(a, b, c);
}

function ig() {
  if (null !== bg) {
    var a = bg;
    bg = null;
    Pf(a);
  }

  jg();
}

function jg() {
  if (!cg && null !== ag) {
    cg = !0;
    var a = 0;

    try {
      var b = ag;
      gg(99, function () {
        for (; a < b.length; a++) {
          var c = b[a];

          do {
            c = c(!0);
          } while (null !== c);
        }
      });
      ag = null;
    } catch (c) {
      throw null !== ag && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
    } finally {
      cg = !1;
    }
  }
}

var kg = ra.ReactCurrentBatchConfig;

function lg(a, b) {
  if (a && a.defaultProps) {
    b = m({}, b);
    a = a.defaultProps;

    for (var c in a) {
      void 0 === b[c] && (b[c] = a[c]);
    }

    return b;
  }

  return b;
}

var mg = Bf(null),
    ng = null,
    og = null,
    pg = null;

function qg() {
  pg = og = ng = null;
}

function rg(a) {
  var b = mg.current;
  H(mg);
  a.type._context._currentValue = b;
}

function sg(a, b) {
  for (; null !== a;) {
    var c = a.alternate;
    if ((a.childLanes & b) === b) {
      if (null === c || (c.childLanes & b) === b) break;else c.childLanes |= b;
    } else a.childLanes |= b, null !== c && (c.childLanes |= b);
    a = a["return"];
  }
}

function tg(a, b) {
  ng = a;
  pg = og = null;
  a = a.dependencies;
  null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (ug = !0), a.firstContext = null);
}

function vg(a, b) {
  if (pg !== a && !1 !== b && 0 !== b) {
    if ("number" !== typeof b || 1073741823 === b) pg = a, b = 1073741823;
    b = {
      context: a,
      observedBits: b,
      next: null
    };

    if (null === og) {
      if (null === ng) throw Error(y(308));
      og = b;
      ng.dependencies = {
        lanes: 0,
        firstContext: b,
        responders: null
      };
    } else og = og.next = b;
  }

  return a._currentValue;
}

var wg = !1;

function xg(a) {
  a.updateQueue = {
    baseState: a.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null
    },
    effects: null
  };
}

function yg(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = {
    baseState: a.baseState,
    firstBaseUpdate: a.firstBaseUpdate,
    lastBaseUpdate: a.lastBaseUpdate,
    shared: a.shared,
    effects: a.effects
  });
}

function zg(a, b) {
  return {
    eventTime: a,
    lane: b,
    tag: 0,
    payload: null,
    callback: null,
    next: null
  };
}

function Ag(a, b) {
  a = a.updateQueue;

  if (null !== a) {
    a = a.shared;
    var c = a.pending;
    null === c ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
}

function Bg(a, b) {
  var c = a.updateQueue,
      d = a.alternate;

  if (null !== d && (d = d.updateQueue, c === d)) {
    var e = null,
        f = null;
    c = c.firstBaseUpdate;

    if (null !== c) {
      do {
        var g = {
          eventTime: c.eventTime,
          lane: c.lane,
          tag: c.tag,
          payload: c.payload,
          callback: c.callback,
          next: null
        };
        null === f ? e = f = g : f = f.next = g;
        c = c.next;
      } while (null !== c);

      null === f ? e = f = b : f = f.next = b;
    } else e = f = b;

    c = {
      baseState: d.baseState,
      firstBaseUpdate: e,
      lastBaseUpdate: f,
      shared: d.shared,
      effects: d.effects
    };
    a.updateQueue = c;
    return;
  }

  a = c.lastBaseUpdate;
  null === a ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}

function Cg(a, b, c, d) {
  var e = a.updateQueue;
  wg = !1;
  var f = e.firstBaseUpdate,
      g = e.lastBaseUpdate,
      h = e.shared.pending;

  if (null !== h) {
    e.shared.pending = null;
    var k = h,
        l = k.next;
    k.next = null;
    null === g ? f = l : g.next = l;
    g = k;
    var n = a.alternate;

    if (null !== n) {
      n = n.updateQueue;
      var A = n.lastBaseUpdate;
      A !== g && (null === A ? n.firstBaseUpdate = l : A.next = l, n.lastBaseUpdate = k);
    }
  }

  if (null !== f) {
    A = e.baseState;
    g = 0;
    n = l = k = null;

    do {
      h = f.lane;
      var p = f.eventTime;

      if ((d & h) === h) {
        null !== n && (n = n.next = {
          eventTime: p,
          lane: 0,
          tag: f.tag,
          payload: f.payload,
          callback: f.callback,
          next: null
        });

        a: {
          var C = a,
              x = f;
          h = b;
          p = c;

          switch (x.tag) {
            case 1:
              C = x.payload;

              if ("function" === typeof C) {
                A = C.call(p, A, h);
                break a;
              }

              A = C;
              break a;

            case 3:
              C.flags = C.flags & -4097 | 64;

            case 0:
              C = x.payload;
              h = "function" === typeof C ? C.call(p, A, h) : C;
              if (null === h || void 0 === h) break a;
              A = m({}, A, h);
              break a;

            case 2:
              wg = !0;
          }
        }

        null !== f.callback && (a.flags |= 32, h = e.effects, null === h ? e.effects = [f] : h.push(f));
      } else p = {
        eventTime: p,
        lane: h,
        tag: f.tag,
        payload: f.payload,
        callback: f.callback,
        next: null
      }, null === n ? (l = n = p, k = A) : n = n.next = p, g |= h;

      f = f.next;
      if (null === f) if (h = e.shared.pending, null === h) break;else f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
    } while (1);

    null === n && (k = A);
    e.baseState = k;
    e.firstBaseUpdate = l;
    e.lastBaseUpdate = n;
    Dg |= g;
    a.lanes = g;
    a.memoizedState = A;
  }
}

function Eg(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (null !== a) for (b = 0; b < a.length; b++) {
    var d = a[b],
        e = d.callback;

    if (null !== e) {
      d.callback = null;
      d = c;
      if ("function" !== typeof e) throw Error(y(191, e));
      e.call(d);
    }
  }
}

var Fg = new aa.Component().refs;

function Gg(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = null === c || void 0 === c ? b : m({}, b, c);
  a.memoizedState = c;
  0 === a.lanes && (a.updateQueue.baseState = c);
}

var Kg = {
  isMounted: function isMounted(a) {
    return (a = a._reactInternals) ? Zb(a) === a : !1;
  },
  enqueueSetState: function enqueueSetState(a, b, c) {
    a = a._reactInternals;
    var d = Hg(),
        e = Ig(a),
        f = zg(d, e);
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    Ag(a, f);
    Jg(a, e, d);
  },
  enqueueReplaceState: function enqueueReplaceState(a, b, c) {
    a = a._reactInternals;
    var d = Hg(),
        e = Ig(a),
        f = zg(d, e);
    f.tag = 1;
    f.payload = b;
    void 0 !== c && null !== c && (f.callback = c);
    Ag(a, f);
    Jg(a, e, d);
  },
  enqueueForceUpdate: function enqueueForceUpdate(a, b) {
    a = a._reactInternals;
    var c = Hg(),
        d = Ig(a),
        e = zg(c, d);
    e.tag = 2;
    void 0 !== b && null !== b && (e.callback = b);
    Ag(a, e);
    Jg(a, d, c);
  }
};

function Lg(a, b, c, d, e, f, g) {
  a = a.stateNode;
  return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : !0;
}

function Mg(a, b, c) {
  var d = !1,
      e = Cf;
  var f = b.contextType;
  "object" === typeof f && null !== f ? f = vg(f) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Ef(a, e) : Cf);
  b = new b(c, f);
  a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
  b.updater = Kg;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
  return b;
}

function Ng(a, b, c, d) {
  a = b.state;
  "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
  "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
}

function Og(a, b, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = Fg;
  xg(a);
  var f = b.contextType;
  "object" === typeof f && null !== f ? e.context = vg(f) : (f = Ff(b) ? Df : M.current, e.context = Ef(a, f));
  Cg(a, c, e, d);
  e.state = a.memoizedState;
  f = b.getDerivedStateFromProps;
  "function" === typeof f && (Gg(a, b, f, c), e.state = a.memoizedState);
  "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);
  "function" === typeof e.componentDidMount && (a.flags |= 4);
}

var Pg = Array.isArray;

function Qg(a, b, c) {
  a = c.ref;

  if (null !== a && "function" !== typeof a && "object" !== typeof a) {
    if (c._owner) {
      c = c._owner;

      if (c) {
        if (1 !== c.tag) throw Error(y(309));
        var d = c.stateNode;
      }

      if (!d) throw Error(y(147, a));
      var e = "" + a;
      if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e) return b.ref;

      b = function b(a) {
        var b = d.refs;
        b === Fg && (b = d.refs = {});
        null === a ? delete b[e] : b[e] = a;
      };

      b._stringRef = e;
      return b;
    }

    if ("string" !== typeof a) throw Error(y(284));
    if (!c._owner) throw Error(y(290, a));
  }

  return a;
}

function Rg(a, b) {
  if ("textarea" !== a.type) throw Error(y(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
}

function Sg(a) {
  function b(b, c) {
    if (a) {
      var d = b.lastEffect;
      null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;
      c.nextEffect = null;
      c.flags = 8;
    }
  }

  function c(c, d) {
    if (!a) return null;

    for (; null !== d;) {
      b(c, d), d = d.sibling;
    }

    return null;
  }

  function d(a, b) {
    for (a = new Map(); null !== b;) {
      null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    }

    return a;
  }

  function e(a, b) {
    a = Tg(a, b);
    a.index = 0;
    a.sibling = null;
    return a;
  }

  function f(b, c, d) {
    b.index = d;
    if (!a) return c;
    d = b.alternate;
    if (null !== d) return d = d.index, d < c ? (b.flags = 2, c) : d;
    b.flags = 2;
    return c;
  }

  function g(b) {
    a && null === b.alternate && (b.flags = 2);
    return b;
  }

  function h(a, b, c, d) {
    if (null === b || 6 !== b.tag) return b = Ug(c, a.mode, d), b["return"] = a, b;
    b = e(b, c);
    b["return"] = a;
    return b;
  }

  function k(a, b, c, d) {
    if (null !== b && b.elementType === c.type) return d = e(b, c.props), d.ref = Qg(a, b, c), d["return"] = a, d;
    d = Vg(c.type, c.key, c.props, null, a.mode, d);
    d.ref = Qg(a, b, c);
    d["return"] = a;
    return d;
  }

  function l(a, b, c, d) {
    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = Wg(c, a.mode, d), b["return"] = a, b;
    b = e(b, c.children || []);
    b["return"] = a;
    return b;
  }

  function n(a, b, c, d, f) {
    if (null === b || 7 !== b.tag) return b = Xg(c, a.mode, d, f), b["return"] = a, b;
    b = e(b, c);
    b["return"] = a;
    return b;
  }

  function A(a, b, c) {
    if ("string" === typeof b || "number" === typeof b) return b = Ug("" + b, a.mode, c), b["return"] = a, b;

    if ("object" === typeof b && null !== b) {
      switch (b.$$typeof) {
        case sa:
          return c = Vg(b.type, b.key, b.props, null, a.mode, c), c.ref = Qg(a, null, b), c["return"] = a, c;

        case ta:
          return b = Wg(b, a.mode, c), b["return"] = a, b;
      }

      if (Pg(b) || La(b)) return b = Xg(b, a.mode, c, null), b["return"] = a, b;
      Rg(a, b);
    }

    return null;
  }

  function p(a, b, c, d) {
    var e = null !== b ? b.key : null;
    if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);

    if ("object" === typeof c && null !== c) {
      switch (c.$$typeof) {
        case sa:
          return c.key === e ? c.type === ua ? n(a, b, c.props.children, d, e) : k(a, b, c, d) : null;

        case ta:
          return c.key === e ? l(a, b, c, d) : null;
      }

      if (Pg(c) || La(c)) return null !== e ? null : n(a, b, c, d, null);
      Rg(a, c);
    }

    return null;
  }

  function C(a, b, c, d, e) {
    if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);

    if ("object" === typeof d && null !== d) {
      switch (d.$$typeof) {
        case sa:
          return a = a.get(null === d.key ? c : d.key) || null, d.type === ua ? n(b, a, d.props.children, e, d.key) : k(b, a, d, e);

        case ta:
          return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);
      }

      if (Pg(d) || La(d)) return a = a.get(c) || null, n(b, a, d, e, null);
      Rg(b, d);
    }

    return null;
  }

  function x(e, g, h, k) {
    for (var l = null, t = null, u = g, z = g = 0, q = null; null !== u && z < h.length; z++) {
      u.index > z ? (q = u, u = null) : q = u.sibling;
      var n = p(e, u, h[z], k);

      if (null === n) {
        null === u && (u = q);
        break;
      }

      a && u && null === n.alternate && b(e, u);
      g = f(n, g, z);
      null === t ? l = n : t.sibling = n;
      t = n;
      u = q;
    }

    if (z === h.length) return c(e, u), l;

    if (null === u) {
      for (; z < h.length; z++) {
        u = A(e, h[z], k), null !== u && (g = f(u, g, z), null === t ? l = u : t.sibling = u, t = u);
      }

      return l;
    }

    for (u = d(e, u); z < h.length; z++) {
      q = C(u, e, z, h[z], k), null !== q && (a && null !== q.alternate && u["delete"](null === q.key ? z : q.key), g = f(q, g, z), null === t ? l = q : t.sibling = q, t = q);
    }

    a && u.forEach(function (a) {
      return b(e, a);
    });
    return l;
  }

  function w(e, g, h, k) {
    var l = La(h);
    if ("function" !== typeof l) throw Error(y(150));
    h = l.call(h);
    if (null == h) throw Error(y(151));

    for (var t = l = null, u = g, z = g = 0, q = null, n = h.next(); null !== u && !n.done; z++, n = h.next()) {
      u.index > z ? (q = u, u = null) : q = u.sibling;
      var w = p(e, u, n.value, k);

      if (null === w) {
        null === u && (u = q);
        break;
      }

      a && u && null === w.alternate && b(e, u);
      g = f(w, g, z);
      null === t ? l = w : t.sibling = w;
      t = w;
      u = q;
    }

    if (n.done) return c(e, u), l;

    if (null === u) {
      for (; !n.done; z++, n = h.next()) {
        n = A(e, n.value, k), null !== n && (g = f(n, g, z), null === t ? l = n : t.sibling = n, t = n);
      }

      return l;
    }

    for (u = d(e, u); !n.done; z++, n = h.next()) {
      n = C(u, e, z, n.value, k), null !== n && (a && null !== n.alternate && u["delete"](null === n.key ? z : n.key), g = f(n, g, z), null === t ? l = n : t.sibling = n, t = n);
    }

    a && u.forEach(function (a) {
      return b(e, a);
    });
    return l;
  }

  return function (a, d, f, h) {
    var k = "object" === typeof f && null !== f && f.type === ua && null === f.key;
    k && (f = f.props.children);
    var l = "object" === typeof f && null !== f;
    if (l) switch (f.$$typeof) {
      case sa:
        a: {
          l = f.key;

          for (k = d; null !== k;) {
            if (k.key === l) {
              switch (k.tag) {
                case 7:
                  if (f.type === ua) {
                    c(a, k.sibling);
                    d = e(k, f.props.children);
                    d["return"] = a;
                    a = d;
                    break a;
                  }

                  break;

                default:
                  if (k.elementType === f.type) {
                    c(a, k.sibling);
                    d = e(k, f.props);
                    d.ref = Qg(a, k, f);
                    d["return"] = a;
                    a = d;
                    break a;
                  }

              }

              c(a, k);
              break;
            } else b(a, k);

            k = k.sibling;
          }

          f.type === ua ? (d = Xg(f.props.children, a.mode, h, f.key), d["return"] = a, a = d) : (h = Vg(f.type, f.key, f.props, null, a.mode, h), h.ref = Qg(a, d, f), h["return"] = a, a = h);
        }

        return g(a);

      case ta:
        a: {
          for (k = f.key; null !== d;) {
            if (d.key === k) {
              if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                c(a, d.sibling);
                d = e(d, f.children || []);
                d["return"] = a;
                a = d;
                break a;
              } else {
                c(a, d);
                break;
              }
            } else b(a, d);
            d = d.sibling;
          }

          d = Wg(f, a.mode, h);
          d["return"] = a;
          a = d;
        }

        return g(a);
    }
    if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d["return"] = a, a = d) : (c(a, d), d = Ug(f, a.mode, h), d["return"] = a, a = d), g(a);
    if (Pg(f)) return x(a, d, f, h);
    if (La(f)) return w(a, d, f, h);
    l && Rg(a, f);
    if ("undefined" === typeof f && !k) switch (a.tag) {
      case 1:
      case 22:
      case 0:
      case 11:
      case 15:
        throw Error(y(152, Ra(a.type) || "Component"));
    }
    return c(a, d);
  };
}

var Yg = Sg(!0),
    Zg = Sg(!1),
    $g = {},
    ah = Bf($g),
    bh = Bf($g),
    ch = Bf($g);

function dh(a) {
  if (a === $g) throw Error(y(174));
  return a;
}

function eh(a, b) {
  I(ch, b);
  I(bh, a);
  I(ah, $g);
  a = b.nodeType;

  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
      break;

    default:
      a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
  }

  H(ah);
  I(ah, b);
}

function fh() {
  H(ah);
  H(bh);
  H(ch);
}

function gh(a) {
  dh(ch.current);
  var b = dh(ah.current);
  var c = mb(b, a.type);
  b !== c && (I(bh, a), I(ah, c));
}

function hh(a) {
  bh.current === a && (H(ah), H(bh));
}

var P = Bf(0);

function ih(a) {
  for (var b = a; null !== b;) {
    if (13 === b.tag) {
      var c = b.memoizedState;
      if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
    } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
      if (0 !== (b.flags & 64)) return b;
    } else if (null !== b.child) {
      b.child["return"] = b;
      b = b.child;
      continue;
    }

    if (b === a) break;

    for (; null === b.sibling;) {
      if (null === b["return"] || b["return"] === a) return null;
      b = b["return"];
    }

    b.sibling["return"] = b["return"];
    b = b.sibling;
  }

  return null;
}

var jh = null,
    kh = null,
    lh = !1;

function mh(a, b) {
  var c = nh(5, null, null, 0);
  c.elementType = "DELETED";
  c.type = "DELETED";
  c.stateNode = b;
  c["return"] = a;
  c.flags = 8;
  null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
}

function oh(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return null !== b ? (a.stateNode = b, !0) : !1;

    case 6:
      return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, !0) : !1;

    case 13:
      return !1;

    default:
      return !1;
  }
}

function ph(a) {
  if (lh) {
    var b = kh;

    if (b) {
      var c = b;

      if (!oh(a, b)) {
        b = rf(c.nextSibling);

        if (!b || !oh(a, b)) {
          a.flags = a.flags & -1025 | 2;
          lh = !1;
          jh = a;
          return;
        }

        mh(jh, c);
      }

      jh = a;
      kh = rf(b.firstChild);
    } else a.flags = a.flags & -1025 | 2, lh = !1, jh = a;
  }
}

function qh(a) {
  for (a = a["return"]; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) {
    a = a["return"];
  }

  jh = a;
}

function rh(a) {
  if (a !== jh) return !1;
  if (!lh) return qh(a), lh = !0, !1;
  var b = a.type;
  if (5 !== a.tag || "head" !== b && "body" !== b && !nf(b, a.memoizedProps)) for (b = kh; b;) {
    mh(a, b), b = rf(b.nextSibling);
  }
  qh(a);

  if (13 === a.tag) {
    a = a.memoizedState;
    a = null !== a ? a.dehydrated : null;
    if (!a) throw Error(y(317));

    a: {
      a = a.nextSibling;

      for (b = 0; a;) {
        if (8 === a.nodeType) {
          var c = a.data;

          if ("/$" === c) {
            if (0 === b) {
              kh = rf(a.nextSibling);
              break a;
            }

            b--;
          } else "$" !== c && "$!" !== c && "$?" !== c || b++;
        }

        a = a.nextSibling;
      }

      kh = null;
    }
  } else kh = jh ? rf(a.stateNode.nextSibling) : null;

  return !0;
}

function sh() {
  kh = jh = null;
  lh = !1;
}

var th = [];

function uh() {
  for (var a = 0; a < th.length; a++) {
    th[a]._workInProgressVersionPrimary = null;
  }

  th.length = 0;
}

var vh = ra.ReactCurrentDispatcher,
    wh = ra.ReactCurrentBatchConfig,
    xh = 0,
    R = null,
    S = null,
    T = null,
    yh = !1,
    zh = !1;

function Ah() {
  throw Error(y(321));
}

function Bh(a, b) {
  if (null === b) return !1;

  for (var c = 0; c < b.length && c < a.length; c++) {
    if (!He(a[c], b[c])) return !1;
  }

  return !0;
}

function Ch(a, b, c, d, e, f) {
  xh = f;
  R = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  vh.current = null === a || null === a.memoizedState ? Dh : Eh;
  a = c(d, e);

  if (zh) {
    f = 0;

    do {
      zh = !1;
      if (!(25 > f)) throw Error(y(301));
      f += 1;
      T = S = null;
      b.updateQueue = null;
      vh.current = Fh;
      a = c(d, e);
    } while (zh);
  }

  vh.current = Gh;
  b = null !== S && null !== S.next;
  xh = 0;
  T = S = R = null;
  yh = !1;
  if (b) throw Error(y(300));
  return a;
}

function Hh() {
  var a = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null
  };
  null === T ? R.memoizedState = T = a : T = T.next = a;
  return T;
}

function Ih() {
  if (null === S) {
    var a = R.alternate;
    a = null !== a ? a.memoizedState : null;
  } else a = S.next;

  var b = null === T ? R.memoizedState : T.next;
  if (null !== b) T = b, S = a;else {
    if (null === a) throw Error(y(310));
    S = a;
    a = {
      memoizedState: S.memoizedState,
      baseState: S.baseState,
      baseQueue: S.baseQueue,
      queue: S.queue,
      next: null
    };
    null === T ? R.memoizedState = T = a : T = T.next = a;
  }
  return T;
}

function Jh(a, b) {
  return "function" === typeof b ? b(a) : b;
}

function Kh(a) {
  var b = Ih(),
      c = b.queue;
  if (null === c) throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = S,
      e = d.baseQueue,
      f = c.pending;

  if (null !== f) {
    if (null !== e) {
      var g = e.next;
      e.next = f.next;
      f.next = g;
    }

    d.baseQueue = e = f;
    c.pending = null;
  }

  if (null !== e) {
    e = e.next;
    d = d.baseState;
    var h = g = f = null,
        k = e;

    do {
      var l = k.lane;
      if ((xh & l) === l) null !== h && (h = h.next = {
        lane: 0,
        action: k.action,
        eagerReducer: k.eagerReducer,
        eagerState: k.eagerState,
        next: null
      }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);else {
        var n = {
          lane: l,
          action: k.action,
          eagerReducer: k.eagerReducer,
          eagerState: k.eagerState,
          next: null
        };
        null === h ? (g = h = n, f = d) : h = h.next = n;
        R.lanes |= l;
        Dg |= l;
      }
      k = k.next;
    } while (null !== k && k !== e);

    null === h ? f = d : h.next = g;
    He(d, b.memoizedState) || (ug = !0);
    b.memoizedState = d;
    b.baseState = f;
    b.baseQueue = h;
    c.lastRenderedState = d;
  }

  return [b.memoizedState, c.dispatch];
}

function Lh(a) {
  var b = Ih(),
      c = b.queue;
  if (null === c) throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch,
      e = c.pending,
      f = b.memoizedState;

  if (null !== e) {
    c.pending = null;
    var g = e = e.next;

    do {
      f = a(f, g.action), g = g.next;
    } while (g !== e);

    He(f, b.memoizedState) || (ug = !0);
    b.memoizedState = f;
    null === b.baseQueue && (b.baseState = f);
    c.lastRenderedState = f;
  }

  return [f, d];
}

function Mh(a, b, c) {
  var d = b._getVersion;
  d = d(b._source);
  var e = b._workInProgressVersionPrimary;
  if (null !== e) a = e === d;else if (a = a.mutableReadLanes, a = (xh & a) === a) b._workInProgressVersionPrimary = d, th.push(b);
  if (a) return c(b._source);
  th.push(b);
  throw Error(y(350));
}

function Nh(a, b, c, d) {
  var e = U;
  if (null === e) throw Error(y(349));
  var f = b._getVersion,
      g = f(b._source),
      h = vh.current,
      k = h.useState(function () {
    return Mh(e, b, c);
  }),
      l = k[1],
      n = k[0];
  k = T;
  var A = a.memoizedState,
      p = A.refs,
      C = p.getSnapshot,
      x = A.source;
  A = A.subscribe;
  var w = R;
  a.memoizedState = {
    refs: p,
    source: b,
    subscribe: d
  };
  h.useEffect(function () {
    p.getSnapshot = c;
    p.setSnapshot = l;
    var a = f(b._source);

    if (!He(g, a)) {
      a = c(b._source);
      He(n, a) || (l(a), a = Ig(w), e.mutableReadLanes |= a & e.pendingLanes);
      a = e.mutableReadLanes;
      e.entangledLanes |= a;

      for (var d = e.entanglements, h = a; 0 < h;) {
        var k = 31 - Vc(h),
            v = 1 << k;
        d[k] |= a;
        h &= ~v;
      }
    }
  }, [c, b, d]);
  h.useEffect(function () {
    return d(b._source, function () {
      var a = p.getSnapshot,
          c = p.setSnapshot;

      try {
        c(a(b._source));
        var d = Ig(w);
        e.mutableReadLanes |= d & e.pendingLanes;
      } catch (q) {
        c(function () {
          throw q;
        });
      }
    });
  }, [b, d]);
  He(C, c) && He(x, b) && He(A, d) || (a = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: Jh,
    lastRenderedState: n
  }, a.dispatch = l = Oh.bind(null, R, a), k.queue = a, k.baseQueue = null, n = Mh(e, b, c), k.memoizedState = k.baseState = n);
  return n;
}

function Ph(a, b, c) {
  var d = Ih();
  return Nh(d, a, b, c);
}

function Qh(a) {
  var b = Hh();
  "function" === typeof a && (a = a());
  b.memoizedState = b.baseState = a;
  a = b.queue = {
    pending: null,
    dispatch: null,
    lastRenderedReducer: Jh,
    lastRenderedState: a
  };
  a = a.dispatch = Oh.bind(null, R, a);
  return [b.memoizedState, a];
}

function Rh(a, b, c, d) {
  a = {
    tag: a,
    create: b,
    destroy: c,
    deps: d,
    next: null
  };
  b = R.updateQueue;
  null === b ? (b = {
    lastEffect: null
  }, R.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}

function Sh(a) {
  var b = Hh();
  a = {
    current: a
  };
  return b.memoizedState = a;
}

function Th() {
  return Ih().memoizedState;
}

function Uh(a, b, c, d) {
  var e = Hh();
  R.flags |= a;
  e.memoizedState = Rh(1 | b, c, void 0, void 0 === d ? null : d);
}

function Vh(a, b, c, d) {
  var e = Ih();
  d = void 0 === d ? null : d;
  var f = void 0;

  if (null !== S) {
    var g = S.memoizedState;
    f = g.destroy;

    if (null !== d && Bh(d, g.deps)) {
      Rh(b, c, f, d);
      return;
    }
  }

  R.flags |= a;
  e.memoizedState = Rh(1 | b, c, f, d);
}

function Wh(a, b) {
  return Uh(516, 4, a, b);
}

function Xh(a, b) {
  return Vh(516, 4, a, b);
}

function Yh(a, b) {
  return Vh(4, 2, a, b);
}

function Zh(a, b) {
  if ("function" === typeof b) return a = a(), b(a), function () {
    b(null);
  };
  if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
    b.current = null;
  };
}

function $h(a, b, c) {
  c = null !== c && void 0 !== c ? c.concat([a]) : null;
  return Vh(4, 2, Zh.bind(null, b, a), c);
}

function ai() {}

function bi(a, b) {
  var c = Ih();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Bh(b, d[1])) return d[0];
  c.memoizedState = [a, b];
  return a;
}

function ci(a, b) {
  var c = Ih();
  b = void 0 === b ? null : b;
  var d = c.memoizedState;
  if (null !== d && null !== b && Bh(b, d[1])) return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}

function di(a, b) {
  var c = eg();
  gg(98 > c ? 98 : c, function () {
    a(!0);
  });
  gg(97 < c ? 97 : c, function () {
    var c = wh.transition;
    wh.transition = 1;

    try {
      a(!1), b();
    } finally {
      wh.transition = c;
    }
  });
}

function Oh(a, b, c) {
  var d = Hg(),
      e = Ig(a),
      f = {
    lane: e,
    action: c,
    eagerReducer: null,
    eagerState: null,
    next: null
  },
      g = b.pending;
  null === g ? f.next = f : (f.next = g.next, g.next = f);
  b.pending = f;
  g = a.alternate;
  if (a === R || null !== g && g === R) zh = yh = !0;else {
    if (0 === a.lanes && (null === g || 0 === g.lanes) && (g = b.lastRenderedReducer, null !== g)) try {
      var h = b.lastRenderedState,
          k = g(h, c);
      f.eagerReducer = g;
      f.eagerState = k;
      if (He(k, h)) return;
    } catch (l) {} finally {}
    Jg(a, e, d);
  }
}

var Gh = {
  readContext: vg,
  useCallback: Ah,
  useContext: Ah,
  useEffect: Ah,
  useImperativeHandle: Ah,
  useLayoutEffect: Ah,
  useMemo: Ah,
  useReducer: Ah,
  useRef: Ah,
  useState: Ah,
  useDebugValue: Ah,
  useDeferredValue: Ah,
  useTransition: Ah,
  useMutableSource: Ah,
  useOpaqueIdentifier: Ah,
  unstable_isNewReconciler: !1
},
    Dh = {
  readContext: vg,
  useCallback: function useCallback(a, b) {
    Hh().memoizedState = [a, void 0 === b ? null : b];
    return a;
  },
  useContext: vg,
  useEffect: Wh,
  useImperativeHandle: function useImperativeHandle(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return Uh(4, 2, Zh.bind(null, b, a), c);
  },
  useLayoutEffect: function useLayoutEffect(a, b) {
    return Uh(4, 2, a, b);
  },
  useMemo: function useMemo(a, b) {
    var c = Hh();
    b = void 0 === b ? null : b;
    a = a();
    c.memoizedState = [a, b];
    return a;
  },
  useReducer: function useReducer(a, b, c) {
    var d = Hh();
    b = void 0 !== c ? c(b) : b;
    d.memoizedState = d.baseState = b;
    a = d.queue = {
      pending: null,
      dispatch: null,
      lastRenderedReducer: a,
      lastRenderedState: b
    };
    a = a.dispatch = Oh.bind(null, R, a);
    return [d.memoizedState, a];
  },
  useRef: Sh,
  useState: Qh,
  useDebugValue: ai,
  useDeferredValue: function useDeferredValue(a) {
    var b = Qh(a),
        c = b[0],
        d = b[1];
    Wh(function () {
      var b = wh.transition;
      wh.transition = 1;

      try {
        d(a);
      } finally {
        wh.transition = b;
      }
    }, [a]);
    return c;
  },
  useTransition: function useTransition() {
    var a = Qh(!1),
        b = a[0];
    a = di.bind(null, a[1]);
    Sh(a);
    return [a, b];
  },
  useMutableSource: function useMutableSource(a, b, c) {
    var d = Hh();
    d.memoizedState = {
      refs: {
        getSnapshot: b,
        setSnapshot: null
      },
      source: a,
      subscribe: c
    };
    return Nh(d, a, b, c);
  },
  useOpaqueIdentifier: function useOpaqueIdentifier() {
    if (lh) {
      var a = !1,
          b = uf(function () {
        a || (a = !0, c("r:" + (tf++).toString(36)));
        throw Error(y(355));
      }),
          c = Qh(b)[1];
      0 === (R.mode & 2) && (R.flags |= 516, Rh(5, function () {
        c("r:" + (tf++).toString(36));
      }, void 0, null));
      return b;
    }

    b = "r:" + (tf++).toString(36);
    Qh(b);
    return b;
  },
  unstable_isNewReconciler: !1
},
    Eh = {
  readContext: vg,
  useCallback: bi,
  useContext: vg,
  useEffect: Xh,
  useImperativeHandle: $h,
  useLayoutEffect: Yh,
  useMemo: ci,
  useReducer: Kh,
  useRef: Th,
  useState: function useState() {
    return Kh(Jh);
  },
  useDebugValue: ai,
  useDeferredValue: function useDeferredValue(a) {
    var b = Kh(Jh),
        c = b[0],
        d = b[1];
    Xh(function () {
      var b = wh.transition;
      wh.transition = 1;

      try {
        d(a);
      } finally {
        wh.transition = b;
      }
    }, [a]);
    return c;
  },
  useTransition: function useTransition() {
    var a = Kh(Jh)[0];
    return [Th().current, a];
  },
  useMutableSource: Ph,
  useOpaqueIdentifier: function useOpaqueIdentifier() {
    return Kh(Jh)[0];
  },
  unstable_isNewReconciler: !1
},
    Fh = {
  readContext: vg,
  useCallback: bi,
  useContext: vg,
  useEffect: Xh,
  useImperativeHandle: $h,
  useLayoutEffect: Yh,
  useMemo: ci,
  useReducer: Lh,
  useRef: Th,
  useState: function useState() {
    return Lh(Jh);
  },
  useDebugValue: ai,
  useDeferredValue: function useDeferredValue(a) {
    var b = Lh(Jh),
        c = b[0],
        d = b[1];
    Xh(function () {
      var b = wh.transition;
      wh.transition = 1;

      try {
        d(a);
      } finally {
        wh.transition = b;
      }
    }, [a]);
    return c;
  },
  useTransition: function useTransition() {
    var a = Lh(Jh)[0];
    return [Th().current, a];
  },
  useMutableSource: Ph,
  useOpaqueIdentifier: function useOpaqueIdentifier() {
    return Lh(Jh)[0];
  },
  unstable_isNewReconciler: !1
},
    ei = ra.ReactCurrentOwner,
    ug = !1;

function fi(a, b, c, d) {
  b.child = null === a ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
}

function gi(a, b, c, d, e) {
  c = c.render;
  var f = b.ref;
  tg(b, e);
  d = Ch(a, b, c, d, f, e);
  if (null !== a && !ug) return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
  b.flags |= 1;
  fi(a, b, d, e);
  return b.child;
}

function ii(a, b, c, d, e, f) {
  if (null === a) {
    var g = c.type;
    if ("function" === typeof g && !ji(g) && void 0 === g.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);
    a = Vg(c.type, null, d, b, b.mode, f);
    a.ref = b.ref;
    a["return"] = b;
    return b.child = a;
  }

  g = a.child;
  if (0 === (e & f) && (e = g.memoizedProps, c = c.compare, c = null !== c ? c : Je, c(e, d) && a.ref === b.ref)) return hi(a, b, f);
  b.flags |= 1;
  a = Tg(g, d);
  a.ref = b.ref;
  a["return"] = b;
  return b.child = a;
}

function ki(a, b, c, d, e, f) {
  if (null !== a && Je(a.memoizedProps, d) && a.ref === b.ref) if (ug = !1, 0 !== (f & e)) 0 !== (a.flags & 16384) && (ug = !0);else return b.lanes = a.lanes, hi(a, b, f);
  return li(a, b, c, d, f);
}

function mi(a, b, c) {
  var d = b.pendingProps,
      e = d.children,
      f = null !== a ? a.memoizedState : null;
  if ("hidden" === d.mode || "unstable-defer-without-hiding" === d.mode) {
    if (0 === (b.mode & 4)) b.memoizedState = {
      baseLanes: 0
    }, ni(b, c);else if (0 !== (c & 1073741824)) b.memoizedState = {
      baseLanes: 0
    }, ni(b, null !== f ? f.baseLanes : c);else return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {
      baseLanes: a
    }, ni(b, a), null;
  } else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
  fi(a, b, e, c);
  return b.child;
}

function oi(a, b) {
  var c = b.ref;
  if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 128;
}

function li(a, b, c, d, e) {
  var f = Ff(c) ? Df : M.current;
  f = Ef(b, f);
  tg(b, e);
  c = Ch(a, b, c, d, f, e);
  if (null !== a && !ug) return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
  b.flags |= 1;
  fi(a, b, c, e);
  return b.child;
}

function pi(a, b, c, d, e) {
  if (Ff(c)) {
    var f = !0;
    Jf(b);
  } else f = !1;

  tg(b, e);
  if (null === b.stateNode) null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = !0;else if (null === a) {
    var g = b.stateNode,
        h = b.memoizedProps;
    g.props = h;
    var k = g.context,
        l = c.contextType;
    "object" === typeof l && null !== l ? l = vg(l) : (l = Ff(c) ? Df : M.current, l = Ef(b, l));
    var n = c.getDerivedStateFromProps,
        A = "function" === typeof n || "function" === typeof g.getSnapshotBeforeUpdate;
    A || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Ng(b, g, d, l);
    wg = !1;
    var p = b.memoizedState;
    g.state = p;
    Cg(b, d, g, e);
    k = b.memoizedState;
    h !== d || p !== k || N.current || wg ? ("function" === typeof n && (Gg(b, c, n, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p, k, l)) ? (A || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4)) : ("function" === typeof g.componentDidMount && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4), d = !1);
  } else {
    g = b.stateNode;
    yg(a, b);
    h = b.memoizedProps;
    l = b.type === b.elementType ? h : lg(b.type, h);
    g.props = l;
    A = b.pendingProps;
    p = g.context;
    k = c.contextType;
    "object" === typeof k && null !== k ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
    var C = c.getDerivedStateFromProps;
    (n = "function" === typeof C || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== A || p !== k) && Ng(b, g, d, k);
    wg = !1;
    p = b.memoizedState;
    g.state = p;
    Cg(b, d, g, e);
    var x = b.memoizedState;
    h !== A || p !== x || N.current || wg ? ("function" === typeof C && (Gg(b, c, C, d), x = b.memoizedState), (l = wg || Lg(b, c, l, d, p, x, k)) ? (n || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, x, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, x, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 256)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x), g.props = d, g.state = x, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), d = !1);
  }
  return qi(a, b, c, d, f, e);
}

function qi(a, b, c, d, e, f) {
  oi(a, b);
  var g = 0 !== (b.flags & 64);
  if (!d && !g) return e && Kf(b, c, !1), hi(a, b, f);
  d = b.stateNode;
  ei.current = b;
  var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
  b.flags |= 1;
  null !== a && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);
  b.memoizedState = d.state;
  e && Kf(b, c, !0);
  return b.child;
}

function ri(a) {
  var b = a.stateNode;
  b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, !1);
  eh(a, b.containerInfo);
}

var si = {
  dehydrated: null,
  retryLane: 0
};

function ti(a, b, c) {
  var d = b.pendingProps,
      e = P.current,
      f = !1,
      g;
  (g = 0 !== (b.flags & 64)) || (g = null !== a && null === a.memoizedState ? !1 : 0 !== (e & 2));
  g ? (f = !0, b.flags &= -65) : null !== a && null === a.memoizedState || void 0 === d.fallback || !0 === d.unstable_avoidThisFallback || (e |= 1);
  I(P, e & 1);

  if (null === a) {
    void 0 !== d.fallback && ph(b);
    a = d.children;
    e = d.fallback;
    if (f) return a = ui(b, a, e, c), b.child.memoizedState = {
      baseLanes: c
    }, b.memoizedState = si, a;
    if ("number" === typeof d.unstable_expectedLoadTime) return a = ui(b, a, e, c), b.child.memoizedState = {
      baseLanes: c
    }, b.memoizedState = si, b.lanes = 33554432, a;
    c = vi({
      mode: "visible",
      children: a
    }, b.mode, c, null);
    c["return"] = b;
    return b.child = c;
  }

  if (null !== a.memoizedState) {
    if (f) return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? {
      baseLanes: c
    } : {
      baseLanes: e.baseLanes | c
    }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
    c = xi(a, b, d.children, c);
    b.memoizedState = null;
    return c;
  }

  if (f) return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? {
    baseLanes: c
  } : {
    baseLanes: e.baseLanes | c
  }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
  c = xi(a, b, d.children, c);
  b.memoizedState = null;
  return c;
}

function ui(a, b, c, d) {
  var e = a.mode,
      f = a.child;
  b = {
    mode: "hidden",
    children: b
  };
  0 === (e & 2) && null !== f ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);
  c = Xg(c, e, d, null);
  f["return"] = a;
  c["return"] = a;
  f.sibling = c;
  a.child = f;
  return c;
}

function xi(a, b, c, d) {
  var e = a.child;
  a = e.sibling;
  c = Tg(e, {
    mode: "visible",
    children: c
  });
  0 === (b.mode & 2) && (c.lanes = d);
  c["return"] = b;
  c.sibling = null;
  null !== a && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
  return b.child = c;
}

function wi(a, b, c, d, e) {
  var f = b.mode,
      g = a.child;
  a = g.sibling;
  var h = {
    mode: "hidden",
    children: c
  };
  0 === (f & 2) && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, null !== g ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);
  null !== a ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);
  d["return"] = b;
  c["return"] = b;
  c.sibling = d;
  b.child = c;
  return d;
}

function yi(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  sg(a["return"], b);
}

function zi(a, b, c, d, e, f) {
  var g = a.memoizedState;
  null === g ? a.memoizedState = {
    isBackwards: b,
    rendering: null,
    renderingStartTime: 0,
    last: d,
    tail: c,
    tailMode: e,
    lastEffect: f
  } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);
}

function Ai(a, b, c) {
  var d = b.pendingProps,
      e = d.revealOrder,
      f = d.tail;
  fi(a, b, d.children, c);
  d = P.current;
  if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 64;else {
    if (null !== a && 0 !== (a.flags & 64)) a: for (a = b.child; null !== a;) {
      if (13 === a.tag) null !== a.memoizedState && yi(a, c);else if (19 === a.tag) yi(a, c);else if (null !== a.child) {
        a.child["return"] = a;
        a = a.child;
        continue;
      }
      if (a === b) break a;

      for (; null === a.sibling;) {
        if (null === a["return"] || a["return"] === b) break a;
        a = a["return"];
      }

      a.sibling["return"] = a["return"];
      a = a.sibling;
    }
    d &= 1;
  }
  I(P, d);
  if (0 === (b.mode & 2)) b.memoizedState = null;else switch (e) {
    case "forwards":
      c = b.child;

      for (e = null; null !== c;) {
        a = c.alternate, null !== a && null === ih(a) && (e = c), c = c.sibling;
      }

      c = e;
      null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
      zi(b, !1, e, c, f, b.lastEffect);
      break;

    case "backwards":
      c = null;
      e = b.child;

      for (b.child = null; null !== e;) {
        a = e.alternate;

        if (null !== a && null === ih(a)) {
          b.child = e;
          break;
        }

        a = e.sibling;
        e.sibling = c;
        c = e;
        e = a;
      }

      zi(b, !0, c, null, f, b.lastEffect);
      break;

    case "together":
      zi(b, !1, null, null, void 0, b.lastEffect);
      break;

    default:
      b.memoizedState = null;
  }
  return b.child;
}

function hi(a, b, c) {
  null !== a && (b.dependencies = a.dependencies);
  Dg |= b.lanes;

  if (0 !== (c & b.childLanes)) {
    if (null !== a && b.child !== a.child) throw Error(y(153));

    if (null !== b.child) {
      a = b.child;
      c = Tg(a, a.pendingProps);
      b.child = c;

      for (c["return"] = b; null !== a.sibling;) {
        a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c["return"] = b;
      }

      c.sibling = null;
    }

    return b.child;
  }

  return null;
}

var Bi, Ci, Di, Ei;

Bi = function Bi(a, b) {
  for (var c = b.child; null !== c;) {
    if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);else if (4 !== c.tag && null !== c.child) {
      c.child["return"] = c;
      c = c.child;
      continue;
    }
    if (c === b) break;

    for (; null === c.sibling;) {
      if (null === c["return"] || c["return"] === b) return;
      c = c["return"];
    }

    c.sibling["return"] = c["return"];
    c = c.sibling;
  }
};

Ci = function Ci() {};

Di = function Di(a, b, c, d) {
  var e = a.memoizedProps;

  if (e !== d) {
    a = b.stateNode;
    dh(ah.current);
    var f = null;

    switch (c) {
      case "input":
        e = Ya(a, e);
        d = Ya(a, d);
        f = [];
        break;

      case "option":
        e = eb(a, e);
        d = eb(a, d);
        f = [];
        break;

      case "select":
        e = m({}, e, {
          value: void 0
        });
        d = m({}, d, {
          value: void 0
        });
        f = [];
        break;

      case "textarea":
        e = gb(a, e);
        d = gb(a, d);
        f = [];
        break;

      default:
        "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = jf);
    }

    vb(c, d);
    var g;
    c = null;

    for (l in e) {
      if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
        var h = e[l];

        for (g in h) {
          h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        }
      } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ca.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));
    }

    for (l in d) {
      var k = d[l];
      h = null != e ? e[l] : void 0;
      if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) {
        if (h) {
          for (g in h) {
            !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
          }

          for (g in k) {
            k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          }
        } else c || (f || (f = []), f.push(l, c)), c = k;
      } else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ca.hasOwnProperty(l) ? (null != k && "onScroll" === l && G("scroll", a), f || h === k || (f = [])) : "object" === typeof k && null !== k && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l, k));
    }

    c && (f = f || []).push("style", c);
    var l = f;
    if (b.updateQueue = l) b.flags |= 4;
  }
};

Ei = function Ei(a, b, c, d) {
  c !== d && (b.flags |= 4);
};

function Fi(a, b) {
  if (!lh) switch (a.tailMode) {
    case "hidden":
      b = a.tail;

      for (var c = null; null !== b;) {
        null !== b.alternate && (c = b), b = b.sibling;
      }

      null === c ? a.tail = null : c.sibling = null;
      break;

    case "collapsed":
      c = a.tail;

      for (var d = null; null !== c;) {
        null !== c.alternate && (d = c), c = c.sibling;
      }

      null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
  }
}

function Gi(a, b, c) {
  var d = b.pendingProps;

  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;

    case 1:
      return Ff(b.type) && Gf(), null;

    case 3:
      fh();
      H(N);
      H(M);
      uh();
      d = b.stateNode;
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (null === a || null === a.child) rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
      Ci(b);
      return null;

    case 5:
      hh(b);
      var e = dh(ch.current);
      c = b.type;
      if (null !== a && null != b.stateNode) Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);else {
        if (!d) {
          if (null === b.stateNode) throw Error(y(166));
          return null;
        }

        a = dh(ah.current);

        if (rh(b)) {
          d = b.stateNode;
          c = b.type;
          var f = b.memoizedProps;
          d[wf] = b;
          d[xf] = f;

          switch (c) {
            case "dialog":
              G("cancel", d);
              G("close", d);
              break;

            case "iframe":
            case "object":
            case "embed":
              G("load", d);
              break;

            case "video":
            case "audio":
              for (a = 0; a < Xe.length; a++) {
                G(Xe[a], d);
              }

              break;

            case "source":
              G("error", d);
              break;

            case "img":
            case "image":
            case "link":
              G("error", d);
              G("load", d);
              break;

            case "details":
              G("toggle", d);
              break;

            case "input":
              Za(d, f);
              G("invalid", d);
              break;

            case "select":
              d._wrapperState = {
                wasMultiple: !!f.multiple
              };
              G("invalid", d);
              break;

            case "textarea":
              hb(d, f), G("invalid", d);
          }

          vb(c, f);
          a = null;

          for (var g in f) {
            f.hasOwnProperty(g) && (e = f[g], "children" === g ? "string" === typeof e ? d.textContent !== e && (a = ["children", e]) : "number" === typeof e && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g) && null != e && "onScroll" === g && G("scroll", d));
          }

          switch (c) {
            case "input":
              Va(d);
              cb(d, f, !0);
              break;

            case "textarea":
              Va(d);
              jb(d);
              break;

            case "select":
            case "option":
              break;

            default:
              "function" === typeof f.onClick && (d.onclick = jf);
          }

          d = a;
          b.updateQueue = d;
          null !== d && (b.flags |= 4);
        } else {
          g = 9 === e.nodeType ? e : e.ownerDocument;
          a === kb.html && (a = lb(c));
          a === kb.html ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script>\x3c/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, {
            is: d.is
          }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = !0 : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
          a[wf] = b;
          a[xf] = d;
          Bi(a, b, !1, !1);
          b.stateNode = a;
          g = wb(c, d);

          switch (c) {
            case "dialog":
              G("cancel", a);
              G("close", a);
              e = d;
              break;

            case "iframe":
            case "object":
            case "embed":
              G("load", a);
              e = d;
              break;

            case "video":
            case "audio":
              for (e = 0; e < Xe.length; e++) {
                G(Xe[e], a);
              }

              e = d;
              break;

            case "source":
              G("error", a);
              e = d;
              break;

            case "img":
            case "image":
            case "link":
              G("error", a);
              G("load", a);
              e = d;
              break;

            case "details":
              G("toggle", a);
              e = d;
              break;

            case "input":
              Za(a, d);
              e = Ya(a, d);
              G("invalid", a);
              break;

            case "option":
              e = eb(a, d);
              break;

            case "select":
              a._wrapperState = {
                wasMultiple: !!d.multiple
              };
              e = m({}, d, {
                value: void 0
              });
              G("invalid", a);
              break;

            case "textarea":
              hb(a, d);
              e = gb(a, d);
              G("invalid", a);
              break;

            default:
              e = d;
          }

          vb(c, e);
          var h = e;

          for (f in h) {
            if (h.hasOwnProperty(f)) {
              var k = h[f];
              "style" === f ? tb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && ob(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && pb(a, k) : "number" === typeof k && pb(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ca.hasOwnProperty(f) ? null != k && "onScroll" === f && G("scroll", a) : null != k && qa(a, f, k, g));
            }
          }

          switch (c) {
            case "input":
              Va(a);
              cb(a, d, !1);
              break;

            case "textarea":
              Va(a);
              jb(a);
              break;

            case "option":
              null != d.value && a.setAttribute("value", "" + Sa(d.value));
              break;

            case "select":
              a.multiple = !!d.multiple;
              f = d.value;
              null != f ? fb(a, !!d.multiple, f, !1) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, !0);
              break;

            default:
              "function" === typeof e.onClick && (a.onclick = jf);
          }

          mf(c, d) && (b.flags |= 4);
        }

        null !== b.ref && (b.flags |= 128);
      }
      return null;

    case 6:
      if (a && null != b.stateNode) Ei(a, b, a.memoizedProps, d);else {
        if ("string" !== typeof d && null === b.stateNode) throw Error(y(166));
        c = dh(ch.current);
        dh(ah.current);
        rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
      }
      return null;

    case 13:
      H(P);
      d = b.memoizedState;
      if (0 !== (b.flags & 64)) return b.lanes = c, b;
      d = null !== d;
      c = !1;
      null === a ? void 0 !== b.memoizedProps.fallback && rh(b) : c = null !== a.memoizedState;
      if (d && !c && 0 !== (b.mode & 2)) if (null === a && !0 !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (P.current & 1)) 0 === V && (V = 3);else {
        if (0 === V || 3 === V) V = 4;
        null === U || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U, W);
      }
      if (d || c) b.flags |= 4;
      return null;

    case 4:
      return fh(), Ci(b), null === a && cf(b.stateNode.containerInfo), null;

    case 10:
      return rg(b), null;

    case 17:
      return Ff(b.type) && Gf(), null;

    case 19:
      H(P);
      d = b.memoizedState;
      if (null === d) return null;
      f = 0 !== (b.flags & 64);
      g = d.rendering;
      if (null === g) {
        if (f) Fi(d, !1);else {
          if (0 !== V || null !== a && 0 !== (a.flags & 64)) for (a = b.child; null !== a;) {
            g = ih(a);

            if (null !== g) {
              b.flags |= 64;
              Fi(d, !1);
              f = g.updateQueue;
              null !== f && (b.updateQueue = f, b.flags |= 4);
              null === d.lastEffect && (b.firstEffect = null);
              b.lastEffect = d.lastEffect;
              d = c;

              for (c = b.child; null !== c;) {
                f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : {
                  lanes: a.lanes,
                  firstContext: a.firstContext
                }), c = c.sibling;
              }

              I(P, P.current & 1 | 2);
              return b.child;
            }

            a = a.sibling;
          }
          null !== d.tail && O() > Ji && (b.flags |= 64, f = !0, Fi(d, !1), b.lanes = 33554432);
        }
      } else {
        if (!f) if (a = ih(g), null !== a) {
          if (b.flags |= 64, f = !0, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Fi(d, !0), null === d.tail && "hidden" === d.tailMode && !g.alternate && !lh) return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
        } else 2 * O() - d.renderingStartTime > Ji && 1073741824 !== c && (b.flags |= 64, f = !0, Fi(d, !1), b.lanes = 33554432);
        d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, null !== c ? c.sibling = g : b.child = g, d.last = g);
      }
      return null !== d.tail ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f ? b & 1 | 2 : b & 1), c) : null;

    case 23:
    case 24:
      return Ki(), null !== a && null !== a.memoizedState !== (null !== b.memoizedState) && "unstable-defer-without-hiding" !== d.mode && (b.flags |= 4), null;
  }

  throw Error(y(156, b.tag));
}

function Li(a) {
  switch (a.tag) {
    case 1:
      Ff(a.type) && Gf();
      var b = a.flags;
      return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;

    case 3:
      fh();
      H(N);
      H(M);
      uh();
      b = a.flags;
      if (0 !== (b & 64)) throw Error(y(285));
      a.flags = b & -4097 | 64;
      return a;

    case 5:
      return hh(a), null;

    case 13:
      return H(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;

    case 19:
      return H(P), null;

    case 4:
      return fh(), null;

    case 10:
      return rg(a), null;

    case 23:
    case 24:
      return Ki(), null;

    default:
      return null;
  }
}

function Mi(a, b) {
  try {
    var c = "",
        d = b;

    do {
      c += Qa(d), d = d["return"];
    } while (d);

    var e = c;
  } catch (f) {
    e = "\nError generating stack: " + f.message + "\n" + f.stack;
  }

  return {
    value: a,
    source: b,
    stack: e
  };
}

function Ni(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function () {
      throw c;
    });
  }
}

var Oi = "function" === typeof WeakMap ? WeakMap : Map;

function Pi(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  c.payload = {
    element: null
  };
  var d = b.value;

  c.callback = function () {
    Qi || (Qi = !0, Ri = d);
    Ni(a, b);
  };

  return c;
}

function Si(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;

  if ("function" === typeof d) {
    var e = b.value;

    c.payload = function () {
      Ni(a, b);
      return d(e);
    };
  }

  var f = a.stateNode;
  null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
    "function" !== typeof d && (null === Ti ? Ti = new Set([this]) : Ti.add(this), Ni(a, b));
    var c = b.stack;
    this.componentDidCatch(b.value, {
      componentStack: null !== c ? c : ""
    });
  });
  return c;
}

var Ui = "function" === typeof WeakSet ? WeakSet : Set;

function Vi(a) {
  var b = a.ref;
  if (null !== b) if ("function" === typeof b) try {
    b(null);
  } catch (c) {
    Wi(a, c);
  } else b.current = null;
}

function Xi(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;

    case 1:
      if (b.flags & 256 && null !== a) {
        var c = a.memoizedProps,
            d = a.memoizedState;
        a = b.stateNode;
        b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
        a.__reactInternalSnapshotBeforeUpdate = b;
      }

      return;

    case 3:
      b.flags & 256 && qf(b.stateNode.containerInfo);
      return;

    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }

  throw Error(y(163));
}

function Yi(a, b, c) {
  switch (c.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      b = c.updateQueue;
      b = null !== b ? b.lastEffect : null;

      if (null !== b) {
        a = b = b.next;

        do {
          if (3 === (a.tag & 3)) {
            var d = a.create;
            a.destroy = d();
          }

          a = a.next;
        } while (a !== b);
      }

      b = c.updateQueue;
      b = null !== b ? b.lastEffect : null;

      if (null !== b) {
        a = b = b.next;

        do {
          var e = a;
          d = e.next;
          e = e.tag;
          0 !== (e & 4) && 0 !== (e & 1) && (Zi(c, a), $i(c, a));
          a = d;
        } while (a !== b);
      }

      return;

    case 1:
      a = c.stateNode;
      c.flags & 4 && (null === b ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(d, b.memoizedState, a.__reactInternalSnapshotBeforeUpdate)));
      b = c.updateQueue;
      null !== b && Eg(c, b, a);
      return;

    case 3:
      b = c.updateQueue;

      if (null !== b) {
        a = null;
        if (null !== c.child) switch (c.child.tag) {
          case 5:
            a = c.child.stateNode;
            break;

          case 1:
            a = c.child.stateNode;
        }
        Eg(c, b, a);
      }

      return;

    case 5:
      a = c.stateNode;
      null === b && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
      return;

    case 6:
      return;

    case 4:
      return;

    case 12:
      return;

    case 13:
      null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && Cc(c))));
      return;

    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }

  throw Error(y(163));
}

function aj(a, b) {
  for (var c = a;;) {
    if (5 === c.tag) {
      var d = c.stateNode;
      if (b) d = d.style, "function" === typeof d.setProperty ? d.setProperty("display", "none", "important") : d.display = "none";else {
        d = c.stateNode;
        var e = c.memoizedProps.style;
        e = void 0 !== e && null !== e && e.hasOwnProperty("display") ? e.display : null;
        d.style.display = sb("display", e);
      }
    } else if (6 === c.tag) c.stateNode.nodeValue = b ? "" : c.memoizedProps;else if ((23 !== c.tag && 24 !== c.tag || null === c.memoizedState || c === a) && null !== c.child) {
      c.child["return"] = c;
      c = c.child;
      continue;
    }

    if (c === a) break;

    for (; null === c.sibling;) {
      if (null === c["return"] || c["return"] === a) return;
      c = c["return"];
    }

    c.sibling["return"] = c["return"];
    c = c.sibling;
  }
}

function bj(a, b) {
  if (Mf && "function" === typeof Mf.onCommitFiberUnmount) try {
    Mf.onCommitFiberUnmount(Lf, b);
  } catch (f) {}

  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      a = b.updateQueue;

      if (null !== a && (a = a.lastEffect, null !== a)) {
        var c = a = a.next;

        do {
          var d = c,
              e = d.destroy;
          d = d.tag;
          if (void 0 !== e) if (0 !== (d & 4)) Zi(b, c);else {
            d = b;

            try {
              e();
            } catch (f) {
              Wi(d, f);
            }
          }
          c = c.next;
        } while (c !== a);
      }

      break;

    case 1:
      Vi(b);
      a = b.stateNode;
      if ("function" === typeof a.componentWillUnmount) try {
        a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
      } catch (f) {
        Wi(b, f);
      }
      break;

    case 5:
      Vi(b);
      break;

    case 4:
      cj(a, b);
  }
}

function dj(a) {
  a.alternate = null;
  a.child = null;
  a.dependencies = null;
  a.firstEffect = null;
  a.lastEffect = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a["return"] = null;
  a.updateQueue = null;
}

function ej(a) {
  return 5 === a.tag || 3 === a.tag || 4 === a.tag;
}

function fj(a) {
  a: {
    for (var b = a["return"]; null !== b;) {
      if (ej(b)) break a;
      b = b["return"];
    }

    throw Error(y(160));
  }

  var c = b;
  b = c.stateNode;

  switch (c.tag) {
    case 5:
      var d = !1;
      break;

    case 3:
      b = b.containerInfo;
      d = !0;
      break;

    case 4:
      b = b.containerInfo;
      d = !0;
      break;

    default:
      throw Error(y(161));
  }

  c.flags & 16 && (pb(b, ""), c.flags &= -17);

  a: b: for (c = a;;) {
    for (; null === c.sibling;) {
      if (null === c["return"] || ej(c["return"])) {
        c = null;
        break a;
      }

      c = c["return"];
    }

    c.sibling["return"] = c["return"];

    for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag;) {
      if (c.flags & 2) continue b;
      if (null === c.child || 4 === c.tag) continue b;else c.child["return"] = c, c = c.child;
    }

    if (!(c.flags & 2)) {
      c = c.stateNode;
      break a;
    }
  }

  d ? gj(a, c, b) : hj(a, c, b);
}

function gj(a, b, c) {
  var d = a.tag,
      e = 5 === d || 6 === d;
  if (e) a = e ? a.stateNode : a.stateNode.instance, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = jf));else if (4 !== d && (a = a.child, null !== a)) for (gj(a, b, c), a = a.sibling; null !== a;) {
    gj(a, b, c), a = a.sibling;
  }
}

function hj(a, b, c) {
  var d = a.tag,
      e = 5 === d || 6 === d;
  if (e) a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);else if (4 !== d && (a = a.child, null !== a)) for (hj(a, b, c), a = a.sibling; null !== a;) {
    hj(a, b, c), a = a.sibling;
  }
}

function cj(a, b) {
  for (var c = b, d = !1, e, f;;) {
    if (!d) {
      d = c["return"];

      a: for (;;) {
        if (null === d) throw Error(y(160));
        e = d.stateNode;

        switch (d.tag) {
          case 5:
            f = !1;
            break a;

          case 3:
            e = e.containerInfo;
            f = !0;
            break a;

          case 4:
            e = e.containerInfo;
            f = !0;
            break a;
        }

        d = d["return"];
      }

      d = !0;
    }

    if (5 === c.tag || 6 === c.tag) {
      a: for (var g = a, h = c, k = h;;) {
        if (bj(g, k), null !== k.child && 4 !== k.tag) k.child["return"] = k, k = k.child;else {
          if (k === h) break a;

          for (; null === k.sibling;) {
            if (null === k["return"] || k["return"] === h) break a;
            k = k["return"];
          }

          k.sibling["return"] = k["return"];
          k = k.sibling;
        }
      }

      f ? (g = e, h = c.stateNode, 8 === g.nodeType ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);
    } else if (4 === c.tag) {
      if (null !== c.child) {
        e = c.stateNode.containerInfo;
        f = !0;
        c.child["return"] = c;
        c = c.child;
        continue;
      }
    } else if (bj(a, c), null !== c.child) {
      c.child["return"] = c;
      c = c.child;
      continue;
    }

    if (c === b) break;

    for (; null === c.sibling;) {
      if (null === c["return"] || c["return"] === b) return;
      c = c["return"];
      4 === c.tag && (d = !1);
    }

    c.sibling["return"] = c["return"];
    c = c.sibling;
  }
}

function ij(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var c = b.updateQueue;
      c = null !== c ? c.lastEffect : null;

      if (null !== c) {
        var d = c = c.next;

        do {
          3 === (d.tag & 3) && (a = d.destroy, d.destroy = void 0, void 0 !== a && a()), d = d.next;
        } while (d !== c);
      }

      return;

    case 1:
      return;

    case 5:
      c = b.stateNode;

      if (null != c) {
        d = b.memoizedProps;
        var e = null !== a ? a.memoizedProps : d;
        a = b.type;
        var f = b.updateQueue;
        b.updateQueue = null;

        if (null !== f) {
          c[xf] = d;
          "input" === a && "radio" === d.type && null != d.name && $a(c, d);
          wb(a, e);
          b = wb(a, d);

          for (e = 0; e < f.length; e += 2) {
            var g = f[e],
                h = f[e + 1];
            "style" === g ? tb(c, h) : "dangerouslySetInnerHTML" === g ? ob(c, h) : "children" === g ? pb(c, h) : qa(c, g, h, b);
          }

          switch (a) {
            case "input":
              ab(c, d);
              break;

            case "textarea":
              ib(c, d);
              break;

            case "select":
              a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, null != f ? fb(c, !!d.multiple, f, !1) : a !== !!d.multiple && (null != d.defaultValue ? fb(c, !!d.multiple, d.defaultValue, !0) : fb(c, !!d.multiple, d.multiple ? [] : "", !1));
          }
        }
      }

      return;

    case 6:
      if (null === b.stateNode) throw Error(y(162));
      b.stateNode.nodeValue = b.memoizedProps;
      return;

    case 3:
      c = b.stateNode;
      c.hydrate && (c.hydrate = !1, Cc(c.containerInfo));
      return;

    case 12:
      return;

    case 13:
      null !== b.memoizedState && (jj = O(), aj(b.child, !0));
      kj(b);
      return;

    case 19:
      kj(b);
      return;

    case 17:
      return;

    case 23:
    case 24:
      aj(b, null !== b.memoizedState);
      return;
  }

  throw Error(y(163));
}

function kj(a) {
  var b = a.updateQueue;

  if (null !== b) {
    a.updateQueue = null;
    var c = a.stateNode;
    null === c && (c = a.stateNode = new Ui());
    b.forEach(function (b) {
      var d = lj.bind(null, a, b);
      c.has(b) || (c.add(b), b.then(d, d));
    });
  }
}

function mj(a, b) {
  return null !== a && (a = a.memoizedState, null === a || null !== a.dehydrated) ? (b = b.memoizedState, null !== b && null === b.dehydrated) : !1;
}

var nj = Math.ceil,
    oj = ra.ReactCurrentDispatcher,
    pj = ra.ReactCurrentOwner,
    X = 0,
    U = null,
    Y = null,
    W = 0,
    qj = 0,
    rj = Bf(0),
    V = 0,
    sj = null,
    tj = 0,
    Dg = 0,
    Hi = 0,
    uj = 0,
    vj = null,
    jj = 0,
    Ji = Infinity;

function wj() {
  Ji = O() + 500;
}

var Z = null,
    Qi = !1,
    Ri = null,
    Ti = null,
    xj = !1,
    yj = null,
    zj = 90,
    Aj = [],
    Bj = [],
    Cj = null,
    Dj = 0,
    Ej = null,
    Fj = -1,
    Gj = 0,
    Hj = 0,
    Ij = null,
    Jj = !1;

function Hg() {
  return 0 !== (X & 48) ? O() : -1 !== Fj ? Fj : Fj = O();
}

function Ig(a) {
  a = a.mode;
  if (0 === (a & 2)) return 1;
  if (0 === (a & 4)) return 99 === eg() ? 1 : 2;
  0 === Gj && (Gj = tj);

  if (0 !== kg.transition) {
    0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
    a = Gj;
    var b = 4186112 & ~Hj;
    b &= -b;
    0 === b && (a = 4186112 & ~a, b = a & -a, 0 === b && (b = 8192));
    return b;
  }

  a = eg();
  0 !== (X & 4) && 98 === a ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
  return a;
}

function Jg(a, b, c) {
  if (50 < Dj) throw Dj = 0, Ej = null, Error(y(185));
  a = Kj(a, b);
  if (null === a) return null;
  $c(a, b, c);
  a === U && (Hi |= b, 4 === V && Ii(a, W));
  var d = eg();
  1 === b ? 0 !== (X & 8) && 0 === (X & 48) ? Lj(a) : (Mj(a, c), 0 === X && (wj(), ig())) : (0 === (X & 4) || 98 !== d && 99 !== d || (null === Cj ? Cj = new Set([a]) : Cj.add(a)), Mj(a, c));
  vj = a;
}

function Kj(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  null !== c && (c.lanes |= b);
  c = a;

  for (a = a["return"]; null !== a;) {
    a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a["return"];
  }

  return 3 === c.tag ? c.stateNode : null;
}

function Mj(a, b) {
  for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g;) {
    var h = 31 - Vc(g),
        k = 1 << h,
        l = f[h];

    if (-1 === l) {
      if (0 === (k & d) || 0 !== (k & e)) {
        l = b;
        Rc(k);
        var n = F;
        f[h] = 10 <= n ? l + 250 : 6 <= n ? l + 5E3 : -1;
      }
    } else l <= b && (a.expiredLanes |= k);

    g &= ~k;
  }

  d = Uc(a, a === U ? W : 0);
  b = F;
  if (0 === d) null !== c && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);else {
    if (null !== c) {
      if (a.callbackPriority === b) return;
      c !== Zf && Pf(c);
    }

    15 === b ? (c = Lj.bind(null, a), null === ag ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : 14 === b ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}

function Nj(a) {
  Fj = -1;
  Hj = Gj = 0;
  if (0 !== (X & 48)) throw Error(y(327));
  var b = a.callbackNode;
  if (Oj() && a.callbackNode !== b) return null;
  var c = Uc(a, a === U ? W : 0);
  if (0 === c) return null;
  var d = c;
  var e = X;
  X |= 16;
  var f = Pj();
  if (U !== a || W !== d) wj(), Qj(a, d);

  do {
    try {
      Rj();
      break;
    } catch (h) {
      Sj(a, h);
    }
  } while (1);

  qg();
  oj.current = f;
  X = e;
  null !== Y ? d = 0 : (U = null, W = 0, d = V);
  if (0 !== (tj & Hi)) Qj(a, 0);else if (0 !== d) {
    2 === d && (X |= 64, a.hydrate && (a.hydrate = !1, qf(a.containerInfo)), c = Wc(a), 0 !== c && (d = Tj(a, c)));
    if (1 === d) throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;
    a.finishedWork = a.current.alternate;
    a.finishedLanes = c;

    switch (d) {
      case 0:
      case 1:
        throw Error(y(345));

      case 2:
        Uj(a);
        break;

      case 3:
        Ii(a, c);

        if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
          if (0 !== Uc(a, 0)) break;
          e = a.suspendedLanes;

          if ((e & c) !== c) {
            Hg();
            a.pingedLanes |= a.suspendedLanes & e;
            break;
          }

          a.timeoutHandle = of(Uj.bind(null, a), d);
          break;
        }

        Uj(a);
        break;

      case 4:
        Ii(a, c);
        if ((c & 4186112) === c) break;
        d = a.eventTimes;

        for (e = -1; 0 < c;) {
          var g = 31 - Vc(c);
          f = 1 << g;
          g = d[g];
          g > e && (e = g);
          c &= ~f;
        }

        c = e;
        c = O() - c;
        c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3E3 > c ? 3E3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;

        if (10 < c) {
          a.timeoutHandle = of(Uj.bind(null, a), c);
          break;
        }

        Uj(a);
        break;

      case 5:
        Uj(a);
        break;

      default:
        throw Error(y(329));
    }
  }
  Mj(a, O());
  return a.callbackNode === b ? Nj.bind(null, a) : null;
}

function Ii(a, b) {
  b &= ~uj;
  b &= ~Hi;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;

  for (a = a.expirationTimes; 0 < b;) {
    var c = 31 - Vc(b),
        d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}

function Lj(a) {
  if (0 !== (X & 48)) throw Error(y(327));
  Oj();

  if (a === U && 0 !== (a.expiredLanes & W)) {
    var b = W;
    var c = Tj(a, b);
    0 !== (tj & Hi) && (b = Uc(a, b), c = Tj(a, b));
  } else b = Uc(a, 0), c = Tj(a, b);

  0 !== a.tag && 2 === c && (X |= 64, a.hydrate && (a.hydrate = !1, qf(a.containerInfo)), b = Wc(a), 0 !== b && (c = Tj(a, b)));
  if (1 === c) throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Uj(a);
  Mj(a, O());
  return null;
}

function Vj() {
  if (null !== Cj) {
    var a = Cj;
    Cj = null;
    a.forEach(function (a) {
      a.expiredLanes |= 24 & a.pendingLanes;
      Mj(a, O());
    });
  }

  ig();
}

function Wj(a, b) {
  var c = X;
  X |= 1;

  try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
}

function Xj(a, b) {
  var c = X;
  X &= -2;
  X |= 8;

  try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
}

function ni(a, b) {
  I(rj, qj);
  qj |= b;
  tj |= b;
}

function Ki() {
  qj = rj.current;
  H(rj);
}

function Qj(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  -1 !== c && (a.timeoutHandle = -1, pf(c));
  if (null !== Y) for (c = Y["return"]; null !== c;) {
    var d = c;

    switch (d.tag) {
      case 1:
        d = d.type.childContextTypes;
        null !== d && void 0 !== d && Gf();
        break;

      case 3:
        fh();
        H(N);
        H(M);
        uh();
        break;

      case 5:
        hh(d);
        break;

      case 4:
        fh();
        break;

      case 13:
        H(P);
        break;

      case 19:
        H(P);
        break;

      case 10:
        rg(d);
        break;

      case 23:
      case 24:
        Ki();
    }

    c = c["return"];
  }
  U = a;
  Y = Tg(a.current, null);
  W = qj = tj = b;
  V = 0;
  sj = null;
  uj = Hi = Dg = 0;
}

function Sj(a, b) {
  do {
    var c = Y;

    try {
      qg();
      vh.current = Gh;

      if (yh) {
        for (var d = R.memoizedState; null !== d;) {
          var e = d.queue;
          null !== e && (e.pending = null);
          d = d.next;
        }

        yh = !1;
      }

      xh = 0;
      T = S = R = null;
      zh = !1;
      pj.current = null;

      if (null === c || null === c["return"]) {
        V = 1;
        sj = b;
        Y = null;
        break;
      }

      a: {
        var f = a,
            g = c["return"],
            h = c,
            k = b;
        b = W;
        h.flags |= 2048;
        h.firstEffect = h.lastEffect = null;

        if (null !== k && "object" === typeof k && "function" === typeof k.then) {
          var l = k;

          if (0 === (h.mode & 2)) {
            var n = h.alternate;
            n ? (h.updateQueue = n.updateQueue, h.memoizedState = n.memoizedState, h.lanes = n.lanes) : (h.updateQueue = null, h.memoizedState = null);
          }

          var A = 0 !== (P.current & 1),
              p = g;

          do {
            var C;

            if (C = 13 === p.tag) {
              var x = p.memoizedState;
              if (null !== x) C = null !== x.dehydrated ? !0 : !1;else {
                var w = p.memoizedProps;
                C = void 0 === w.fallback ? !1 : !0 !== w.unstable_avoidThisFallback ? !0 : A ? !1 : !0;
              }
            }

            if (C) {
              var z = p.updateQueue;

              if (null === z) {
                var u = new Set();
                u.add(l);
                p.updateQueue = u;
              } else z.add(l);

              if (0 === (p.mode & 2)) {
                p.flags |= 64;
                h.flags |= 16384;
                h.flags &= -2981;
                if (1 === h.tag) if (null === h.alternate) h.tag = 17;else {
                  var t = zg(-1, 1);
                  t.tag = 2;
                  Ag(h, t);
                }
                h.lanes |= 1;
                break a;
              }

              k = void 0;
              h = b;
              var q = f.pingCache;
              null === q ? (q = f.pingCache = new Oi(), k = new Set(), q.set(l, k)) : (k = q.get(l), void 0 === k && (k = new Set(), q.set(l, k)));

              if (!k.has(h)) {
                k.add(h);
                var v = Yj.bind(null, f, l, h);
                l.then(v, v);
              }

              p.flags |= 4096;
              p.lanes = b;
              break a;
            }

            p = p["return"];
          } while (null !== p);

          k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }

        5 !== V && (V = 2);
        k = Mi(k, h);
        p = g;

        do {
          switch (p.tag) {
            case 3:
              f = k;
              p.flags |= 4096;
              b &= -b;
              p.lanes |= b;
              var J = Pi(p, f, b);
              Bg(p, J);
              break a;

            case 1:
              f = k;
              var K = p.type,
                  Q = p.stateNode;

              if (0 === (p.flags & 64) && ("function" === typeof K.getDerivedStateFromError || null !== Q && "function" === typeof Q.componentDidCatch && (null === Ti || !Ti.has(Q)))) {
                p.flags |= 4096;
                b &= -b;
                p.lanes |= b;
                var L = Si(p, f, b);
                Bg(p, L);
                break a;
              }

          }

          p = p["return"];
        } while (null !== p);
      }

      Zj(c);
    } catch (va) {
      b = va;
      Y === c && null !== c && (Y = c = c["return"]);
      continue;
    }

    break;
  } while (1);
}

function Pj() {
  var a = oj.current;
  oj.current = Gh;
  return null === a ? Gh : a;
}

function Tj(a, b) {
  var c = X;
  X |= 16;
  var d = Pj();
  U === a && W === b || Qj(a, b);

  do {
    try {
      ak();
      break;
    } catch (e) {
      Sj(a, e);
    }
  } while (1);

  qg();
  X = c;
  oj.current = d;
  if (null !== Y) throw Error(y(261));
  U = null;
  W = 0;
  return V;
}

function ak() {
  for (; null !== Y;) {
    bk(Y);
  }
}

function Rj() {
  for (; null !== Y && !Qf();) {
    bk(Y);
  }
}

function bk(a) {
  var b = ck(a.alternate, a, qj);
  a.memoizedProps = a.pendingProps;
  null === b ? Zj(a) : Y = b;
  pj.current = null;
}

function Zj(a) {
  var b = a;

  do {
    var c = b.alternate;
    a = b["return"];

    if (0 === (b.flags & 2048)) {
      c = Gi(c, b, qj);

      if (null !== c) {
        Y = c;
        return;
      }

      c = b;

      if (24 !== c.tag && 23 !== c.tag || null === c.memoizedState || 0 !== (qj & 1073741824) || 0 === (c.mode & 4)) {
        for (var d = 0, e = c.child; null !== e;) {
          d |= e.lanes | e.childLanes, e = e.sibling;
        }

        c.childLanes = d;
      }

      null !== a && 0 === (a.flags & 2048) && (null === a.firstEffect && (a.firstEffect = b.firstEffect), null !== b.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (null !== a.lastEffect ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
    } else {
      c = Li(b);

      if (null !== c) {
        c.flags &= 2047;
        Y = c;
        return;
      }

      null !== a && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
    }

    b = b.sibling;

    if (null !== b) {
      Y = b;
      return;
    }

    Y = b = a;
  } while (null !== b);

  0 === V && (V = 5);
}

function Uj(a) {
  var b = eg();
  gg(99, dk.bind(null, a, b));
  return null;
}

function dk(a, b) {
  do {
    Oj();
  } while (null !== yj);

  if (0 !== (X & 48)) throw Error(y(327));
  var c = a.finishedWork;
  if (null === c) return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current) throw Error(y(177));
  a.callbackNode = null;
  var d = c.lanes | c.childLanes,
      e = d,
      f = a.pendingLanes & ~e;
  a.pendingLanes = e;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= e;
  a.mutableReadLanes &= e;
  a.entangledLanes &= e;
  e = a.entanglements;

  for (var g = a.eventTimes, h = a.expirationTimes; 0 < f;) {
    var k = 31 - Vc(f),
        l = 1 << k;
    e[k] = 0;
    g[k] = -1;
    h[k] = -1;
    f &= ~l;
  }

  null !== Cj && 0 === (d & 24) && Cj.has(a) && Cj["delete"](a);
  a === U && (Y = U = null, W = 0);
  1 < c.flags ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;

  if (null !== d) {
    e = X;
    X |= 32;
    pj.current = null;
    kf = fd;
    g = Ne();

    if (Oe(g)) {
      if ("selectionStart" in g) h = {
        start: g.selectionStart,
        end: g.selectionEnd
      };else a: if (h = (h = g.ownerDocument) && h.defaultView || window, (l = h.getSelection && h.getSelection()) && 0 !== l.rangeCount) {
        h = l.anchorNode;
        f = l.anchorOffset;
        k = l.focusNode;
        l = l.focusOffset;

        try {
          h.nodeType, k.nodeType;
        } catch (va) {
          h = null;
          break a;
        }

        var n = 0,
            A = -1,
            p = -1,
            C = 0,
            x = 0,
            w = g,
            z = null;

        b: for (;;) {
          for (var u;;) {
            w !== h || 0 !== f && 3 !== w.nodeType || (A = n + f);
            w !== k || 0 !== l && 3 !== w.nodeType || (p = n + l);
            3 === w.nodeType && (n += w.nodeValue.length);
            if (null === (u = w.firstChild)) break;
            z = w;
            w = u;
          }

          for (;;) {
            if (w === g) break b;
            z === h && ++C === f && (A = n);
            z === k && ++x === l && (p = n);
            if (null !== (u = w.nextSibling)) break;
            w = z;
            z = w.parentNode;
          }

          w = u;
        }

        h = -1 === A || -1 === p ? null : {
          start: A,
          end: p
        };
      } else h = null;
      h = h || {
        start: 0,
        end: 0
      };
    } else h = null;

    lf = {
      focusedElem: g,
      selectionRange: h
    };
    fd = !1;
    Ij = null;
    Jj = !1;
    Z = d;

    do {
      try {
        ek();
      } catch (va) {
        if (null === Z) throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    } while (null !== Z);

    Ij = null;
    Z = d;

    do {
      try {
        for (g = a; null !== Z;) {
          var t = Z.flags;
          t & 16 && pb(Z.stateNode, "");

          if (t & 128) {
            var q = Z.alternate;

            if (null !== q) {
              var v = q.ref;
              null !== v && ("function" === typeof v ? v(null) : v.current = null);
            }
          }

          switch (t & 1038) {
            case 2:
              fj(Z);
              Z.flags &= -3;
              break;

            case 6:
              fj(Z);
              Z.flags &= -3;
              ij(Z.alternate, Z);
              break;

            case 1024:
              Z.flags &= -1025;
              break;

            case 1028:
              Z.flags &= -1025;
              ij(Z.alternate, Z);
              break;

            case 4:
              ij(Z.alternate, Z);
              break;

            case 8:
              h = Z;
              cj(g, h);
              var J = h.alternate;
              dj(h);
              null !== J && dj(J);
          }

          Z = Z.nextEffect;
        }
      } catch (va) {
        if (null === Z) throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    } while (null !== Z);

    v = lf;
    q = Ne();
    t = v.focusedElem;
    g = v.selectionRange;

    if (q !== t && t && t.ownerDocument && Me(t.ownerDocument.documentElement, t)) {
      null !== g && Oe(t) && (q = g.start, v = g.end, void 0 === v && (v = q), "selectionStart" in t ? (t.selectionStart = q, t.selectionEnd = Math.min(v, t.value.length)) : (v = (q = t.ownerDocument || document) && q.defaultView || window, v.getSelection && (v = v.getSelection(), h = t.textContent.length, J = Math.min(g.start, h), g = void 0 === g.end ? J : Math.min(g.end, h), !v.extend && J > g && (h = g, g = J, J = h), h = Le(t, J), f = Le(t, g), h && f && (1 !== v.rangeCount || v.anchorNode !== h.node || v.anchorOffset !== h.offset || v.focusNode !== f.node || v.focusOffset !== f.offset) && (q = q.createRange(), q.setStart(h.node, h.offset), v.removeAllRanges(), J > g ? (v.addRange(q), v.extend(f.node, f.offset)) : (q.setEnd(f.node, f.offset), v.addRange(q))))));
      q = [];

      for (v = t; v = v.parentNode;) {
        1 === v.nodeType && q.push({
          element: v,
          left: v.scrollLeft,
          top: v.scrollTop
        });
      }

      "function" === typeof t.focus && t.focus();

      for (t = 0; t < q.length; t++) {
        v = q[t], v.element.scrollLeft = v.left, v.element.scrollTop = v.top;
      }
    }

    fd = !!kf;
    lf = kf = null;
    a.current = c;
    Z = d;

    do {
      try {
        for (t = a; null !== Z;) {
          var K = Z.flags;
          K & 36 && Yi(t, Z.alternate, Z);

          if (K & 128) {
            q = void 0;
            var Q = Z.ref;

            if (null !== Q) {
              var L = Z.stateNode;

              switch (Z.tag) {
                case 5:
                  q = L;
                  break;

                default:
                  q = L;
              }

              "function" === typeof Q ? Q(q) : Q.current = q;
            }
          }

          Z = Z.nextEffect;
        }
      } catch (va) {
        if (null === Z) throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    } while (null !== Z);

    Z = null;
    $f();
    X = e;
  } else a.current = c;

  if (xj) xj = !1, yj = a, zj = b;else for (Z = d; null !== Z;) {
    b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K = Z, K.sibling = null, K.stateNode = null), Z = b;
  }
  d = a.pendingLanes;
  0 === d && (Ti = null);
  1 === d ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
  c = c.stateNode;
  if (Mf && "function" === typeof Mf.onCommitFiberRoot) try {
    Mf.onCommitFiberRoot(Lf, c, void 0, 64 === (c.current.flags & 64));
  } catch (va) {}
  Mj(a, O());
  if (Qi) throw Qi = !1, a = Ri, Ri = null, a;
  if (0 !== (X & 8)) return null;
  ig();
  return null;
}

function ek() {
  for (; null !== Z;) {
    var a = Z.alternate;
    Jj || null === Ij || (0 !== (Z.flags & 8) ? dc(Z, Ij) && (Jj = !0) : 13 === Z.tag && mj(a, Z) && dc(Z, Ij) && (Jj = !0));
    var b = Z.flags;
    0 !== (b & 256) && Xi(a, Z);
    0 === (b & 512) || xj || (xj = !0, hg(97, function () {
      Oj();
      return null;
    }));
    Z = Z.nextEffect;
  }
}

function Oj() {
  if (90 !== zj) {
    var a = 97 < zj ? 97 : zj;
    zj = 90;
    return gg(a, fk);
  }

  return !1;
}

function $i(a, b) {
  Aj.push(b, a);
  xj || (xj = !0, hg(97, function () {
    Oj();
    return null;
  }));
}

function Zi(a, b) {
  Bj.push(b, a);
  xj || (xj = !0, hg(97, function () {
    Oj();
    return null;
  }));
}

function fk() {
  if (null === yj) return !1;
  var a = yj;
  yj = null;
  if (0 !== (X & 48)) throw Error(y(331));
  var b = X;
  X |= 32;
  var c = Bj;
  Bj = [];

  for (var d = 0; d < c.length; d += 2) {
    var e = c[d],
        f = c[d + 1],
        g = e.destroy;
    e.destroy = void 0;
    if ("function" === typeof g) try {
      g();
    } catch (k) {
      if (null === f) throw Error(y(330));
      Wi(f, k);
    }
  }

  c = Aj;
  Aj = [];

  for (d = 0; d < c.length; d += 2) {
    e = c[d];
    f = c[d + 1];

    try {
      var h = e.create;
      e.destroy = h();
    } catch (k) {
      if (null === f) throw Error(y(330));
      Wi(f, k);
    }
  }

  for (h = a.current.firstEffect; null !== h;) {
    a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;
  }

  X = b;
  ig();
  return !0;
}

function gk(a, b, c) {
  b = Mi(c, b);
  b = Pi(a, b, 1);
  Ag(a, b);
  b = Hg();
  a = Kj(a, 1);
  null !== a && ($c(a, 1, b), Mj(a, b));
}

function Wi(a, b) {
  if (3 === a.tag) gk(a, a, b);else for (var c = a["return"]; null !== c;) {
    if (3 === c.tag) {
      gk(c, a, b);
      break;
    } else if (1 === c.tag) {
      var d = c.stateNode;

      if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) {
        a = Mi(b, a);
        var e = Si(c, a, 1);
        Ag(c, e);
        e = Hg();
        c = Kj(c, 1);
        if (null !== c) $c(c, 1, e), Mj(c, e);else if ("function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) try {
          d.componentDidCatch(b, a);
        } catch (f) {}
        break;
      }
    }

    c = c["return"];
  }
}

function Yj(a, b, c) {
  var d = a.pingCache;
  null !== d && d["delete"](b);
  b = Hg();
  a.pingedLanes |= a.suspendedLanes & c;
  U === a && (W & c) === c && (4 === V || 3 === V && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);
  Mj(a, b);
}

function lj(a, b) {
  var c = a.stateNode;
  null !== c && c["delete"](b);
  b = 0;
  0 === b && (b = a.mode, 0 === (b & 2) ? b = 1 : 0 === (b & 4) ? b = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b = Yc(62914560 & ~Gj), 0 === b && (b = 4194304)));
  c = Hg();
  a = Kj(a, b);
  null !== a && ($c(a, b, c), Mj(a, c));
}

var ck;

ck = function ck(a, b, c) {
  var d = b.lanes;
  if (null !== a) {
    if (a.memoizedProps !== b.pendingProps || N.current) ug = !0;else if (0 !== (c & d)) ug = 0 !== (a.flags & 16384) ? !0 : !1;else {
      ug = !1;

      switch (b.tag) {
        case 3:
          ri(b);
          sh();
          break;

        case 5:
          gh(b);
          break;

        case 1:
          Ff(b.type) && Jf(b);
          break;

        case 4:
          eh(b, b.stateNode.containerInfo);
          break;

        case 10:
          d = b.memoizedProps.value;
          var e = b.type._context;
          I(mg, e._currentValue);
          e._currentValue = d;
          break;

        case 13:
          if (null !== b.memoizedState) {
            if (0 !== (c & b.child.childLanes)) return ti(a, b, c);
            I(P, P.current & 1);
            b = hi(a, b, c);
            return null !== b ? b.sibling : null;
          }

          I(P, P.current & 1);
          break;

        case 19:
          d = 0 !== (c & b.childLanes);

          if (0 !== (a.flags & 64)) {
            if (d) return Ai(a, b, c);
            b.flags |= 64;
          }

          e = b.memoizedState;
          null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
          I(P, P.current);
          if (d) break;else return null;

        case 23:
        case 24:
          return b.lanes = 0, mi(a, b, c);
      }

      return hi(a, b, c);
    }
  } else ug = !1;
  b.lanes = 0;

  switch (b.tag) {
    case 2:
      d = b.type;
      null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
      a = b.pendingProps;
      e = Ef(b, M.current);
      tg(b, c);
      e = Ch(null, b, d, a, e, c);
      b.flags |= 1;

      if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
        b.tag = 1;
        b.memoizedState = null;
        b.updateQueue = null;

        if (Ff(d)) {
          var f = !0;
          Jf(b);
        } else f = !1;

        b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
        xg(b);
        var g = d.getDerivedStateFromProps;
        "function" === typeof g && Gg(b, d, g, a);
        e.updater = Kg;
        b.stateNode = e;
        e._reactInternals = b;
        Og(b, d, a, c);
        b = qi(null, b, d, !0, f, c);
      } else b.tag = 0, fi(null, b, e, c), b = b.child;

      return b;

    case 16:
      e = b.elementType;

      a: {
        null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
        a = b.pendingProps;
        f = e._init;
        e = f(e._payload);
        b.type = e;
        f = b.tag = hk(e);
        a = lg(e, a);

        switch (f) {
          case 0:
            b = li(null, b, e, a, c);
            break a;

          case 1:
            b = pi(null, b, e, a, c);
            break a;

          case 11:
            b = gi(null, b, e, a, c);
            break a;

          case 14:
            b = ii(null, b, e, lg(e.type, a), d, c);
            break a;
        }

        throw Error(y(306, e, ""));
      }

      return b;

    case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a, b, d, e, c);

    case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a, b, d, e, c);

    case 3:
      ri(b);
      d = b.updateQueue;
      if (null === a || null === d) throw Error(y(282));
      d = b.pendingProps;
      e = b.memoizedState;
      e = null !== e ? e.element : null;
      yg(a, b);
      Cg(b, d, null, c);
      d = b.memoizedState.element;
      if (d === e) sh(), b = hi(a, b, c);else {
        e = b.stateNode;
        if (f = e.hydrate) kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = !0;

        if (f) {
          a = e.mutableSourceEagerHydrationData;
          if (null != a) for (e = 0; e < a.length; e += 2) {
            f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);
          }
          c = Zg(b, null, d, c);

          for (b.child = c; c;) {
            c.flags = c.flags & -3 | 1024, c = c.sibling;
          }
        } else fi(a, b, d, c), sh();

        b = b.child;
      }
      return b;

    case 5:
      return gh(b), null === a && ph(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : null !== f && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;

    case 6:
      return null === a && ph(b), null;

    case 13:
      return ti(a, b, c);

    case 4:
      return eh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;

    case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a, b, d, e, c);

    case 7:
      return fi(a, b, b.pendingProps, c), b.child;

    case 8:
      return fi(a, b, b.pendingProps.children, c), b.child;

    case 12:
      return fi(a, b, b.pendingProps.children, c), b.child;

    case 10:
      a: {
        d = b.type._context;
        e = b.pendingProps;
        g = b.memoizedProps;
        f = e.value;
        var h = b.type._context;
        I(mg, h._currentValue);
        h._currentValue = f;
        if (null !== g) if (h = g.value, f = He(h, f) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h, f) : 1073741823) | 0, 0 === f) {
          if (g.children === e.children && !N.current) {
            b = hi(a, b, c);
            break a;
          }
        } else for (h = b.child, null !== h && (h["return"] = b); null !== h;) {
          var k = h.dependencies;

          if (null !== k) {
            g = h.child;

            for (var l = k.firstContext; null !== l;) {
              if (l.context === d && 0 !== (l.observedBits & f)) {
                1 === h.tag && (l = zg(-1, c & -c), l.tag = 2, Ag(h, l));
                h.lanes |= c;
                l = h.alternate;
                null !== l && (l.lanes |= c);
                sg(h["return"], c);
                k.lanes |= c;
                break;
              }

              l = l.next;
            }
          } else g = 10 === h.tag ? h.type === b.type ? null : h.child : h.child;

          if (null !== g) g["return"] = h;else for (g = h; null !== g;) {
            if (g === b) {
              g = null;
              break;
            }

            h = g.sibling;

            if (null !== h) {
              h["return"] = g["return"];
              g = h;
              break;
            }

            g = g["return"];
          }
          h = g;
        }
        fi(a, b, e.children, c);
        b = b.child;
      }

      return b;

    case 9:
      return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(e, f.unstable_observedBits), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;

    case 14:
      return e = b.type, f = lg(e, b.pendingProps), f = lg(e.type, f), ii(a, b, e, f, d, c);

    case 15:
      return ki(a, b, b.type, b.pendingProps, d, c);

    case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = !0, Jf(b)) : a = !1, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, !0, a, c);

    case 19:
      return Ai(a, b, c);

    case 23:
      return mi(a, b, c);

    case 24:
      return mi(a, b, c);
  }

  throw Error(y(156, b.tag));
};

function ik(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this["return"] = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.flags = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}

function nh(a, b, c, d) {
  return new ik(a, b, c, d);
}

function ji(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}

function hk(a) {
  if ("function" === typeof a) return ji(a) ? 1 : 0;

  if (void 0 !== a && null !== a) {
    a = a.$$typeof;
    if (a === Aa) return 11;
    if (a === Da) return 14;
  }

  return 2;
}

function Tg(a, b) {
  var c = a.alternate;
  null === c ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = null === b ? null : {
    lanes: b.lanes,
    firstContext: b.firstContext
  };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}

function Vg(a, b, c, d, e, f) {
  var g = 2;
  d = a;
  if ("function" === typeof a) ji(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {
    case ua:
      return Xg(c.children, e, f, b);

    case Ha:
      g = 8;
      e |= 16;
      break;

    case wa:
      g = 8;
      e |= 1;
      break;

    case xa:
      return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;

    case Ba:
      return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;

    case Ca:
      return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;

    case Ia:
      return vi(c, e, f, b);

    case Ja:
      return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;

    default:
      if ("object" === typeof a && null !== a) switch (a.$$typeof) {
        case ya:
          g = 10;
          break a;

        case za:
          g = 9;
          break a;

        case Aa:
          g = 11;
          break a;

        case Da:
          g = 14;
          break a;

        case Ea:
          g = 16;
          d = null;
          break a;

        case Fa:
          g = 22;
          break a;
      }
      throw Error(y(130, null == a ? a : typeof a, ""));
  }
  b = nh(g, c, b, e);
  b.elementType = a;
  b.type = d;
  b.lanes = f;
  return b;
}

function Xg(a, b, c, d) {
  a = nh(7, a, d, b);
  a.lanes = c;
  return a;
}

function vi(a, b, c, d) {
  a = nh(23, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  return a;
}

function Ug(a, b, c) {
  a = nh(6, a, null, b);
  a.lanes = c;
  return a;
}

function Wg(a, b, c) {
  b = nh(4, null !== a.children ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = {
    containerInfo: a.containerInfo,
    pendingChildren: null,
    implementation: a.implementation
  };
  return b;
}

function jk(a, b, c) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.pendingContext = this.context = null;
  this.hydrate = c;
  this.callbackNode = null;
  this.callbackPriority = 0;
  this.eventTimes = Zc(0);
  this.expirationTimes = Zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = Zc(0);
  this.mutableSourceEagerHydrationData = null;
}

function kk(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: ta,
    key: null == d ? null : "" + d,
    children: a,
    containerInfo: b,
    implementation: c
  };
}

function lk(a, b, c, d) {
  var e = b.current,
      f = Hg(),
      g = Ig(e);

  a: if (c) {
    c = c._reactInternals;

    b: {
      if (Zb(c) !== c || 1 !== c.tag) throw Error(y(170));
      var h = c;

      do {
        switch (h.tag) {
          case 3:
            h = h.stateNode.context;
            break b;

          case 1:
            if (Ff(h.type)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;
              break b;
            }

        }

        h = h["return"];
      } while (null !== h);

      throw Error(y(171));
    }

    if (1 === c.tag) {
      var k = c.type;

      if (Ff(k)) {
        c = If(c, k, h);
        break a;
      }
    }

    c = h;
  } else c = Cf;

  null === b.context ? b.context = c : b.pendingContext = c;
  b = zg(f, g);
  b.payload = {
    element: a
  };
  d = void 0 === d ? null : d;
  null !== d && (b.callback = d);
  Ag(e, b);
  Jg(e, g, f);
  return g;
}

function mk(a) {
  a = a.current;
  if (!a.child) return null;

  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;

    default:
      return a.child.stateNode;
  }
}

function nk(a, b) {
  a = a.memoizedState;

  if (null !== a && null !== a.dehydrated) {
    var c = a.retryLane;
    a.retryLane = 0 !== c && c < b ? c : b;
  }
}

function ok(a, b) {
  nk(a, b);
  (a = a.alternate) && nk(a, b);
}

function pk() {
  return null;
}

function qk(a, b, c) {
  var d = null != c && null != c.hydrationOptions && c.hydrationOptions.mutableSources || null;
  c = new jk(a, b, null != c && !0 === c.hydrate);
  b = nh(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
  c.current = b;
  b.stateNode = c;
  xg(b);
  a[ff] = c.current;
  cf(8 === a.nodeType ? a.parentNode : a);
  if (d) for (a = 0; a < d.length; a++) {
    b = d[a];
    var e = b._getVersion;
    e = e(b._source);
    null == c.mutableSourceEagerHydrationData ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
  }
  this._internalRoot = c;
}

qk.prototype.render = function (a) {
  lk(a, this._internalRoot, null, null);
};

qk.prototype.unmount = function () {
  var a = this._internalRoot,
      b = a.containerInfo;
  lk(null, a, null, function () {
    b[ff] = null;
  });
};

function rk(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}

function sk(a, b) {
  b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));
  if (!b) for (var c; c = a.lastChild;) {
    a.removeChild(c);
  }
  return new qk(a, 0, b ? {
    hydrate: !0
  } : void 0);
}

function tk(a, b, c, d, e) {
  var f = c._reactRootContainer;

  if (f) {
    var g = f._internalRoot;

    if ("function" === typeof e) {
      var h = e;

      e = function e() {
        var a = mk(g);
        h.call(a);
      };
    }

    lk(b, g, a, e);
  } else {
    f = c._reactRootContainer = sk(c, d);
    g = f._internalRoot;

    if ("function" === typeof e) {
      var k = e;

      e = function e() {
        var a = mk(g);
        k.call(a);
      };
    }

    Xj(function () {
      lk(b, g, a, e);
    });
  }

  return mk(g);
}

ec = function ec(a) {
  if (13 === a.tag) {
    var b = Hg();
    Jg(a, 4, b);
    ok(a, 4);
  }
};

fc = function fc(a) {
  if (13 === a.tag) {
    var b = Hg();
    Jg(a, 67108864, b);
    ok(a, 67108864);
  }
};

gc = function gc(a) {
  if (13 === a.tag) {
    var b = Hg(),
        c = Ig(a);
    Jg(a, c, b);
    ok(a, c);
  }
};

hc = function hc(a, b) {
  return b();
};

yb = function yb(a, b, c) {
  switch (b) {
    case "input":
      ab(a, c);
      b = c.name;

      if ("radio" === c.type && null != b) {
        for (c = a; c.parentNode;) {
          c = c.parentNode;
        }

        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');

        for (b = 0; b < c.length; b++) {
          var d = c[b];

          if (d !== a && d.form === a.form) {
            var e = Db(d);
            if (!e) throw Error(y(90));
            Wa(d);
            ab(d, e);
          }
        }
      }

      break;

    case "textarea":
      ib(a, c);
      break;

    case "select":
      b = c.value, null != b && fb(a, !!c.multiple, b, !1);
  }
};

Gb = Wj;

Hb = function Hb(a, b, c, d, e) {
  var f = X;
  X |= 4;

  try {
    return gg(98, a.bind(null, b, c, d, e));
  } finally {
    X = f, 0 === X && (wj(), ig());
  }
};

Ib = function Ib() {
  0 === (X & 49) && (Vj(), Oj());
};

Jb = function Jb(a, b) {
  var c = X;
  X |= 2;

  try {
    return a(b);
  } finally {
    X = c, 0 === X && (wj(), ig());
  }
};

function uk(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!rk(b)) throw Error(y(200));
  return kk(a, b, null, c);
}

var vk = {
  Events: [Cb, ue, Db, Eb, Fb, Oj, {
    current: !1
  }]
},
    wk = {
  findFiberByHostInstance: wc,
  bundleType: 0,
  version: "17.0.2",
  rendererPackageName: "react-dom"
};
var xk = {
  bundleType: wk.bundleType,
  version: wk.version,
  rendererPackageName: wk.rendererPackageName,
  rendererConfig: wk.rendererConfig,
  overrideHookState: null,
  overrideHookStateDeletePath: null,
  overrideHookStateRenamePath: null,
  overrideProps: null,
  overridePropsDeletePath: null,
  overridePropsRenamePath: null,
  setSuspenseHandler: null,
  scheduleUpdate: null,
  currentDispatcherRef: ra.ReactCurrentDispatcher,
  findHostInstanceByFiber: function findHostInstanceByFiber(a) {
    a = cc(a);
    return null === a ? null : a.stateNode;
  },
  findFiberByHostInstance: wk.findFiberByHostInstance || pk,
  findHostInstancesForRefresh: null,
  scheduleRefresh: null,
  scheduleRoot: null,
  setRefreshHandler: null,
  getCurrentFiber: null
};

if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!yk.isDisabled && yk.supportsFiber) try {
    Lf = yk.inject(xk), Mf = yk;
  } catch (a) {}
}

exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
exports.createPortal = uk;

exports.findDOMNode = function (a) {
  if (null == a) return null;
  if (1 === a.nodeType) return a;
  var b = a._reactInternals;

  if (void 0 === b) {
    if ("function" === typeof a.render) throw Error(y(188));
    throw Error(y(268, Object.keys(a)));
  }

  a = cc(b);
  a = null === a ? null : a.stateNode;
  return a;
};

exports.flushSync = function (a, b) {
  var c = X;
  if (0 !== (c & 48)) return a(b);
  X |= 1;

  try {
    if (a) return gg(99, a.bind(null, b));
  } finally {
    X = c, ig();
  }
};

exports.hydrate = function (a, b, c) {
  if (!rk(b)) throw Error(y(200));
  return tk(null, a, b, !0, c);
};

exports.render = function (a, b, c) {
  if (!rk(b)) throw Error(y(200));
  return tk(null, a, b, !1, c);
};

exports.unmountComponentAtNode = function (a) {
  if (!rk(a)) throw Error(y(40));
  return a._reactRootContainer ? (Xj(function () {
    tk(null, null, a, !1, function () {
      a._reactRootContainer = null;
      a[ff] = null;
    });
  }), !0) : !1;
};

exports.unstable_batchedUpdates = Wj;

exports.unstable_createPortal = function (a, b) {
  return uk(a, b, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
};

exports.unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
  if (!rk(c)) throw Error(y(200));
  if (null == a || void 0 === a._reactInternals) throw Error(y(38));
  return tk(a, b, c, !1, d);
};

exports.version = "17.0.2";

/***/ }),

/***/ 26796:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }

  if (false) {}

  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (true) {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(31730);
} else {}

/***/ }),

/***/ 42165:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var l = __webpack_require__(62967),
    n = 60103,
    p = 60106;

exports.Fragment = 60107;
exports.StrictMode = 60108;
exports.Profiler = 60114;
var q = 60109,
    r = 60110,
    t = 60112;
exports.Suspense = 60113;
var u = 60115,
    v = 60116;

if ("function" === typeof Symbol && Symbol["for"]) {
  var w = Symbol["for"];
  n = w("react.element");
  p = w("react.portal");
  exports.Fragment = w("react.fragment");
  exports.StrictMode = w("react.strict_mode");
  exports.Profiler = w("react.profiler");
  q = w("react.provider");
  r = w("react.context");
  t = w("react.forward_ref");
  exports.Suspense = w("react.suspense");
  u = w("react.memo");
  v = w("react.lazy");
}

var x = "function" === typeof Symbol && Symbol.iterator;

function y(a) {
  if (null === a || "object" !== typeof a) return null;
  a = x && a[x] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}

function z(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) {
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  }

  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}

var A = {
  isMounted: function isMounted() {
    return !1;
  },
  enqueueForceUpdate: function enqueueForceUpdate() {},
  enqueueReplaceState: function enqueueReplaceState() {},
  enqueueSetState: function enqueueSetState() {}
},
    B = {};

function C(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B;
  this.updater = c || A;
}

C.prototype.isReactComponent = {};

C.prototype.setState = function (a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error(z(85));
  this.updater.enqueueSetState(this, a, b, "setState");
};

C.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};

function D() {}

D.prototype = C.prototype;

function E(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B;
  this.updater = c || A;
}

var F = E.prototype = new D();
F.constructor = E;
l(F, C.prototype);
F.isPureReactComponent = !0;
var G = {
  current: null
},
    H = Object.prototype.hasOwnProperty,
    I = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};

function J(a, b, c) {
  var e,
      d = {},
      k = null,
      h = null;
  if (null != b) for (e in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) {
    H.call(b, e) && !I.hasOwnProperty(e) && (d[e] = b[e]);
  }
  var g = arguments.length - 2;
  if (1 === g) d.children = c;else if (1 < g) {
    for (var f = Array(g), m = 0; m < g; m++) {
      f[m] = arguments[m + 2];
    }

    d.children = f;
  }
  if (a && a.defaultProps) for (e in g = a.defaultProps, g) {
    void 0 === d[e] && (d[e] = g[e]);
  }
  return {
    $$typeof: n,
    type: a,
    key: k,
    ref: h,
    props: d,
    _owner: G.current
  };
}

function K(a, b) {
  return {
    $$typeof: n,
    type: a.type,
    key: b,
    ref: a.ref,
    props: a.props,
    _owner: a._owner
  };
}

function L(a) {
  return "object" === typeof a && null !== a && a.$$typeof === n;
}

function escape(a) {
  var b = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + a.replace(/[=:]/g, function (a) {
    return b[a];
  });
}

var M = /\/+/g;

function N(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}

function O(a, b, c, e, d) {
  var k = typeof a;
  if ("undefined" === k || "boolean" === k) a = null;
  var h = !1;
  if (null === a) h = !0;else switch (k) {
    case "string":
    case "number":
      h = !0;
      break;

    case "object":
      switch (a.$$typeof) {
        case n:
        case p:
          h = !0;
      }

  }
  if (h) return h = a, d = d(h), a = "" === e ? "." + N(h, 0) : e, Array.isArray(d) ? (c = "", null != a && (c = a.replace(M, "$&/") + "/"), O(d, b, c, "", function (a) {
    return a;
  })) : null != d && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M, "$&/") + "/") + a)), b.push(d)), 1;
  h = 0;
  e = "" === e ? "." : e + ":";
  if (Array.isArray(a)) for (var g = 0; g < a.length; g++) {
    k = a[g];
    var f = e + N(k, g);
    h += O(k, b, c, f, d);
  } else if (f = y(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) {
    k = k.value, f = e + N(k, g++), h += O(k, b, c, f, d);
  } else if ("object" === k) throw b = "" + a, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
  return h;
}

function P(a, b, c) {
  if (null == a) return a;
  var e = [],
      d = 0;
  O(a, e, "", "", function (a) {
    return b.call(c, a, d++);
  });
  return e;
}

function Q(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    a._status = 0;
    a._result = b;
    b.then(function (b) {
      0 === a._status && (b = b["default"], a._status = 1, a._result = b);
    }, function (b) {
      0 === a._status && (a._status = 2, a._result = b);
    });
  }

  if (1 === a._status) return a._result;
  throw a._result;
}

var R = {
  current: null
};

function S() {
  var a = R.current;
  if (null === a) throw Error(z(321));
  return a;
}

var T = {
  ReactCurrentDispatcher: R,
  ReactCurrentBatchConfig: {
    transition: 0
  },
  ReactCurrentOwner: G,
  IsSomeRendererActing: {
    current: !1
  },
  assign: l
};
exports.Children = {
  map: P,
  forEach: function forEach(a, b, c) {
    P(a, function () {
      b.apply(this, arguments);
    }, c);
  },
  count: function count(a) {
    var b = 0;
    P(a, function () {
      b++;
    });
    return b;
  },
  toArray: function toArray(a) {
    return P(a, function (a) {
      return a;
    }) || [];
  },
  only: function only(a) {
    if (!L(a)) throw Error(z(143));
    return a;
  }
};
exports.Component = C;
exports.PureComponent = E;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T;

exports.cloneElement = function (a, b, c) {
  if (null === a || void 0 === a) throw Error(z(267, a));
  var e = l({}, a.props),
      d = a.key,
      k = a.ref,
      h = a._owner;

  if (null != b) {
    void 0 !== b.ref && (k = b.ref, h = G.current);
    void 0 !== b.key && (d = "" + b.key);
    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;

    for (f in b) {
      H.call(b, f) && !I.hasOwnProperty(f) && (e[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
  }

  var f = arguments.length - 2;
  if (1 === f) e.children = c;else if (1 < f) {
    g = Array(f);

    for (var m = 0; m < f; m++) {
      g[m] = arguments[m + 2];
    }

    e.children = g;
  }
  return {
    $$typeof: n,
    type: a.type,
    key: d,
    ref: k,
    props: e,
    _owner: h
  };
};

exports.createContext = function (a, b) {
  void 0 === b && (b = null);
  a = {
    $$typeof: r,
    _calculateChangedBits: b,
    _currentValue: a,
    _currentValue2: a,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  };
  a.Provider = {
    $$typeof: q,
    _context: a
  };
  return a.Consumer = a;
};

exports.createElement = J;

exports.createFactory = function (a) {
  var b = J.bind(null, a);
  b.type = a;
  return b;
};

exports.createRef = function () {
  return {
    current: null
  };
};

exports.forwardRef = function (a) {
  return {
    $$typeof: t,
    render: a
  };
};

exports.isValidElement = L;

exports.lazy = function (a) {
  return {
    $$typeof: v,
    _payload: {
      _status: -1,
      _result: a
    },
    _init: Q
  };
};

exports.memo = function (a, b) {
  return {
    $$typeof: u,
    type: a,
    compare: void 0 === b ? null : b
  };
};

exports.useCallback = function (a, b) {
  return S().useCallback(a, b);
};

exports.useContext = function (a, b) {
  return S().useContext(a, b);
};

exports.useDebugValue = function () {};

exports.useEffect = function (a, b) {
  return S().useEffect(a, b);
};

exports.useImperativeHandle = function (a, b, c) {
  return S().useImperativeHandle(a, b, c);
};

exports.useLayoutEffect = function (a, b) {
  return S().useLayoutEffect(a, b);
};

exports.useMemo = function (a, b) {
  return S().useMemo(a, b);
};

exports.useReducer = function (a, b, c) {
  return S().useReducer(a, b, c);
};

exports.useRef = function (a) {
  return S().useRef(a);
};

exports.useState = function (a) {
  return S().useState(a);
};

exports.version = "17.0.2";

/***/ }),

/***/ 43745:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(42165);
} else {}

/***/ }),

/***/ 33538:
/***/ ((module) => {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }

  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  define(Gp, toStringTagSymbol, "Generator"); // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
 true ? module.exports : 0);

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

/***/ }),

/***/ 51703:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "P": () => (/* binding */ Notification)
/* harmony export */ });
/* unused harmony export NotificationKind */
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47485);
/* harmony import */ var _observable_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65637);
/* harmony import */ var _observable_throwError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55022);
/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */



var NotificationKind;
/*@__PURE__*/

(function (NotificationKind) {
  NotificationKind["NEXT"] = "N";
  NotificationKind["ERROR"] = "E";
  NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));

var Notification = /*@__PURE__*/function () {
  function Notification(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === 'N';
  }

  Notification.prototype.observe = function (observer) {
    switch (this.kind) {
      case 'N':
        return observer.next && observer.next(this.value);

      case 'E':
        return observer.error && observer.error(this.error);

      case 'C':
        return observer.complete && observer.complete();
    }
  };

  Notification.prototype["do"] = function (next, error, complete) {
    var kind = this.kind;

    switch (kind) {
      case 'N':
        return next && next(this.value);

      case 'E':
        return error && error(this.error);

      case 'C':
        return complete && complete();
    }
  };

  Notification.prototype.accept = function (nextOrObserver, error, complete) {
    if (nextOrObserver && typeof nextOrObserver.next === 'function') {
      return this.observe(nextOrObserver);
    } else {
      return this["do"](nextOrObserver, error, complete);
    }
  };

  Notification.prototype.toObservable = function () {
    var kind = this.kind;

    switch (kind) {
      case 'N':
        return (0,_observable_of__WEBPACK_IMPORTED_MODULE_0__.of)(this.value);

      case 'E':
        return (0,_observable_throwError__WEBPACK_IMPORTED_MODULE_1__/* .throwError */ ._)(this.error);

      case 'C':
        return (0,_observable_empty__WEBPACK_IMPORTED_MODULE_2__/* .empty */ .c)();
    }

    throw new Error('unexpected notification kind value');
  };

  Notification.createNext = function (value) {
    if (typeof value !== 'undefined') {
      return new Notification('N', value);
    }

    return Notification.undefinedValueNotification;
  };

  Notification.createError = function (err) {
    return new Notification('E', undefined, err);
  };

  Notification.createComplete = function () {
    return Notification.completeNotification;
  };

  Notification.completeNotification = new Notification('C');
  Notification.undefinedValueNotification = new Notification('N', undefined);
  return Notification;
}();



/***/ }),

/***/ 30365:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "y": () => (/* binding */ Observable)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(50032);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/canReportError.js
/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */

function canReportError(observer) {
  while (observer) {
    var _a = observer,
        closed_1 = _a.closed,
        destination = _a.destination,
        isStopped = _a.isStopped;

    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber/* Subscriber */.L) {
      observer = destination;
    } else {
      observer = null;
    }
  }

  return true;
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js
var rxSubscriber = __webpack_require__(12396);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observer.js
var Observer = __webpack_require__(68057);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/toSubscriber.js
/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */



function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber/* Subscriber */.L) {
      return nextOrObserver;
    }

    if (nextOrObserver[rxSubscriber/* rxSubscriber */.b]) {
      return nextOrObserver[rxSubscriber/* rxSubscriber */.b]();
    }
  }

  if (!nextOrObserver && !error && !complete) {
    return new Subscriber/* Subscriber */.L(Observer/* empty */.c);
  }

  return new Subscriber/* Subscriber */.L(nextOrObserver, error, complete);
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
var observable = __webpack_require__(30005);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/identity.js
var identity = __webpack_require__(11707);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/pipe.js
/** PURE_IMPORTS_START _identity PURE_IMPORTS_END */

function pipe() {
  var fns = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    fns[_i] = arguments[_i];
  }

  return pipeFromArray(fns);
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity/* identity */.y;
  }

  if (fns.length === 1) {
    return fns[0];
  }

  return function piped(input) {
    return fns.reduce(function (prev, fn) {
      return fn(prev);
    }, input);
  };
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/config.js
var config = __webpack_require__(10174);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js
/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */






var Observable = /*@__PURE__*/function () {
  function Observable(subscribe) {
    this._isScalar = false;

    if (subscribe) {
      this._subscribe = subscribe;
    }
  }

  Observable.prototype.lift = function (operator) {
    var observable = new Observable();
    observable.source = this;
    observable.operator = operator;
    return observable;
  };

  Observable.prototype.subscribe = function (observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = toSubscriber(observerOrNext, error, complete);

    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || config/* config.useDeprecatedSynchronousErrorHandling */.v.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }

    if (config/* config.useDeprecatedSynchronousErrorHandling */.v.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;

        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }

    return sink;
  };

  Observable.prototype._trySubscribe = function (sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (config/* config.useDeprecatedSynchronousErrorHandling */.v.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }

      if (canReportError(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };

  Observable.prototype.forEach = function (next, promiseCtor) {
    var _this = this;

    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var subscription;
      subscription = _this.subscribe(function (value) {
        try {
          next(value);
        } catch (err) {
          reject(err);

          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve);
    });
  };

  Observable.prototype._subscribe = function (subscriber) {
    var source = this.source;
    return source && source.subscribe(subscriber);
  };

  Observable.prototype[observable/* observable */.L] = function () {
    return this;
  };

  Observable.prototype.pipe = function () {
    var operations = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }

    if (operations.length === 0) {
      return this;
    }

    return pipeFromArray(operations)(this);
  };

  Observable.prototype.toPromise = function (promiseCtor) {
    var _this = this;

    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function (resolve, reject) {
      var value;

      _this.subscribe(function (x) {
        return value = x;
      }, function (err) {
        return reject(err);
      }, function () {
        return resolve(value);
      });
    });
  };

  Observable.create = function (subscribe) {
    return new Observable(subscribe);
  };

  return Observable;
}();



function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = config/* config.Promise */.v.Promise || Promise;
  }

  if (!promiseCtor) {
    throw new Error('no Promise impl found');
  }

  return promiseCtor;
}

/***/ }),

/***/ 68057:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": () => (/* binding */ empty)
/* harmony export */ });
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10174);
/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27242);
/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */


var empty = {
  closed: true,
  next: function next(value) {},
  error: function error(err) {
    if (_config__WEBPACK_IMPORTED_MODULE_0__/* .config.useDeprecatedSynchronousErrorHandling */ .v.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__/* .hostReportError */ .z)(err);
    }
  },
  complete: function complete() {}
};

/***/ }),

/***/ 6965:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "L": () => (/* binding */ OuterSubscriber)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50032);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */



var OuterSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(OuterSubscriber, _super);

  function OuterSubscriber() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
    this.destination.next(innerValue);
  };

  OuterSubscriber.prototype.notifyError = function (error, innerSub) {
    this.destination.error(error);
  };

  OuterSubscriber.prototype.notifyComplete = function (innerSub) {
    this.destination.complete();
  };

  return OuterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);



/***/ }),

/***/ 4815:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "t": () => (/* binding */ ReplaySubject)
});

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(10649);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(81044);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js + 1 modules
var AsyncAction = __webpack_require__(55733);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/QueueAction.js
/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */



var QueueAction = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(QueueAction, _super);

  function QueueAction(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }

  QueueAction.prototype.schedule = function (state, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay > 0) {
      return _super.prototype.schedule.call(this, state, delay);
    }

    this.delay = delay;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };

  QueueAction.prototype.execute = function (state, delay) {
    return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
  };

  QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
    }

    return scheduler.flush(this);
  };

  return QueueAction;
}(AsyncAction/* AsyncAction */.o);


// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js + 1 modules
var AsyncScheduler = __webpack_require__(62641);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/QueueScheduler.js
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */



var QueueScheduler = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(QueueScheduler, _super);

  function QueueScheduler() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  return QueueScheduler;
}(AsyncScheduler/* AsyncScheduler */.v);


;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/queue.js
/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */


var queueScheduler = /*@__PURE__*/new QueueScheduler(QueueAction);
var queue = queueScheduler;
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(53310);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(50032);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Notification.js
var Notification = __webpack_require__(51703);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/observeOn.js
/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */



function observeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }

  return function observeOnOperatorFunction(source) {
    return source.lift(new ObserveOnOperator(scheduler, delay));
  };
}

var ObserveOnOperator = /*@__PURE__*/(/* unused pure expression or super */ null && (function () {
  function ObserveOnOperator(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    this.scheduler = scheduler;
    this.delay = delay;
  }

  ObserveOnOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
  };

  return ObserveOnOperator;
}()));



var ObserveOnSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(ObserveOnSubscriber, _super);

  function ObserveOnSubscriber(destination, scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    var _this = _super.call(this, destination) || this;

    _this.scheduler = scheduler;
    _this.delay = delay;
    return _this;
  }

  ObserveOnSubscriber.dispatch = function (arg) {
    var notification = arg.notification,
        destination = arg.destination;
    notification.observe(destination);
    this.unsubscribe();
  };

  ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
    var destination = this.destination;
    destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
  };

  ObserveOnSubscriber.prototype._next = function (value) {
    this.scheduleMessage(Notification/* Notification.createNext */.P.createNext(value));
  };

  ObserveOnSubscriber.prototype._error = function (err) {
    this.scheduleMessage(Notification/* Notification.createError */.P.createError(err));
    this.unsubscribe();
  };

  ObserveOnSubscriber.prototype._complete = function () {
    this.scheduleMessage(Notification/* Notification.createComplete */.P.createComplete());
    this.unsubscribe();
  };

  return ObserveOnSubscriber;
}(Subscriber/* Subscriber */.L);



var ObserveOnMessage = /*@__PURE__*/function () {
  function ObserveOnMessage(notification, destination) {
    this.notification = notification;
    this.destination = destination;
  }

  return ObserveOnMessage;
}();


// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = __webpack_require__(46101);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/SubjectSubscription.js
var SubjectSubscription = __webpack_require__(60912);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js
/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */








var ReplaySubject = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(ReplaySubject, _super);

  function ReplaySubject(bufferSize, windowTime, scheduler) {
    if (bufferSize === void 0) {
      bufferSize = Number.POSITIVE_INFINITY;
    }

    if (windowTime === void 0) {
      windowTime = Number.POSITIVE_INFINITY;
    }

    var _this = _super.call(this) || this;

    _this.scheduler = scheduler;
    _this._events = [];
    _this._infiniteTimeWindow = false;
    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
    _this._windowTime = windowTime < 1 ? 1 : windowTime;

    if (windowTime === Number.POSITIVE_INFINITY) {
      _this._infiniteTimeWindow = true;
      _this.next = _this.nextInfiniteTimeWindow;
    } else {
      _this.next = _this.nextTimeWindow;
    }

    return _this;
  }

  ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
    if (!this.isStopped) {
      var _events = this._events;

      _events.push(value);

      if (_events.length > this._bufferSize) {
        _events.shift();
      }
    }

    _super.prototype.next.call(this, value);
  };

  ReplaySubject.prototype.nextTimeWindow = function (value) {
    if (!this.isStopped) {
      this._events.push(new ReplayEvent(this._getNow(), value));

      this._trimBufferThenGetEvents();
    }

    _super.prototype.next.call(this, value);
  };

  ReplaySubject.prototype._subscribe = function (subscriber) {
    var _infiniteTimeWindow = this._infiniteTimeWindow;

    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();

    var scheduler = this.scheduler;
    var len = _events.length;
    var subscription;

    if (this.closed) {
      throw new ObjectUnsubscribedError/* ObjectUnsubscribedError */.N();
    } else if (this.isStopped || this.hasError) {
      subscription = Subscription/* Subscription.EMPTY */.w.EMPTY;
    } else {
      this.observers.push(subscriber);
      subscription = new SubjectSubscription/* SubjectSubscription */.W(this, subscriber);
    }

    if (scheduler) {
      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
    }

    if (_infiniteTimeWindow) {
      for (var i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i]);
      }
    } else {
      for (var i = 0; i < len && !subscriber.closed; i++) {
        subscriber.next(_events[i].value);
      }
    }

    if (this.hasError) {
      subscriber.error(this.thrownError);
    } else if (this.isStopped) {
      subscriber.complete();
    }

    return subscription;
  };

  ReplaySubject.prototype._getNow = function () {
    return (this.scheduler || queue).now();
  };

  ReplaySubject.prototype._trimBufferThenGetEvents = function () {
    var now = this._getNow();

    var _bufferSize = this._bufferSize;
    var _windowTime = this._windowTime;
    var _events = this._events;
    var eventsCount = _events.length;
    var spliceCount = 0;

    while (spliceCount < eventsCount) {
      if (now - _events[spliceCount].time < _windowTime) {
        break;
      }

      spliceCount++;
    }

    if (eventsCount > _bufferSize) {
      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
    }

    if (spliceCount > 0) {
      _events.splice(0, spliceCount);
    }

    return _events;
  };

  return ReplaySubject;
}(Subject/* Subject */.xQ);



var ReplayEvent = /*@__PURE__*/function () {
  function ReplayEvent(time, value) {
    this.time = time;
    this.value = value;
  }

  return ReplayEvent;
}();

/***/ }),

/***/ 81044:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Yc": () => (/* binding */ SubjectSubscriber),
/* harmony export */   "xQ": () => (/* binding */ Subject)
/* harmony export */ });
/* unused harmony export AnonymousSubject */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(30365);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50032);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(53310);
/* harmony import */ var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(46101);
/* harmony import */ var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(60912);
/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12396);
/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */








var SubjectSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(SubjectSubscriber, _super);

  function SubjectSubscriber(destination) {
    var _this = _super.call(this, destination) || this;

    _this.destination = destination;
    return _this;
  }

  return SubjectSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);



var Subject = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(Subject, _super);

  function Subject() {
    var _this = _super.call(this) || this;

    _this.observers = [];
    _this.closed = false;
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }

  Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_2__/* .rxSubscriber */ .b] = function () {
    return new SubjectSubscriber(this);
  };

  Subject.prototype.lift = function (operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };

  Subject.prototype.next = function (value) {
    if (this.closed) {
      throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__/* .ObjectUnsubscribedError */ .N();
    }

    if (!this.isStopped) {
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();

      for (var i = 0; i < len; i++) {
        copy[i].next(value);
      }
    }
  };

  Subject.prototype.error = function (err) {
    if (this.closed) {
      throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__/* .ObjectUnsubscribedError */ .N();
    }

    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();

    for (var i = 0; i < len; i++) {
      copy[i].error(err);
    }

    this.observers.length = 0;
  };

  Subject.prototype.complete = function () {
    if (this.closed) {
      throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__/* .ObjectUnsubscribedError */ .N();
    }

    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();

    for (var i = 0; i < len; i++) {
      copy[i].complete();
    }

    this.observers.length = 0;
  };

  Subject.prototype.unsubscribe = function () {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  };

  Subject.prototype._trySubscribe = function (subscriber) {
    if (this.closed) {
      throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__/* .ObjectUnsubscribedError */ .N();
    } else {
      return _super.prototype._trySubscribe.call(this, subscriber);
    }
  };

  Subject.prototype._subscribe = function (subscriber) {
    if (this.closed) {
      throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__/* .ObjectUnsubscribedError */ .N();
    } else if (this.hasError) {
      subscriber.error(this.thrownError);
      return _Subscription__WEBPACK_IMPORTED_MODULE_4__/* .Subscription.EMPTY */ .w.EMPTY;
    } else if (this.isStopped) {
      subscriber.complete();
      return _Subscription__WEBPACK_IMPORTED_MODULE_4__/* .Subscription.EMPTY */ .w.EMPTY;
    } else {
      this.observers.push(subscriber);
      return new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__/* .SubjectSubscription */ .W(this, subscriber);
    }
  };

  Subject.prototype.asObservable = function () {
    var observable = new _Observable__WEBPACK_IMPORTED_MODULE_6__/* .Observable */ .y();
    observable.source = this;
    return observable;
  };

  Subject.create = function (destination, source) {
    return new AnonymousSubject(destination, source);
  };

  return Subject;
}(_Observable__WEBPACK_IMPORTED_MODULE_6__/* .Observable */ .y);



var AnonymousSubject = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(AnonymousSubject, _super);

  function AnonymousSubject(destination, source) {
    var _this = _super.call(this) || this;

    _this.destination = destination;
    _this.source = source;
    return _this;
  }

  AnonymousSubject.prototype.next = function (value) {
    var destination = this.destination;

    if (destination && destination.next) {
      destination.next(value);
    }
  };

  AnonymousSubject.prototype.error = function (err) {
    var destination = this.destination;

    if (destination && destination.error) {
      this.destination.error(err);
    }
  };

  AnonymousSubject.prototype.complete = function () {
    var destination = this.destination;

    if (destination && destination.complete) {
      this.destination.complete();
    }
  };

  AnonymousSubject.prototype._subscribe = function (subscriber) {
    var source = this.source;

    if (source) {
      return this.source.subscribe(subscriber);
    } else {
      return _Subscription__WEBPACK_IMPORTED_MODULE_4__/* .Subscription.EMPTY */ .w.EMPTY;
    }
  };

  return AnonymousSubject;
}(Subject);



/***/ }),

/***/ 60912:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "W": () => (/* binding */ SubjectSubscription)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53310);
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */



var SubjectSubscription = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(SubjectSubscription, _super);

  function SubjectSubscription(subject, subscriber) {
    var _this = _super.call(this) || this;

    _this.subject = subject;
    _this.subscriber = subscriber;
    _this.closed = false;
    return _this;
  }

  SubjectSubscription.prototype.unsubscribe = function () {
    if (this.closed) {
      return;
    }

    this.closed = true;
    var subject = this.subject;
    var observers = subject.observers;
    this.subject = null;

    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }

    var subscriberIndex = observers.indexOf(this.subscriber);

    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  };

  return SubjectSubscription;
}(_Subscription__WEBPACK_IMPORTED_MODULE_1__/* .Subscription */ .w);



/***/ }),

/***/ 50032:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "L": () => (/* binding */ Subscriber)
/* harmony export */ });
/* unused harmony export SafeSubscriber */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(89012);
/* harmony import */ var _Observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(68057);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(53310);
/* harmony import */ var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12396);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(10174);
/* harmony import */ var _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(27242);
/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */








var Subscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(Subscriber, _super);

  function Subscriber(destinationOrNext, error, complete) {
    var _this = _super.call(this) || this;

    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;

    switch (arguments.length) {
      case 0:
        _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__/* .empty */ .c;
        break;

      case 1:
        if (!destinationOrNext) {
          _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__/* .empty */ .c;
          break;
        }

        if (typeof destinationOrNext === 'object') {
          if (destinationOrNext instanceof Subscriber) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }

          break;
        }

      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
        break;
    }

    return _this;
  }

  Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_2__/* .rxSubscriber */ .b] = function () {
    return this;
  };

  Subscriber.create = function (next, error, complete) {
    var subscriber = new Subscriber(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };

  Subscriber.prototype.next = function (value) {
    if (!this.isStopped) {
      this._next(value);
    }
  };

  Subscriber.prototype.error = function (err) {
    if (!this.isStopped) {
      this.isStopped = true;

      this._error(err);
    }
  };

  Subscriber.prototype.complete = function () {
    if (!this.isStopped) {
      this.isStopped = true;

      this._complete();
    }
  };

  Subscriber.prototype.unsubscribe = function () {
    if (this.closed) {
      return;
    }

    this.isStopped = true;

    _super.prototype.unsubscribe.call(this);
  };

  Subscriber.prototype._next = function (value) {
    this.destination.next(value);
  };

  Subscriber.prototype._error = function (err) {
    this.destination.error(err);
    this.unsubscribe();
  };

  Subscriber.prototype._complete = function () {
    this.destination.complete();
    this.unsubscribe();
  };

  Subscriber.prototype._unsubscribeAndRecycle = function () {
    var _parentOrParents = this._parentOrParents;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  };

  return Subscriber;
}(_Subscription__WEBPACK_IMPORTED_MODULE_3__/* .Subscription */ .w);



var SafeSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(SafeSubscriber, _super);

  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
    var _this = _super.call(this) || this;

    _this._parentSubscriber = _parentSubscriber;
    var next;
    var context = _this;

    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_4__/* .isFunction */ .m)(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;

      if (observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_1__/* .empty */ .c) {
        context = Object.create(observerOrNext);

        if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_4__/* .isFunction */ .m)(context.unsubscribe)) {
          _this.add(context.unsubscribe.bind(context));
        }

        context.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }

    _this._context = context;
    _this._next = next;
    _this._error = error;
    _this._complete = complete;
    return _this;
  }

  SafeSubscriber.prototype.next = function (value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;

      if (!_config__WEBPACK_IMPORTED_MODULE_5__/* .config.useDeprecatedSynchronousErrorHandling */ .v.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  };

  SafeSubscriber.prototype.error = function (err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__/* .config.useDeprecatedSynchronousErrorHandling */ .v.useDeprecatedSynchronousErrorHandling;

      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);

          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);

          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();

        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }

        (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__/* .hostReportError */ .z)(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__/* .hostReportError */ .z)(err);
        }

        this.unsubscribe();
      }
    }
  };

  SafeSubscriber.prototype.complete = function () {
    var _this = this;

    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;

      if (this._complete) {
        var wrappedComplete = function wrappedComplete() {
          return _this._complete.call(_this._context);
        };

        if (!_config__WEBPACK_IMPORTED_MODULE_5__/* .config.useDeprecatedSynchronousErrorHandling */ .v.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);

          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);

          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };

  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
    try {
      fn.call(this._context, value);
    } catch (err) {
      this.unsubscribe();

      if (_config__WEBPACK_IMPORTED_MODULE_5__/* .config.useDeprecatedSynchronousErrorHandling */ .v.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__/* .hostReportError */ .z)(err);
      }
    }
  };

  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
    if (!_config__WEBPACK_IMPORTED_MODULE_5__/* .config.useDeprecatedSynchronousErrorHandling */ .v.useDeprecatedSynchronousErrorHandling) {
      throw new Error('bad call');
    }

    try {
      fn.call(this._context, value);
    } catch (err) {
      if (_config__WEBPACK_IMPORTED_MODULE_5__/* .config.useDeprecatedSynchronousErrorHandling */ .v.useDeprecatedSynchronousErrorHandling) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      } else {
        (0,_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__/* .hostReportError */ .z)(err);
        return true;
      }
    }

    return false;
  };

  SafeSubscriber.prototype._unsubscribe = function () {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;

    _parentSubscriber.unsubscribe();
  };

  return SafeSubscriber;
}(Subscriber);



/***/ }),

/***/ 53310:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "w": () => (/* binding */ Subscription)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArray.js
var isArray = __webpack_require__(65330);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isObject.js
var isObject = __webpack_require__(62860);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isFunction.js
var isFunction = __webpack_require__(89012);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var UnsubscriptionErrorImpl = /*@__PURE__*/function () {
  function UnsubscriptionErrorImpl(errors) {
    Error.call(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
      return i + 1 + ") " + err.toString();
    }).join('\n  ') : '';
    this.name = 'UnsubscriptionError';
    this.errors = errors;
    return this;
  }

  UnsubscriptionErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);
  return UnsubscriptionErrorImpl;
}();

var UnsubscriptionError = UnsubscriptionErrorImpl;
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js
/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */





var Subscription = /*@__PURE__*/function () {
  function Subscription(unsubscribe) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;

    if (unsubscribe) {
      this._ctorUnsubscribe = true;
      this._unsubscribe = unsubscribe;
    }
  }

  Subscription.prototype.unsubscribe = function () {
    var errors;

    if (this.closed) {
      return;
    }

    var _a = this,
        _parentOrParents = _a._parentOrParents,
        _ctorUnsubscribe = _a._ctorUnsubscribe,
        _unsubscribe = _a._unsubscribe,
        _subscriptions = _a._subscriptions;

    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;

    if (_parentOrParents instanceof Subscription) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (var index = 0; index < _parentOrParents.length; ++index) {
        var parent_1 = _parentOrParents[index];
        parent_1.remove(this);
      }
    }

    if ((0,isFunction/* isFunction */.m)(_unsubscribe)) {
      if (_ctorUnsubscribe) {
        this._unsubscribe = undefined;
      }

      try {
        _unsubscribe.call(this);
      } catch (e) {
        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
      }
    }

    if ((0,isArray/* isArray */.k)(_subscriptions)) {
      var index = -1;
      var len = _subscriptions.length;

      while (++index < len) {
        var sub = _subscriptions[index];

        if ((0,isObject/* isObject */.K)(sub)) {
          try {
            sub.unsubscribe();
          } catch (e) {
            errors = errors || [];

            if (e instanceof UnsubscriptionError) {
              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
            } else {
              errors.push(e);
            }
          }
        }
      }
    }

    if (errors) {
      throw new UnsubscriptionError(errors);
    }
  };

  Subscription.prototype.add = function (teardown) {
    var subscription = teardown;

    if (!teardown) {
      return Subscription.EMPTY;
    }

    switch (typeof teardown) {
      case 'function':
        subscription = new Subscription(teardown);

      case 'object':
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription)) {
          var tmp = subscription;
          subscription = new Subscription();
          subscription._subscriptions = [tmp];
        }

        break;

      default:
        {
          throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
    }

    var _parentOrParents = subscription._parentOrParents;

    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription) {
      if (_parentOrParents === this) {
        return subscription;
      }

      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }

    var subscriptions = this._subscriptions;

    if (subscriptions === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions.push(subscription);
    }

    return subscription;
  };

  Subscription.prototype.remove = function (subscription) {
    var subscriptions = this._subscriptions;

    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);

      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  };

  Subscription.EMPTY = function (empty) {
    empty.closed = true;
    return empty;
  }(new Subscription());

  return Subscription;
}();



function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function (errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}

/***/ }),

/***/ 10174:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "v": () => (/* binding */ config)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
  Promise: undefined,

  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      var error = /*@__PURE__*/new Error();
      /*@__PURE__*/

      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
    } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
      /*@__PURE__*/
      console.log('RxJS: Back to a better error behavior. Thank you. <3');
    }

    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },

  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }

};

/***/ }),

/***/ 90789:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IY": () => (/* binding */ SimpleInnerSubscriber),
/* harmony export */   "Ds": () => (/* binding */ SimpleOuterSubscriber),
/* harmony export */   "ft": () => (/* binding */ innerSubscribe)
/* harmony export */ });
/* unused harmony exports ComplexInnerSubscriber, ComplexOuterSubscriber */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50032);
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30365);
/* harmony import */ var _util_subscribeTo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23145);
/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */





var SimpleInnerSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(SimpleInnerSubscriber, _super);

  function SimpleInnerSubscriber(parent) {
    var _this = _super.call(this) || this;

    _this.parent = parent;
    return _this;
  }

  SimpleInnerSubscriber.prototype._next = function (value) {
    this.parent.notifyNext(value);
  };

  SimpleInnerSubscriber.prototype._error = function (error) {
    this.parent.notifyError(error);
    this.unsubscribe();
  };

  SimpleInnerSubscriber.prototype._complete = function () {
    this.parent.notifyComplete();
    this.unsubscribe();
  };

  return SimpleInnerSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);



var ComplexInnerSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(ComplexInnerSubscriber, _super);

  function ComplexInnerSubscriber(parent, outerValue, outerIndex) {
    var _this = _super.call(this) || this;

    _this.parent = parent;
    _this.outerValue = outerValue;
    _this.outerIndex = outerIndex;
    return _this;
  }

  ComplexInnerSubscriber.prototype._next = function (value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this);
  };

  ComplexInnerSubscriber.prototype._error = function (error) {
    this.parent.notifyError(error);
    this.unsubscribe();
  };

  ComplexInnerSubscriber.prototype._complete = function () {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  };

  return ComplexInnerSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);



var SimpleOuterSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(SimpleOuterSubscriber, _super);

  function SimpleOuterSubscriber() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {
    this.destination.next(innerValue);
  };

  SimpleOuterSubscriber.prototype.notifyError = function (err) {
    this.destination.error(err);
  };

  SimpleOuterSubscriber.prototype.notifyComplete = function () {
    this.destination.complete();
  };

  return SimpleOuterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);



var ComplexOuterSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(ComplexOuterSubscriber, _super);

  function ComplexOuterSubscriber() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  ComplexOuterSubscriber.prototype.notifyNext = function (_outerValue, innerValue, _outerIndex, _innerSub) {
    this.destination.next(innerValue);
  };

  ComplexOuterSubscriber.prototype.notifyError = function (error) {
    this.destination.error(error);
  };

  ComplexOuterSubscriber.prototype.notifyComplete = function (_innerSub) {
    this.destination.complete();
  };

  return ComplexOuterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);


function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return undefined;
  }

  if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_2__/* .Observable */ .y) {
    return result.subscribe(innerSubscriber);
  }

  var subscription;

  try {
    subscription = (0,_util_subscribeTo__WEBPACK_IMPORTED_MODULE_3__/* .subscribeTo */ .s)(result)(innerSubscriber);
  } catch (error) {
    innerSubscriber.error(error);
  }

  return subscription;
}

/***/ }),

/***/ 92953:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "aj": () => (/* binding */ combineLatest)
/* harmony export */ });
/* unused harmony exports CombineLatestOperator, CombineLatestSubscriber */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10649);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8793);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65330);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6965);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(81173);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71298);
/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */






var NONE = {};
function combineLatest() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  var resultSelector = undefined;
  var scheduler = undefined;

  if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__/* .isScheduler */ .K)(observables[observables.length - 1])) {
    scheduler = observables.pop();
  }

  if (typeof observables[observables.length - 1] === 'function') {
    resultSelector = observables.pop();
  }

  if (observables.length === 1 && (0,_util_isArray__WEBPACK_IMPORTED_MODULE_1__/* .isArray */ .k)(observables[0])) {
    observables = observables[0];
  }

  return (0,_fromArray__WEBPACK_IMPORTED_MODULE_2__/* .fromArray */ .n)(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}

var CombineLatestOperator = /*@__PURE__*/function () {
  function CombineLatestOperator(resultSelector) {
    this.resultSelector = resultSelector;
  }

  CombineLatestOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
  };

  return CombineLatestOperator;
}();



var CombineLatestSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_3__/* .__extends */ .ZT(CombineLatestSubscriber, _super);

  function CombineLatestSubscriber(destination, resultSelector) {
    var _this = _super.call(this, destination) || this;

    _this.resultSelector = resultSelector;
    _this.active = 0;
    _this.values = [];
    _this.observables = [];
    return _this;
  }

  CombineLatestSubscriber.prototype._next = function (observable) {
    this.values.push(NONE);
    this.observables.push(observable);
  };

  CombineLatestSubscriber.prototype._complete = function () {
    var observables = this.observables;
    var len = observables.length;

    if (len === 0) {
      this.destination.complete();
    } else {
      this.active = len;
      this.toRespond = len;

      for (var i = 0; i < len; i++) {
        var observable = observables[i];
        this.add((0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__/* .subscribeToResult */ .D)(this, observable, undefined, i));
      }
    }
  };

  CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
    if ((this.active -= 1) === 0) {
      this.destination.complete();
    }
  };

  CombineLatestSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
    var values = this.values;
    var oldVal = values[outerIndex];
    var toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
    values[outerIndex] = innerValue;

    if (toRespond === 0) {
      if (this.resultSelector) {
        this._tryResultSelector(values);
      } else {
        this.destination.next(values.slice());
      }
    }
  };

  CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
    var result;

    try {
      result = this.resultSelector.apply(this, values);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.next(result);
  };

  return CombineLatestSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_5__/* .OuterSubscriber */ .L);



/***/ }),

/***/ 70252:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "z": () => (/* binding */ concat)
/* harmony export */ });
/* harmony import */ var _of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65637);
/* harmony import */ var _operators_concatAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28358);
/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */


function concat() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  return (0,_operators_concatAll__WEBPACK_IMPORTED_MODULE_0__/* .concatAll */ .u)()(_of__WEBPACK_IMPORTED_MODULE_1__.of.apply(void 0, observables));
}

/***/ }),

/***/ 24251:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "P": () => (/* binding */ defer)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30365);
/* harmony import */ var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41981);
/* harmony import */ var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47485);
/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */



function defer(observableFactory) {
  return new _Observable__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y(function (subscriber) {
    var input;

    try {
      input = observableFactory();
    } catch (err) {
      subscriber.error(err);
      return undefined;
    }

    var source = input ? (0,_from__WEBPACK_IMPORTED_MODULE_1__/* .from */ .D)(input) : (0,_empty__WEBPACK_IMPORTED_MODULE_2__/* .empty */ .c)();
    return source.subscribe(subscriber);
  });
}

/***/ }),

/***/ 47485:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "E": () => (/* binding */ EMPTY),
/* harmony export */   "c": () => (/* binding */ empty)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30365);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

var EMPTY = /*@__PURE__*/new _Observable__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y(function (subscriber) {
  return subscriber.complete();
});
function empty(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}

function emptyScheduled(scheduler) {
  return new _Observable__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y(function (subscriber) {
    return scheduler.schedule(function () {
      return subscriber.complete();
    });
  });
}

/***/ }),

/***/ 41981:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "D": () => (/* binding */ from)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(30365);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js + 3 modules
var subscribeTo = __webpack_require__(23145);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(53310);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
var symbol_observable = __webpack_require__(30005);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduleObservable.js
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */



function scheduleObservable(input, scheduler) {
  return new Observable/* Observable */.y(function (subscriber) {
    var sub = new Subscription/* Subscription */.w();
    sub.add(scheduler.schedule(function () {
      var observable = input[symbol_observable/* observable */.L]();
      sub.add(observable.subscribe({
        next: function next(value) {
          sub.add(scheduler.schedule(function () {
            return subscriber.next(value);
          }));
        },
        error: function error(err) {
          sub.add(scheduler.schedule(function () {
            return subscriber.error(err);
          }));
        },
        complete: function complete() {
          sub.add(scheduler.schedule(function () {
            return subscriber.complete();
          }));
        }
      }));
    }));
    return sub;
  });
}
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/schedulePromise.js
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function schedulePromise(input, scheduler) {
  return new Observable/* Observable */.y(function (subscriber) {
    var sub = new Subscription/* Subscription */.w();
    sub.add(scheduler.schedule(function () {
      return input.then(function (value) {
        sub.add(scheduler.schedule(function () {
          subscriber.next(value);
          sub.add(scheduler.schedule(function () {
            return subscriber.complete();
          }));
        }));
      }, function (err) {
        sub.add(scheduler.schedule(function () {
          return subscriber.error(err);
        }));
      });
    }));
    return sub;
  });
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduleArray.js
var scheduleArray = __webpack_require__(51900);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/iterator.js
var symbol_iterator = __webpack_require__(71998);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduleIterable.js
/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */



function scheduleIterable(input, scheduler) {
  if (!input) {
    throw new Error('Iterable cannot be null');
  }

  return new Observable/* Observable */.y(function (subscriber) {
    var sub = new Subscription/* Subscription */.w();
    var iterator;
    sub.add(function () {
      if (iterator && typeof iterator["return"] === 'function') {
        iterator["return"]();
      }
    });
    sub.add(scheduler.schedule(function () {
      iterator = input[symbol_iterator/* iterator */.hZ]();
      sub.add(scheduler.schedule(function () {
        if (subscriber.closed) {
          return;
        }

        var value;
        var done;

        try {
          var result = iterator.next();
          value = result.value;
          done = result.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }

        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
          this.schedule();
        }
      }));
    }));
    return sub;
  });
}
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isInteropObservable.js
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

function isInteropObservable(input) {
  return input && typeof input[symbol_observable/* observable */.L] === 'function';
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isPromise.js
var isPromise = __webpack_require__(25858);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArrayLike.js
var isArrayLike = __webpack_require__(58198);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/isIterable.js
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

function isIterable(input) {
  return input && typeof input[symbol_iterator/* iterator */.hZ] === 'function';
}
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduled/scheduled.js
/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */








function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    } else if ((0,isPromise/* isPromise */.t)(input)) {
      return schedulePromise(input, scheduler);
    } else if ((0,isArrayLike/* isArrayLike */.z)(input)) {
      return (0,scheduleArray/* scheduleArray */.r)(input, scheduler);
    } else if (isIterable(input) || typeof input === 'string') {
      return scheduleIterable(input, scheduler);
    }
  }

  throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js
/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */



function from(input, scheduler) {
  if (!scheduler) {
    if (input instanceof Observable/* Observable */.y) {
      return input;
    }

    return new Observable/* Observable */.y((0,subscribeTo/* subscribeTo */.s)(input));
  } else {
    return scheduled(input, scheduler);
  }
}

/***/ }),

/***/ 71298:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "n": () => (/* binding */ fromArray)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30365);
/* harmony import */ var _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82051);
/* harmony import */ var _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(51900);
/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */



function fromArray(input, scheduler) {
  if (!scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y((0,_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__/* .subscribeToArray */ .V)(input));
  } else {
    return (0,_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__/* .scheduleArray */ .r)(input, scheduler);
  }
}

/***/ }),

/***/ 54514:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "R": () => (/* binding */ fromEvent)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30365);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(65330);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(89012);
/* harmony import */ var _operators_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65208);
/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */





var toString = /*@__PURE__*/(/* unused pure expression or super */ null && (function () {
  return Object.prototype.toString;
}()));

function fromEvent(target, eventName, options, resultSelector) {
  if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_0__/* .isFunction */ .m)(options)) {
    resultSelector = options;
    options = undefined;
  }

  if (resultSelector) {
    return fromEvent(target, eventName, options).pipe((0,_operators_map__WEBPACK_IMPORTED_MODULE_1__/* .map */ .U)(function (args) {
      return (0,_util_isArray__WEBPACK_IMPORTED_MODULE_2__/* .isArray */ .k)(args) ? resultSelector.apply(void 0, args) : resultSelector(args);
    }));
  }

  return new _Observable__WEBPACK_IMPORTED_MODULE_3__/* .Observable */ .y(function (subscriber) {
    function handler(e) {
      if (arguments.length > 1) {
        subscriber.next(Array.prototype.slice.call(arguments));
      } else {
        subscriber.next(e);
      }
    }

    setupSubscription(target, eventName, handler, subscriber, options);
  });
}

function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
  var unsubscribe;

  if (isEventTarget(sourceObj)) {
    var source_1 = sourceObj;
    sourceObj.addEventListener(eventName, handler, options);

    unsubscribe = function unsubscribe() {
      return source_1.removeEventListener(eventName, handler, options);
    };
  } else if (isJQueryStyleEventEmitter(sourceObj)) {
    var source_2 = sourceObj;
    sourceObj.on(eventName, handler);

    unsubscribe = function unsubscribe() {
      return source_2.off(eventName, handler);
    };
  } else if (isNodeStyleEventEmitter(sourceObj)) {
    var source_3 = sourceObj;
    sourceObj.addListener(eventName, handler);

    unsubscribe = function unsubscribe() {
      return source_3.removeListener(eventName, handler);
    };
  } else if (sourceObj && sourceObj.length) {
    for (var i = 0, len = sourceObj.length; i < len; i++) {
      setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
    }
  } else {
    throw new TypeError('Invalid event target');
  }

  subscriber.add(unsubscribe);
}

function isNodeStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}

function isJQueryStyleEventEmitter(sourceObj) {
  return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}

function isEventTarget(sourceObj) {
  return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}

/***/ }),

/***/ 75573:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "F": () => (/* binding */ interval)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30365);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(49663);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87967);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */



function interval(period, scheduler) {
  if (period === void 0) {
    period = 0;
  }

  if (scheduler === void 0) {
    scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__/* .async */ .P;
  }

  if (!(0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_1__/* .isNumeric */ .k)(period) || period < 0) {
    period = 0;
  }

  if (!scheduler || typeof scheduler.schedule !== 'function') {
    scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__/* .async */ .P;
  }

  return new _Observable__WEBPACK_IMPORTED_MODULE_2__/* .Observable */ .y(function (subscriber) {
    subscriber.add(scheduler.schedule(dispatch, period, {
      subscriber: subscriber,
      counter: 0,
      period: period
    }));
    return subscriber;
  });
}

function dispatch(state) {
  var subscriber = state.subscriber,
      counter = state.counter,
      period = state.period;
  subscriber.next(counter);
  this.schedule({
    subscriber: subscriber,
    counter: counter + 1,
    period: period
  }, period);
}

/***/ }),

/***/ 10125:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "T": () => (/* binding */ merge)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(30365);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8793);
/* harmony import */ var _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(64443);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(71298);
/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */




function merge() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  var concurrent = Number.POSITIVE_INFINITY;
  var scheduler = null;
  var last = observables[observables.length - 1];

  if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__/* .isScheduler */ .K)(last)) {
    scheduler = observables.pop();

    if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
      concurrent = observables.pop();
    }
  } else if (typeof last === 'number') {
    concurrent = observables.pop();
  }

  if (scheduler === null && observables.length === 1 && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_1__/* .Observable */ .y) {
    return observables[0];
  }

  return (0,_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__/* .mergeAll */ .J)(concurrent)((0,_fromArray__WEBPACK_IMPORTED_MODULE_3__/* .fromArray */ .n)(observables, scheduler));
}

/***/ }),

/***/ 65637:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "of": () => (/* binding */ of)
/* harmony export */ });
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8793);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(71298);
/* harmony import */ var _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51900);
/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */



function of() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  var scheduler = args[args.length - 1];

  if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__/* .isScheduler */ .K)(scheduler)) {
    args.pop();
    return (0,_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_1__/* .scheduleArray */ .r)(args, scheduler);
  } else {
    return (0,_fromArray__WEBPACK_IMPORTED_MODULE_2__/* .fromArray */ .n)(args);
  }
}

/***/ }),

/***/ 98925:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "S3": () => (/* binding */ race)
/* harmony export */ });
/* unused harmony exports RaceOperator, RaceSubscriber */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10649);
/* harmony import */ var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65330);
/* harmony import */ var _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(71298);
/* harmony import */ var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6965);
/* harmony import */ var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81173);
/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */





function race() {
  var observables = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    observables[_i] = arguments[_i];
  }

  if (observables.length === 1) {
    if ((0,_util_isArray__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .k)(observables[0])) {
      observables = observables[0];
    } else {
      return observables[0];
    }
  }

  return (0,_fromArray__WEBPACK_IMPORTED_MODULE_1__/* .fromArray */ .n)(observables, undefined).lift(new RaceOperator());
}

var RaceOperator = /*@__PURE__*/function () {
  function RaceOperator() {}

  RaceOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new RaceSubscriber(subscriber));
  };

  return RaceOperator;
}();



var RaceSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_2__/* .__extends */ .ZT(RaceSubscriber, _super);

  function RaceSubscriber(destination) {
    var _this = _super.call(this, destination) || this;

    _this.hasFirst = false;
    _this.observables = [];
    _this.subscriptions = [];
    return _this;
  }

  RaceSubscriber.prototype._next = function (observable) {
    this.observables.push(observable);
  };

  RaceSubscriber.prototype._complete = function () {
    var observables = this.observables;
    var len = observables.length;

    if (len === 0) {
      this.destination.complete();
    } else {
      for (var i = 0; i < len && !this.hasFirst; i++) {
        var observable = observables[i];
        var subscription = (0,_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__/* .subscribeToResult */ .D)(this, observable, undefined, i);

        if (this.subscriptions) {
          this.subscriptions.push(subscription);
        }

        this.add(subscription);
      }

      this.observables = null;
    }
  };

  RaceSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
    if (!this.hasFirst) {
      this.hasFirst = true;

      for (var i = 0; i < this.subscriptions.length; i++) {
        if (i !== outerIndex) {
          var subscription = this.subscriptions[i];
          subscription.unsubscribe();
          this.remove(subscription);
        }
      }

      this.subscriptions = null;
    }

    this.destination.next(innerValue);
  };

  return RaceSubscriber;
}(_OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__/* .OuterSubscriber */ .L);



/***/ }),

/***/ 55022:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_": () => (/* binding */ throwError)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30365);
/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

function throwError(error, scheduler) {
  if (!scheduler) {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y(function (subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new _Observable__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y(function (subscriber) {
      return scheduler.schedule(dispatch, 0, {
        error: error,
        subscriber: subscriber
      });
    });
  }
}

function dispatch(_a) {
  var error = _a.error,
      subscriber = _a.subscriber;
  subscriber.error(error);
}

/***/ }),

/***/ 61106:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "H": () => (/* binding */ timer)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30365);
/* harmony import */ var _scheduler_async__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49663);
/* harmony import */ var _util_isNumeric__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87967);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8793);
/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */




function timer(dueTime, periodOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }

  var period = -1;

  if ((0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_0__/* .isNumeric */ .k)(periodOrScheduler)) {
    period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
  } else if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__/* .isScheduler */ .K)(periodOrScheduler)) {
    scheduler = periodOrScheduler;
  }

  if (!(0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__/* .isScheduler */ .K)(scheduler)) {
    scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_2__/* .async */ .P;
  }

  return new _Observable__WEBPACK_IMPORTED_MODULE_3__/* .Observable */ .y(function (subscriber) {
    var due = (0,_util_isNumeric__WEBPACK_IMPORTED_MODULE_0__/* .isNumeric */ .k)(dueTime) ? dueTime : +dueTime - scheduler.now();
    return scheduler.schedule(dispatch, due, {
      index: 0,
      period: period,
      subscriber: subscriber
    });
  });
}

function dispatch(state) {
  var index = state.index,
      period = state.period,
      subscriber = state.subscriber;
  subscriber.next(index);

  if (subscriber.closed) {
    return;
  } else if (period === -1) {
    return subscriber.complete();
  }

  state.index = index + 1;
  this.schedule(state, period);
}

/***/ }),

/***/ 7947:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "K": () => (/* binding */ catchError)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(90789);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function catchError(selector) {
  return function catchErrorOperatorFunction(source) {
    var operator = new CatchOperator(selector);
    var caught = source.lift(operator);
    return operator.caught = caught;
  };
}

var CatchOperator = /*@__PURE__*/function () {
  function CatchOperator(selector) {
    this.selector = selector;
  }

  CatchOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
  };

  return CatchOperator;
}();

var CatchSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(CatchSubscriber, _super);

  function CatchSubscriber(destination, selector, caught) {
    var _this = _super.call(this, destination) || this;

    _this.selector = selector;
    _this.caught = caught;
    return _this;
  }

  CatchSubscriber.prototype.error = function (err) {
    if (!this.isStopped) {
      var result = void 0;

      try {
        result = this.selector(err, this.caught);
      } catch (err2) {
        _super.prototype.error.call(this, err2);

        return;
      }

      this._unsubscribeAndRecycle();

      var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_1__/* .SimpleInnerSubscriber */ .IY(this);
      this.add(innerSubscriber);
      var innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__/* .innerSubscribe */ .ft)(result, innerSubscriber);

      if (innerSubscription !== innerSubscriber) {
        this.add(innerSubscription);
      }
    }
  };

  return CatchSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_1__/* .SimpleOuterSubscriber */ .Ds);

/***/ }),

/***/ 28358:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "u": () => (/* binding */ concatAll)
/* harmony export */ });
/* harmony import */ var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64443);
/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */

function concatAll() {
  return (0,_mergeAll__WEBPACK_IMPORTED_MODULE_0__/* .mergeAll */ .J)(1);
}

/***/ }),

/***/ 96078:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x": () => (/* binding */ distinctUntilChanged)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50032);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function distinctUntilChanged(compare, keySelector) {
  return function (source) {
    return source.lift(new DistinctUntilChangedOperator(compare, keySelector));
  };
}

var DistinctUntilChangedOperator = /*@__PURE__*/function () {
  function DistinctUntilChangedOperator(compare, keySelector) {
    this.compare = compare;
    this.keySelector = keySelector;
  }

  DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
  };

  return DistinctUntilChangedOperator;
}();

var DistinctUntilChangedSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(DistinctUntilChangedSubscriber, _super);

  function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
    var _this = _super.call(this, destination) || this;

    _this.keySelector = keySelector;
    _this.hasKey = false;

    if (typeof compare === 'function') {
      _this.compare = compare;
    }

    return _this;
  }

  DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
    return x === y;
  };

  DistinctUntilChangedSubscriber.prototype._next = function (value) {
    var key;

    try {
      var keySelector = this.keySelector;
      key = keySelector ? keySelector(value) : value;
    } catch (err) {
      return this.destination.error(err);
    }

    var result = false;

    if (this.hasKey) {
      try {
        var compare = this.compare;
        result = compare(this.key, key);
      } catch (err) {
        return this.destination.error(err);
      }
    } else {
      this.hasKey = true;
    }

    if (!result) {
      this.key = key;
      this.destination.next(value);
    }
  };

  return DistinctUntilChangedSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);

/***/ }),

/***/ 96705:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": () => (/* binding */ filter)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50032);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function filter(predicate, thisArg) {
  return function filterOperatorFunction(source) {
    return source.lift(new FilterOperator(predicate, thisArg));
  };
}

var FilterOperator = /*@__PURE__*/function () {
  function FilterOperator(predicate, thisArg) {
    this.predicate = predicate;
    this.thisArg = thisArg;
  }

  FilterOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
  };

  return FilterOperator;
}();

var FilterSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(FilterSubscriber, _super);

  function FilterSubscriber(destination, predicate, thisArg) {
    var _this = _super.call(this, destination) || this;

    _this.predicate = predicate;
    _this.thisArg = thisArg;
    _this.count = 0;
    return _this;
  }

  FilterSubscriber.prototype._next = function (value) {
    var result;

    try {
      result = this.predicate.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    if (result) {
      this.destination.next(value);
    }
  };

  return FilterSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);

/***/ }),

/***/ 61030:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "l": () => (/* binding */ ignoreElements)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50032);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function ignoreElements() {
  return function ignoreElementsOperatorFunction(source) {
    return source.lift(new IgnoreElementsOperator());
  };
}

var IgnoreElementsOperator = /*@__PURE__*/function () {
  function IgnoreElementsOperator() {}

  IgnoreElementsOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new IgnoreElementsSubscriber(subscriber));
  };

  return IgnoreElementsOperator;
}();

var IgnoreElementsSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(IgnoreElementsSubscriber, _super);

  function IgnoreElementsSubscriber() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  IgnoreElementsSubscriber.prototype._next = function (unused) {};

  return IgnoreElementsSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);

/***/ }),

/***/ 65208:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": () => (/* binding */ map)
/* harmony export */ });
/* unused harmony export MapOperator */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50032);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function map(project, thisArg) {
  return function mapOperation(source) {
    if (typeof project !== 'function') {
      throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
    }

    return source.lift(new MapOperator(project, thisArg));
  };
}

var MapOperator = /*@__PURE__*/function () {
  function MapOperator(project, thisArg) {
    this.project = project;
    this.thisArg = thisArg;
  }

  MapOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
  };

  return MapOperator;
}();



var MapSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(MapSubscriber, _super);

  function MapSubscriber(destination, project, thisArg) {
    var _this = _super.call(this, destination) || this;

    _this.project = project;
    _this.count = 0;
    _this.thisArg = thisArg || _this;
    return _this;
  }

  MapSubscriber.prototype._next = function (value) {
    var result;

    try {
      result = this.project.call(this.thisArg, value, this.count++);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.next(result);
  };

  return MapSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);

/***/ }),

/***/ 53059:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "h": () => (/* binding */ mapTo)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50032);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function mapTo(value) {
  return function (source) {
    return source.lift(new MapToOperator(value));
  };
}

var MapToOperator = /*@__PURE__*/function () {
  function MapToOperator(value) {
    this.value = value;
  }

  MapToOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new MapToSubscriber(subscriber, this.value));
  };

  return MapToOperator;
}();

var MapToSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(MapToSubscriber, _super);

  function MapToSubscriber(destination, value) {
    var _this = _super.call(this, destination) || this;

    _this.value = value;
    return _this;
  }

  MapToSubscriber.prototype._next = function (x) {
    this.destination.next(this.value);
  };

  return MapToSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);

/***/ }),

/***/ 64443:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "J": () => (/* binding */ mergeAll)
/* harmony export */ });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75688);
/* harmony import */ var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11707);
/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */


function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }

  return (0,_mergeMap__WEBPACK_IMPORTED_MODULE_0__/* .mergeMap */ .zg)(_util_identity__WEBPACK_IMPORTED_MODULE_1__/* .identity */ .y, concurrent);
}

/***/ }),

/***/ 75688:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "zg": () => (/* binding */ mergeMap)
/* harmony export */ });
/* unused harmony exports MergeMapOperator, MergeMapSubscriber, flatMap */
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10649);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65208);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41981);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90789);
/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */




function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }

  if (typeof resultSelector === 'function') {
    return function (source) {
      return source.pipe(mergeMap(function (a, i) {
        return (0,_observable_from__WEBPACK_IMPORTED_MODULE_0__/* .from */ .D)(project(a, i)).pipe((0,_map__WEBPACK_IMPORTED_MODULE_1__/* .map */ .U)(function (b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }, concurrent));
    };
  } else if (typeof resultSelector === 'number') {
    concurrent = resultSelector;
  }

  return function (source) {
    return source.lift(new MergeMapOperator(project, concurrent));
  };
}

var MergeMapOperator = /*@__PURE__*/function () {
  function MergeMapOperator(project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }

    this.project = project;
    this.concurrent = concurrent;
  }

  MergeMapOperator.prototype.call = function (observer, source) {
    return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
  };

  return MergeMapOperator;
}();



var MergeMapSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_2__/* .__extends */ .ZT(MergeMapSubscriber, _super);

  function MergeMapSubscriber(destination, project, concurrent) {
    if (concurrent === void 0) {
      concurrent = Number.POSITIVE_INFINITY;
    }

    var _this = _super.call(this, destination) || this;

    _this.project = project;
    _this.concurrent = concurrent;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }

  MergeMapSubscriber.prototype._next = function (value) {
    if (this.active < this.concurrent) {
      this._tryNext(value);
    } else {
      this.buffer.push(value);
    }
  };

  MergeMapSubscriber.prototype._tryNext = function (value) {
    var result;
    var index = this.index++;

    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.active++;

    this._innerSub(result);
  };

  MergeMapSubscriber.prototype._innerSub = function (ish) {
    var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__/* .SimpleInnerSubscriber */ .IY(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__/* .innerSubscribe */ .ft)(ish, innerSubscriber);

    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };

  MergeMapSubscriber.prototype._complete = function () {
    this.hasCompleted = true;

    if (this.active === 0 && this.buffer.length === 0) {
      this.destination.complete();
    }

    this.unsubscribe();
  };

  MergeMapSubscriber.prototype.notifyNext = function (innerValue) {
    this.destination.next(innerValue);
  };

  MergeMapSubscriber.prototype.notifyComplete = function () {
    var buffer = this.buffer;
    this.active--;

    if (buffer.length > 0) {
      this._next(buffer.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      this.destination.complete();
    }
  };

  return MergeMapSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__/* .SimpleOuterSubscriber */ .Ds);


var flatMap = (/* unused pure expression or super */ null && (mergeMap));

/***/ }),

/***/ 2089:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j": () => (/* binding */ mergeMapTo)
/* harmony export */ });
/* harmony import */ var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(75688);
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function mergeMapTo(innerObservable, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }

  if (typeof resultSelector === 'function') {
    return (0,_mergeMap__WEBPACK_IMPORTED_MODULE_0__/* .mergeMap */ .zg)(function () {
      return innerObservable;
    }, resultSelector, concurrent);
  }

  if (typeof resultSelector === 'number') {
    concurrent = resultSelector;
  }

  return (0,_mergeMap__WEBPACK_IMPORTED_MODULE_0__/* .mergeMap */ .zg)(function () {
    return innerObservable;
  }, concurrent);
}

/***/ }),

/***/ 20596:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "O": () => (/* binding */ multicast)
});

// UNUSED EXPORTS: MulticastOperator

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(10649);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(81044);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(30365);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(50032);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(53310);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/refCount.js
var refCount = __webpack_require__(80950);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/ConnectableObservable.js
/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */







var ConnectableObservable = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(ConnectableObservable, _super);

  function ConnectableObservable(source, subjectFactory) {
    var _this = _super.call(this) || this;

    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._refCount = 0;
    _this._isComplete = false;
    return _this;
  }

  ConnectableObservable.prototype._subscribe = function (subscriber) {
    return this.getSubject().subscribe(subscriber);
  };

  ConnectableObservable.prototype.getSubject = function () {
    var subject = this._subject;

    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }

    return this._subject;
  };

  ConnectableObservable.prototype.connect = function () {
    var connection = this._connection;

    if (!connection) {
      this._isComplete = false;
      connection = this._connection = new Subscription/* Subscription */.w();
      connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));

      if (connection.closed) {
        this._connection = null;
        connection = Subscription/* Subscription.EMPTY */.w.EMPTY;
      }
    }

    return connection;
  };

  ConnectableObservable.prototype.refCount = function () {
    return (0,refCount/* refCount */.x)()(this);
  };

  return ConnectableObservable;
}(Observable/* Observable */.y);


var connectableObservableDescriptor = /*@__PURE__*/function () {
  var connectableProto = ConnectableObservable.prototype;
  return {
    operator: {
      value: null
    },
    _refCount: {
      value: 0,
      writable: true
    },
    _subject: {
      value: null,
      writable: true
    },
    _connection: {
      value: null,
      writable: true
    },
    _subscribe: {
      value: connectableProto._subscribe
    },
    _isComplete: {
      value: connectableProto._isComplete,
      writable: true
    },
    getSubject: {
      value: connectableProto.getSubject
    },
    connect: {
      value: connectableProto.connect
    },
    refCount: {
      value: connectableProto.refCount
    }
  };
}();

var ConnectableSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(ConnectableSubscriber, _super);

  function ConnectableSubscriber(destination, connectable) {
    var _this = _super.call(this, destination) || this;

    _this.connectable = connectable;
    return _this;
  }

  ConnectableSubscriber.prototype._error = function (err) {
    this._unsubscribe();

    _super.prototype._error.call(this, err);
  };

  ConnectableSubscriber.prototype._complete = function () {
    this.connectable._isComplete = true;

    this._unsubscribe();

    _super.prototype._complete.call(this);
  };

  ConnectableSubscriber.prototype._unsubscribe = function () {
    var connectable = this.connectable;

    if (connectable) {
      this.connectable = null;
      var connection = connectable._connection;
      connectable._refCount = 0;
      connectable._subject = null;
      connectable._connection = null;

      if (connection) {
        connection.unsubscribe();
      }
    }
  };

  return ConnectableSubscriber;
}(Subject/* SubjectSubscriber */.Yc);

var RefCountOperator = /*@__PURE__*/(/* unused pure expression or super */ null && (function () {
  function RefCountOperator(connectable) {
    this.connectable = connectable;
  }

  RefCountOperator.prototype.call = function (subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);

    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }

    return subscription;
  };

  return RefCountOperator;
}()));

var RefCountSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(RefCountSubscriber, _super);

  function RefCountSubscriber(destination, connectable) {
    var _this = _super.call(this, destination) || this;

    _this.connectable = connectable;
    return _this;
  }

  RefCountSubscriber.prototype._unsubscribe = function () {
    var connectable = this.connectable;

    if (!connectable) {
      this.connection = null;
      return;
    }

    this.connectable = null;
    var refCount = connectable._refCount;

    if (refCount <= 0) {
      this.connection = null;
      return;
    }

    connectable._refCount = refCount - 1;

    if (refCount > 1) {
      this.connection = null;
      return;
    }

    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;

    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };

  return RefCountSubscriber;
}(Subscriber/* Subscriber */.L);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/multicast.js
/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */

function multicast(subjectOrSubjectFactory, selector) {
  return function multicastOperatorFunction(source) {
    var subjectFactory;

    if (typeof subjectOrSubjectFactory === 'function') {
      subjectFactory = subjectOrSubjectFactory;
    } else {
      subjectFactory = function subjectFactory() {
        return subjectOrSubjectFactory;
      };
    }

    if (typeof selector === 'function') {
      return source.lift(new MulticastOperator(subjectFactory, selector));
    }

    var connectable = Object.create(source, connectableObservableDescriptor);
    connectable.source = source;
    connectable.subjectFactory = subjectFactory;
    return connectable;
  };
}

var MulticastOperator = /*@__PURE__*/function () {
  function MulticastOperator(subjectFactory, selector) {
    this.subjectFactory = subjectFactory;
    this.selector = selector;
  }

  MulticastOperator.prototype.call = function (subscriber, source) {
    var selector = this.selector;
    var subject = this.subjectFactory();
    var subscription = selector(subject).subscribe(subscriber);
    subscription.add(source.subscribe(subject));
    return subscription;
  };

  return MulticastOperator;
}();



/***/ }),

/***/ 80950:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "x": () => (/* binding */ refCount)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50032);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function refCount() {
  return function refCountOperatorFunction(source) {
    return source.lift(new RefCountOperator(source));
  };
}

var RefCountOperator = /*@__PURE__*/function () {
  function RefCountOperator(connectable) {
    this.connectable = connectable;
  }

  RefCountOperator.prototype.call = function (subscriber, source) {
    var connectable = this.connectable;
    connectable._refCount++;
    var refCounter = new RefCountSubscriber(subscriber, connectable);
    var subscription = source.subscribe(refCounter);

    if (!refCounter.closed) {
      refCounter.connection = connectable.connect();
    }

    return subscription;
  };

  return RefCountOperator;
}();

var RefCountSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(RefCountSubscriber, _super);

  function RefCountSubscriber(destination, connectable) {
    var _this = _super.call(this, destination) || this;

    _this.connectable = connectable;
    return _this;
  }

  RefCountSubscriber.prototype._unsubscribe = function () {
    var connectable = this.connectable;

    if (!connectable) {
      this.connection = null;
      return;
    }

    this.connectable = null;
    var refCount = connectable._refCount;

    if (refCount <= 0) {
      this.connection = null;
      return;
    }

    connectable._refCount = refCount - 1;

    if (refCount > 1) {
      this.connection = null;
      return;
    }

    var connection = this.connection;
    var sharedConnection = connectable._connection;
    this.connection = null;

    if (sharedConnection && (!connection || sharedConnection === connection)) {
      sharedConnection.unsubscribe();
    }
  };

  return RefCountSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);

/***/ }),

/***/ 55291:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "R": () => (/* binding */ scan)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(50032);
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function scan(accumulator, seed) {
  var hasSeed = false;

  if (arguments.length >= 2) {
    hasSeed = true;
  }

  return function scanOperatorFunction(source) {
    return source.lift(new ScanOperator(accumulator, seed, hasSeed));
  };
}

var ScanOperator = /*@__PURE__*/function () {
  function ScanOperator(accumulator, seed, hasSeed) {
    if (hasSeed === void 0) {
      hasSeed = false;
    }

    this.accumulator = accumulator;
    this.seed = seed;
    this.hasSeed = hasSeed;
  }

  ScanOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
  };

  return ScanOperator;
}();

var ScanSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(ScanSubscriber, _super);

  function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
    var _this = _super.call(this, destination) || this;

    _this.accumulator = accumulator;
    _this._seed = _seed;
    _this.hasSeed = hasSeed;
    _this.index = 0;
    return _this;
  }

  Object.defineProperty(ScanSubscriber.prototype, "seed", {
    get: function get() {
      return this._seed;
    },
    set: function set(value) {
      this.hasSeed = true;
      this._seed = value;
    },
    enumerable: true,
    configurable: true
  });

  ScanSubscriber.prototype._next = function (value) {
    if (!this.hasSeed) {
      this.seed = value;
      this.destination.next(value);
    } else {
      return this._tryNext(value);
    }
  };

  ScanSubscriber.prototype._tryNext = function (value) {
    var index = this.index++;
    var result;

    try {
      result = this.accumulator(this.seed, value, index);
    } catch (err) {
      this.destination.error(err);
    }

    this.seed = result;
    this.destination.next(result);
  };

  return ScanSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_1__/* .Subscriber */ .L);

/***/ }),

/***/ 32139:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "B": () => (/* binding */ share)
/* harmony export */ });
/* harmony import */ var _multicast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20596);
/* harmony import */ var _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(80950);
/* harmony import */ var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(81044);
/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */




function shareSubjectFactory() {
  return new _Subject__WEBPACK_IMPORTED_MODULE_0__/* .Subject */ .xQ();
}

function share() {
  return function (source) {
    return (0,_refCount__WEBPACK_IMPORTED_MODULE_1__/* .refCount */ .x)()((0,_multicast__WEBPACK_IMPORTED_MODULE_2__/* .multicast */ .O)(shareSubjectFactory)(source));
  };
}

/***/ }),

/***/ 83425:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "d": () => (/* binding */ shareReplay)
/* harmony export */ });
/* harmony import */ var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4815);
/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */

function shareReplay(configOrBufferSize, windowTime, scheduler) {
  var config;

  if (configOrBufferSize && typeof configOrBufferSize === 'object') {
    config = configOrBufferSize;
  } else {
    config = {
      bufferSize: configOrBufferSize,
      windowTime: windowTime,
      refCount: false,
      scheduler: scheduler
    };
  }

  return function (source) {
    return source.lift(shareReplayOperator(config));
  };
}

function shareReplayOperator(_a) {
  var _b = _a.bufferSize,
      bufferSize = _b === void 0 ? Number.POSITIVE_INFINITY : _b,
      _c = _a.windowTime,
      windowTime = _c === void 0 ? Number.POSITIVE_INFINITY : _c,
      useRefCount = _a.refCount,
      scheduler = _a.scheduler;
  var subject;
  var refCount = 0;
  var subscription;
  var hasError = false;
  var isComplete = false;
  return function shareReplayOperation(source) {
    refCount++;
    var innerSub;

    if (!subject || hasError) {
      hasError = false;
      subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__/* .ReplaySubject */ .t(bufferSize, windowTime, scheduler);
      innerSub = subject.subscribe(this);
      subscription = source.subscribe({
        next: function next(value) {
          subject.next(value);
        },
        error: function error(err) {
          hasError = true;
          subject.error(err);
        },
        complete: function complete() {
          isComplete = true;
          subscription = undefined;
          subject.complete();
        }
      });

      if (isComplete) {
        subscription = undefined;
      }
    } else {
      innerSub = subject.subscribe(this);
    }

    this.add(function () {
      refCount--;
      innerSub.unsubscribe();
      innerSub = undefined;

      if (subscription && !isComplete && useRefCount && refCount === 0) {
        subscription.unsubscribe();
        subscription = undefined;
        subject = undefined;
      }
    });
  };
}

/***/ }),

/***/ 5118:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "O": () => (/* binding */ startWith)
/* harmony export */ });
/* harmony import */ var _observable_concat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70252);
/* harmony import */ var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8793);
/** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */


function startWith() {
  var array = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    array[_i] = arguments[_i];
  }

  var scheduler = array[array.length - 1];

  if ((0,_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__/* .isScheduler */ .K)(scheduler)) {
    array.pop();
    return function (source) {
      return (0,_observable_concat__WEBPACK_IMPORTED_MODULE_1__/* .concat */ .z)(array, source, scheduler);
    };
  } else {
    return function (source) {
      return (0,_observable_concat__WEBPACK_IMPORTED_MODULE_1__/* .concat */ .z)(array, source);
    };
  }
}

/***/ }),

/***/ 17568:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "w": () => (/* binding */ switchMap)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10649);
/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65208);
/* harmony import */ var _observable_from__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41981);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(90789);
/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */




function switchMap(project, resultSelector) {
  if (typeof resultSelector === 'function') {
    return function (source) {
      return source.pipe(switchMap(function (a, i) {
        return (0,_observable_from__WEBPACK_IMPORTED_MODULE_0__/* .from */ .D)(project(a, i)).pipe((0,_map__WEBPACK_IMPORTED_MODULE_1__/* .map */ .U)(function (b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }));
    };
  }

  return function (source) {
    return source.lift(new SwitchMapOperator(project));
  };
}

var SwitchMapOperator = /*@__PURE__*/function () {
  function SwitchMapOperator(project) {
    this.project = project;
  }

  SwitchMapOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
  };

  return SwitchMapOperator;
}();

var SwitchMapSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_2__/* .__extends */ .ZT(SwitchMapSubscriber, _super);

  function SwitchMapSubscriber(destination, project) {
    var _this = _super.call(this, destination) || this;

    _this.project = project;
    _this.index = 0;
    return _this;
  }

  SwitchMapSubscriber.prototype._next = function (value) {
    var result;
    var index = this.index++;

    try {
      result = this.project(value, index);
    } catch (error) {
      this.destination.error(error);
      return;
    }

    this._innerSub(result);
  };

  SwitchMapSubscriber.prototype._innerSub = function (result) {
    var innerSubscription = this.innerSubscription;

    if (innerSubscription) {
      innerSubscription.unsubscribe();
    }

    var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__/* .SimpleInnerSubscriber */ .IY(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    this.innerSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__/* .innerSubscribe */ .ft)(result, innerSubscriber);

    if (this.innerSubscription !== innerSubscriber) {
      destination.add(this.innerSubscription);
    }
  };

  SwitchMapSubscriber.prototype._complete = function () {
    var innerSubscription = this.innerSubscription;

    if (!innerSubscription || innerSubscription.closed) {
      _super.prototype._complete.call(this);
    }

    this.unsubscribe();
  };

  SwitchMapSubscriber.prototype._unsubscribe = function () {
    this.innerSubscription = undefined;
  };

  SwitchMapSubscriber.prototype.notifyComplete = function () {
    this.innerSubscription = undefined;

    if (this.isStopped) {
      _super.prototype._complete.call(this);
    }
  };

  SwitchMapSubscriber.prototype.notifyNext = function (innerValue) {
    this.destination.next(innerValue);
  };

  return SwitchMapSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__/* .SimpleOuterSubscriber */ .Ds);

/***/ }),

/***/ 97228:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "c": () => (/* binding */ switchMapTo)
/* harmony export */ });
/* harmony import */ var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17568);
/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

function switchMapTo(innerObservable, resultSelector) {
  return resultSelector ? (0,_switchMap__WEBPACK_IMPORTED_MODULE_0__/* .switchMap */ .w)(function () {
    return innerObservable;
  }, resultSelector) : (0,_switchMap__WEBPACK_IMPORTED_MODULE_0__/* .switchMap */ .w)(function () {
    return innerObservable;
  });
}

/***/ }),

/***/ 53329:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "q": () => (/* binding */ take)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10649);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(50032);
/* harmony import */ var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(86665);
/* harmony import */ var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47485);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function take(count) {
  return function (source) {
    if (count === 0) {
      return (0,_observable_empty__WEBPACK_IMPORTED_MODULE_0__/* .empty */ .c)();
    } else {
      return source.lift(new TakeOperator(count));
    }
  };
}

var TakeOperator = /*@__PURE__*/function () {
  function TakeOperator(total) {
    this.total = total;

    if (this.total < 0) {
      throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__/* .ArgumentOutOfRangeError */ .W();
    }
  }

  TakeOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new TakeSubscriber(subscriber, this.total));
  };

  return TakeOperator;
}();

var TakeSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_2__/* .__extends */ .ZT(TakeSubscriber, _super);

  function TakeSubscriber(destination, total) {
    var _this = _super.call(this, destination) || this;

    _this.total = total;
    _this.count = 0;
    return _this;
  }

  TakeSubscriber.prototype._next = function (value) {
    var total = this.total;
    var count = ++this.count;

    if (count <= total) {
      this.destination.next(value);

      if (count === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  };

  return TakeSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__/* .Subscriber */ .L);

/***/ }),

/***/ 28305:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "R": () => (/* binding */ takeUntil)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10649);
/* harmony import */ var _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(90789);
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function takeUntil(notifier) {
  return function (source) {
    return source.lift(new TakeUntilOperator(notifier));
  };
}

var TakeUntilOperator = /*@__PURE__*/function () {
  function TakeUntilOperator(notifier) {
    this.notifier = notifier;
  }

  TakeUntilOperator.prototype.call = function (subscriber, source) {
    var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
    var notifierSubscription = (0,_innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .innerSubscribe */ .ft)(this.notifier, new _innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .SimpleInnerSubscriber */ .IY(takeUntilSubscriber));

    if (notifierSubscription && !takeUntilSubscriber.seenValue) {
      takeUntilSubscriber.add(notifierSubscription);
      return source.subscribe(takeUntilSubscriber);
    }

    return takeUntilSubscriber;
  };

  return TakeUntilOperator;
}();

var TakeUntilSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_1__/* .__extends */ .ZT(TakeUntilSubscriber, _super);

  function TakeUntilSubscriber(destination) {
    var _this = _super.call(this, destination) || this;

    _this.seenValue = false;
    return _this;
  }

  TakeUntilSubscriber.prototype.notifyNext = function () {
    this.seenValue = true;
    this.complete();
  };

  TakeUntilSubscriber.prototype.notifyComplete = function () {};

  return TakeUntilSubscriber;
}(_innerSubscribe__WEBPACK_IMPORTED_MODULE_0__/* .SimpleOuterSubscriber */ .Ds);

/***/ }),

/***/ 5842:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": () => (/* binding */ tap)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10649);
/* harmony import */ var _Subscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(50032);
/* harmony import */ var _util_noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(44992);
/* harmony import */ var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(89012);
/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */




function tap(nextOrObserver, error, complete) {
  return function tapOperatorFunction(source) {
    return source.lift(new DoOperator(nextOrObserver, error, complete));
  };
}

var DoOperator = /*@__PURE__*/function () {
  function DoOperator(nextOrObserver, error, complete) {
    this.nextOrObserver = nextOrObserver;
    this.error = error;
    this.complete = complete;
  }

  DoOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
  };

  return DoOperator;
}();

var TapSubscriber = /*@__PURE__*/function (_super) {
  tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .ZT(TapSubscriber, _super);

  function TapSubscriber(destination, observerOrNext, error, complete) {
    var _this = _super.call(this, destination) || this;

    _this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_1__/* .noop */ .Z;
    _this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_1__/* .noop */ .Z;
    _this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_1__/* .noop */ .Z;
    _this._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_1__/* .noop */ .Z;
    _this._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_1__/* .noop */ .Z;

    if ((0,_util_isFunction__WEBPACK_IMPORTED_MODULE_2__/* .isFunction */ .m)(observerOrNext)) {
      _this._context = _this;
      _this._tapNext = observerOrNext;
    } else if (observerOrNext) {
      _this._context = observerOrNext;
      _this._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_1__/* .noop */ .Z;
      _this._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_1__/* .noop */ .Z;
      _this._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_1__/* .noop */ .Z;
    }

    return _this;
  }

  TapSubscriber.prototype._next = function (value) {
    try {
      this._tapNext.call(this._context, value);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.next(value);
  };

  TapSubscriber.prototype._error = function (err) {
    try {
      this._tapError.call(this._context, err);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.error(err);
  };

  TapSubscriber.prototype._complete = function () {
    try {
      this._tapComplete.call(this._context);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    return this.destination.complete();
  };

  return TapSubscriber;
}(_Subscriber__WEBPACK_IMPORTED_MODULE_3__/* .Subscriber */ .L);

/***/ }),

/***/ 51900:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r": () => (/* binding */ scheduleArray)
/* harmony export */ });
/* harmony import */ var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30365);
/* harmony import */ var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53310);
/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */


function scheduleArray(input, scheduler) {
  return new _Observable__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y(function (subscriber) {
    var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__/* .Subscription */ .w();
    var i = 0;
    sub.add(scheduler.schedule(function () {
      if (i === input.length) {
        subscriber.complete();
        return;
      }

      subscriber.next(input[i++]);

      if (!subscriber.closed) {
        sub.add(this.schedule());
      }
    }));
    return sub;
  });
}

/***/ }),

/***/ 55733:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "o": () => (/* binding */ AsyncAction)
});

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(10649);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(53310);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/Action.js
/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */



var Action = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(Action, _super);

  function Action(scheduler, work) {
    return _super.call(this) || this;
  }

  Action.prototype.schedule = function (state, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    return this;
  };

  return Action;
}(Subscription/* Subscription */.w);


;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js
/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */



var AsyncAction = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(AsyncAction, _super);

  function AsyncAction(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }

  AsyncAction.prototype.schedule = function (state, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (this.closed) {
      return this;
    }

    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;

    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }

    this.pending = true;
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };

  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    return setInterval(scheduler.flush.bind(scheduler, this), delay);
  };

  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && this.delay === delay && this.pending === false) {
      return id;
    }

    clearInterval(id);
    return undefined;
  };

  AsyncAction.prototype.execute = function (state, delay) {
    if (this.closed) {
      return new Error('executing a cancelled action');
    }

    this.pending = false;

    var error = this._execute(state, delay);

    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };

  AsyncAction.prototype._execute = function (state, delay) {
    var errored = false;
    var errorValue = undefined;

    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = !!e && e || new Error(e);
    }

    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };

  AsyncAction.prototype._unsubscribe = function () {
    var id = this.id;
    var scheduler = this.scheduler;
    var actions = scheduler.actions;
    var index = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;

    if (index !== -1) {
      actions.splice(index, 1);
    }

    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, null);
    }

    this.delay = null;
  };

  return AsyncAction;
}(Action);



/***/ }),

/***/ 62641:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "v": () => (/* binding */ AsyncScheduler)
});

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(10649);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/Scheduler.js
var Scheduler = /*@__PURE__*/function () {
  function Scheduler(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }

    this.SchedulerAction = SchedulerAction;
    this.now = now;
  }

  Scheduler.prototype.schedule = function (work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }

    return new this.SchedulerAction(this, work).schedule(state, delay);
  };

  Scheduler.now = function () {
    return Date.now();
  };

  return Scheduler;
}();


;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js
/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */



var AsyncScheduler = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(AsyncScheduler, _super);

  function AsyncScheduler(SchedulerAction, now) {
    if (now === void 0) {
      now = Scheduler.now;
    }

    var _this = _super.call(this, SchedulerAction, function () {
      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
        return AsyncScheduler.delegate.now();
      } else {
        return now();
      }
    }) || this;

    _this.actions = [];
    _this.active = false;
    _this.scheduled = undefined;
    return _this;
  }

  AsyncScheduler.prototype.schedule = function (work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }

    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
      return AsyncScheduler.delegate.schedule(work, delay, state);
    } else {
      return _super.prototype.schedule.call(this, work, delay, state);
    }
  };

  AsyncScheduler.prototype.flush = function (action) {
    var actions = this.actions;

    if (this.active) {
      actions.push(action);
      return;
    }

    var error;
    this.active = true;

    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());

    this.active = false;

    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }

      throw error;
    }
  };

  return AsyncScheduler;
}(Scheduler);



/***/ }),

/***/ 49663:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "P": () => (/* binding */ async)
/* harmony export */ });
/* unused harmony export asyncScheduler */
/* harmony import */ var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55733);
/* harmony import */ var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(62641);
/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */


var asyncScheduler = /*@__PURE__*/new _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__/* .AsyncScheduler */ .v(_AsyncAction__WEBPACK_IMPORTED_MODULE_1__/* .AsyncAction */ .o);
var async = asyncScheduler;

/***/ }),

/***/ 71998:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hZ": () => (/* binding */ iterator)
/* harmony export */ });
/* unused harmony exports getSymbolIterator, $$iterator */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
  if (typeof Symbol !== 'function' || !Symbol.iterator) {
    return '@@iterator';
  }

  return Symbol.iterator;
}
var iterator = /*@__PURE__*/getSymbolIterator();
var $$iterator = (/* unused pure expression or super */ null && (iterator));

/***/ }),

/***/ 30005:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "L": () => (/* binding */ observable)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = /*@__PURE__*/function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
}();

/***/ }),

/***/ 12396:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "b": () => (/* binding */ rxSubscriber)
/* harmony export */ });
/* unused harmony export $$rxSubscriber */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = /*@__PURE__*/function () {
  return typeof Symbol === 'function' ? /*@__PURE__*/Symbol('rxSubscriber') : '@@rxSubscriber_' + /*@__PURE__*/Math.random();
}();
var $$rxSubscriber = (/* unused pure expression or super */ null && (rxSubscriber));

/***/ }),

/***/ 86665:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "W": () => (/* binding */ ArgumentOutOfRangeError)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ArgumentOutOfRangeErrorImpl = /*@__PURE__*/function () {
  function ArgumentOutOfRangeErrorImpl() {
    Error.call(this);
    this.message = 'argument out of range';
    this.name = 'ArgumentOutOfRangeError';
    return this;
  }

  ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);
  return ArgumentOutOfRangeErrorImpl;
}();

var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

/***/ }),

/***/ 46101:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "N": () => (/* binding */ ObjectUnsubscribedError)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ObjectUnsubscribedErrorImpl = /*@__PURE__*/function () {
  function ObjectUnsubscribedErrorImpl() {
    Error.call(this);
    this.message = 'object unsubscribed';
    this.name = 'ObjectUnsubscribedError';
    return this;
  }

  ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);
  return ObjectUnsubscribedErrorImpl;
}();

var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

/***/ }),

/***/ 27242:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "z": () => (/* binding */ hostReportError)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
  setTimeout(function () {
    throw err;
  }, 0);
}

/***/ }),

/***/ 11707:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "y": () => (/* binding */ identity)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
  return x;
}

/***/ }),

/***/ 65330:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "k": () => (/* binding */ isArray)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray = /*@__PURE__*/function () {
  return Array.isArray || function (x) {
    return x && typeof x.length === 'number';
  };
}();

/***/ }),

/***/ 58198:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "z": () => (/* binding */ isArrayLike)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = function isArrayLike(x) {
  return x && typeof x.length === 'number' && typeof x !== 'function';
};

/***/ }),

/***/ 53074:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "J": () => (/* binding */ isDate)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}

/***/ }),

/***/ 89012:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "m": () => (/* binding */ isFunction)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
  return typeof x === 'function';
}

/***/ }),

/***/ 87967:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "k": () => (/* binding */ isNumeric)
/* harmony export */ });
/* harmony import */ var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65330);
/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */

function isNumeric(val) {
  return !(0,_isArray__WEBPACK_IMPORTED_MODULE_0__/* .isArray */ .k)(val) && val - parseFloat(val) + 1 >= 0;
}

/***/ }),

/***/ 62860:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "K": () => (/* binding */ isObject)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
  return x !== null && typeof x === 'object';
}

/***/ }),

/***/ 25858:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "t": () => (/* binding */ isPromise)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
  return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}

/***/ }),

/***/ 8793:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "K": () => (/* binding */ isScheduler)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
  return value && typeof value.schedule === 'function';
}

/***/ }),

/***/ 44992:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ noop)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() {}

/***/ }),

/***/ 23145:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "s": () => (/* binding */ subscribeTo)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToArray.js
var subscribeToArray = __webpack_require__(82051);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/hostReportError.js
var hostReportError = __webpack_require__(27242);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToPromise.js
/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */

var subscribeToPromise = function subscribeToPromise(promise) {
  return function (subscriber) {
    promise.then(function (value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function (err) {
      return subscriber.error(err);
    }).then(null, hostReportError/* hostReportError */.z);
    return subscriber;
  };
};
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/iterator.js
var symbol_iterator = __webpack_require__(71998);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToIterable.js
/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */

var subscribeToIterable = function subscribeToIterable(iterable) {
  return function (subscriber) {
    var iterator = iterable[symbol_iterator/* iterator */.hZ]();

    do {
      var item = void 0;

      try {
        item = iterator.next();
      } catch (err) {
        subscriber.error(err);
        return subscriber;
      }

      if (item.done) {
        subscriber.complete();
        break;
      }

      subscriber.next(item.value);

      if (subscriber.closed) {
        break;
      }
    } while (true);

    if (typeof iterator["return"] === 'function') {
      subscriber.add(function () {
        if (iterator["return"]) {
          iterator["return"]();
        }
      });
    }

    return subscriber;
  };
};
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/symbol/observable.js
var observable = __webpack_require__(30005);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToObservable.js
/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */

var subscribeToObservable = function subscribeToObservable(obj) {
  return function (subscriber) {
    var obs = obj[observable/* observable */.L]();

    if (typeof obs.subscribe !== 'function') {
      throw new TypeError('Provided object does not correctly implement Symbol.observable');
    } else {
      return obs.subscribe(subscriber);
    }
  };
};
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isArrayLike.js
var isArrayLike = __webpack_require__(58198);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isPromise.js
var isPromise = __webpack_require__(25858);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isObject.js
var isObject = __webpack_require__(62860);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js
/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */









var subscribeTo = function subscribeTo(result) {
  if (!!result && typeof result[observable/* observable */.L] === 'function') {
    return subscribeToObservable(result);
  } else if ((0,isArrayLike/* isArrayLike */.z)(result)) {
    return (0,subscribeToArray/* subscribeToArray */.V)(result);
  } else if ((0,isPromise/* isPromise */.t)(result)) {
    return subscribeToPromise(result);
  } else if (!!result && typeof result[symbol_iterator/* iterator */.hZ] === 'function') {
    return subscribeToIterable(result);
  } else {
    var value = (0,isObject/* isObject */.K)(result) ? 'an invalid object' : "'" + result + "'";
    var msg = "You provided " + value + " where a stream was expected." + ' You can provide an Observable, Promise, Array, or Iterable.';
    throw new TypeError(msg);
  }
};

/***/ }),

/***/ 82051:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "V": () => (/* binding */ subscribeToArray)
/* harmony export */ });
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function subscribeToArray(array) {
  return function (subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
      subscriber.next(array[i]);
    }

    subscriber.complete();
  };
};

/***/ }),

/***/ 81173:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "D": () => (/* binding */ subscribeToResult)
});

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(10649);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(50032);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/InnerSubscriber.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */



var InnerSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(InnerSubscriber, _super);

  function InnerSubscriber(parent, outerValue, outerIndex) {
    var _this = _super.call(this) || this;

    _this.parent = parent;
    _this.outerValue = outerValue;
    _this.outerIndex = outerIndex;
    _this.index = 0;
    return _this;
  }

  InnerSubscriber.prototype._next = function (value) {
    this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
  };

  InnerSubscriber.prototype._error = function (error) {
    this.parent.notifyError(error, this);
    this.unsubscribe();
  };

  InnerSubscriber.prototype._complete = function () {
    this.parent.notifyComplete(this);
    this.unsubscribe();
  };

  return InnerSubscriber;
}(Subscriber/* Subscriber */.L);


// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeTo.js + 3 modules
var subscribeTo = __webpack_require__(23145);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(30365);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js
/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */



function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
  if (innerSubscriber === void 0) {
    innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
  }

  if (innerSubscriber.closed) {
    return undefined;
  }

  if (result instanceof Observable/* Observable */.y) {
    return result.subscribe(innerSubscriber);
  }

  return (0,subscribeTo/* subscribeTo */.s)(result)(innerSubscriber);
}

/***/ }),

/***/ 26104:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var _f, g, h, k;

if ("object" === typeof performance && "function" === typeof performance.now) {
  var l = performance;

  exports.unstable_now = function () {
    return l.now();
  };
} else {
  var p = Date,
      q = p.now();

  exports.unstable_now = function () {
    return p.now() - q;
  };
}

if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
  var t = null,
      u = null,
      w = function w() {
    if (null !== t) try {
      var a = exports.unstable_now();
      t(!0, a);
      t = null;
    } catch (b) {
      throw setTimeout(w, 0), b;
    }
  };

  _f = function f(a) {
    null !== t ? setTimeout(_f, 0, a) : (t = a, setTimeout(w, 0));
  };

  g = function g(a, b) {
    u = setTimeout(a, b);
  };

  h = function h() {
    clearTimeout(u);
  };

  exports.unstable_shouldYield = function () {
    return !1;
  };

  k = exports.unstable_forceFrameRate = function () {};
} else {
  var x = window.setTimeout,
      y = window.clearTimeout;

  if ("undefined" !== typeof console) {
    var z = window.cancelAnimationFrame;
    "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    "function" !== typeof z && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
  }

  var A = !1,
      B = null,
      C = -1,
      D = 5,
      E = 0;

  exports.unstable_shouldYield = function () {
    return exports.unstable_now() >= E;
  };

  k = function k() {};

  exports.unstable_forceFrameRate = function (a) {
    0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D = 0 < a ? Math.floor(1E3 / a) : 5;
  };

  var F = new MessageChannel(),
      G = F.port2;

  F.port1.onmessage = function () {
    if (null !== B) {
      var a = exports.unstable_now();
      E = a + D;

      try {
        B(!0, a) ? G.postMessage(null) : (A = !1, B = null);
      } catch (b) {
        throw G.postMessage(null), b;
      }
    } else A = !1;
  };

  _f = function _f(a) {
    B = a;
    A || (A = !0, G.postMessage(null));
  };

  g = function g(a, b) {
    C = x(function () {
      a(exports.unstable_now());
    }, b);
  };

  h = function h() {
    y(C);
    C = -1;
  };
}

function H(a, b) {
  var c = a.length;
  a.push(b);

  a: for (;;) {
    var d = c - 1 >>> 1,
        e = a[d];
    if (void 0 !== e && 0 < I(e, b)) a[d] = b, a[c] = e, c = d;else break a;
  }
}

function J(a) {
  a = a[0];
  return void 0 === a ? null : a;
}

function K(a) {
  var b = a[0];

  if (void 0 !== b) {
    var c = a.pop();

    if (c !== b) {
      a[0] = c;

      a: for (var d = 0, e = a.length; d < e;) {
        var m = 2 * (d + 1) - 1,
            n = a[m],
            v = m + 1,
            r = a[v];
        if (void 0 !== n && 0 > I(n, c)) void 0 !== r && 0 > I(r, n) ? (a[d] = r, a[v] = c, d = v) : (a[d] = n, a[m] = c, d = m);else if (void 0 !== r && 0 > I(r, c)) a[d] = r, a[v] = c, d = v;else break a;
      }
    }

    return b;
  }

  return null;
}

function I(a, b) {
  var c = a.sortIndex - b.sortIndex;
  return 0 !== c ? c : a.id - b.id;
}

var L = [],
    M = [],
    N = 1,
    O = null,
    P = 3,
    Q = !1,
    R = !1,
    S = !1;

function T(a) {
  for (var b = J(M); null !== b;) {
    if (null === b.callback) K(M);else if (b.startTime <= a) K(M), b.sortIndex = b.expirationTime, H(L, b);else break;
    b = J(M);
  }
}

function U(a) {
  S = !1;
  T(a);
  if (!R) if (null !== J(L)) R = !0, _f(V);else {
    var b = J(M);
    null !== b && g(U, b.startTime - a);
  }
}

function V(a, b) {
  R = !1;
  S && (S = !1, h());
  Q = !0;
  var c = P;

  try {
    T(b);

    for (O = J(L); null !== O && (!(O.expirationTime > b) || a && !exports.unstable_shouldYield());) {
      var d = O.callback;

      if ("function" === typeof d) {
        O.callback = null;
        P = O.priorityLevel;
        var e = d(O.expirationTime <= b);
        b = exports.unstable_now();
        "function" === typeof e ? O.callback = e : O === J(L) && K(L);
        T(b);
      } else K(L);

      O = J(L);
    }

    if (null !== O) var m = !0;else {
      var n = J(M);
      null !== n && g(U, n.startTime - b);
      m = !1;
    }
    return m;
  } finally {
    O = null, P = c, Q = !1;
  }
}

var W = k;
exports.unstable_IdlePriority = 5;
exports.unstable_ImmediatePriority = 1;
exports.unstable_LowPriority = 4;
exports.unstable_NormalPriority = 3;
exports.unstable_Profiling = null;
exports.unstable_UserBlockingPriority = 2;

exports.unstable_cancelCallback = function (a) {
  a.callback = null;
};

exports.unstable_continueExecution = function () {
  R || Q || (R = !0, _f(V));
};

exports.unstable_getCurrentPriorityLevel = function () {
  return P;
};

exports.unstable_getFirstCallbackNode = function () {
  return J(L);
};

exports.unstable_next = function (a) {
  switch (P) {
    case 1:
    case 2:
    case 3:
      var b = 3;
      break;

    default:
      b = P;
  }

  var c = P;
  P = b;

  try {
    return a();
  } finally {
    P = c;
  }
};

exports.unstable_pauseExecution = function () {};

exports.unstable_requestPaint = W;

exports.unstable_runWithPriority = function (a, b) {
  switch (a) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      break;

    default:
      a = 3;
  }

  var c = P;
  P = a;

  try {
    return b();
  } finally {
    P = c;
  }
};

exports.unstable_scheduleCallback = function (a, b, c) {
  var d = exports.unstable_now();
  "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;

  switch (a) {
    case 1:
      var e = -1;
      break;

    case 2:
      e = 250;
      break;

    case 5:
      e = 1073741823;
      break;

    case 4:
      e = 1E4;
      break;

    default:
      e = 5E3;
  }

  e = c + e;
  a = {
    id: N++,
    callback: b,
    priorityLevel: a,
    startTime: c,
    expirationTime: e,
    sortIndex: -1
  };
  c > d ? (a.sortIndex = c, H(M, a), null === J(L) && a === J(M) && (S ? h() : S = !0, g(U, c - d))) : (a.sortIndex = e, H(L, a), R || Q || (R = !0, _f(V)));
  return a;
};

exports.unstable_wrapCallback = function (a) {
  var b = P;
  return function () {
    var c = P;
    P = b;

    try {
      return a.apply(this, arguments);
    } finally {
      P = c;
    }
  };
};

/***/ }),

/***/ 79409:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(26104);
} else {}

/***/ }),

/***/ 10649:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ZT": () => (/* binding */ __extends)
/* harmony export */ });
/* unused harmony exports __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __createBinding, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

/* global Reflect, Promise */
var _extendStatics = function extendStatics(d, b) {
  _extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (b.hasOwnProperty(p)) d[p] = b[p];
    }
  };

  return _extendStatics(d, b);
};

function __extends(d, b) {
  _extendStatics(d, b);

  function __() {
    this.constructor = d;
  }

  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var _assign = function __assign() {
  _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return _assign.apply(this, arguments);
};


function __rest(s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  }
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = {
    label: 0,
    sent: function sent() {
      if (t[0] & 1) throw t[1];
      return t[1];
    },
    trys: [],
    ops: []
  },
      f,
      y,
      t,
      g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;

  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }

  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");

    while (_) {
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    }

    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
}
function __createBinding(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
}
function __exportStar(m, exports) {
  for (var p in m) {
    if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function next() {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
      ar.push(r.value);
    }
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) {
    ar = ar.concat(__read(arguments[i]));
  }

  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
    s += arguments[i].length;
  }

  for (var r = Array(s), k = 0, i = 0; i < il; i++) {
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
      r[k] = a[j];
    }
  }

  return r;
}
;
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i;

  function verb(n) {
    if (g[n]) i[n] = function (v) {
      return new Promise(function (a, b) {
        q.push([n, v, a, b]) > 1 || resume(n, v);
      });
    };
  }

  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }

  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }

  function fulfill(value) {
    resume("next", value);
  }

  function reject(value) {
    resume("throw", value);
  }

  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function () {
    return this;
  }, i;

  function verb(n, f) {
    i[n] = o[n] ? function (v) {
      return (p = !p) ? {
        value: __await(o[n](v)),
        done: n === "return"
      } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator],
      i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
    return this;
  }, i);

  function verb(n) {
    i[n] = o[n] && function (v) {
      return new Promise(function (resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }

  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function (v) {
      resolve({
        value: v,
        done: d
      });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", {
      value: raw
    });
  } else {
    cooked.raw = raw;
  }

  return cooked;
}
;
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  }
  result["default"] = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }

  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }

  privateMap.set(receiver, value);
  return value;
}

/***/ }),

/***/ 46700:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./af": 68704,
	"./af.js": 68704,
	"./ar": 27156,
	"./ar-dz": 42642,
	"./ar-dz.js": 42642,
	"./ar-kw": 20640,
	"./ar-kw.js": 20640,
	"./ar-ly": 82641,
	"./ar-ly.js": 82641,
	"./ar-ma": 52750,
	"./ar-ma.js": 52750,
	"./ar-sa": 43697,
	"./ar-sa.js": 43697,
	"./ar-tn": 60667,
	"./ar-tn.js": 60667,
	"./ar.js": 27156,
	"./az": 33899,
	"./az.js": 33899,
	"./be": 55777,
	"./be.js": 55777,
	"./bg": 26429,
	"./bg.js": 26429,
	"./bm": 18337,
	"./bm.js": 18337,
	"./bn": 91379,
	"./bn-bd": 36843,
	"./bn-bd.js": 36843,
	"./bn.js": 91379,
	"./bo": 71798,
	"./bo.js": 71798,
	"./br": 50706,
	"./br.js": 50706,
	"./bs": 60158,
	"./bs.js": 60158,
	"./ca": 10191,
	"./ca.js": 10191,
	"./cs": 41958,
	"./cs.js": 41958,
	"./cv": 54139,
	"./cv.js": 54139,
	"./cy": 99673,
	"./cy.js": 99673,
	"./da": 48845,
	"./da.js": 48845,
	"./de": 50940,
	"./de-at": 1477,
	"./de-at.js": 1477,
	"./de-ch": 64025,
	"./de-ch.js": 64025,
	"./de.js": 50940,
	"./dv": 72684,
	"./dv.js": 72684,
	"./el": 1672,
	"./el.js": 1672,
	"./en-au": 62979,
	"./en-au.js": 62979,
	"./en-ca": 67149,
	"./en-ca.js": 67149,
	"./en-gb": 35595,
	"./en-gb.js": 35595,
	"./en-ie": 62994,
	"./en-ie.js": 62994,
	"./en-il": 86866,
	"./en-il.js": 86866,
	"./en-in": 82260,
	"./en-in.js": 82260,
	"./en-nz": 59993,
	"./en-nz.js": 59993,
	"./en-sg": 94434,
	"./en-sg.js": 94434,
	"./eo": 40996,
	"./eo.js": 40996,
	"./es": 59314,
	"./es-do": 99749,
	"./es-do.js": 99749,
	"./es-mx": 29604,
	"./es-mx.js": 29604,
	"./es-us": 57034,
	"./es-us.js": 57034,
	"./es.js": 59314,
	"./et": 75366,
	"./et.js": 75366,
	"./eu": 95121,
	"./eu.js": 95121,
	"./fa": 55851,
	"./fa.js": 55851,
	"./fi": 89785,
	"./fi.js": 89785,
	"./fil": 62830,
	"./fil.js": 62830,
	"./fo": 74933,
	"./fo.js": 74933,
	"./fr": 92051,
	"./fr-ca": 36979,
	"./fr-ca.js": 36979,
	"./fr-ch": 62466,
	"./fr-ch.js": 62466,
	"./fr.js": 92051,
	"./fy": 57389,
	"./fy.js": 57389,
	"./ga": 44060,
	"./ga.js": 44060,
	"./gd": 44640,
	"./gd.js": 44640,
	"./gl": 85090,
	"./gl.js": 85090,
	"./gom-deva": 22927,
	"./gom-deva.js": 22927,
	"./gom-latn": 73602,
	"./gom-latn.js": 73602,
	"./gu": 20486,
	"./gu.js": 20486,
	"./he": 19023,
	"./he.js": 19023,
	"./hi": 79435,
	"./hi.js": 79435,
	"./hr": 96345,
	"./hr.js": 96345,
	"./hu": 47492,
	"./hu.js": 47492,
	"./hy-am": 24585,
	"./hy-am.js": 24585,
	"./id": 96701,
	"./id.js": 96701,
	"./is": 65276,
	"./is.js": 65276,
	"./it": 23602,
	"./it-ch": 75062,
	"./it-ch.js": 75062,
	"./it.js": 23602,
	"./ja": 90987,
	"./ja.js": 90987,
	"./jv": 35485,
	"./jv.js": 35485,
	"./ka": 13048,
	"./ka.js": 13048,
	"./kk": 12664,
	"./kk.js": 12664,
	"./km": 12681,
	"./km.js": 12681,
	"./kn": 45263,
	"./kn.js": 45263,
	"./ko": 36023,
	"./ko.js": 36023,
	"./ku": 34839,
	"./ku.js": 34839,
	"./ky": 77750,
	"./ky.js": 77750,
	"./lb": 77223,
	"./lb.js": 77223,
	"./lo": 81906,
	"./lo.js": 81906,
	"./lt": 64837,
	"./lt.js": 64837,
	"./lv": 18656,
	"./lv.js": 18656,
	"./me": 48331,
	"./me.js": 48331,
	"./mi": 97645,
	"./mi.js": 97645,
	"./mk": 2963,
	"./mk.js": 2963,
	"./ml": 44744,
	"./ml.js": 44744,
	"./mn": 3296,
	"./mn.js": 3296,
	"./mr": 62448,
	"./mr.js": 62448,
	"./ms": 406,
	"./ms-my": 23814,
	"./ms-my.js": 23814,
	"./ms.js": 406,
	"./mt": 28957,
	"./mt.js": 28957,
	"./my": 18940,
	"./my.js": 18940,
	"./nb": 37127,
	"./nb.js": 37127,
	"./ne": 43285,
	"./ne.js": 43285,
	"./nl": 75835,
	"./nl-be": 77243,
	"./nl-be.js": 77243,
	"./nl.js": 75835,
	"./nn": 32802,
	"./nn.js": 32802,
	"./oc-lnc": 87282,
	"./oc-lnc.js": 87282,
	"./pa-in": 53424,
	"./pa-in.js": 53424,
	"./pl": 83696,
	"./pl.js": 83696,
	"./pt": 61551,
	"./pt-br": 61657,
	"./pt-br.js": 61657,
	"./pt.js": 61551,
	"./ro": 29199,
	"./ro.js": 29199,
	"./ru": 88217,
	"./ru.js": 88217,
	"./sd": 14817,
	"./sd.js": 14817,
	"./se": 91403,
	"./se.js": 91403,
	"./si": 18446,
	"./si.js": 18446,
	"./sk": 21098,
	"./sk.js": 21098,
	"./sl": 48805,
	"./sl.js": 48805,
	"./sq": 47718,
	"./sq.js": 47718,
	"./sr": 52003,
	"./sr-cyrl": 86925,
	"./sr-cyrl.js": 86925,
	"./sr.js": 52003,
	"./ss": 83707,
	"./ss.js": 83707,
	"./sv": 80643,
	"./sv.js": 80643,
	"./sw": 46250,
	"./sw.js": 46250,
	"./ta": 52550,
	"./ta.js": 52550,
	"./te": 5558,
	"./te.js": 5558,
	"./tet": 63503,
	"./tet.js": 63503,
	"./tg": 87711,
	"./tg.js": 87711,
	"./th": 95626,
	"./th.js": 95626,
	"./tk": 60727,
	"./tk.js": 60727,
	"./tl-ph": 97568,
	"./tl-ph.js": 97568,
	"./tlh": 71682,
	"./tlh.js": 71682,
	"./tr": 53538,
	"./tr.js": 53538,
	"./tzl": 83614,
	"./tzl.js": 83614,
	"./tzm": 77706,
	"./tzm-latn": 77828,
	"./tzm-latn.js": 77828,
	"./tzm.js": 77706,
	"./ug-cn": 86550,
	"./ug-cn.js": 86550,
	"./uk": 75509,
	"./uk.js": 75509,
	"./ur": 912,
	"./ur.js": 912,
	"./uz": 23725,
	"./uz-latn": 67537,
	"./uz-latn.js": 67537,
	"./uz.js": 23725,
	"./vi": 53285,
	"./vi.js": 53285,
	"./x-pseudo": 69201,
	"./x-pseudo.js": 69201,
	"./yo": 90392,
	"./yo.js": 90392,
	"./zh-cn": 98914,
	"./zh-cn.js": 98914,
	"./zh-hk": 8229,
	"./zh-hk.js": 8229,
	"./zh-mo": 59735,
	"./zh-mo.js": 59735,
	"./zh-tw": 55786,
	"./zh-tw.js": 55786
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 46700;

/***/ }),

/***/ 18909:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DQ": () => (/* binding */ HTMLElement_),
/* harmony export */   "JJ": () => (/* binding */ MediaSource_),
/* harmony export */   "cX": () => (/* binding */ READY_STATES),
/* harmony export */   "w": () => (/* binding */ VTTCue_)
/* harmony export */ });
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32825);
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68767);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/**
 * Shortcut to the global browser object `window`. Set to an empty object in
 * non-browser platforms
 */
const win = _is_node__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z ? {} :
    window;
/** Browser implementation of an HTMLElement. */
const HTMLElement_ = win.HTMLElement;
/** TextTrack cue constructor, as implemented by the browser. */
const VTTCue_ = !(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(win.VTTCue) ? win.VTTCue :
    win.TextTrackCue;
/** MediaSource implementation, including vendored implementations. */
const MediaSource_ = !(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(win.MediaSource) ? win.MediaSource :
    !(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(win.MozMediaSource) ? win.MozMediaSource :
        !(0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(win.WebKitMediaSource) ? win.WebKitMediaSource :
            win.MSMediaSource;
/* eslint-enable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/** List an HTMLMediaElement's possible values for its readyState property. */
const READY_STATES = { HAVE_NOTHING: 0,
    HAVE_METADATA: 1,
    HAVE_CURRENT_DATA: 2,
    HAVE_FUTURE_DATA: 3,
    HAVE_ENOUGH_DATA: 4 };



/***/ }),

/***/ 8886:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kD": () => (/* binding */ isEdgeChromium),
/* harmony export */   "fq": () => (/* binding */ isIE11),
/* harmony export */   "YM": () => (/* binding */ isIEOrEdge),
/* harmony export */   "vU": () => (/* binding */ isFirefox),
/* harmony export */   "G6": () => (/* binding */ isSafari),
/* harmony export */   "SB": () => (/* binding */ isSafariMobile),
/* harmony export */   "op": () => (/* binding */ isSamsungBrowser),
/* harmony export */   "yS": () => (/* binding */ isTizen)
/* harmony export */ });
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68767);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var _a;

// true on IE11
// false on Edge and other IEs/browsers.
/* eslint-disable @typescript-eslint/strict-boolean-expressions */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
const isIE11 = !_is_node__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z &&
    !!window.MSInputMethodContext &&
    !!document.documentMode;
/* eslint-enable @typescript-eslint/strict-boolean-expressions */
/* eslint-enable @typescript-eslint/no-unsafe-member-access */
// true for IE / Edge
const isIEOrEdge = _is_node__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z ?
    false :
    navigator.appName === "Microsoft Internet Explorer" ||
        navigator.appName === "Netscape" &&
            /(Trident|Edge)\//.test(navigator.userAgent);
const isEdgeChromium = !_is_node__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z &&
    navigator.userAgent.toLowerCase().indexOf("edg/") !== -1;
const isFirefox = !_is_node__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z &&
    navigator.userAgent.toLowerCase().indexOf("firefox") !== -1;
const isSamsungBrowser = !_is_node__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z &&
    /SamsungBrowser/.test(navigator.userAgent);
const isTizen = !_is_node__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z &&
    /Tizen/.test(navigator.userAgent);
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-call */
const isSafari = !_is_node__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z && (Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") >= 0 ||
    ((_a = window.safari) === null || _a === void 0 ? void 0 : _a.pushNotification.toString()) ===
        "[object SafariRemoteNotification]");
/* eslint-enable @typescript-eslint/no-unsafe-member-access */
/* eslint-enable @typescript-eslint/no-unsafe-call */
const isSafariMobile = !_is_node__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z &&
    typeof navigator.platform === "string" &&
    /iPad|iPhone|iPod/.test(navigator.platform);



/***/ }),

/***/ 38815:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ clearElementSrc)
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6077);
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8886);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Clear element's src attribute.
 * @param {HTMLMediaElement} element
 */
function clearElementSrc(element) {
    // On Firefox, we also have to make sure the textTracks elements are both
    // disabled and removed from the DOM.
    // If we do not do that, we may be left with displayed text tracks on the
    // screen
    if (_browser_detection__WEBPACK_IMPORTED_MODULE_0__/* .isFirefox */ .vU) {
        const { textTracks } = element;
        for (let i = 0; i < textTracks.length; i++) {
            textTracks[i].mode = "disabled";
        }
        if (element.hasChildNodes()) {
            const { childNodes } = element;
            for (let j = childNodes.length - 1; j >= 0; j--) {
                if (childNodes[j].nodeName === "track") {
                    try {
                        element.removeChild(childNodes[j]);
                    }
                    catch (err) {
                        _log__WEBPACK_IMPORTED_MODULE_1__/* .default.warn */ .Z.warn("Compat: Could not remove text track child from element.");
                    }
                }
            }
        }
    }
    element.src = "";
    // On IE11, element.src = "" is not sufficient as it
    // does not clear properly the current MediaKey Session.
    // Microsoft recommended to use element.removeAttr("src").
    element.removeAttribute("src");
}


/***/ }),

/***/ 39013:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "N": () => (/* binding */ requestMediaKeySystemAccess),
  "Y": () => (/* binding */ setMediaKeys)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/throwError.js
var throwError = __webpack_require__(55022);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(24251);
// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(3590);
// EXTERNAL MODULE: ./src/utils/cast_to_observable.ts
var cast_to_observable = __webpack_require__(42121);
// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(8886);
// EXTERNAL MODULE: ./src/compat/is_node.ts
var is_node = __webpack_require__(68767);
// EXTERNAL MODULE: ./src/compat/should_favour_custom_safari_EME.ts
var should_favour_custom_safari_EME = __webpack_require__(40213);
// EXTERNAL MODULE: ./src/utils/promise.ts
var promise = __webpack_require__(5068);
;// CONCATENATED MODULE: ./src/compat/eme/custom_key_system_access.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Simple implementation of the MediaKeySystemAccess EME API.
 *
 * All needed arguments are given to the constructor
 * @class CustomMediaKeySystemAccess
 */
class CustomMediaKeySystemAccess {
    /**
     * @param {string} _keyType - type of key system (e.g. "widevine" or
     * "com.widevine.alpha").
     * @param {Object} _mediaKeys - MediaKeys implementation
     * @param {Object} _configuration - Configuration accepted for this
     * MediaKeySystemAccess.
     */
    constructor(_keyType, _mediaKeys, _configuration) {
        this._keyType = _keyType;
        this._mediaKeys = _mediaKeys;
        this._configuration = _configuration;
    }
    /**
     * @returns {string} - current key system type (e.g. "widevine" or
     * "com.widevine.alpha").
     */
    get keySystem() {
        return this._keyType;
    }
    /**
     * @returns {Promise.<Object>} - Promise wrapping the MediaKeys for this
     * MediaKeySystemAccess. Never rejects.
     */
    createMediaKeys() {
        return new promise/* default */.Z((res) => res(this._mediaKeys));
    }
    /**
     * @returns {Object} - Configuration accepted for this MediaKeySystemAccess.
     */
    getConfiguration() {
        return this._configuration;
    }
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(81044);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(10125);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(28305);
// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(61603);
// EXTERNAL MODULE: ./src/compat/event_listeners.ts + 4 modules
var event_listeners = __webpack_require__(90315);
;// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/ms_media_keys_constructor.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let MSMediaKeysConstructor;
if (!is_node/* default */.Z) {
    /* eslint-disable @typescript-eslint/no-unsafe-assignment */
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    const { MSMediaKeys } = window;
    if (MSMediaKeys !== undefined &&
        MSMediaKeys.prototype !== undefined &&
        typeof MSMediaKeys.isTypeSupported === "function" &&
        typeof MSMediaKeys.prototype.createSession === "function") {
        MSMediaKeysConstructor = MSMediaKeys;
    }
    /* eslint-enable @typescript-eslint/no-unsafe-assignment */
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}


;// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/ie11_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






class IE11MediaKeySession extends event_emitter/* default */.Z {
    constructor(mk) {
        super();
        this.expiration = NaN;
        this.keyStatuses = new Map();
        this._mk = mk;
        this._closeSession$ = new Subject/* Subject */.xQ();
        this.closed = new promise/* default */.Z((resolve) => {
            this._closeSession$.subscribe(resolve);
        });
        this.update = (license) => {
            return new promise/* default */.Z((resolve, reject) => {
                if (this._ss === undefined) {
                    return reject("MediaKeySession not set.");
                }
                try {
                    /* eslint-disable @typescript-eslint/no-unsafe-call */
                    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
                    resolve(this._ss.update(license, /* sessionId */ ""));
                    /* eslint-enable @typescript-eslint/no-unsafe-call */
                    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
                }
                catch (err) {
                    reject(err);
                }
            });
        };
    }
    generateRequest(_initDataType, initData) {
        return new promise/* default */.Z((resolve) => {
            /* eslint-disable @typescript-eslint/no-unsafe-call */
            /* eslint-disable @typescript-eslint/no-unsafe-member-access */
            this._ss = this._mk.createSession("video/mp4", initData);
            /* eslint-enable @typescript-eslint/no-unsafe-call */
            /* eslint-enable @typescript-eslint/no-unsafe-member-access */
            (0,merge/* merge */.T)(event_listeners.onKeyMessage$(this._ss), event_listeners.onKeyAdded$(this._ss), event_listeners.onKeyError$(this._ss)).pipe((0,takeUntil/* takeUntil */.R)(this._closeSession$))
                .subscribe((evt) => this.trigger(evt.type, evt));
            resolve();
        });
    }
    close() {
        return new promise/* default */.Z((resolve) => {
            if (this._ss != null) {
                /* eslint-disable @typescript-eslint/no-floating-promises */
                this._ss.close();
                /* eslint-enable @typescript-eslint/no-floating-promises */
                this._ss = undefined;
            }
            this._closeSession$.next();
            this._closeSession$.complete();
            resolve();
        });
    }
    load() {
        return promise/* default.resolve */.Z.resolve(false);
    }
    remove() {
        return promise/* default.resolve */.Z.resolve();
    }
    get sessionId() {
        var _a, _b;
        return (_b = (_a = this._ss) === null || _a === void 0 ? void 0 : _a.sessionId) !== null && _b !== void 0 ? _b : "";
    }
}
class IE11CustomMediaKeys {
    constructor(keyType) {
        if (MSMediaKeysConstructor === undefined) {
            throw new Error("No MSMediaKeys API.");
        }
        this._mediaKeys = new MSMediaKeysConstructor(keyType);
    }
    _setVideo(videoElement) {
        this._videoElement = videoElement;
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        /* eslint-disable @typescript-eslint/no-unsafe-call */
        if (this._videoElement.msSetMediaKeys !== undefined) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return this._videoElement.msSetMediaKeys(this._mediaKeys);
        }
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        /* eslint-enable @typescript-eslint/no-unsafe-call */
    }
    createSession( /* sessionType */) {
        if (this._videoElement === undefined || this._mediaKeys === undefined) {
            throw new Error("Video not attached to the MediaKeys");
        }
        return new IE11MediaKeySession(this._mediaKeys);
    }
    setServerCertificate() {
        throw new Error("Server certificate is not implemented in your browser");
    }
}
function getIE11MediaKeysCallbacks() {
    const isTypeSupported = (keySystem, type) => {
        if (MSMediaKeysConstructor === undefined) {
            throw new Error("No MSMediaKeys API.");
        }
        if (type !== undefined) {
            return MSMediaKeysConstructor.isTypeSupported(keySystem, type);
        }
        return MSMediaKeysConstructor.isTypeSupported(keySystem);
    };
    const createCustomMediaKeys = (keyType) => new IE11CustomMediaKeys(keyType);
    const setMediaKeys = (elt, mediaKeys) => {
        if (mediaKeys === null) {
            // msSetMediaKeys only accepts native MSMediaKeys as argument.
            // Calling it with null or undefined will raise an exception.
            // There is no way to unset the mediakeys in that case, so return here.
            return;
        }
        if (!(mediaKeys instanceof IE11CustomMediaKeys)) {
            throw new Error("Custom setMediaKeys is supposed to be called " +
                "with IE11 custom MediaKeys.");
        }
        return mediaKeys._setVideo(elt);
    };
    return {
        isTypeSupported,
        createCustomMediaKeys,
        setMediaKeys,
    };
}


;// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/moz_media_keys_constructor.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let MozMediaKeysConstructor;
if (!is_node/* default */.Z) {
    /* eslint-disable @typescript-eslint/no-unsafe-assignment */
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    const { MozMediaKeys } = window;
    if (MozMediaKeys !== undefined &&
        MozMediaKeys.prototype !== undefined &&
        typeof MozMediaKeys.isTypeSupported === "function" &&
        typeof MozMediaKeys.prototype.createSession === "function") {
        MozMediaKeysConstructor = MozMediaKeys;
    }
    /* eslint-enable @typescript-eslint/no-unsafe-assignment */
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}

function getMozMediaKeysCallbacks() {
    const isTypeSupported = (keySystem, type) => {
        if (MozMediaKeysConstructor === undefined) {
            throw new Error("No MozMediaKeys API.");
        }
        if (type !== undefined) {
            return MozMediaKeysConstructor.isTypeSupported(keySystem, type);
        }
        return MozMediaKeysConstructor.isTypeSupported(keySystem);
    };
    const createCustomMediaKeys = (keyType) => {
        if (MozMediaKeysConstructor === undefined) {
            throw new Error("No MozMediaKeys API.");
        }
        return new MozMediaKeysConstructor(keyType);
    };
    const setMediaKeys = (elt, mediaKeys) => {
        /* eslint-disable @typescript-eslint/no-unsafe-return */
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        /* eslint-disable @typescript-eslint/no-unsafe-call */
        if (elt.mozSetMediaKeys === undefined ||
            typeof elt.mozSetMediaKeys !== "function") {
            throw new Error("Can't set video on MozMediaKeys.");
        }
        return elt.mozSetMediaKeys(mediaKeys);
        /* eslint-enable @typescript-eslint/no-unsafe-return */
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        /* eslint-enable @typescript-eslint/no-unsafe-call */
    };
    return {
        isTypeSupported,
        createCustomMediaKeys,
        setMediaKeys,
    };
}

// EXTERNAL MODULE: ./src/utils/base64.ts
var base64 = __webpack_require__(91282);
// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(26332);
;// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/old_webkit_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Returns true if the given media element has old webkit methods
 * corresponding to the IOldWebkitHTMLMediaElement interface.
 * @param {HTMLMediaElement} element
 * @returns {Boolean}
 */
function isOldWebkitMediaElement(element) {
    return typeof element
        .webkitGenerateKeyRequest === "function";
}
class OldWebkitMediaKeySession extends event_emitter/* default */.Z {
    constructor(mediaElement, keySystem) {
        super();
        this._closeSession$ = new Subject/* Subject */.xQ();
        this._vid = mediaElement;
        this._key = keySystem;
        this.sessionId = "";
        this.closed = new promise/* default */.Z((resolve) => {
            this._closeSession$.subscribe(resolve);
        });
        this.keyStatuses = new Map();
        this.expiration = NaN;
        (0,merge/* merge */.T)(event_listeners.onKeyMessage$(mediaElement), event_listeners.onKeyAdded$(mediaElement), event_listeners.onKeyError$(mediaElement))
            .pipe((0,takeUntil/* takeUntil */.R)(this._closeSession$))
            .subscribe((evt) => this.trigger(evt.type, evt));
        this.update = (license) => {
            return new promise/* default */.Z((resolve, reject) => {
                try {
                    if (this._key.indexOf("clearkey") >= 0) {
                        const licenseTypedArray = license instanceof ArrayBuffer ? new Uint8Array(license) :
                            license;
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                        const json = JSON.parse((0,string_parsing/* utf8ToStr */.uR)(licenseTypedArray));
                        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
                        const key = (0,base64/* base64ToBytes */.K)(json.keys[0].k);
                        const kid = (0,base64/* base64ToBytes */.K)(json.keys[0].kid);
                        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
                        resolve(this._vid.webkitAddKey(this._key, key, kid, /* sessionId */ ""));
                    }
                    else {
                        resolve(this._vid.webkitAddKey(this._key, license, null, /* sessionId */ ""));
                    }
                }
                catch (err) {
                    reject(err);
                }
            });
        };
    }
    generateRequest(_initDataType, initData) {
        return new promise/* default */.Z((resolve) => {
            this._vid.webkitGenerateKeyRequest(this._key, initData);
            resolve();
        });
    }
    close() {
        return new promise/* default */.Z((resolve) => {
            this._closeSession$.next();
            this._closeSession$.complete();
            resolve();
        });
    }
    load() {
        return promise/* default.resolve */.Z.resolve(false);
    }
    remove() {
        return promise/* default.resolve */.Z.resolve();
    }
}
class OldWebKitCustomMediaKeys {
    constructor(keySystem) {
        this._keySystem = keySystem;
    }
    _setVideo(videoElement) {
        if (!isOldWebkitMediaElement(videoElement)) {
            throw new Error("Video not attached to the MediaKeys");
        }
        this._videoElement = videoElement;
    }
    createSession( /* sessionType */) {
        if (this._videoElement == null) {
            throw new Error("Video not attached to the MediaKeys");
        }
        return new OldWebkitMediaKeySession(this._videoElement, this._keySystem);
    }
    setServerCertificate() {
        throw new Error("Server certificate is not implemented in your browser");
    }
}
function getOldWebKitMediaKeysCallbacks() {
    const isTypeSupported = function (keyType) {
        // get any <video> element from the DOM or create one
        // and try the `canPlayType` method
        let videoElement = document.querySelector("video");
        if (videoElement == null) {
            videoElement = document.createElement("video");
        }
        /* eslint-disable @typescript-eslint/unbound-method */
        if (videoElement != null && typeof videoElement.canPlayType === "function") {
            /* eslint-enable @typescript-eslint/unbound-method */
            /* eslint-disable @typescript-eslint/no-unsafe-member-access */
            /* eslint-disable @typescript-eslint/strict-boolean-expressions */
            /* eslint-disable @typescript-eslint/no-unsafe-call */
            return !!videoElement.canPlayType("video/mp4", keyType);
            /* eslint-enable @typescript-eslint/no-unsafe-member-access */
            /* eslint-enable @typescript-eslint/strict-boolean-expressions */
            /* eslint-enable @typescript-eslint/no-unsafe-call */
        }
        else {
            return false;
        }
    };
    const createCustomMediaKeys = (keyType) => new OldWebKitCustomMediaKeys(keyType);
    const setMediaKeys = (elt, mediaKeys) => {
        if (mediaKeys === null) {
            return;
        }
        if (!(mediaKeys instanceof OldWebKitCustomMediaKeys)) {
            throw new Error("Custom setMediaKeys is supposed to be called " +
                "with old webkit custom MediaKeys.");
        }
        return mediaKeys._setVideo(elt);
    };
    return {
        isTypeSupported,
        createCustomMediaKeys,
        setMediaKeys,
    };
}

// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(97308);
;// CONCATENATED MODULE: ./src/compat/eme/get_webkit_fairplay_initdata.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Create formatted fairplay initdata for WebKit createSession.
 * Layout is :
 * [initData][4 byte: idLength][idLength byte: id]
 * [4 byte:certLength][certLength byte: cert]
 * @param {Uint8Array} initData
 * @param {Uint8Array} serverCertificate
 * @returns {Uint8Array}
 */
function getWebKitFairPlayInitData(initDataBytes, serverCertificateBytes) {
    const initData = initDataBytes instanceof Uint8Array ? initDataBytes :
        new Uint8Array(initDataBytes);
    const serverCertificate = serverCertificateBytes instanceof Uint8Array ?
        serverCertificateBytes :
        new Uint8Array(serverCertificateBytes);
    const length = (0,byte_parsing/* le4toi */.dN)(initData, 0);
    if (length + 4 !== initData.length) {
        throw new Error("Unsupported WebKit initData.");
    }
    const initDataUri = (0,string_parsing/* utf16LEToStr */.wV)(initData);
    const skdIndexInInitData = initDataUri.indexOf("skd://");
    const contentIdStr = skdIndexInInitData > -1 ?
        initDataUri.substring(skdIndexInInitData + 6) :
        initDataUri;
    const id = (0,string_parsing/* strToUtf16LE */.TZ)(contentIdStr);
    let offset = 0;
    const res = new Uint8Array(initData.byteLength
        /* id length */ + 4 + id.byteLength
        /* certificate length */ + 4 + serverCertificate.byteLength);
    res.set(initData);
    offset += initData.length;
    res.set((0,byte_parsing/* itole4 */.O_)(id.byteLength), offset);
    offset += 4;
    res.set(id, offset);
    offset += id.byteLength;
    res.set((0,byte_parsing/* itole4 */.O_)(serverCertificate.byteLength), offset);
    offset += 4;
    res.set(serverCertificate, offset);
    return res;
}

// EXTERNAL MODULE: ./src/compat/eme/custom_media_keys/webkit_media_keys_constructor.ts
var webkit_media_keys_constructor = __webpack_require__(36184);
;// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/webkit_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Check if keyType is for fairplay DRM
 * @param {string} keyType
 * @returns {boolean}
 */
function isFairplayKeyType(keyType) {
    return keyType === "com.apple.fps.1_0" ||
        keyType === "com.apple.fps.2_0";
}
/**
 * Set media keys on video element using native HTMLMediaElement
 * setMediaKeys from WebKit.
 * @param {HTMLMediaElement} videoElement
 * @param {Object|null} mediaKeys
 */
function setWebKitMediaKeys(videoElement, mediaKeys) {
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    if (videoElement.webkitSetMediaKeys === undefined) {
        throw new Error("No webKitMediaKeys API.");
    }
    /* eslint-disable @typescript-eslint/no-unsafe-return */
    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
    return videoElement.webkitSetMediaKeys(mediaKeys);
    /* eslint-enable @typescript-eslint/no-unsafe-return */
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}
/**
 * On Safari browsers (>= 9), there are specific webkit prefixed APIs for cyphered
 * content playback. Standard EME APIs are therefore available since Safari 12.1, but they
 * don't allow to play fairplay cyphered content.
 *
 * This class implements a standard EME API polyfill that wraps webkit prefixed Safari
 * EME custom APIs.
 */
class WebkitMediaKeySession extends event_emitter/* default */.Z {
    /**
     * @param {HTMLMediaElement} mediaElement
     * @param {string} keyType
     * @param {Uint8Array | undefined} serverCertificate
     */
    constructor(mediaElement, keyType, serverCertificate) {
        super();
        this._serverCertificate = serverCertificate;
        this._closeSession$ = new Subject/* Subject */.xQ();
        this._videoElement = mediaElement;
        this._keyType = keyType;
        this.closed = new promise/* default */.Z((resolve) => {
            this._closeSession$.subscribe(resolve);
        });
        this.keyStatuses = new Map();
        this.expiration = NaN;
        this.update = (license) => {
            return new promise/* default */.Z((resolve, reject) => {
                /* eslint-disable @typescript-eslint/no-unsafe-member-access */
                if (this._nativeSession === undefined ||
                    this._nativeSession.update === undefined ||
                    typeof this._nativeSession.update !== "function") {
                    return reject("Unavailable WebKit key session.");
                }
                try {
                    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-call
                    resolve(this._nativeSession.update(license));
                    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
                }
                catch (err) {
                    reject(err);
                }
                /* eslint-enable @typescript-eslint/no-unsafe-member-access */
            });
        };
    }
    listenEvent(session) {
        (0,merge/* merge */.T)(event_listeners.onKeyMessage$(session), event_listeners.onKeyAdded$(session), event_listeners.onKeyError$(session))
            .pipe((0,takeUntil/* takeUntil */.R)(this._closeSession$))
            .subscribe((evt) => {
            this.trigger(evt.type, evt);
        });
    }
    generateRequest(_initDataType, initData) {
        return new promise/* default */.Z((resolve) => {
            /* eslint-disable @typescript-eslint/no-unsafe-member-access */
            if (this._videoElement.webkitKeys === undefined ||
                this._videoElement.webkitKeys.createSession === undefined) {
                throw new Error("No WebKitMediaKeys API.");
            }
            /* eslint-enable @typescript-eslint/no-unsafe-member-access */
            let formattedInitData;
            if (isFairplayKeyType(this._keyType)) {
                if (this._serverCertificate === undefined) {
                    throw new Error("A server certificate is needed for creating fairplay session.");
                }
                formattedInitData = getWebKitFairPlayInitData(initData, this._serverCertificate);
            }
            else {
                formattedInitData = initData;
            }
            /* eslint-disable @typescript-eslint/no-unsafe-member-access */
            /* eslint-disable @typescript-eslint/no-unsafe-assignment */
            /* eslint-disable @typescript-eslint/no-unsafe-call */
            const keySession = this._videoElement.webkitKeys.createSession("video/mp4", formattedInitData);
            /* eslint-enable @typescript-eslint/no-unsafe-member-access */
            /* eslint-enable @typescript-eslint/no-unsafe-assignment */
            /* eslint-enable @typescript-eslint/no-unsafe-call */
            if (keySession === undefined || keySession === null) {
                throw new Error("Impossible to get the key sessions");
            }
            this.listenEvent(keySession);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            this._nativeSession = keySession;
            resolve();
        });
    }
    close() {
        return new promise/* default */.Z((resolve, reject) => {
            this._closeSession$.next();
            this._closeSession$.complete();
            if (this._nativeSession === undefined) {
                reject("No session to close.");
            }
            /* eslint-disable @typescript-eslint/no-unsafe-member-access */
            /* eslint-disable @typescript-eslint/no-unsafe-call */
            this._nativeSession.close();
            /* eslint-enable @typescript-eslint/no-unsafe-member-access */
            /* eslint-enable @typescript-eslint/no-unsafe-call */
            resolve();
        });
    }
    load() {
        return promise/* default.resolve */.Z.resolve(false);
    }
    remove() {
        return promise/* default.resolve */.Z.resolve();
    }
    get sessionId() {
        var _a, _b;
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        /* eslint-disable @typescript-eslint/no-unsafe-return */
        return (_b = (_a = this._nativeSession) === null || _a === void 0 ? void 0 : _a.sessionId) !== null && _b !== void 0 ? _b : "";
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        /* eslint-enable @typescript-eslint/no-unsafe-return */
    }
}
class WebKitCustomMediaKeys {
    constructor(keyType) {
        if (webkit_media_keys_constructor/* WebKitMediaKeysConstructor */.t === undefined) {
            throw new Error("No WebKitMediaKeys API.");
        }
        this._keyType = keyType;
        this._mediaKeys = new webkit_media_keys_constructor/* WebKitMediaKeysConstructor */.t(keyType);
    }
    _setVideo(videoElement) {
        this._videoElement = videoElement;
        if (this._videoElement === undefined) {
            throw new Error("Video not attached to the MediaKeys");
        }
        return setWebKitMediaKeys(this._videoElement, this._mediaKeys);
    }
    createSession( /* sessionType */) {
        if (this._videoElement === undefined ||
            this._mediaKeys === undefined) {
            throw new Error("Video not attached to the MediaKeys");
        }
        return new WebkitMediaKeySession(this._videoElement, this._keyType, this._serverCertificate);
    }
    setServerCertificate(serverCertificate) {
        this._serverCertificate = serverCertificate;
        return promise/* default.resolve */.Z.resolve();
    }
}
function getWebKitMediaKeysCallbacks() {
    if (webkit_media_keys_constructor/* WebKitMediaKeysConstructor */.t === undefined) {
        throw new Error("No WebKitMediaKeys API.");
    }
    const isTypeSupported = webkit_media_keys_constructor/* WebKitMediaKeysConstructor.isTypeSupported */.t.isTypeSupported;
    const createCustomMediaKeys = (keyType) => new WebKitCustomMediaKeys(keyType);
    const setMediaKeys = (elt, mediaKeys) => {
        if (mediaKeys === null) {
            return setWebKitMediaKeys(elt, mediaKeys);
        }
        if (!(mediaKeys instanceof WebKitCustomMediaKeys)) {
            throw new Error("Custom setMediaKeys is supposed to be called " +
                "with webkit custom MediaKeys.");
        }
        return mediaKeys._setVideo(elt);
    };
    return {
        isTypeSupported,
        createCustomMediaKeys,
        setMediaKeys,
    };
}

;// CONCATENATED MODULE: ./src/compat/eme/custom_media_keys/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












let requestMediaKeySystemAccess = null;
let _setMediaKeys = function defaultSetMediaKeys(elt, mediaKeys) {
    /* eslint-disable @typescript-eslint/unbound-method */
    if (typeof elt.setMediaKeys === "function") {
        return elt.setMediaKeys(mediaKeys);
    }
    /* eslint-enable @typescript-eslint/unbound-method */
    /* eslint-disable @typescript-eslint/strict-boolean-expressions */
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    /* eslint-disable @typescript-eslint/no-unsafe-return */
    /* eslint-disable @typescript-eslint/no-unsafe-call */
    // If we get in the following code, it means that no compat case has been
    // found and no standard setMediaKeys API exists. This case is particulary
    // rare. We will try to call each API with native media keys.
    if (elt.webkitSetMediaKeys) {
        return elt.webkitSetMediaKeys(mediaKeys);
    }
    if (elt.mozSetMediaKeys) {
        return elt.mozSetMediaKeys(mediaKeys);
    }
    if (elt.msSetMediaKeys && mediaKeys !== null) {
        return elt.msSetMediaKeys(mediaKeys);
    }
    /* eslint-enable @typescript-eslint/strict-boolean-expressions */
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    /* eslint-enable @typescript-eslint/no-unsafe-return */
    /* eslint-enable @typescript-eslint/no-unsafe-call */
};
/**
 * Since Safari 12.1, EME APIs are available without webkit prefix.
 * However, it seems that since fairplay CDM implementation within the browser is not
 * standard with EME w3c current spec, the requestMediaKeySystemAccess API doesn't resolve
 * positively, even if the drm (fairplay in most cases) is supported.
 *
 * Therefore, we prefer not to use requestMediaKeySystemAccess on Safari when webkit API
 * is available.
 */
if (is_node/* default */.Z ||
    (navigator.requestMediaKeySystemAccess != null && !(0,should_favour_custom_safari_EME/* default */.Z)())) {
    requestMediaKeySystemAccess = (a, b) => (0,cast_to_observable/* default */.Z)(navigator.requestMediaKeySystemAccess(a, b));
}
else {
    let isTypeSupported;
    let createCustomMediaKeys;
    // This is for Chrome with unprefixed EME api
    if (isOldWebkitMediaElement(HTMLVideoElement.prototype)) {
        const callbacks = getOldWebKitMediaKeysCallbacks();
        isTypeSupported = callbacks.isTypeSupported;
        createCustomMediaKeys = callbacks.createCustomMediaKeys;
        _setMediaKeys = callbacks.setMediaKeys;
        // This is for WebKit with prefixed EME api
    }
    else if (webkit_media_keys_constructor/* WebKitMediaKeysConstructor */.t !== undefined) {
        const callbacks = getWebKitMediaKeysCallbacks();
        isTypeSupported = callbacks.isTypeSupported;
        createCustomMediaKeys = callbacks.createCustomMediaKeys;
        _setMediaKeys = callbacks.setMediaKeys;
    }
    else if (browser_detection/* isIE11 */.fq && MSMediaKeysConstructor !== undefined) {
        const callbacks = getIE11MediaKeysCallbacks();
        isTypeSupported = callbacks.isTypeSupported;
        createCustomMediaKeys = callbacks.createCustomMediaKeys;
        _setMediaKeys = callbacks.setMediaKeys;
    }
    else if (MozMediaKeysConstructor !== undefined) {
        const callbacks = getMozMediaKeysCallbacks();
        isTypeSupported = callbacks.isTypeSupported;
        createCustomMediaKeys = callbacks.createCustomMediaKeys;
        _setMediaKeys = callbacks.setMediaKeys;
    }
    else {
        /* eslint-disable @typescript-eslint/no-unsafe-assignment */
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        /* eslint-disable @typescript-eslint/no-unsafe-return */
        const { MediaKeys } = window;
        const checkForStandardMediaKeys = () => {
            if (MediaKeys === undefined) {
                throw new media_error/* default */.Z("MEDIA_KEYS_NOT_SUPPORTED", "No `MediaKeys` implementation found " +
                    "in the current browser.");
            }
            if (MediaKeys.isTypeSupported === undefined) {
                const message = "This browser seems to be unable to play encrypted contents " +
                    "currently. Note: Some browsers do not allow decryption " +
                    "in some situations, like when not using HTTPS.";
                throw new Error(message);
            }
        };
        isTypeSupported = (keyType) => {
            checkForStandardMediaKeys();
            /* eslint-disable-next-line @typescript-eslint/no-unsafe-call */
            return MediaKeys.isTypeSupported(keyType);
        };
        createCustomMediaKeys = (keyType) => {
            checkForStandardMediaKeys();
            /* eslint-disable-next-line @typescript-eslint/no-unsafe-call */
            return new MediaKeys(keyType);
        };
        /* eslint-enable @typescript-eslint/no-unsafe-assignment */
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        /* eslint-enable @typescript-eslint/no-unsafe-return */
    }
    requestMediaKeySystemAccess = function (keyType, keySystemConfigurations) {
        // TODO Why TS Do not understand that isTypeSupported exists here?
        if (!isTypeSupported(keyType)) {
            return (0,throwError/* throwError */._)(undefined);
        }
        for (let i = 0; i < keySystemConfigurations.length; i++) {
            const keySystemConfiguration = keySystemConfigurations[i];
            const { videoCapabilities, audioCapabilities, initDataTypes, distinctiveIdentifier } = keySystemConfiguration;
            let supported = true;
            supported = supported &&
                (initDataTypes == null ||
                    initDataTypes.some((idt) => idt === "cenc"));
            supported = supported && (distinctiveIdentifier !== "required");
            if (supported) {
                const keySystemConfigurationResponse = {
                    videoCapabilities,
                    audioCapabilities,
                    initDataTypes: ["cenc"],
                    distinctiveIdentifier: "not-allowed",
                    persistentState: "required",
                    sessionTypes: ["temporary", "persistent-license"],
                };
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const customMediaKeys = createCustomMediaKeys(keyType);
                return (0,of.of)(new CustomMediaKeySystemAccess(keyType, customMediaKeys, keySystemConfigurationResponse));
            }
        }
        return (0,throwError/* throwError */._)(undefined);
    };
}
/**
 * Set the given MediaKeys on the given HTMLMediaElement.
 * Emits null when done then complete.
 * @param {HTMLMediaElement} elt
 * @param {Object} mediaKeys
 * @returns {Observable}
 */
function setMediaKeys(elt, mediaKeys) {
    return (0,defer/* defer */.P)(() => (0,cast_to_observable/* default */.Z)(_setMediaKeys(elt, mediaKeys)));
}



/***/ }),

/***/ 36184:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "t": () => (/* binding */ WebKitMediaKeysConstructor)
/* harmony export */ });
/* harmony import */ var _is_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68767);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

let WebKitMediaKeysConstructor;
if (!_is_node__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z) {
    /* eslint-disable @typescript-eslint/no-unsafe-assignment */
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    const { WebKitMediaKeys } = window;
    if (WebKitMediaKeys !== undefined &&
        typeof WebKitMediaKeys.isTypeSupported === "function" &&
        typeof WebKitMediaKeys.prototype.createSession === "function" &&
        typeof HTMLMediaElement.prototype.webkitSetMediaKeys === "function") {
        WebKitMediaKeysConstructor = WebKitMediaKeys;
    }
    /* eslint-enable @typescript-eslint/no-unsafe-assignment */
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}



/***/ }),

/***/ 90315:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "isActive": () => (/* binding */ isActive),
  "isVideoVisible": () => (/* binding */ isVideoVisible),
  "onEncrypted$": () => (/* binding */ onEncrypted$),
  "onEnded$": () => (/* binding */ onEnded$),
  "onFullscreenChange$": () => (/* binding */ onFullscreenChange$),
  "onKeyAdded$": () => (/* binding */ onKeyAdded$),
  "onKeyError$": () => (/* binding */ onKeyError$),
  "onKeyMessage$": () => (/* binding */ onKeyMessage$),
  "onKeyStatusesChange$": () => (/* binding */ onKeyStatusesChange$),
  "onLoadedMetadata$": () => (/* binding */ onLoadedMetadata$),
  "onPictureInPictureEvent$": () => (/* binding */ onPictureInPictureEvent$),
  "onPlayPause$": () => (/* binding */ onPlayPause$),
  "onRemoveSourceBuffers$": () => (/* binding */ onRemoveSourceBuffers$),
  "onSeeked$": () => (/* binding */ onSeeked$),
  "onSeeking$": () => (/* binding */ onSeeking$),
  "onSourceOpen$": () => (/* binding */ onSourceOpen$),
  "onTextTrackChanges$": () => (/* binding */ onTextTrackChanges$),
  "onTimeUpdate$": () => (/* binding */ onTimeUpdate$),
  "onUpdate$": () => (/* binding */ onUpdate$),
  "videoWidth$": () => (/* binding */ videoWidth$)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(30365);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/noop.js
var noop = __webpack_require__(44992);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/never.js
/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */


var NEVER = /*@__PURE__*/new Observable/* Observable */.y(noop/* noop */.Z);
function never() {
  return NEVER;
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(54514);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(10125);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(24251);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(92953);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
var interval = __webpack_require__(75573);
// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(10649);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/async.js
var scheduler_async = __webpack_require__(49663);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isDate.js
var isDate = __webpack_require__(53074);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(50032);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Notification.js
var Notification = __webpack_require__(51703);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/delay.js
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */





function delay(delay, scheduler) {
  if (scheduler === void 0) {
    scheduler = scheduler_async/* async */.P;
  }

  var absoluteDelay = (0,isDate/* isDate */.J)(delay);
  var delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
  return function (source) {
    return source.lift(new DelayOperator(delayFor, scheduler));
  };
}

var DelayOperator = /*@__PURE__*/function () {
  function DelayOperator(delay, scheduler) {
    this.delay = delay;
    this.scheduler = scheduler;
  }

  DelayOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
  };

  return DelayOperator;
}();

var DelaySubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(DelaySubscriber, _super);

  function DelaySubscriber(destination, delay, scheduler) {
    var _this = _super.call(this, destination) || this;

    _this.delay = delay;
    _this.scheduler = scheduler;
    _this.queue = [];
    _this.active = false;
    _this.errored = false;
    return _this;
  }

  DelaySubscriber.dispatch = function (state) {
    var source = state.source;
    var queue = source.queue;
    var scheduler = state.scheduler;
    var destination = state.destination;

    while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
      queue.shift().notification.observe(destination);
    }

    if (queue.length > 0) {
      var delay_1 = Math.max(0, queue[0].time - scheduler.now());
      this.schedule(state, delay_1);
    } else {
      this.unsubscribe();
      source.active = false;
    }
  };

  DelaySubscriber.prototype._schedule = function (scheduler) {
    this.active = true;
    var destination = this.destination;
    destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
      source: this,
      destination: this.destination,
      scheduler: scheduler
    }));
  };

  DelaySubscriber.prototype.scheduleNotification = function (notification) {
    if (this.errored === true) {
      return;
    }

    var scheduler = this.scheduler;
    var message = new DelayMessage(scheduler.now() + this.delay, notification);
    this.queue.push(message);

    if (this.active === false) {
      this._schedule(scheduler);
    }
  };

  DelaySubscriber.prototype._next = function (value) {
    this.scheduleNotification(Notification/* Notification.createNext */.P.createNext(value));
  };

  DelaySubscriber.prototype._error = function (err) {
    this.errored = true;
    this.queue = [];
    this.destination.error(err);
    this.unsubscribe();
  };

  DelaySubscriber.prototype._complete = function () {
    this.scheduleNotification(Notification/* Notification.createComplete */.P.createComplete());
    this.unsubscribe();
  };

  return DelaySubscriber;
}(Subscriber/* Subscriber */.L);

var DelayMessage = /*@__PURE__*/function () {
  function DelayMessage(time, notification) {
    this.time = time;
    this.notification = notification;
  }

  return DelayMessage;
}();
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/innerSubscribe.js
var innerSubscribe = __webpack_require__(90789);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/throttle.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


var defaultThrottleConfig = {
  leading: true,
  trailing: false
};
function throttle(durationSelector, config) {
  if (config === void 0) {
    config = defaultThrottleConfig;
  }

  return function (source) {
    return source.lift(new ThrottleOperator(durationSelector, !!config.leading, !!config.trailing));
  };
}

var ThrottleOperator = /*@__PURE__*/(/* unused pure expression or super */ null && (function () {
  function ThrottleOperator(durationSelector, leading, trailing) {
    this.durationSelector = durationSelector;
    this.leading = leading;
    this.trailing = trailing;
  }

  ThrottleOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
  };

  return ThrottleOperator;
}()));

var ThrottleSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(ThrottleSubscriber, _super);

  function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
    var _this = _super.call(this, destination) || this;

    _this.destination = destination;
    _this.durationSelector = durationSelector;
    _this._leading = _leading;
    _this._trailing = _trailing;
    _this._hasValue = false;
    return _this;
  }

  ThrottleSubscriber.prototype._next = function (value) {
    this._hasValue = true;
    this._sendValue = value;

    if (!this._throttled) {
      if (this._leading) {
        this.send();
      } else {
        this.throttle(value);
      }
    }
  };

  ThrottleSubscriber.prototype.send = function () {
    var _a = this,
        _hasValue = _a._hasValue,
        _sendValue = _a._sendValue;

    if (_hasValue) {
      this.destination.next(_sendValue);
      this.throttle(_sendValue);
    }

    this._hasValue = false;
    this._sendValue = undefined;
  };

  ThrottleSubscriber.prototype.throttle = function (value) {
    var duration = this.tryDurationSelector(value);

    if (!!duration) {
      this.add(this._throttled = (0,innerSubscribe/* innerSubscribe */.ft)(duration, new innerSubscribe/* SimpleInnerSubscriber */.IY(this)));
    }
  };

  ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
    try {
      return this.durationSelector(value);
    } catch (err) {
      this.destination.error(err);
      return null;
    }
  };

  ThrottleSubscriber.prototype.throttlingDone = function () {
    var _a = this,
        _throttled = _a._throttled,
        _trailing = _a._trailing;

    if (_throttled) {
      _throttled.unsubscribe();
    }

    this._throttled = undefined;

    if (_trailing) {
      this.send();
    }
  };

  ThrottleSubscriber.prototype.notifyNext = function () {
    this.throttlingDone();
  };

  ThrottleSubscriber.prototype.notifyComplete = function () {
    this.throttlingDone();
  };

  return ThrottleSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/throttleTime.js
/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */




function throttleTime(duration, scheduler, config) {
  if (scheduler === void 0) {
    scheduler = scheduler_async/* async */.P;
  }

  if (config === void 0) {
    config = defaultThrottleConfig;
  }

  return function (source) {
    return source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));
  };
}

var ThrottleTimeOperator = /*@__PURE__*/function () {
  function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
    this.duration = duration;
    this.scheduler = scheduler;
    this.leading = leading;
    this.trailing = trailing;
  }

  ThrottleTimeOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
  };

  return ThrottleTimeOperator;
}();

var ThrottleTimeSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(ThrottleTimeSubscriber, _super);

  function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
    var _this = _super.call(this, destination) || this;

    _this.duration = duration;
    _this.scheduler = scheduler;
    _this.leading = leading;
    _this.trailing = trailing;
    _this._hasTrailingValue = false;
    _this._trailingValue = null;
    return _this;
  }

  ThrottleTimeSubscriber.prototype._next = function (value) {
    if (this.throttled) {
      if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    } else {
      this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, {
        subscriber: this
      }));

      if (this.leading) {
        this.destination.next(value);
      } else if (this.trailing) {
        this._trailingValue = value;
        this._hasTrailingValue = true;
      }
    }
  };

  ThrottleTimeSubscriber.prototype._complete = function () {
    if (this._hasTrailingValue) {
      this.destination.next(this._trailingValue);
      this.destination.complete();
    } else {
      this.destination.complete();
    }
  };

  ThrottleTimeSubscriber.prototype.clearThrottle = function () {
    var throttled = this.throttled;

    if (throttled) {
      if (this.trailing && this._hasTrailingValue) {
        this.destination.next(this._trailingValue);
        this._trailingValue = null;
        this._hasTrailingValue = false;
      }

      throttled.unsubscribe();
      this.remove(throttled);
      this.throttled = null;
    }
  };

  return ThrottleTimeSubscriber;
}(Subscriber/* Subscriber */.L);

function dispatchNext(arg) {
  var subscriber = arg.subscriber;
  subscriber.clearThrottle();
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(65208);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
var startWith = __webpack_require__(5118);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(96078);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMap.js
var switchMap = __webpack_require__(17568);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(53059);
// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(86694);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
// EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
var browser_compatibility_types = __webpack_require__(18909);
// EXTERNAL MODULE: ./src/compat/is_node.ts
var is_node = __webpack_require__(68767);
// EXTERNAL MODULE: ./src/compat/should_favour_custom_safari_EME.ts
var should_favour_custom_safari_EME = __webpack_require__(40213);
;// CONCATENATED MODULE: ./src/compat/event_listeners.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file provides browser-agnostic event listeners under the form of
 * RxJS Observables
 */








const BROWSER_PREFIXES = ["", "webkit", "moz", "ms"];
const INACTIVITY_DELAY = config/* default.INACTIVITY_DELAY */.Z.INACTIVITY_DELAY;
const pixelRatio = is_node/* default */.Z ||
    window.devicePixelRatio == null ||
    window.devicePixelRatio === 0 ? 1 :
    window.devicePixelRatio;
/**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {string} eventNameSuffix
 * @returns {Boolean}
 */
function isEventSupported(element, eventNameSuffix) {
    const clone = document.createElement(element.tagName);
    const eventName = "on" + eventNameSuffix;
    if (eventName in clone) {
        return true;
    }
    else {
        clone.setAttribute(eventName, "return;");
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        return typeof clone[eventName] === "function";
    }
}
/**
 * Find the first supported event from the list given.
 * @param {HTMLElement} element
 * @param {Array.<string>} eventNames
 * @returns {string|undefined}
 */
function findSupportedEvent(element, eventNames) {
    return eventNames
        .filter((name) => isEventSupported(element, name))[0];
}
/**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Array.<string>}
 */
function eventPrefixed(eventNames, prefixes) {
    return eventNames.reduce((parent, name) => parent.concat((prefixes == null ? BROWSER_PREFIXES :
        prefixes)
        .map((p) => p + name)), []);
}
/**
 * @param {Array.<string>} eventNames
 * @param {Array.<string>|undefined} prefixes
 * @returns {Observable}
 */
function compatibleListener(eventNames, prefixes) {
    let mem;
    const prefixedEvents = eventPrefixed(eventNames, prefixes);
    return (element) => {
        // if the element is a HTMLElement we can detect
        // the supported event, and memoize it in `mem`
        if (element instanceof browser_compatibility_types/* HTMLElement_ */.DQ) {
            if (typeof mem === "undefined") {
                mem = findSupportedEvent(element, prefixedEvents);
            }
            if ((0,is_non_empty_string/* default */.Z)(mem)) {
                return (0,fromEvent/* fromEvent */.R)(element, mem);
            }
            else {
                if (true) {
                    log/* default.warn */.Z.warn(`compat: element ${element.tagName}` +
                        " does not support any of these events: " +
                        prefixedEvents.join(", "));
                }
                return NEVER;
            }
        }
        // otherwise, we need to listen to all the events
        // and merge them into one observable sequence
        return (0,merge/* merge */.T)(...prefixedEvents.map(eventName => (0,fromEvent/* fromEvent */.R)(element, eventName)));
    };
}
/**
 * Returns an observable:
 *   - emitting true when the document is visible
 *   - emitting false when the document is hidden
 * @returns {Observable}
 */
function visibilityChange() {
    let prefix;
    const doc = document;
    if (doc.hidden != null) {
        prefix = "";
    }
    else if (doc.mozHidden != null) {
        prefix = "moz";
    }
    else if (doc.msHidden != null) {
        prefix = "ms";
    }
    else if (doc.webkitHidden != null) {
        prefix = "webkit";
    }
    const hidden = (0,is_non_empty_string/* default */.Z)(prefix) ? prefix + "Hidden" :
        "hidden";
    const visibilityChangeEvent = (0,is_non_empty_string/* default */.Z)(prefix) ? prefix + "visibilitychange" :
        "visibilitychange";
    return (0,defer/* defer */.P)(() => {
        const isHidden = document[hidden];
        return (0,fromEvent/* fromEvent */.R)(document, visibilityChangeEvent)
            .pipe((0,map/* map */.U)(() => !(document[hidden])), (0,startWith/* startWith */.O)(!isHidden), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
    });
}
/**
 * @returns {Observable}
 */
function videoSizeChange() {
    return (0,fromEvent/* fromEvent */.R)(window, "resize");
}
/**
 * Emit `true` if the page is considered active.
 * `false` when considered inactive.
 * Emit the original value on subscription.
 * @returns {Observable}
 */
function isActive() {
    return visibilityChange().pipe((0,switchMap/* switchMap */.w)((x) => {
        if (!x) {
            return (0,of.of)(x).pipe(delay(INACTIVITY_DELAY));
        }
        return (0,of.of)(x);
    }));
}
/**
 * Get video width from Picture-in-Picture window
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} pipWindow
 * @returns {number}
 */
function getVideoWidthFromPIPWindow(mediaElement, pipWindow) {
    const { width, height } = pipWindow;
    const videoRatio = mediaElement.clientHeight / mediaElement.clientWidth;
    const calcWidth = height / videoRatio;
    return Math.min(width, calcWidth);
}
/**
 * Emit when video enters and leaves Picture-In-Picture mode.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
function onPictureInPictureEvent$(mediaElement) {
    return (0,defer/* defer */.P)(() => {
        /* eslint-disable @typescript-eslint/strict-boolean-expressions */
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        if (mediaElement.webkitSupportsPresentationMode &&
            typeof mediaElement.webkitSetPresentationMode === "function") {
            const isWebKitPIPEnabled = mediaElement.webkitPresentationMode === "picture-in-picture";
            return (0,fromEvent/* fromEvent */.R)(mediaElement, "webkitpresentationmodechanged").pipe((0,map/* map */.U)(() => ({
                isEnabled: mediaElement
                    .webkitPresentationMode === "picture-in-picture",
                pipWindow: null,
            })), (0,startWith/* startWith */.O)({ isEnabled: isWebKitPIPEnabled, pipWindow: null }));
        }
        /* eslint-disable @typescript-eslint/no-unsafe-assignment */
        const isPIPEnabled = (document.pictureInPictureElement &&
            document.pictureInPictureElement === mediaElement);
        const initialState = { isEnabled: isPIPEnabled, pipWindow: null };
        /* eslint-enable @typescript-eslint/no-unsafe-assignment */
        return (0,merge/* merge */.T)((0,fromEvent/* fromEvent */.R)(mediaElement, "enterpictureinpicture")
            .pipe((0,map/* map */.U)((evt) => ({
            isEnabled: true,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            pipWindow: evt.pictureInPictureWindow,
        }))), (0,fromEvent/* fromEvent */.R)(mediaElement, "leavepictureinpicture")
            .pipe((0,mapTo/* mapTo */.h)({ isEnabled: false, pipWindow: null }))).pipe((0,startWith/* startWith */.O)(initialState));
        /* eslint-enable @typescript-eslint/strict-boolean-expressions */
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    });
}
/**
 * Returns `true` when video is considered as visible (the page is visible and/or
 * the Picture-In-Picture is activated). Returns `false` otherwise.
 * @param {Observable} pip$
 * @returns {Observable}
 */
function isVideoVisible(pip$) {
    return (0,combineLatest/* combineLatest */.aj)([visibilityChange(), pip$]).pipe((0,switchMap/* switchMap */.w)(([isVisible, pip]) => {
        if (pip.isEnabled || isVisible) {
            return (0,of.of)(true);
        }
        return (0,of.of)(false)
            .pipe(delay(INACTIVITY_DELAY));
    }), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
}
/**
 * Get video width from HTML video element, or video estimated dimensions
 * when Picture-in-Picture is activated.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
function videoWidth$(mediaElement, pip$) {
    return (0,combineLatest/* combineLatest */.aj)([
        pip$,
        (0,interval/* interval */.F)(20000).pipe((0,startWith/* startWith */.O)(null)),
        videoSizeChange().pipe(throttleTime(500), (0,startWith/* startWith */.O)(null)),
    ]).pipe((0,switchMap/* switchMap */.w)(([pip]) => {
        if (!pip.isEnabled) {
            return (0,of.of)(mediaElement.clientWidth * pixelRatio);
        }
        else if (pip.pipWindow != null) {
            const { pipWindow } = pip;
            const firstWidth = getVideoWidthFromPIPWindow(mediaElement, pipWindow);
            // RxJS typing issue (for the "as any")
            return (0,fromEvent/* fromEvent */.R)(pipWindow, "resize").pipe((0,startWith/* startWith */.O)(firstWidth * pixelRatio), (0,map/* map */.U)(() => getVideoWidthFromPIPWindow(mediaElement, pipWindow) * pixelRatio));
        }
        else {
            return (0,of.of)(Infinity);
        }
    }), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
}
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
const onLoadedMetadata$ = compatibleListener(["loadedmetadata"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
const onSeeking$ = compatibleListener(["seeking"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
const onSeeked$ = compatibleListener(["seeked"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
const onEnded$ = compatibleListener(["ended"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
const onTimeUpdate$ = compatibleListener(["timeupdate"]);
/**
 * @param {HTMLElement} element
 * @returns {Observable}
 */
const onFullscreenChange$ = compatibleListener(["fullscreenchange", "FullscreenChange"], 
// On IE11, fullscreen change events is called MSFullscreenChange
BROWSER_PREFIXES.concat("MS"));
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
const onPlayPause$ = (mediaElement) => (0,merge/* merge */.T)(compatibleListener(["play"])(mediaElement), compatibleListener(["pause"])(mediaElement));
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
const onTextTrackChanges$ = (textTrackList) => (0,merge/* merge */.T)(compatibleListener(["addtrack"])(textTrackList), compatibleListener(["removetrack"])(textTrackList));
/**
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */
const onSourceOpen$ = compatibleListener(["sourceopen", "webkitsourceopen"]);
/**
 * @param {SourceBuffer} sourceBuffer
 * @returns {Observable}
 */
const onUpdate$ = compatibleListener(["update"]);
/**
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */
const onRemoveSourceBuffers$ = compatibleListener(["onremovesourcebuffer"]);
/**
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
const onEncrypted$ = compatibleListener((0,should_favour_custom_safari_EME/* default */.Z)() ? ["needkey"] :
    ["encrypted", "needkey"]);
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */
const onKeyMessage$ = compatibleListener(["keymessage", "message"]);
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */
const onKeyAdded$ = compatibleListener(["keyadded", "ready"]);
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */
const onKeyError$ = compatibleListener(["keyerror", "error"]);
/**
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */
const onKeyStatusesChange$ = compatibleListener(["keystatuseschange"]);



/***/ }),

/***/ 68767:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const isNode = typeof window === "undefined";
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isNode);


/***/ }),

/***/ 56003:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ isVTTCue)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns true if the given cue is an instance of a VTTCue.
 * @param {*} cue
 * @returns {boolean}
 */
function isVTTCue(cue) {
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    return typeof window.VTTCue === "function" &&
        cue instanceof window.VTTCue;
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}


/***/ }),

/***/ 11862:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ makeCue)
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6077);
/* harmony import */ var _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18909);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Creates a cue using the best platform-specific interface available.
 *
 * @param {Number} startTime
 * @param {Number} endTime
 * @param {string} payload
 * @returns {VTTCue|TextTrackCue|null} Text track cue or null if the parameters
 * were invalid.
 */
function makeCue(startTime, endTime, payload) {
    if (_browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__/* .VTTCue_ */ .w == null) {
        throw new Error("VTT cues not supported in your target");
    }
    if (startTime >= endTime) {
        // IE/Edge will throw in this case.
        // See issue #501
        _log__WEBPACK_IMPORTED_MODULE_1__/* .default.warn */ .Z.warn(`Compat: Invalid cue times: ${startTime} - ${endTime}`);
        return null;
    }
    return new _browser_compatibility_types__WEBPACK_IMPORTED_MODULE_0__/* .VTTCue_ */ .w(startTime, endTime, payload);
}


/***/ }),

/***/ 40213:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ shouldFavourCustomSafariEME)
/* harmony export */ });
/* harmony import */ var _browser_detection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8886);
/* harmony import */ var _eme_custom_media_keys_webkit_media_keys_constructor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(36184);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * On Safari 12.1, it seems that since fairplay CDM implementation
 * within the browser is not standard with EME w3c current spec, the
 * requestMediaKeySystemAccess API doesn't resolve positively, even
 * if the drm (fairplay in most cases) is supported.
 * @returns {boolean}
 */
function shouldFavourCustomSafariEME() {
    return _browser_detection__WEBPACK_IMPORTED_MODULE_0__/* .isSafari */ .G6 && _eme_custom_media_keys_webkit_media_keys_constructor__WEBPACK_IMPORTED_MODULE_1__/* .WebKitMediaKeysConstructor */ .t !== undefined;
}


/***/ }),

/***/ 86694:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Configuration file for the whole player.
 * Feel free to tweak those values if you know what you're doing.
 *
 * Please not that you will need to re-build the whole project to take these
 * modifications into account.
 *
 * @type {Object}
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    /**
     * Volume set on unMute if the volume is set to 0 and either:
     *   - mute has never been called before
     *   - mute has last been called while the volume was already set to 0 (either
     *     via setVolume, or a previous mute call)
     * @type {Number}
     */
    DEFAULT_UNMUTED_VOLUME: 0.1,
    /**
     * Default time interval after which a request will timeout, in ms.
     * @type {Number}
     */
    DEFAULT_REQUEST_TIMEOUT: 30 * 1000,
    /**
     * Can be either:
     *   - "native": Subtitles are all displayed in a <track> element
     *   - "html": Subtitles are all displayed in a <div> separated from the video
     *     element. Can be useful to display richer TTML subtitles, for example.
     * @type {Object|null}
     */
    DEFAULT_TEXT_TRACK_MODE: "native",
    /**
     * Strategy to adopt when manually setting the current bitrate.
     * Can be either:
     *   - "seamless": transitions are very smooth but not immediate.
     *   - "direct": the quality switch happens immediately but to achieve that,
     *     the player will need to set a new MediaSource on the media element in
     *     some cases. This often leads to a black screen + unavailable APIs
     *     during a short moment.
     * @type {string}
     */
    DEFAULT_MANUAL_BITRATE_SWITCHING_MODE: "seamless",
    /**
     * Default behavior for the `enableFastSwitching` loadVideo options.
     *
     * Fast-switching allows to provide quicker transitions from lower quality
     * segments to higher quality segments but might be badly supported on some
     * devices.
     * When enabled, the RxPlayer might replace segments of a lower-quality
     * (with a lower bitrate) with segments of a higher quality (with a higher
     * bitrate). This allows to have a fast transition when network conditions
     * improve.
     * When disabled, segments of a lower-quality will not be replaced.
     */
    DEFAULT_ENABLE_FAST_SWITCHING: true,
    /**
     * Strategy to adopt when manually switching of audio adaptation.
     * Can be either:
     *    - "seamless": transitions are smooth but could be not immediate.
     *    - "direct": that strategy will be "smart", if the mimetype and the codec,
     *    change, we will perform a hard reload of the media source, however, if it
     *    doesn't change, we will just perform a small flush by removing buffered range,
     *    and perform, a small seek on the media element.
     *    Transitions are faster, but we could see appear a reloading or seeking state.
     */
    DEFAULT_AUDIO_TRACK_SWITCHING_MODE: "seamless",
    /**
     * In some cases after switching the current track or bitrate, the RxPlayer
     * could be led to go into the `"RELOADING"` state, which corresponds to
     * visually a black screen (with nothing audible) before restarting playback.
     *
     * We could want to seek back some milliseconds when doing that.
     * For example, when switching the current audio track, it might make sense
     * to restart some time before, so the beginning of the sentence can be heard
     * again in the new language.
     *
     * This config property allows to set the relative position the RxPlayer will
     * seek to after reloading, in seconds.
     *
     * For example: a value of `-0.7` means that will seek back 700 milliseconds
     * when reloading due to a track or bitrate switch with necessitated a
     * reloading.
     */
    DELTA_POSITION_AFTER_RELOAD: {
        /** Relative position when switching the bitrate */
        bitrateSwitch: -0.1,
        /**
         * Relative position when switching the track.
         *
         * From tests, I noticed that seeking back was only really "pleasant" when
         * switching the audio track.
         *
         * E.g. switching the video track often means changing the camera angle or
         * even totally changing what is being seen and rely much less on temporal
         * context than when an audio track is switched.
         * As such, I decided to only set a sensible seek-back behavior when
         * switching the audio track, and only a minimal one (to still ensure
         * nothing was missed) for video.
         *
         * "Other" mainly concern text track, where seeking back could even be
         * annoying, so that behavior has been disabled in that case.
         */
        trackSwitch: { audio: -0.7,
            video: -0.1,
            other: 0 },
    },
    /**
     * Behavior of the RxPlayer when encountering a whole other codec on a already
     * existing audio or video SourceBuffer.
     *
     * Can be either:
     *
     *    - "continue": Segments linked to the new codec will continue to be
     *      pushed to that same SourceBuffer. The RxPlayer will still try to call
     *      the `changeType` API on the SourceBuffer before pushing those
     *      segments but continue even if this call failed.
     *
     *    - "reload": Every time a new incompatible codec is encountered on a
     *      given SourceBuffer, we will reload the MediaSource.
     */
    DEFAULT_CODEC_SWITCHING_BEHAVIOR: "continue",
    /**
     * If set to true, video through loadVideo will auto play by default
     * @type {Boolean}
     */
    DEFAULT_AUTO_PLAY: false,
    /**
     * If set to false, "native" subtitles (in a <track> element) will be hidden
     * by default.
     * @type {Boolean}
     */
    DEFAULT_SHOW_NATIVE_SUBTITLE: true,
    /**
     * If set to true, the player will by default stop immediately and unload the
     * content on reaching the end of the media.
     *
     * If set to false, it will not unload nor stop by default, leaving the user
     * free to seek in the already-loaded content.
     *
     * Set to `true` for legacy reasons.
     * @type {Boolean}
     */
    DEFAULT_STOP_AT_END: true,
    /**
     * Default buffer goal in seconds.
     * Once enough content has been downloaded to fill the buffer up to
     * ``current position + DEFAULT_WANTED_BUFFER_AHEAD", we will stop downloading
     * content.
     * @type {Number}
     */
    DEFAULT_WANTED_BUFFER_AHEAD: 30,
    /**
     * Default max buffer size ahead of the current position in seconds.
     * The buffer _after_ this limit will be garbage collected.
     * Set to Infinity for no limit.
     * @type {Number}
     */
    DEFAULT_MAX_BUFFER_AHEAD: Infinity,
    /**
     * Default max buffer size ahead of the current position in seconds.
     * The buffer _before_ this limit will be garbage collected.
     * Set to Infinity for no limit.
     * @type {Number}
     */
    DEFAULT_MAX_BUFFER_BEHIND: Infinity,
    /* eslint-disable @typescript-eslint/consistent-type-assertions */
    /**
     * Maximum possible buffer ahead for each type of buffer, to avoid too much
     * memory usage when playing for a long time.
     * Equal to Infinity if not defined here.
     * @type {Object}
     */
    MAXIMUM_MAX_BUFFER_AHEAD: {
        text: 5 * 60 * 60,
    },
    /* eslint-enable @typescript-eslint/consistent-type-assertions */
    /* eslint-disable @typescript-eslint/consistent-type-assertions */
    /**
     * Maximum possible buffer behind for each type of buffer, to avoid too much
     * memory usage when playing for a long time.
     * Equal to Infinity if not defined here.
     * @type {Object}
     */
    MAXIMUM_MAX_BUFFER_BEHIND: {
        text: 5 * 60 * 60,
    },
    /* eslint-enable @typescript-eslint/consistent-type-assertions */
    /**
     * Default bitrate ceils initially set as the first content begins.
     *
     * If no track is found with a bitrate inferior or equal to the
     * bitrate there, the one with the lowest bitrate will be taken instead.
     *
     * Set to 0 for the lowest bitrate, Infinity for the highest.
     *
     * These values are only useful for the first content played, as consecutive
     * play will always take the last set one.
     * @type {Object}
     */
    DEFAULT_INITIAL_BITRATES: {
        audio: 0,
        video: 0,
        other: 0, // tracks which are not audio/video (text images).
        // Though those are generally at a single bitrate, so no adaptive
        // mechanism is triggered for them.
    },
    /* eslint-disable @typescript-eslint/consistent-type-assertions */
    /**
     * Default bitrate floor initially set to dictate the minimum bitrate the
     * ABR manager can automatically switch to.
     *
     * If no track is found with a quality superior or equal to the
     * bitrate there, the lowest bitrate will be taken instead.
     *
     * Set to Infinity to discard any limit in the ABR strategy.
     * @type {Object}
     */
    DEFAULT_MIN_BITRATES: {
        audio: 0,
        video: 0,
        other: 0, // tracks which are not audio/video
        // Though those are generally at a single bitrate, so no
        // adaptive mechanism is triggered for them.
    },
    /* eslint-enable @typescript-eslint/consistent-type-assertions */
    /* eslint-disable @typescript-eslint/consistent-type-assertions */
    /**
     * Default bitrate ceil initially set to dictate the maximum bitrate the
     * ABR manager can automatically switch to.
     *
     * If no track is found with a quality inferior or equal to the
     * bitrate there, the lowest bitrate will be taken instead.
     *
     * Set to Infinity to discard any limit in the ABR strategy.
     * @type {Object}
     */
    DEFAULT_MAX_BITRATES: {
        audio: Infinity,
        video: Infinity,
        other: Infinity, // tracks which are not audio/video
        // Though those are generally at a single bitrate, so no
        // adaptive mechanism is triggered for them.
    },
    /* eslint-enable @typescript-eslint/consistent-type-assertions */
    /**
     * Delay after which, if the page is hidden, the user is considered inactive
     * on the current video.
     *
     * Allow to enforce specific optimizations when the page is not shown.
     * @see DEFAULT_THROTTLE_WHEN_HIDDEN
     * @type {Number}
     */
    INACTIVITY_DELAY: 60 * 1000,
    /**
     * If true, if the player is in a "hidden" state for a delay specified by the
     * INACTIVITY DELAY config property, we throttle automatically to the video
     * representation with the lowest bitrate.
     * @type {Boolean}
     */
    DEFAULT_THROTTLE_WHEN_HIDDEN: false,
    /**
     * If true, if the video is considered in a "hidden" state for a delay specified by
     * the INACTIVITY DELAY config property, we throttle automatically to the video
     * representation with the lowest bitrate.
     * @type {Boolean}
     */
    DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN: false,
    /**
     * If true, the video representations you can switch to in adaptive mode
     * are limited by the video element's width.
     *
     * Basically in that case, we won't switch to a video Representation with
     * a width higher than the current width of the video HTMLElement.
     * @type {Boolean}
     */
    DEFAULT_LIMIT_VIDEO_WIDTH: false,
    /**
     * Default initial live gap considered if no presentation delay has been
     * suggested, in seconds.
     * @type {Number}
     */
    DEFAULT_LIVE_GAP: {
        DEFAULT: 10,
        LOW_LATENCY: 3,
    },
    /**
     * Maximum time, in seconds, the player should automatically skip when stalled
     * because of a current hole in the buffer.
     * Bear in mind that this might seek over not-yet-downloaded/pushed segments.
     * @type {Number}
     */
    BUFFER_DISCONTINUITY_THRESHOLD: 0.2,
    /**
     * When encountering small discontinuities, the RxPlayer may want, in specific
     * conditions, ignore those and let the browser seek over them iself (this
     * allows for example to avoid conflicts when both the browser and the
     * RxPlayer want to seek at a different position, sometimes leading to a
     * seeking loop).
     * In this case, we however still want to seek it ourselves if the browser
     * doesn't take the opportunity soon enough.
     *
     * This value specifies a delay after which a discontinuity ignored by the
     * RxPlayer is finally considered.
     * We want to maintain high enough to be sure the browser will not seek yet
     * small enough so this (arguably rare) situation won't lead to too much
     * waiting time.
     */
    FORCE_DISCONTINUITY_SEEK_DELAY: 2000,
    /**
     * Ratio used to know if an already loaded segment should be re-buffered.
     * We re-load the given segment if the current one times that ratio is
     * inferior to the new one.
     * @type {Number}
     */
    BITRATE_REBUFFERING_RATIO: 1.5,
    /**
     * Those are used when a "QuotaExceededError" error is received after
     * appending a new segment in the SourceBuffer.
     *
     * This error can arise when the browser's buffer is considered full.
     * In this case, the player goes into manual garbage collection (GC) mode.
     * @type {Object}
     */
    BUFFER_GC_GAPS: {
        /**
         * _Low_ gap (from current position) from which the buffer will be _garbage
         * collected_ (read removed from the buffer) when a QuotaExceededError is
         * received.
         * In seconds.
         * @type {Number}
         */
        CALM: 240,
        /**
         * _High_ gap (from current position) from which the buffer will be _garbage
         * collected_ (read removed from the buffer) when a QuotaExceededError is
         * received, if the low one does not clean up any buffer.
         * In seconds.
         * @type {Number}
         */
        BEEFY: 30,
    },
    /**
     * The default number of times a manifest request will be re-performed
     * when loaded/refreshed if the request finishes on an error which
     * justify an retry.
     *
     * Note that some errors do not use this counter:
     *   - if the error is not due to the xhr, no retry will be peformed
     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
     *     retry will be performed.
     *   - if it has a high chance of being due to the user being offline, a
     *     separate counter is used (see DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE).
     * @type Number
     */
    DEFAULT_MAX_MANIFEST_REQUEST_RETRY: 4,
    /**
     * The default number of times a segment request will be re-performed when
     * on error which justify a retry.
     *
     * Note that some errors do not use this counter:
     *   - if the error is not due to the xhr, no retry will be peformed
     *   - if the error is an HTTP error code, but not a 500-smthg or a 404, no
     *     retry will be performed.
     *   - if it has a high chance of being due to the user being offline, a
     *     separate counter is used (see DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE).
     * @type Number
     */
    DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR: 4,
    /**
     * Under some circonstances, we're able to tell that the user is offline (see
     * the compat files).
     * When this happens, and xhr requests fails due to an error event (you might
     * still be able to perform xhr offline, e.g. on localhost), you might want to
     * retry indefinitely or with a higher number of retry than if the error is
     * due to a CDN problem.
     *
     * A capped exponential backoff will still be used (like for an error code).
     * @type {Number}
     */
    DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE: Infinity,
    /**
     * Initial backoff delay when a segment / manifest download fails, in
     * milliseconds.
     *
     * This delay will then grow exponentally by power of twos (200, 400, 800
     * etc.)
     *
     * Please note that this delay is not exact, as it will be fuzzed.
     * @type {Number}
     */
    INITIAL_BACKOFF_DELAY_BASE: {
        REGULAR: 200,
        LOW_LATENCY: 50,
    },
    /**
     * Maximum backoff delay when a segment / manifest download fails, in
     * milliseconds.
     *
     * Please note that this delay is not exact, as it will be fuzzed.
     * @type {Number}
     */
    MAX_BACKOFF_DELAY_BASE: {
        REGULAR: 3000,
        LOW_LATENCY: 1000,
    },
    /**
     * Minimum interval at which timeupdate events will be "constructed". This
     * variable is for the "regular" mediasource strategy (that is, not for the
     * directfile API.
     *
     * Those events are the base of various important mechanisms in the player:
     *   - set the clock used to regularly check which segments should be loaded
     *   - set the clock for the ABR strategy.
     *   - used to trigger positionUpdate events.
     *
     * This common logic is for performance reasons, as we call multiple browser's
     * APIs which are useful for most of these.
     *
     * Keep in mind this is the minimum interval. This logic will also be
     * triggered when various events of the media element are received.
     * @type {Number}
     */
    SAMPLING_INTERVAL_MEDIASOURCE: 1000,
    /**
     * Same than SAMPLING_INTERVAL_MEDIASOURCE but for lowLatency mode.
     * @type {Number}
     */
    SAMPLING_INTERVAL_LOW_LATENCY: 250,
    /**
     * Same than SAMPLING_INTERVAL_MEDIASOURCE but for the directfile API.
     * @type {Number}
     */
    SAMPLING_INTERVAL_NO_MEDIASOURCE: 500,
    /**
     * Minimum number of bytes sampled before we trust the estimate.
     * If we have not sampled much data, our estimate may not be accurate
     * enough to trust.
     * If the total of bytes sampled is less than this value, we use a
     * default estimate.
     * This specific value is based on experimentations.
     * @type {Number}
     */
    ABR_MINIMUM_TOTAL_BYTES: 150e3,
    /**
     * Minimum number of bytes, under which samples are discarded.
     * Our models do not include latency information, so connection startup time
     * (time to first byte) is considered part of the download time.
     * Because of this, we should ignore very small downloads which would cause
     * our estimate to be too low.
     * This specific value is based on experimentation.
     * @type {Number}
     */
    ABR_MINIMUM_CHUNK_SIZE: 16e3,
    /**
     * Factor with which is multiplied the bandwidth estimate when the ABR is in
     * starvation mode.
     * @type {Object}
     */
    ABR_STARVATION_FACTOR: {
        DEFAULT: 0.72,
        LOW_LATENCY: 0.72,
    },
    /**
     * Factor with which is multiplied the bandwidth estimate when the ABR is not
     * in starvation mode.
     * @type {Object}
     */
    ABR_REGULAR_FACTOR: {
        DEFAULT: 0.8,
        LOW_LATENCY: 0.8,
    },
    /**
     * If a media buffer has less than ABR_STARVATION_GAP in seconds ahead of the
     * current position in its buffer, the ABR manager will go into starvation
     * mode.
     *
     * It gets out of starvation mode when the OUT_OF_STARVATION_GAP value is
     * reached.
     *
     * Under this starvation mode:
     *
     *   - the bandwidth considered will be a little lower than the one estimated
     *
     *   - the time the next important request take will be checked
     *     multiple times to detect when/if it takes too much time.
     *     If the request is considered too long, the bitrate will be hastily
     *     re-calculated from this single request.
     *
     * @type {Object}
     */
    ABR_STARVATION_GAP: {
        DEFAULT: 5,
        LOW_LATENCY: 5,
    },
    OUT_OF_STARVATION_GAP: {
        DEFAULT: 7,
        LOW_LATENCY: 7,
    },
    /**
     * This is a security to avoid going into starvation mode when the content is
     * ending (@see ABR_STARVATION_GAP).
     * Basically, we subtract that value from the global duration of the content
     * and we never enter "starvation mode" if the currently available buffer
     * (which equals to the current position + the available buffer ahead of it)
     * is equal or higher than this value.
     * @type {Number}
     */
    ABR_STARVATION_DURATION_DELTA: 0.1,
    /**
     * Half-life, in seconds for a fastly-evolving exponential weighted moving
     * average.
     * The lower it is, the faster the ABR logic will react to the bandwidth
     * falling quickly.
     * Should be kept to a lower number than ABR_SLOW_EMA for coherency reasons.
     * @type {Number}
     */
    ABR_FAST_EMA: 2,
    /**
     * Half-life, in seconds for a slowly-evolving exponential weighted moving
     * average.
     * The lower it is, the faster the ABR logic is going to react to recent
     * bandwidth variation, on the higher and on the lower side.
     * Should be kept to a higher number than ABR_FAST_EMA for coherency reasons.
     * @type {Number}
     */
    ABR_SLOW_EMA: 10,
    /**
     * Number of seconds ahead in the buffer after which playback will resume when
     * seeking on an unbuffered part of the content.
     * @type {Number}
     */
    RESUME_GAP_AFTER_SEEKING: {
        DEFAULT: 1.5,
        LOW_LATENCY: 0.5,
    },
    /**
     * Number of seconds ahead in the buffer after which playback will resume when
     * the player was stalled due to a low readyState.
     * @type {Number}
     */
    RESUME_GAP_AFTER_NOT_ENOUGH_DATA: {
        DEFAULT: 0.5,
        LOW_LATENCY: 0.5,
    },
    /**
     * Number of seconds ahead in the buffer after which playback will resume
     * after the player went through a buffering step.
     * @type {Number}
     */
    RESUME_GAP_AFTER_BUFFERING: {
        DEFAULT: 5,
        LOW_LATENCY: 0.5,
    },
    /**
     * Maximum number of seconds in the buffer based on which a "stalling"
     * strategy will be considered:
     * The player will pause playback to get enough time building a sufficient
     * buffer. This mostly happen when seeking in an unbuffered part or when
     * buffering.
     * @type {Number}
     */
    STALL_GAP: {
        DEFAULT: 0.5,
        LOW_LATENCY: 0.2,
    },
    /**
     * Maximum authorized difference between what we calculated to be the
     * beginning or end of the segment in a media buffer and what we
     * actually are noticing now.
     *
     * If the segment seems to have removed more than this size in seconds, we
     * will infer that the segment has been garbage collected and we might try to
     * re-download it.
     * @type {Number}
     */
    MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT: 0.15,
    /**
     * The maximum authorized difference, in seconds, between the real buffered
     * time of a given chunk and what the segment information of the Manifest
     * tells us.
     *
     * Setting a value too high can lead to parts of the media buffer being
     * linked to the wrong segments and to segments wrongly believed to be still
     * complete (instead of garbage collected).
     *
     * Setting a value too low can lead to parts of the media buffer not being
     * linked to the concerned segment and to segments wrongly believed to be
     * partly garbage collected (instead of complete segments).
     * @type {Number}
     */
    MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE: 0.4,
    /**
     * The maximum authorized difference, in seconds, between the duration a
     * segment should have according to the Manifest and the actual duration it
     * seems to have once pushed to the media buffer.
     *
     * Setting a value too high can lead to parts of the media buffer being
     * linked to the wrong segments and to segments wrongly believed to be still
     * complete (instead of garbage collected).
     *
     * Setting a value too low can lead to parts of the media buffer not being
     * linked to the concerned segment and to segments wrongly believed to be
     * partly garbage collected (instead of complete segments). This last point
     * could lead to unnecessary segment re-downloading.
     * @type {Number}
     */
    MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE: 0.3,
    /**
     * Minimum duration in seconds a segment should be into a buffered range to be
     * considered as part of that range.
     * Segments which have less than this amount of time "linked" to a buffered
     * range will be deleted.
     *
     * Setting a value too low can lead in worst-case scenarios to segments being
     * wrongly linked to the next or previous range it is truly linked too (if
     * those ranges are too close).
     *
     * Setting a value too high can lead to part of the buffer not being assigned
     * any segment. It also limits the minimum duration a segment can be.
     *
     * TODO As of now, this limits the minimum size a complete segment can be. A
     * better logic would be to also consider the duration of a segment. Though
     * this logic could lead to bugs with the current code.
     * @type {Number}
     */
    MINIMUM_SEGMENT_SIZE: 0.005,
    /**
     * Append windows allow to filter media data from segments if they are outside
     * a given limit.
     * Coded frames with presentation timestamp within this range are allowed to
     * be appended to the media buffer while coded frames outside this range are
     * filtered out.
     *
     * Those are often set to be the start and end of the "Period" the segment is
     * in.
     * However, we noticed that some browsers were too aggressive when the exact
     * limits were set: more data than needed was removed, often leading to
     * discontinuities.
     *
     * Those securities are added to the set windows (substracted from the window
     * start and added to the window end) to avoid those problems.
     * @type {Object}
     */
    APPEND_WINDOW_SECURITIES: {
        START: 0.2,
        END: 0.1,
    },
    /**
     * Maximum interval at which text tracks are refreshed in an "html"
     * textTrackMode.
     *
     * The text tracks are also refreshed on various video events, this interval
     * will only trigger a refresh if none of those events was received during
     * that timespan.
     *
     * Note that if the TextTrack cue did not change between two intervals or
     * events, the DOM won't be refreshed.
     * The TextTrack cues structure is also optimized for fast retrieval.
     * We should thus not have much of a performance impact here if we set a low
     * interval.
     *
     * @type {Number}
     */
    MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL: 50,
    /**
     * On browsers with no ResizeObserver API, this will be the interval in
     * milliseconds at which we should check if the text track element has
     * changed its size, and updates proportional text-track data accordingly
     * (like a proportional font-size).
     *
     * This is only used:
     *   - in an "html" textTrackMode
     *   - when some styling is proportional in the text track data
     *
     * Putting a value too low will render faster but might use to much proc time.
     * Putting a value too high might provoke a re-render too late after the user
     * changed the element's size (e.g. when going to fullscreen mode).
     *
     * @type {Number}
     */
    TEXT_TRACK_SIZE_CHECKS_INTERVAL: 250,
    /**
     * The Buffer padding is a time offset from the current time that affects
     * the buffer.
     *
     * Basically, from a given time, if the current buffer gap number (time
     * between the current time and the end of the downloaded buffer) is above
     * the padding described here (of the corresponding type), we won't
     * reschedule segments for that range.
     *
     * This is to avoid excessive re-buffering.
     *
     * Keeping the padding too low would increase the risk of re-bufferings.
     *
     * Keeping the padding too high would delay visible quality increase.
     *
     * @type {Object}
     */
    BUFFER_PADDING: {
        audio: 1,
        video: 3,
        other: 1, // tracks which are not audio/video (text images).
    },
    /**
     * Segments of different types are downloaded by steps:
     *
     *   - first the audio/video/text Segments which are immediately needed
     *
     *   - then once every of those Segments have been downloaded, less-needed
     *     Segments
     *
     *   - then once every of those less-needed Segments have been downloaded,
     *     even less-needed Segments
     *
     *   - etc.
     *
     * This stepped download strategy allows to make a better use of network
     * ressources.
     *
     * For example, if more than sufficient audio buffer has been downloaded but
     * the immediately-needed video Segment is still pending its request, we might
     * be in a situation of rebuffering.
     * In that case, a better strategy would be to make sure every network
     * ressource is allocated for this video Segment before rebuffering happens.
     *
     * This is where those steps become useful.
     *
     * --
     *
     * The numbers defined in this Array describe what the steps are.
     *
     * Each number is linked to a distance from the current playing position, in
     * seconds.
     * Distances which will be used as limit points, from which a new step is
     * reached (see example).
     *
     * In the RxPlayer's code, each step is then translated in to a priority
     * number.
     * The lower is that number, the lower is the step and the lower is the step,
     * the higher is the priority.
     *
     * Note: You can set an empty array to deactivate the steps feature (every
     * Segments have the same priority).
     *
     * @example
     *
     * let's imagine the following SEGMENT_PRIORITIES_STEPS array:
     * [5, 11, 17, 25]
     *
     * To link each Segments to a corresponding priority number (and thus to a
     * specific step), we have to consider the distance between the current
     * position and the start time of the Segment.
     *
     * We have in our example 5 groups, which correspond to the following possible
     * distances:
     *   1. inferior to 5 => first step (priority number = 0)
     *   2. between 5 and 11 => second step (priority number = 1)
     *   3. between 11 and 17 => third step (priority number = 2)
     *   4. between 17 and 25 => fourth step (priority number = 3)
     *   5. superior to 25 => fifth step (priority number = 4)
     *
     * Segments corresponding to a lower-step will need to all be downloaded
     * before Segments of a newer step begin.
     *
     * @type {Array.<Number>}
     */
    SEGMENT_PRIORITIES_STEPS: [2,
        4,
        8,
        12,
        18,
        25],
    // 7th Step (priority number = 6):  >= 25
    /**
     * Some segment requests are said to be "high priority".
     *
     * Requests in that category once done will cancel any segment request that
     * has a low priority number (see `SEGMENT_PRIORITIES_STEPS`) - meaning a
     * priority number equal to `MIN_CANCELABLE_PRIORITY` or more.
     *
     * Enter here the last priority number that is considered high priority
     * (beginning by the first step, which has the priority number `0`).
     * @type {number}
     */
    MAX_HIGH_PRIORITY_LEVEL: 1,
    /**
     * Enter here the first priority step (see `SEGMENT_PRIORITIES_STEPS`) that
     * will be considered as low priority.
     *
     * Segment requests with a low priority will be cancelled if a high priority
     * segment request (see MAX_HIGH_PRIORITY_LEVEL) is scheduled while they are
     * pending.
     *
     * This number should be strictly superior to the value indicated in
     * `MAX_HIGH_PRIORITY_LEVEL`.
     * @type {number}
     */
    MIN_CANCELABLE_PRIORITY: 3,
    /**
     * Robustnesses used in the {audio,video}Capabilities of the
     * MediaKeySystemConfiguration (EME).
     *
     * Only used for widevine keysystems.
     *
     * Defined in order of importance (first will be tested first etc.)
     * @type {Array.<string>}
     */
    EME_DEFAULT_WIDEVINE_ROBUSTNESSES: ["HW_SECURE_ALL",
        "HW_SECURE_DECODE",
        "HW_SECURE_CRYPTO",
        "SW_SECURE_DECODE",
        "SW_SECURE_CRYPTO"],
    /**
     * Link canonical key systems names to their respective reverse domain name,
     * used in the EME APIs.
     * This allows to have a simpler API, where users just need to set "widevine"
     * or "playready" as a keySystem.
     * @type {Object}
     */
    /* eslint-disable @typescript-eslint/consistent-type-assertions */
    EME_KEY_SYSTEMS: {
        clearkey: ["webkit-org.w3.clearkey",
            "org.w3.clearkey"],
        widevine: ["com.widevine.alpha"],
        playready: ["com.microsoft.playready",
            "com.chromecast.playready",
            "com.youtube.playready"],
        fairplay: ["com.apple.fps.1_0"],
    },
    /* eslint-enable @typescript-eslint/consistent-type-assertions */
    /**
     * The Manifest parsing logic has a notion of "unsafeMode" which allows to
     * speed-up this process a lot with a small risk of de-synchronization with
     * what actually is on the server.
     * Because using that mode is risky, and can lead to all sort of problems, we
     * regularly should fall back to a regular "safe" parsing every once in a
     * while.
     * This value defines how many consecutive time maximum the "unsafeMode"
     * parsing can be done.
     */
    MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE: 10,
    /**
     * Minimum time spent parsing the Manifest before we can authorize parsing
     * it in an "unsafeMode", to speed-up the process with a little risk.
     * Please note that this parsing time also sometimes includes idle time such
     * as when the parser is waiting for a request to finish.
     */
    MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE: 200,
    /**
     * Minimum amount of <S> elements in a DASH MPD's <SegmentTimeline> element
     * necessary to begin parsing the current SegmentTimeline element in an
     * unsafe manner (meaning: with risks of de-synchronization).
     * This is only done when the "unsafeMode" parsing mode is enabled.
     */
    MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY: 300,
    /**
     * When we detect that the local Manifest might be out-of-sync with the
     * server's one, we schedule a Manifest refresh.
     * However, as this "unsynchronization" is only a theory and as we do not want
     * to send too many Manifest requests, we keep a delay between the last
     * Manifest refresh done and that one.
     * This value indicates which delay we want. Note that the Manifest could
     * still be refreshed before this delay for other reasons.
     * @type {Number}
     */
    OUT_OF_SYNC_MANIFEST_REFRESH_DELAY: 3000,
    /**
     * When a partial Manifest update (that is an update with a partial sub-set
     * of the Manifest) fails, we will perform an update with the whole Manifest
     * instead.
     * To not overload the client - as parsing a Manifest can be resource heavy -
     * we set a minimum delay to wait before doing the corresponding request.
     * @type {Number}
     */
    FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY: 3000,
    /**
     * DASH Manifest based on a SegmentTimeline should normally have an
     * MPD@minimumUpdatePeriod attribute which should be sufficient to
     * know when to refresh it.
     * However, there is a specific case, for when it is equal to 0.
     * As of DASH-IF IOP (valid in v4.3), when a DASH's MPD set a
     * MPD@minimumUpdatePeriod to `0`, a client should not refresh the MPD
     * unless told to do so through inband events, in the stream.
     * In reality however, we found it to not always be the case (even with
     * DASH-IF own streams) and moreover to not always be the best thing to do.
     * We prefer to refresh in average at a regular interval when we do not have
     * this information.
     * /!\ This value is expressed in seconds.
     */
    DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0: 3,
    /**
     * Max simultaneous MediaKeySessions that will be kept as a cache to avoid
     * doing superfluous license requests.
     * If this number is reached, any new session creation will close the oldest
     * one.
     * @type {Number}
     */
    EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS: 50,
    /**
     * When playing contents with a persistent license, we will usually store some
     * information related to that MediaKeySession, to be able to play it at a
     * later time.
     *
     * Those information are removed once a MediaKeySession is not considered
     * as "usable" anymore. But to know that, the RxPlayer has to load it.
     *
     * But the RxPlayer does not re-load every persisted MediaKeySession every
     * time to check each one of them one by one, as this would not be a
     * performant thing to do.
     *
     * So this is only done when and if the corresponding content is encountered
     * again and only if it contains the same initialization data.
     *
     * We have to consider that those "information" contain binary data which can
     * be of arbitrary length. Size taken by an array of them can relatively
     * rapidly take a lot of space in JS memory.
     *
     * So to avoid this storage to take too much space (would it be in the chosen
     * browser's storage or in JS memory), we now set a higher bound for the
     * amount of MediaKeySession information that can be stored at the same time.
     *
     * I set the value of 1000 here, as it seems big enough to not be considered a
     * problem (though it can become one, when contents have a lot of keys per
     * content), and still low enough so it should not cause much problem (my
     * method to choose that number was to work with power of 10s and choosing the
     * amount which seemed the most sensible one).
     *
     * This wasn't battle-tested however.
     */
    EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION: 1000,
    /**
     * Attempts to closing a MediaKeySession can fail, most likely because the
     * MediaKeySession was not initialized yet.
     * When we consider that we're in one of these case, we will retry to close it.
     *
     * To avoid going into an infinite loop of retry, this number indicates a
     * maximum number of attemps we're going to make (`0` meaning no retry at all,
     * `1` only one retry and so on).
     */
    EME_SESSION_CLOSING_MAX_RETRY: 5,
    /**
     * When closing a MediaKeySession failed due to the reasons explained for the
     * `EME_SESSION_CLOSING_MAX_RETRY` config property, we may (among other
     * triggers) choose to wait a delay raising exponentially at each retry before
     * that new attempt.
     * This value indicates the initial value for this delay, in milliseconds.
     */
    EME_SESSION_CLOSING_INITIAL_DELAY: 100,
    /**
     * When closing a MediaKeySession failed due to the reasons explained for the
     * `EME_SESSION_CLOSING_MAX_RETRY` config property, we may (among other
     * triggers) choose to wait a delay raising exponentially at each retry before
     * that new attempt.
     * This value indicates the maximum possible value for this delay, in
     * milliseconds.
     */
    EME_SESSION_CLOSING_MAX_DELAY: 1000,
    /**
     * After loading a persistent MediaKeySession, the RxPlayer needs to ensure
     * that its keys still allow to decrypt a content.
     *
     * However on some browsers, the `keyStatuses` property that we used to check
     * the keys' satuses linked to that session can be empty for some time after
     * the loading operation is done.
     *
     * This value allows to configure a delay in milliseconds that will be the
     * maximum time we will wait after a persistent session is loaded.
     * If after that time, the `keyStatuses` property is still empty, we will
     * consider that session as not usable.
     */
    EME_WAITING_DELAY_LOADED_SESSION_EMPTY_KEYSTATUSES: 100,
    /**
     * The player relies on browser events and properties to update its status to
     * "ENDED".
     *
     * Sadly in some cases, like in Chrome 54, this event is never triggered on
     * some contents probably due to a browser bug.
     *
     * This threshold resolves this issue by forcing the status to "ENDED" when:
     *   1. the player is stalling
     *   2. the absolute difference between current playback time and duration is
     *      under this value
     *
     * If set to null, this workaround is disabled and the player only relies on
     * browser events.
     *
     * @type {Number|null}
     */
    FORCED_ENDED_THRESHOLD: 0.001,
    /**
     * Maximum duration from the current position we will let in the buffer when
     * switching an Adaptation of a given type.
     *
     * For example, if we have ``text: { before: 1, after: 4 }``, it means that
     * when switching subtitles, we will let 1 second before and 4 second after
     * the current position in the previous language (until the new segments
     * overwrite it).
     * This is to allow smooth transitions and avoid de-synchronization that
     * can happen when removing the content being decoded.
     * @type {Object}
     */
    ADAPTATION_SWITCH_BUFFER_PADDINGS: {
        video: { before: 2, after: 2.5 },
        audio: { before: 2, after: 2.5 },
        text: { before: 0, after: 0 },
        image: { before: 0, after: 0 }, // not managed natively, so no problem here
    },
    /**
     * Interval, in milliseconds, at which we should manually flush
     * SourceBuffers.
     * Some browsers (happened with firefox 66) sometimes "forget" to send us
     * `update` or `updateend` events.
     * In that case, we're completely unable to continue the queue here and
     * stay locked in a waiting state.
     * This interval is here to check at regular intervals if the underlying
     * SourceBuffer is currently updating.
     * @type {Number}
     */
    SOURCE_BUFFER_FLUSHING_INTERVAL: 500,
    /**
     * Any already-pushed segment starting before or at the current position +
     * CONTENT_REPLACEMENT_PADDING won't be replaced by new segments.
     *
     * This allows to avoid overwriting segments that are currently being decoded
     * as we encountered many decoding issues when doing so.
     * @type {Number} - in seconds
     */
    CONTENT_REPLACEMENT_PADDING: 1.2,
    /**
     * For video and audio segments, determines two thresholds below which :
     * - The segment is considered as loaded from cache
     * - The segment may be loaded from cache depending on the previous request
     */
    CACHE_LOAD_DURATION_THRESHOLDS: {
        video: 50,
        audio: 10,
    },
    /** Interval we will use to poll for checking if an event shall be emitted */
    STREAM_EVENT_EMITTER_POLL_INTERVAL: 250,
    /**
     * In Javascript, numbers are encoded in a way that a floating number may be
     * represented internally with a rounding error. When multiplying times in
     * seconds by the timescale, we've encoutered cases were the rounding error
     * was amplified by a factor which is about the timescale.
     * Example :
     * (192797480.641122).toFixed(20) = 192797480.64112201333045959473
     * (error is 0.0000000133...)
     * 192797480.641122 * 10000000 = 1927974806411220.2 (error is 0.2)
     * 192797480.641122 * 10000000 * 4 = 7711899225644881 (error is 1)
     * The error is much more significant here, once the timescale has been
     * applied.
     * Thus, we consider that our max tolerable rounding error is 1ms.
     * It is much more than max rounding errors when seen into practice,
     * and not significant from the media loss perspective.
     */
    DEFAULT_MAXIMUM_TIME_ROUNDING_ERROR: 1 / 1000,
});


/***/ }),

/***/ 22704:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ MediaElementTrackChoiceManager)
/* harmony export */ });
/* harmony import */ var _utils_event_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61603);
/* harmony import */ var _utils_languages__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46211);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Check if track array is different from an other one
 * @param {Array.<Object>} oldTrackArray
 * @param {Array.<Object>} newTrackArray
 * @returns {boolean}
 */
function areTrackArraysDifferent(oldTrackArray, newTrackArray) {
    var _a;
    if (newTrackArray.length !== oldTrackArray.length) {
        return true;
    }
    for (let i = 0; i < newTrackArray.length; i++) {
        if (newTrackArray[i].nativeTrack !== ((_a = oldTrackArray[i]) === null || _a === void 0 ? void 0 : _a.nativeTrack)) {
            return true;
        }
    }
    return false;
}
/**
 * Create audio tracks from native audio tracks.
 * @param {AudioTrackList} audioTracks
 * @returns {Array.<Object>}
 */
function createAudioTracks(audioTracks) {
    var _a;
    const newAudioTracks = [];
    const languagesOccurences = {};
    for (let i = 0; i < audioTracks.length; i++) {
        const audioTrack = audioTracks[i];
        const language = audioTrack.language === "" ? "nolang" :
            audioTrack.language;
        const occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;
        const id = "gen_audio_" +
            language +
            "_" +
            occurences.toString();
        languagesOccurences[language] = occurences + 1;
        const track = { language: audioTrack.language,
            id,
            normalized: (0,_utils_languages__WEBPACK_IMPORTED_MODULE_0__/* .default */ .ZP)(audioTrack.language),
            audioDescription: false, representations: [] };
        newAudioTracks.push({ track,
            nativeTrack: audioTrack });
    }
    return newAudioTracks;
}
/**
 * Create text tracks from native text tracks.
 * @param {TextTrackList} textTracks
 * @returns {Array.<Object>}
 */
function createTextTracks(textTracks) {
    var _a;
    const newTextTracks = [];
    const languagesOccurences = {};
    for (let i = 0; i < textTracks.length; i++) {
        const textTrack = textTracks[i];
        const language = textTrack.language === "" ? "nolang" :
            textTrack.language;
        const occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;
        const id = "gen_text_" +
            language +
            "_" +
            occurences.toString();
        languagesOccurences[language] = occurences + 1;
        const track = { language: textTrack.language,
            id,
            normalized: (0,_utils_languages__WEBPACK_IMPORTED_MODULE_0__/* .default */ .ZP)(textTrack.language),
            closedCaption: textTrack.kind === "captions" };
        newTextTracks.push({ track,
            nativeTrack: textTrack });
    }
    return newTextTracks;
}
/**
 * Create video tracks from native video tracks.
 * @param {VideoTrackList} videoTracks
 * @returns {Array.<Object>}
 */
function createVideoTracks(videoTracks) {
    var _a;
    const newVideoTracks = [];
    const languagesOccurences = {};
    for (let i = 0; i < videoTracks.length; i++) {
        const videoTrack = videoTracks[i];
        const language = videoTrack.language === "" ? "nolang" :
            videoTrack.language;
        const occurences = (_a = languagesOccurences[language]) !== null && _a !== void 0 ? _a : 1;
        const id = "gen_video_" +
            language +
            "_" +
            occurences.toString();
        languagesOccurences[language] = occurences + 1;
        newVideoTracks.push({ track: { id, representations: [] }, nativeTrack: videoTrack });
    }
    return newVideoTracks;
}
/**
 * Manage video, audio and text tracks for current direct file content.
 * @class MediaElementTrackChoiceManager
 */
class MediaElementTrackChoiceManager extends _utils_event_emitter__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z {
    constructor(mediaElement) {
        var _a, _b, _c;
        super();
        this._preferredAudioTracks = [];
        this._preferredTextTracks = [];
        this._preferredVideoTracks = [];
        // TODO In practice, the audio/video/text tracks API are not always implemented on
        // the media element, although Typescript HTMLMediaElement types tend to mean
        // that can't be undefined.
        this._nativeAudioTracks = mediaElement.audioTracks;
        this._nativeVideoTracks = mediaElement.videoTracks;
        this._nativeTextTracks = mediaElement.textTracks;
        this._audioTracks =
            this._nativeAudioTracks !== undefined ? createAudioTracks(this._nativeAudioTracks) :
                [];
        this._videoTracks =
            this._nativeVideoTracks !== undefined ? createVideoTracks(this._nativeVideoTracks) :
                [];
        this._textTracks =
            this._nativeTextTracks !== undefined ? createTextTracks(this._nativeTextTracks) :
                [];
        this._lastEmittedNativeAudioTrack = (_a = this._getPrivateChosenAudioTrack()) === null || _a === void 0 ? void 0 : _a.nativeTrack;
        this._lastEmittedNativeVideoTrack = (_b = this._getPrivateChosenVideoTrack()) === null || _b === void 0 ? void 0 : _b.nativeTrack;
        this._lastEmittedNativeTextTrack = (_c = this._getPrivateChosenTextTrack()) === null || _c === void 0 ? void 0 : _c.nativeTrack;
        this._handleNativeTracksCallbacks();
    }
    /**
     * Set the list of preferred audio tracks, in preference order.
     * @param {Array.<Object>} preferredAudioTracks
     * @param {boolean} shouldApply - `true` if those preferences should be
     * applied on the currently loaded Period. `false` if it should only
     * be applied to new content.
     */
    setPreferredAudioTracks(preferredAudioTracks, shouldApply) {
        this._preferredAudioTracks = preferredAudioTracks;
        if (shouldApply) {
            this._applyAudioPreferences();
        }
    }
    /**
     * Set the list of preferred text tracks, in preference order.
     * @param {Array.<Object>} preferredTextTracks
     * @param {boolean} shouldApply - `true` if those preferences should be
     * applied on the currently loaded Period. `false` if it should only
     * be applied to new content.
     */
    setPreferredTextTracks(preferredTextTracks, shouldApply) {
        this._preferredTextTracks = preferredTextTracks;
        if (shouldApply) {
            this._applyTextPreferences();
        }
    }
    /**
     * Set the list of preferred video tracks, in preference order.
     * @param {Array.<Object>} preferredVideoTracks
     * @param {boolean} shouldApply - `true` if those preferences should be
     * applied on the currently loaded Period. `false` if it should only
     * be applied to new content.
     */
    setPreferredVideoTracks(preferredVideoTracks, shouldApply) {
        this._preferredVideoTracks = preferredVideoTracks;
        if (shouldApply) {
            this._applyVideoPreferences();
        }
    }
    /**
     * Update the currently active audio track by setting the wanted audio track's
     * ID property.
     * Throws if the wanted audio track is not found.
     * @param {string|number|undefined} id
     */
    setAudioTrackById(id) {
        for (let i = 0; i < this._audioTracks.length; i++) {
            const { track, nativeTrack } = this._audioTracks[i];
            if (track.id === id) {
                nativeTrack.enabled = true;
                this._audioTrackLockedOn = nativeTrack;
                return;
            }
        }
        throw new Error("Audio track not found.");
    }
    /**
     * Disable the currently-active text track, if one.
     */
    disableTextTrack() {
        disableTextTracks(this._textTracks);
        this._textTrackLockedOn = null;
    }
    /**
     * Update the currently active text track by setting the wanted text track's
     * ID property.
     * Throws if the wanted text track is not found.
     * @param {string|number|undefined} id
     */
    setTextTrackById(id) {
        let hasSetTrack = false;
        for (let i = 0; i < this._textTracks.length; i++) {
            const { track, nativeTrack } = this._textTracks[i];
            if (track.id === id) {
                nativeTrack.mode = "showing";
                hasSetTrack = true;
                this._textTrackLockedOn = nativeTrack;
            }
            else if (nativeTrack.mode === "showing" || nativeTrack.mode === "hidden") {
                nativeTrack.mode = "disabled";
            }
        }
        if (!hasSetTrack) {
            throw new Error("Text track not found.");
        }
    }
    /**
     * Disable the currently-active video track, if one.
     */
    disableVideoTrack() {
        disableVideoTracks(this._videoTracks);
        this._videoTrackLockedOn = null;
    }
    /**
     * Update the currently active video track by setting the wanted video track's
     * ID property.
     * Throws if the wanted video track is not found.
     * @param {string|number|undefined} id
     */
    setVideoTrackById(id) {
        for (let i = 0; i < this._videoTracks.length; i++) {
            const { track, nativeTrack } = this._videoTracks[i];
            if (track.id === id) {
                nativeTrack.selected = true;
                this._videoTrackLockedOn = nativeTrack;
                return;
            }
        }
        throw new Error("Video track not found.");
    }
    /**
     * Returns the currently active audio track.
     * Returns `null` if no audio track is active.
     * Returns `undefined` if we cannot know which audio track is active.
     * @returns {Object|null|undefined}
     */
    getChosenAudioTrack() {
        const chosenPrivateAudioTrack = this._getPrivateChosenAudioTrack();
        if (chosenPrivateAudioTrack != null) {
            return chosenPrivateAudioTrack.track;
        }
        return chosenPrivateAudioTrack;
    }
    /**
     * Returns the currently active text track.
     * Returns `null` if no text track is active.
     * Returns `undefined` if we cannot know which text track is active.
     * @returns {Object|null|undefined}
     */
    getChosenTextTrack() {
        const chosenPrivateTextTrack = this._getPrivateChosenTextTrack();
        if (chosenPrivateTextTrack != null) {
            return chosenPrivateTextTrack.track;
        }
        return chosenPrivateTextTrack;
    }
    /**
     * Returns the currently active video track.
     * Returns `null` if no video track is active.
     * Returns `undefined` if we cannot know which video track is active.
     * @returns {Object|null|undefined}
     */
    getChosenVideoTrack() {
        const chosenPrivateVideoTrack = this._getPrivateChosenVideoTrack();
        if (chosenPrivateVideoTrack != null) {
            return chosenPrivateVideoTrack.track;
        }
        return chosenPrivateVideoTrack;
    }
    /**
     * Returns a description of every available audio tracks.
     * @returns {Array.<Object>}
     */
    getAvailableAudioTracks() {
        return this._audioTracks.map(({ track, nativeTrack }) => {
            return { id: track.id,
                language: track.language,
                normalized: track.normalized,
                audioDescription: track.audioDescription,
                active: nativeTrack.enabled,
                representations: track.representations };
        });
    }
    /**
     * Returns a description of every available text tracks.
     * @returns {Array.<Object>}
     */
    getAvailableTextTracks() {
        return this._textTracks.map(({ track, nativeTrack }) => {
            return { id: track.id,
                language: track.language,
                normalized: track.normalized,
                closedCaption: track.closedCaption,
                active: nativeTrack.mode === "showing" };
        });
    }
    /**
     * Returns a description of every available video tracks.
     * @returns {Array.<Object>}
     */
    getAvailableVideoTracks() {
        return this._videoTracks.map(({ track, nativeTrack }) => {
            return { id: track.id,
                representations: track.representations,
                active: nativeTrack.selected };
        });
    }
    /**
     * Free the resources used by the MediaElementTrackChoiceManager.
     */
    dispose() {
        if (this._nativeVideoTracks !== undefined) {
            this._nativeVideoTracks.onchange = null;
            this._nativeVideoTracks.onaddtrack = null;
            this._nativeVideoTracks.onremovetrack = null;
        }
        if (this._nativeAudioTracks !== undefined) {
            this._nativeAudioTracks.onchange = null;
            this._nativeAudioTracks.onaddtrack = null;
            this._nativeAudioTracks.onremovetrack = null;
        }
        if (this._nativeTextTracks !== undefined) {
            this._nativeTextTracks.onchange = null;
            this._nativeTextTracks.onaddtrack = null;
            this._nativeTextTracks.onremovetrack = null;
        }
        this.removeEventListener();
    }
    /**
     * Get information about the currently chosen audio track.
     * `undefined` if we cannot know it.
     * `null` if no audio track is chosen.
     * @returns {Object|undefined|null}
     */
    _getPrivateChosenAudioTrack() {
        if (this._nativeAudioTracks === undefined) {
            return undefined;
        }
        for (let i = 0; i < this._audioTracks.length; i++) {
            const audioTrack = this._audioTracks[i];
            if (audioTrack.nativeTrack.enabled) {
                return audioTrack;
            }
        }
        return null;
    }
    /**
     * Get information about the currently chosen video track.
     * `undefined` if we cannot know it.
     * `null` if no video track is chosen.
     * @returns {Object|undefined|null}
     */
    _getPrivateChosenVideoTrack() {
        if (this._nativeVideoTracks === undefined) {
            return undefined;
        }
        for (let i = 0; i < this._videoTracks.length; i++) {
            const videoTrack = this._videoTracks[i];
            if (videoTrack.nativeTrack.selected) {
                return videoTrack;
            }
        }
        return null;
    }
    /**
     * Get information about the currently chosen text track.
     * `undefined` if we cannot know it.
     * `null` if no text track is chosen.
     * @returns {Object|undefined|null}
     */
    _getPrivateChosenTextTrack() {
        if (this._nativeTextTracks === undefined) {
            return undefined;
        }
        for (let i = 0; i < this._textTracks.length; i++) {
            const textTrack = this._textTracks[i];
            if (textTrack.nativeTrack.mode === "showing") {
                return textTrack;
            }
        }
        return null;
    }
    /**
     * Iterate over every available audio tracks on the media element and either:
     *   - if the last manually set audio track is found, set that one.
     *   - if not, set the most preferred one
     *   - if we still do not find an optimal track, let the one chosen by default
     */
    _setOptimalAudioTrack() {
        // First check if the last set track is available, set it if that's the case
        if (this._audioTrackLockedOn !== undefined) {
            for (let i = 0; i < this._audioTracks.length; i++) {
                const { nativeTrack } = this._audioTracks[i];
                if (nativeTrack === this._audioTrackLockedOn) {
                    nativeTrack.enabled = true;
                    return;
                }
            }
        }
        this._applyAudioPreferences();
    }
    /**
     * Try to find a track corresponding to the audio track preferences:
     *   - if found, set it as the active track
     *   - if not found, let the chosen audio track by default
     */
    _applyAudioPreferences() {
        // Re-set the last manually set audio track
        this._audioTrackLockedOn = undefined;
        const preferredAudioTracks = this._preferredAudioTracks;
        for (let i = 0; i < preferredAudioTracks.length; i++) {
            const track = preferredAudioTracks[i];
            if (track !== null && track.language !== undefined) {
                const normalized = (0,_utils_languages__WEBPACK_IMPORTED_MODULE_0__/* .default */ .ZP)(track.language);
                for (let j = 0; j < this._audioTracks.length; j++) {
                    const audioTrack = this._audioTracks[j];
                    if (audioTrack.track.normalized === normalized &&
                        audioTrack.track.audioDescription === track.audioDescription) {
                        audioTrack.nativeTrack.enabled = true;
                        return;
                    }
                }
            }
        }
        // else just let the default one instead
    }
    /**
     * Iterate over every available text tracks on the media element and either:
     *   - if the last manually set text track is found, set that one.
     *   - if not, set the most preferred one
     *   - if we still do not find an optimal track, just disable it.
     */
    _setOptimalTextTrack() {
        // First check if the last set track is available, set it if that's the case
        if (this._textTrackLockedOn === null) {
            disableTextTracks(this._textTracks);
            return;
        }
        else if (this._textTrackLockedOn !== undefined) {
            for (let i = 0; i < this._textTracks.length; i++) {
                const { nativeTrack } = this._textTracks[i];
                if (nativeTrack === this._textTrackLockedOn) {
                    // disable the rest
                    disableAllTextTracksBut(this._textTracks, nativeTrack);
                    if (nativeTrack.mode !== "showing") {
                        nativeTrack.mode = "showing";
                    }
                    return;
                }
            }
        }
        // Else set the preferred one
        this._applyTextPreferences();
    }
    /**
     * Try to find a track corresponding to the text track preferences:
     *   - if found, set it as the active track
     *   - if not found, let the chosen text track by default
     */
    _applyTextPreferences() {
        // Re-set the last manually set audio track
        this._textTrackLockedOn = undefined;
        const preferredTextTracks = this._preferredTextTracks;
        for (let i = 0; i < preferredTextTracks.length; i++) {
            const track = preferredTextTracks[i];
            if (track === null) {
                disableTextTracks(this._textTracks);
                return;
            }
            const normalized = (0,_utils_languages__WEBPACK_IMPORTED_MODULE_0__/* .default */ .ZP)(track.language);
            for (let j = 0; j < this._textTracks.length; j++) {
                const textTrack = this._textTracks[j];
                if (textTrack.track.normalized === normalized &&
                    textTrack.track.closedCaption === track.closedCaption) {
                    // disable the rest
                    disableAllTextTracksBut(this._textTracks, textTrack.nativeTrack);
                    if (textTrack.nativeTrack.mode !== "showing") {
                        textTrack.nativeTrack.mode = "showing";
                    }
                    return;
                }
            }
        }
        // Else just disable text tracks
        disableTextTracks(this._textTracks);
    }
    /**
     * Iterate over every available video tracks on the media element and either:
     *   - if the last manually set video track is found, set that one.
     *   - if not, set the most preferred one
     *   - if we still do not find an optimal track, let the one chosen by default
     */
    _setOptimalVideoTrack() {
        // 1. first check if the last set track is available, set it if that's the case
        if (this._videoTrackLockedOn === null) {
            disableVideoTracks(this._videoTracks);
            return;
        }
        else if (this._videoTrackLockedOn !== undefined) {
            for (let i = 0; i < this._videoTracks.length; i++) {
                const { nativeTrack } = this._videoTracks[i];
                if (nativeTrack === this._videoTrackLockedOn) {
                    nativeTrack.selected = true;
                    return;
                }
            }
        }
        // Else set the preferred one
        this._applyVideoPreferences();
    }
    /**
     * Try to find a track corresponding to the text track preferences:
     *   - if found, set it as the active track
     *   - if not found, let the chosen text track by default
     */
    _applyVideoPreferences() {
        // Re-set the last manually set video track
        this._videoTrackLockedOn = undefined;
        // NOTE: As we cannot access either codec information or sign interpretation
        // information easily about the different codecs. It is the same case than
        // if we had only tracks where those were set to undefined.
        // Based on that, we should disable the video track as long as one of the
        // set preferrence is "no video track" (i.e. `null`) as this is the only
        // constraint that we know we can respect.
        // Else, just chose the first track.
        const preferredVideoTracks = this._preferredVideoTracks;
        const hasNullPreference = preferredVideoTracks.some(p => p === null);
        if (hasNullPreference) {
            disableVideoTracks(this._videoTracks);
        }
        // else just let the default one instead
    }
    /**
     * Monitor native tracks add, remove and change callback and trigger the
     * change events.
     */
    _handleNativeTracksCallbacks() {
        if (this._nativeAudioTracks !== undefined) {
            this._nativeAudioTracks.onaddtrack = () => {
                var _a, _b;
                if (this._nativeAudioTracks !== undefined) {
                    const newAudioTracks = createAudioTracks(this._nativeAudioTracks);
                    if (areTrackArraysDifferent(this._audioTracks, newAudioTracks)) {
                        this._audioTracks = newAudioTracks;
                        this._setOptimalAudioTrack();
                        this.trigger("availableAudioTracksChange", this.getAvailableAudioTracks());
                        const chosenAudioTrack = this._getPrivateChosenAudioTrack();
                        if ((chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== this._lastEmittedNativeAudioTrack) {
                            this.trigger("audioTrackChange", (_a = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.track) !== null && _a !== void 0 ? _a : null);
                            this._lastEmittedNativeAudioTrack = (_b = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
                        }
                    }
                }
            };
            this._nativeAudioTracks.onremovetrack = () => {
                var _a, _b;
                if (this._nativeAudioTracks !== undefined) {
                    const newAudioTracks = createAudioTracks(this._nativeAudioTracks);
                    if (areTrackArraysDifferent(this._audioTracks, newAudioTracks)) {
                        this._audioTracks = newAudioTracks;
                        this.trigger("availableAudioTracksChange", this.getAvailableAudioTracks());
                        const chosenAudioTrack = this._getPrivateChosenAudioTrack();
                        if ((chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== this._lastEmittedNativeAudioTrack) {
                            this.trigger("audioTrackChange", (_a = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.track) !== null && _a !== void 0 ? _a : null);
                            this._lastEmittedNativeAudioTrack = (_b = chosenAudioTrack === null || chosenAudioTrack === void 0 ? void 0 : chosenAudioTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
                        }
                    }
                }
            };
            this._nativeAudioTracks.onchange = () => {
                if (this._audioTracks !== undefined) {
                    for (let i = 0; i < this._audioTracks.length; i++) {
                        const { track, nativeTrack } = this._audioTracks[i];
                        if (nativeTrack.enabled) {
                            if (nativeTrack !== this._lastEmittedNativeAudioTrack) {
                                this.trigger("audioTrackChange", track);
                                this._lastEmittedNativeAudioTrack = nativeTrack;
                            }
                            return;
                        }
                    }
                }
                if (this._lastEmittedNativeAudioTrack !== null) {
                    this.trigger("audioTrackChange", null);
                    this._lastEmittedNativeAudioTrack = null;
                }
                return;
            };
        }
        if (this._nativeTextTracks !== undefined) {
            this._nativeTextTracks.onaddtrack = () => {
                var _a, _b;
                if (this._nativeTextTracks !== undefined) {
                    const newTextTracks = createTextTracks(this._nativeTextTracks);
                    if (areTrackArraysDifferent(this._textTracks, newTextTracks)) {
                        this._textTracks = newTextTracks;
                        this._setOptimalTextTrack();
                        this.trigger("availableTextTracksChange", this.getAvailableTextTracks());
                        const chosenTextTrack = this._getPrivateChosenTextTrack();
                        if ((chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== this._lastEmittedNativeTextTrack) {
                            this.trigger("textTrackChange", (_a = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.track) !== null && _a !== void 0 ? _a : null);
                            this._lastEmittedNativeTextTrack = (_b = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
                        }
                    }
                }
            };
            this._nativeTextTracks.onremovetrack = () => {
                var _a, _b;
                if (this._nativeTextTracks !== undefined) {
                    const newTextTracks = createTextTracks(this._nativeTextTracks);
                    if (areTrackArraysDifferent(this._textTracks, newTextTracks)) {
                        this._textTracks = newTextTracks;
                        this._setOptimalTextTrack();
                        this.trigger("availableTextTracksChange", this.getAvailableTextTracks());
                        const chosenTextTrack = this._getPrivateChosenTextTrack();
                        if ((chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== this._lastEmittedNativeTextTrack) {
                            this.trigger("textTrackChange", (_a = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.track) !== null && _a !== void 0 ? _a : null);
                            this._lastEmittedNativeTextTrack = (_b = chosenTextTrack === null || chosenTextTrack === void 0 ? void 0 : chosenTextTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
                        }
                    }
                }
            };
            this._nativeTextTracks.onchange = () => {
                if (this._textTracks !== undefined) {
                    for (let i = 0; i < this._textTracks.length; i++) {
                        const { track, nativeTrack } = this._textTracks[i];
                        if (nativeTrack.mode === "showing") {
                            if (nativeTrack !== this._lastEmittedNativeTextTrack) {
                                this.trigger("textTrackChange", track);
                                this._lastEmittedNativeTextTrack = nativeTrack;
                            }
                            return;
                        }
                    }
                }
                if (this._lastEmittedNativeTextTrack !== null) {
                    this.trigger("textTrackChange", null);
                    this._lastEmittedNativeTextTrack = null;
                }
                return;
            };
        }
        if (this._nativeVideoTracks !== undefined) {
            this._nativeVideoTracks.onaddtrack = () => {
                var _a, _b;
                if (this._nativeVideoTracks !== undefined) {
                    const newVideoTracks = createVideoTracks(this._nativeVideoTracks);
                    if (areTrackArraysDifferent(this._videoTracks, newVideoTracks)) {
                        this._videoTracks = newVideoTracks;
                        this._setOptimalVideoTrack();
                        this.trigger("availableVideoTracksChange", this.getAvailableVideoTracks());
                        const chosenVideoTrack = this._getPrivateChosenVideoTrack();
                        if ((chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== this._lastEmittedNativeVideoTrack) {
                            this.trigger("videoTrackChange", (_a = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.track) !== null && _a !== void 0 ? _a : null);
                            this._lastEmittedNativeVideoTrack = (_b = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
                        }
                    }
                }
            };
            this._nativeVideoTracks.onremovetrack = () => {
                var _a, _b;
                if (this._nativeVideoTracks !== undefined) {
                    const newVideoTracks = createVideoTracks(this._nativeVideoTracks);
                    if (areTrackArraysDifferent(this._videoTracks, newVideoTracks)) {
                        this._videoTracks = newVideoTracks;
                        this._setOptimalVideoTrack();
                        this.trigger("availableVideoTracksChange", this.getAvailableVideoTracks());
                        const chosenVideoTrack = this._getPrivateChosenVideoTrack();
                        if ((chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== this._lastEmittedNativeVideoTrack) {
                            this.trigger("videoTrackChange", (_a = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.track) !== null && _a !== void 0 ? _a : null);
                            this._lastEmittedNativeVideoTrack = (_b = chosenVideoTrack === null || chosenVideoTrack === void 0 ? void 0 : chosenVideoTrack.nativeTrack) !== null && _b !== void 0 ? _b : null;
                        }
                    }
                }
            };
            this._nativeVideoTracks.onchange = () => {
                if (this._videoTracks !== undefined) {
                    for (let i = 0; i < this._videoTracks.length; i++) {
                        const { track, nativeTrack } = this._videoTracks[i];
                        if (nativeTrack.selected) {
                            if (nativeTrack !== this._lastEmittedNativeVideoTrack) {
                                this.trigger("videoTrackChange", track);
                                this._lastEmittedNativeVideoTrack = nativeTrack;
                            }
                            return;
                        }
                    }
                }
                if (this._lastEmittedNativeVideoTrack !== null) {
                    this.trigger("videoTrackChange", null);
                    this._lastEmittedNativeVideoTrack = null;
                }
                return;
            };
        }
    }
}
/**
 * Disable all text track elements in the given array from showing.
 * @param {Array.<Object>} textTracks
 */
function disableTextTracks(textTracks) {
    for (let i = 0; i < textTracks.length; i++) {
        const { nativeTrack } = textTracks[i];
        nativeTrack.mode = "disabled";
    }
}
/**
 * Disable all text track elements in the given array from showing but one which
 * should stay in the same state it was before.
 * @param {Array.<Object>} textTracks
 * @param {TextTrack} track
 */
function disableAllTextTracksBut(textTracks, track) {
    for (let i = 0; i < textTracks.length; i++) {
        const { nativeTrack } = textTracks[i];
        if (nativeTrack !== track &&
            (nativeTrack.mode === "showing" || nativeTrack.mode === "hidden")) {
            nativeTrack.mode = "disabled";
        }
    }
}
/**
 * Disable all video track elements in the given array from showing.
 * Note that browser need to support that use case, which they often do not.
 * @param {Array.<Object>} videoTracks
 */
function disableVideoTracks(videoTracks) {
    for (let i = 0; i < videoTracks.length; i++) {
        const { nativeTrack } = videoTracks[i];
        nativeTrack.selected = false;
    }
}


/***/ }),

/***/ 16036:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ZP": () => (/* binding */ eme)
});

// UNUSED EXPORTS: clearEMESession, disposeEME, getCurrentKeySystem

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(70252);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(10125);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/throwError.js
var throwError = __webpack_require__(55022);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js + 4 modules
var ReplaySubject = __webpack_require__(4815);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js
var empty = __webpack_require__(47485);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(75688);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(83425);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(96705);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/take.js
var take = __webpack_require__(53329);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(5842);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(65208);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/catchError.js
var catchError = __webpack_require__(7947);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
var ignoreElements = __webpack_require__(61030);
// EXTERNAL MODULE: ./src/compat/event_listeners.ts + 4 modules
var event_listeners = __webpack_require__(90315);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/take_pssh_out.ts + 1 modules
var take_pssh_out = __webpack_require__(3544);
// EXTERNAL MODULE: ./src/utils/are_arrays_of_numbers_equal.ts
var are_arrays_of_numbers_equal = __webpack_require__(90387);
// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(97308);
// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(26332);
;// CONCATENATED MODULE: ./src/compat/eme/constants.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// The way "pssh" will be written in ISOBMFF files
const PSSH_TO_INTEGER = (0,byte_parsing/* be4toi */.pX)((0,string_parsing/* strToUtf8 */.tG)("pssh"), 0);

;// CONCATENATED MODULE: ./src/compat/eme/get_init_data.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Take in input initialization data from an encrypted event and generate the
 * corresponding array of initialization data values from it.
 *
 * At the moment, this function only handles initialization data which have the
 * "cenc" initialization data type.
 * It will just return a single value with an `undefined` `systemId` for all
 * other types of data.
 * @param {Uint8Array} initData - Raw initialization data
 * @returns {Array.<Object>}
 */
function getInitializationDataValues(initData) {
    const result = [];
    let offset = 0;
    while (offset < initData.length) {
        if (initData.length < offset + 8 ||
            (0,byte_parsing/* be4toi */.pX)(initData, offset + 4) !== PSSH_TO_INTEGER) {
            log/* default.warn */.Z.warn("Compat: Unrecognized initialization data. Use as is.");
            return [{ systemId: undefined,
                    data: initData }];
        }
        const len = (0,byte_parsing/* be4toi */.pX)(new Uint8Array(initData), offset);
        if (offset + len > initData.length) {
            log/* default.warn */.Z.warn("Compat: Unrecognized initialization data. Use as is.");
            return [{ systemId: undefined,
                    data: initData }];
        }
        const currentPSSH = initData.subarray(offset, offset + len);
        const systemId = (0,take_pssh_out/* getPsshSystemID */.Y)(currentPSSH, 8);
        const currentItem = { systemId, data: currentPSSH };
        if (isPSSHAlreadyEncountered(result, currentItem)) {
            // As we observed on some browsers (IE and Edge), the initialization data on
            // some segments have sometimes duplicated PSSH when sent through an encrypted
            // event (but not when the corresponding segment has been pushed to the
            // SourceBuffer).
            // We prefer filtering them out, to avoid further issues.
            log/* default.warn */.Z.warn("Compat: Duplicated PSSH found in initialization data, removing it.");
        }
        else {
            result.push(currentItem);
        }
        offset += len;
    }
    if (offset !== initData.length) {
        log/* default.warn */.Z.warn("Compat: Unrecognized initialization data. Use as is.");
        return [{ systemId: undefined,
                data: initData }];
    }
    return result;
}
/**
 * Returns `true` if the given PSSH has already been stored in the
 * `encounteredPSSHs` cache given.
 * Returns `false` otherwise.
 * @param {Array.<Object>} encounteredPSSHs
 * @param {Uint8Array} pssh
 * @returns {boolean}
 */
function isPSSHAlreadyEncountered(encounteredPSSHs, pssh) {
    for (let i = 0; i < encounteredPSSHs.length; i++) {
        const item = encounteredPSSHs[i];
        if (pssh.systemId === undefined ||
            item.systemId === undefined ||
            pssh.systemId === item.systemId) {
            if ((0,are_arrays_of_numbers_equal/* default */.Z)(pssh.data, item.data)) {
                return true;
            }
        }
    }
    return false;
}
/**
 * Take out the two things we need on an encryptedEvent:
 *   - the initialization Data
 *   - the initialization Data type
 *
 * @param {MediaEncryptedEvent} encryptedEvent - Payload received with an
 * "encrypted" event.
 * @returns {Object} - Initialization data and Initialization data type.
 * @throws {EncryptedMediaError} - Throws if no initialization data is
 * encountered in the given event.
 */
function getInitData(encryptedEvent) {
    const { initData, initDataType } = encryptedEvent;
    if (initData == null) {
        log/* default.warn */.Z.warn("Compat: No init data found on media encrypted event.");
        return null;
    }
    const initDataBytes = new Uint8Array(initData);
    const values = getInitializationDataValues(initDataBytes);
    return { type: initDataType, values };
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(24251);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/get_box.ts
var get_box = __webpack_require__(65489);
// EXTERNAL MODULE: ./src/utils/cast_to_observable.ts
var cast_to_observable = __webpack_require__(42121);
;// CONCATENATED MODULE: ./src/compat/eme/generate_key_request.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Modify "initialization data" sent to a `generateKeyRequest` EME call to
 * improve the player's browser compatibility:
 *
 *   1. some browsers/CDM have problems when the CENC PSSH box is the first
 *      encountered PSSH box in the initialization data (for the moment just
 *      Edge was noted with this behavior).
 *      We found however that it works on every browser when the CENC pssh
 *      box(es) is/are the last box(es) encountered.
 *
 *      To that end, we move CENC pssh boxes at the end of the initialization
 *      data in this function.
 *
 *   2. Some poorly encoded/packaged contents communicate both a CENC with a
 *      pssh version of 0 and one with a version of 1. We found out that this is
 *      not always well handled on some devices/browsers (on Edge and some other
 *      embedded devices that shall remain nameless for now!).
 *
 *      Here this function will filter out CENC pssh with a version different to
 *      1 when one(s) with a version of 1 is/are already present.
 *
 * If the initData is unrecognized or if a CENC PSSH is not found, this function
 * throws.
 * @param {Uint8Array} initData - Initialization data you want to patch
 * @returns {Uint8Array} - Initialization data, patched
 */
function patchInitData(initData) {
    log/* default.info */.Z.info("Compat: Trying to move CENC PSSH from init data at the end of it.");
    let foundCencV1 = false;
    let concatenatedCencs = new Uint8Array();
    let resInitData = new Uint8Array();
    let offset = 0;
    while (offset < initData.length) {
        if (initData.length < offset + 8 ||
            (0,byte_parsing/* be4toi */.pX)(initData, offset + 4) !== PSSH_TO_INTEGER) {
            log/* default.warn */.Z.warn("Compat: unrecognized initialization data. Cannot patch it.");
            throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
        }
        const len = (0,byte_parsing/* be4toi */.pX)(new Uint8Array(initData), offset);
        if (offset + len > initData.length) {
            log/* default.warn */.Z.warn("Compat: unrecognized initialization data. Cannot patch it.");
            throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
        }
        const currentPSSH = initData.subarray(offset, offset + len);
        // yep
        if (initData[offset + 12] === 0x10 &&
            initData[offset + 13] === 0x77 &&
            initData[offset + 14] === 0xEF &&
            initData[offset + 15] === 0xEC &&
            initData[offset + 16] === 0xC0 &&
            initData[offset + 17] === 0xB2 &&
            initData[offset + 18] === 0x4D &&
            initData[offset + 19] === 0x02 &&
            initData[offset + 20] === 0xAC &&
            initData[offset + 21] === 0xE3 &&
            initData[offset + 22] === 0x3C &&
            initData[offset + 23] === 0x1E &&
            initData[offset + 24] === 0x52 &&
            initData[offset + 25] === 0xE2 &&
            initData[offset + 26] === 0xFB &&
            initData[offset + 27] === 0x4B) {
            const cencOffsets = (0,get_box/* getNextBoxOffsets */.Xj)(currentPSSH);
            const version = cencOffsets === null ? undefined :
                currentPSSH[cencOffsets[1]];
            log/* default.info */.Z.info("Compat: CENC PSSH found with version", version);
            if (version === undefined) {
                log/* default.warn */.Z.warn("Compat: could not read version of CENC PSSH");
            }
            else if (foundCencV1 === (version === 1)) {
                // Either `concatenatedCencs` only contains v1 or does not contain any
                concatenatedCencs = (0,byte_parsing/* concat */.zo)(concatenatedCencs, currentPSSH);
            }
            else if (version === 1) {
                log/* default.warn */.Z.warn("Compat: cenc version 1 encountered, " +
                    "removing every other cenc pssh box.");
                concatenatedCencs = currentPSSH;
                foundCencV1 = true;
            }
            else {
                log/* default.warn */.Z.warn("Compat: filtering out cenc pssh box with wrong version", version);
            }
        }
        else {
            resInitData = (0,byte_parsing/* concat */.zo)(resInitData, currentPSSH);
        }
        offset += len;
    }
    if (offset !== initData.length) {
        log/* default.warn */.Z.warn("Compat: unrecognized initialization data. Cannot patch it.");
        throw new Error("Compat: unrecognized initialization data. Cannot patch it.");
    }
    return (0,byte_parsing/* concat */.zo)(resInitData, concatenatedCencs);
}
/**
 * Generate a request from session.
 * @param {MediaKeySession}session - MediaKeySession on which the request will
 * be done.
 * @param {Uint8Array}initData - Initialization data given e.g. by the
 * "encrypted" event for the corresponding request.
 * @param {string} initDataType - Initialization data type given e.g. by the
 * "encrypted" event for the corresponding request.
 * @param {string} sessionType - Type of session you want to generate. Consult
 * EME Specification for more information on session types.
 * @returns {Observable} - Emit when done. Errors if fails.
 */
function generateKeyRequest(session, initializationDataType, initializationData) {
    return (0,defer/* defer */.P)(() => {
        log/* default.debug */.Z.debug("Compat: Calling generateRequest on the MediaKeySession");
        let patchedInit;
        try {
            patchedInit = patchInitData(initializationData);
        }
        catch (_e) {
            patchedInit = initializationData;
        }
        const initDataType = initializationDataType !== null && initializationDataType !== void 0 ? initializationDataType : "";
        return (0,cast_to_observable/* default */.Z)(session.generateRequest(initDataType, patchedInit))
            .pipe((0,catchError/* catchError */.K)(error => {
            if (initDataType !== "" || !(error instanceof TypeError)) {
                throw error;
            }
            // On newer EME versions of the specification, the initialization data
            // type given to generateRequest cannot be an empty string (it returns
            // a rejected promise with a TypeError in that case).
            // Retry with a default "cenc" value for initialization data type if
            // we're in that condition.
            log/* default.warn */.Z.warn("Compat: error while calling `generateRequest` with an empty " +
                "initialization data type. Retrying with a default \"cenc\" value.", error);
            return (0,cast_to_observable/* default */.Z)(session.generateRequest("cenc", patchedInit));
        }));
    });
}

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(86694);
// EXTERNAL MODULE: ./src/errors/encrypted_media_error.ts
var encrypted_media_error = __webpack_require__(4029);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(54924);
// EXTERNAL MODULE: ./src/utils/assert_unreachable.ts
var assert_unreachable = __webpack_require__(76709);
// EXTERNAL MODULE: ./src/utils/filter_map.ts
var filter_map = __webpack_require__(15731);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(32825);
;// CONCATENATED MODULE: ./src/core/eme/clean_old_stored_persistent_info.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Remove old information from a PersistentSessionsStore so that it respects the
 * given `limit` as a maximum size. This can be used to prevent its size from
 * growing indefinitely.
 *
 * This is needed because our persistent session information storage is
 * un-bounded in size, adding more data will just add more data without removing
 * the old one - which can be valid or invalid.
 *
 * This is problematic for at least two reasons:
 *   - This data is loaded into JS memory which is finite (and which maximum
 *     bounds depends on the user environment).
 *   - The final storage used (as chosen by the application using the RxPlayer)
 *     will in most cases have a maximum storage size.
 */
function cleanOldStoredPersistentInfo(persistentSessionsStore, limit) {
    if (isNaN(limit) || limit < 0 || limit >= persistentSessionsStore.getLength()) {
        return;
    }
    const numberOfPersistentSessions = persistentSessionsStore.getLength();
    const toDelete = numberOfPersistentSessions - limit;
    log/* default.info */.Z.info("EME: Too many stored persistent sessions, removing some.", numberOfPersistentSessions, toDelete);
    persistentSessionsStore.deleteOldSessions(toDelete);
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(53059);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
var startWith = __webpack_require__(5118);
;// CONCATENATED MODULE: ./src/core/eme/clean_old_loaded_sessions.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Close sessions from the loadedSessionsStore to allow at maximum `limit`
 * stored MediaKeySessions in it.
 *
 * Emit event when a MediaKeySession begin to be closed and another when the
 * MediaKeySession is closed.
 * @param {Object} loadedSessionsStore
 * @returns {Observable}
 */
function cleanOldLoadedSessions(loadedSessionsStore, limit) {
    if (limit < 0 || limit >= loadedSessionsStore.getLength()) {
        return empty/* EMPTY */.E;
    }
    const cleaningOldSessions$ = [];
    const entries = loadedSessionsStore
        .getAll()
        .slice(); // clone
    const toDelete = entries.length - limit;
    for (let i = 0; i < toDelete; i++) {
        const entry = entries[i];
        const cleaning$ = loadedSessionsStore
            .closeSession(entry.initializationData)
            .pipe((0,mapTo/* mapTo */.h)({ type: "cleaned-old-session", value: entry }), (0,startWith/* startWith */.O)({ type: "cleaning-old-session", value: entry }));
        cleaningOldSessions$.push(cleaning$);
    }
    return (0,merge/* merge */.T)(...cleaningOldSessions$);
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/race.js
var race = __webpack_require__(98925);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/timer.js
var timer = __webpack_require__(61106);
// EXTERNAL MODULE: ./src/utils/rx-try_catch.ts
var rx_try_catch = __webpack_require__(85033);
;// CONCATENATED MODULE: ./src/compat/eme/load_session.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const EME_WAITING_DELAY_LOADED_SESSION_EMPTY_KEYSTATUSES = 100;
/**
 * Load a persistent session, based on its `sessionId`, on the given
 * MediaKeySession.
 *
 * Returns an Observable which emits:
 *   - true if the persistent MediaKeySession was found and loaded
 *   - false if no persistent MediaKeySession was found with that `sessionId`.
 * Then completes.
 *
 * The Observable throws if anything goes wrong in the process.
 * @param {MediaKeySession} session
 * @param {string} sessionId
 * @returns {Observable}
 */
function loadSession(session, sessionId) {
    return (0,defer/* defer */.P)(() => {
        log/* default.info */.Z.info("Compat/EME: Load persisted session", sessionId);
        return (0,rx_try_catch/* default */.Z)(() => (0,cast_to_observable/* default */.Z)(session.load(sessionId)), undefined);
    }).pipe((0,mergeMap/* mergeMap */.zg)((isLoaded) => {
        if (!isLoaded || session.keyStatuses.size > 0) {
            return (0,of.of)(isLoaded);
        }
        // A browser race condition can exist, seen for example in some
        // Chromium/Chrome versions where the `keyStatuses` property from a loaded
        // MediaKeySession would not be populated directly as the load answer but
        // asynchronously after.
        return (0,race/* race */.S3)((0,timer/* timer */.H)(EME_WAITING_DELAY_LOADED_SESSION_EMPTY_KEYSTATUSES), (0,event_listeners.onKeyStatusesChange$)(session)).pipe((0,take/* take */.q)(1), (0,mapTo/* mapTo */.h)(isLoaded));
    }));
}

;// CONCATENATED MODULE: ./src/core/eme/utils/is_session_usable.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * If all key statuses attached to session are valid (either not
 * "expired" or "internal-error"), return true.
 * If not, return false.
 * @param {Uint8Array} initData
 * @param {MediaKeySession} loadedSession
 * @returns {MediaKeySession}
 */
function isSessionUsable(loadedSession) {
    if (loadedSession.sessionId === "") {
        return false;
    }
    const keyStatusesMap = loadedSession.keyStatuses;
    const keyStatuses = [];
    keyStatusesMap.forEach((keyStatus) => {
        keyStatuses.push(keyStatus);
    });
    if (keyStatuses.length <= 0) {
        log/* default.debug */.Z.debug("EME: isSessionUsable: MediaKeySession given has an empty keyStatuses", loadedSession);
        return false;
    }
    if ((0,array_includes/* default */.Z)(keyStatuses, "expired")) {
        log/* default.debug */.Z.debug("EME: isSessionUsable: MediaKeySession given has an expired key", loadedSession.sessionId);
        return false;
    }
    if ((0,array_includes/* default */.Z)(keyStatuses, "internal-error")) {
        log/* default.debug */.Z.debug("EME: isSessionUsable: MediaKeySession given has a key with an " +
            "internal-error", loadedSession.sessionId);
        return false;
    }
    log/* default.debug */.Z.debug("EME: isSessionUsable: MediaKeySession is usable", loadedSession.sessionId);
    return true;
}

;// CONCATENATED MODULE: ./src/core/eme/create_session.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Create a new Session on the given MediaKeys, corresponding to the given
 * initializationData.
 * If session creating fails, remove the oldest MediaKeySession loaded and
 * retry.
 *
 * /!\ This only creates new sessions.
 * It will fail if loadedSessionsStore already has a MediaKeySession with
 * the given initializationData.
 * @param {Uint8Array} initData
 * @param {string|undefined} initDataType
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */
function createSession(stores, initializationData, wantedSessionType) {
    return (0,defer/* defer */.P)(() => {
        const { loadedSessionsStore, persistentSessionsStore } = stores;
        if (wantedSessionType === "temporary") {
            return createTemporarySession(loadedSessionsStore, initializationData);
        }
        else if (persistentSessionsStore === null) {
            log/* default.warn */.Z.warn("EME: Cannot create persistent MediaKeySession, " +
                "PersistentSessionsStore not created.");
            return createTemporarySession(loadedSessionsStore, initializationData);
        }
        return createAndTryToRetrievePersistentSession(loadedSessionsStore, persistentSessionsStore, initializationData);
    });
}
/**
 * Create a new temporary MediaKeySession linked to the given initData and
 * initDataType.
 * @param {Object} loadedSessionsStore
 * @param {Object} initData
 * @returns {Observable}
 */
function createTemporarySession(loadedSessionsStore, initData) {
    return (0,defer/* defer */.P)(() => {
        log/* default.info */.Z.info("EME: Creating a new temporary session");
        const session = loadedSessionsStore.createSession(initData, "temporary");
        return (0,of.of)({ type: "created-session",
            value: { mediaKeySession: session, sessionType: "temporary" } });
    });
}
/**
 * Create a persistent MediaKeySession and try to load on it a previous
 * MediaKeySession linked to the same initData and initDataType.
 * @param {Object} loadedSessionsStore
 * @param {Object} persistentSessionsStore
 * @param {Object} initData
 * @returns {Observable}
 */
function createAndTryToRetrievePersistentSession(loadedSessionsStore, persistentSessionsStore, initData) {
    return (0,defer/* defer */.P)(() => {
        log/* default.info */.Z.info("EME: Creating persistent MediaKeySession");
        const session = loadedSessionsStore
            .createSession(initData, "persistent-license");
        const storedEntry = persistentSessionsStore.getAndReuse(initData);
        if (storedEntry === null) {
            return (0,of.of)({ type: "created-session",
                value: { mediaKeySession: session, sessionType: "persistent-license" } });
        }
        /**
         * Helper function to close and restart the current persistent session
         * considered, and re-create it from scratch.
         * @returns {Observable}
         */
        const recreatePersistentSession = () => {
            log/* default.info */.Z.info("EME: Removing previous persistent session.");
            if (persistentSessionsStore.get(initData) !== null) {
                persistentSessionsStore.delete(initData);
            }
            return loadedSessionsStore.closeSession(initData)
                .pipe((0,map/* map */.U)(() => {
                const newSession = loadedSessionsStore.createSession(initData, "persistent-license");
                return { type: "created-session", value: { mediaKeySession: newSession,
                        sessionType: "persistent-license" } };
            }));
        };
        return loadSession(session, storedEntry.sessionId).pipe((0,mergeMap/* mergeMap */.zg)((hasLoadedSession) => {
            if (!hasLoadedSession) {
                log/* default.warn */.Z.warn("EME: No data stored for the loaded session");
                persistentSessionsStore.delete(initData);
                return (0,of.of)({ type: "created-session", value: { mediaKeySession: session,
                        sessionType: "persistent-license" } });
            }
            if (hasLoadedSession && isSessionUsable(session)) {
                persistentSessionsStore.add(initData, session);
                log/* default.info */.Z.info("EME: Succeeded to load persistent session.");
                return (0,of.of)({ type: "loaded-persistent-session", value: { mediaKeySession: session,
                        sessionType: "persistent-license" } });
            }
            // Unusable persistent session: recreate a new session from scratch.
            log/* default.warn */.Z.warn("EME: Previous persistent session not usable anymore.");
            return recreatePersistentSession();
        }), (0,catchError/* catchError */.K)((err) => {
            log/* default.warn */.Z.warn("EME: Unable to load persistent session: " +
                (err instanceof Error ? err.toString() :
                    "Unknown Error"));
            return recreatePersistentSession();
        }));
    });
}

;// CONCATENATED MODULE: ./src/core/eme/get_session.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







const { EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS } = config/* default */.Z;
/**
 * Handle MediaEncryptedEvents sent by a HTMLMediaElement:
 * Either create a MediaKeySession, recuperate a previous MediaKeySession or
 * load a persistent session.
 *
 * Some previously created MediaKeySession can be closed in this process to
 * respect the maximum limit of concurrent MediaKeySession, as defined by the
 * `EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS` config property.
 *
 * You can refer to the events emitted to know about the current situation.
 * @param {Event} initializationDataInfo
 * @param {Object} handledInitData
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */
function getSession(initializationData, stores, wantedSessionType) {
    return (0,defer/* defer */.P)(() => {
        /**
         * Store previously-loaded MediaKeySession with the same initialization data, if one.
         */
        let previousLoadedSession = null;
        const { loadedSessionsStore, persistentSessionsStore } = stores;
        const entry = loadedSessionsStore.getAndReuse(initializationData);
        if (entry !== null) {
            previousLoadedSession = entry.mediaKeySession;
            if (isSessionUsable(previousLoadedSession)) {
                log/* default.info */.Z.info("EME: Reuse loaded session", previousLoadedSession.sessionId);
                return (0,of.of)({ type: "loaded-open-session", value: { mediaKeySession: previousLoadedSession,
                        sessionType: entry.sessionType,
                        initializationData } });
            }
            else if (persistentSessionsStore !== null) {
                // If the session is not usable anymore, we can also remove it from the
                // PersistentSessionsStore.
                // TODO Are we sure this is always what we want?
                persistentSessionsStore.delete(initializationData);
            }
        }
        return (previousLoadedSession != null ?
            loadedSessionsStore.closeSession(initializationData) :
            (0,of.of)(null)).pipe((0,mergeMap/* mergeMap */.zg)(() => {
            return (0,concat/* concat */.z)(cleanOldLoadedSessions(loadedSessionsStore, EME_MAX_SIMULTANEOUS_MEDIA_KEY_SESSIONS - 1), createSession(stores, initializationData, wantedSessionType)
                .pipe((0,map/* map */.U)((evt) => ({ type: evt.type,
                value: { mediaKeySession: evt.value.mediaKeySession,
                    sessionType: evt.value.sessionType,
                    initializationData } }))));
        }));
    });
}

// EXTERNAL MODULE: ./src/compat/eme/custom_media_keys/index.ts + 7 modules
var custom_media_keys = __webpack_require__(39013);
// EXTERNAL MODULE: ./src/core/eme/media_keys_infos_store.ts
var media_keys_infos_store = __webpack_require__(91132);
;// CONCATENATED MODULE: ./src/core/eme/attach_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Dispose the media keys on media element.
 * @param {Object} mediaElement
 * @returns {Observable}
 */
function disableMediaKeys(mediaElement) {
    return (0,defer/* defer */.P)(() => {
        media_keys_infos_store/* default.setState */.Z.setState(mediaElement, null);
        return (0,custom_media_keys/* setMediaKeys */.Y)(mediaElement, null);
    });
}
/**
 * Attach MediaKeys and its associated state to an HTMLMediaElement.
 *
 * /!\ Mutates heavily MediaKeysInfosStore
 * @param {Object} mediaKeysInfos
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
function attachMediaKeys(mediaElement, { keySystemOptions, loadedSessionsStore, mediaKeySystemAccess, mediaKeys }) {
    return (0,defer/* defer */.P)(() => {
        const previousState = media_keys_infos_store/* default.getState */.Z.getState(mediaElement);
        const closeAllSessions$ = previousState !== null &&
            previousState.loadedSessionsStore !== loadedSessionsStore ?
            previousState.loadedSessionsStore.closeAllSessions() :
            (0,of.of)(null);
        return closeAllSessions$.pipe((0,mergeMap/* mergeMap */.zg)(() => {
            media_keys_infos_store/* default.setState */.Z.setState(mediaElement, { keySystemOptions,
                mediaKeySystemAccess,
                mediaKeys,
                loadedSessionsStore });
            if (mediaElement.mediaKeys === mediaKeys) {
                return (0,of.of)(null);
            }
            log/* default.info */.Z.info("EME: Attaching MediaKeys to the media element");
            return (0,custom_media_keys/* setMediaKeys */.Y)(mediaElement, mediaKeys)
                .pipe((0,tap/* tap */.b)(() => { log/* default.info */.Z.info("EME: MediaKeys attached with success"); }));
        }));
    });
}

// EXTERNAL MODULE: ./src/utils/starts_with.ts
var starts_with = __webpack_require__(27140);
;// CONCATENATED MODULE: ./src/core/eme/get_drm_system_id.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {string} keySystem
 * @returns {string|undefined}
 */
function getDrmSystemId(keySystem) {
    if ((0,starts_with/* default */.Z)(keySystem, "com.microsoft.playready") ||
        keySystem === "com.chromecast.playready" ||
        keySystem === "com.youtube.playready") {
        return "9a04f07998404286ab92e65be0885f95";
    }
    if (keySystem === "com.widevine.alpha") {
        return "edef8ba979d64acea3c827dcd51d21ed";
    }
    if ((0,starts_with/* default */.Z)(keySystem, "com.apple.fps")) {
        return "94ce86fb07ff4f43adb893d2fa968ca2";
    }
    if ((0,starts_with/* default */.Z)(keySystem, "com.nagra.")) {
        return "adb41c242dbf4a6d958b4457c0d27b95";
    }
    return undefined;
}

// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(8886);
;// CONCATENATED MODULE: ./src/compat/should_renew_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the current target require the media keys to be renewed on
 * each content.
 * @returns {Boolean}
 */
function shouldRenewMediaKeys() {
    return browser_detection/* isIE11 */.fq;
}

// EXTERNAL MODULE: ./src/utils/flat_map.ts
var flat_map = __webpack_require__(7536);
;// CONCATENATED MODULE: ./src/core/eme/find_key_system.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









const { EME_DEFAULT_WIDEVINE_ROBUSTNESSES, EME_KEY_SYSTEMS } = config/* default */.Z;
/**
 * @param {Array.<Object>} keySystems
 * @param {MediaKeySystemAccess} currentKeySystemAccess
 * @param {Object} currentKeySystemOptions
 * @returns {null|Object}
 */
function checkCachedMediaKeySystemAccess(keySystems, currentKeySystemAccess, currentKeySystemOptions) {
    const mksConfiguration = currentKeySystemAccess.getConfiguration();
    if (shouldRenewMediaKeys() || mksConfiguration == null) {
        return null;
    }
    const firstCompatibleOption = keySystems.filter((ks) => {
        // TODO Do it with MediaKeySystemAccess.prototype.keySystem instead
        if (ks.type !== currentKeySystemOptions.type) {
            return false;
        }
        if ((ks.persistentLicense === true || ks.persistentStateRequired === true) &&
            mksConfiguration.persistentState !== "required") {
            return false;
        }
        if (ks.distinctiveIdentifierRequired === true &&
            mksConfiguration.distinctiveIdentifier !== "required") {
            return false;
        }
        return true;
    })[0];
    if (firstCompatibleOption != null) {
        return { keySystemOptions: firstCompatibleOption,
            keySystemAccess: currentKeySystemAccess };
    }
    return null;
}
/**
 * Find key system canonical name from key system type.
 * @param {string} ksType - Obtained via inversion
 * @returns {string|undefined} - Either the canonical name, or undefined.
 */
function findKeySystemCanonicalName(ksType) {
    for (const ksName of Object.keys(EME_KEY_SYSTEMS)) {
        if ((0,array_includes/* default */.Z)(EME_KEY_SYSTEMS[ksName], ksType)) {
            return ksName;
        }
    }
    return undefined;
}
/**
 * Build configuration for the requestMediaKeySystemAccess EME API, based
 * on the current keySystem object.
 * @param {string} [ksName] - Generic name for the key system. e.g. "clearkey",
 * "widevine", "playready". Can be used to make exceptions depending on it.
 * @param {Object} keySystem
 * @returns {Array.<Object>} - Configuration to give to the
 * requestMediaKeySystemAccess API.
 */
function buildKeySystemConfigurations(ksName, keySystem) {
    const sessionTypes = ["temporary"];
    let persistentState = "optional";
    let distinctiveIdentifier = "optional";
    if (keySystem.persistentLicense === true) {
        persistentState = "required";
        sessionTypes.push("persistent-license");
    }
    if (keySystem.persistentStateRequired === true) {
        persistentState = "required";
    }
    if (keySystem.distinctiveIdentifierRequired === true) {
        distinctiveIdentifier = "required";
    }
    // Set robustness, in order of consideration:
    //   1. the user specified its own robustnesses
    //   2. a "widevine" key system is used, in that case set the default widevine
    //      robustnesses as defined in the config
    //   3. set an undefined robustness
    const videoRobustnesses = keySystem.videoRobustnesses != null ?
        keySystem.videoRobustnesses :
        (ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES :
            []);
    const audioRobustnesses = keySystem.audioRobustnesses != null ?
        keySystem.audioRobustnesses :
        (ksName === "widevine" ? EME_DEFAULT_WIDEVINE_ROBUSTNESSES :
            []);
    if (videoRobustnesses.length === 0) {
        videoRobustnesses.push(undefined);
    }
    if (audioRobustnesses.length === 0) {
        audioRobustnesses.push(undefined);
    }
    // From the W3 EME spec, we have to provide videoCapabilities and
    // audioCapabilities.
    // These capabilities must specify a codec (even though you can use a
    // completely different codec afterward).
    // It is also strongly recommended to specify the required security
    // robustness. As we do not want to forbide any security level, we specify
    // every existing security level from highest to lowest so that the best
    // security level is selected.
    // More details here:
    // https://storage.googleapis.com/wvdocs/Chrome_EME_Changes_and_Best_Practices.pdf
    // https://www.w3.org/TR/encrypted-media/#get-supported-configuration-and-consent
    const videoCapabilities = (0,flat_map/* default */.Z)(videoRobustnesses, robustness => [{ contentType: "video/mp4;codecs=\"avc1.4d401e\"",
            robustness },
        { contentType: "video/mp4;codecs=\"avc1.42e01e\"",
            robustness },
        { contentType: "video/webm;codecs=\"vp8\"",
            robustness }]);
    const audioCapabilities = (0,flat_map/* default */.Z)(audioRobustnesses, robustness => [{ contentType: "audio/mp4;codecs=\"mp4a.40.2\"",
            robustness },
        { contentType: "audio/webm;codecs=opus",
            robustness }]);
    // TODO Re-test with a set contentType but an undefined robustness on the
    // STBs on which this problem was found.
    //
    // add another with no {audio,video}Capabilities for some legacy browsers.
    // As of today's spec, this should return NotSupported but the first
    // candidate configuration should be good, so we should have no downside
    // doing that.
    // initDataTypes: ["cenc"],
    // videoCapabilities: undefined,
    // audioCapabilities: undefined,
    // distinctiveIdentifier,
    // persistentState,
    // sessionTypes,
    return [{ initDataTypes: ["cenc"],
            videoCapabilities,
            audioCapabilities,
            distinctiveIdentifier,
            persistentState,
            sessionTypes }];
}
/**
 * Try to find a compatible key system from the keySystems array given.
 *
 * Returns an Observable which, when subscribed to, will request a
 * MediaKeySystemAccess based on the various keySystems provided. This
 * Observable will:
 *   - emit the MediaKeySystemAccess and the keySystems as an object, when
 *     found. The object is under this form:
 *     {
 *       keySystemAccess {MediaKeySystemAccess}
 *       keySystem {Object}
 *     }
 *   - complete immediately after emitting.
 *   - throw if no  compatible key system has been found.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems - The keySystems you want to test.
 * @returns {Observable}
 */
function getMediaKeySystemAccess(mediaElement, keySystemsConfigs) {
    return (0,defer/* defer */.P)(() => {
        log/* default.info */.Z.info("EME: Searching for compatible MediaKeySystemAccess");
        const currentState = media_keys_infos_store/* default.getState */.Z.getState(mediaElement);
        if (currentState != null) {
            // Fast way to find a compatible keySystem if the currently loaded
            // one as exactly the same compatibility options.
            const cachedKeySystemAccess = checkCachedMediaKeySystemAccess(keySystemsConfigs, currentState.mediaKeySystemAccess, currentState.keySystemOptions);
            if (cachedKeySystemAccess !== null) {
                log/* default.info */.Z.info("EME: Found cached compatible keySystem", cachedKeySystemAccess);
                return (0,of.of)({
                    type: "reuse-media-key-system-access",
                    value: { mediaKeySystemAccess: cachedKeySystemAccess.keySystemAccess,
                        options: cachedKeySystemAccess.keySystemOptions },
                });
            }
        }
        /**
         * Array of set keySystems for this content.
         * Each item of this array is an object containing the following keys:
         *   - keyName {string}: keySystem canonical name (e.g. "widevine")
         *   - keyType {string}: keySystem type (e.g. "com.widevine.alpha")
         *   - keySystem {Object}: the original keySystem object
         * @type {Array.<Object>}
         */
        const keySystemsType = keySystemsConfigs.reduce((arr, keySystemOptions) => {
            const managedRDNs = EME_KEY_SYSTEMS[keySystemOptions.type];
            let ksType;
            if (managedRDNs != null) {
                ksType = managedRDNs.map((keyType) => {
                    const keyName = keySystemOptions.type;
                    return { keyName, keyType, keySystemOptions };
                });
            }
            else {
                const keyName = findKeySystemCanonicalName(keySystemOptions.type);
                const keyType = keySystemOptions.type;
                ksType = [{ keyName, keyType, keySystemOptions }];
            }
            return arr.concat(ksType);
        }, []);
        return recursivelyTestKeySystems(0);
        /**
         * Test all key system configuration stored in `keySystemsType` one by one
         * recursively.
         * Returns an Observable which emit the MediaKeySystemAccess if one was
         * found compatible with one of the configurations or just throws if none
         * were found to be compatible.
         * @param {Number} index - The index in `keySystemsType` to start from.
         * Should be set to `0` when calling directly.
         * @returns {Observable}
         */
        function recursivelyTestKeySystems(index) {
            // if we iterated over the whole keySystemsType Array, quit on error
            if (index >= keySystemsType.length) {
                const error = new encrypted_media_error/* default */.Z("INCOMPATIBLE_KEYSYSTEMS", "No key system compatible with your " +
                    "wanted configuration has been found " +
                    "in the current browser.");
                return (0,throwError/* throwError */._)(error);
            }
            if (custom_media_keys/* requestMediaKeySystemAccess */.N == null) {
                const error = Error("requestMediaKeySystemAccess is not " +
                    "implemented in your browser.");
                return (0,throwError/* throwError */._)(error);
            }
            const { keyName, keyType, keySystemOptions } = keySystemsType[index];
            const keySystemConfigurations = buildKeySystemConfigurations(keyName, keySystemOptions);
            log/* default.debug */.Z.debug(`EME: Request keysystem access ${keyType},` +
                `${index + 1} of ${keySystemsType.length}`, keySystemConfigurations);
            return (0,custom_media_keys/* requestMediaKeySystemAccess */.N)(keyType, keySystemConfigurations).pipe((0,map/* map */.U)((keySystemAccess) => {
                log/* default.info */.Z.info("EME: Found compatible keysystem", keyType, keySystemConfigurations);
                return { type: "create-media-key-system-access", value: { options: keySystemOptions,
                        mediaKeySystemAccess: keySystemAccess } };
            }), (0,catchError/* catchError */.K)(() => {
                log/* default.debug */.Z.debug("EME: Rejected access to keysystem", keyType, keySystemConfigurations);
                return recursivelyTestKeySystems(index + 1);
            }));
        }
    });
}

// EXTERNAL MODULE: ./src/utils/hash_buffer.ts
var hash_buffer = __webpack_require__(13245);
;// CONCATENATED MODULE: ./src/core/eme/server_certificate_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Keep track of server certificate which have been set for a MediaKeys.
 * As it is impossible for a MediaKeys to have his server certificate reset
 * or updated, we consider that once it has been set, it will remain set until
 * the MediaKeys instance is killed.
 *
 * So, a WeakMap helps keeping a trace of which server certificate (identified
 * with a unique hash) is set on a MediaKeys.
 * `null` indicate that we don't know (and not `undefined`, because this is the
 * default value for when a WeakMap has no value for a key) which server
 * certificate is attached to a MediaKeys instance (most likely because related
 * EME APIs failed or had an unexpected behavior).
 */
const serverCertificateHashesMap = new WeakMap();
/** ServerCertificateStore */
/* harmony default export */ const server_certificate_store = ({
    /**
     * Tells the ServerCertificateStore that you begin to call the APIs to set a
     * ServerCertificate on `mediaKeys`.
     *
     * Calling this function is necessary due to how server certificate work
     * currently in EME APIs:
     * Because right now, it is impossible to tell if a MediaKeys instance has an
     * attached ServerCertificate or not when the corresponding API fails or if it
     * never answers, we prefer to announce through this function that the current
     * server certificate attached to this MediaKeys is for now invalid.
     * @param {MediaKeys | Object} mediaKeys
     */
    prepare(mediaKeys) {
        serverCertificateHashesMap.set(mediaKeys, null);
    },
    /**
     * Attach a new server certificate to a MediaKeys in the
     * ServerCertificateStore.
     *
     * Only one server certificate should ever be attached to a MediaKeys
     * instance and the `prepare` function should have been called before any
     * action to update the server certificate took place (this function does not
     * enforce either of those behaviors).
     * @param {MediaKeys | Object} mediaKeys
     * @param {ArrayBufferView | BufferSource} serverCertificate
     */
    set(mediaKeys, serverCertificate) {
        const formattedServerCertificate = serverCertificate instanceof Uint8Array ?
            serverCertificate :
            new Uint8Array(serverCertificate instanceof ArrayBuffer ? serverCertificate :
                serverCertificate.buffer);
        const hash = (0,hash_buffer/* default */.Z)(formattedServerCertificate);
        serverCertificateHashesMap.set(mediaKeys, { hash, serverCertificate: formattedServerCertificate });
    },
    /**
     * Returns `true` if the MediaKeys instance has an attached ServerCertificate.
     * Returns `false` if it doesn't.
     *
     * Returns `undefined` if we cannot know, most likely because related EME APIs
     * failed or had an unexpected behavior.
     * @param {MediaKeys} mediaKeys
     * @returns {Boolean|undefined}
     */
    hasOne(mediaKeys) {
        const currentServerCertificate = serverCertificateHashesMap.get(mediaKeys);
        return currentServerCertificate === undefined ? false :
            currentServerCertificate === null ? undefined :
                true;
    },
    /**
     * Returns `true` if the given `mediaKeys` has `serverCertificate` attached to
     * it.
     * Returns `false` either if it doesn't of if we doesn't know if it does.
     * @param {MediaKeys | Object} mediaKeys
     * @param {ArrayBufferView | BufferSource} serverCertificate
     * @returns {boolean}
     */
    has(mediaKeys, serverCertificate) {
        const serverCertificateHash = serverCertificateHashesMap.get(mediaKeys);
        if (serverCertificateHash === undefined || serverCertificateHash === null) {
            return false;
        }
        const { hash: oldHash, serverCertificate: oldServerCertificate } = serverCertificateHash;
        const newServerCertificate = serverCertificate instanceof Uint8Array ?
            serverCertificate :
            new Uint8Array(serverCertificate instanceof ArrayBuffer ? serverCertificate :
                serverCertificate.buffer);
        const newHash = (0,hash_buffer/* default */.Z)(newServerCertificate);
        if (newHash !== oldHash ||
            oldServerCertificate.length !== newServerCertificate.length) {
            return false;
        }
        for (let i = 0; i < oldServerCertificate.length; i++) {
            if (oldServerCertificate[i] !== newServerCertificate[i]) {
                return false;
            }
        }
        return true;
    },
});

;// CONCATENATED MODULE: ./src/compat/eme/close_session.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Close session and returns and observable that emits when
 * the session is closed.
 * @param {MediaKeySession|Object} session
 * @returns {Observable}
 */
function closeSession$(session) {
    return (0,race/* race */.S3)((0,cast_to_observable/* default */.Z)(session.close()), 
    // If the session is not closed after 1000ms, try
    // to call another method on session to guess if
    // session is closed or not.
    (0,timer/* timer */.H)(1000).pipe((0,mergeMap/* mergeMap */.zg)(() => {
        const tryToUpdateSession$ = (0,cast_to_observable/* default */.Z)(session.update(new Uint8Array(1)));
        return tryToUpdateSession$.pipe(
        // Update has resolved, so we can't know if session is closed
        (0,map/* map */.U)(() => {
            throw new Error("Compat: Couldn't know if session is " +
                "closed");
        }), (0,catchError/* catchError */.K)((err) => {
            // The caught error can tell if session is closed
            // (Chrome may throw this error)
            if (err instanceof Error &&
                err.message === "The session is already closed.") {
                return (0,of.of)(null);
            }
            // The `closed` promise may resolve, even if `close()` result has not
            // (it may happen on Firefox). Wait for it and timeout after 1 second.
            const sessionIsClosed$ = (0,cast_to_observable/* default */.Z)(session.closed);
            return (0,race/* race */.S3)(sessionIsClosed$, (0,timer/* timer */.H)(1000).pipe((0,map/* map */.U)(() => {
                throw new Error("Compat: Couldn't know if session is " +
                    "closed");
            })));
        }));
    })));
}

;// CONCATENATED MODULE: ./src/core/eme/utils/close_session.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const { EME_SESSION_CLOSING_MAX_RETRY, EME_SESSION_CLOSING_INITIAL_DELAY, EME_SESSION_CLOSING_MAX_DELAY } = config/* default */.Z;
/**
 * Close a MediaKeySession with multiple attempts if needed and do not throw if
 * this action throws an error.
 * Emits then complete when done.
 * @param {MediaKeySession} mediaKeySession
 * @returns {Observable}
 */
function safelyCloseMediaKeySession(mediaKeySession) {
    return recursivelyTryToCloseMediaKeySession(0);
    /**
     * Perform a new attempt at closing the MediaKeySession.
     * If this operation fails due to a not-"callable" (an EME term)
     * MediaKeySession, retry based on either a timer or on MediaKeySession
     * events, whichever comes first.
     * Emits then complete when done.
     * @param {number} retryNb - The attempt number starting at 0.
     * @returns {Observable}
     */
    function recursivelyTryToCloseMediaKeySession(retryNb) {
        log/* default.debug */.Z.debug("EME: Trying to close a MediaKeySession", mediaKeySession, retryNb);
        return closeSession$(mediaKeySession).pipe((0,tap/* tap */.b)(() => { log/* default.debug */.Z.debug("EME: Succeeded to close MediaKeySession"); }), (0,catchError/* catchError */.K)((err) => {
            // Unitialized MediaKeySession may not close properly until their
            // corresponding `generateRequest` or `load` call are handled by the
            // browser.
            // In that case the EME specification tells us that the browser is
            // supposed to reject the `close` call with an InvalidStateError.
            if (!(err instanceof Error) || err.name !== "InvalidStateError" ||
                mediaKeySession.sessionId !== "") {
                return failToCloseSession(err);
            }
            // We will retry either:
            //   - when an event indicates that the MediaKeySession is
            //     initialized (`callable` is the proper EME term here)
            //   - after a delay, raising exponentially
            const nextRetryNb = retryNb + 1;
            if (nextRetryNb > EME_SESSION_CLOSING_MAX_RETRY) {
                return failToCloseSession(err);
            }
            const delay = Math.min(Math.pow(2, retryNb) * EME_SESSION_CLOSING_INITIAL_DELAY, EME_SESSION_CLOSING_MAX_DELAY);
            log/* default.warn */.Z.warn("EME: attempt to close a mediaKeySession failed, " +
                "scheduling retry...", delay);
            return (0,race/* race */.S3)([(0,timer/* timer */.H)(delay),
                (0,event_listeners.onKeyStatusesChange$)(mediaKeySession),
                (0,event_listeners.onKeyMessage$)(mediaKeySession)])
                .pipe((0,take/* take */.q)(1), (0,mergeMap/* mergeMap */.zg)(() => recursivelyTryToCloseMediaKeySession(nextRetryNb)));
        }));
    }
    /**
     * Log error anouncing that we could not close the MediaKeySession and emits
     * then complete through Observable.
     * TODO Emit warning?
     * @returns {Observable}
     */
    function failToCloseSession(err) {
        log/* default.error */.Z.error("EME: Could not close MediaKeySession: " +
            (err instanceof Error ? err.toString() :
                "Unknown error"));
        return (0,of.of)(null);
    }
}

// EXTERNAL MODULE: ./src/utils/base64.ts
var utils_base64 = __webpack_require__(91282);
;// CONCATENATED MODULE: ./src/core/eme/utils/init_data_container.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Wrap initialization data and allow serialization of it into base64. */
class InitDataContainer {
    /**
     * Create a new container, wrapping the initialization data given and allowing
     * linearization into base64.
     * @param {Uint8Array}
     */
    constructor(initData) {
        this.initData = initData;
    }
    /**
     * Convert it to base64.
     * `toJSON` is specially interpreted by JavaScript engines to be able to rely
     * on it when calling `JSON.stringify` on it or any of its parent objects:
     * https://tc39.es/ecma262/#sec-serializejsonproperty
     * @returns {string}
     */
    toJSON() {
        return (0,utils_base64/* bytesToBase64 */.J)(this.initData);
    }
    /**
     * Decode a base64 sequence representing an initialization data back to an
     * Uint8Array.
     * @param {string}
     * @returns {Uint8Array}
     */
    static decode(base64) {
        return (0,utils_base64/* base64ToBytes */.K)(base64);
    }
}

;// CONCATENATED MODULE: ./src/core/eme/utils/are_init_values_compatible.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns `true` if both values are compatible initialization data, which
 * means that one is completely contained in the other.
 *
 * Both values given should be sorted by systemId the same way.
 * @param {Array.<Object>} stored
 * @param {Array.<Object>} newElts
 * @returns {boolean}
 */
function areInitializationValuesCompatible(stored, newElts) {
    var _a, _b;
    return (_b = (_a = _isAInB(stored, newElts)) !== null && _a !== void 0 ? _a : _isAInB(newElts, stored)) !== null && _b !== void 0 ? _b : false;
}
/**
 * Take two arrays of initialization data values, `a` and `b`, sorted by
 * their `systemId` property in the same order.
 *
 * Returns `true` if `a` is not empty and is completely contained in the `b`
 * array.
 * This is equivalent to: "`a` is contained in `b`".
 *
 * Returns `false` either if `a` is empty or if `b` has different initialization
 * data than it for equivalent system ids.
 * This is equivalent to: "`a` represents different data than `b`".
 *
 * Returns `null` if `a` is not fully contained in `b` but can still be
 * compatible with it.
 * This is equivalent to: "`a` is not contained in `b`, but `b` could be
 * contained in `a`".
 * @param {Array.<Object>} a
 * @param {Array.<Object>} b
 * @returns {boolean}
 */
function _isAInB(a, b) {
    if (a.length === 0) {
        return false;
    }
    if (b.length < a.length) {
        return null;
    }
    const firstAElt = a[0];
    let aIdx = 0;
    let bIdx = 0;
    for (; bIdx < b.length; bIdx++) {
        const bElt = b[bIdx];
        if (bElt.systemId !== firstAElt.systemId) {
            continue;
        }
        if (bElt.hash !== firstAElt.hash) {
            return false;
        }
        const aData = firstAElt.data instanceof Uint8Array ? firstAElt.data :
            typeof firstAElt.data === "string" ? InitDataContainer.decode(firstAElt.data) :
                firstAElt.data.initData;
        const bData = bElt.data instanceof Uint8Array ? bElt.data :
            typeof bElt.data === "string" ? InitDataContainer.decode(bElt.data) :
                bElt.data.initData;
        if (!(0,are_arrays_of_numbers_equal/* default */.Z)(aData, bData)) {
            return false;
        }
        if (b.length - bIdx < a.length) {
            // not enough place to store `a`'s initialization data.
            return null;
        }
        // first `a` value was found. Check if all `a` values are found in `b`
        for (aIdx = 1; aIdx < a.length; aIdx++) {
            const aElt = a[aIdx];
            for (bIdx += 1; bIdx < b.length; bIdx++) {
                const bNewElt = b[bIdx];
                if (aElt.systemId !== bNewElt.systemId) {
                    continue;
                }
                if (aElt.hash !== bNewElt.hash) {
                    return false;
                }
                const aNewData = aElt.data instanceof Uint8Array ? aElt.data :
                    typeof aElt.data === "string" ? InitDataContainer.decode(aElt.data) :
                        aElt.data.initData;
                const bNewData = bNewElt.data instanceof Uint8Array ? bNewElt.data :
                    typeof bNewElt.data === "string" ? InitDataContainer.decode(bNewElt.data) :
                        bNewElt.data.initData;
                if (!(0,are_arrays_of_numbers_equal/* default */.Z)(aNewData, bNewData)) {
                    return false;
                }
                break;
            }
            if (aIdx === b.length) {
                // we didn't find `aElt`'s systemId in b
                return null;
            }
        }
        // If we're here, then we've found all `a`'s systemId in `b` and they match
        return true;
    }
    return null; // We didn't find the firstAElt`s systemId in `b`.
}

;// CONCATENATED MODULE: ./src/core/eme/utils/init_data_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Store a unique value associated to an initData and initDataType.
 * @class InitDataStore
 */
class InitDataStore {
    /** Construct a new InitDataStore.  */
    constructor() {
        this._storage = [];
    }
    /**
     * Returns all stored value, in the order in which they have been stored.
     * Note: it is possible to move a value to the end of this array by calling
     * the `getAndReuse` method.
     * @returns {Array}
     */
    getAll() {
        return this._storage.map(item => item.payload);
    }
    /**
     * Returns the number of stored values.
     * @returns {number}
     */
    getLength() {
        return this._storage.length;
    }
    /**
     * Returns `true` if no initialization data is stored yet in this
     * InitDataStore.
     * Returns `false` otherwise.
     * @returns {boolean}
     */
    isEmpty() {
        return this._storage.length === 0;
    }
    /**
     * Returns the element associated with the given initData and initDataType.
     * Returns `undefined` if not found.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {*}
     */
    get(initializationData) {
        const index = this._findIndex(initializationData);
        return index >= 0 ? this._storage[index].payload :
            undefined;
    }
    /**
     * Like `get`, but also move the corresponding value at the end of the store
     * (as returned by `getAll`) if found.
     * This can be used for example to tell when a previously-stored value is
     * re-used to then be able to implement a caching replacement algorithm based
     * on the least-recently-used values by just evicting the first values
     * returned by `getAll`.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {*}
     */
    getAndReuse(initializationData) {
        const index = this._findIndex(initializationData);
        if (index === -1) {
            return undefined;
        }
        const item = this._storage.splice(index, 1)[0];
        this._storage.push(item);
        return item.payload;
    }
    /**
     * Add to the store a value linked to the corresponding initData and
     * initDataType.
     * If a value was already stored linked to those, replace it.
     * @param {Object} initializationData
     * @param {*} payload
     */
    store(initializationData, payload) {
        const indexOf = this._findIndex(initializationData);
        if (indexOf >= 0) {
            // this._storage contains the stored value in the same order they have
            // been put. So here we want to remove the previous element and re-push
            // it to the end.
            this._storage.splice(indexOf, 1);
        }
        const values = this._formatValuesForStore(initializationData.values);
        this._storage.push({ type: initializationData.type,
            values,
            payload });
    }
    /**
     * Add to the store a value linked to the corresponding initData and
     * initDataType.
     * If a value linked to those was already stored, do nothing and returns
     * `false`.
     * If not, add the value and return `true`.
     *
     * This can be used as a more performant version of doing both a `get` call -
     * to see if a value is stored linked to that data - and then if not doing a
     * store. `storeIfNone` is more performant as it will only perform hashing
     * and a look-up a single time.
     * @param {Object} initializationData
     * @param {*} payload
     * @returns {boolean}
     */
    storeIfNone(initializationData, payload) {
        const indexOf = this._findIndex(initializationData);
        if (indexOf >= 0) {
            return false;
        }
        const values = this._formatValuesForStore(initializationData.values);
        this._storage.push({ type: initializationData.type,
            values,
            payload });
        return true;
    }
    /**
     * Remove an initDataType and initData combination from this store.
     * Returns the associated value if it has been found, `undefined` otherwise.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {*}
     */
    remove(initializationData) {
        const indexOf = this._findIndex(initializationData);
        if (indexOf === -1) {
            return undefined;
        }
        return this._storage.splice(indexOf, 1)[0].payload;
    }
    /**
     * Find the index of the corresponding initialization data in `this._storage`.
     * Returns `-1` if not found.
     * @param {Object} initializationData
     * @returns {boolean}
     */
    _findIndex(initializationData) {
        const formattedVals = this._formatValuesForStore(initializationData.values);
        // Begin by the last element as we usually re-encounter the last stored
        // initData sooner than the first one.
        for (let i = this._storage.length - 1; i >= 0; i--) {
            const stored = this._storage[i];
            if (stored.type === initializationData.type) {
                if (areInitializationValuesCompatible(stored.values, formattedVals)) {
                    return i;
                }
            }
        }
        return -1;
    }
    /**
     * Format given initializationData's values so they are ready to be stored:
     *   - sort them by systemId, so they are faster to compare
     *   - add hash for each initialization data encountered.
     * @param {Array.<Object>} initialValues
     * @returns {Array.<Object>}
     */
    _formatValuesForStore(initialValues) {
        return initialValues.slice()
            .sort((a, b) => a.systemId === b.systemId ? 0 :
            a.systemId === undefined ? 1 :
                b.systemId === undefined ? -1 :
                    a.systemId < b.systemId ? -1 :
                        1)
            .map(({ systemId, data }) => ({ systemId,
            data,
            hash: (0,hash_buffer/* default */.Z)(data) }));
    }
}

;// CONCATENATED MODULE: ./src/core/eme/utils/loaded_sessions_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Create and store MediaKeySessions linked to a single MediaKeys
 * instance.
 *
 * Keep track of sessionTypes and of the initialization data each
 * MediaKeySession is created for.
 * @class LoadedSessionsStore
 */
class LoadedSessionsStore {
    /**
     * Create a new LoadedSessionsStore, which will store information about
     * loaded MediaKeySessions on the given MediaKeys instance.
     * @param {MediaKeys} mediaKeys
     */
    constructor(mediaKeys) {
        this._mediaKeys = mediaKeys;
        this._storage = new InitDataStore();
    }
    /**
     * Returns the stored MediaKeySession information related to the
     * given initDataType and initData if found.
     * Returns `null` if no such MediaKeySession is stored.
     * @param {Object} initializationData
     * @returns {Object|null}
     */
    get(initializationData) {
        const entry = this._storage.get(initializationData);
        return entry === undefined ? null :
            { mediaKeySession: entry.mediaKeySession,
                sessionType: entry.sessionType };
    }
    /**
     * Like `get` but also moves the corresponding MediaKeySession to the end of
     * its internal storage, as returned by the `getAll` method.
     *
     * This can be used for example to tell when a previously-stored
     * initialization data is re-used to then be able to implement a caching
     * replacement algorithm based on the least-recently-used values by just
     * evicting the first values returned by `getAll`.
     * @param {Object} initializationData
     * @returns {Object|null}
     */
    getAndReuse(initializationData) {
        const entry = this._storage.getAndReuse(initializationData);
        return entry === undefined ? null :
            { mediaKeySession: entry.mediaKeySession,
                sessionType: entry.sessionType };
    }
    /**
     * Moves the corresponding MediaKeySession to the end of its internal storage,
     * as returned by the `getAll` method.
     *
     * This can be used to signal that a previously-stored initialization data is
     * re-used to then be able to implement a caching replacement algorithm based
     * on the least-recently-used values by just evicting the first values
     * returned by `getAll`.
     *
     * Returns `true` if the corresponding session was found in the store, `false`
     * otherwise.
     * @param {Object} initializationData
     * @returns {boolean}
     */
    reuse(initializationData) {
        return this._storage.getAndReuse(initializationData) !== undefined;
    }
    /**
     * Create a new MediaKeySession and store it in this store.
     * @throws {EncryptedMediaError}
     * @param {Object} initializationData
     * @param {string} sessionType
     * @returns {MediaKeySession}
     */
    createSession(initializationData, sessionType) {
        if (this._storage.get(initializationData) !== undefined) {
            throw new encrypted_media_error/* default */.Z("MULTIPLE_SESSIONS_SAME_INIT_DATA", "This initialization data was already stored.");
        }
        const mediaKeySession = this._mediaKeys.createSession(sessionType);
        const entry = { mediaKeySession, sessionType, initializationData };
        if (!(0,is_null_or_undefined/* default */.Z)(mediaKeySession.closed)) {
            mediaKeySession.closed
                .then(() => {
                const currentEntry = this._storage.get(initializationData);
                if (currentEntry !== undefined &&
                    currentEntry.mediaKeySession === mediaKeySession) {
                    this._storage.remove(initializationData);
                }
            })
                .catch((e) => {
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                log/* default.warn */.Z.warn(`EME-LSS: MediaKeySession.closed rejected: ${e}`);
            });
        }
        log/* default.debug */.Z.debug("EME-LSS: Add MediaKeySession", entry);
        this._storage.store(initializationData, entry);
        return mediaKeySession;
    }
    /**
     * Close a MediaKeySession corresponding to an initialization data and remove
     * its related stored information from the LoadedSessionsStore.
     * Emit when done.
     * @param {Object} initializationData
     * @returns {Observable}
     */
    closeSession(initializationData) {
        return (0,defer/* defer */.P)(() => {
            const entry = this._storage.remove(initializationData);
            if (entry === undefined) {
                log/* default.warn */.Z.warn("EME-LSS: No MediaKeySession found with " +
                    "the given initData and initDataType");
                return empty/* EMPTY */.E;
            }
            return safelyCloseMediaKeySession(entry.mediaKeySession);
        });
    }
    /**
     * Returns the number of stored MediaKeySessions in this LoadedSessionsStore.
     * @returns {number}
     */
    getLength() {
        return this._storage.getLength();
    }
    /**
     * Returns information about all stored MediaKeySession, in the order in which
     * the MediaKeySession have been created.
     * @returns {Array.<Object>}
     */
    getAll() {
        return this._storage.getAll();
    }
    /**
     * Close all sessions in this store.
     * Emit `null` when done.
     * @returns {Observable}
     */
    closeAllSessions() {
        return (0,defer/* defer */.P)(() => {
            const closing$ = this._storage.getAll()
                .map((entry) => safelyCloseMediaKeySession(entry.mediaKeySession));
            log/* default.debug */.Z.debug("EME-LSS: Closing all current MediaKeySessions", closing$.length);
            // re-initialize the storage, so that new interactions with the
            // `LoadedSessionsStore` do not rely on MediaKeySessions we're in the
            // process of removing
            this._storage = new InitDataStore();
            return (0,concat/* concat */.z)((0,merge/* merge */.T)(...closing$).pipe((0,ignoreElements/* ignoreElements */.l)()), (0,of.of)(null));
        });
    }
}

// EXTERNAL MODULE: ./src/utils/assert.ts
var assert = __webpack_require__(25222);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
;// CONCATENATED MODULE: ./src/core/eme/utils/persistent_sessions_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









/**
 * Throw if the given storage does not respect the right interface.
 * @param {Object} storage
 */
function checkStorage(storage) {
    (0,assert/* assertInterface */.u)(storage, { save: "function", load: "function" }, "licenseStorage");
}
/** Wrap initialization data and allow serialization of it into base64. */
class persistent_sessions_store_InitDataContainer {
    /**
     * Create a new container, wrapping the initialization data given and allowing
     * linearization into base64.
     * @param {Uint8Array}
     */
    constructor(initData) {
        this.initData = initData;
    }
    /**
     * Convert it to base64.
     * `toJSON` is specially interpreted by JavaScript engines to be able to rely
     * on it when calling `JSON.stringify` on it or any of its parent objects:
     * https://tc39.es/ecma262/#sec-serializejsonproperty
     * @returns {string}
     */
    toJSON() {
        return (0,utils_base64/* bytesToBase64 */.J)(this.initData);
    }
    /**
     * Decode a base64 sequence representing an initialization data back to an
     * Uint8Array.
     * @param {string}
     * @returns {Uint8Array}
     */
    static decode(base64) {
        return (0,utils_base64/* base64ToBytes */.K)(base64);
    }
}
/**
 * Set representing persisted licenses. Depends on a simple local-
 * storage implementation with a `save`/`load` synchronous interface
 * to persist information on persisted sessions.
 *
 * This set is used only for a cdm/keysystem with license persistency
 * supported.
 * @class PersistentSessionsStore
 */
class PersistentSessionsStore {
    /**
     * Create a new PersistentSessionsStore.
     * @param {Object} storage
     */
    constructor(storage) {
        checkStorage(storage);
        this._entries = [];
        this._storage = storage;
        try {
            this._entries = this._storage.load();
            if (!Array.isArray(this._entries)) {
                this._entries = [];
            }
        }
        catch (e) {
            log/* default.warn */.Z.warn("EME-PSS: Could not get entries from license storage", e);
            this.dispose();
        }
    }
    /**
     * Returns the number of stored values.
     * @returns {number}
     */
    getLength() {
        return this._entries.length;
    }
    /**
     * Returns information about all stored MediaKeySession, in the order in which
     * the MediaKeySession have been created.
     * @returns {Array.<Object>}
     */
    getAll() {
        return this._entries;
    }
    /**
     * Retrieve an entry based on its initialization data.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     * @returns {Object|null}
     */
    get(initData) {
        const index = this._getIndex(initData);
        return index === -1 ? null :
            this._entries[index];
    }
    /**
     * Like `get`, but also move the corresponding value at the end of the store
     * (as returned by `getAll`) if found.
     * This can be used for example to tell when a previously-stored value is
     * re-used to then be able to implement a caching replacement algorithm based
     * on the least-recently-used values by just evicting the first values
     * returned by `getAll`.
     * @param {Uint8Array} initData
     * @param {string|undefined} initDataType
     * @returns {*}
     */
    getAndReuse(initData) {
        const index = this._getIndex(initData);
        if (index === -1) {
            return null;
        }
        const item = this._entries.splice(index, 1)[0];
        this._entries.push(item);
        return item;
    }
    /**
     * Add a new entry in the PersistentSessionsStore.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     * @param {MediaKeySession} session
     */
    add(initData, session) {
        if ((0,is_null_or_undefined/* default */.Z)(session) || !(0,is_non_empty_string/* default */.Z)(session.sessionId)) {
            log/* default.warn */.Z.warn("EME-PSS: Invalid Persisten Session given.");
            return;
        }
        const { sessionId } = session;
        const currentEntry = this.get(initData);
        if (currentEntry !== null && currentEntry.sessionId === sessionId) {
            return;
        }
        else if (currentEntry !== null) { // currentEntry has a different sessionId
            this.delete(initData);
        }
        log/* default.info */.Z.info("EME-PSS: Add new session", sessionId, session);
        this._entries.push({ version: 3,
            sessionId,
            values: this._formatValuesForStore(initData.values),
            initDataType: initData.type });
        this._save();
    }
    /**
     * Delete stored MediaKeySession information based on its initialization
     * data.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     */
    delete(initData) {
        const index = this._getIndex(initData);
        if (index === -1) {
            log/* default.warn */.Z.warn("EME-PSS: initData to delete not found.");
            return;
        }
        const entry = this._entries[index];
        log/* default.warn */.Z.warn("EME-PSS: Delete session from store", entry);
        this._entries.splice(index, 1);
        this._save();
    }
    deleteOldSessions(sessionsToDelete) {
        log/* default.info */.Z.info(`EME-PSS: Deleting last ${sessionsToDelete} sessions.`);
        if (sessionsToDelete <= 0) {
            return;
        }
        if (sessionsToDelete <= this._entries.length) {
            this._entries.splice(0, sessionsToDelete);
        }
        else {
            log/* default.warn */.Z.warn("EME-PSS: Asked to remove more information that it contains", sessionsToDelete, this._entries.length);
            this._entries = [];
        }
        this._save();
    }
    /**
     * Delete all saved entries.
     */
    dispose() {
        this._entries = [];
        this._save();
    }
    /**
     * Retrieve index of an entry.
     * Returns `-1` if not found.
     * @param {Uint8Array}  initData
     * @param {string|undefined} initDataType
     * @returns {number}
     */
    _getIndex(initData) {
        const formatted = this._formatValuesForStore(initData.values);
        // Older versions of the format include a concatenation of all
        // initialization data and its hash.
        const concatInitData = (0,byte_parsing/* concat */.zo)(...initData.values.map(i => i.data));
        const concatInitDataHash = (0,hash_buffer/* default */.Z)(concatInitData);
        for (let i = 0; i < this._entries.length; i++) {
            const entry = this._entries[i];
            if (entry.initDataType === initData.type) {
                switch (entry.version) {
                    case 3:
                        if (areInitializationValuesCompatible(formatted, entry.values)) {
                            return i;
                        }
                        break;
                    case 2:
                        if (entry.initDataHash === concatInitDataHash) {
                            try {
                                const decodedInitData = typeof entry.initData === "string" ?
                                    persistent_sessions_store_InitDataContainer.decode(entry.initData) :
                                    entry.initData.initData;
                                if ((0,are_arrays_of_numbers_equal/* default */.Z)(decodedInitData, concatInitData)) {
                                    return i;
                                }
                            }
                            catch (e) {
                                log/* default.warn */.Z.warn("EME-PSS: Could not decode initialization data.", e);
                            }
                        }
                        break;
                    case 1:
                        if (entry.initDataHash === concatInitDataHash) {
                            if (typeof entry.initData.length === "undefined") {
                                // If length is undefined, it has been linearized. We could still
                                // convert it back to an Uint8Array but this would necessitate some
                                // ugly unreadable logic for a very very minor possibility.
                                // Just consider that it is a match based on the hash.
                                return i;
                            }
                            else if ((0,are_arrays_of_numbers_equal/* default */.Z)(entry.initData, concatInitData)) {
                                return i;
                            }
                        }
                        break;
                    default:
                        if (entry.initData === concatInitDataHash) {
                            return i;
                        }
                }
            }
        }
        return -1;
    }
    /**
     * Use the given storage to store the current entries.
     */
    _save() {
        try {
            this._storage.save(this._entries);
        }
        catch (e) {
            log/* default.warn */.Z.warn("EME-PSS: Could not save licenses in localStorage");
        }
    }
    /**
     * Format given initializationData's values so they are ready to be stored:
     *   - sort them by systemId, so they are faster to compare
     *   - add hash for each initialization data encountered.
     * @param {Array.<Object>} initialValues
     * @returns {Array.<Object>}
     */
    _formatValuesForStore(initialValues) {
        return initialValues.slice()
            .sort((a, b) => a.systemId === b.systemId ? 0 :
            a.systemId === undefined ? 1 :
                b.systemId === undefined ? -1 :
                    a.systemId < b.systemId ? -1 :
                        1)
            .map(({ systemId, data }) => ({ systemId,
            data: new persistent_sessions_store_InitDataContainer(data),
            hash: (0,hash_buffer/* default */.Z)(data) }));
    }
}

;// CONCATENATED MODULE: ./src/core/eme/get_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












/**
 * @throws {EncryptedMediaError}
 * @param {Object} keySystemOptions
 * @returns {Object|null}
 */
function createPersistentSessionsStorage(keySystemOptions) {
    if (keySystemOptions.persistentLicense !== true) {
        return null;
    }
    const { licenseStorage } = keySystemOptions;
    if (licenseStorage == null) {
        throw new encrypted_media_error/* default */.Z("INVALID_KEY_SYSTEM", "No license storage found for persistent license.");
    }
    log/* default.debug */.Z.debug("EME: Set the given license storage");
    return new PersistentSessionsStore(licenseStorage);
}
/**
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs
 * @returns {Observable}
 */
function getMediaKeysInfos(mediaElement, keySystemsConfigs) {
    return getMediaKeySystemAccess(mediaElement, keySystemsConfigs).pipe((0,mergeMap/* mergeMap */.zg)((evt) => {
        const { options, mediaKeySystemAccess } = evt.value;
        const currentState = media_keys_infos_store/* default.getState */.Z.getState(mediaElement);
        const persistentSessionsStore = createPersistentSessionsStorage(options);
        if (currentState !== null && evt.type === "reuse-media-key-system-access") {
            const { mediaKeys, loadedSessionsStore } = currentState;
            // We might just rely on the currently attached MediaKeys instance.
            // First check if server certificate parameters are the same than in the
            // current MediaKeys instance. If not, re-create MediaKeys from scratch.
            if (server_certificate_store.hasOne(mediaKeys) === false ||
                (!(0,is_null_or_undefined/* default */.Z)(options.serverCertificate) &&
                    server_certificate_store.has(mediaKeys, options.serverCertificate))) {
                return (0,of.of)({ mediaKeys,
                    mediaKeySystemAccess,
                    stores: { loadedSessionsStore, persistentSessionsStore },
                    options });
            }
        }
        return createMediaKeys(mediaKeySystemAccess).pipe((0,map/* map */.U)((mediaKeys) => {
            log/* default.info */.Z.info("EME: MediaKeys created with success", mediaKeys);
            const loadedSessionsStore = new LoadedSessionsStore(mediaKeys);
            return { mediaKeys,
                mediaKeySystemAccess,
                stores: { loadedSessionsStore, persistentSessionsStore },
                options };
        }));
    }));
}
/**
 * Create `MediaKeys` from the `MediaKeySystemAccess` given.
 * Throws the right formatted error if it fails.
 * @param {MediaKeySystemAccess} mediaKeySystemAccess
 * @returns {Observable.<MediaKeys>}
 */
function createMediaKeys(mediaKeySystemAccess) {
    log/* default.info */.Z.info("EME: Calling createMediaKeys on the MediaKeySystemAccess");
    return (0,rx_try_catch/* default */.Z)(() => (0,cast_to_observable/* default */.Z)(mediaKeySystemAccess.createMediaKeys()), undefined).pipe((0,catchError/* catchError */.K)((error) => {
        const message = error instanceof Error ?
            error.message :
            "Unknown error when creating MediaKeys.";
        throw new encrypted_media_error/* default */.Z("CREATE_MEDIA_KEYS_ERROR", message);
    }));
}

;// CONCATENATED MODULE: ./src/core/eme/init_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Get media keys infos from key system configs then attach media keys to media element.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystemsConfigs
 * @returns {Observable}
 */
function initMediaKeys(mediaElement, keySystemsConfigs) {
    return getMediaKeysInfos(mediaElement, keySystemsConfigs)
        .pipe((0,mergeMap/* mergeMap */.zg)(({ mediaKeys, mediaKeySystemAccess, stores, options }) => {
        /**
         * String identifying the key system, allowing the rest of the code to
         * only advertise the required initialization data for license requests.
         *
         * Note that we only set this value if retro-compatibility to older
         * persistent logic in the RxPlayer is not important, as the optimizations
         * this property unlocks can break the loading of MediaKeySessions
         * persisted in older RxPlayer's versions.
         */
        let initializationDataSystemId;
        if ((0,is_null_or_undefined/* default */.Z)(options.licenseStorage) ||
            options.licenseStorage.disableRetroCompatibility === true) {
            initializationDataSystemId = getDrmSystemId(mediaKeySystemAccess.keySystem);
        }
        const attachMediaKeys$ = new ReplaySubject/* ReplaySubject */.t(1);
        const shouldDisableOldMediaKeys = mediaElement.mediaKeys !== null &&
            mediaElement.mediaKeys !== undefined &&
            mediaKeys !== mediaElement.mediaKeys;
        let disableOldMediaKeys$ = (0,of.of)(null);
        if (shouldDisableOldMediaKeys) {
            log/* default.debug */.Z.debug("EME: Disabling old MediaKeys");
            disableOldMediaKeys$ = disableMediaKeys(mediaElement);
        }
        return disableOldMediaKeys$.pipe((0,mergeMap/* mergeMap */.zg)(() => {
            log/* default.debug */.Z.debug("EME: Attaching current MediaKeys");
            return attachMediaKeys$.pipe((0,mergeMap/* mergeMap */.zg)(() => {
                const stateToAttatch = { loadedSessionsStore: stores.loadedSessionsStore,
                    mediaKeySystemAccess,
                    mediaKeys,
                    keySystemOptions: options };
                return attachMediaKeys(mediaElement, stateToAttatch);
            }), (0,take/* take */.q)(1), (0,mapTo/* mapTo */.h)({ type: "attached-media-keys", value: { mediaKeySystemAccess, mediaKeys, stores, options } }), (0,startWith/* startWith */.O)({ type: "created-media-keys", value: { mediaKeySystemAccess,
                    initializationDataSystemId,
                    mediaKeys,
                    stores,
                    options,
                    attachMediaKeys$ } }));
        }));
    }));
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(81044);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/identity.js
var identity = __webpack_require__(11707);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/TimeoutError.js
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var TimeoutErrorImpl = /*@__PURE__*/function () {
  function TimeoutErrorImpl() {
    Error.call(this);
    this.message = 'Timeout has occurred';
    this.name = 'TimeoutError';
    return this;
  }

  TimeoutErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);
  return TimeoutErrorImpl;
}();

var TimeoutError = TimeoutErrorImpl;
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/async.js
var scheduler_async = __webpack_require__(49663);
// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(10649);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isDate.js
var isDate = __webpack_require__(53074);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/innerSubscribe.js
var innerSubscribe = __webpack_require__(90789);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeoutWith.js
/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_innerSubscribe PURE_IMPORTS_END */




function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = scheduler_async/* async */.P;
  }

  return function (source) {
    var absoluteTimeout = (0,isDate/* isDate */.J)(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}

var TimeoutWithOperator = /*@__PURE__*/function () {
  function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
    this.waitFor = waitFor;
    this.absoluteTimeout = absoluteTimeout;
    this.withObservable = withObservable;
    this.scheduler = scheduler;
  }

  TimeoutWithOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  };

  return TimeoutWithOperator;
}();

var TimeoutWithSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(TimeoutWithSubscriber, _super);

  function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
    var _this = _super.call(this, destination) || this;

    _this.absoluteTimeout = absoluteTimeout;
    _this.waitFor = waitFor;
    _this.withObservable = withObservable;
    _this.scheduler = scheduler;

    _this.scheduleTimeout();

    return _this;
  }

  TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
    var withObservable = subscriber.withObservable;

    subscriber._unsubscribeAndRecycle();

    subscriber.add((0,innerSubscribe/* innerSubscribe */.ft)(withObservable, new innerSubscribe/* SimpleInnerSubscriber */.IY(subscriber)));
  };

  TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
    var action = this.action;

    if (action) {
      this.action = action.schedule(this, this.waitFor);
    } else {
      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
    }
  };

  TimeoutWithSubscriber.prototype._next = function (value) {
    if (!this.absoluteTimeout) {
      this.scheduleTimeout();
    }

    _super.prototype._next.call(this, value);
  };

  TimeoutWithSubscriber.prototype._unsubscribe = function () {
    this.action = undefined;
    this.scheduler = null;
    this.withObservable = null;
  };

  return TimeoutWithSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/timeout.js
/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */




function timeout(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = scheduler_async/* async */.P;
  }

  return timeoutWith(due, (0,throwError/* throwError */._)(new TimeoutError()), scheduler);
}
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatMap.js
/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

function concatMap(project, resultSelector) {
  return (0,mergeMap/* mergeMap */.zg)(project, resultSelector, 1);
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(28305);
// EXTERNAL MODULE: ./src/utils/get_fuzzed_delay.ts
var get_fuzzed_delay = __webpack_require__(47125);
;// CONCATENATED MODULE: ./src/utils/rx-retry_with_backoff.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Retry the given observable (if it triggers an error) with an exponential
 * backoff.
 * The backoff behavior can be tweaked through the options given.
 *
 * @param {Observable} obs$
 * @param {Object} options - Configuration object.
 * This object contains the following properties:
 *
 *   - retryDelay {Number} - The initial delay, in ms.
 *     This delay will be fuzzed to fall under the range +-30% each time a new
 *     retry is done.
 *     Then, this delay will be multiplied by 2^(n-1), n being the counter of
 *     retry we performed (beginning at 1 for the first retry).
 *
 *   - totalRetry {Number} - The amount of time we should retry. 0
 *     means no retry, 1 means a single retry, Infinity means infinite retry
 *     etc.
 *     If the observable still fails after this number of retry, the error will
 *     be throwed through this observable.
 *
 *   - shouldRetry {Function|undefined} -  Function which will receive the
 *     observable error each time it fails, and should return a boolean. If this
 *     boolean is false, the error will be directly thrown (without anymore
 *     retry).
 *
 *   - onRetry {Function|undefined} - Function which will be triggered at
 *     each retry. Will receive two arguments:
 *       1. The observable error
 *       2. The current retry count, beginning at 1 for the first retry
 *
 * @returns {Observable}
 * TODO Take errorSelector out. Should probably be entirely managed in the
 * calling code via a catch (much simpler to use and to understand).
 */
function retryObsWithBackoff(obs$, options) {
    const { baseDelay, maxDelay, totalRetry, shouldRetry, onRetry } = options;
    let retryCount = 0;
    return obs$.pipe((0,catchError/* catchError */.K)((error, source) => {
        if ((!(0,is_null_or_undefined/* default */.Z)(shouldRetry) && !shouldRetry(error)) ||
            retryCount++ >= totalRetry) {
            throw error;
        }
        if (typeof onRetry === "function") {
            onRetry(error, retryCount);
        }
        const delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);
        const fuzzedDelay = (0,get_fuzzed_delay/* default */.Z)(delay);
        return (0,timer/* timer */.H)(fuzzedDelay)
            .pipe((0,mergeMap/* mergeMap */.zg)(() => source));
    }));
}

;// CONCATENATED MODULE: ./src/compat/eme/get_uuid_kid_from_keystatus_kid.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get KID from MediaKeySession keyStatus, and convert it in usual big-endian kid
 * if necessary. On EDGE, Microsoft Playready KID are presented into little-endian GUID.
 * @param {String} keySystem
 * @param {Uint8Array} baseKeyId
 * @returns {Uint8Array}
 */
function getUUIDKIDFromKeyStatusKID(keySystem, baseKeyId) {
    if (keySystem.indexOf("playready") !== -1 &&
        (browser_detection/* isIEOrEdge */.YM || browser_detection/* isEdgeChromium */.kD)) {
        return (0,string_parsing/* guidToUuid */.wO)(baseKeyId);
    }
    return baseKeyId;
}

;// CONCATENATED MODULE: ./src/core/eme/check_key_statuses.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const KEY_STATUSES = { EXPIRED: "expired",
    INTERNAL_ERROR: "internal-error",
    OUTPUT_RESTRICTED: "output-restricted" };
/**
 * Look at the current key statuses in the sessions and construct the
 * appropriate warnings, whitelisted and blacklisted key ids.
 *
 * Throws if one of the keyID is on an error.
 * @param {MediaKeySession} session - The MediaKeySession from which the keys
 * will be checked.
 * @param {Object} options
 * @param {String} keySystem - The configuration keySystem used for deciphering
 * @returns {Object} - Warnings to send, whitelisted and blacklisted key ids.
 */
function checkKeyStatuses(session, options, keySystem) {
    const warnings = [];
    const blacklistedKeyIDs = [];
    const whitelistedKeyIds = [];
    const { fallbackOn = {}, throwOnLicenseExpiration } = options;
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    /* eslint-disable @typescript-eslint/no-unsafe-call */
    session.keyStatuses.forEach((_arg1, _arg2) => {
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        /* eslint-enable @typescript-eslint/no-unsafe-call */
        // Hack present because the order of the arguments has changed in spec
        // and is not the same between some versions of Edge and Chrome.
        const [keyStatus, keyStatusKeyId] = (() => {
            return (typeof _arg1 === "string" ? [_arg1, _arg2] :
                [_arg2, _arg1]);
        })();
        const keyId = getUUIDKIDFromKeyStatusKID(keySystem, new Uint8Array(keyStatusKeyId));
        switch (keyStatus) {
            case KEY_STATUSES.EXPIRED: {
                const error = new encrypted_media_error/* default */.Z("KEY_STATUS_CHANGE_ERROR", "A decryption key expired");
                if (throwOnLicenseExpiration !== false) {
                    throw error;
                }
                warnings.push({ type: "warning", value: error });
                whitelistedKeyIds.push(keyId);
                break;
            }
            case KEY_STATUSES.INTERNAL_ERROR: {
                const error = new encrypted_media_error/* default */.Z("KEY_STATUS_CHANGE_ERROR", "An invalid key status has been " +
                    "encountered: " + keyStatus);
                if (fallbackOn.keyInternalError !== true) {
                    throw error;
                }
                warnings.push({ type: "warning", value: error });
                blacklistedKeyIDs.push(keyId);
                break;
            }
            case KEY_STATUSES.OUTPUT_RESTRICTED: {
                const error = new encrypted_media_error/* default */.Z("KEY_STATUS_CHANGE_ERROR", "An invalid key status has been " +
                    "encountered: " + keyStatus);
                if (fallbackOn.keyOutputRestricted !== true) {
                    throw error;
                }
                warnings.push({ type: "warning", value: error });
                blacklistedKeyIDs.push(keyId);
                break;
            }
            default:
                whitelistedKeyIds.push(keyId);
                break;
        }
    });
    return { warnings, blacklistedKeyIDs, whitelistedKeyIds };
}

;// CONCATENATED MODULE: ./src/core/eme/session_events_listener.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











const { onKeyError$, onKeyMessage$, onKeyStatusesChange$ } = event_listeners;
/**
 * Error thrown when the MediaKeySession is blacklisted.
 * Such MediaKeySession should not be re-used but other MediaKeySession for the
 * same content can still be used.
 * @class BlacklistedSessionError
 * @extends Error
 */
class BlacklistedSessionError extends Error {
    constructor(sessionError) {
        super();
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(this, BlacklistedSessionError.prototype);
        this.sessionError = sessionError;
    }
}
/**
 * listen to various events from a MediaKeySession and react accordingly
 * depending on the configuration given.
 * @param {MediaKeySession} session - The MediaKeySession concerned.
 * @param {Object} keySystemOptions - The key system options.
 * @param {String} keySystem - The configuration keySystem used for deciphering
 * @param {Object} initializationData - The initialization data linked to that
 * session.
 * @returns {Observable}
 */
function SessionEventsListener(session, keySystemOptions, keySystem, initializationData) {
    log/* default.info */.Z.info("EME: Binding session events", session);
    const sessionWarningSubject$ = new Subject/* Subject */.xQ();
    const { getLicenseConfig = {} } = keySystemOptions;
    const keyErrors = onKeyError$(session)
        .pipe((0,map/* map */.U)((error) => { throw new encrypted_media_error/* default */.Z("KEY_ERROR", error.type); }));
    const keyStatusesChange$ = onKeyStatusesChange$(session)
        .pipe((0,mergeMap/* mergeMap */.zg)((keyStatusesEvent) => handleKeyStatusesChangeEvent(session, keySystemOptions, keySystem, keyStatusesEvent)));
    const keyMessages$ = onKeyMessage$(session).pipe((0,mergeMap/* mergeMap */.zg)((messageEvent) => {
        const message = new Uint8Array(messageEvent.message);
        const messageType = (0,is_non_empty_string/* default */.Z)(messageEvent.messageType) ?
            messageEvent.messageType :
            "license-request";
        log/* default.info */.Z.info(`EME: Received message event, type ${messageType}`, session, messageEvent);
        const getLicense$ = (0,defer/* defer */.P)(() => {
            const getLicense = keySystemOptions.getLicense(message, messageType);
            const getLicenseTimeout = (0,is_null_or_undefined/* default */.Z)(getLicenseConfig.timeout) ?
                10 * 1000 :
                getLicenseConfig.timeout;
            return (0,cast_to_observable/* default */.Z)(getLicense)
                .pipe(getLicenseTimeout >= 0 ? timeout(getLicenseTimeout) :
                identity/* identity */.y /* noop */);
        });
        const backoffOptions = getLicenseBackoffOptions(sessionWarningSubject$, getLicenseConfig.retry);
        return retryObsWithBackoff(getLicense$, backoffOptions).pipe((0,map/* map */.U)(licenseObject => ({
            type: "key-message-handled",
            value: { session, license: licenseObject },
        })), (0,catchError/* catchError */.K)((err) => {
            const formattedError = formatGetLicenseError(err);
            if (!(0,is_null_or_undefined/* default */.Z)(err)) {
                const { fallbackOnLastTry } = err;
                if (fallbackOnLastTry === true) {
                    log/* default.warn */.Z.warn("EME: Last `getLicense` attempt failed. " +
                        "Blacklisting the current session.");
                    throw new BlacklistedSessionError(formattedError);
                }
            }
            throw formattedError;
        }), (0,startWith/* startWith */.O)({ type: "session-message", value: { messageType, initializationData } }));
    }));
    const sessionUpdates = (0,merge/* merge */.T)(keyMessages$, keyStatusesChange$)
        .pipe(concatMap((evt) => {
        switch (evt.type) {
            case "key-message-handled":
            case "key-status-change-handled":
                return updateSessionWithMessage(session, evt.value.license, initializationData);
            default:
                return (0,of.of)(evt);
        }
    }));
    const sessionEvents = (0,merge/* merge */.T)(getKeyStatusesEvents(session, keySystemOptions, keySystem), sessionUpdates, keyErrors, sessionWarningSubject$);
    return !(0,is_null_or_undefined/* default */.Z)(session.closed) ?
        sessionEvents.pipe((0,takeUntil/* takeUntil */.R)((0,cast_to_observable/* default */.Z)(session.closed))) :
        sessionEvents;
}
/**
 * Check current MediaKeyStatus for each key in the given MediaKeySession and
 * return an Observable which either:
 *    - throw if at least one status is a non-recoverable error
 *    - emit warning events for recoverable errors
 *    - emit blacklist-keys events for key IDs that are not decipherable
 * @param {MediaKeySession} session - The MediaKeySession concerned.
 * @param {Object} options - Options related to key statuses checks.
 * @param {String} keySystem - The name of the key system used for deciphering
 * @returns {Observable}
 */
function getKeyStatusesEvents(session, options, keySystem) {
    return (0,defer/* defer */.P)(() => {
        if (session.keyStatuses.size === 0) {
            return empty/* EMPTY */.E;
        }
        const { warnings, blacklistedKeyIDs, whitelistedKeyIds } = checkKeyStatuses(session, options, keySystem);
        const warnings$ = warnings.length > 0 ? (0,of.of)(...warnings) :
            empty/* EMPTY */.E;
        const keysUpdate$ = (0,of.of)({ type: "keys-update", value: { whitelistedKeyIds,
                blacklistedKeyIDs } });
        return (0,concat/* concat */.z)(warnings$, keysUpdate$);
    });
}
/**
 * Format an error returned by a `getLicense` call to a proper form as defined
 * by the RxPlayer's API.
 * @param {*} error
 * @returns {Error}
 */
function formatGetLicenseError(error) {
    if (error instanceof TimeoutError) {
        return new encrypted_media_error/* default */.Z("KEY_LOAD_TIMEOUT", "The license server took too much time to " +
            "respond.");
    }
    const err = new encrypted_media_error/* default */.Z("KEY_LOAD_ERROR", "An error occured when calling `getLicense`.");
    if (!(0,is_null_or_undefined/* default */.Z)(error) &&
        (0,is_non_empty_string/* default */.Z)(error.message)) {
        err.message = error.message;
    }
    return err;
}
/**
 * Call MediaKeySession.update with the given `message`, if defined.
 * Returns the right event depending on the action taken.
 * @param {MediaKeySession} session
 * @param {ArrayBuffer|TypedArray|null} message
 * @param {Object} initializationData
 * @returns {Observable}
 */
function updateSessionWithMessage(session, message, initializationData) {
    if ((0,is_null_or_undefined/* default */.Z)(message)) {
        log/* default.info */.Z.info("EME: No message given, skipping session.update");
        return (0,of.of)({ type: "no-update", value: { initializationData } });
    }
    log/* default.info */.Z.info("EME: Updating MediaKeySession with message");
    return (0,cast_to_observable/* default */.Z)(session.update(message)).pipe((0,catchError/* catchError */.K)((error) => {
        const reason = error instanceof Error ? error.toString() :
            "`session.update` failed";
        throw new encrypted_media_error/* default */.Z("KEY_UPDATE_ERROR", reason);
    }), (0,tap/* tap */.b)(() => { log/* default.info */.Z.info("EME: MediaKeySession update succeeded."); }), (0,mapTo/* mapTo */.h)({ type: "session-updated", value: { session, license: message, initializationData } }));
}
/**
 * @param {MediaKeySession}
 * @param {Object} keySystem
 * @param {Event} keyStatusesEvent
 * @returns {Observable}
 */
function handleKeyStatusesChangeEvent(session, keySystemOptions, keySystem, keyStatusesEvent) {
    log/* default.info */.Z.info("EME: keystatuseschange event received", session, keyStatusesEvent);
    const callback$ = (0,defer/* defer */.P)(() => {
        return (0,rx_try_catch/* default */.Z)(() => {
            if (typeof keySystemOptions.onKeyStatusesChange !== "function") {
                return empty/* EMPTY */.E;
            }
            return (0,cast_to_observable/* default */.Z)(keySystemOptions.onKeyStatusesChange(keyStatusesEvent, session));
        }, undefined);
    }).pipe((0,map/* map */.U)(licenseObject => ({ type: "key-status-change-handled", value: { session, license: licenseObject } })), (0,catchError/* catchError */.K)((error) => {
        const err = new encrypted_media_error/* default */.Z("KEY_STATUS_CHANGE_ERROR", "Unknown `onKeyStatusesChange` error");
        if (!(0,is_null_or_undefined/* default */.Z)(error) &&
            (0,is_non_empty_string/* default */.Z)(error.message)) {
            err.message = error.message;
        }
        throw err;
    }));
    return (0,merge/* merge */.T)(getKeyStatusesEvents(session, keySystemOptions, keySystem), callback$);
}
/**
 * Construct backoff options for the getLicense call.
 * @param {Subject} sessionWarningSubject$ - Subject through which retry
 * warnings will be sent.
 * @param {number|undefined} numberOfRetry - Maximum of amount retried.
 * Equal to `2` if not defined.
 * @returns {Object}
 */
function getLicenseBackoffOptions(sessionWarningSubject$, numberOfRetry) {
    return {
        totalRetry: numberOfRetry !== null && numberOfRetry !== void 0 ? numberOfRetry : 2,
        baseDelay: 200,
        maxDelay: 3000,
        shouldRetry: (error) => error instanceof TimeoutError ||
            (0,is_null_or_undefined/* default */.Z)(error) ||
            error.noRetry !== true,
        onRetry: (error) => sessionWarningSubject$.next({ type: "warning",
            value: formatGetLicenseError(error) }),
    };
}

;// CONCATENATED MODULE: ./src/core/eme/set_server_certificate.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Call the setServerCertificate API with the given certificate.
 * Complete observable on success, throw when failed.
 *
 * TODO Handle returned value?
 * From the spec:
 *   - setServerCertificate resolves with true if everything worked
 *   - it resolves with false if the CDM does not support server
 *     certificates.
 *
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */
function setServerCertificate(mediaKeys, serverCertificate) {
    return (0,defer/* defer */.P)(() => {
        return (0,rx_try_catch/* default */.Z)(() => (0,cast_to_observable/* default */.Z)(mediaKeys.setServerCertificate(serverCertificate)), undefined).pipe((0,catchError/* catchError */.K)((error) => {
            log/* default.warn */.Z.warn("EME: mediaKeys.setServerCertificate returned an error", error);
            const reason = error instanceof Error ? error.toString() :
                "`setServerCertificate` error";
            throw new encrypted_media_error/* default */.Z("LICENSE_SERVER_CERTIFICATE_ERROR", reason);
        }));
    });
}
/**
 * Call the setCertificate API. If it fails just emit the error as warning
 * and complete.
 * @param {MediaKeys} mediaKeys
 * @param {ArrayBuffer} serverCertificate
 * @returns {Observable}
 */
function trySettingServerCertificate(mediaKeys, serverCertificate) {
    return (0,defer/* defer */.P)(() => {
        if (typeof mediaKeys.setServerCertificate !== "function") {
            log/* default.warn */.Z.warn("EME: Could not set the server certificate." +
                " mediaKeys.setServerCertificate is not a function");
            return empty/* EMPTY */.E;
        }
        if (server_certificate_store.hasOne(mediaKeys) === true) {
            log/* default.info */.Z.info("EME: The MediaKeys already has a server certificate, skipping...");
            return empty/* EMPTY */.E;
        }
        log/* default.info */.Z.info("EME: Setting server certificate on the MediaKeys");
        // Because of browser errors, or a user action that can lead to interrupting
        // server certificate setting, we might be left in a status where we don't
        // know if we attached the server certificate or not.
        // Calling `prepare` allow to invalidate temporarily that status.
        server_certificate_store.prepare(mediaKeys);
        return setServerCertificate(mediaKeys, serverCertificate).pipe((0,tap/* tap */.b)(() => { server_certificate_store.set(mediaKeys, serverCertificate); }), (0,ignoreElements/* ignoreElements */.l)(), (0,catchError/* catchError */.K)(error => (0,of.of)({
            type: "warning",
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            value: error,
        })));
    });
}


;// CONCATENATED MODULE: ./src/core/eme/eme_manager.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


















const { EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION } = config/* default */.Z;
const { onEncrypted$ } = event_listeners;
/**
 * EME abstraction used to communicate with the Content Decryption Module (or
 * CDM) to be able to decrypt contents.
 *
 * The `EMEManager` can be given one or multiple key systems. It will choose the
 * appropriate one depending on user settings and browser support.
 * @param {HTMLMediaElement} mediaElement - The MediaElement which will be
 * associated to a MediaKeys object
 * @param {Array.<Object>} keySystemsConfigs - key system configuration
 * @param {Observable} contentProtections$ - Observable emitting external
 * initialization data.
 * @returns {Observable}
 */
function EMEManager(mediaElement, keySystemsConfigs, contentProtections$) {
    log/* default.debug */.Z.debug("EME: Starting EMEManager logic.");
    /**
     * Keep track of all decryption keys handled by this instance of the
     * `EMEManager`.
     * This allows to avoid creating multiple MediaKeySessions handling the same
     * decryption keys.
     */
    const contentSessions = new InitDataStore();
    /**
     * Keep track of which initialization data have been blacklisted in the
     * current instance of the `EMEManager`.
     * If the same initialization data is encountered again, we can directly emit
     * the same `BlacklistedSessionError`.
     */
    const blacklistedInitData = new InitDataStore();
    /** Emit the MediaKeys instance and its related information when ready. */
    const mediaKeysInit$ = initMediaKeys(mediaElement, keySystemsConfigs)
        .pipe((0,mergeMap/* mergeMap */.zg)((mediaKeysEvt) => {
        if (mediaKeysEvt.type !== "attached-media-keys") {
            return (0,of.of)(mediaKeysEvt);
        }
        const { mediaKeys, options } = mediaKeysEvt.value;
        const { serverCertificate } = options;
        if ((0,is_null_or_undefined/* default */.Z)(serverCertificate)) {
            return (0,of.of)(mediaKeysEvt);
        }
        return (0,concat/* concat */.z)(trySettingServerCertificate(mediaKeys, serverCertificate), (0,of.of)(mediaKeysEvt));
    }), (0,shareReplay/* shareReplay */.d)()); // Share side-effects and cache success
    /** Emit when the MediaKeys instance has been attached the HTMLMediaElement. */
    const attachedMediaKeys$ = mediaKeysInit$.pipe((0,filter/* filter */.h)((evt) => {
        return evt.type === "attached-media-keys";
    }), (0,take/* take */.q)(1));
    /** Parsed `encrypted` events coming from the HTMLMediaElement. */
    const mediaEncryptedEvents$ = onEncrypted$(mediaElement).pipe((0,tap/* tap */.b)((evt) => {
        log/* default.debug */.Z.debug("EME: Encrypted event received from media element.", evt);
    }), (0,filter_map/* default */.Z)((evt) => getInitData(evt), null), (0,shareReplay/* shareReplay */.d)({ refCount: true })); // multiple Observables listen to that one
    // as soon as the EMEManager is subscribed
    /** Encryption events coming from the `contentProtections$` argument. */
    const externalEvents$ = contentProtections$.pipe((0,tap/* tap */.b)((evt) => { log/* default.debug */.Z.debug("EME: Encrypted event received from Player", evt); }));
    /** Emit events signaling that an encryption initialization data is encountered. */
    const initializationData$ = (0,merge/* merge */.T)(externalEvents$, mediaEncryptedEvents$);
    /** Create MediaKeySessions and handle the corresponding events. */
    const bindSession$ = initializationData$.pipe(
    // Add attached MediaKeys info once available
    (0,mergeMap/* mergeMap */.zg)((initializationData) => attachedMediaKeys$.pipe((0,map/* map */.U)((mediaKeysEvt) => [initializationData, mediaKeysEvt]))), 
    /* Attach server certificate and create/reuse MediaKeySession */
    (0,mergeMap/* mergeMap */.zg)(([initializationData, mediaKeysEvent]) => {
        const { mediaKeySystemAccess, stores, options } = mediaKeysEvent.value;
        const blacklistError = blacklistedInitData.get(initializationData);
        if (blacklistError !== undefined) {
            if (initializationData.type === undefined) {
                log/* default.error */.Z.error("EME: The current session has already been blacklisted " +
                    "but the current content is not known. Throwing.");
                const { sessionError } = blacklistError;
                sessionError.fatal = true;
                return (0,throwError/* throwError */._)(sessionError);
            }
            log/* default.warn */.Z.warn("EME: The current session has already been blacklisted. " +
                "Blacklisting content.");
            return (0,of.of)({ type: "blacklist-protection-data", value: initializationData });
        }
        const lastKeyUpdate$ = new ReplaySubject/* ReplaySubject */.t(1);
        // First, check that this initialization data is not already handled
        if (options.singleLicensePer === "content" && !contentSessions.isEmpty()) {
            const keyIds = initializationData.keyIds;
            if (keyIds === undefined) {
                log/* default.warn */.Z.warn("EME: Initialization data linked to unknown key id, we'll " +
                    "not able to fallback from it.");
                return (0,of.of)({ type: "init-data-ignored", value: { initializationData } });
            }
            const firstSession = contentSessions.getAll()[0];
            return firstSession.lastKeyUpdate$.pipe((0,mergeMap/* mergeMap */.zg)((evt) => {
                const hasAllNeededKeyIds = keyIds.every(keyId => {
                    for (let i = 0; i < evt.whitelistedKeyIds.length; i++) {
                        if ((0,are_arrays_of_numbers_equal/* default */.Z)(evt.whitelistedKeyIds[i], keyId)) {
                            return true;
                        }
                    }
                });
                if (!hasAllNeededKeyIds) {
                    // Not all keys are available in the current session, blacklist those
                    return (0,of.of)({ type: "keys-update", value: { blacklistedKeyIDs: keyIds,
                            whitelistedKeyIds: [] } });
                }
                // Already handled by the current session.
                // Move corresponding session on top of the cache if it exists
                const { loadedSessionsStore } = mediaKeysEvent.value.stores;
                loadedSessionsStore.reuse(firstSession.initializationData);
                return (0,of.of)({ type: "init-data-ignored", value: { initializationData } });
            }));
        }
        else if (!contentSessions.storeIfNone(initializationData, { initializationData,
            lastKeyUpdate$ })) {
            log/* default.debug */.Z.debug("EME: Init data already received. Skipping it.");
            return (0,of.of)({ type: "init-data-ignored", value: { initializationData } });
        }
        let wantedSessionType;
        if (options.persistentLicense !== true) {
            wantedSessionType = "temporary";
        }
        else if (!canCreatePersistentSession(mediaKeySystemAccess)) {
            log/* default.warn */.Z.warn("EME: Cannot create \"persistent-license\" session: not supported");
            wantedSessionType = "temporary";
        }
        else {
            wantedSessionType = "persistent-license";
        }
        return getSession(initializationData, stores, wantedSessionType)
            .pipe((0,mergeMap/* mergeMap */.zg)((sessionEvt) => {
            switch (sessionEvt.type) {
                case "cleaning-old-session":
                    contentSessions.remove(sessionEvt.value.initializationData);
                    return empty/* EMPTY */.E;
                case "cleaned-old-session":
                    return empty/* EMPTY */.E;
                case "created-session":
                case "loaded-open-session":
                case "loaded-persistent-session":
                    // Do nothing, just to check every possibility is taken
                    break;
                default: // Use TypeScript to check if all possibilities have been checked
                    (0,assert_unreachable/* default */.Z)(sessionEvt);
            }
            const { mediaKeySession, sessionType } = sessionEvt.value;
            /**
             * We only store persistent sessions once its keys are known.
             * This boolean allows to know if this session has already been
             * persisted or not.
             */
            let isSessionPersisted = false;
            // `generateKeyRequest` awaits a single Uint8Array containing all
            // initialization data.
            const concatInitData = (0,byte_parsing/* concat */.zo)(...initializationData.values.map(i => i.data));
            const generateRequest$ = sessionEvt.type !== "created-session" ?
                empty/* EMPTY */.E :
                generateKeyRequest(mediaKeySession, initializationData.type, concatInitData).pipe((0,catchError/* catchError */.K)((error) => {
                    throw new encrypted_media_error/* default */.Z("KEY_GENERATE_REQUEST_ERROR", error instanceof Error ? error.toString() :
                        "Unknown error");
                }), (0,ignoreElements/* ignoreElements */.l)());
            return (0,merge/* merge */.T)(SessionEventsListener(mediaKeySession, options, mediaKeySystemAccess.keySystem, initializationData), generateRequest$)
                .pipe((0,tap/* tap */.b)((evt) => {
                if (evt.type !== "keys-update") {
                    return;
                }
                lastKeyUpdate$.next(evt.value);
                if ((evt.value.whitelistedKeyIds.length === 0 &&
                    evt.value.blacklistedKeyIDs.length === 0) ||
                    sessionType === "temporary" ||
                    stores.persistentSessionsStore === null ||
                    isSessionPersisted) {
                    return;
                }
                const { persistentSessionsStore } = stores;
                cleanOldStoredPersistentInfo(persistentSessionsStore, EME_MAX_STORED_PERSISTENT_SESSION_INFORMATION - 1);
                persistentSessionsStore.add(initializationData, mediaKeySession);
                isSessionPersisted = true;
            }), (0,catchError/* catchError */.K)(err => {
                if (!(err instanceof BlacklistedSessionError)) {
                    throw err;
                }
                blacklistedInitData.store(initializationData, err);
                const { sessionError } = err;
                if (initializationData.type === undefined) {
                    log/* default.error */.Z.error("EME: Current session blacklisted and content not known. " +
                        "Throwing.");
                    sessionError.fatal = true;
                    throw sessionError;
                }
                log/* default.warn */.Z.warn("EME: Current session blacklisted. Blacklisting content.");
                return (0,of.of)({ type: "warning", value: sessionError }, { type: "blacklist-protection-data", value: initializationData });
            }));
        }));
    }));
    return (0,merge/* merge */.T)(mediaKeysInit$, mediaEncryptedEvents$
        .pipe((0,map/* map */.U)(evt => ({ type: "encrypted-event-received", value: evt }))), bindSession$);
}
/**
 * Returns `true` if the given MediaKeySystemAccess can create
 * "persistent-license" MediaKeySessions.
 * @param {MediaKeySystemAccess} mediaKeySystemAccess
 * @returns {Boolean}
 */
function canCreatePersistentSession(mediaKeySystemAccess) {
    const { sessionTypes } = mediaKeySystemAccess.getConfiguration();
    return sessionTypes !== undefined &&
        (0,array_includes/* default */.Z)(sessionTypes, "persistent-license");
}

;// CONCATENATED MODULE: ./src/core/eme/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */





/* harmony default export */ const eme = (EMEManager);



/***/ }),

/***/ 91132:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Store the MediaKeys infos attached to a media element.
const currentMediaState = new WeakMap();
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
    /**
     * Update MediaKeys infos set on a HMTLMediaElement
     * @param {HTMLMediaElement} mediaElement
     * @param {Object} state
     */
    setState(mediaElement, state) {
        currentMediaState.set(mediaElement, state);
    },
    /**
     * Get MediaKeys infos currently set on a HMTLMediaElement
     * @param {HTMLMediaElement} mediaElement
     * @returns {Object}
     */
    getState(mediaElement) {
        const currentState = currentMediaState.get(mediaElement);
        return currentState === undefined ? null :
            currentState;
    },
    /**
     * Remove MediaKeys infos currently set on a HMTLMediaElement
     * @param {HTMLMediaElement} mediaElement
     */
    clearState(mediaElement) {
        currentMediaState.set(mediaElement, null);
    },
});


/***/ }),

/***/ 50225:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ createEMEManager)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(10125);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(65208);
// EXTERNAL MODULE: ./src/compat/eme/custom_media_keys/index.ts + 7 modules
var custom_media_keys = __webpack_require__(39013);
;// CONCATENATED MODULE: ./src/compat/has_eme_apis.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the browser has the minimum needed EME APIs to decrypt a
 * content.
 * @returns {Boolean}
 */
function hasEMEAPIs() {
    return typeof custom_media_keys/* requestMediaKeySystemAccess */.N === "function";
}

// EXTERNAL MODULE: ./src/compat/event_listeners.ts + 4 modules
var event_listeners = __webpack_require__(90315);
// EXTERNAL MODULE: ./src/errors/encrypted_media_error.ts
var encrypted_media_error = __webpack_require__(4029);
// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(41195);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
;// CONCATENATED MODULE: ./src/core/init/create_eme_manager.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const { onEncrypted$ } = event_listeners;
/**
 * Create EMEManager if possible (has the APIs and configuration).
 * Else, return an Observable throwing at the next encrypted event encountered.
 * @param {HTMLMediaElement} mediaElement
 * @param {Array.<Object>} keySystems
 * @param {Observable<Object>} contentProtections$
 * @returns {Observable}
 */
function createEMEManager(mediaElement, keySystems, contentProtections$) {
    const encryptedEvents$ = (0,merge/* merge */.T)(onEncrypted$(mediaElement), contentProtections$);
    if (features/* default.emeManager */.Z.emeManager == null) {
        return (0,merge/* merge */.T)(encryptedEvents$.pipe((0,map/* map */.U)(() => {
            log/* default.error */.Z.error("Init: Encrypted event but EME feature not activated");
            throw new encrypted_media_error/* default */.Z("MEDIA_IS_ENCRYPTED_ERROR", "EME feature not activated.");
        })), (0,of.of)({ type: "eme-disabled" }));
    }
    if (keySystems.length === 0) {
        return (0,merge/* merge */.T)(encryptedEvents$.pipe((0,map/* map */.U)(() => {
            log/* default.error */.Z.error("Init: Ciphered media and no keySystem passed");
            throw new encrypted_media_error/* default */.Z("MEDIA_IS_ENCRYPTED_ERROR", "Media is encrypted and no `keySystems` given");
        })), (0,of.of)({ type: "eme-disabled" }));
    }
    if (!hasEMEAPIs()) {
        return (0,merge/* merge */.T)(encryptedEvents$.pipe((0,map/* map */.U)(() => {
            log/* default.error */.Z.error("Init: Encrypted event but no EME API available");
            throw new encrypted_media_error/* default */.Z("MEDIA_IS_ENCRYPTED_ERROR", "Encryption APIs not found.");
        })), (0,of.of)({ type: "eme-disabled" }));
    }
    log/* default.debug */.Z.debug("Init: Creating EMEManager");
    return features/* default.emeManager */.Z.emeManager(mediaElement, keySystems, contentProtections$);
}


/***/ }),

/***/ 72902:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Construct a "loaded" event.
 * @returns {Object}
 */
function loaded(segmentBuffersStore) {
    return { type: "loaded", value: { segmentBuffersStore } };
}
/**
 * Construct a "stalled" event.
 * @param {Object|null} stalling
 * @returns {Object}
 */
function stalled(stalling) {
    return { type: "stalled", value: stalling };
}
/**
 * Construct a "stalled" event.
 * @param {Object|null} stalling
 * @returns {Object}
 */
function unstalled() {
    return { type: "unstalled", value: null };
}
/**
 * Construct a "decipherabilityUpdate" event.
 * @param {Array.<Object>} arg
 * @returns {Object}
 */
function decipherabilityUpdate(arg) {
    return { type: "decipherabilityUpdate", value: arg };
}
/**
 * Construct a "manifestReady" event.
 * @param {Object} manifest
 * @returns {Object}
 */
function manifestReady(manifest) {
    return { type: "manifestReady", value: { manifest } };
}
/**
 * Construct a "manifestUpdate" event.
 * @returns {Object}
 */
function manifestUpdate() {
    return { type: "manifestUpdate", value: null };
}
/**
 * Construct a "representationChange" event.
 * @param {string} type
 * @param {Object} period
 * @returns {Object}
 */
function nullRepresentation(type, period) {
    return { type: "representationChange",
        value: { type,
            representation: null,
            period } };
}
/**
 * construct a "warning" event.
 * @param {error} value
 * @returns {object}
 */
function warning(value) {
    return { type: "warning", value };
}
/**
 * construct a "reloading-media-source" event.
 * @returns {object}
 */
function reloadingMediaSource() {
    return { type: "reloading-media-source", value: undefined };
}
const INIT_EVENTS = { loaded,
    decipherabilityUpdate,
    manifestReady,
    manifestUpdate,
    nullRepresentation,
    reloadingMediaSource,
    stalled,
    unstalled,
    warning };
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (INIT_EVENTS);


/***/ }),

/***/ 52678:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ seekAndLoadOnMediaEvents)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(70252);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(96705);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/take.js
var take = __webpack_require__(53329);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(53059);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/catchError.js
var catchError = __webpack_require__(7947);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(5842);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(83425);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(75688);
// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(8886);
;// CONCATENATED MODULE: ./src/compat/should_wait_for_data_before_loaded.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * On some browsers, the ready state might never go above `1` when autoplay is
 * blocked. On these cases, for now, we just advertise the content as "loaded".
 * We might go into BUFFERING just after that state, but that's a small price to
 * pay.
 * @param {Boolean} isDirectfile
 * @returns {Boolean}
 */
function shouldWaitForDataBeforeLoaded(isDirectfile, mustPlayInline) {
    if (isDirectfile && browser_detection/* isSafariMobile */.SB) {
        return mustPlayInline;
    }
    return true;
}

;// CONCATENATED MODULE: ./src/compat/should_validate_metadata.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the metadata received after a "loadedmetadata" event has
 * to be validated in the current browser (which means that we do not trust
 * this event on these browsers).
 * @returns {boolean}
 */
function shouldValidateMetadata() {
    return browser_detection/* isSamsungBrowser */.op;
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(24251);
// EXTERNAL MODULE: ./src/utils/cast_to_observable.ts
var cast_to_observable = __webpack_require__(42121);
// EXTERNAL MODULE: ./src/utils/rx-try_catch.ts
var rx_try_catch = __webpack_require__(85033);
;// CONCATENATED MODULE: ./src/compat/play.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Call play on the media element on subscription and return the response as an
 * observable.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
function play$(mediaElement) {
    return (0,defer/* defer */.P)(() => 
    // mediaElement.play is not always a Promise. In the improbable case it
    // throws, I prefer still to catch to return the error wrapped in an
    // Observable
    (0,rx_try_catch/* default */.Z)(() => (0,cast_to_observable/* default */.Z)(mediaElement.play()), undefined));
}

// EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
var browser_compatibility_types = __webpack_require__(18909);
// EXTERNAL MODULE: ./src/compat/event_listeners.ts + 4 modules
var event_listeners = __webpack_require__(90315);
;// CONCATENATED MODULE: ./src/compat/when_loaded_metadata.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Returns an observable emitting a single time, as soon as a seek is possible
 * (the metadata are loaded).
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
function whenLoadedMetadata$(mediaElement) {
    if (mediaElement.readyState >= browser_compatibility_types/* READY_STATES.HAVE_METADATA */.cX.HAVE_METADATA) {
        return (0,of.of)(null);
    }
    else {
        return (0,event_listeners.onLoadedMetadata$)(mediaElement)
            .pipe((0,take/* take */.q)(1));
    }
}

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
;// CONCATENATED MODULE: ./src/core/init/initial_seek_and_play.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Emit once a "can-play" message as soon as the clock$ announce that the content
 * can begin to be played.
 *
 * Warn you if the metadata is not yet loaded metadata by emitting a
 * "not-loaded-metadata" message first.
 * @param {Observable} clock$
 * @returns {Observable}
 */
function canPlay(clock$, mediaElement, isDirectfile) {
    const isLoaded$ = clock$.pipe((0,filter/* filter */.h)((tick) => {
        const { seeking, stalled, readyState, currentRange } = tick;
        if (seeking || stalled !== null) {
            return false;
        }
        if (!shouldWaitForDataBeforeLoaded(isDirectfile, mediaElement.hasAttribute("playsinline"))) {
            return readyState >= 1 && mediaElement.duration > 0;
        }
        if (readyState >= 4 || (readyState === 3 && currentRange !== null)) {
            return shouldValidateMetadata() ? mediaElement.duration > 0 :
                true;
        }
        return false;
    }), (0,take/* take */.q)(1), (0,mapTo/* mapTo */.h)("can-play"));
    if (shouldValidateMetadata() && mediaElement.duration === 0) {
        return (0,concat/* concat */.z)((0,of.of)("not-loaded-metadata"), isLoaded$);
    }
    return isLoaded$;
}
/**
 * Try to play content then handle autoplay errors.
 * @param {HTMLMediaElement} - mediaElement
 * @returns {Observable}
 */
function autoPlay$(mediaElement) {
    return play$(mediaElement).pipe((0,mapTo/* mapTo */.h)("autoplay"), (0,catchError/* catchError */.K)((error) => {
        if (error instanceof Error && error.name === "NotAllowedError") {
            // auto-play was probably prevented.
            log/* default.warn */.Z.warn("Init: Media element can't play." +
                " It may be due to browser auto-play policies.");
            return (0,of.of)("autoplay-blocked");
        }
        else {
            throw error;
        }
    }));
}
/**
 * Returns two Observables:
 *
 *   - seek$: when subscribed, will seek to the wanted started time as soon as
 *     it can. Emit and complete when done.
 *
 *   - load$: when subscribed, will play if and only if the `mustAutoPlay`
 *     option is set as soon as it can. Emit and complete when done.
 *     When this observable emits, it also means that the content is `loaded`
 *     and can begin to play the current content.
 *
 * @param {Object} args
 * @returns {Object}
 */
function seekAndLoadOnMediaEvents({ clock$, mediaElement, startTime, mustAutoPlay, setCurrentTime, isDirectfile }) {
    const seek$ = whenLoadedMetadata$(mediaElement).pipe((0,take/* take */.q)(1), (0,tap/* tap */.b)(() => {
        log/* default.info */.Z.info("Init: Set initial time", startTime);
        const initialTime = typeof startTime === "function" ? startTime() :
            startTime;
        setCurrentTime(initialTime);
    }), (0,shareReplay/* shareReplay */.d)({ refCount: true }));
    const load$ = seek$.pipe((0,mergeMap/* mergeMap */.zg)(() => {
        return canPlay(clock$, mediaElement, isDirectfile).pipe((0,tap/* tap */.b)(() => log/* default.info */.Z.info("Init: Can begin to play content")), (0,mergeMap/* mergeMap */.zg)((evt) => {
            if (evt === "can-play") {
                if (!mustAutoPlay) {
                    if (mediaElement.autoplay) {
                        log/* default.warn */.Z.warn("Init: autoplay is enabled on HTML media element. " +
                            "Media will play as soon as possible.");
                    }
                    return (0,of.of)("loaded");
                }
                return autoPlay$(mediaElement);
            }
            return (0,of.of)(evt);
        }));
    }), (0,shareReplay/* shareReplay */.d)({ refCount: true }));
    return { seek$, load$ };
}


/***/ }),

/***/ 65309:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ initializeDirectfileContent)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js
var empty = __webpack_require__(47485);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(10125);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(75688);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/share.js
var share = __webpack_require__(32139);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
var ignoreElements = __webpack_require__(61030);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(65208);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(96705);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/take.js
var take = __webpack_require__(53329);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js
var mergeMapTo = __webpack_require__(2089);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(30365);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
// EXTERNAL MODULE: ./src/compat/clear_element_src.ts
var clear_element_src = __webpack_require__(38815);
;// CONCATENATED MODULE: ./src/compat/set_element_src.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Set an URL to the element's src.
 * Emit ``undefined`` when done.
 * Unlink src on unsubscription.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {string} url
 * @returns {Observable}
 */
function setElementSrc$(mediaElement, url) {
    return new Observable/* Observable */.y((observer) => {
        log/* default.info */.Z.info("Setting URL to Element", url, mediaElement);
        mediaElement.src = url;
        observer.next(undefined);
        return () => {
            (0,clear_element_src/* default */.Z)(mediaElement);
        };
    });
}

// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(3590);
// EXTERNAL MODULE: ./src/utils/defer_subscriptions.ts + 6 modules
var defer_subscriptions = __webpack_require__(45150);
// EXTERNAL MODULE: ./src/core/init/create_eme_manager.ts + 1 modules
var create_eme_manager = __webpack_require__(50225);
// EXTERNAL MODULE: ./src/core/init/events_generators.ts
var events_generators = __webpack_require__(72902);
// EXTERNAL MODULE: ./src/core/init/initial_seek_and_play.ts + 4 modules
var initial_seek_and_play = __webpack_require__(52678);
// EXTERNAL MODULE: ./src/core/init/throw_on_media_error.ts
var throw_on_media_error = __webpack_require__(41654);
// EXTERNAL MODULE: ./src/core/init/update_playback_rate.ts
var update_playback_rate = __webpack_require__(26087);
;// CONCATENATED MODULE: ./src/core/init/initialize_directfile.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */











/**
 * calculate initial time as a position in seconds.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object|undefined} startAt
 * @returns {number}
 */
function getDirectFileInitialTime(mediaElement, startAt) {
    if (startAt == null) {
        return 0;
    }
    if (startAt.position != null) {
        return startAt.position;
    }
    else if (startAt.wallClockTime != null) {
        return startAt.wallClockTime;
    }
    else if (startAt.fromFirstPosition != null) {
        return startAt.fromFirstPosition;
    }
    const duration = mediaElement.duration;
    if (duration == null || !isFinite(duration)) {
        log/* default.warn */.Z.warn("startAt.fromLastPosition set but no known duration, " +
            "beginning at 0.");
        return 0;
    }
    if (typeof startAt.fromLastPosition === "number") {
        return Math.max(0, duration + startAt.fromLastPosition);
    }
    else if (startAt.percentage != null) {
        const { percentage } = startAt;
        if (percentage >= 100) {
            return duration;
        }
        else if (percentage <= 0) {
            return 0;
        }
        const ratio = +percentage / 100;
        return duration * ratio;
    }
    return 0;
}
/**
 * Launch a content in "Directfile mode".
 * @param {Object} directfileOptions
 * @returns {Observable}
 */
function initializeDirectfileContent({ autoPlay, clock$, keySystems, mediaElement, speed$, setCurrentTime, startAt, url, }) {
    (0,clear_element_src/* default */.Z)(mediaElement);
    if (url == null) {
        throw new Error("No URL for a DirectFile content");
    }
    // Start everything! (Just put the URL in the element's src).
    const linkURL$ = setElementSrc$(mediaElement, url);
    log/* default.debug */.Z.debug("Init: Calculating initial time");
    const initialTime = () => getDirectFileInitialTime(mediaElement, startAt);
    log/* default.debug */.Z.debug("Init: Initial time calculated:", initialTime);
    const { seek$, load$ } = (0,initial_seek_and_play/* default */.Z)({ clock$,
        mediaElement,
        startTime: initialTime,
        mustAutoPlay: autoPlay,
        setCurrentTime,
        isDirectfile: true });
    // Create EME Manager, an observable which will manage every EME-related
    // issue.
    const emeManager$ = linkURL$.pipe((0,mergeMap/* mergeMap */.zg)(() => (0,create_eme_manager/* default */.Z)(mediaElement, keySystems, empty/* EMPTY */.E)), (0,defer_subscriptions/* default */.Z)(), (0,share/* share */.B)());
    // Translate errors coming from the media element into RxPlayer errors
    // through a throwing Observable.
    const mediaError$ = (0,throw_on_media_error/* default */.Z)(mediaElement);
    // Set the speed set by the user on the media element while pausing a
    // little longer while the buffer is empty.
    const playbackRate$ = (0,update_playback_rate/* default */.Z)(mediaElement, speed$, clock$, { pauseWhenStalled: true })
        .pipe((0,ignoreElements/* ignoreElements */.l)());
    // Create Stalling Manager, an observable which will try to get out of
    // various infinite stalling issues
    const stalled$ = clock$.pipe((0,map/* map */.U)(tick => tick.stalled === null ? events_generators/* default.unstalled */.Z.unstalled() :
        events_generators/* default.stalled */.Z.stalled(tick.stalled)));
    // Manage "loaded" event and warn if autoplay is blocked on the current browser
    const loadedEvent$ = emeManager$.pipe((0,filter/* filter */.h)(function isEMEReady(evt) {
        if (evt.type === "created-media-keys") {
            evt.value.attachMediaKeys$.next();
            return true;
        }
        return evt.type === "eme-disabled" || evt.type === "attached-media-keys";
    }), (0,take/* take */.q)(1), (0,mergeMapTo/* mergeMapTo */.j)(load$), (0,mergeMap/* mergeMap */.zg)((evt) => {
        if (evt === "autoplay-blocked") {
            const error = new media_error/* default */.Z("MEDIA_ERR_BLOCKED_AUTOPLAY", "Cannot trigger auto-play automatically: " +
                "your browser does not allow it.");
            return (0,of.of)(events_generators/* default.warning */.Z.warning(error), events_generators/* default.loaded */.Z.loaded(null));
        }
        else if (evt === "not-loaded-metadata") {
            const error = new media_error/* default */.Z("MEDIA_ERR_NOT_LOADED_METADATA", "Cannot load automatically: your browser " +
                "falsely announced having loaded the content.");
            return (0,of.of)(events_generators/* default.warning */.Z.warning(error));
        }
        return (0,of.of)(events_generators/* default.loaded */.Z.loaded(null));
    }));
    const initialSeek$ = seek$.pipe((0,ignoreElements/* ignoreElements */.l)());
    return (0,merge/* merge */.T)(loadedEvent$, initialSeek$, emeManager$, mediaError$, playbackRate$, stalled$);
}


/***/ }),

/***/ 41654:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ throwOnMediaError)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54514);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75688);
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3590);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Returns an observable which throws the right MediaError as soon an "error"
 * event is received through the media element.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
function throwOnMediaError(mediaElement) {
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__/* .fromEvent */ .R)(mediaElement, "error")
        .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__/* .mergeMap */ .zg)(() => {
        const errorCode = mediaElement.error == null ? 0 :
            mediaElement.error.code;
        switch (errorCode) {
            case 1:
                throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z("MEDIA_ERR_ABORTED", "The fetching of the associated resource was aborted " +
                    "by the user's request.");
            case 2:
                throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z("MEDIA_ERR_NETWORK", "A network error occurred which prevented the media " +
                    "from being successfully fetched");
            case 3:
                throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z("MEDIA_ERR_DECODE", "An error occurred while trying to decode the media " +
                    "resource");
            case 4:
                throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z("MEDIA_ERR_SRC_NOT_SUPPORTED", "The media resource has been found to be unsuitable.");
            default:
                throw new _errors__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z("MEDIA_ERR_UNKNOWN", "The HTMLMediaElement errored due to an unknown reason.");
        }
    }));
}


/***/ }),

/***/ 26087:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ updatePlaybackRate)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65637);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24251);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65208);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5118);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(96078);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(17568);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(5842);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6077);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Manage playback speed.
 * Set playback rate set by the user, pause playback when the player appear to
 * stall and restore the speed once it appears to un-stall.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Observable} speed$ - emit speed set by the user
 * @param {Observable} clock$ - Current playback conditions
 * @param {Object} options - Contains the following properties:
 *   - pauseWhenStalled {Boolean|undefined} - true if the player
 *     stalling should lead to a pause until it un-stalls. True by default.
 * @returns {Observable}
 */
function updatePlaybackRate(mediaElement, speed$, clock$, { pauseWhenStalled = true }) {
    let forcePause$;
    if (!pauseWhenStalled) {
        forcePause$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(false);
    }
    else {
        forcePause$ = clock$
            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__/* .map */ .U)((timing) => timing.stalled !== null), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__/* .startWith */ .O)(false), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_3__/* .distinctUntilChanged */ .x)());
    }
    return forcePause$
        .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_4__/* .switchMap */ .w)(shouldForcePause => {
        if (shouldForcePause) {
            return (0,rxjs__WEBPACK_IMPORTED_MODULE_5__/* .defer */ .P)(() => {
                _log__WEBPACK_IMPORTED_MODULE_6__/* .default.info */ .Z.info("Init: Pause playback to build buffer");
                mediaElement.playbackRate = 0;
                return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(0);
            });
        }
        return speed$
            .pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_7__/* .tap */ .b)((speed) => {
            _log__WEBPACK_IMPORTED_MODULE_6__/* .default.info */ .Z.info("Init: Resume playback speed", speed);
            mediaElement.playbackRate = speed;
        }));
    }));
}


/***/ }),

/***/ 71396:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ implementations_image)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(24251);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/types.ts + 1 modules
var types = __webpack_require__(79860);
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/utils/manual_time_ranges.ts
var manual_time_ranges = __webpack_require__(23656);
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/image/image_segment_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Image SegmentBuffer implementation.
 * @class ImageSegmentBuffer
 */
class ImageSegmentBuffer extends types/* SegmentBuffer */.C {
    constructor() {
        log/* default.debug */.Z.debug("ISB: Creating ImageSegmentBuffer");
        super();
        this.bufferType = "image";
        this._buffered = new manual_time_ranges/* default */.Z();
    }
    /**
     * @param {Object} data
     */
    pushChunk(infos) {
        return (0,defer/* defer */.P)(() => {
            var _a, _b;
            log/* default.debug */.Z.debug("ISB: appending new data.");
            if (infos.data.chunk === null) {
                return (0,of.of)(undefined);
            }
            const { appendWindow, chunk } = infos.data;
            const { start, end, timescale } = chunk;
            const appendWindowStart = (_a = appendWindow[0]) !== null && _a !== void 0 ? _a : 0;
            const appendWindowEnd = (_b = appendWindow[1]) !== null && _b !== void 0 ? _b : Infinity;
            const timescaledStart = start / timescale;
            const timescaledEnd = end / timescale;
            const startTime = Math.max(appendWindowStart, timescaledStart);
            const endTime = Math.min(appendWindowEnd, timescaledEnd);
            this._buffered.insert(startTime, endTime);
            if (infos.inventoryInfos !== null) {
                this._segmentInventory.insertChunk(infos.inventoryInfos);
            }
            return (0,of.of)(undefined);
        });
    }
    /**
     * @param {Number} from
     * @param {Number} to
     */
    removeBuffer(start, end) {
        return (0,defer/* defer */.P)(() => {
            log/* default.info */.Z.info("ISB: ignored image data remove order", start, end);
            // Logic removed as it caused more problems than it resolved:
            // Image thumbnails are always downloaded as a single BIF file, meaning that
            // any removing might necessitate to re-load the whole file in the future
            // which seems pointless.
            // In any case, image handling through the regular RxPlayer APIs has been
            // completely deprecated now for several reasons, and should disappear in
            // the next major version.
            return (0,of.of)(undefined);
        });
    }
    /**
     * Indicate that every chunks from a Segment has been given to pushChunk so
     * far.
     * This will update our internal Segment inventory accordingly.
     * The returned Observable will emit and complete successively once the whole
     * segment has been pushed and this indication is acknowledged.
     * @param {Object} infos
     * @returns {Observable}
     */
    endOfSegment(_infos) {
        return (0,defer/* defer */.P)(() => {
            this._segmentInventory.completeSegment(_infos);
            return (0,of.of)(undefined);
        });
    }
    /**
     * Returns the currently buffered data, in a TimeRanges object.
     * @returns {TimeRanges}
     */
    getBufferedRanges() {
        return this._buffered;
    }
    dispose() {
        log/* default.debug */.Z.debug("ISB: disposing image SegmentBuffer");
        this._buffered.remove(0, Infinity);
    }
}

;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/image/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const implementations_image = (ImageSegmentBuffer);


/***/ }),

/***/ 47706:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ html)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(10125);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
var observable_interval = __webpack_require__(75573);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(70252);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(81044);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(24251);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
var startWith = __webpack_require__(5118);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
var switchMapTo = __webpack_require__(97228);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(53059);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(28305);
// EXTERNAL MODULE: ./src/compat/event_listeners.ts + 4 modules
var event_listeners = __webpack_require__(90315);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(30365);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(65208);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(96078);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
// EXTERNAL MODULE: ./src/compat/is_node.ts
var is_node = __webpack_require__(68767);
;// CONCATENATED MODULE: ./src/compat/on_height_width_change.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
const _ResizeObserver = is_node/* default */.Z ? undefined :
    window.ResizeObserver;
/* eslint-enable @typescript-eslint/no-unsafe-member-access */
/* eslint-enable @typescript-eslint/no-unsafe-assignment */
/**
 * Emit the current height and width of the given `element` on subscribtion
 * and each time it changes.
 *
 * On some browsers, we might not be able to rely on a native API to know when
 * it changes, the `interval` argument allow us to provide us an inverval in
 * milliseconds at which we should query that element's size.
 * @param {HTMLElement} element
 * @param {number} interval
 * @returns {Observable}
 */
function onHeightWidthChange(element, interval) {
    return (0,defer/* defer */.P)(() => {
        if (_ResizeObserver !== undefined) {
            let lastHeight = -1;
            let lastWidth = -1;
            return new Observable/* Observable */.y((obs) => {
                const resizeObserver = new _ResizeObserver(entries => {
                    if (entries.length === 0) {
                        log/* default.error */.Z.error("Compat: Resized but no observed element.");
                        return;
                    }
                    const entry = entries[0];
                    const { height, width } = entry.contentRect;
                    if (height !== lastHeight || width !== lastWidth) {
                        lastHeight = height;
                        lastWidth = width;
                        obs.next({ height, width });
                    }
                });
                resizeObserver.observe(element);
                return () => {
                    resizeObserver.disconnect();
                };
            });
        }
        return (0,observable_interval/* interval */.F)(interval).pipe((0,startWith/* startWith */.O)(null), (0,map/* map */.U)(() => {
            const { height, width } = element.getBoundingClientRect();
            return { height, width };
        }), (0,distinctUntilChanged/* distinctUntilChanged */.x)((o, n) => {
            return o.height === n.height && o.width === n.width;
        }));
    });
}

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(86694);
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/types.ts + 1 modules
var types = __webpack_require__(79860);
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/utils/manual_time_ranges.ts
var manual_time_ranges = __webpack_require__(23656);
// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(41195);
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/html/parsers.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Convert text track data into timed HTML Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<Object>}
 * @throws Error - Throw if no parser is found for the given type
 */
function parseTextTrackToElements(type, data, timestampOffset, language) {
    log/* default.debug */.Z.debug("HTSB: Finding parser for html text tracks:", type);
    const parser = features/* default.htmlTextTracksParsers */.Z.htmlTextTracksParsers[type];
    if (typeof parser !== "function") {
        throw new Error("no parser found for the given text track");
    }
    log/* default.debug */.Z.debug("HTSB: Parser found, parsing...");
    const parsed = parser(data, timestampOffset, language);
    log/* default.debug */.Z.debug("HTTB: Parsed successfully!", parsed);
    return parsed;
}

// EXTERNAL MODULE: ./src/utils/assert.ts
var assert = __webpack_require__(25222);
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/html/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Maximum time difference, in seconds, between two text segment's start times
 * and/or end times for them to be considered the same in the
 * HTMLTextSegmentBuffer (used for the "html" textTrackMode).
 *
 * For example for two segments s1 and s2 which have a start time respectively
 * of st1 and st2 and end time of et1 and et2:
 *   - if both the absolute difference between st1 and st2 AND the one between
 *     et1 and et2 is inferior or equal to the MAX_DELTA_BUFFER_TIME, s1 and s2
 *     are considered to target the exact same time. As a consequence, if s2 is
 *     added after s1 in the buffer, s1 will be completely replaced by it and
 *     vice-versa.
 *   - if only one of the two (absolute difference between st1 and st2 OR et1
 *     and et2) is inferior to the MAX_DELTA_BUFFER_TIME then the last added
 *     is not completely considered the same. It WILL still replace - either
 *     partially or completely (depending on the sign of the other difference) -
 *     the previously added segment.
 *   - if both differences are strictly superior to the MAX_DELTA_BUFFER_TIME,
 *     then they are not considered to have the same start nor the same end.
 *     They can still overlap however, and MIGHT thus still replace partially
 *     or completely each other.
 *
 * Setting a value too low might lead to two segments targeting the same time,
 * both being present in the buffer. In worst case scenarios, this could lead
 * to indicate that an unwanted text track is still here (theorically though,
 * this is a case that should never happen for reasons that might be too long
 * to explain here).
 *
 * Setting a value too high might lead to two segments targeting different times
 * to be wrongly believed to target the same time. In worst case scenarios, this
 * could lead to wanted text tracks being removed.
 * @type Number
 */
const MAX_DELTA_BUFFER_TIME = 0.2;
/**
 * @see MAX_DELTA_BUFFER_TIME
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
function areNearlyEqual(a, b) {
    return Math.abs(a - b) <= MAX_DELTA_BUFFER_TIME;
}
/**
 * Get all cues which have data before the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */
function getCuesBefore(cues, time) {
    for (let i = cues.length - 1; i >= 0; i--) {
        const cue = cues[i];
        if (cue.start < time) {
            return cues.slice(0, i + 1);
        }
    }
    return [];
}
/**
 * Get all cues which have data after the given time.
 * @param {Object} cues
 * @param {Number} time
 * @returns {Array.<Object>}
 */
function getCuesAfter(cues, time) {
    for (let i = 0; i < cues.length; i++) {
        const cue = cues[i];
        if (cue.end > time) {
            return cues.slice(i, cues.length);
        }
    }
    return [];
}
/**
 * @param {Object} cuesInfos
 * @param {Number} start
 * @param {Number} end
 * @returns {Array.<Object>}
 */
function removeCuesInfosBetween(cuesInfos, start, end) {
    const endCuesInfos1 = Math.max(cuesInfos.start, start);
    const cues1 = getCuesBefore(cuesInfos.cues, start);
    const cuesInfos1 = { start: cuesInfos.start,
        end: endCuesInfos1,
        cues: cues1 };
    const startCuesInfos2 = Math.min(end, cuesInfos.end);
    const cues2 = getCuesAfter(cuesInfos.cues, end);
    const cuesInfos2 = { start: startCuesInfos2,
        end: cuesInfos.end,
        cues: cues2 };
    return [cuesInfos1, cuesInfos2];
}

;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/html/text_track_cues_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Manage the buffer of the HTMLTextSegmentBuffer.
 * Allows to add, remove and recuperate cues at given times.
 * @class TextTrackCuesStore
 */
class TextTrackCuesStore {
    constructor() {
        this._cuesBuffer = [];
    }
    /**
     * Get corresponding cue(s) for the given time.
     * A cue is an object with three properties:
     *   - start {Number}: start time for which the cue should be displayed.
     *   - end {Number}: end time for which the cue should be displayed.
     *   - element {HTMLElement}: The cue to diplay
     *
     * We do not mutate individual cue here.
     * That is, if the ``get`` method returns the same cue's reference than a
     * previous ``get`` call, its properties are guaranteed to have the exact same
     * values than before, if you did not mutate it on your side.
     * The inverse is true, if the values are the same than before, the reference
     * will stay the same (this is useful to easily check if the DOM should be
     * updated, for example).
     *
     * @param {Number} time
     * @returns {Array.<HTMLElement>} - The cues that need to be displayed at that
     * time.
     */
    get(time) {
        const cuesBuffer = this._cuesBuffer;
        const ret = [];
        // begins at the end as most of the time the player will ask for the last
        // CuesGroup
        for (let i = cuesBuffer.length - 1; i >= 0; i--) {
            const segment = cuesBuffer[i];
            if (time < segment.end && time >= segment.start) {
                const cues = segment.cues;
                for (let j = 0; j < cues.length; j++) {
                    if (time >= cues[j].start && time < cues[j].end) {
                        ret.push(cues[j].element);
                    }
                }
                return ret;
            }
        }
        return [];
    }
    /**
     * Remove cue from a certain range of time.
     * @param {Number} from
     * @param {Number} to
     */
    remove(from, _to) {
        if (true) {
            (0,assert/* default */.Z)(from >= 0);
            (0,assert/* default */.Z)(_to >= 0);
            (0,assert/* default */.Z)(_to > from);
        }
        const to = Math.max(from, _to);
        const cuesBuffer = this._cuesBuffer;
        for (let i = 0; i < cuesBuffer.length; i++) {
            if (cuesBuffer[i].end > from) {
                // this cuesInfos is concerned by the remove
                const startCuesInfos = cuesBuffer[i];
                if (startCuesInfos.start >= to) {
                    // our cuesInfos is strictly after this interval, we have nothing to do
                    return;
                }
                if (startCuesInfos.end >= to) {
                    // our cuesInfos ends after `to`, we have to keep the end of it
                    if (from <= startCuesInfos.start) {
                        // from -> to only remove the start of startCuesInfos
                        startCuesInfos.cues = getCuesAfter(startCuesInfos.cues, to);
                        startCuesInfos.start = to;
                    }
                    else {
                        // from -> to is in the middle part of startCuesInfos
                        const [cuesInfos1, cuesInfos2] = removeCuesInfosBetween(startCuesInfos, from, to);
                        this._cuesBuffer[i] = cuesInfos1;
                        cuesBuffer.splice(i + 1, 0, cuesInfos2);
                    }
                    // No cuesInfos can be concerned after this one, we can quit
                    return;
                }
                // Else remove all part after `from`
                if (startCuesInfos.start >= from) {
                    // all the segment is concerned
                    cuesBuffer.splice(i, 1);
                    i--; // one less element, we have to decrement the loop
                }
                else {
                    // only the end is concerned
                    startCuesInfos.cues = getCuesBefore(startCuesInfos.cues, from);
                    startCuesInfos.end = Math.max(from, startCuesInfos.start);
                }
            }
        }
    }
    /**
     * Insert new cues in our text buffer.
     * cues is an array of objects with three properties:
     *   - start {Number}: start time for which the cue should be displayed.
     *   - end {Number}: end time for which the cue should be displayed.
     *   - element {HTMLElement}: The cue to diplay
     *
     * @param {Array.<Object>} cues - CuesGroups, array of objects with the
     * following properties:
     *   - start {Number}: the time at which the cue will start to be displayed
     *   - end {Number}: the time at which the cue will end to be displayed
     *   - cue {HTMLElement}: The cue
     * @param {Number} start - Start time at which the CuesGroup applies.
     * This is different than the start of the first cue to display in it, this
     * has more to do with the time at which the _text segment_ starts.
     * @param {Number} end - End time at which the CuesGroup applies.
     * This is different than the end of the last cue to display in it, this
     * has more to do with the time at which the _text segment_ ends.
     *
     * TODO add securities to ensure that:
     *   - the start of a CuesGroup is inferior or equal to the start of the first
     *     cue in it
     *   - the end of a CuesGroup is superior or equal to the end of the last
     *     cue in it
     * If those requirements are not met, we could delete some cues when adding
     * a CuesGroup before/after. Find a solution.
     */
    insert(cues, start, end) {
        const cuesBuffer = this._cuesBuffer;
        const cuesInfosToInsert = { start, end, cues };
        /**
         * Called when we found the index of the next cue relative to the cue we
         * want to insert (that is a cue starting after its start or at the same
         * time but ending strictly after its end).
         * Will insert the cue at the right place and update the next cue
         * accordingly.
         * @param {number} indexOfNextCue
         */
        function onIndexOfNextCueFound(indexOfNextCue) {
            const nextCue = cuesBuffer[indexOfNextCue];
            if (nextCue === undefined || // no cue
                areNearlyEqual(cuesInfosToInsert.end, nextCue.end)) // samey end
             {
                //   ours:            |AAAAA|
                //   the current one: |BBBBB|
                //   Result:          |AAAAA|
                cuesBuffer[indexOfNextCue] = cuesInfosToInsert;
            }
            else if (nextCue.start >= cuesInfosToInsert.end) {
                // Either
                //   ours:            |AAAAA|
                //   the current one:         |BBBBBB|
                //   Result:          |AAAAA| |BBBBBB|
                // Or:
                //   ours:            |AAAAA|
                //   the current one:       |BBBBBB|
                //   Result:          |AAAAA|BBBBBB|
                // Add ours before
                cuesBuffer.splice(indexOfNextCue, 0, cuesInfosToInsert);
            }
            else {
                // Either
                //   ours:            |AAAAA|
                //   the current one: |BBBBBBBB|
                //   Result:          |AAAAABBB|
                // Or:
                //   ours:            |AAAAA|
                //   the current one:    |BBBBB|
                //   Result:          |AAAAABBB|
                nextCue.cues = getCuesAfter(nextCue.cues, cuesInfosToInsert.end);
                nextCue.start = cuesInfosToInsert.end;
                cuesBuffer.splice(indexOfNextCue, 0, cuesInfosToInsert);
            }
        }
        for (let i = 0; i < cuesBuffer.length; i++) {
            let cuesInfos = cuesBuffer[i];
            if (start < cuesInfos.end) {
                if (areNearlyEqual(start, cuesInfos.start)) {
                    if (areNearlyEqual(end, cuesInfos.end)) {
                        // exact same segment
                        //   ours:            |AAAAA|
                        //   the current one: |BBBBB|
                        //   Result:          |AAAAA|
                        // Which means:
                        //   1. replace the current cue with ours
                        cuesBuffer[i] = cuesInfosToInsert;
                        return;
                    }
                    else if (end < cuesInfos.end) {
                        // our cue overlaps with the current one:
                        //   ours:            |AAAAA|
                        //   the current one: |BBBBBBBB|
                        //   Result:          |AAAAABBB|
                        // Which means:
                        //   1. remove some cues at the start of the current one
                        //   2. update start of current one
                        //   3. add ours before the current one
                        cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
                        cuesInfos.start = end;
                        cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        return;
                    }
                    // our cue goes beyond the current one:
                    //   ours:            |AAAAAAA|
                    //   the current one: |BBBB|...
                    //   Result:          |AAAAAAA|
                    // Here we have to delete any cuesInfos which end before ours end,
                    // and see about the following one.
                    do {
                        cuesBuffer.splice(i, 1);
                        cuesInfos = cuesBuffer[i];
                    } while (cuesInfos !== undefined && end > cuesInfos.end);
                    onIndexOfNextCueFound(i);
                    return;
                }
                else if (start < cuesInfos.start) {
                    if (end < cuesInfos.start) {
                        // our cue goes strictly before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:           |BBBB|
                        //   Result:          |AAAAAAA| |BBBB|
                        // Which means:
                        //   - add ours before the current one
                        cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        return;
                    }
                    else if (areNearlyEqual(end, cuesInfos.start)) {
                        // our cue goes just before the current one:
                        //   ours:            |AAAAAAA|
                        //   the current one:         |BBBB|
                        //   Result:          |AAAAAAA|BBBB|
                        // Which means:
                        //   - update start time of the current one to be sure
                        //   - add ours before the current one
                        cuesInfos.start = end;
                        cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        return;
                    }
                    else if (areNearlyEqual(end, cuesInfos.end)) {
                        //   ours:            |AAAAAAA|
                        //   the current one:    |BBBB|
                        //   Result:          |AAAAAAA|
                        // Replace
                        cuesBuffer.splice(i, 1, cuesInfosToInsert);
                        return;
                    }
                    else if (end < cuesInfos.end) {
                        //   ours:            |AAAAAAA|
                        //   the current one:     |BBBBB|
                        //   Result:          |AAAAAAABB|
                        cuesInfos.cues = getCuesAfter(cuesInfos.cues, end);
                        cuesInfos.start = end;
                        cuesBuffer.splice(i, 0, cuesInfosToInsert);
                        return;
                    }
                    //   ours:            |AAAAAAA|
                    //   the current one:   |BBB|...
                    //   Result:          |AAAAAAA|...
                    do {
                        cuesBuffer.splice(i, 1);
                        cuesInfos = cuesBuffer[i];
                    } while (cuesInfos !== undefined && end > cuesInfos.end);
                    onIndexOfNextCueFound(i);
                    return;
                }
                // else -> start > cuesInfos.start
                if (areNearlyEqual(cuesInfos.end, end)) {
                    //   ours:              |AAAAAA|
                    //   the current one: |BBBBBBBB|
                    //   Result:          |BBAAAAAA|
                    cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
                    cuesInfos.end = start;
                    cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
                    return;
                }
                else if (cuesInfos.end > end) {
                    //   ours:              |AAAAAA|
                    //   the current one: |BBBBBBBBBBB|
                    //   Result:          |BBAAAAAABBB|
                    const [cuesInfos1, cuesInfos2] = removeCuesInfosBetween(cuesInfos, start, end);
                    this._cuesBuffer[i] = cuesInfos1;
                    cuesBuffer.splice(i + 1, 0, cuesInfosToInsert);
                    cuesBuffer.splice(i + 2, 0, cuesInfos2);
                    return;
                }
                else {
                    //   ours:              |AAAAAA|
                    //   the current one: |BBBBB|...
                    //   Result:          |BBAAAAAA|...
                    cuesInfos.cues = getCuesBefore(cuesInfos.cues, start);
                    cuesInfos.end = start;
                    cuesInfos = cuesBuffer[i + 1];
                    while (cuesInfos !== undefined && end > cuesInfos.end) {
                        cuesBuffer.splice(i, 1);
                        cuesInfos = cuesBuffer[i];
                    }
                    onIndexOfNextCueFound(i);
                    return;
                }
            }
        }
        // no cues group has the end after our current start.
        // These cues should be the last one
        cuesBuffer.push(cuesInfosToInsert);
    }
}

;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/html/update_proportional_elements.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Update size of element which are proportional to the current text track
 * element.
 * Returns `true` if at least a single styling information is proportional,
 * `false` otherwise.
 * @param {number} currentHeight
 * @param {number} currentWidth
 * @param {Object} resolution
 * @param {HTMLElement} textTrackElement
 * @returns {boolean}
 */
function updateProportionalElements(currentHeight, currentWidth, resolution, textTrackElement) {
    const cellUnit = [currentWidth / resolution.columns,
        currentHeight / resolution.rows];
    const proportElts = textTrackElement.getElementsByClassName("proportional-style");
    for (let eltIdx = 0; eltIdx < proportElts.length; eltIdx++) {
        const elt = proportElts[eltIdx];
        if (elt instanceof HTMLElement) {
            const fontSizeVal = elt.getAttribute("data-proportional-font-size");
            if (fontSizeVal !== null && !isNaN(+fontSizeVal)) {
                elt.style.fontSize = String(+fontSizeVal * cellUnit[1]) + "px";
            }
            const widthVal = elt.getAttribute("data-proportional-width");
            if (widthVal !== null && !isNaN(+widthVal)) {
                elt.style.width = String(+widthVal * cellUnit[0]) + "px";
            }
            const heightVal = elt.getAttribute("data-proportional-height");
            if (heightVal !== null && !isNaN(+heightVal)) {
                elt.style.height = String(+heightVal * cellUnit[1]) + "px";
            }
            const lineHeightVal = elt.getAttribute("data-proportional-line-height");
            if (lineHeightVal !== null && !isNaN(+lineHeightVal)) {
                elt.style.lineHeight = String(+lineHeightVal * cellUnit[1]) + "px";
            }
            const leftVal = elt.getAttribute("data-proportional-left");
            if (leftVal !== null && !isNaN(+leftVal)) {
                elt.style.left = String(+leftVal * cellUnit[0]) + "px";
            }
            const topVal = elt.getAttribute("data-proportional-top");
            if (topVal !== null && !isNaN(+topVal)) {
                elt.style.top = String(+topVal * cellUnit[1]) + "px";
            }
            const paddingTopVal = elt.getAttribute("data-proportional-padding-top");
            if (paddingTopVal !== null && !isNaN(+paddingTopVal)) {
                elt.style.paddingTop = String(+paddingTopVal * cellUnit[1]) + "px";
            }
            const paddingBottomVal = elt.getAttribute("data-proportional-padding-bottom");
            if (paddingBottomVal !== null && !isNaN(+paddingBottomVal)) {
                elt.style.paddingBottom = String(+paddingBottomVal * cellUnit[1]) + "px";
            }
            const paddingLeftVal = elt.getAttribute("data-proportional-padding-left");
            if (paddingLeftVal !== null && !isNaN(+paddingLeftVal)) {
                elt.style.paddingLeft = String(+paddingLeftVal * cellUnit[0]) + "px";
            }
            const paddingRightVal = elt.getAttribute("data-proportional-padding-right");
            if (paddingRightVal !== null && !isNaN(+paddingRightVal)) {
                elt.style.paddingRight = String(+paddingRightVal * cellUnit[0]) + "px";
            }
        }
    }
    return proportElts.length > 0;
}

;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/html/html_text_segment_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










const { onEnded$, onSeeked$, onSeeking$ } = event_listeners;
const { MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL, TEXT_TRACK_SIZE_CHECKS_INTERVAL } = config/* default */.Z;
/**
 * Generate the clock at which TextTrack HTML Cues should be refreshed.
 * @param {HTMLMediaElement} videoElement
 * @returns {Observable}
 */
function generateClock(videoElement) {
    const seeking$ = onSeeking$(videoElement);
    const seeked$ = onSeeked$(videoElement);
    const ended$ = onEnded$(videoElement);
    const manualRefresh$ = (0,merge/* merge */.T)(seeked$, ended$);
    const autoRefresh$ = (0,observable_interval/* interval */.F)(MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL)
        .pipe((0,startWith/* startWith */.O)(null));
    return manualRefresh$.pipe((0,startWith/* startWith */.O)(null), (0,switchMapTo/* switchMapTo */.c)((0,concat/* concat */.z)(autoRefresh$.pipe((0,mapTo/* mapTo */.h)(true), (0,takeUntil/* takeUntil */.R)(seeking$)), (0,of.of)(false))));
}
/**
 * @param {Element} element
 * @param {Element} child
 */
function safelyRemoveChild(element, child) {
    try {
        element.removeChild(child);
    }
    catch (_error) {
        log/* default.warn */.Z.warn("HTSB: Can't remove text track: not in the element.");
    }
}
/**
 * @param {HTMLElement} element
 * @returns {Object|null}
 */
function getElementResolution(element) {
    const strRows = element.getAttribute("data-resolution-rows");
    const strColumns = element.getAttribute("data-resolution-columns");
    if (strRows === null || strColumns === null) {
        return null;
    }
    const rows = parseInt(strRows, 10);
    const columns = parseInt(strColumns, 10);
    if (rows === null || columns === null) {
        return null;
    }
    return { rows, columns };
}
/**
 * SegmentBuffer implementation which display buffered TextTracks in the given
 * HTML element.
 * @class HTMLTextSegmentBuffer
 */
class HTMLTextSegmentBuffer extends types/* SegmentBuffer */.C {
    /**
     * @param {HTMLMediaElement} videoElement
     * @param {HTMLElement} textTrackElement
     */
    constructor(videoElement, textTrackElement) {
        log/* default.debug */.Z.debug("HTSB: Creating HTMLTextSegmentBuffer");
        super();
        this.bufferType = "text";
        this._buffered = new manual_time_ranges/* default */.Z();
        this._videoElement = videoElement;
        this._textTrackElement = textTrackElement;
        this._clearSizeUpdates$ = new Subject/* Subject */.xQ();
        this._destroy$ = new Subject/* Subject */.xQ();
        this._buffer = new TextTrackCuesStore();
        this._currentCues = [];
        // update text tracks
        generateClock(this._videoElement)
            .pipe((0,takeUntil/* takeUntil */.R)(this._destroy$))
            .subscribe((shouldDisplay) => {
            if (!shouldDisplay) {
                this._disableCurrentCues();
                return;
            }
            // to spread the time error, we divide the regular chosen interval.
            const time = Math.max(this._videoElement.currentTime +
                (MAXIMUM_HTML_TEXT_TRACK_UPDATE_INTERVAL / 1000) / 2, 0);
            const cues = this._buffer.get(time);
            if (cues.length === 0) {
                this._disableCurrentCues();
            }
            else {
                this._displayCues(cues);
            }
        });
    }
    /**
     * Push segment on Subscription.
     * @param {Object} infos
     * @returns {Observable}
     */
    pushChunk(infos) {
        return (0,defer/* defer */.P)(() => {
            this.pushChunkSync(infos);
            return (0,of.of)(undefined);
        });
    }
    /**
     * Remove buffered data.
     * @param {number} start - start position, in seconds
     * @param {number} end - end position, in seconds
     * @returns {Observable}
     */
    removeBuffer(start, end) {
        return (0,defer/* defer */.P)(() => {
            this.removeBufferSync(start, end);
            return (0,of.of)(undefined);
        });
    }
    /**
     * Indicate that every chunks from a Segment has been given to pushChunk so
     * far.
     * This will update our internal Segment inventory accordingly.
     * The returned Observable will emit and complete successively once the whole
     * segment has been pushed and this indication is acknowledged.
     * @param {Object} infos
     * @returns {Observable}
     */
    endOfSegment(_infos) {
        return (0,defer/* defer */.P)(() => {
            this._segmentInventory.completeSegment(_infos);
            return (0,of.of)(undefined);
        });
    }
    /**
     * Returns the currently buffered data, in a TimeRanges object.
     * @returns {TimeRanges}
     */
    getBufferedRanges() {
        return this._buffered;
    }
    dispose() {
        log/* default.debug */.Z.debug("HTSB: Disposing HTMLTextSegmentBuffer");
        this._disableCurrentCues();
        this._buffer.remove(0, Infinity);
        this._buffered.remove(0, Infinity);
        this._destroy$.next();
        this._destroy$.complete();
    }
    /**
     * Push the text track contained in `data` to the HTMLTextSegmentBuffer
     * synchronously.
     * Returns a boolean:
     *   - `true` if text tracks have been added the the HTMLTextSegmentBuffer's
     *     buffer after that segment has been added.
     *   - `false` if no text tracks have been added the the
     *     HTMLTextSegmentBuffer's buffer (e.g. empty text-track, incoherent times
     *     etc.)
     *
     * /!\ This method won't add any data to the linked inventory.
     * Please use the `pushChunk` method for most use-cases.
     * @param {Object} data
     * @returns {boolean}
     */
    pushChunkSync(infos) {
        var _a, _b;
        log/* default.debug */.Z.debug("HTSB: Appending new html text tracks");
        const { timestampOffset, appendWindow, chunk } = infos.data;
        if (chunk === null) {
            return;
        }
        const { start: startTime, end: endTime, data: dataString, type, language } = chunk;
        const appendWindowStart = (_a = appendWindow[0]) !== null && _a !== void 0 ? _a : 0;
        const appendWindowEnd = (_b = appendWindow[1]) !== null && _b !== void 0 ? _b : Infinity;
        const cues = parseTextTrackToElements(type, dataString, timestampOffset, language);
        if (appendWindowStart !== 0 && appendWindowEnd !== Infinity) {
            // Removing before window start
            let i = 0;
            while (i < cues.length && cues[i].end <= appendWindowStart) {
                i++;
            }
            cues.splice(0, i);
            i = 0;
            while (i < cues.length && cues[i].start < appendWindowStart) {
                cues[i].start = appendWindowStart;
                i++;
            }
            // Removing after window end
            i = cues.length - 1;
            while (i >= 0 && cues[i].start >= appendWindowEnd) {
                i--;
            }
            cues.splice(i, cues.length);
            i = cues.length - 1;
            while (i >= 0 && cues[i].end > appendWindowEnd) {
                cues[i].end = appendWindowEnd;
                i--;
            }
        }
        let start;
        if (startTime !== undefined) {
            start = Math.max(appendWindowStart, startTime);
        }
        else {
            if (cues.length <= 0) {
                log/* default.warn */.Z.warn("HTSB: Current text tracks have no cues nor start time. Aborting");
                return;
            }
            log/* default.warn */.Z.warn("HTSB: No start time given. Guessing from cues.");
            start = cues[0].start;
        }
        let end;
        if (endTime !== undefined) {
            end = Math.min(appendWindowEnd, endTime);
        }
        else {
            if (cues.length <= 0) {
                log/* default.warn */.Z.warn("HTSB: Current text tracks have no cues nor end time. Aborting");
                return;
            }
            log/* default.warn */.Z.warn("HTSB: No end time given. Guessing from cues.");
            end = cues[cues.length - 1].end;
        }
        if (end <= start) {
            log/* default.warn */.Z.warn("HTSB: Invalid text track appended: ", "the start time is inferior or equal to the end time.");
            return;
        }
        if (infos.inventoryInfos !== null) {
            this._segmentInventory.insertChunk(infos.inventoryInfos);
        }
        this._buffer.insert(cues, start, end);
        this._buffered.insert(start, end);
    }
    /**
     * Remove buffer data between the given start and end, synchronously.
     * @param {number} start
     * @param {number} end
     */
    removeBufferSync(start, end) {
        log/* default.debug */.Z.debug("HTSB: Removing html text track data", start, end);
        this._buffer.remove(start, end);
        this._buffered.remove(start, end);
    }
    /**
     * Remove the current cue from being displayed.
     */
    _disableCurrentCues() {
        this._clearSizeUpdates$.next();
        if (this._currentCues.length > 0) {
            for (let i = 0; i < this._currentCues.length; i++) {
                safelyRemoveChild(this._textTrackElement, this._currentCues[i].element);
            }
            this._currentCues = [];
        }
    }
    /**
     * Display a new Cue. If one was already present, it will be replaced.
     * @param {HTMLElement} element
     */
    _displayCues(elements) {
        const nothingChanged = this._currentCues.length === elements.length &&
            this._currentCues.every((current, index) => current.element === elements[index]);
        if (nothingChanged) {
            return;
        }
        // Remove and re-display everything
        // TODO More intelligent handling
        this._clearSizeUpdates$.next();
        for (let i = 0; i < this._currentCues.length; i++) {
            safelyRemoveChild(this._textTrackElement, this._currentCues[i].element);
        }
        this._currentCues = [];
        for (let i = 0; i < elements.length; i++) {
            const element = elements[i];
            const resolution = getElementResolution(element);
            this._currentCues.push({ element, resolution });
            this._textTrackElement.appendChild(element);
        }
        const proportionalCues = this._currentCues
            .filter((cue) => cue.resolution !== null);
        if (proportionalCues.length > 0) {
            // update propertionally-sized elements periodically
            onHeightWidthChange(this._textTrackElement, TEXT_TRACK_SIZE_CHECKS_INTERVAL)
                .pipe((0,takeUntil/* takeUntil */.R)(this._clearSizeUpdates$), (0,takeUntil/* takeUntil */.R)(this._destroy$))
                .subscribe(({ height, width }) => {
                for (let i = 0; i < proportionalCues.length; i++) {
                    const { resolution, element } = proportionalCues[i];
                    updateProportionalElements(height, width, resolution, element);
                }
            });
        }
    }
}

;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/html/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ const html = (HTMLTextSegmentBuffer);


/***/ }),

/***/ 10486:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ text_native)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(24251);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(8886);
;// CONCATENATED MODULE: ./src/compat/add_text_track.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Add text track to the given media element.
 *
 * Returns an object with the following properties:
 *   - track {TextTrack}: the added text track
 *   - trackElement {HTMLElement|undefined}: the added <track> element.
 *     undefined if no trackElement was added.
 *
 * @param {HTMLMediaElement} mediaElement
 * @param {Boolean} hidden - If `true`, the text track will be hidden by
 * default. If `false`, the text track will be directly showing.
 * @returns {Object}
 */
function addTextTrack(mediaElement, hidden) {
    var _a, _b;
    let track;
    let trackElement;
    const kind = "subtitles";
    if (browser_detection/* isIEOrEdge */.YM) {
        const tracksLength = mediaElement.textTracks.length;
        track = (tracksLength > 0 ? mediaElement.textTracks[tracksLength - 1] :
            mediaElement.addTextTrack(kind));
        track.mode = hidden ? ((_a = track.HIDDEN) !== null && _a !== void 0 ? _a : "hidden") :
            ((_b = track.SHOWING) !== null && _b !== void 0 ? _b : "showing");
    }
    else {
        trackElement = document.createElement("track");
        mediaElement.appendChild(trackElement);
        track = trackElement.track;
        trackElement.kind = kind;
        track.mode = hidden ? "hidden" : "showing";
    }
    return { track, trackElement };
}

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
;// CONCATENATED MODULE: ./src/compat/remove_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Return true if given cue is active.
 * @param {TextTrack} track
 * @param {TextTrackCue} cue
 * @returns {boolean}
 */
function isActiveCue(track, cue) {
    const { activeCues } = track;
    if (activeCues === null) {
        return false;
    }
    for (let i = 0; i < activeCues.length; i++) {
        if (activeCues[i] === cue) {
            return true;
        }
    }
    return false;
}
/**
 * Remove cue from text track.
 * @param {TextTrack} track
 * @param {TextTrackCue} cue
 */
function removeCue(track, cue) {
    // On Firefox, cue doesn't dissapear when it is removed from track. Track
    // should be hidden, and shown again after removing cue, in order to
    // definitely clean the cue.
    if (browser_detection/* isFirefox */.vU && isActiveCue(track, cue)) {
        const trackMode = track.mode;
        track.mode = "hidden";
        try {
            track.removeCue(cue);
        }
        catch (err) {
            log/* default.warn */.Z.warn("Compat: Could not remove cue from text track.");
        }
        track.mode = trackMode;
        return;
    }
    try {
        track.removeCue(cue);
    }
    catch (err) {
        log/* default.warn */.Z.warn("Compat: Could not remove cue from text track.");
    }
}

// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/types.ts + 1 modules
var types = __webpack_require__(79860);
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/utils/manual_time_ranges.ts
var manual_time_ranges = __webpack_require__(23656);
// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(41195);
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/native/parsers.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Convert text track data into timed VTT Cues.
 * @param {string} type - Text track format wanted
 * @param {string} data - Text track data
 * @param {Number} timestampOffset - offset to apply to every timed text
 * @param {string} [language] - language of the text tracks
 * @returns {Array.<VTTCue>}
 * @throws Error - Throw if no parser is found for the given type
 */
function parseTextTrackToCues(type, data, timestampOffset, language) {
    log/* default.debug */.Z.debug("NTSB: Finding parser for native text tracks:", type);
    const parser = features/* default.nativeTextTracksParsers */.Z.nativeTextTracksParsers[type];
    if (typeof parser !== "function") {
        throw new Error("no parser found for the given text track");
    }
    log/* default.debug */.Z.debug("NTSB: Parser found, parsing...");
    const parsed = parser(data, timestampOffset, language);
    log/* default.debug */.Z.debug("NTSB: Parsed successfully!", parsed);
    return parsed;
}

;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/native/native_text_segment_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Implementation of an SegmentBuffer for "native" text tracks.
 * "Native" text tracks rely on a `<track>` HTMLElement and its associated
 * expected behavior to display subtitles synchronized to the video.
 * @class NativeTextSegmentBuffer
 */
class NativeTextSegmentBuffer extends types/* SegmentBuffer */.C {
    /**
     * @param {HTMLMediaElement} videoElement
     * @param {Boolean} hideNativeSubtitle
     */
    constructor(videoElement, hideNativeSubtitle) {
        log/* default.debug */.Z.debug("NTSB: Creating NativeTextSegmentBuffer");
        super();
        const { track, trackElement } = addTextTrack(videoElement, hideNativeSubtitle);
        this.bufferType = "text";
        this._buffered = new manual_time_ranges/* default */.Z();
        this._videoElement = videoElement;
        this._track = track;
        this._trackElement = trackElement;
    }
    /**
     * @param {Object} infos
     * @returns {Observable}
     */
    pushChunk(infos) {
        return (0,defer/* defer */.P)(() => {
            var _a, _b;
            log/* default.debug */.Z.debug("NTSB: Appending new native text tracks");
            if (infos.data.chunk === null) {
                return (0,of.of)(undefined);
            }
            const { timestampOffset, appendWindow, chunk } = infos.data;
            const { start: startTime, end: endTime, data: dataString, type, language } = chunk;
            const appendWindowStart = (_a = appendWindow[0]) !== null && _a !== void 0 ? _a : 0;
            const appendWindowEnd = (_b = appendWindow[1]) !== null && _b !== void 0 ? _b : Infinity;
            const cues = parseTextTrackToCues(type, dataString, timestampOffset, language);
            if (appendWindowStart !== 0 && appendWindowEnd !== Infinity) {
                // Removing before window start
                let i = 0;
                while (i < cues.length && cues[i].endTime <= appendWindowStart) {
                    i++;
                }
                cues.splice(0, i);
                i = 0;
                while (i < cues.length && cues[i].startTime < appendWindowStart) {
                    cues[i].startTime = appendWindowStart;
                    i++;
                }
                // Removing after window end
                i = cues.length - 1;
                while (i >= 0 && cues[i].startTime >= appendWindowEnd) {
                    i--;
                }
                cues.splice(i, cues.length);
                i = cues.length - 1;
                while (i >= 0 && cues[i].endTime > appendWindowEnd) {
                    cues[i].endTime = appendWindowEnd;
                    i--;
                }
            }
            let start;
            if (startTime !== undefined) {
                start = Math.max(appendWindowStart, startTime);
            }
            else {
                if (cues.length <= 0) {
                    log/* default.warn */.Z.warn("NTSB: Current text tracks have no cues nor start time. Aborting");
                    return (0,of.of)(undefined);
                }
                log/* default.warn */.Z.warn("NTSB: No start time given. Guessing from cues.");
                start = cues[0].startTime;
            }
            let end;
            if (endTime !== undefined) {
                end = Math.min(appendWindowEnd, endTime);
            }
            else {
                if (cues.length <= 0) {
                    log/* default.warn */.Z.warn("NTSB: Current text tracks have no cues nor end time. Aborting");
                    return (0,of.of)(undefined);
                }
                log/* default.warn */.Z.warn("NTSB: No end time given. Guessing from cues.");
                end = cues[cues.length - 1].endTime;
            }
            if (end <= start) {
                log/* default.warn */.Z.warn("NTSB: Invalid text track appended: ", "the start time is inferior or equal to the end time.");
                return (0,of.of)(undefined);
            }
            if (cues.length > 0) {
                const firstCue = cues[0];
                // NOTE(compat): cleanup all current cues if the newly added
                // ones are in the past. this is supposed to fix an issue on
                // IE/Edge.
                // TODO Move to compat
                const currentCues = this._track.cues;
                if (currentCues !== null && currentCues.length > 0) {
                    if (firstCue.startTime < currentCues[currentCues.length - 1].startTime) {
                        this._removeData(firstCue.startTime, +Infinity);
                    }
                }
                for (let i = 0; i < cues.length; i++) {
                    this._track.addCue(cues[i]);
                }
            }
            this._buffered.insert(start, end);
            if (infos.inventoryInfos !== null) {
                this._segmentInventory.insertChunk(infos.inventoryInfos);
            }
            return (0,of.of)(undefined);
        });
    }
    /**
     * Remove buffered data.
     * @param {number} start - start position, in seconds
     * @param {number} end - end position, in seconds
     * @returns {Observable}
     */
    removeBuffer(start, end) {
        return (0,defer/* defer */.P)(() => {
            this._removeData(start, end);
            return (0,of.of)(undefined);
        });
    }
    /**
     * Indicate that every chunks from a Segment has been given to pushChunk so
     * far.
     * This will update our internal Segment inventory accordingly.
     * The returned Observable will emit and complete successively once the whole
     * segment has been pushed and this indication is acknowledged.
     * @param {Object} infos
     * @returns {Observable}
     */
    endOfSegment(_infos) {
        return (0,defer/* defer */.P)(() => {
            this._segmentInventory.completeSegment(_infos);
            return (0,of.of)(undefined);
        });
    }
    /**
     * Returns the currently buffered data, in a TimeRanges object.
     * @returns {TimeRanges}
     */
    getBufferedRanges() {
        return this._buffered;
    }
    dispose() {
        log/* default.debug */.Z.debug("NTSB: Aborting NativeTextSegmentBuffer");
        this._removeData(0, Infinity);
        const { _trackElement, _videoElement } = this;
        if (_trackElement !== undefined && _videoElement.hasChildNodes()) {
            try {
                _videoElement.removeChild(_trackElement);
            }
            catch (e) {
                log/* default.warn */.Z.warn("NTSB: Can't remove track element from the video");
            }
        }
        this._track.mode = "disabled";
        if (this._trackElement !== undefined) {
            this._trackElement.innerHTML = "";
        }
    }
    _removeData(start, end) {
        log/* default.debug */.Z.debug("NTSB: Removing native text track data", start, end);
        const track = this._track;
        const cues = track.cues;
        if (cues !== null) {
            for (let i = cues.length - 1; i >= 0; i--) {
                const cue = cues[i];
                const { startTime, endTime } = cue;
                if (startTime >= start && startTime <= end && endTime <= end) {
                    removeCue(track, cue);
                }
            }
        }
        this._buffered.remove(start, end);
    }
}

;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/text/native/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const text_native = (NativeTextSegmentBuffer);


/***/ }),

/***/ 79860:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "C": () => (/* binding */ SegmentBuffer),
  "f": () => (/* binding */ SegmentBufferOperation)
});

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(86694);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
// EXTERNAL MODULE: ./src/manifest/are_same_content.ts
var are_same_content = __webpack_require__(96667);
// EXTERNAL MODULE: ./src/utils/take_first_set.ts
var take_first_set = __webpack_require__(66365);
;// CONCATENATED MODULE: ./src/core/segment_buffers/segment_inventory.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




const { MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE, MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, MINIMUM_SEGMENT_SIZE } = config/* default */.Z;
/**
 * Keep track of every chunk downloaded and currently in the linked media
 * buffer.
 *
 * The main point of this class is to know which chunks are already pushed to
 * the corresponding media buffer, at which bitrate, and which have been garbage-collected
 * since by the browser (and thus may need to be re-loaded).
 * @class SegmentInventory
 */
class SegmentInventory {
    constructor() {
        this._inventory = [];
    }
    /**
     * Reset the whole inventory.
     */
    reset() {
        this._inventory.length = 0;
    }
    /**
     * Infer each segment's bufferedStart and bufferedEnd from the TimeRanges
     * given.
     *
     * The TimeRanges object given should come from the media buffer linked to
     * that SegmentInventory.
     *
     * /!\ A SegmentInventory should not be associated to multiple media buffers
     * at a time, so each `synchronizeBuffered` call should be given a TimeRanges
     * coming from the same buffer.
     * @param {TimeRanges}
     */
    synchronizeBuffered(buffered) {
        const inventory = this._inventory;
        let inventoryIndex = 0; // Current index considered.
        let thisSegment = inventory[0]; // Current segmentInfos considered
        /** Type of buffer considered, used for logs */
        const bufferType = thisSegment === null || thisSegment === void 0 ? void 0 : thisSegment.infos.adaptation.type;
        const rangesLength = buffered.length;
        for (let i = 0; i < rangesLength; i++) {
            if (thisSegment === undefined) { // we arrived at the end of our inventory
                return;
            }
            // take the i'nth contiguous buffered TimeRange
            const rangeStart = buffered.start(i);
            const rangeEnd = buffered.end(i);
            if (rangeEnd - rangeStart < MINIMUM_SEGMENT_SIZE) {
                log/* default.warn */.Z.warn("SI: skipped TimeRange when synchronizing because it was too small", bufferType, rangeStart, rangeEnd);
                continue;
            }
            const indexBefore = inventoryIndex; // keep track of that number
            // Find the first segment either within this TimeRange or completely past
            // it:
            // skip until first segment with at least `MINIMUM_SEGMENT_SIZE` past the
            // start of that range.
            while (thisSegment !== undefined &&
                ((0,take_first_set/* default */.Z)(thisSegment.bufferedEnd, thisSegment.end)
                    - rangeStart) < MINIMUM_SEGMENT_SIZE) {
                thisSegment = inventory[++inventoryIndex];
            }
            // Contains infos about the last garbage-collected segment before
            // `thisSegment`.
            let lastDeletedSegmentInfos = null;
            // remove garbage-collected segments
            // (not in that TimeRange nor in the previous one)
            const numberOfSegmentToDelete = inventoryIndex - indexBefore;
            if (numberOfSegmentToDelete > 0) {
                const lastDeletedSegment = // last garbage-collected segment
                 inventory[indexBefore + numberOfSegmentToDelete - 1];
                lastDeletedSegmentInfos = {
                    end: (0,take_first_set/* default */.Z)(lastDeletedSegment.bufferedEnd, lastDeletedSegment.end),
                    precizeEnd: lastDeletedSegment.precizeEnd,
                };
                log/* default.debug */.Z.debug(`SI: ${numberOfSegmentToDelete} segments GCed.`, bufferType);
                inventory.splice(indexBefore, numberOfSegmentToDelete);
                inventoryIndex = indexBefore;
            }
            if (thisSegment === undefined) {
                return;
            }
            // If the current segment is actually completely outside that range (it
            // is contained in one of the next one), skip that part.
            if (rangeEnd -
                (0,take_first_set/* default */.Z)(thisSegment.bufferedStart, thisSegment.start)
                >= MINIMUM_SEGMENT_SIZE) {
                guessBufferedStartFromRangeStart(thisSegment, rangeStart, lastDeletedSegmentInfos, bufferType);
                if (inventoryIndex === inventory.length - 1) {
                    guessBufferedEndFromRangeEnd(thisSegment, rangeEnd, bufferType);
                    return;
                }
                thisSegment = inventory[++inventoryIndex];
                // Make contiguous until first segment outside that range
                let thisSegmentStart = (0,take_first_set/* default */.Z)(thisSegment.bufferedStart, thisSegment.start);
                let thisSegmentEnd = (0,take_first_set/* default */.Z)(thisSegment.bufferedEnd, thisSegment.end);
                const nextRangeStart = i < rangesLength - 1 ? buffered.start(i + 1) :
                    undefined;
                while (thisSegment !== undefined &&
                    (rangeEnd - thisSegmentStart) >= MINIMUM_SEGMENT_SIZE &&
                    (nextRangeStart === undefined ||
                        rangeEnd - thisSegmentStart >= thisSegmentEnd - nextRangeStart)) {
                    const prevSegment = inventory[inventoryIndex - 1];
                    // those segments are contiguous, we have no way to infer their real
                    // end
                    if (prevSegment.bufferedEnd === undefined) {
                        prevSegment.bufferedEnd = thisSegment.precizeStart ? thisSegment.start :
                            prevSegment.end;
                        log/* default.debug */.Z.debug("SI: calculating buffered end of contiguous segment", bufferType, prevSegment.bufferedEnd, prevSegment.end);
                    }
                    thisSegment.bufferedStart = prevSegment.bufferedEnd;
                    thisSegment = inventory[++inventoryIndex];
                    if (thisSegment !== undefined) {
                        thisSegmentStart = (0,take_first_set/* default */.Z)(thisSegment.bufferedStart, thisSegment.start);
                        thisSegmentEnd = (0,take_first_set/* default */.Z)(thisSegment.bufferedEnd, thisSegment.end);
                    }
                }
            }
            // update the bufferedEnd of the last segment in that range
            const lastSegmentInRange = inventory[inventoryIndex - 1];
            if (lastSegmentInRange !== undefined) {
                guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd, bufferType);
            }
        }
        // if we still have segments left, they are not affiliated to any range.
        // They might have been garbage collected, delete them from here.
        if (thisSegment != null) {
            log/* default.debug */.Z.debug("SI: last segments have been GCed", bufferType, inventoryIndex, inventory.length);
            inventory.splice(inventoryIndex, inventory.length - inventoryIndex);
        }
        if (bufferType !== undefined && log/* default.getLevel */.Z.getLevel() === "DEBUG") {
            log/* default.debug */.Z.debug(`SI: current ${bufferType} inventory timeline:\n` +
                prettyPrintInventory(this._inventory));
        }
    }
    /**
     * Add a new chunk in the inventory.
     *
     * Chunks are decodable sub-parts of a whole segment. Once all chunks in a
     * segment have been inserted, you should call the `completeSegment` method.
     * @param {Object} chunkInformation
     */
    insertChunk({ period, adaptation, representation, segment, start, end }) {
        if (segment.isInit) {
            return;
        }
        const bufferType = adaptation.type;
        if (start >= end) {
            log/* default.warn */.Z.warn("SI: Invalid chunked inserted: starts before it ends", bufferType, start, end);
            return;
        }
        const inventory = this._inventory;
        const newSegment = { partiallyPushed: true,
            estimatedStart: start,
            start,
            end,
            precizeStart: false,
            precizeEnd: false,
            bufferedStart: undefined,
            bufferedEnd: undefined,
            infos: { segment, period, adaptation, representation } };
        // begin by the end as in most use cases this will be faster
        for (let i = inventory.length - 1; i >= 0; i--) {
            const segmentI = inventory[i];
            if ((segmentI.start) <= start) {
                if ((segmentI.end) <= start) {
                    // our segment is after, push it after this one
                    //
                    // Case 1:
                    //   prevSegment  : |------|
                    //   newSegment   :        |======|
                    //   ===>         : |------|======|
                    //
                    // Case 2:
                    //   prevSegment  : |------|
                    //   newSegment   :          |======|
                    //   ===>         : |------| |======|
                    log/* default.debug */.Z.debug("SI: Pushing segment strictly after previous one.", bufferType, start, segmentI.end);
                    this._inventory.splice(i + 1, 0, newSegment);
                    i += 2; // Go to segment immediately after newSegment
                    while (i < inventory.length && inventory[i].start < newSegment.end) {
                        if (inventory[i].end > newSegment.end) {
                            // The next segment ends after newSegment.
                            // Mutate the next segment.
                            //
                            // Case 1:
                            //   prevSegment  : |------|
                            //   newSegment   :        |======|
                            //   nextSegment  :            |----|
                            //   ===>         : |------|======|-|
                            log/* default.debug */.Z.debug("SI: Segment pushed updates the start of the next one", bufferType, newSegment.end, inventory[i].start);
                            inventory[i].start = newSegment.end;
                            inventory[i].bufferedStart = undefined;
                            inventory[i].precizeStart = inventory[i].precizeStart &&
                                newSegment.precizeEnd;
                            return;
                        }
                        // The next segment was completely contained in newSegment.
                        // Remove it.
                        //
                        // Case 1:
                        //   prevSegment  : |------|
                        //   newSegment   :        |======|
                        //   nextSegment  :          |---|
                        //   ===>         : |------|======|
                        //
                        // Case 2:
                        //   prevSegment  : |------|
                        //   newSegment   :        |======|
                        //   nextSegment  :          |----|
                        //   ===>         : |------|======|
                        log/* default.debug */.Z.debug("SI: Segment pushed removes the next one", bufferType, start, end, inventory[i].start, inventory[i].end);
                        inventory.splice(i, 1);
                    }
                    return;
                }
                else {
                    if (segmentI.start === start) {
                        if (segmentI.end <= end) {
                            // In those cases, replace
                            //
                            // Case 1:
                            //  prevSegment  : |-------|
                            //  newSegment   : |=======|
                            //  ===>         : |=======|
                            //
                            // Case 2:
                            //  prevSegment  : |-------|
                            //  newSegment   : |==========|
                            //  ===>         : |==========|
                            log/* default.debug */.Z.debug("SI: Segment pushed replace another one", bufferType, start, end, segmentI.end);
                            this._inventory.splice(i, 1, newSegment);
                            i += 1; // Go to segment immediately after newSegment
                            while (i < inventory.length && inventory[i].start < newSegment.end) {
                                if (inventory[i].end > newSegment.end) {
                                    // The next segment ends after newSegment.
                                    // Mutate the next segment.
                                    //
                                    // Case 1:
                                    //   newSegment   : |======|
                                    //   nextSegment  :      |----|
                                    //   ===>         : |======|--|
                                    log/* default.debug */.Z.debug("SI: Segment pushed updates the start of the next one", bufferType, newSegment.end, inventory[i].start);
                                    inventory[i].start = newSegment.end;
                                    inventory[i].bufferedStart = undefined;
                                    inventory[i].precizeStart = inventory[i].precizeStart &&
                                        newSegment.precizeEnd;
                                    return;
                                }
                                // The next segment was completely contained in newSegment.
                                // Remove it.
                                //
                                // Case 1:
                                //   newSegment   : |======|
                                //   nextSegment  :   |---|
                                //   ===>         : |======|
                                //
                                // Case 2:
                                //   newSegment   : |======|
                                //   nextSegment  :   |----|
                                //   ===>         : |======|
                                log/* default.debug */.Z.debug("SI: Segment pushed removes the next one", bufferType, start, end, inventory[i].start, inventory[i].end);
                                inventory.splice(i, 1);
                            }
                            return;
                        }
                        else {
                            // The previous segment starts at the same time and finishes
                            // after the new segment.
                            // Update the start of the previous segment and put the new
                            // segment before.
                            //
                            // Case 1:
                            //  prevSegment  : |------------|
                            //  newSegment   : |==========|
                            //  ===>         : |==========|-|
                            log/* default.debug */.Z.debug("SI: Segment pushed ends before another with the same start", bufferType, start, end, segmentI.end);
                            inventory.splice(i, 0, newSegment);
                            segmentI.start = newSegment.end;
                            segmentI.bufferedStart = undefined;
                            segmentI.precizeStart = segmentI.precizeStart &&
                                newSegment.precizeEnd;
                            return;
                        }
                    }
                    else {
                        if (segmentI.end <= newSegment.end) {
                            // our segment has a "complex" relation with this one,
                            // update the old one end and add this one after it.
                            //
                            // Case 1:
                            //  prevSegment  : |-------|
                            //  newSegment   :    |======|
                            //  ===>         : |--|======|
                            //
                            // Case 2:
                            //  prevSegment  : |-------|
                            //  newSegment   :    |====|
                            //  ===>         : |--|====|
                            log/* default.debug */.Z.debug("SI: Segment pushed updates end of previous one", bufferType, start, end, segmentI.start, segmentI.end);
                            this._inventory.splice(i + 1, 0, newSegment);
                            segmentI.end = newSegment.start;
                            segmentI.bufferedEnd = undefined;
                            segmentI.precizeEnd = segmentI.precizeEnd &&
                                newSegment.precizeStart;
                            i += 2; // Go to segment immediately after newSegment
                            while (i < inventory.length && inventory[i].start < newSegment.end) {
                                if (inventory[i].end > newSegment.end) {
                                    // The next segment ends after newSegment.
                                    // Mutate the next segment.
                                    //
                                    // Case 1:
                                    //   newSegment   : |======|
                                    //   nextSegment  :      |----|
                                    //   ===>         : |======|--|
                                    log/* default.debug */.Z.debug("SI: Segment pushed updates the start of the next one", bufferType, newSegment.end, inventory[i].start);
                                    inventory[i].start = newSegment.end;
                                    inventory[i].bufferedStart = undefined;
                                    inventory[i].precizeStart = inventory[i].precizeStart &&
                                        newSegment.precizeEnd;
                                    return;
                                }
                                // The next segment was completely contained in newSegment.
                                // Remove it.
                                //
                                // Case 1:
                                //   newSegment   : |======|
                                //   nextSegment  :   |---|
                                //   ===>         : |======|
                                //
                                // Case 2:
                                //   newSegment   : |======|
                                //   nextSegment  :   |----|
                                //   ===>         : |======|
                                log/* default.debug */.Z.debug("SI: Segment pushed removes the next one", bufferType, start, end, inventory[i].start, inventory[i].end);
                                inventory.splice(i, 1);
                            }
                            return;
                        }
                        else {
                            // The previous segment completely recovers the new segment.
                            // Split the previous segment into two segments, before and after
                            // the new segment.
                            //
                            // Case 1:
                            //  prevSegment  : |---------|
                            //  newSegment   :    |====|
                            //  ===>         : |--|====|-|
                            log/* default.debug */.Z.debug("SI: Segment pushed is contained in a previous one", bufferType, start, end, segmentI.start, segmentI.end);
                            const nextSegment = { partiallyPushed: segmentI.partiallyPushed,
                                start: newSegment.end,
                                end: segmentI.end,
                                precizeStart: segmentI.precizeStart &&
                                    segmentI.precizeEnd &&
                                    newSegment.precizeEnd,
                                precizeEnd: segmentI.precizeEnd,
                                bufferedStart: undefined,
                                bufferedEnd: segmentI.end,
                                infos: segmentI.infos };
                            segmentI.end = newSegment.start;
                            segmentI.bufferedEnd = undefined;
                            segmentI.precizeEnd = segmentI.precizeEnd &&
                                newSegment.precizeStart;
                            inventory.splice(i + 1, 0, newSegment);
                            inventory.splice(i + 2, 0, nextSegment);
                            return;
                        }
                    }
                }
            }
        }
        // if we got here, we are at the first segment
        // check bounds of the previous first segment
        const firstSegment = this._inventory[0];
        if (firstSegment === undefined) { // we do not have any segment yet
            log/* default.debug */.Z.debug("SI: first segment pushed", bufferType, start, end);
            this._inventory.push(newSegment);
            return;
        }
        if (firstSegment.start >= end) {
            // our segment is before, put it before
            //
            // Case 1:
            //  firstSegment :      |----|
            //  newSegment   : |====|
            //  ===>         : |====|----|
            //
            // Case 2:
            //  firstSegment :        |----|
            //  newSegment   : |====|
            //  ===>         : |====| |----|
            log/* default.debug */.Z.debug("SI: Segment pushed comes before all previous ones", bufferType, start, end, firstSegment.start);
            this._inventory.splice(0, 0, newSegment);
        }
        else if (firstSegment.end <= end) {
            // Our segment is bigger, replace the first
            //
            // Case 1:
            //  firstSegment :   |---|
            //  newSegment   : |=======|
            //  ===>         : |=======|
            //
            // Case 2:
            //  firstSegment :   |-----|
            //  newSegment   : |=======|
            //  ===>         : |=======|
            log/* default.debug */.Z.debug("SI: Segment pushed starts before and completely " +
                "recovers the previous first one", bufferType, start, end, firstSegment.start, firstSegment.end);
            this._inventory.splice(0, 1, newSegment);
            while (inventory.length > 1 && inventory[1].start < newSegment.end) {
                if (inventory[1].end > newSegment.end) {
                    // The next segment ends after newSegment.
                    // Mutate the next segment.
                    //
                    // Case 1:
                    //   newSegment   : |======|
                    //   nextSegment  :      |----|
                    //   ===>         : |======|--|
                    log/* default.debug */.Z.debug("SI: Segment pushed updates the start of the next one", bufferType, newSegment.end, inventory[1].start);
                    inventory[1].start = newSegment.end;
                    inventory[1].bufferedStart = undefined;
                    inventory[1].precizeStart = newSegment.precizeEnd;
                    return;
                }
                // The next segment was completely contained in newSegment.
                // Remove it.
                //
                // Case 1:
                //   newSegment   : |======|
                //   nextSegment  :   |---|
                //   ===>         : |======|
                //
                // Case 2:
                //   newSegment   : |======|
                //   nextSegment  :   |----|
                //   ===>         : |======|
                log/* default.debug */.Z.debug("SI: Segment pushed removes the next one", bufferType, start, end, inventory[1].start, inventory[1].end);
                inventory.splice(1, 1);
            }
            return;
        }
        else {
            // our segment has a "complex" relation with the first one,
            // update the old one start and add this one before it.
            //
            // Case 1:
            //  firstSegment :    |------|
            //  newSegment   : |======|
            //  ===>         : |======|--|
            log/* default.debug */.Z.debug("SI: Segment pushed start of the next one", bufferType, start, end, firstSegment.start, firstSegment.end);
            firstSegment.start = end;
            firstSegment.bufferedStart = undefined;
            firstSegment.precizeStart = newSegment.precizeEnd;
            this._inventory.splice(0, 0, newSegment);
            return;
        }
    }
    /**
     * Indicate that inserted chunks can now be considered as a complete segment.
     * Take in argument the same content than what was given to `insertChunk` for
     * the corresponding chunks.
     * @param {Object} content
     */
    completeSegment(content) {
        if (content.segment.isInit) {
            return;
        }
        const inventory = this._inventory;
        let foundIt = false;
        for (let i = 0; i < inventory.length; i++) {
            if ((0,are_same_content/* default */.Z)(inventory[i].infos, content)) {
                if (foundIt) {
                    log/* default.warn */.Z.warn("SI: Completed Segment is splitted.", content);
                }
                foundIt = true;
                const firstI = i;
                i += 1;
                while (i < inventory.length &&
                    (0,are_same_content/* default */.Z)(inventory[i].infos, content)) {
                    i++;
                }
                const lastI = i - 1;
                const length = lastI - firstI;
                const lastEnd = inventory[lastI].end;
                const lastBufferedEnd = inventory[lastI].bufferedEnd;
                if (length > 0) {
                    this._inventory.splice(firstI + 1, length);
                    i -= length;
                }
                this._inventory[firstI].partiallyPushed = false;
                this._inventory[firstI].end = lastEnd;
                this._inventory[firstI].bufferedEnd = lastBufferedEnd;
            }
        }
        if (!foundIt) {
            log/* default.warn */.Z.warn("SI: Completed Segment not found", content);
        }
    }
    /**
     * Returns the whole inventory.
     *
     * To get a list synchronized with what a media buffer actually has buffered
     * you might want to call `synchronizeBuffered` before calling this method.
     * @returns {Array.<Object>}
     */
    getInventory() {
        return this._inventory;
    }
}
/**
 * Returns `true` if the buffered start of the given chunk looks coherent enough
 * relatively to what is announced in the Manifest.
 * @param {Object} thisSegment
 * @returns {Boolean}
 */
function bufferedStartLooksCoherent(thisSegment) {
    if (thisSegment.bufferedStart === undefined ||
        thisSegment.partiallyPushed) {
        return false;
    }
    const { start, end } = thisSegment;
    const duration = end - start;
    return Math.abs(start - thisSegment.bufferedStart) <=
        MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE &&
        (thisSegment.bufferedEnd === undefined ||
            thisSegment.bufferedEnd > thisSegment.bufferedStart &&
                Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart -
                    duration) <= Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3));
}
/**
 * Returns `true` if the buffered end of the given chunk looks coherent enough
 * relatively to what is announced in the Manifest.
 * @param {Object} thisSegment
 * @returns {Boolean}
 */
function bufferedEndLooksCoherent(thisSegment) {
    if (thisSegment.bufferedEnd === undefined ||
        thisSegment.partiallyPushed) {
        return false;
    }
    const { start, end } = thisSegment;
    const duration = end - start;
    return Math.abs(end - thisSegment.bufferedEnd) <=
        MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE &&
        thisSegment.bufferedStart != null &&
        thisSegment.bufferedEnd > thisSegment.bufferedStart &&
        Math.abs(thisSegment.bufferedEnd - thisSegment.bufferedStart -
            duration) <= Math.min(MAX_MANIFEST_BUFFERED_DURATION_DIFFERENCE, duration / 3);
}
/**
 * Evaluate the given buffered Chunk's buffered start from its range's start,
 * considering that this chunk is the first one in it.
 * @param {Object} firstSegmentInRange
 * @param {number} rangeStart
 * @param {Object} lastDeletedSegmentInfos
 */
function guessBufferedStartFromRangeStart(firstSegmentInRange, rangeStart, lastDeletedSegmentInfos, bufferType) {
    if (firstSegmentInRange.bufferedStart !== undefined) {
        if (firstSegmentInRange.bufferedStart < rangeStart) {
            log/* default.debug */.Z.debug("SI: Segment partially GCed at the start", bufferType, firstSegmentInRange.bufferedStart, rangeStart);
            firstSegmentInRange.bufferedStart = rangeStart;
        }
        if (!firstSegmentInRange.precizeStart &&
            bufferedStartLooksCoherent(firstSegmentInRange)) {
            firstSegmentInRange.start = firstSegmentInRange.bufferedStart;
            firstSegmentInRange.precizeStart = true;
        }
    }
    else if (firstSegmentInRange.precizeStart) {
        log/* default.debug */.Z.debug("SI: buffered start is precize start", bufferType, firstSegmentInRange.start);
        firstSegmentInRange.bufferedStart = firstSegmentInRange.start;
    }
    else if (lastDeletedSegmentInfos !== null &&
        lastDeletedSegmentInfos.end > rangeStart &&
        (lastDeletedSegmentInfos.precizeEnd ||
            firstSegmentInRange.start - lastDeletedSegmentInfos.end <=
                MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE)) {
        log/* default.debug */.Z.debug("SI: buffered start is end of previous segment", bufferType, rangeStart, firstSegmentInRange.start, lastDeletedSegmentInfos.end);
        firstSegmentInRange.bufferedStart = lastDeletedSegmentInfos.end;
        if (bufferedStartLooksCoherent(firstSegmentInRange)) {
            firstSegmentInRange.start = lastDeletedSegmentInfos.end;
            firstSegmentInRange.precizeStart = true;
        }
    }
    else if (firstSegmentInRange.start - rangeStart <=
        MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE) {
        log/* default.debug */.Z.debug("SI: found true buffered start", bufferType, rangeStart, firstSegmentInRange.start);
        firstSegmentInRange.bufferedStart = rangeStart;
        if (bufferedStartLooksCoherent(firstSegmentInRange)) {
            firstSegmentInRange.start = rangeStart;
            firstSegmentInRange.precizeStart = true;
        }
    }
    else if (rangeStart < firstSegmentInRange.start) {
        log/* default.debug */.Z.debug("SI: range start too far from expected start", bufferType, rangeStart, firstSegmentInRange.start);
    }
    else {
        log/* default.debug */.Z.debug("SI: Segment appears immediately garbage collected at the start", bufferType, firstSegmentInRange.bufferedStart, rangeStart);
        firstSegmentInRange.bufferedStart = rangeStart;
    }
}
/**
 * Evaluate the given buffered Chunk's buffered end from its range's end,
 * considering that this chunk is the last one in it.
 * @param {Object} firstSegmentInRange
 * @param {number} rangeStart
 * @param {Object} infos
 */
function guessBufferedEndFromRangeEnd(lastSegmentInRange, rangeEnd, bufferType) {
    if (lastSegmentInRange.bufferedEnd !== undefined) {
        if (lastSegmentInRange.bufferedEnd > rangeEnd) {
            log/* default.debug */.Z.debug("SI: Segment partially GCed at the end", bufferType, lastSegmentInRange.bufferedEnd, rangeEnd);
            lastSegmentInRange.bufferedEnd = rangeEnd;
        }
        if (!lastSegmentInRange.precizeEnd &&
            rangeEnd - lastSegmentInRange.end <= MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE &&
            bufferedEndLooksCoherent(lastSegmentInRange)) {
            lastSegmentInRange.precizeEnd = true;
            lastSegmentInRange.end = rangeEnd;
        }
    }
    else if (lastSegmentInRange.precizeEnd) {
        log/* default.debug */.Z.debug("SI: buffered end is precize end", bufferType, lastSegmentInRange.end);
        lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;
    }
    else if (rangeEnd - lastSegmentInRange.end <=
        MAX_MANIFEST_BUFFERED_START_END_DIFFERENCE) {
        log/* default.debug */.Z.debug("SI: found true buffered end", bufferType, rangeEnd, lastSegmentInRange.end);
        lastSegmentInRange.bufferedEnd = rangeEnd;
        if (bufferedEndLooksCoherent(lastSegmentInRange)) {
            lastSegmentInRange.end = rangeEnd;
            lastSegmentInRange.precizeEnd = true;
        }
    }
    else if (rangeEnd > lastSegmentInRange.end) {
        log/* default.debug */.Z.debug("SI: range end too far from expected end", bufferType, rangeEnd, lastSegmentInRange.end);
        lastSegmentInRange.bufferedEnd = lastSegmentInRange.end;
    }
    else {
        log/* default.debug */.Z.debug("SI: Segment appears immediately garbage collected at the end", bufferType, lastSegmentInRange.bufferedEnd, rangeEnd);
        lastSegmentInRange.bufferedEnd = rangeEnd;
    }
}
/**
 * Pretty print the inventory, to easily note which segments are where in the
 * current buffer.
 *
 * This is mostly useful when logging.
 *
 * @example
 * This function is called by giving it the inventory, such as:
 * ```js
 * prettyPrintInventory(inventory);
 * ```
 *
 * Let's consider this possible return:
 * ```
 * 0.00|A|9.00 ~ 9.00|B|45.08 ~ 282.08|B|318.08
 * [A] P: gen-dash-period-0 || R: video/5(2362822)
 * [B] P: gen-dash-period-0 || R: video/6(2470094)
 * ```
 * We have a first part, from 0 to 9 seconds, which contains segments for
 * the Representation with the id "video/5" and an associated bitrate of
 * 2362822 bits per seconds (in the Period with the id "gen-dash-period-0").
 *
 * Then from 9.00 seconds to 45.08 seconds, we have segments from another
 * Representation from the same Period (with the id "video/6" and a bitrate
 * of 2470094 bits per seconds).
 *
 * At last we have a long time between 45.08 and 282.08 with no segment followed
 * by a segment from that same Representation between 282.08 seconds and 318.08
 * seconds.
 * @param {Array.<Object>} inventory
 * @returns {string}
 */
function prettyPrintInventory(inventory) {
    const roundingError = 1 / 60;
    const encounteredReps = {};
    const letters = [];
    let lastChunk = null;
    let lastLetter = null;
    function generateNewLetter(infos) {
        const currentLetter = String.fromCharCode(letters.length + 65);
        letters.push({ letter: currentLetter,
            periodId: infos.period.id,
            representationId: infos.representation.id,
            bitrate: infos.representation.bitrate });
        return currentLetter;
    }
    let str = "";
    for (let i = 0; i < inventory.length; i++) {
        const chunk = inventory[i];
        if (chunk.bufferedStart !== undefined && chunk.bufferedEnd !== undefined) {
            const periodId = chunk.infos.period.id;
            const representationId = chunk.infos.representation.id;
            const encounteredPeriod = encounteredReps[periodId];
            let currentLetter;
            if (encounteredPeriod === undefined) {
                currentLetter = generateNewLetter(chunk.infos);
                encounteredReps[periodId] = { [representationId]: currentLetter };
            }
            else if (encounteredPeriod[representationId] === undefined) {
                currentLetter = generateNewLetter(chunk.infos);
                encounteredPeriod[representationId] = currentLetter;
            }
            else {
                currentLetter = encounteredPeriod[representationId];
            }
            if (lastChunk === null) {
                str += `${chunk.bufferedStart.toFixed(2)}|${currentLetter}|`;
            }
            else if (lastLetter === currentLetter) {
                if (lastChunk.bufferedEnd + roundingError < chunk.bufferedStart) {
                    str += `${lastChunk.bufferedEnd.toFixed(2)} ~ ` +
                        `${chunk.bufferedStart.toFixed(2)}|${currentLetter}|`;
                }
            }
            else {
                str += `${lastChunk.bufferedEnd.toFixed(2)} ~ ` +
                    `${chunk.bufferedStart.toFixed(2)}|${currentLetter}|`;
            }
            lastChunk = chunk;
            lastLetter = currentLetter;
        }
    }
    if (lastChunk !== null) {
        str += String(lastChunk.end.toFixed(2));
    }
    letters.forEach(letterInfo => {
        var _a;
        str += `\n[${letterInfo.letter}] ` +
            `P: ${letterInfo.periodId} || R: ${letterInfo.representationId}` +
            `(${(_a = letterInfo.bitrate) !== null && _a !== void 0 ? _a : "unknown bitrate"})`;
    });
    return str;
}

;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/types.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Class allowing to push segments and remove data to a buffer to be able
 * to decode them in the future as well as retrieving information about which
 * segments have already been pushed.
 *
 * A `SegmentBuffer` can rely on a browser's SourceBuffer as well as being
 * entirely defined in the code.
 *
 * A SegmentBuffer is associated to a given "bufferType" (e.g. "audio",
 * "video", "text") and allows to push segments as well as removing part of
 * already-pushed segments for that type.
 *
 * Because a segment can be divided into multiple chunks, one should call the
 * `endOfSegment` method once all chunks of a given segment have been pushed
 * (through the `pushChunk` method) to validate that a segment has been
 * completely pushed.
 * It is expected to push chunks from only one segment at a time before calling
 * the `endOfSegment` function for that segment. Pushing chunks from multiple
 * segments in parallel could have unexpected result depending on the underlying
 * implementation.
 * TODO reflect that in the API?
 *
 * A SegmentBuffer also maintains an "inventory", which is the current
 * list of segments contained in the underlying buffer.
 * This inventory has to be manually "synchronized" (through the
 * `synchronizeInventory` method) before being retrieved (through the
 * `getInventory` method).
 *
 * Also depending on the underlying implementation, the various operations
 * performed on a `SegmentBuffer` (push/remove/endOfSegment) can happen
 * synchronously or asynchronously.
 * In the latter case, such operations are put in a FIFO Queue.
 * You can retrieve the current queue of operations by calling the
 * `getPendingOperations` method.
 * If operations happens synchronously, this method will just return an empty
 * array.
 */
class SegmentBuffer {
    constructor() {
        // Use SegmentInventory by default for inventory purposes
        this._segmentInventory = new SegmentInventory();
    }
    /**
     * The maintained inventory can fall out of sync from garbage collection or
     * other events.
     *
     * This methods allow to manually trigger a synchronization. It should be
     * called before retrieving Segment information from it (e.g. with
     * `getInventory`).
     */
    synchronizeInventory() {
        // The default implementation just use the SegmentInventory
        this._segmentInventory.synchronizeBuffered(this.getBufferedRanges());
    }
    /**
     * Returns the currently buffered data for which the content is known with
     * the corresponding content information.
     * /!\ This data can fall out of sync with the real buffered ranges. Please
     * call `synchronizeInventory` before to make sure it is correctly
     * synchronized.
     * @returns {Array.<Object>}
     */
    getInventory() {
        // The default implementation just use the SegmentInventory
        return this._segmentInventory.getInventory();
    }
    /**
     * Returns the list of every operations that the `SegmentBuffer` is still
     * processing. From the one with the highest priority (like the one being
     * processed)
     * @returns {Array.<Object>}
     */
    getPendingOperations() {
        // Return no pending operation by default (for synchronous SegmentBuffers)
        return [];
    }
}
/**
 * Enum used by a SegmentBuffer as a discriminant in its queue of
 * "operations".
 */
var SegmentBufferOperation;
(function (SegmentBufferOperation) {
    SegmentBufferOperation[SegmentBufferOperation["Push"] = 0] = "Push";
    SegmentBufferOperation[SegmentBufferOperation["Remove"] = 1] = "Remove";
    SegmentBufferOperation[SegmentBufferOperation["EndOfSegment"] = 2] = "EndOfSegment";
})(SegmentBufferOperation || (SegmentBufferOperation = {}));


/***/ }),

/***/ 23656:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ ManualTimeRanges)
/* harmony export */ });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25222);
/* harmony import */ var _utils_ranges__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26042);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Simulate TimeRanges as returned by SourceBuffer.prototype.buffered.
 * Add an "insert" and "remove" methods to manually update it.
 * @class ManualTimeRanges
 */
class ManualTimeRanges {
    constructor() {
        this._ranges = [];
        this.length = 0;
    }
    insert(start, end) {
        if (true) {
            (0,_utils_assert__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(start >= 0, "invalid start time");
            (0,_utils_assert__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(end - start > 0, "invalid end time");
        }
        (0,_utils_ranges__WEBPACK_IMPORTED_MODULE_1__/* .insertInto */ .kR)(this._ranges, { start, end });
        this.length = this._ranges.length;
    }
    remove(start, end) {
        if (true) {
            (0,_utils_assert__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(start >= 0, "invalid start time");
            (0,_utils_assert__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(end - start > 0, "invalid end time");
        }
        const rangesToIntersect = [];
        if (start > 0) {
            rangesToIntersect.push({ start: 0, end: start });
        }
        if (end < Infinity) {
            rangesToIntersect.push({ start: end, end: Infinity });
        }
        this._ranges = (0,_utils_ranges__WEBPACK_IMPORTED_MODULE_1__/* .keepRangeIntersection */ .tn)(this._ranges, rangesToIntersect);
        this.length = this._ranges.length;
    }
    start(index) {
        if (index >= this._ranges.length) {
            throw new Error("INDEX_SIZE_ERROR");
        }
        return this._ranges[index].start;
    }
    end(index) {
        if (index >= this._ranges.length) {
            throw new Error("INDEX_SIZE_ERROR");
        }
        return this._ranges[index].end;
    }
}


/***/ }),

/***/ 22090:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ AssertionError)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Error due to an abnormal assertion fails.
 *
 * @class AssertionError
 * @extends Error
 */
class AssertionError extends Error {
    /**
     * @param {string} message
     */
    constructor(message) {
        super();
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(this, AssertionError.prototype);
        this.name = "AssertionError";
        this.message = message;
    }
}


/***/ }),

/***/ 4029:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ EncryptedMediaError)
/* harmony export */ });
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35659);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63878);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Error linked to the encryption of the media.
 *
 * @class EncryptedMediaError
 * @extends Error
 */
class EncryptedMediaError extends Error {
    /**
     * @param {string} code
     * @param {string} reason
     * @Param {Boolean} fatal
     */
    constructor(code, reason) {
        super();
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(this, EncryptedMediaError.prototype);
        this.name = "EncryptedMediaError";
        this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__/* .ErrorTypes.ENCRYPTED_MEDIA_ERROR */ .ZB.ENCRYPTED_MEDIA_ERROR;
        this.code = code;
        this.message = (0,_error_message__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(this.name, this.code, reason);
        this.fatal = false;
    }
}


/***/ }),

/***/ 35659:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ZB": () => (/* binding */ ErrorTypes),
/* harmony export */   "br": () => (/* binding */ NetworkErrorTypes),
/* harmony export */   "SM": () => (/* binding */ ErrorCodes)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ErrorTypes = {
    NETWORK_ERROR: "NETWORK_ERROR",
    MEDIA_ERROR: "MEDIA_ERROR",
    ENCRYPTED_MEDIA_ERROR: "ENCRYPTED_MEDIA_ERROR",
    OTHER_ERROR: "OTHER_ERROR",
};
const NetworkErrorTypes = {
    TIMEOUT: "TIMEOUT",
    ERROR_EVENT: "ERROR_EVENT",
    ERROR_HTTP_CODE: "ERROR_HTTP_CODE",
    PARSE_ERROR: "PARSE_ERROR",
};
const ErrorCodes = {
    PIPELINE_LOAD_ERROR: "PIPELINE_LOAD_ERROR",
    PIPELINE_PARSE_ERROR: "PIPELINE_PARSE_ERROR",
    INTEGRITY_ERROR: "INTEGRITY_ERROR",
    MANIFEST_PARSE_ERROR: "MANIFEST_PARSE_ERROR",
    MANIFEST_INCOMPATIBLE_CODECS_ERROR: "MANIFEST_INCOMPATIBLE_CODECS_ERROR",
    MANIFEST_UPDATE_ERROR: "MANIFEST_UPDATE_ERROR",
    MANIFEST_UNSUPPORTED_ADAPTATION_TYPE: "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE",
    MEDIA_STARTING_TIME_NOT_FOUND: "MEDIA_STARTING_TIME_NOT_FOUND",
    MEDIA_TIME_BEFORE_MANIFEST: "MEDIA_TIME_BEFORE_MANIFEST",
    MEDIA_TIME_AFTER_MANIFEST: "MEDIA_TIME_AFTER_MANIFEST",
    MEDIA_TIME_NOT_FOUND: "MEDIA_TIME_NOT_FOUND",
    NO_PLAYABLE_REPRESENTATION: "NO_PLAYABLE_REPRESENTATION",
    MEDIA_IS_ENCRYPTED_ERROR: "MEDIA_IS_ENCRYPTED_ERROR",
    CREATE_MEDIA_KEYS_ERROR: "CREATE_MEDIA_KEYS_ERROR",
    KEY_ERROR: "KEY_ERROR",
    KEY_STATUS_CHANGE_ERROR: "KEY_STATUS_CHANGE_ERROR",
    KEY_UPDATE_ERROR: "KEY_UPDATE_ERROR",
    KEY_LOAD_ERROR: "KEY_LOAD_ERROR",
    KEY_LOAD_TIMEOUT: "KEY_LOAD_TIMEOUT",
    KEY_GENERATE_REQUEST_ERROR: "KEY_GENERATE_REQUEST_ERROR",
    INCOMPATIBLE_KEYSYSTEMS: "INCOMPATIBLE_KEYSYSTEMS",
    INVALID_ENCRYPTED_EVENT: "INVALID_ENCRYPTED_EVENT",
    INVALID_KEY_SYSTEM: "INVALID_KEY_SYSTEM",
    LICENSE_SERVER_CERTIFICATE_ERROR: "LICENSE_SERVER_CERTIFICATE_ERROR",
    MULTIPLE_SESSIONS_SAME_INIT_DATA: "MULTIPLE_SESSIONS_SAME_INIT_DATA",
    BUFFER_APPEND_ERROR: "BUFFER_APPEND_ERROR",
    BUFFER_FULL_ERROR: "BUFFER_FULL_ERROR",
    BUFFER_TYPE_UNKNOWN: "BUFFER_TYPE_UNKNOWN",
    MEDIA_ERR_BLOCKED_AUTOPLAY: "MEDIA_ERR_BLOCKED_AUTOPLAY",
    MEDIA_ERR_PLAY_NOT_ALLOWED: "MEDIA_ERR_PLAY_NOT_ALLOWED",
    MEDIA_ERR_NOT_LOADED_METADATA: "MEDIA_ERR_NOT_LOADED_METADATA",
    MEDIA_ERR_ABORTED: "MEDIA_ERR_ABORTED",
    MEDIA_ERR_NETWORK: "MEDIA_ERR_NETWORK",
    MEDIA_ERR_DECODE: "MEDIA_ERR_DECODE",
    MEDIA_ERR_SRC_NOT_SUPPORTED: "MEDIA_ERR_SRC_NOT_SUPPORTED",
    MEDIA_ERR_UNKNOWN: "MEDIA_ERR_UNKNOWN",
    MEDIA_SOURCE_NOT_SUPPORTED: "MEDIA_SOURCE_NOT_SUPPORTED",
    MEDIA_KEYS_NOT_SUPPORTED: "MEDIA_KEYS_NOT_SUPPORTED",
    DISCONTINUITY_ENCOUNTERED: "DISCONTINUITY_ENCOUNTERED",
    NONE: "NONE",
};



/***/ }),

/***/ 63878:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ errorMessage)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Generate a normalized error message.
 * @param {string} name
 * @param {string} code
 * @param {Error|string|Event|null} [reason]
 * @returns {string}
 */
function errorMessage(name, code, reason) {
    return `${name} (${code}) ${reason}`;
}


/***/ }),

/***/ 70524:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ isKnownError)
/* harmony export */ });
/* harmony import */ var _encrypted_media_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4029);
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(35659);
/* harmony import */ var _media_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3590);
/* harmony import */ var _network_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12081);
/* harmony import */ var _other_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12353);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Whether the error given is a ICustomError.
 * @param {Error} error
 * @returns {Boolean}
 */
function isKnownError(error) {
    return (error instanceof _encrypted_media_error__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z ||
        error instanceof _media_error__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z ||
        error instanceof _other_error__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z ||
        error instanceof _network_error__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z) &&
        Object.keys(_error_codes__WEBPACK_IMPORTED_MODULE_4__/* .ErrorTypes */ .ZB).indexOf(error.type) >= 0;
}


/***/ }),

/***/ 3590:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ MediaError)
/* harmony export */ });
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35659);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63878);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Error linked to the media Playback.
 *
 * @class MediaError
 * @extends Error
 */
class MediaError extends Error {
    /**
     * @param {string} code
     * @param {string} reason
     * @param {Boolean} fatal
     */
    constructor(code, reason) {
        super();
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(this, MediaError.prototype);
        this.name = "MediaError";
        this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__/* .ErrorTypes.MEDIA_ERROR */ .ZB.MEDIA_ERROR;
        this.code = code;
        this.message = (0,_error_message__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(this.name, this.code, reason);
        this.fatal = false;
    }
}


/***/ }),

/***/ 12081:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ NetworkError)
/* harmony export */ });
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35659);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63878);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Error linked to network interactions (requests).
 *
 * @class NetworkError
 * @extends Error
 */
class NetworkError extends Error {
    /**
     * @param {string} code
     * @param {Error} options
     * @param {Boolean} fatal
     */
    constructor(code, options) {
        super();
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(this, NetworkError.prototype);
        this.name = "NetworkError";
        this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__/* .ErrorTypes.NETWORK_ERROR */ .ZB.NETWORK_ERROR;
        this.xhr = options.xhr === undefined ? null : options.xhr;
        this.url = options.url;
        this.status = options.status;
        this.errorType = options.type;
        this.code = code;
        this.message = (0,_error_message__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(this.name, this.code, options.message);
        this.fatal = false;
    }
    /**
     * Returns true if the NetworkError is due to the given http error code
     * @param {number} httpErrorCode
     * @returns {Boolean}
     */
    isHttpError(httpErrorCode) {
        return this.errorType === _error_codes__WEBPACK_IMPORTED_MODULE_0__/* .NetworkErrorTypes.ERROR_HTTP_CODE */ .br.ERROR_HTTP_CODE &&
            this.status === httpErrorCode;
    }
}


/***/ }),

/***/ 12353:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ OtherError)
/* harmony export */ });
/* harmony import */ var _error_codes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35659);
/* harmony import */ var _error_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63878);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @class OtherError
 * @extends Error
 */
class OtherError extends Error {
    /**
     * @param {string} code
     * @param {string} reason
     * @param {Boolean} fatal
     */
    constructor(code, reason) {
        super();
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(this, OtherError.prototype);
        this.name = "OtherError";
        this.type = _error_codes__WEBPACK_IMPORTED_MODULE_0__/* .ErrorTypes.OTHER_ERROR */ .ZB.OTHER_ERROR;
        this.code = code;
        this.message = (0,_error_message__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(this.name, this.code, reason);
        this.fatal = false;
    }
}


/***/ }),

/***/ 13307:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ RequestError)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Errors linked to the XHR implentation done in the RxPlayer.
 *
 * @class RequestError
 * @extends Error
 */
class RequestError extends Error {
    /**
     * @param {XMLHttpRequest} xhr
     * @param {string} url
     * @param {string} type
     */
    constructor(url, status, type, xhr) {
        super();
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(this, RequestError.prototype);
        this.name = "RequestError";
        this.url = url;
        this.xhr = xhr;
        this.status = status;
        this.type = type;
        this.message = type;
    }
}


/***/ }),

/***/ 63121:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Initial features object, with no feature activated by default.
 * @type {Object}
 */
const features = { directfile: null,
    emeManager: null,
    htmlTextTracksBuffer: null,
    htmlTextTracksParsers: {},
    imageBuffer: null,
    imageParser: null,
    nativeTextTracksBuffer: null,
    nativeTextTracksParsers: {},
    transports: {} };
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (features);


/***/ }),

/***/ 41195:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _features_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63121);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * File allowing feature-switching.
 *
 * Every optional feature is included here.
 * They all should subsequently be accessed in the code through the exported
 * `features` object.
 *
 * The then exported features object will be used dynamically to know which
 * features are activated.
 *
 * This also lazy-feature loading, where this exported object can be updated
 * at runtime, to allow some new features even if the player instance has
 * already have been instanciated.
 */


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_features_object__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z);



/***/ }),

/***/ 6077:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ log)
});

// EXTERNAL MODULE: ./src/utils/noop.ts
var noop = __webpack_require__(41011);
;// CONCATENATED MODULE: ./src/utils/logger.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const DEFAULT_LOG_LEVEL = "NONE";
/**
 * Logger implementation.
 * @class Logger
 */
class Logger {
    constructor() {
        this.error = noop/* default */.Z;
        this.warn = noop/* default */.Z;
        this.info = noop/* default */.Z;
        this.debug = noop/* default */.Z;
        this._levels = { NONE: 0,
            ERROR: 1,
            WARNING: 2,
            INFO: 3,
            DEBUG: 4 };
        this._currentLevel = DEFAULT_LOG_LEVEL;
    }
    /**
     * @param {string} levelStr
     */
    setLevel(levelStr) {
        let level;
        const foundLevel = this._levels[levelStr];
        if (typeof foundLevel === "number") {
            level = foundLevel;
            this._currentLevel = levelStr;
        }
        else { // not found
            level = 0;
            this._currentLevel = "NONE";
        }
        /* eslint-disable no-invalid-this */
        /* eslint-disable no-console */
        this.error = (level >= this._levels.ERROR) ? console.error.bind(console) :
            noop/* default */.Z;
        this.warn = (level >= this._levels.WARNING) ? console.warn.bind(console) :
            noop/* default */.Z;
        this.info = (level >= this._levels.INFO) ? console.info.bind(console) :
            noop/* default */.Z;
        this.debug = (level >= this._levels.DEBUG) ? console.log.bind(console) :
            noop/* default */.Z;
        /* eslint-enable no-console */
        /* eslint-enable no-invalid-this */
    }
    /**
     * @returns {string}
     */
    getLevel() {
        return this._currentLevel;
    }
}

;// CONCATENATED MODULE: ./src/log.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// create a logger specifically for the RxPlayer.
const logger = new Logger();
/* harmony default export */ const log = (logger);


/***/ }),

/***/ 40042:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "r": () => (/* binding */ SUPPORTED_ADAPTATIONS_TYPE),
  "Z": () => (/* binding */ Adaptation)
});

// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(3590);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(23437);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(54924);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(32825);
// EXTERNAL MODULE: ./src/utils/languages/index.ts
var languages = __webpack_require__(46211);
;// CONCATENATED MODULE: ./src/utils/uniq.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Uniq implementation by combining a filter and an indexOf.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
function uniqFromFilter(arr) {
    return arr.filter((val, i, self) => self.indexOf(val) === i);
}
/**
 * Uniq implementation by using the Set browser API.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
function uniqFromSet(arr) {
    return Array.from(new Set(arr));
}
/**
 * Returns the input array without duplicates values.
 * All values are unique.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
/* harmony default export */ const uniq = (typeof window !== "undefined" &&
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    typeof window.Set === "function" &&
    typeof Array.from === "function" ? uniqFromSet :
    uniqFromFilter);


// EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
var browser_compatibility_types = __webpack_require__(18909);
;// CONCATENATED MODULE: ./src/compat/is_codec_supported.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the given codec is supported by the browser's MediaSource
 * implementation.
 * @param {string} mimeType - The MIME media type that you want to test support
 * for in the current browser.
 * This may include the codecs parameter to provide added details about the
 * codecs used within the file.
 * @returns {Boolean}
 */
function isCodecSupported(mimeType) {
    if (browser_compatibility_types/* MediaSource_ */.JJ == null) {
        return false;
    }
    /* eslint-disable @typescript-eslint/unbound-method */
    if (typeof browser_compatibility_types/* MediaSource_.isTypeSupported */.JJ.isTypeSupported === "function") {
        /* eslint-enable @typescript-eslint/unbound-method */
        return browser_compatibility_types/* MediaSource_.isTypeSupported */.JJ.isTypeSupported(mimeType);
    }
    return true;
}

// EXTERNAL MODULE: ./src/utils/are_arrays_of_numbers_equal.ts
var are_arrays_of_numbers_equal = __webpack_require__(90387);
;// CONCATENATED MODULE: ./src/manifest/representation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Normalized Representation structure.
 * @class Representation
 */
class Representation {
    /**
     * @param {Object} args
     */
    constructor(args, opts) {
        this.id = args.id;
        this.bitrate = args.bitrate;
        this.codec = args.codecs;
        if (args.height != null) {
            this.height = args.height;
        }
        if (args.width != null) {
            this.width = args.width;
        }
        if (args.mimeType != null) {
            this.mimeType = args.mimeType;
        }
        if (args.contentProtections !== undefined) {
            this.contentProtections = args.contentProtections;
        }
        if (args.frameRate != null) {
            this.frameRate = args.frameRate;
        }
        this.index = args.index;
        this.isSupported = opts.type === "audio" ||
            opts.type === "video" ?
            isCodecSupported(this.getMimeTypeString()) :
            true; // TODO for other types
    }
    /**
     * Returns "mime-type string" which includes both the mime-type and the codec,
     * which is often needed when interacting with the browser's APIs.
     * @returns {string}
     */
    getMimeTypeString() {
        var _a, _b;
        return `${(_a = this.mimeType) !== null && _a !== void 0 ? _a : ""};codecs="${(_b = this.codec) !== null && _b !== void 0 ? _b : ""}"`;
    }
    /**
     * Returns encryption initialization data linked to the given DRM's system ID.
     * This data may be useful to decrypt encrypted media segments.
     *
     * Returns an empty array if there is no data found for that system ID at the
     * moment.
     *
     * When you know that all encryption data has been added to this
     * Representation, you can also call the `getAllEncryptionData` method.
     * This second function will return all encryption initialization data
     * regardless of the DRM system, and might thus be used in all cases.
     *
     * /!\ Note that encryption initialization data may be progressively added to
     * this Representation after `_addProtectionData` calls or Manifest updates.
     * Because of this, the return value of this function might change after those
     * events.
     *
     * @param {string} drmSystemId - The hexa-encoded DRM system ID
     * @returns {Array.<Object>}
     */
    getEncryptionData(drmSystemId) {
        var _a;
        const allInitData = this.getAllEncryptionData();
        const filtered = [];
        for (let i = 0; i < allInitData.length; i++) {
            let createdObjForType = false;
            const initData = allInitData[i];
            for (let j = 0; j < initData.values.length; j++) {
                if (initData.values[j].systemId.toLowerCase() === drmSystemId.toLowerCase()) {
                    if (!createdObjForType) {
                        const keyIds = (_a = this.contentProtections) === null || _a === void 0 ? void 0 : _a.keyIds.map(val => val.keyId);
                        filtered.push({ type: initData.type,
                            keyIds,
                            values: [initData.values[j]] });
                        createdObjForType = true;
                    }
                    else {
                        filtered[filtered.length - 1].values.push(initData.values[j]);
                    }
                }
            }
        }
        return filtered;
    }
    /**
     * Returns all currently-known encryption initialization data linked to this
     * Representation.
     * Encryption initialization data is generally required to be able to decrypt
     * those Representation's media segments.
     *
     * Unlike `getEncryptionData`, this method will return all available
     * encryption data.
     * It might as such might be used when either the current drm's system id is
     * not known or when no encryption data specific to it was found. In that
     * case, providing every encryption data linked to this Representation might
     * still allow decryption.
     *
     * Returns an empty array in two cases:
     *   - the content is not encrypted.
     *   - We don't have any decryption data yet.
     *
     * /!\ Note that new encryption initialization data can be added progressively
     * through the `_addProtectionData` method or through Manifest updates.
     * It is thus highly advised to only rely on this method once every protection
     * data related to this Representation has been known to be added.
     *
     * The main situation where new encryption initialization data is added is
     * after parsing this Representation's initialization segment, if one exists.
     * @returns {Array.<Object>}
     */
    getAllEncryptionData() {
        var _a;
        if (this.contentProtections === undefined ||
            this.contentProtections.initData.length === 0) {
            return [];
        }
        const keyIds = (_a = this.contentProtections) === null || _a === void 0 ? void 0 : _a.keyIds.map(val => val.keyId);
        return this.contentProtections.initData.map((x) => {
            return { type: x.type,
                keyIds,
                values: x.values };
        });
    }
    /**
     * Add new encryption initialization data to this Representation if it was not
     * already included.
     *
     * Returns `true` if new encryption initialization data has been added.
     * Returns `false` if none has been added (e.g. because it was already known).
     *
     * /!\ Mutates the current Representation
     * @param {string} initDataArr
     * @param {string} systemId
     * @param {Uint8Array} data
     * @returns {boolean}
     */
    _addProtectionData(initDataType, data) {
        let hasUpdatedProtectionData = false;
        if (this.contentProtections === undefined) {
            this.contentProtections = { keyIds: [],
                initData: [{ type: initDataType,
                        values: data }] };
            return true;
        }
        const cInitData = this.contentProtections.initData;
        for (let i = 0; i < cInitData.length; i++) {
            if (cInitData[i].type === initDataType) {
                const cValues = cInitData[i].values;
                // loop through data
                for (let dataI = 0; dataI < data.length; dataI++) {
                    const dataToAdd = data[dataI];
                    let cValuesIdx;
                    for (cValuesIdx = 0; cValuesIdx < cValues.length; cValuesIdx++) {
                        if (dataToAdd.systemId === cValues[cValuesIdx].systemId) {
                            if ((0,are_arrays_of_numbers_equal/* default */.Z)(dataToAdd.data, cValues[cValuesIdx].data)) {
                                // go to next dataToAdd
                                break;
                            }
                            else {
                                log/* default.warn */.Z.warn("Manifest: different init data for the same system ID");
                            }
                        }
                    }
                    if (cValuesIdx === cValues.length) {
                        // we didn't break the loop === we didn't already find that value
                        cValues.push(dataToAdd);
                        hasUpdatedProtectionData = true;
                    }
                }
                return hasUpdatedProtectionData;
            }
        }
        // If we are here, this means that we didn't find the corresponding
        // init data type in this.contentProtections.initData.
        this.contentProtections.initData.push({ type: initDataType,
            values: data });
        return true;
    }
}
/* harmony default export */ const manifest_representation = (Representation);

;// CONCATENATED MODULE: ./src/manifest/adaptation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/** List in an array every possible value for the Adaptation's `type` property. */
const SUPPORTED_ADAPTATIONS_TYPE = ["audio",
    "video",
    "text",
    "image"];
/**
 * Returns true if the given Adaptation's `type` is a valid `type` property.
 * @param {string} adaptationType
 * @returns {boolean}
 */
function isSupportedAdaptationType(adaptationType) {
    return (0,array_includes/* default */.Z)(SUPPORTED_ADAPTATIONS_TYPE, adaptationType);
}
/**
 * Normalized Adaptation structure.
 * An Adaptation describes a single `Track`. For example a specific audio
 * track (in a given language) or a specific video track.
 * It istelf can be represented in different qualities, which we call here
 * `Representation`.
 * @class Adaptation
 */
class Adaptation {
    /**
     * @constructor
     * @param {Object} parsedAdaptation
     * @param {Object|undefined} [options]
     */
    constructor(parsedAdaptation, options = {}) {
        const { representationFilter, isManuallyAdded } = options;
        this.parsingErrors = [];
        this.id = parsedAdaptation.id;
        if (!isSupportedAdaptationType(parsedAdaptation.type)) {
            log/* default.info */.Z.info("Manifest: Not supported adaptation type", parsedAdaptation.type);
            /* eslint-disable @typescript-eslint/restrict-template-expressions */
            throw new media_error/* default */.Z("MANIFEST_UNSUPPORTED_ADAPTATION_TYPE", `"${parsedAdaptation.type}" is not a valid ` +
                "Adaptation type.");
            /* eslint-enable @typescript-eslint/restrict-template-expressions */
        }
        this.type = parsedAdaptation.type;
        if (parsedAdaptation.language !== undefined) {
            this.language = parsedAdaptation.language;
            this.normalizedLanguage = (0,languages/* default */.ZP)(parsedAdaptation.language);
        }
        if (parsedAdaptation.closedCaption !== undefined) {
            this.isClosedCaption = parsedAdaptation.closedCaption;
        }
        if (parsedAdaptation.audioDescription !== undefined) {
            this.isAudioDescription = parsedAdaptation.audioDescription;
        }
        if (parsedAdaptation.isDub !== undefined) {
            this.isDub = parsedAdaptation.isDub;
        }
        if (parsedAdaptation.isSignInterpreted !== undefined) {
            this.isSignInterpreted = parsedAdaptation.isSignInterpreted;
        }
        const argsRepresentations = parsedAdaptation.representations;
        const representations = [];
        let isSupported = false;
        for (let i = 0; i < argsRepresentations.length; i++) {
            const representation = new manifest_representation(argsRepresentations[i], { type: this.type });
            const shouldAdd = (0,is_null_or_undefined/* default */.Z)(representationFilter) ||
                representationFilter(representation, { bufferType: this.type,
                    language: this.language,
                    normalizedLanguage: this.normalizedLanguage,
                    isClosedCaption: this.isClosedCaption,
                    isDub: this.isDub,
                    isAudioDescription: this.isAudioDescription,
                    isSignInterpreted: this.isSignInterpreted });
            if (shouldAdd) {
                representations.push(representation);
                if (!isSupported && representation.isSupported) {
                    isSupported = true;
                }
            }
        }
        representations.sort((a, b) => a.bitrate - b.bitrate);
        this.representations = representations;
        this.isSupported = isSupported;
        // for manuallyAdded adaptations (not in the manifest)
        this.manuallyAdded = isManuallyAdded === true;
        if (this.representations.length > 0 && !isSupported) {
            log/* default.warn */.Z.warn("Incompatible codecs for adaptation", parsedAdaptation);
            const error = new media_error/* default */.Z("MANIFEST_INCOMPATIBLE_CODECS_ERROR", "An Adaptation contains only incompatible codecs.");
            this.parsingErrors.push(error);
        }
    }
    /**
     * Returns unique bitrate for every Representation in this Adaptation.
     * @returns {Array.<Number>}
     */
    getAvailableBitrates() {
        const bitrates = [];
        for (let i = 0; i < this.representations.length; i++) {
            const representation = this.representations[i];
            if (representation.decipherable !== false) {
                bitrates.push(representation.bitrate);
            }
        }
        return uniq(bitrates);
    }
    /**
     * Returns all Representation in this Adaptation that can be played (that is:
     * not undecipherable and with a supported codec).
     * @returns {Array.<Representation>}
     */
    getPlayableRepresentations() {
        return this.representations.filter(rep => {
            return rep.isSupported && rep.decipherable !== false;
        });
    }
    /**
     * Returns the Representation linked to the given ID.
     * @param {number|string} wantedId
     * @returns {Object|undefined}
     */
    getRepresentation(wantedId) {
        return (0,array_find/* default */.Z)(this.representations, ({ id }) => wantedId === id);
    }
}


/***/ }),

/***/ 96667:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ areSameContent)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Check if two contents are the same
 * @param {Object} content1
 * @param {Object} content2
 * @returns {boolean}
 */
function areSameContent(content1, content2) {
    return (content1.segment.id === content2.segment.id &&
        content1.representation.id === content2.representation.id &&
        content1.adaptation.id === content2.adaptation.id &&
        content1.period.id === content2.period.id);
}


/***/ }),

/***/ 18567:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ZP": () => (/* binding */ manifest)
});

// UNUSED EXPORTS: Adaptation, Period, Representation, SUPPORTED_ADAPTATIONS_TYPE, StaticRepresentationIndex, areSameContent

// EXTERNAL MODULE: ./src/utils/are_arrays_of_numbers_equal.ts
var are_arrays_of_numbers_equal = __webpack_require__(90387);
// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(23437);
// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(61603);
// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(14638);
// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(73973);
// EXTERNAL MODULE: ./src/manifest/adaptation.ts + 3 modules
var manifest_adaptation = __webpack_require__(40042);
// EXTERNAL MODULE: ./src/errors/is_known_error.ts
var is_known_error = __webpack_require__(70524);
// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(3590);
// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(86293);
;// CONCATENATED MODULE: ./src/manifest/period.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Class representing the tracks and qualities available from a given time
 * period in the the Manifest.
 * @class Period
 */
class Period {
    /**
     * @constructor
     * @param {Object} args
     * @param {function|undefined} [representationFilter]
     */
    constructor(args, representationFilter) {
        this.parsingErrors = [];
        this.id = args.id;
        this.adaptations = Object.keys(args.adaptations)
            .reduce((acc, type) => {
            const adaptationsForType = args.adaptations[type];
            if (adaptationsForType == null) {
                return acc;
            }
            const filteredAdaptations = adaptationsForType
                .map((adaptation) => {
                let newAdaptation = null;
                try {
                    newAdaptation = new manifest_adaptation/* default */.Z(adaptation, { representationFilter });
                }
                catch (err) {
                    if ((0,is_known_error/* default */.Z)(err) &&
                        err.code === "MANIFEST_UNSUPPORTED_ADAPTATION_TYPE") {
                        this.parsingErrors.push(err);
                        return null;
                    }
                    throw err;
                }
                this.parsingErrors.push(...newAdaptation.parsingErrors);
                return newAdaptation;
            })
                .filter((adaptation) => adaptation !== null && adaptation.representations.length > 0);
            if (filteredAdaptations.every(adaptation => !adaptation.isSupported) &&
                adaptationsForType.length > 0 &&
                (type === "video" || type === "audio")) {
                throw new media_error/* default */.Z("MANIFEST_PARSE_ERROR", "No supported " + type + " adaptations");
            }
            if (filteredAdaptations.length > 0) {
                acc[type] = filteredAdaptations;
            }
            return acc;
        }, {});
        if (!Array.isArray(this.adaptations.video) &&
            !Array.isArray(this.adaptations.audio)) {
            throw new media_error/* default */.Z("MANIFEST_PARSE_ERROR", "No supported audio and video tracks.");
        }
        this.duration = args.duration;
        this.start = args.start;
        if (this.duration != null && this.start != null) {
            this.end = this.start + this.duration;
        }
        this.streamEvents = args.streamEvents === undefined ?
            [] :
            args.streamEvents;
    }
    /**
     * Returns every `Adaptations` (or `tracks`) linked to that Period, in an
     * Array.
     * @returns {Array.<Object>}
     */
    getAdaptations() {
        const adaptationsByType = this.adaptations;
        return (0,object_values/* default */.Z)(adaptationsByType).reduce(
        // Note: the second case cannot happen. TS is just being dumb here
        (acc, adaptations) => adaptations != null ? acc.concat(adaptations) :
            acc, []);
    }
    /**
     * Returns every `Adaptations` (or `tracks`) linked to that Period for a
     * given type.
     * @param {string} adaptationType
     * @returns {Array.<Object>}
     */
    getAdaptationsForType(adaptationType) {
        const adaptationsForType = this.adaptations[adaptationType];
        return adaptationsForType == null ? [] :
            adaptationsForType;
    }
    /**
     * Returns the Adaptation linked to the given ID.
     * @param {number|string} wantedId
     * @returns {Object|undefined}
     */
    getAdaptation(wantedId) {
        return (0,array_find/* default */.Z)(this.getAdaptations(), ({ id }) => wantedId === id);
    }
    getPlayableAdaptations(type) {
        if (type === undefined) {
            return this.getAdaptations().filter(ada => {
                return ada.getPlayableRepresentations().length > 0;
            });
        }
        const adaptationsForType = this.adaptations[type];
        if (adaptationsForType === undefined) {
            return [];
        }
        return adaptationsForType.filter(ada => {
            return ada.getPlayableRepresentations().length > 0;
        });
    }
}

// EXTERNAL MODULE: ./src/manifest/representation_index/static.ts
var representation_index_static = __webpack_require__(19327);
;// CONCATENATED MODULE: ./src/manifest/types.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Enumerate the different ways a Manifest update can be done. */
var MANIFEST_UPDATE_TYPE;
(function (MANIFEST_UPDATE_TYPE) {
    /**
     * Manifest is updated entirely thanks to a re-downloaded version of
     * the original manifest document.
     */
    MANIFEST_UPDATE_TYPE[MANIFEST_UPDATE_TYPE["Full"] = 0] = "Full";
    /**
     * Manifest is updated partially thanks to a shortened version
     * of the manifest document. The latter's URL might be different
     * from the original one.
     */
    MANIFEST_UPDATE_TYPE[MANIFEST_UPDATE_TYPE["Partial"] = 1] = "Partial";
})(MANIFEST_UPDATE_TYPE || (MANIFEST_UPDATE_TYPE = {}));

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
// EXTERNAL MODULE: ./src/utils/array_find_index.ts
var array_find_index = __webpack_require__(34612);
;// CONCATENATED MODULE: ./src/manifest/update_period_in_place.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Update oldPeriod attributes with the one from newPeriod (e.g. when updating
 * the Manifest).
 * @param {Object} oldPeriod
 * @param {Object} newPeriod
 */
function updatePeriodInPlace(oldPeriod, newPeriod, updateType) {
    oldPeriod.start = newPeriod.start;
    oldPeriod.end = newPeriod.end;
    oldPeriod.duration = newPeriod.duration;
    const oldAdaptations = oldPeriod.getAdaptations();
    const newAdaptations = newPeriod.getAdaptations();
    for (let j = 0; j < oldAdaptations.length; j++) {
        const oldAdaptation = oldAdaptations[j];
        const newAdaptation = (0,array_find/* default */.Z)(newAdaptations, a => a.id === oldAdaptation.id);
        if (newAdaptation === undefined) {
            log/* default.warn */.Z.warn("Manifest: Adaptation \"" +
                oldAdaptations[j].id +
                "\" not found when merging.");
        }
        else {
            const oldRepresentations = oldAdaptations[j].representations;
            const newRepresentations = newAdaptation.representations;
            for (let k = 0; k < oldRepresentations.length; k++) {
                const oldRepresentation = oldRepresentations[k];
                const newRepresentation = (0,array_find/* default */.Z)(newRepresentations, representation => representation.id === oldRepresentation.id);
                if (newRepresentation === undefined) {
                    log/* default.warn */.Z.warn(`Manifest: Representation "${oldRepresentations[k].id}" ` +
                        "not found when merging.");
                }
                else {
                    if (updateType === MANIFEST_UPDATE_TYPE.Full) {
                        oldRepresentation.index._replace(newRepresentation.index);
                    }
                    else {
                        oldRepresentation.index._update(newRepresentation.index);
                    }
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/manifest/update_periods.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Update old periods by adding new periods and removing
 * not available ones.
 * @param {Array.<Object>} oldPeriods
 * @param {Array.<Object>} newPeriods
 */
function replacePeriods(oldPeriods, newPeriods) {
    let firstUnhandledPeriodIdx = 0;
    for (let i = 0; i < newPeriods.length; i++) {
        const newPeriod = newPeriods[i];
        let j = firstUnhandledPeriodIdx;
        let oldPeriod = oldPeriods[j];
        while (oldPeriod != null && oldPeriod.id !== newPeriod.id) {
            j++;
            oldPeriod = oldPeriods[j];
        }
        if (oldPeriod != null) {
            updatePeriodInPlace(oldPeriod, newPeriod, MANIFEST_UPDATE_TYPE.Full);
            const periodsToInclude = newPeriods.slice(firstUnhandledPeriodIdx, i);
            const nbrOfPeriodsToRemove = j - firstUnhandledPeriodIdx;
            oldPeriods.splice(firstUnhandledPeriodIdx, nbrOfPeriodsToRemove, ...periodsToInclude);
            firstUnhandledPeriodIdx = i + 1;
        }
    }
    if (firstUnhandledPeriodIdx > oldPeriods.length) {
        log/* default.error */.Z.error("Manifest: error when updating Periods");
        return;
    }
    if (firstUnhandledPeriodIdx < oldPeriods.length) {
        oldPeriods.splice(firstUnhandledPeriodIdx, oldPeriods.length - firstUnhandledPeriodIdx);
    }
    const remainingNewPeriods = newPeriods.slice(firstUnhandledPeriodIdx, newPeriods.length);
    if (remainingNewPeriods.length > 0) {
        oldPeriods.push(...remainingNewPeriods);
    }
}
/**
 * Update old periods by adding new periods and removing
 * not available ones.
 * @param {Array.<Object>} oldPeriods
 * @param {Array.<Object>} newPeriods
 */
function updatePeriods(oldPeriods, newPeriods) {
    if (oldPeriods.length === 0) {
        oldPeriods.splice(0, 0, ...newPeriods);
        return;
    }
    if (newPeriods.length === 0) {
        return;
    }
    const oldLastPeriod = oldPeriods[oldPeriods.length - 1];
    if (oldLastPeriod.start < newPeriods[0].start) {
        if (oldLastPeriod.end !== newPeriods[0].start) {
            throw new media_error/* default */.Z("MANIFEST_UPDATE_ERROR", "Cannot perform partial update: not enough data");
        }
        oldPeriods.push(...newPeriods);
        return;
    }
    const indexOfNewFirstPeriod = (0,array_find_index/* default */.Z)(oldPeriods, ({ id }) => id === newPeriods[0].id);
    if (indexOfNewFirstPeriod < 0) {
        throw new media_error/* default */.Z("MANIFEST_UPDATE_ERROR", "Cannot perform partial update: incoherent data");
    }
    // The first updated Period can only be a partial part
    updatePeriodInPlace(oldPeriods[indexOfNewFirstPeriod], newPeriods[0], MANIFEST_UPDATE_TYPE.Partial);
    let prevIndexOfNewPeriod = indexOfNewFirstPeriod + 1;
    for (let i = 1; i < newPeriods.length; i++) {
        const newPeriod = newPeriods[i];
        let indexOfNewPeriod = -1;
        for (let j = prevIndexOfNewPeriod; j < oldPeriods.length; j++) {
            if (newPeriod.id === oldPeriods[j].id) {
                indexOfNewPeriod = j;
                break; // end the loop
            }
        }
        if (indexOfNewPeriod < 0) {
            oldPeriods.splice(prevIndexOfNewPeriod, oldPeriods.length - prevIndexOfNewPeriod, ...newPeriods.slice(i, newPeriods.length));
            return;
        }
        if (indexOfNewPeriod > prevIndexOfNewPeriod) {
            oldPeriods.splice(prevIndexOfNewPeriod, indexOfNewPeriod - prevIndexOfNewPeriod);
            indexOfNewPeriod = prevIndexOfNewPeriod;
        }
        // Later Periods can be fully replaced
        updatePeriodInPlace(oldPeriods[indexOfNewPeriod], newPeriod, MANIFEST_UPDATE_TYPE.Full);
        prevIndexOfNewPeriod++;
    }
    if (prevIndexOfNewPeriod < oldPeriods.length) {
        oldPeriods.splice(prevIndexOfNewPeriod, oldPeriods.length - prevIndexOfNewPeriod);
    }
}

;// CONCATENATED MODULE: ./src/manifest/manifest.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










const generateSupplementaryTrackID = (0,id_generator/* default */.Z)();
const generateNewManifestId = (0,id_generator/* default */.Z)();
/**
 * Normalized Manifest structure.
 *
 * Details the current content being played:
 *   - the duration of the content
 *   - the available tracks
 *   - the available qualities
 *   - the segments defined in those qualities
 *   - ...
 * while staying agnostic of the transport protocol used (Smooth, DASH etc.).
 *
 * The Manifest and its contained information can evolve over time (like when
 * updating a dynamic manifest or when right management forbid some tracks from
 * being played).
 * To perform actions on those changes, any module using this Manifest can
 * listen to its sent events and react accordingly.
 *
 * @class Manifest
 */
class Manifest extends event_emitter/* default */.Z {
    /**
     * Construct a Manifest instance from a parsed Manifest object (as returned by
     * Manifest parsers) and options.
     *
     * Some minor errors can arise during that construction. `this.parsingErrors`
     * will contain all such errors, in the order they have been encountered.
     * @param {Object} parsedManifest
     * @param {Object} options
     */
    constructor(parsedManifest, options) {
        var _a;
        super();
        const { supplementaryTextTracks = [], supplementaryImageTracks = [], representationFilter, manifestUpdateUrl } = options;
        this.parsingErrors = [];
        this.id = generateNewManifestId();
        this.expired = (_a = parsedManifest.expired) !== null && _a !== void 0 ? _a : null;
        this.transport = parsedManifest.transportType;
        this.clockOffset = parsedManifest.clockOffset;
        this.periods = parsedManifest.periods.map((parsedPeriod) => {
            const period = new Period(parsedPeriod, representationFilter);
            this.parsingErrors.push(...period.parsingErrors);
            return period;
        }).sort((a, b) => a.start - b.start);
        /**
         * @deprecated It is here to ensure compatibility with the way the
         * v3.x.x manages adaptations at the Manifest level
         */
        /* eslint-disable import/no-deprecated */
        this.adaptations = this.periods[0] === undefined ? {} :
            this.periods[0].adaptations;
        /* eslint-enable import/no-deprecated */
        this._timeBounds = parsedManifest.timeBounds;
        this.isDynamic = parsedManifest.isDynamic;
        this.isLive = parsedManifest.isLive;
        this.uris = parsedManifest.uris === undefined ? [] :
            parsedManifest.uris;
        this.updateUrl = manifestUpdateUrl;
        this.lifetime = parsedManifest.lifetime;
        this.suggestedPresentationDelay = parsedManifest.suggestedPresentationDelay;
        this.availabilityStartTime = parsedManifest.availabilityStartTime;
        this.publishTime = parsedManifest.publishTime;
        if (supplementaryImageTracks.length > 0) {
            this._addSupplementaryImageAdaptations(supplementaryImageTracks);
        }
        if (supplementaryTextTracks.length > 0) {
            this._addSupplementaryTextAdaptations(supplementaryTextTracks);
        }
    }
    /**
     * Returns the Period corresponding to the given `id`.
     * Returns `undefined` if there is none.
     * @param {string} id
     * @returns {Object|undefined}
     */
    getPeriod(id) {
        return (0,array_find/* default */.Z)(this.periods, (period) => {
            return id === period.id;
        });
    }
    /**
     * Returns the Period encountered at the given time.
     * Returns `undefined` if there is no Period exactly at the given time.
     * @param {number} time
     * @returns {Object|undefined}
     */
    getPeriodForTime(time) {
        return (0,array_find/* default */.Z)(this.periods, (period) => {
            return time >= period.start &&
                (period.end === undefined || period.end > time);
        });
    }
    /**
     * Returns the first Period starting strictly after the given time.
     * Returns `undefined` if there is no Period starting after that time.
     * @param {number} time
     * @returns {Object|undefined}
     */
    getNextPeriod(time) {
        return (0,array_find/* default */.Z)(this.periods, (period) => {
            return period.start > time;
        });
    }
    /**
     * Returns the Period coming chronologically just after another given Period.
     * Returns `undefined` if not found.
     * @param {Object} period
     * @returns {Object|null}
     */
    getPeriodAfter(period) {
        const endOfPeriod = period.end;
        if (endOfPeriod === undefined) {
            return null;
        }
        const nextPeriod = (0,array_find/* default */.Z)(this.periods, (_period) => {
            return _period.end === undefined || endOfPeriod < _period.end;
        });
        return nextPeriod === undefined ? null :
            nextPeriod;
    }
    /**
     * Returns the most important URL from which the Manifest can be refreshed.
     * `undefined` if no URL is found.
     * @returns {string|undefined}
     */
    getUrl() {
        return this.uris[0];
    }
    /**
     * Update the current Manifest properties by giving a new updated version.
     * This instance will be updated with the new information coming from it.
     * @param {Object} newManifest
     */
    replace(newManifest) {
        this._performUpdate(newManifest, MANIFEST_UPDATE_TYPE.Full);
    }
    /**
     * Update the current Manifest properties by giving a new but shorter version
     * of it.
     * This instance will add the new information coming from it and will
     * automatically clean old Periods that shouldn't be available anymore.
     *
     * /!\ Throws if the given Manifest cannot be used or is not sufficient to
     * update the Manifest.
     * @param {Object} newManifest
     */
    update(newManifest) {
        this._performUpdate(newManifest, MANIFEST_UPDATE_TYPE.Partial);
    }
    /**
     * Get the minimum position currently defined by the Manifest, in seconds.
     * @returns {number}
     */
    getMinimumPosition() {
        var _a, _b;
        const windowData = this._timeBounds;
        if (windowData.timeshiftDepth === null) {
            return (_a = windowData.absoluteMinimumTime) !== null && _a !== void 0 ? _a : 0;
        }
        const { maximumTimeData } = windowData;
        let maximumTime;
        if (!windowData.maximumTimeData.isLinear) {
            maximumTime = maximumTimeData.value;
        }
        else {
            const timeDiff = performance.now() - maximumTimeData.time;
            maximumTime = maximumTimeData.value + timeDiff / 1000;
        }
        const theoricalMinimum = maximumTime - windowData.timeshiftDepth;
        return Math.max((_b = windowData.absoluteMinimumTime) !== null && _b !== void 0 ? _b : 0, theoricalMinimum);
    }
    /**
     * Get the maximum position currently defined by the Manifest, in seconds.
     * @returns {number}
     */
    getMaximumPosition() {
        const { maximumTimeData } = this._timeBounds;
        if (!maximumTimeData.isLinear) {
            return maximumTimeData.value;
        }
        const timeDiff = performance.now() - maximumTimeData.time;
        return maximumTimeData.value + timeDiff / 1000;
    }
    /**
     * Look in the Manifest for Representations linked to the given key ID,
     * and mark them as being impossible to decrypt.
     * Then trigger a "decipherabilityUpdate" event to notify everyone of the
     * changes performed.
     * @param {Object} keyUpdates
     */
    updateDeciperabilitiesBasedOnKeyIds({ whitelistedKeyIds, blacklistedKeyIDs }) {
        const updates = updateDeciperability(this, (representation) => {
            if (representation.decipherable === false ||
                representation.contentProtections === undefined) {
                return representation.decipherable;
            }
            const contentKIDs = representation.contentProtections.keyIds;
            for (let i = 0; i < contentKIDs.length; i++) {
                const elt = contentKIDs[i];
                for (let j = 0; j < blacklistedKeyIDs.length; j++) {
                    if ((0,are_arrays_of_numbers_equal/* default */.Z)(blacklistedKeyIDs[j], elt.keyId)) {
                        return false;
                    }
                }
                for (let j = 0; j < whitelistedKeyIds.length; j++) {
                    if ((0,are_arrays_of_numbers_equal/* default */.Z)(whitelistedKeyIds[j], elt.keyId)) {
                        return true;
                    }
                }
            }
            return representation.decipherable;
        });
        if (updates.length > 0) {
            this.trigger("decipherabilityUpdate", updates);
        }
    }
    /**
     * Look in the Manifest for Representations linked to the given content
     * protection initialization data and mark them as being impossible to
     * decrypt.
     * Then trigger a "decipherabilityUpdate" event to notify everyone of the
     * changes performed.
     * @param {Object} initData
     */
    addUndecipherableProtectionData(initData) {
        const updates = updateDeciperability(this, (representation) => {
            var _a, _b;
            if (representation.decipherable === false) {
                return false;
            }
            const segmentProtections = (_b = (_a = representation.contentProtections) === null || _a === void 0 ? void 0 : _a.initData) !== null && _b !== void 0 ? _b : [];
            for (let i = 0; i < segmentProtections.length; i++) {
                if (initData.type === undefined ||
                    segmentProtections[i].type === initData.type) {
                    const containedInitData = initData.values.every(undecipherableVal => {
                        return segmentProtections[i].values.some(currVal => {
                            return (undecipherableVal.systemId === undefined ||
                                currVal.systemId === undecipherableVal.systemId) &&
                                (0,are_arrays_of_numbers_equal/* default */.Z)(currVal.data, undecipherableVal.data);
                        });
                    });
                    if (containedInitData) {
                        return false;
                    }
                }
            }
            return representation.decipherable;
        });
        if (updates.length > 0) {
            this.trigger("decipherabilityUpdate", updates);
        }
    }
    /**
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */
    getAdaptations() {
        (0,warn_once/* default */.Z)("manifest.getAdaptations() is deprecated." +
            " Please use manifest.period[].getAdaptations() instead");
        const firstPeriod = this.periods[0];
        if (firstPeriod === undefined) {
            return [];
        }
        const adaptationsByType = firstPeriod.adaptations;
        const adaptationsList = [];
        for (const adaptationType in adaptationsByType) {
            if (adaptationsByType.hasOwnProperty(adaptationType)) {
                const adaptations = adaptationsByType[adaptationType];
                adaptationsList.push(...adaptations);
            }
        }
        return adaptationsList;
    }
    /**
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */
    getAdaptationsForType(adaptationType) {
        (0,warn_once/* default */.Z)("manifest.getAdaptationsForType(type) is deprecated." +
            " Please use manifest.period[].getAdaptationsForType(type) instead");
        const firstPeriod = this.periods[0];
        if (firstPeriod === undefined) {
            return [];
        }
        const adaptationsForType = firstPeriod.adaptations[adaptationType];
        return adaptationsForType === undefined ? [] :
            adaptationsForType;
    }
    /**
     * @deprecated only returns adaptations for the first period
     * @returns {Array.<Object>}
     */
    getAdaptation(wantedId) {
        (0,warn_once/* default */.Z)("manifest.getAdaptation(id) is deprecated." +
            " Please use manifest.period[].getAdaptation(id) instead");
        /* eslint-disable import/no-deprecated */
        return (0,array_find/* default */.Z)(this.getAdaptations(), ({ id }) => wantedId === id);
        /* eslint-enable import/no-deprecated */
    }
    /**
     * Add supplementary image Adaptation(s) to the manifest.
     * @private
     * @param {Object|Array.<Object>} imageTracks
     */
    _addSupplementaryImageAdaptations(
    /* eslint-disable import/no-deprecated */
    imageTracks) {
        const _imageTracks = Array.isArray(imageTracks) ? imageTracks : [imageTracks];
        const newImageTracks = _imageTracks.map(({ mimeType, url }) => {
            const adaptationID = "gen-image-ada-" + generateSupplementaryTrackID();
            const representationID = "gen-image-rep-" + generateSupplementaryTrackID();
            const newAdaptation = new manifest_adaptation/* default */.Z({ id: adaptationID,
                type: "image",
                representations: [{
                        bitrate: 0,
                        id: representationID,
                        mimeType,
                        index: new representation_index_static/* default */.Z({
                            media: url,
                        })
                    }] }, { isManuallyAdded: true });
            this.parsingErrors.push(...newAdaptation.parsingErrors);
            return newAdaptation;
        });
        if (newImageTracks.length > 0 && this.periods.length > 0) {
            const { adaptations } = this.periods[0];
            adaptations.image =
                adaptations.image != null ? adaptations.image.concat(newImageTracks) :
                    newImageTracks;
        }
    }
    /**
     * Add supplementary text Adaptation(s) to the manifest.
     * @private
     * @param {Object|Array.<Object>} textTracks
     */
    _addSupplementaryTextAdaptations(
    /* eslint-disable import/no-deprecated */
    textTracks
    /* eslint-enable import/no-deprecated */
    ) {
        const _textTracks = Array.isArray(textTracks) ? textTracks : [textTracks];
        const newTextAdaptations = _textTracks.reduce((allSubs, { mimeType, codecs, url, language, 
        /* eslint-disable import/no-deprecated */
        languages, 
        /* eslint-enable import/no-deprecated */
        closedCaption, }) => {
            const langsToMapOn = language != null ? [language] :
                languages != null ? languages :
                    [];
            return allSubs.concat(langsToMapOn.map((_language) => {
                const adaptationID = "gen-text-ada-" + generateSupplementaryTrackID();
                const representationID = "gen-text-rep-" + generateSupplementaryTrackID();
                const newAdaptation = new manifest_adaptation/* default */.Z({ id: adaptationID,
                    type: "text",
                    language: _language,
                    closedCaption,
                    representations: [{
                            bitrate: 0,
                            id: representationID,
                            mimeType,
                            codecs,
                            index: new representation_index_static/* default */.Z({
                                media: url,
                            })
                        }] }, { isManuallyAdded: true });
                this.parsingErrors.push(...newAdaptation.parsingErrors);
                return newAdaptation;
            }));
        }, []);
        if (newTextAdaptations.length > 0 && this.periods.length > 0) {
            const { adaptations } = this.periods[0];
            adaptations.text =
                adaptations.text != null ? adaptations.text.concat(newTextAdaptations) :
                    newTextAdaptations;
        }
    }
    /**
     * @param {Object} newManifest
     * @param {number} type
     */
    _performUpdate(newManifest, updateType) {
        this.availabilityStartTime = newManifest.availabilityStartTime;
        this.expired = newManifest.expired;
        this.isDynamic = newManifest.isDynamic;
        this.isLive = newManifest.isLive;
        this.lifetime = newManifest.lifetime;
        this.parsingErrors = newManifest.parsingErrors;
        this.suggestedPresentationDelay = newManifest.suggestedPresentationDelay;
        this.transport = newManifest.transport;
        this.publishTime = newManifest.publishTime;
        if (updateType === MANIFEST_UPDATE_TYPE.Full) {
            this._timeBounds = newManifest._timeBounds;
            this.uris = newManifest.uris;
            replacePeriods(this.periods, newManifest.periods);
        }
        else {
            this._timeBounds.maximumTimeData = newManifest._timeBounds.maximumTimeData;
            this.updateUrl = newManifest.uris[0];
            updatePeriods(this.periods, newManifest.periods);
            // Partial updates do not remove old Periods.
            // This can become a memory problem when playing a content long enough.
            // Let's clean manually Periods behind the minimum possible position.
            const min = this.getMinimumPosition();
            while (this.periods.length > 0) {
                const period = this.periods[0];
                if (period.end === undefined || period.end > min) {
                    break;
                }
                this.periods.shift();
            }
        }
        // Re-set this.adaptations for retro-compatibility in v3.x.x
        /* eslint-disable import/no-deprecated */
        this.adaptations = this.periods[0] === undefined ?
            {} :
            this.periods[0].adaptations;
        /* eslint-enable import/no-deprecated */
        // Let's trigger events at the end, as those can trigger side-effects.
        // We do not want the current Manifest object to be incomplete when those
        // happen.
        this.trigger("manifestUpdate", null);
    }
}
/**
 * Update `decipherable` property of every `Representation` found in the
 * Manifest based on the result of a `isDecipherable` callback:
 *   - When that callback returns `true`, update `decipherable` to `true`
 *   - When that callback returns `false`, update `decipherable` to `false`
 *   - When that callback returns `undefined`, update `decipherable` to
 *     `undefined`
 * @param {Manifest} manifest
 * @param {Function} isDecipherable
 * @returns {Array.<Object>}
 */
function updateDeciperability(manifest, isDecipherable) {
    const updates = [];
    for (let i = 0; i < manifest.periods.length; i++) {
        const period = manifest.periods[i];
        const adaptations = period.getAdaptations();
        for (let j = 0; j < adaptations.length; j++) {
            const adaptation = adaptations[j];
            const representations = adaptation.representations;
            for (let k = 0; k < representations.length; k++) {
                const representation = representations[k];
                const result = isDecipherable(representation);
                if (result !== representation.decipherable) {
                    updates.push({ manifest, period, adaptation, representation });
                    representation.decipherable = result;
                }
            }
        }
    }
    return updates;
}

;// CONCATENATED MODULE: ./src/manifest/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/* harmony default export */ const manifest = (Manifest);



/***/ }),

/***/ 19327:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ StaticRepresentationIndex)
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6077);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Simple RepresentationIndex implementation for static files.
 * @class StaticRepresentationIndex
 */
class StaticRepresentationIndex {
    /**
     * @param {Object} infos
     */
    constructor(infos) {
        this._mediaURLs = infos.media;
    }
    /**
     * Static contents do not have any initialization segments.
     * Just return null.
     * @returns {null}
     */
    getInitSegment() {
        return null;
    }
    /**
     * Returns the only Segment available here.
     * @returns {Array.<Object>}
     */
    getSegments() {
        return [{ id: "0",
                isInit: false,
                number: 0,
                mediaURLs: [this._mediaURLs],
                time: 0,
                end: Number.MAX_VALUE,
                duration: Number.MAX_VALUE,
                timescale: 1 }];
    }
    /**
     * Returns first position in index.
     * @returns {undefined}
     */
    getFirstPosition() {
        return;
    }
    /**
     * Returns last position in index.
     * @returns {undefined}
     */
    getLastPosition() {
        return;
    }
    /**
     * Returns false as a static file never need to be refreshed.
     * @returns {Boolean}
     */
    shouldRefresh() {
        return false;
    }
    /**
     * @returns {null}
     */
    checkDiscontinuity() {
        return null;
    }
    /**
     * @returns {boolean}
     */
    areSegmentsChronologicallyGenerated() {
        return true;
    }
    /**
     * Returns true as a static file should never need lose availability.
     * @returns {Boolean}
     */
    isSegmentStillAvailable() {
        return true;
    }
    /**
     * @returns {Boolean}
     */
    canBeOutOfSyncError() {
        return false;
    }
    /**
     * @returns {Boolean}
     */
    isFinished() {
        return true;
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
        return true;
    }
    _replace() {
        _log__WEBPACK_IMPORTED_MODULE_0__/* .default.warn */ .Z.warn("Tried to replace a static RepresentationIndex");
    }
    _update() {
        _log__WEBPACK_IMPORTED_MODULE_0__/* .default.warn */ .Z.warn("Tried to update a static RepresentationIndex");
    }
}


/***/ }),

/***/ 63133:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "s": () => (/* binding */ MAX_32_BIT_INT)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Maximum integer that can be stored on 32 bits.
 *
 * This can be used for example to know what is the maximum ISOBMFF box size
 * that can be stored on the first four bytes of a box. Any value higher than
 * that will need 8 bytes (64 bits) to be stored.
 */
const MAX_32_BIT_INT = Math.pow(2, 32) - 1;


/***/ }),

/***/ 65489:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "iz": () => (/* binding */ getBox),
/* harmony export */   "t_": () => (/* binding */ getBoxContent),
/* harmony export */   "Qy": () => (/* binding */ getBoxOffsets),
/* harmony export */   "Xj": () => (/* binding */ getNextBoxOffsets),
/* harmony export */   "nR": () => (/* binding */ getUuidContent)
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6077);
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97308);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns the content of a box based on its name.
 * `null` if not found.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 bit integer
 * generated from encoding the corresponding ASCII in big endian.
 * @returns {UInt8Array|null}
 */
function getBoxContent(buf, boxName) {
    const offsets = getBoxOffsets(buf, boxName);
    return offsets !== null ? buf.subarray(offsets[1], offsets[2]) :
        null;
}
/**
 * Returns an ISOBMFF box - size and name included - based on its name.
 * `null` if not found.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 bit integer
 * generated from encoding the corresponding ASCII in big endian.
 * @returns {UInt8Array|null}
 */
function getBox(buf, boxName) {
    const offsets = getBoxOffsets(buf, boxName);
    return offsets !== null ? buf.subarray(offsets[0], offsets[2]) :
        null;
}
/**
 * Returns byte offsets for the start of the box, the start of its content and
 * the end of the box (not inclusive).
 *
 * `null` if not found.
 *
 * If found, the tuple returned has three elements, all numbers:
 *   1. The starting byte corresponding to the start of the box (from its size)
 *   2. The beginning of the box content - meaning the first byte after the
 *      size and the name of the box.
 *   3. The first byte after the end of the box, might be equal to `buf`'s
 *      length if we're considering the last box.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 bit integer
 * generated from encoding the corresponding ASCII in big endian.
 * @returns {Array.<number>|null}
 */
function getBoxOffsets(buf, boxName) {
    const len = buf.length;
    let boxBaseOffset = 0;
    let name;
    let lastBoxSize = 0;
    let lastOffset;
    while (boxBaseOffset + 8 <= len) {
        lastOffset = boxBaseOffset;
        lastBoxSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .pX)(buf, lastOffset);
        lastOffset += 4;
        name = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .pX)(buf, lastOffset);
        lastOffset += 4;
        if (lastBoxSize === 0) {
            lastBoxSize = len - boxBaseOffset;
        }
        else if (lastBoxSize === 1) {
            if (lastOffset + 8 > len) {
                return null;
            }
            lastBoxSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be8toi */ .pV)(buf, lastOffset);
            lastOffset += 8;
        }
        if (lastBoxSize < 0) {
            throw new Error("ISOBMFF: Size out of range");
        }
        if (name === boxName) {
            if (boxName === 0x75756964 /* === "uuid" */) {
                lastOffset += 16; // Skip uuid name
            }
            return [boxBaseOffset, lastOffset, boxBaseOffset + lastBoxSize];
        }
        else {
            boxBaseOffset += lastBoxSize;
        }
    }
    return null;
}
/**
 * Gives the content of a specific UUID box.
 * `undefined` if that box is not found.
 *
 * If found, the returned Uint8Array contains just the box's content: the box
 * without its name and size.
 * @param {Uint8Array} buf
 * @param {Number} id1
 * @param {Number} id2
 * @param {Number} id3
 * @param {Number} id4
 * @returns {Uint8Array|undefined}
 */
function getUuidContent(buf, id1, id2, id3, id4) {
    const len = buf.length;
    let boxSize;
    for (let boxBaseOffset = 0; boxBaseOffset < len; boxBaseOffset += boxSize) {
        let currentOffset = boxBaseOffset;
        boxSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .pX)(buf, currentOffset);
        currentOffset += 4;
        const boxName = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .pX)(buf, currentOffset);
        currentOffset += 4;
        if (boxSize === 0) {
            boxSize = len - boxBaseOffset;
        }
        else if (boxSize === 1) {
            if (currentOffset + 8 > len) {
                return undefined;
            }
            boxSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be8toi */ .pV)(buf, currentOffset);
            currentOffset += 8;
        }
        if (boxName === 0x75756964 /* === "uuid" */ &&
            currentOffset + 16 <= len &&
            (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .pX)(buf, currentOffset) === id1 &&
            (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .pX)(buf, currentOffset + 4) === id2 &&
            (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .pX)(buf, currentOffset + 8) === id3 &&
            (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .pX)(buf, currentOffset + 12) === id4) {
            currentOffset += 16;
            return buf.subarray(currentOffset, boxBaseOffset + boxSize);
        }
    }
}
/**
 * For the next encountered box, return byte offsets corresponding to:
 *   1. the starting byte offset for the next box (should always be equal to
 *       `0`).
 *   2. The beginning of the box content - meaning the first byte after the
 *      size and the name of the box.
 *   3. The first byte after the end of the box, might be equal to `buf`'s
 *      length if we're considering the last box.
 *
 * `null` if no box is found.
 * @param {Uint8Array} buf - the isobmff structure
 * @param {Number} boxName - the 4-letter 'name' of the box as a 4 bit integer
 * generated from encoding the corresponding ASCII in big endian.
 */
function getNextBoxOffsets(buf) {
    const len = buf.length;
    if (len < 8) {
        _log__WEBPACK_IMPORTED_MODULE_1__/* .default.warn */ .Z.warn("ISOBMFF: box inferior to 8 bytes, cannot find offsets");
        return null;
    }
    let lastOffset = 0;
    let boxSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .pX)(buf, lastOffset);
    lastOffset += 4;
    const name = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .pX)(buf, lastOffset);
    lastOffset += 4;
    if (boxSize === 0) {
        boxSize = len;
    }
    else if (boxSize === 1) {
        if (lastOffset + 8 > len) {
            _log__WEBPACK_IMPORTED_MODULE_1__/* .default.warn */ .Z.warn("ISOBMFF: box too short, cannot find offsets");
            return null;
        }
        boxSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be8toi */ .pV)(buf, lastOffset);
        lastOffset += 8;
    }
    if (boxSize < 0) {
        throw new Error("ISOBMFF: Size out of range");
    }
    if (name === 0x75756964 /* === "uuid" */) {
        lastOffset += 16; // Skip uuid name
    }
    return [0, lastOffset, boxSize];
}



/***/ }),

/***/ 69903:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "XA": () => (/* binding */ getTRAF),
/* harmony export */   "Le": () => (/* binding */ getMDAT),
/* harmony export */   "fs": () => (/* binding */ getMDIA),
/* harmony export */   "E3": () => (/* binding */ getEMSG)
/* harmony export */ });
/* harmony import */ var _get_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65489);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns TRAF Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */
function getTRAF(buffer) {
    const moof = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .t_)(buffer, 0x6D6F6F66 /* moof */);
    if (moof === null) {
        return null;
    }
    return (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .t_)(moof, 0x74726166 /* traf */);
}
/**
 * Returns MDAT Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */
function getMDAT(buf) {
    return (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .t_)(buf, 0x6D646174 /* "mdat" */);
}
/**
 * Returns MDIA Box from the whole ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */
function getMDIA(buf) {
    const moov = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .t_)(buf, 0x6D6F6F76 /* moov */);
    if (moov === null) {
        return null;
    }
    const trak = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .t_)(moov, 0x7472616B /* "trak" */);
    if (trak === null) {
        return null;
    }
    return (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .t_)(trak, 0x6D646961 /* "mdia" */);
}
/**
 * Returns EMSG Box from the while ISOBMFF File.
 * Returns null if not found.
 * @param {Uint8Array} buffer
 * @returns {Uint8Array|null}
 */
function getEMSG(buffer, offset = 0) {
    return (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .t_)(buffer.subarray(offset), 0x656D7367 /* emsg */);
}



/***/ }),

/***/ 3544:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ takePSSHOut),
  "Y": () => (/* binding */ getPsshSystemID)
});

// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
;// CONCATENATED MODULE: ./src/utils/slice_uint8array.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {Uint8Array} arr - The Uint8Array you want to slice
 * @param {number} start - The starting byte index from the beginning
 * @param {number} end -     Byte index before which to end slicing.
 * If end is unspecified, the new ArrayBuffer contains all bytes from begin to
 * the end of this ArrayBuffer. If negative, it will make the Byte index begin
 * from the last Byte.
 * @returns {Uint8Array}
 */
function arraySlice(arr, start, end) {
    return new Uint8Array(Array.prototype.slice.call(arr, start, end));
}
/**
 * @param {Uint8Array} arr - The Uint8Array you want to slice
 * @param {number} start - The starting byte index from the beginning
 * @param {number} end -     Byte index before which to end slicing.
 * If end is unspecified, the new ArrayBuffer contains all bytes from begin to
 * the end of this ArrayBuffer. If negative, it will make the Byte index begin
 * from the last Byte.
 * @returns {Uint8Array}
 */
function uint8ArraySlice(arr, start, end) {
    return arr.slice(start, end);
}
/* harmony default export */ const slice_uint8array = (typeof Uint8Array.prototype.slice === "function" ?
    uint8ArraySlice :
    arraySlice);

// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(26332);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/get_box.ts
var get_box = __webpack_require__(65489);
;// CONCATENATED MODULE: ./src/parsers/containers/isobmff/take_pssh_out.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Replace every PSSH box from an ISOBMFF segment by FREE boxes and returns the
 * removed PSSH in an array.
 * Useful to manually manage encryption while avoiding the round-trip with the
 * browser's encrypted event.
 * @param {Uint8Array} data - the ISOBMFF segment
 * @returns {Array.<Uint8Array>} - The extracted PSSH boxes. In the order they
 * are encountered.
 */
function takePSSHOut(data) {
    let i = 0;
    const moov = (0,get_box/* getBoxContent */.t_)(data, 0x6D6F6F76 /* moov */);
    if (moov === null) {
        return [];
    }
    const psshBoxes = [];
    while (i < moov.length) {
        let psshOffsets;
        try {
            psshOffsets = (0,get_box/* getBoxOffsets */.Qy)(moov, 0x70737368 /* pssh */);
        }
        catch (e) {
            log/* default.warn */.Z.warn("ISOBMFF:", e);
            return psshBoxes;
        }
        if (psshOffsets == null) {
            return psshBoxes;
        }
        const pssh = slice_uint8array(moov, psshOffsets[0], psshOffsets[2]);
        const systemId = getPsshSystemID(pssh, psshOffsets[1] - psshOffsets[0]);
        if (systemId !== undefined) {
            psshBoxes.push({ systemId, data: pssh });
        }
        // replace by `free` box.
        moov[psshOffsets[0] + 4] = 0x66;
        moov[psshOffsets[0] + 5] = 0x72;
        moov[psshOffsets[0] + 6] = 0x65;
        moov[psshOffsets[0] + 7] = 0x65;
        i = psshOffsets[2];
    }
    return psshBoxes;
}
/**
 * Parse systemId from a "pssh" box into an hexadecimal string.
 * `undefined` if we could not extract a systemId.
 * @param {Uint8Array} buff - The pssh box
 * @param {number} initialDataOffset - offset of the first byte after the size
 * and name in this pssh box.
 * @returns {string|undefined}
 */
function getPsshSystemID(buff, initialDataOffset) {
    if (buff[initialDataOffset] > 1) {
        log/* default.warn */.Z.warn("ISOBMFF: un-handled PSSH version");
        return undefined;
    }
    const offset = initialDataOffset +
        4; /* version + flags */
    if (offset + 16 > buff.length) {
        return undefined;
    }
    const systemIDBytes = slice_uint8array(buff, offset, offset + 16);
    return (0,string_parsing/* bytesToHex */.ci)(systemIDBytes);
}


/***/ }),

/***/ 14959:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LD": () => (/* binding */ getMDHDTimescale),
/* harmony export */   "Qx": () => (/* binding */ getTrackFragmentDecodeTime),
/* harmony export */   "MM": () => (/* binding */ getDurationFromTrun),
/* harmony export */   "Wf": () => (/* binding */ getSegmentsFromSidx),
/* harmony export */   "J6": () => (/* binding */ updateBoxLength),
/* harmony export */   "s9": () => (/* binding */ parseEmsgBoxes)
/* harmony export */ });
/* unused harmony export patchPssh */
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97308);
/* harmony import */ var _utils_string_parsing__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(26332);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(63133);
/* harmony import */ var _get_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65489);
/* harmony import */ var _read__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69903);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Parse the sidx part (segment index) of an ISOBMFF buffer and construct a
 * corresponding Array of available segments.
 *
 * Returns `null` if not found.
 * @param {Uint8Array} buf
 * @param {Number} sidxOffsetInWholeSegment
 * @returns {Object|null} {Array.<Object>} - Information about each subsegment.
 */
function getSegmentsFromSidx(buf, sidxOffsetInWholeSegment) {
    const sidxOffsets = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxOffsets */ .Qy)(buf, 0x73696478 /* "sidx" */);
    if (sidxOffsets === null) {
        return null;
    }
    let offset = sidxOffsetInWholeSegment;
    const boxSize = sidxOffsets[2] - sidxOffsets[0];
    let cursor = sidxOffsets[1];
    /* version(8) */
    /* flags(24) */
    /* reference_ID(32); */
    /* timescale(32); */
    const version = buf[cursor];
    cursor += 4 + 4;
    const timescale = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(buf, cursor);
    cursor += 4;
    /* earliest_presentation_time(32 / 64) */
    /* first_offset(32 / 64) */
    let time;
    if (version === 0) {
        time = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(buf, cursor);
        cursor += 4;
        offset += (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(buf, cursor) + boxSize;
        cursor += 4;
    }
    else if (version === 1) {
        time = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be8toi */ .pV)(buf, cursor);
        cursor += 8;
        offset += (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be8toi */ .pV)(buf, cursor) + boxSize;
        cursor += 8;
    }
    else {
        return null;
    }
    const segments = [];
    /* reserved(16) */
    /* reference_count(16) */
    cursor += 2;
    let count = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be2toi */ .zK)(buf, cursor);
    cursor += 2;
    while (--count >= 0) {
        /* reference_type(1) */
        /* reference_size(31) */
        /* segment_duration(32) */
        /* sap..(32) */
        const refChunk = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(buf, cursor);
        cursor += 4;
        const refType = (refChunk & 0x80000000) >>> 31;
        const refSize = (refChunk & 0x7FFFFFFF);
        // when set to 1 indicates that the reference is to a sidx, else to media
        if (refType === 1) {
            throw new Error("sidx with reference_type `1` not yet implemented");
        }
        const duration = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(buf, cursor);
        cursor += 4;
        // let sapChunk = be4toi(buf, cursor + 8);
        cursor += 4;
        // TODO(pierre): handle sap
        // let startsWithSap = (sapChunk & 0x80000000) >>> 31;
        // let sapType = (sapChunk & 0x70000000) >>> 28;
        // let sapDelta = sapChunk & 0x0FFFFFFF;
        segments.push({ time,
            duration,
            count: 0,
            timescale,
            range: [offset, offset + refSize - 1] });
        time += duration;
        offset += refSize;
    }
    return segments;
}
/**
 * Parse track Fragment Decode Time to get a precize initial time for this
 * segment (in the media timescale).
 *
 * Stops at the first tfdt encountered from the beginning of the file.
 * Returns this time.
 * `undefined` if not found.
 * @param {Uint8Array} buffer
 * @returns {Number | undefined}
 */
function getTrackFragmentDecodeTime(buffer) {
    const traf = (0,_read__WEBPACK_IMPORTED_MODULE_2__/* .getTRAF */ .XA)(buffer);
    if (traf === null) {
        return undefined;
    }
    const tfdt = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .t_)(traf, 0x74666474 /* tfdt */);
    if (tfdt === null) {
        return undefined;
    }
    const version = tfdt[0];
    return version === 1 ? (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be8toi */ .pV)(tfdt, 4) :
        version === 0 ? (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(tfdt, 4) :
            undefined;
}
/**
 * Returns the "default sample duration" which is the default value for duration
 * of samples found in a "traf" ISOBMFF box.
 *
 * Returns `undefined` if no "default sample duration" has been found.
 * @param {Uint8Array} traf
 * @returns {number|undefined}
 */
function getDefaultDurationFromTFHDInTRAF(traf) {
    const tfhd = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .t_)(traf, 0x74666864 /* tfhd */);
    if (tfhd === null) {
        return undefined;
    }
    let cursor = /* version */ 1;
    const flags = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be3toi */ .QI)(tfhd, cursor);
    cursor += 3;
    const hasBaseDataOffset = (flags & 0x000001) > 0;
    const hasSampleDescriptionIndex = (flags & 0x000002) > 0;
    const hasDefaultSampleDuration = (flags & 0x000008) > 0;
    if (!hasDefaultSampleDuration) {
        return undefined;
    }
    cursor += 4;
    if (hasBaseDataOffset) {
        cursor += 8;
    }
    if (hasSampleDescriptionIndex) {
        cursor += 4;
    }
    const defaultDuration = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(tfhd, cursor);
    return defaultDuration;
}
/**
 * Calculate segment duration approximation by additioning the duration from
 * every samples in a trun ISOBMFF box.
 *
 * Returns `undefined` if we could not parse the duration.
 * @param {Uint8Array} buffer
 * @returns {number | undefined}
 */
function getDurationFromTrun(buffer) {
    const traf = (0,_read__WEBPACK_IMPORTED_MODULE_2__/* .getTRAF */ .XA)(buffer);
    if (traf === null) {
        return undefined;
    }
    const trun = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .t_)(traf, 0x7472756E /* trun */);
    if (trun === null) {
        return undefined;
    }
    let cursor = 0;
    const version = trun[cursor];
    cursor += 1;
    if (version > 1) {
        return undefined;
    }
    const flags = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be3toi */ .QI)(trun, cursor);
    cursor += 3;
    const hasSampleDuration = (flags & 0x000100) > 0;
    let defaultDuration = 0;
    if (!hasSampleDuration) {
        defaultDuration = getDefaultDurationFromTFHDInTRAF(traf);
        if (defaultDuration === undefined) {
            return undefined;
        }
    }
    const hasDataOffset = (flags & 0x000001) > 0;
    const hasFirstSampleFlags = (flags & 0x000004) > 0;
    const hasSampleSize = (flags & 0x000200) > 0;
    const hasSampleFlags = (flags & 0x000400) > 0;
    const hasSampleCompositionOffset = (flags & 0x000800) > 0;
    const sampleCounts = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(trun, cursor);
    cursor += 4;
    if (hasDataOffset) {
        cursor += 4;
    }
    if (hasFirstSampleFlags) {
        cursor += 4;
    }
    let i = sampleCounts;
    let duration = 0;
    while (i-- > 0) {
        if (hasSampleDuration) {
            duration += (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(trun, cursor);
            cursor += 4;
        }
        else {
            duration += defaultDuration;
        }
        if (hasSampleSize) {
            cursor += 4;
        }
        if (hasSampleFlags) {
            cursor += 4;
        }
        if (hasSampleCompositionOffset) {
            cursor += 4;
        }
    }
    return duration;
}
/**
 * Get timescale information from a movie header box. Found in init segments.
 * `undefined` if not found or not parsed.
 *
 * This timescale is the default timescale used for segments.
 * @param {Uint8Array} buffer
 * @returns {Number | undefined}
 */
function getMDHDTimescale(buffer) {
    const mdia = (0,_read__WEBPACK_IMPORTED_MODULE_2__/* .getMDIA */ .fs)(buffer);
    if (mdia === null) {
        return undefined;
    }
    const mdhd = (0,_get_box__WEBPACK_IMPORTED_MODULE_0__/* .getBoxContent */ .t_)(mdia, 0x6D646864 /* "mdhd" */);
    if (mdhd === null) {
        return undefined;
    }
    let cursor = 0;
    const version = mdhd[cursor];
    cursor += 4;
    return version === 1 ? (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(mdhd, cursor + 16) :
        version === 0 ? (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(mdhd, cursor + 8) :
            undefined;
}
/**
 * Creates a PSSH box with the given systemId and data.
 * @param {Array.<Object>} psshInfo
 * @returns {Uint8Array}
 */
function createPssh({ systemId, privateData }) {
    const _systemId = systemId.replace(/-/g, "");
    assert(_systemId.length === 32);
    return createBox("pssh", concat(4, // 4 initial zeroed bytes
    hexToBytes(_systemId), itobe4(privateData.length), privateData));
}
/**
 * Update ISOBMFF given to add a "pssh" box in the "moov" box for every content
 * protection in the psshList array given.
 * @param {Uint8Array} buf - the ISOBMFF file
 * @param {Array.<Object>} psshList
 * @returns {Uint8Array} - The new ISOBMFF generated.
 */
function patchPssh(buf, psshList) {
    if (psshList == null || psshList.length === 0) {
        return buf;
    }
    const moovOffsets = getBoxOffsets(buf, 0x6D6F6F76 /* = "moov" */);
    if (moovOffsets === null) {
        return buf;
    }
    const moov = buf.subarray(moovOffsets[0], moovOffsets[2]);
    const moovArr = [moov];
    for (let i = 0; i < psshList.length; i++) {
        moovArr.push(createPssh(psshList[i]));
    }
    const newmoov = updateBoxLength(concat(...moovArr));
    return concat(buf.subarray(0, moovOffsets[0]), newmoov, buf.subarray(moovOffsets[2]));
}
/**
 * Returns a new version of the given box with the size updated
 * so it reflects its actual size.
 *
 * You can use this function after modifying a ISOBMFF box so its size is
 * updated.
 *
 * /!\ Please consider that this function might mutate the given Uint8Array
 * in place or might create a new one, depending on the current conditions.
 * @param {Uint8Array} buf - The ISOBMFF box
 * @returns {Uint8Array}
 */
function updateBoxLength(buf) {
    const newLen = buf.length;
    if (newLen < 4) {
        throw new Error("Cannot update box length: box too short");
    }
    const oldSize = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(buf, 0);
    if (oldSize === 0) {
        if (newLen > _constants__WEBPACK_IMPORTED_MODULE_3__/* .MAX_32_BIT_INT */ .s) {
            const newBox = new Uint8Array(newLen + 8);
            newBox.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe4 */ .kh)(1), 0);
            newBox.set(buf.subarray(4, 8), 4);
            newBox.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe8 */ .el)(newLen + 8), 8);
            newBox.set(buf.subarray(8, newLen), 16);
            return newBox;
        }
        else {
            buf.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe4 */ .kh)(newLen), 0);
            return buf;
        }
    }
    else if (oldSize === 1) {
        if (newLen < 16) {
            throw new Error("Cannot update box length: box too short");
        }
        buf.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe8 */ .el)(newLen), 8);
        return buf;
    }
    else if (newLen <= _constants__WEBPACK_IMPORTED_MODULE_3__/* .MAX_32_BIT_INT */ .s) {
        buf.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe4 */ .kh)(newLen), 0);
        return buf;
    }
    else {
        const newBox = new Uint8Array(newLen + 8);
        newBox.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe4 */ .kh)(1), 0);
        newBox.set(buf.subarray(4, 8), 4);
        newBox.set((0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .itobe8 */ .el)(newLen + 8), 8);
        newBox.set(buf.subarray(8, newLen), 16);
        return newBox;
    }
}
/**
 * Parse EMSG boxes from ISOBMFF data.
 * @param {Uint8Array} buf
 * @returns {Array.<Object> | undefined}
 */
function parseEmsgBoxes(buffer) {
    const emsgs = [];
    let offset = 0;
    while (offset < buffer.length) {
        const emsg = (0,_read__WEBPACK_IMPORTED_MODULE_2__/* .getEMSG */ .E3)(buffer, offset);
        if (emsg === null) {
            break;
        }
        const length = emsg.length;
        offset += length;
        let position = 4; // skip version + flags
        const { end: schemeIdEnd, string: schemeIdUri } = (0,_utils_string_parsing__WEBPACK_IMPORTED_MODULE_4__/* .readNullTerminatedString */ .DM)(emsg, position);
        position = schemeIdEnd; // skip schemeIdUri
        const { end: valueEnd, string: value } = (0,_utils_string_parsing__WEBPACK_IMPORTED_MODULE_4__/* .readNullTerminatedString */ .DM)(emsg, position);
        position = valueEnd; // skip value
        const timescale = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(emsg, position);
        position += 4; // skip timescale
        const presentationTimeDelta = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(emsg, position);
        position += 4; // skip presentationTimeDelta
        const eventDuration = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(emsg, position);
        position += 4; // skip eventDuration
        const id = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .be4toi */ .pX)(emsg, position);
        position += 4; // skip id
        const messageData = emsg.subarray(position, length);
        const emsgData = { schemeIdUri,
            value,
            timescale,
            presentationTimeDelta,
            eventDuration,
            id,
            messageData };
        emsgs.push(emsgData);
    }
    if (emsgs.length === 0) {
        return undefined;
    }
    return emsgs;
}



/***/ }),

/***/ 20077:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "i": () => (/* binding */ getTimeCodeScale),
/* harmony export */   "$": () => (/* binding */ getSegmentsFromCues)
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6077);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const SEGMENT_ID = 0x18538067;
const INFO_ID = 0x1549A966;
const TIMECODESCALE_ID = 0x2AD7B1;
const DURATION_ID = 0x4489;
const CUES_ID = 0x1C53BB6B;
const CUE_POINT_ID = 0xBB;
const CUE_TIME_ID = 0xB3;
const CUE_TRACK_POSITIONS_ID = 0xB7;
const CUE_CLUSTER_POSITIONS_ID = 0xF1;
/**
 * Find the offsets of the value linked to the given element ID.
 * @param {number} elementID - ID for the searched element.
 * @param {Array.<number>} parents - eventual IDs of the parent elements. From
 * top level to lower level (from the furthest to the closest).
 * @param {Uint8Array} buffer - buffer where the ID will be searched
 * @param {Array.<number>} range - start and end offsets in the buffer where the
 * ID will be searched.
 * @returns {Array.<number>|null}
 */
function findNextElement(elementID, parents, buffer, [initialOffset, maxOffset]) {
    let currentOffset = initialOffset;
    while (currentOffset < maxOffset) {
        const parsedID = getEBMLID(buffer, currentOffset);
        if (parsedID == null) {
            return null;
        }
        const { value: ebmlTagID, length: ebmlTagLength } = parsedID;
        const sizeOffset = currentOffset + ebmlTagLength;
        const parsedValue = getEBMLValue(buffer, sizeOffset);
        if (parsedValue == null) {
            return null;
        }
        const { length: valueLengthLength, value: valueLength } = parsedValue;
        const valueOffset = sizeOffset + valueLengthLength;
        const valueEndOffset = valueOffset + valueLength;
        if (ebmlTagID === elementID) {
            return [valueOffset, valueEndOffset];
        }
        else if (parents.length > 0) {
            for (let i = 0; i < parents.length; i++) {
                if (ebmlTagID === parents[i]) {
                    const newParents = parents.slice(i + 1, parents.length);
                    return findNextElement(elementID, newParents, buffer, [valueOffset, valueEndOffset]);
                }
            }
        }
        currentOffset = valueEndOffset;
    }
    return null;
}
/**
 * Return the timecode scale (basically timescale) of the whole file.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */
function getTimeCodeScale(buffer, initialOffset) {
    const timeCodeScaleOffsets = findNextElement(TIMECODESCALE_ID, [SEGMENT_ID, INFO_ID], buffer, [initialOffset, buffer.length]);
    if (timeCodeScaleOffsets == null) {
        return null;
    }
    const length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
    return 1e9 / bytesToNumber(buffer, timeCodeScaleOffsets[0], length);
}
/**
 * Return the duration of the concerned media.
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {number|null}
 */
function getDuration(buffer, initialOffset) {
    const timeCodeScaleOffsets = findNextElement(DURATION_ID, [SEGMENT_ID, INFO_ID], buffer, [initialOffset, buffer.length]);
    if (timeCodeScaleOffsets == null) {
        return null;
    }
    const length = timeCodeScaleOffsets[1] - timeCodeScaleOffsets[0];
    if (length === 4) {
        return get_IEEE754_32Bits(buffer, timeCodeScaleOffsets[0]);
    }
    else if (length === 8) {
        return get_IEEE754_64Bits(buffer, timeCodeScaleOffsets[0]);
    }
    return null;
}
/**
 * @param {Uint8Array} buffer
 * @param {number} initialOffset
 * @returns {Array.<Object>|null}
 */
function getSegmentsFromCues(buffer, initialOffset) {
    const segmentRange = findNextElement(SEGMENT_ID, [], buffer, [initialOffset, buffer.length]);
    if (segmentRange == null) {
        return null;
    }
    const [segmentRangeStart, segmentRangeEnd] = segmentRange;
    const timescale = getTimeCodeScale(buffer, segmentRangeStart);
    if (timescale == null) {
        return null;
    }
    const duration = getDuration(buffer, segmentRangeStart);
    if (duration == null) {
        return null;
    }
    const cuesRange = findNextElement(CUES_ID, [], buffer, [segmentRangeStart, segmentRangeEnd]);
    if (cuesRange == null) {
        return null;
    }
    const rawInfos = [];
    let currentOffset = cuesRange[0];
    while (currentOffset < cuesRange[1]) {
        const cuePointRange = findNextElement(CUE_POINT_ID, [], buffer, [currentOffset, cuesRange[1]]);
        if (cuePointRange == null) {
            break;
        }
        const cueTimeRange = findNextElement(CUE_TIME_ID, [], buffer, [cuePointRange[0], cuePointRange[1]]);
        if (cueTimeRange == null) {
            return null;
        }
        const time = bytesToNumber(buffer, cueTimeRange[0], cueTimeRange[1] - cueTimeRange[0]);
        const cueOffsetRange = findNextElement(CUE_CLUSTER_POSITIONS_ID, [CUE_TRACK_POSITIONS_ID], buffer, [cuePointRange[0], cuePointRange[1]]);
        if (cueOffsetRange == null) {
            return null;
        }
        const rangeStart = bytesToNumber(buffer, cueOffsetRange[0], cueOffsetRange[1] - cueOffsetRange[0]) +
            segmentRangeStart;
        rawInfos.push({ time, rangeStart });
        currentOffset = cuePointRange[1];
    }
    const segments = [];
    for (let i = 0; i < rawInfos.length; i++) {
        const currentSegment = rawInfos[i];
        if (i === rawInfos.length - 1) {
            segments.push({
                time: currentSegment.time,
                count: 0,
                timescale,
                duration: i === 0 ? duration :
                    duration - currentSegment.time,
                range: [currentSegment.rangeStart, Infinity],
            });
        }
        else {
            segments.push({
                time: currentSegment.time,
                count: 0,
                timescale,
                duration: rawInfos[i + 1].time - currentSegment.time,
                range: [currentSegment.rangeStart, rawInfos[i + 1].rangeStart - 1],
            });
        }
    }
    return segments;
}
function getLength(buffer, offset) {
    for (let length = 1; length <= 8; length++) {
        if (buffer[offset] >= Math.pow(2, 8 - length)) {
            return length;
        }
    }
    return undefined;
}
function getEBMLID(buffer, offset) {
    const length = getLength(buffer, offset);
    if (length == null) {
        _log__WEBPACK_IMPORTED_MODULE_0__/* .default.warn */ .Z.warn("webm: unrepresentable length");
        return null;
    }
    if (offset + length > buffer.length) {
        _log__WEBPACK_IMPORTED_MODULE_0__/* .default.warn */ .Z.warn("webm: impossible length");
        return null;
    }
    let value = 0;
    for (let i = 0; i < length; i++) {
        value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
    }
    return { length, value };
}
function getEBMLValue(buffer, offset) {
    const length = getLength(buffer, offset);
    if (length == null) {
        _log__WEBPACK_IMPORTED_MODULE_0__/* .default.warn */ .Z.warn("webm: unrepresentable length");
        return null;
    }
    if (offset + length > buffer.length) {
        _log__WEBPACK_IMPORTED_MODULE_0__/* .default.warn */ .Z.warn("webm: impossible length");
        return null;
    }
    let value = (buffer[offset] & (1 << (8 - length)) - 1) *
        Math.pow(2, (length - 1) * 8);
    for (let i = 1; i < length; i++) {
        value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
    }
    return { length, value };
}
/**
 * Convert a IEEE754 32 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */
function get_IEEE754_32Bits(buffer, offset) {
    return new DataView(buffer.buffer).getFloat32(offset);
}
/**
 * Convert a IEEE754 64 bits floating number as an Uint8Array into its
 * corresponding Number.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {number}
 */
function get_IEEE754_64Bits(buffer, offset) {
    return new DataView(buffer.buffer).getFloat64(offset);
}
function bytesToNumber(buffer, offset, length) {
    let value = 0;
    for (let i = 0; i < length; i++) {
        value = buffer[offset + i] * Math.pow(2, (length - i - 1) * 8) + value;
    }
    return value;
}


/***/ }),

/***/ 73393:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(97308);
/* harmony import */ var _utils_string_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26332);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */


/**
 * @param {UInt8Array} buf
 * @returns {Object}
 */
function parseBif(buf) {
    let pos = 0;
    const length = buf.length;
    const fileFormat = (0,_utils_string_parsing__WEBPACK_IMPORTED_MODULE_0__/* .utf8ToStr */ .uR)(buf.subarray(pos + 1, pos + 8));
    pos += 8;
    if (buf[0] !== 0x89 || fileFormat !== "BIF\r\n\u001a\n") {
        throw new Error("Invalid BIF file");
    }
    const minorVersion = buf[pos];
    pos += 1;
    const majorVersion = buf[pos];
    pos += 1;
    const patchVersion = buf[pos];
    pos += 1;
    const increVersion = buf[pos];
    pos += 1;
    const version = [minorVersion, majorVersion, patchVersion, increVersion].join(".");
    if (majorVersion > 0) {
        throw new Error(`Unhandled version: ${majorVersion}`);
    }
    const imageCount = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .le4toi */ .dN)(buf, pos);
    pos += 4;
    const framewiseSeparation = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .le4toi */ .dN)(buf, pos);
    pos += 4;
    const format = (0,_utils_string_parsing__WEBPACK_IMPORTED_MODULE_0__/* .utf8ToStr */ .uR)(buf.subarray(pos, pos + 4));
    pos += 4;
    const width = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .le2toi */ .qb)(buf, pos);
    pos += 2;
    const height = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .le2toi */ .qb)(buf, pos);
    pos += 2;
    const aspectRatio = [buf[pos], buf[pos + 1]].join(":");
    pos += 2;
    const isVod = buf[pos] === 1;
    // bytes 0x1F to 0x40 is unused data for now
    pos = 0x40;
    const thumbs = [];
    if (imageCount === 0) {
        throw new Error("bif: no images to parse");
    }
    let index = 0;
    let previousImageInfo = null;
    while (pos < length) {
        const currentImageTimestamp = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .le4toi */ .dN)(buf, pos);
        pos += 4;
        const currentImageOffset = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_1__/* .le4toi */ .dN)(buf, pos);
        pos += 4;
        if (previousImageInfo !== null) {
            // calculate for index-1
            const ts = previousImageInfo.timestamp * framewiseSeparation;
            const duration = framewiseSeparation;
            const data = buf.slice(previousImageInfo.offset, currentImageOffset);
            thumbs.push({ index, duration, ts, data });
            index++;
        }
        if (currentImageTimestamp === 0xFFFFFFFF) {
            break;
        }
        previousImageInfo = { timestamp: currentImageTimestamp,
            offset: currentImageOffset };
    }
    return { fileFormat: "BIF",
        version,
        imageCount,
        timescale: 1000,
        format,
        width,
        height,
        aspectRatio,
        isVod,
        thumbs };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parseBif);


/***/ }),

/***/ 2259:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ clearTimelineFromPosition)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Remove segments which starts before the given `firstAvailablePosition` from
 * the timeline. `firstAvailablePosition` has to be time scaled.
 * @param {Array.<Object>}
 * @returns {number}
 */
function clearTimelineFromPosition(timeline, firstAvailablePosition) {
    while (timeline.length > 0) {
        const firstElt = timeline[0];
        if (firstElt.start >= firstAvailablePosition) {
            return; // all clear
        }
        if (firstElt.repeatCount <= 0) {
            timeline.shift();
        }
        else { // we have a segment repetition
            const nextElt = timeline[1];
            if (nextElt != null && nextElt.start <= firstAvailablePosition) {
                timeline.shift();
            }
            else { // no next segment or next segment is available
                if (firstElt.duration <= 0) {
                    return;
                }
                let nextStart = firstElt.start + firstElt.duration;
                let nextRepeat = 1;
                while (nextStart < firstAvailablePosition &&
                    nextRepeat <= firstElt.repeatCount) {
                    nextStart += firstElt.duration;
                    nextRepeat++;
                }
                if (nextRepeat > firstElt.repeatCount) { // every start is before
                    timeline.shift();
                }
                else { // some repetitions start after and some before
                    const newRepeat = firstElt.repeatCount - nextRepeat;
                    firstElt.start = nextStart;
                    firstElt.repeatCount = newRepeat;
                    return;
                }
            }
        }
    }
}


/***/ }),

/***/ 61443:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KF": () => (/* binding */ calculateRepeat),
/* harmony export */   "jH": () => (/* binding */ getIndexSegmentEnd),
/* harmony export */   "gT": () => (/* binding */ toIndexTime),
/* harmony export */   "zG": () => (/* binding */ fromIndexTime),
/* harmony export */   "PZ": () => (/* binding */ getTimescaledRange),
/* harmony export */   "_j": () => (/* binding */ checkDiscontinuity)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// byte-range
/**
 * Calculate the number of times a timeline element repeats based on the next
 * element.
 * @param {Object} element
 * @param {Object} nextElement
 * @param {number} maxPosition
 * @returns {Number}
 */
function calculateRepeat(element, nextElement, maxPosition) {
    const { repeatCount } = element;
    if (repeatCount >= 0) {
        return repeatCount;
    }
    // A negative value of the @r attribute of the S element indicates
    // that the duration indicated in @d attribute repeats until the
    // start of the next S element, the end of the Period or until the
    // next MPD update.
    let segmentEnd;
    if (nextElement != null) {
        segmentEnd = nextElement.start;
    }
    else if (maxPosition != null) {
        segmentEnd = maxPosition;
    }
    else {
        segmentEnd = Number.MAX_VALUE;
    }
    return Math.ceil((segmentEnd - element.start) / element.duration) - 1;
}
/**
 * Returns end of the segment given, in index time.
 * @param {Object} segment
 * @param {Object|null} [nextSegment]
 * @param {number} maxPosition
 * @returns {Number}
 */
function getIndexSegmentEnd(segment, nextSegment, maxPosition) {
    const { start, duration } = segment;
    if (duration <= 0) {
        return start;
    }
    const repeat = calculateRepeat(segment, nextSegment, maxPosition);
    return start + (repeat + 1) * duration;
}
/**
 * Convert from `presentationTime`, the time of the segment at the moment it
 * is decoded to `mediaTime`, the original time the segments point at.
 * @param {number} time
 * @param {Object} indexOptions
 * @returns {number}
 */
function toIndexTime(time, indexOptions) {
    var _a;
    return time * indexOptions.timescale + ((_a = indexOptions.indexTimeOffset) !== null && _a !== void 0 ? _a : 0);
}
/**
 * Convert from `mediaTime`, the original time the segments point at to
 * `presentationTime`, the time of the segment at the moment it is decoded.
 * @param {number} time
 * @param {Object} indexOptions
 * @returns {number}
 */
function fromIndexTime(time, indexOptions) {
    var _a;
    return (time - ((_a = indexOptions.indexTimeOffset) !== null && _a !== void 0 ? _a : 0)) / indexOptions.timescale;
}
/**
 * @param {Number} start
 * @param {Number} duration
 * @param {Number} timescale
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */
function getTimescaledRange(start, duration, timescale) {
    return [start * timescale,
        (start + duration) * timescale];
}
/**
 * Get index of the last segment in the timeline starting before/at the given
 * timescaled time.
 * Returns -1 if the given time is lower than the start of the first available
 * segment.
 * @param {Object} index
 * @param {Number} timeTScaled
 * @returns {Number}
 */
function getIndexOfLastObjectBefore(timeline, timeTScaled) {
    let low = 0;
    let high = timeline.length;
    while (low < high) {
        const mid = (low + high) >>> 1; // Divide by two + floor
        if (timeline[mid].start <= timeTScaled) {
            low = mid + 1;
        }
        else {
            high = mid;
        }
    }
    return low - 1;
}
/**
 * @param {Object} index
 * @param {number} timeSec
 * @param {number} [maxPosition]
 * @returns {number|null}
 */
function checkDiscontinuity(index, timeSec, maxPosition) {
    const { timeline } = index;
    const scaledTime = toIndexTime(timeSec, index);
    if (scaledTime < 0) {
        return null;
    }
    const segmentIndex = getIndexOfLastObjectBefore(timeline, scaledTime);
    if (segmentIndex < 0 || segmentIndex >= timeline.length - 1) {
        return null;
    }
    const timelineItem = timeline[segmentIndex];
    if (timelineItem.duration <= 0) {
        return null;
    }
    const nextTimelineItem = timeline[segmentIndex + 1];
    if (nextTimelineItem === undefined) {
        return null;
    }
    const nextStart = nextTimelineItem.start;
    const segmentEnd = getIndexSegmentEnd(timelineItem, nextTimelineItem, maxPosition);
    return scaledTime >= segmentEnd &&
        scaledTime < nextStart ? fromIndexTime(nextStart, index) :
        null;
}


/***/ }),

/***/ 91434:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ isSegmentStillAvailable)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns true if a Segment returned by the corresponding index is still
 * considered available.
 * Returns false if it is not available anymore.
 * Returns undefined if we cannot know whether it is still available or not.
 * /!\ We do not check the mediaURLs of the segment.
 * @param {Object} segment
 * @param {Array.<Object>} timescale
 * @param {number} timeline
 * @returns {Boolean|undefined}
 */
function isSegmentStillAvailable(segment, timeline, timescale, indexTimeOffset) {
    for (let i = 0; i < timeline.length; i++) {
        const tSegment = timeline[i];
        const tSegmentTime = (tSegment.start - indexTimeOffset) / timescale;
        if (tSegmentTime > segment.time) {
            return false;
        }
        else if (tSegmentTime === segment.time) {
            if ((tSegment.duration / timescale) !== segment.duration) {
                return false;
            }
            if (tSegment.range == null) {
                return segment.range == null;
            }
            return segment.range != null &&
                tSegment.range[0] === segment.range[0] &&
                tSegment.range[1] === segment.range[1];
        }
        else { // tSegment.start < segment.time
            if (tSegment.repeatCount >= 0 && tSegment.duration != null) {
                const timeDiff = tSegmentTime - tSegment.start;
                const repeat = (timeDiff / tSegment.duration) - 1;
                return repeat % 1 === 0 && repeat <= tSegment.repeatCount;
            }
        }
    }
    return false;
}


/***/ }),

/***/ 71140:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ updateSegmentTimeline)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3590);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6077);
/* harmony import */ var _index_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61443);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Update a complete array of segments in a given timeline with a [generally]
 * smaller but [generally] newer set of segments.
 * @param {Array.<Object>} oldTimeline
 * @param {Array.<Object>} newTimeline
 */
function updateSegmentTimeline(oldTimeline, newTimeline) {
    const prevTimelineLength = oldTimeline.length;
    if (oldTimeline.length === 0) {
        oldTimeline.splice(0, prevTimelineLength, ...newTimeline);
        return;
    }
    if (newTimeline.length === 0) {
        return;
    }
    const newIndexStart = newTimeline[0].start;
    const oldLastElt = oldTimeline[prevTimelineLength - 1];
    const oldIndexEnd = (0,_index_helpers__WEBPACK_IMPORTED_MODULE_0__/* .getIndexSegmentEnd */ .jH)(oldLastElt, newTimeline[0]);
    if (oldIndexEnd < newIndexStart) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z("MANIFEST_UPDATE_ERROR", "Cannot perform partial update: not enough data");
    }
    for (let i = prevTimelineLength - 1; i >= 0; i--) {
        const currStart = oldTimeline[i].start;
        if (currStart === newIndexStart) {
            // replace that one and those after it
            oldTimeline.splice(i, prevTimelineLength - i, ...newTimeline);
            return;
        }
        else if (currStart < newIndexStart) { // first to be before
            const currElt = oldTimeline[i];
            if (currElt.start + currElt.duration > newIndexStart) {
                // the new Manifest overlaps a previous segment (weird). Remove the latter.
                _log__WEBPACK_IMPORTED_MODULE_2__/* .default.warn */ .Z.warn("RepresentationIndex: Manifest update removed previous segments");
                oldTimeline.splice(i, prevTimelineLength - i, ...newTimeline);
                return;
            }
            else if (currElt.repeatCount === undefined || currElt.repeatCount <= 0) {
                if (currElt.repeatCount < 0) {
                    currElt.repeatCount = Math.floor((newIndexStart - currElt.start) /
                        currElt.duration) - 1;
                }
                oldTimeline.splice(i + 1, prevTimelineLength - (i + 1), ...newTimeline);
                return;
            }
            // else, there is a positive repeat we might want to update
            const eltLastTime = currElt.start + currElt.duration * (currElt.repeatCount + 1);
            if (eltLastTime <= newIndexStart) { // our new index comes directly after
                // put it after this one
                oldTimeline.splice(i + 1, prevTimelineLength - (i + 1), ...newTimeline);
                return;
            }
            const newCurrRepeat = ((newIndexStart - currElt.start) / currElt.duration) - 1;
            if (newCurrRepeat % 1 === 0 && currElt.duration === newTimeline[0].duration) {
                const newRepeatCount = newTimeline[0].repeatCount < 0 ?
                    -1 : // === maximum possible repeat
                    newTimeline[0].repeatCount + newCurrRepeat + 1;
                // replace that one and those after it
                oldTimeline.splice(i, prevTimelineLength - i, ...newTimeline);
                oldTimeline[i].start = currElt.start;
                oldTimeline[i].repeatCount = newRepeatCount;
                return;
            }
            _log__WEBPACK_IMPORTED_MODULE_2__/* .default.warn */ .Z.warn("RepresentationIndex: Manifest update removed previous segments");
            oldTimeline[i].repeatCount = Math.floor(newCurrRepeat);
            // put it after this one
            oldTimeline.splice(i + 1, prevTimelineLength - (i + 1), ...newTimeline);
            return;
        }
    }
    // if we got here, it means that every segments in the previous manifest are
    // after the new one. This is unusual.
    // Either the new one has more depth or it's an older one.
    const prevLastElt = oldTimeline[oldTimeline.length - 1];
    const newLastElt = newTimeline[newTimeline.length - 1];
    if (prevLastElt.repeatCount !== undefined && prevLastElt.repeatCount < 0) {
        if (prevLastElt.start > newLastElt.start) {
            _log__WEBPACK_IMPORTED_MODULE_2__/* .default.warn */ .Z.warn("RepresentationIndex: The new index is older than the previous one");
            return; // the old comes after
        }
        else { // the new has more depth
            _log__WEBPACK_IMPORTED_MODULE_2__/* .default.warn */ .Z.warn("RepresentationIndex: The new index is \"bigger\" than the previous one");
            oldTimeline.splice(0, prevTimelineLength, ...newTimeline);
            return;
        }
    }
    const prevLastTime = prevLastElt.start + prevLastElt.duration *
        (prevLastElt.repeatCount + 1);
    const newLastTime = newLastElt.start + newLastElt.duration *
        (newLastElt.repeatCount + 1);
    if (prevLastTime >= newLastTime) {
        _log__WEBPACK_IMPORTED_MODULE_2__/* .default.warn */ .Z.warn("RepresentationIndex: The new index is older than the previous one");
        return; // the old comes after
    }
    // the new one has more depth. full update
    _log__WEBPACK_IMPORTED_MODULE_2__/* .default.warn */ .Z.warn("RepresentationIndex: The new index is \"bigger\" than the previous one");
    oldTimeline.splice(0, prevTimelineLength, ...newTimeline);
    return;
}


/***/ }),

/***/ 38397:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4938);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// __VERY__ simple SAMI parser, based on ugly-but-working REGEXP:
//   - the text, start and end times are correctly parsed.
//   - only text for the given language is parsed.
//   - only the CSS style associated to the P element is set.
//   - we should be safe for any XSS.
// The language indicated to the parser should be present in the CSS and the
// corresponding Class should be on the P elements. If we fail to find the
// language in a "lang" property of a CSS class, the parser will throw.
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

const HTML_ENTITIES = /&#([0-9]+);/g;
const BR = /<br>/gi;
const STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
const PARAG = /\s*<p (?:class=([^>]+))?>(.*)/i;
const START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
/**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */
function getClassNameByLang(str) {
    const ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
    const langs = {};
    let m = ruleRe.exec(str);
    while (m !== null) {
        const name = m[1];
        const lang = getCSSProperty(m[2], "lang");
        if (name != null && lang != null) {
            langs[lang] = name;
        }
        m = ruleRe.exec(str);
    }
    return langs;
}
/**
 * Returns the rules defined for the P element.
 * Empty string if not found.
 * @param {string} str - The entire styling part.
 * @returns {string}
 */
function getPCSSRules(str) {
    const pRuleRegex = /p\s*{([^}]*)}/gi;
    const rule = pRuleRegex.exec(str);
    if (rule === null) {
        return "";
    }
    return rule[1];
}
/**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */
function getCSSProperty(str, name) {
    const matches = (new RegExp("\\s*" + name + ":\\s*(\\S+);", "i")).exec(str);
    return Array.isArray(matches) ? matches[1] :
        null;
}
/**
 * @param {string} text
 * @returns {string}
 */
function decodeEntities(text) {
    return text
        .replace(HTML_ENTITIES, (_, $1) => String.fromCharCode($1));
}
/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 */
function parseSami(smi, timeOffset, lang) {
    const syncOpen = /<sync[ >]/ig;
    const syncClose = /<sync[ >]|<\/body>/ig;
    const subs = [];
    const styleMatches = STYLE.exec(smi);
    const css = Array.isArray(styleMatches) ? styleMatches[1] :
        "";
    let up;
    let to;
    // FIXME Is that wanted?
    // previously written as let to = SyncClose.exec(smi); but never used
    syncClose.exec(smi);
    const langs = getClassNameByLang(css);
    const pCSS = getPCSSRules(css);
    let klass;
    if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(lang)) {
        klass = langs[lang];
        if (klass === undefined) {
            throw new Error(`sami: could not find lang ${lang} in CSS`);
        }
    }
    while (true) {
        up = syncOpen.exec(smi);
        to = syncClose.exec(smi);
        if (up === null && to === null) {
            break;
        }
        if (up === null || to === null || up.index >= to.index) {
            throw new Error("parse error");
        }
        const str = smi.slice(up.index, to.index);
        const tim = START.exec(str);
        if (!Array.isArray(tim)) {
            throw new Error("parse error (sync time attribute)");
        }
        const start = +tim[1];
        if (isNaN(start)) {
            throw new Error("parse error (sync time attribute NaN)");
        }
        appendToSubs(str.split("\n"), start / 1000);
    }
    return subs;
    function appendToSubs(lines, start) {
        let i = lines.length;
        while (--i >= 0) {
            const paragraphInfos = PARAG.exec(lines[i]);
            if (!Array.isArray(paragraphInfos)) {
                continue;
            }
            const [, className, txt] = paragraphInfos;
            if (klass !== className) {
                continue;
            }
            if (txt === "&nbsp;") {
                subs[subs.length - 1].end = start;
            }
            else {
                const wrapperEl = document.createElement("DIV");
                wrapperEl.className = "rxp-texttrack-region";
                const divEl = document.createElement("DIV");
                divEl.className = "rxp-texttrack-div";
                divEl.style.position = "absolute";
                divEl.style.bottom = "0";
                divEl.style.width = "100%";
                divEl.style.color = "#fff";
                divEl.style.textShadow = "-1px -1px 0 #000," +
                    "1px -1px 0 #000," +
                    "-1px 1px 0 #000," +
                    "1px 1px 0 #000";
                const pEl = document.createElement("div");
                pEl.className = "rxp-texttrack-p";
                if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(pCSS)) {
                    pEl.style.cssText = pCSS;
                }
                const textEls = txt.split(BR);
                for (let j = 0; j < textEls.length; j++) {
                    if (j !== 0) {
                        pEl.appendChild(document.createElement("BR"));
                    }
                    const spanEl = document.createElement("SPAN");
                    spanEl.className = "rxp-texttrack-span";
                    spanEl.textContent = decodeEntities(textEls[j]);
                    pEl.appendChild(spanEl);
                }
                divEl.appendChild(pEl);
                wrapperEl.appendChild(divEl);
                subs.push({ element: wrapperEl,
                    start: start + timeOffset,
                    end: -1 /* Will be updated on a following iteration */ });
            }
        }
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parseSami);


/***/ }),

/***/ 20891:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _compat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11862);
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4938);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */


const HTML_ENTITIES = /&#([0-9]+);/g;
const BR = /<br>/gi;
const STYLE = /<style[^>]*>([\s\S]*?)<\/style[^>]*>/i;
const PARAG = /\s*<p (?:class=([^>]+))?>(.*)/i;
const START = /<sync[^>]+?start="?([0-9]*)"?[^0-9]/i;
/**
 * Creates an array of VTTCue/TextTrackCue from a given array of cue objects.
 * @param {Array.<Object>} cuesArray - Objects containing the start, end and
 * text.
 * @returns {Array.<VTTCue>}
 */
function createCuesFromArray(cuesArray) {
    const nativeCues = [];
    for (let i = 0; i < cuesArray.length; i++) {
        const { start, end, text } = cuesArray[i];
        if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(text) && end != null) {
            const cue = (0,_compat__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(start, end, text);
            if (cue != null) {
                nativeCues.push(cue);
            }
        }
    }
    return nativeCues;
}
/**
 * Returns classnames for every languages.
 * @param {string} str
 * @returns {Object}
 */
function getClassNameByLang(str) {
    const ruleRe = /\.(\S+)\s*{([^}]*)}/gi;
    const langs = {};
    let m = ruleRe.exec(str);
    while (Array.isArray(m)) {
        const name = m[1];
        const lang = getCSSProperty(m[2], "lang");
        if (name != null && lang != null) {
            langs[lang] = name;
        }
        m = ruleRe.exec(str);
    }
    return langs;
}
/**
 * @param {string} str - entire CSS rule
 * @param {string} name - name of the property
 * @returns {string|null} - value of the property. Null if not found.
 */
function getCSSProperty(str, name) {
    const matches = (new RegExp("\\s*" + name + ":\\s*(\\S+);", "i")).exec(str);
    return Array.isArray(matches) ? matches[1] :
        null;
}
/**
 * Decode HMTL formatting into a string.
 * @param {string} text
 * @returns {string}
 */
function decodeEntities(text) {
    return text
        .replace(BR, "\n")
        .replace(HTML_ENTITIES, (_, $1) => String.fromCharCode($1));
}
/**
 * Because sami is not really html... we have to use
 * some kind of regular expressions to parse it...
 * the cthulhu way :)
 * The specification being quite clunky, this parser
 * may not work for every sami input.
 *
 * @param {string} smi
 * @param {Number} timeOffset
 * @param {string} lang
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseSami(smi, timeOffset, lang) {
    const syncOpen = /<sync[ >]/ig;
    const syncClose = /<sync[ >]|<\/body>/ig;
    const subs = [];
    const styleMatches = STYLE.exec(smi);
    const css = styleMatches !== null ? styleMatches[1] :
        "";
    let up;
    let to;
    // FIXME Is that wanted?
    // previously written as let to = SyncClose.exec(smi); but never used
    syncClose.exec(smi);
    const langs = getClassNameByLang(css);
    let klass;
    if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(lang)) {
        klass = langs[lang];
        if (klass === undefined) {
            throw new Error(`sami: could not find lang ${lang} in CSS`);
        }
    }
    while (true) {
        up = syncOpen.exec(smi);
        to = syncClose.exec(smi);
        if (up === null && to === null) {
            break;
        }
        if (up === null || to === null || up.index >= to.index) {
            throw new Error("parse error");
        }
        const str = smi.slice(up.index, to.index);
        const tim = START.exec(str);
        if (tim === null) {
            throw new Error("parse error (sync time attribute)");
        }
        const start = +tim[1];
        if (isNaN(start)) {
            throw new Error("parse error (sync time attribute NaN)");
        }
        appendToSubs(str.split("\n"), start / 1000);
    }
    return createCuesFromArray(subs);
    function appendToSubs(lines, start) {
        let i = lines.length;
        let m;
        while (--i >= 0) {
            m = PARAG.exec(lines[i]);
            if (m === null) {
                continue;
            }
            const [, kl, txt] = m;
            if (klass !== kl) {
                continue;
            }
            if (txt === "&nbsp;") {
                subs[subs.length - 1].end = start;
            }
            else {
                subs.push({ text: decodeEntities(txt),
                    start: start + timeOffset });
            }
        }
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parseSami);


/***/ }),

/***/ 19533:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ getCueBlocks)
});

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
;// CONCATENATED MODULE: ./src/parsers/texttracks/srt/find_end_of_cue_block.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the first line that is not apart of the given cue block.
 * The index given can be anywhere in a known cue block.
 *
 * This function is extra-resilient due to observed real-life malformed
 * subtitles.
 * Basically, it allows some deviation from the specification as long as the
 * intent is pretty clear.
 * @param {Array<string>} linified - Whole srt. Line by line.
 * @param {number} startIndex - Index in `linified` of the first line within the
 * block.
 * @returns {number}
 */
function findEndOfCueBlock(linified, startIndex) {
    let firstEmptyLineIndex = startIndex + 1;
    // continue incrementing i until either:
    //   - an empty line
    //   - the end
    while ((0,is_non_empty_string/* default */.Z)(linified[firstEmptyLineIndex])) {
        firstEmptyLineIndex++;
    }
    return firstEmptyLineIndex;
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/srt/get_cue_blocks.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get cue blocks from a srt file.
 * @param {Array.<string>} linified - Whole srt file. Each new element in this
 * array is a new line.
 * @returns {Array.<Array.<string>>}
 */
function getCueBlocks(linified) {
    const cueBlocks = [];
    for (let i = 0; i < linified.length; i++) {
        if ((0,is_non_empty_string/* default */.Z)(linified[i])) {
            const endOfCue = findEndOfCueBlock(linified, i);
            const cueBlockCandidate = linified.slice(i, endOfCue);
            if (cueBlockCandidate.length > 0) {
                if (cueBlockCandidate.length === 1) {
                    if (cueBlockCandidate[0].indexOf("-->") >= 0) {
                        cueBlocks.push(cueBlockCandidate);
                    }
                }
                else {
                    if (cueBlockCandidate[1].indexOf("-->") >= 0 ||
                        cueBlockCandidate[0].indexOf("-->") >= 0) {
                        cueBlocks.push(cueBlockCandidate);
                    }
                }
            }
            i = endOfCue;
        }
    }
    return cueBlocks;
}


/***/ }),

/***/ 38090:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ parseSRTStringToHTML)
/* harmony export */ });
/* harmony import */ var _get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19533);
/* harmony import */ var _parse_cue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4536);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
// Parse SRT subtitles into HTML.
// Done for fun. Understand <b>, <i>, <u> and <font color="#ff0000" /> type
// of tags.


/**
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
function parseSRTStringToHTML(srtStr, timeOffset) {
    // Even if srt only authorize CRLF, we will also take LF or CR as line
    // terminators for resilience
    const lines = srtStr.split(/\r\n|\n|\r/);
    const cueBlocks = (0,_get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(lines);
    const cues = [];
    for (let i = 0; i < cueBlocks.length; i++) {
        const cueObject = (0,_parse_cue__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(cueBlocks[i], timeOffset);
        if (cueObject != null) {
            const htmlCue = toHTML(cueObject);
            if (htmlCue != null) {
                cues.push(htmlCue);
            }
        }
    }
    return cues;
}
/**
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object|null}
 */
function toHTML(cueObj) {
    const { start, end, payload } = cueObj;
    const pEl = document.createElement("div");
    pEl.className = "rxp-texttrack-p";
    pEl.style.fontSize = "28px";
    pEl.style.position = "absolute";
    pEl.style.bottom = "5%";
    pEl.style.width = "100%";
    pEl.style.textAlign = "center";
    pEl.style.color = "#fff";
    pEl.style.textShadow = "-1px -1px 2px #000," +
        "1px -1px 2px #000," +
        "-1px 1px 2px #000," +
        "1px 1px 2px #000";
    for (let i = 0; i < payload.length; i++) {
        if (i !== 0) {
            pEl.appendChild(document.createElement("br"));
        }
        const span = generateSpansFromSRTText(payload[i]);
        pEl.appendChild(span);
    }
    return {
        start,
        end,
        element: pEl,
    };
}
/**
 * Take a single srt line and convert it into a span with the right style while
 * avoiding XSS.
 * What we do is set a whitelist of authorized tags, and recreate the
 * corresponding tag from scratch.
 * Supported tags:
 *   - <b>: make content bold
 *   - <i>: make content italic
 *   - <u>: draw underline on content
 *   - <font color="x">: add color x to the content
 * @param {string} text
 * @returns {HTMLElement}
 */
function generateSpansFromSRTText(text) {
    const secureDiv = document.createElement("div");
    secureDiv.innerHTML = text;
    const _loop = function (node) {
        const childNodes = node.childNodes;
        const span = document.createElement("span");
        span.className = "rxp-texttrack-span";
        for (let i = 0; i < childNodes.length; i++) {
            const currentNode = childNodes[i];
            if (currentNode.nodeName === "#text") {
                const linifiedText = currentNode.wholeText
                    .split("\n");
                for (let line = 0; line < linifiedText.length; line++) {
                    if (line !== 0) {
                        span.appendChild(document.createElement("br"));
                    }
                    if (linifiedText[line].length > 0) {
                        const textNode = document.createTextNode(linifiedText[line]);
                        span.appendChild(textNode);
                    }
                }
            }
            else if (currentNode.nodeName === "B") {
                const spanChild = _loop(currentNode);
                spanChild.style.fontWeight = "bold";
                span.appendChild(spanChild);
            }
            else if (currentNode.nodeName === "I") {
                const spanChild = _loop(currentNode);
                spanChild.style.fontStyle = "italic";
                span.appendChild(spanChild);
            }
            else if (currentNode.nodeName === "U") {
                const spanChild = _loop(currentNode);
                spanChild.style.textDecoration = "underline";
                span.appendChild(spanChild);
            }
            else if (currentNode.nodeName === "FONT" &&
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                currentNode.color != null) {
                // TODO loop through attributes to find color?
                /* eslint-disable @typescript-eslint/no-unsafe-assignment */
                /* eslint-disable @typescript-eslint/no-unsafe-member-access */
                const spanChild = _loop(currentNode);
                spanChild.style.color = currentNode.color;
                /* eslint-enable @typescript-eslint/no-unsafe-assignment */
                /* eslint-enable @typescript-eslint/no-unsafe-member-access */
                span.appendChild(spanChild);
            }
            else {
                const spanChild = _loop(currentNode);
                span.appendChild(spanChild);
            }
        }
        return span;
    };
    return _loop(secureDiv);
}


/***/ }),

/***/ 29663:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ parseSRTStringToVTTCues)
/* harmony export */ });
/* harmony import */ var _compat_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11862);
/* harmony import */ var _get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19533);
/* harmony import */ var _parse_cue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4536);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */
// srt to VTTCue parser, Done for fun.
// Heavily inspired from the WebVTT implementation



/**
 * Parse whole srt file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} srtStr
 * @param {Number} timeOffset
 * @returns {Array.<VTTCue|TextTrackCue>}
 */
function parseSRTStringToVTTCues(srtStr, timeOffset) {
    // Even if srt only authorize CRLF, we will also take LF or CR as line
    // terminators for resilience
    const lines = srtStr.split(/\r\n|\n|\r/);
    const cueBlocks = (0,_get_cue_blocks__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(lines);
    const cues = [];
    for (let i = 0; i < cueBlocks.length; i++) {
        const cueObject = (0,_parse_cue__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(cueBlocks[i], timeOffset);
        if (cueObject !== null) {
            const nativeCue = toNativeCue(cueObject);
            if (nativeCue !== null) {
                cues.push(nativeCue);
            }
        }
    }
    return cues;
}
/**
 * @param {Object} cue Object
 * @returns {TextTrackCue|VTTCue|null}
 */
function toNativeCue(cueObj) {
    const { start, end, payload } = cueObj;
    const text = payload.join("\n");
    return (0,_compat_index__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z)(start, end, text);
}


/***/ }),

/***/ 4536:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ parseCueBlock)
});

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
;// CONCATENATED MODULE: ./src/parsers/texttracks/srt/parse_timestamp.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a single srt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */
function parseTimestamp(timestampString) {
    const splittedTS = timestampString.split(":");
    if ((0,is_non_empty_string/* default */.Z)(splittedTS[2])) {
        const hours = parseInt(splittedTS[0], 10);
        const minutes = parseInt(splittedTS[1], 10);
        const seconds = parseFloat(splittedTS[2].replace(",", "."));
        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
            return undefined;
        }
        return hours * 60 * 60 + minutes * 60 + seconds;
    }
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/srt/parse_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */
function parseCueBlock(cueLines, timeOffset) {
    if (cueLines.length === 0) {
        return null;
    }
    let startTimeString;
    let endTimeString;
    let payload = [];
    // normally in srt, the timing is at second position.
    // We still authorize to put it in the first position for resilience
    if ((0,is_non_empty_string/* default */.Z)(cueLines[1]) && cueLines[1].indexOf("-->") !== -1) {
        [startTimeString, endTimeString] = cueLines[1].split("-->")
            .map(s => s.trim());
        payload = cueLines.slice(2, cueLines.length);
    }
    if (!(0,is_non_empty_string/* default */.Z)(startTimeString) ||
        !(0,is_non_empty_string/* default */.Z)(endTimeString)) {
        // Try to see if we find them in the first position
        [startTimeString, endTimeString] = cueLines[0].split("-->")
            .map(s => s.trim());
        payload = cueLines.slice(1, cueLines.length);
    }
    if (!(0,is_non_empty_string/* default */.Z)(startTimeString) || !(0,is_non_empty_string/* default */.Z)(endTimeString)) {
        // if the time is still not found, exit
        return null;
    }
    const start = parseTimestamp(startTimeString);
    const end = parseTimestamp(endTimeString);
    if (start === undefined || end === undefined) {
        return null;
    }
    return { start: start + timeOffset,
        end: end + timeOffset,
        payload };
}


/***/ }),

/***/ 60908:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ getParentElementsByTagName)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns the parent elements which have the given tagName, by order of
 * closeness relative to our element.
 * @param {Element|Node} element
 * @param {string} tagName
 * @returns {Array.<Element>}
 */
function getParentElementsByTagName(element, tagName) {
    if (!(element.parentNode instanceof Element)) {
        return [];
    }
    function constructArray(_element) {
        const elements = [];
        if (_element.tagName.toLowerCase() === tagName.toLowerCase()) {
            elements.push(_element);
        }
        const parentNode = _element.parentNode;
        if (parentNode instanceof Element) {
            elements.push(...constructArray(parentNode));
        }
        return elements;
    }
    return constructArray(element.parentNode);
}


/***/ }),

/***/ 5083:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "U": () => (/* binding */ getStylingAttributes),
/* harmony export */   "b": () => (/* binding */ getStylingFromElement)
/* harmony export */ });
/* harmony import */ var _utils_array_find__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23437);
/* harmony import */ var _utils_array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54924);
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4938);
/* harmony import */ var _utils_starts_with__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27140);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Retrieve the attributes given in arguments in the given nodes and their
 * associated style(s)/region.
 * The first notion of the attribute encountered will be taken (by looping
 * through the given nodes in order).
 *
 * TODO manage IDREFS (plural) for styles and regions, that is, multiple one
 * @param {Array.<string>} attributes
 * @param {Array.<Node>} nodes
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @returns {Object}
 */
function getStylingAttributes(attributes, nodes, styles, regions) {
    const currentStyle = {};
    const leftAttributes = attributes.slice();
    for (let i = 0; i <= nodes.length - 1; i++) {
        const node = nodes[i];
        if (node !== undefined) {
            let styleID;
            let regionID;
            // 1. the style is directly set on a "tts:" attribute
            if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node;
                for (let j = 0; j <= element.attributes.length - 1; j++) {
                    const attribute = element.attributes[j];
                    const name = attribute.name;
                    if (name === "style") {
                        styleID = attribute.value;
                    }
                    else if (name === "region") {
                        regionID = attribute.value;
                    }
                    else {
                        const nameWithoutTTS = name.substring(4);
                        if ((0,_utils_array_includes__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(leftAttributes, nameWithoutTTS)) {
                            currentStyle[nameWithoutTTS] = attribute.value;
                            leftAttributes.splice(j, 1);
                            if (leftAttributes.length === 0) {
                                return currentStyle;
                            }
                        }
                    }
                }
            }
            // 2. the style is referenced on a "style" attribute
            if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(styleID)) {
                const style = (0,_utils_array_find__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z)(styles, (x) => x.id === styleID);
                if (style !== undefined) {
                    for (let j = 0; j <= leftAttributes.length - 1; j++) {
                        const attribute = leftAttributes[j];
                        if (!(0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(currentStyle[attribute])) {
                            if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(style.style[attribute])) {
                                currentStyle[attribute] = style.style[attribute];
                                leftAttributes.splice(j, 1);
                                if (leftAttributes.length === 0) {
                                    return currentStyle;
                                }
                                j--;
                            }
                        }
                    }
                }
            }
            // 3. the node reference a region (which can have a value for the
            //    corresponding style)
            if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(regionID)) {
                const region = (0,_utils_array_find__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z)(regions, (x) => x.id === regionID);
                if (region !== undefined) {
                    for (let j = 0; j <= leftAttributes.length - 1; j++) {
                        const attribute = leftAttributes[j];
                        if (!(0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(currentStyle[attribute])) {
                            if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(region.style[attribute])) {
                                currentStyle[attribute] = region.style[attribute];
                                leftAttributes.splice(j, 1);
                                if (leftAttributes.length === 0) {
                                    return currentStyle;
                                }
                                j--;
                            }
                        }
                    }
                }
            }
        }
    }
    return currentStyle;
}
/**
 * Returns the styling directly linked to an element.
 * @param {Node} node
 * @returns {Object}
 */
function getStylingFromElement(node) {
    if (node.nodeType !== Node.ELEMENT_NODE) {
        return {};
    }
    const element = node;
    const currentStyle = {};
    for (let i = 0; i <= element.attributes.length - 1; i++) {
        const styleAttribute = element.attributes[i];
        if ((0,_utils_starts_with__WEBPACK_IMPORTED_MODULE_3__/* .default */ .Z)(styleAttribute.name, "tts")) {
            const nameWithoutTTS = styleAttribute.name.substring(4);
            currentStyle[nameWithoutTTS] = styleAttribute.value;
        }
    }
    return currentStyle;
}


/***/ }),

/***/ 53454:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ getTimeDelimiters)
});

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
var regexps = __webpack_require__(49289);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/time_parsing.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parses a TTML time into seconds.
 * @param {string} text
 * @param {Object} ttParams
 * @returns {Number|undefined}
 */
function parseTime(text, ttParams) {
    if (regexps/* REGXP_TIME_COLON_FRAMES.test */.gu.test(text)) {
        return parseColonTimeWithFrames(ttParams, text);
    }
    else if (regexps/* REGXP_TIME_COLON.test */.KO.test(text)) {
        return parseTimeFromRegExp(regexps/* REGXP_TIME_COLON */.KO, text);
    }
    else if (regexps/* REGXP_TIME_COLON_MS.test */.wf.test(text)) {
        return parseTimeFromRegExp(regexps/* REGXP_TIME_COLON_MS */.wf, text);
    }
    else if (regexps/* REGXP_TIME_FRAMES.test */.jb.test(text)) {
        return parseFramesTime(ttParams, text);
    }
    else if (regexps/* REGXP_TIME_TICK.test */.Du.test(text)) {
        return parseTickTime(ttParams, text);
    }
    else if (regexps/* REGXP_TIME_HMS.test */.te.test(text)) {
        return parseTimeFromRegExp(regexps/* REGXP_TIME_HMS */.te, text);
    }
}
/**
 * Parses a TTML time in frame format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseFramesTime(ttParams, text) {
    // 75f or 75.5f
    // (We cast as we're sure the regexp is respected here)
    const results = regexps/* REGXP_TIME_FRAMES.exec */.jb.exec(text);
    const frames = Number(results[1]);
    return frames / ttParams.frameRate;
}
/**
 * Parses a TTML time in tick format
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseTickTime(ttParams, text) {
    // 50t or 50.5t
    // (We cast as we're sure the regexp is respected here)
    const results = regexps/* REGXP_TIME_TICK.exec */.Du.exec(text);
    const ticks = Number(results[1]);
    return ticks / ttParams.tickRate;
}
/**
 * Parses a TTML colon formatted time containing frames
 * @param {Object} ttParams
 * @param {string} text
 * @returns {Number}
 */
function parseColonTimeWithFrames(ttParams, text) {
    // 01:02:43:07 ("07" is frames) or 01:02:43:07.1 (subframes)
    // (We cast as we're sure the regexp is respected here)
    const results = regexps/* REGXP_TIME_COLON_FRAMES.exec */.gu.exec(text);
    const hours = Number(results[1]);
    const minutes = Number(results[2]);
    let seconds = Number(results[3]);
    let frames = Number(results[4]);
    let subframes = Number(results[5]);
    if (isNaN(subframes)) {
        subframes = 0;
    }
    frames += subframes / ttParams.subFrameRate;
    seconds += frames / ttParams.frameRate;
    return seconds + (minutes * 60) + (hours * 3600);
}
/**
 * Parses a TTML time with a given regex. Expects regex to be some
 * sort of a time-matcher to match hours, minutes, seconds and milliseconds
 *
 * @param {RegExp} regex
 * @param {string} text
 * @returns {number|null}
 */
function parseTimeFromRegExp(regex, text) {
    const results = regex.exec(text);
    if (results === null || results[0] === "") {
        return null;
    }
    // This capture is optional, but will still be in the array as undefined,
    // default to 0.
    let hours = Number(results[1]);
    if (isNaN(hours)) {
        hours = 0;
    }
    let minutes = Number(results[2]);
    if (isNaN(minutes)) {
        minutes = 0;
    }
    let seconds = Number(results[3]);
    if (isNaN(seconds)) {
        seconds = 0;
    }
    let milliseconds = Number(results[4]);
    if (isNaN(milliseconds)) {
        milliseconds = 0;
    }
    return (milliseconds / 1000) + seconds + (minutes * 60) + (hours * 3600);
}
/* harmony default export */ const time_parsing = (parseTime);

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get start and end time of an element.
 * @param {Element} element
 * @param {Object} ttParams
 * @returns {Object}
 */
function getTimeDelimiters(element, ttParams) {
    const beginAttr = element.getAttribute("begin");
    const durationAttr = element.getAttribute("dur");
    const endAttr = element.getAttribute("end");
    const start = (0,is_non_empty_string/* default */.Z)(beginAttr) ? time_parsing(beginAttr, ttParams) :
        null;
    const duration = (0,is_non_empty_string/* default */.Z)(durationAttr) ? time_parsing(durationAttr, ttParams) :
        null;
    const parsedEnd = (0,is_non_empty_string/* default */.Z)(endAttr) ? time_parsing(endAttr, ttParams) :
        null;
    if (start == null || (parsedEnd == null && duration == null)) {
        throw new Error("Invalid text cue");
    }
    // Huh? Is TypeScript that dumb here?
    const end = parsedEnd == null ? start + duration :
        parsedEnd;
    return { start, end };
}


/***/ }),

/***/ 4330:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ html)
});

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/parse_ttml.ts + 3 modules
var parse_ttml = __webpack_require__(91366);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_default_ttml_paragraph_style.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Return true if no style has been already declared and no conflict is
 * detected with current cue style.
 *
 * No position, orientation and dimension style should have been set to
 * avoid any conflict.
 * @param {object} paragraphStyle
 * @returns {boolean}
 */
function shouldApplyDefaultTTMLStyle(paragraphStyle) {
    return paragraphStyle.extent === undefined &&
        paragraphStyle.origin === undefined &&
        paragraphStyle.displayAlign === undefined &&
        paragraphStyle.display === undefined &&
        paragraphStyle.textAlign === undefined &&
        paragraphStyle.fontSize === undefined;
}
/**
 * Apply a default style to TTML cue.
 *
 * The default style propose to set the cue at the bottom, centered
 * and lightly spaced apart from the edges :
 *
 *        -----------------------------------------------
 *        |                                             |
 *        |                                             |
 *        |                                             |
 *        |                                             |
 *        |                                             |
 *        |                                             |
 *        |            subtitle is displayed            |
 *        |                    here                     |
 *        -----------------------------------------------
 *
 * @param {Object} cue
 * TODO This code can be seen as risky because we might not predict every
 * possible styles that can enter in conflict.
 * A better solution should be found in the future
 */
function applyDefaultTTMLStyle(paragraphStyle) {
    paragraphStyle.extent = "70% 20%";
    paragraphStyle.fontSize = "1c";
    paragraphStyle.origin = "15% 80%";
    paragraphStyle.displayAlign = "before";
    paragraphStyle.textAlign = "center";
}

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts + 1 modules
var get_time_delimiters = __webpack_require__(53454);
;// CONCATENATED MODULE: ./src/compat/add_class_name.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let hasClassList;
/**
 * Add className to an HTMLElement. Do nothing if the className was already
 * added.
 * @param {HTMLElement} elt
 * @param {string} className
 */
function addClassName(elt, className) {
    if (hasClassList === undefined) {
        hasClassList = elt.classList !== undefined &&
            /* eslint-disable @typescript-eslint/unbound-method */
            typeof elt.classList.add === "function";
        /* eslint-enable @typescript-eslint/unbound-method */
    }
    if (hasClassList) {
        elt.classList.add(className);
    }
    else {
        const classNamesWithSpaces = " " + elt.className + " ";
        if (classNamesWithSpaces.indexOf(" " + className + " ") < 0) {
            elt.className += " " + className;
        }
    }
}

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(53811);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_parent_elements_by_tag_name.ts
var get_parent_elements_by_tag_name = __webpack_require__(60908);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_styling.ts
var get_styling = __webpack_require__(5083);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
var regexps = __webpack_require__(49289);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_extent.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Apply `tts:extent` styling to an HTML element.
 * @param {HTMLElement} element
 * @param {string} extent
 */
function applyExtent(element, extent) {
    const trimmedExtent = extent.trim();
    if (trimmedExtent === "auto") {
        return;
    }
    const splittedExtent = trimmedExtent.split(" ");
    if (splittedExtent.length !== 2) {
        return;
    }
    const firstExtent = regexps/* REGXP_LENGTH.exec */.eT.exec(splittedExtent[0]);
    const secondExtent = regexps/* REGXP_LENGTH.exec */.eT.exec(splittedExtent[1]);
    if (firstExtent !== null && secondExtent !== null) {
        if (firstExtent[2] === "px" ||
            firstExtent[2] === "%" ||
            firstExtent[2] === "em") {
            element.style.width = firstExtent[1] + firstExtent[2];
        }
        else if (firstExtent[2] === "c") {
            addClassName(element, "proportional-style");
            element.setAttribute("data-proportional-width", firstExtent[1]);
        }
        else {
            log/* default.warn */.Z.warn("TTML Parser: unhandled extent unit:", firstExtent[2]);
        }
        if (secondExtent[2] === "px" ||
            secondExtent[2] === "%" ||
            secondExtent[2] === "em") {
            element.style.height = secondExtent[1] + secondExtent[2];
        }
        else if (secondExtent[2] === "c") {
            addClassName(element, "proportional-style");
            element.setAttribute("data-proportional-height", secondExtent[1]);
        }
        else {
            log/* default.warn */.Z.warn("TTML Parser: unhandled extent unit:", secondExtent[2]);
        }
    }
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_font_size.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Apply `tts:fontSize` styling to an HTML element.
 * @param {HTMLElement} element
 * @param {string} fontSize
 */
function applyFontSize(element, fontSize) {
    const trimmedFontSize = fontSize.trim();
    const splittedFontSize = trimmedFontSize.split(" ");
    if (splittedFontSize.length === 0) {
        return;
    }
    const firstFontSize = regexps/* REGXP_LENGTH.exec */.eT.exec(splittedFontSize[0]);
    if (firstFontSize === null) {
        return;
    }
    if (firstFontSize[2] === "px" ||
        firstFontSize[2] === "%" ||
        firstFontSize[2] === "em") {
        element.style.fontSize = firstFontSize[1] + firstFontSize[2];
    }
    else if (firstFontSize[2] === "c") {
        element.style.position = "relative";
        addClassName(element, "proportional-style");
        element.setAttribute("data-proportional-font-size", firstFontSize[1]);
    }
    else {
        log/* default.warn */.Z.warn("TTML Parser: unhandled fontSize unit:", firstFontSize[2]);
    }
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_line_height.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLElement} element
 * @param {string} lineHeight
 */
function applyLineHeight(element, lineHeight) {
    const trimmedLineHeight = lineHeight.trim();
    if (trimmedLineHeight === "auto") {
        return;
    }
    const firstLineHeight = regexps/* REGXP_LENGTH.exec */.eT.exec(trimmedLineHeight[0]);
    if (firstLineHeight === null) {
        return;
    }
    if (firstLineHeight[2] === "px" ||
        firstLineHeight[2] === "%" ||
        firstLineHeight[2] === "em") {
        element.style.lineHeight = firstLineHeight[1] + firstLineHeight[2];
    }
    else if (firstLineHeight[2] === "c") {
        addClassName(element, "proportional-style");
        element.setAttribute("data-proportional-line-height", firstLineHeight[1]);
    }
    else {
        log/* default.warn */.Z.warn("TTML Parser: unhandled lineHeight unit:", firstLineHeight[2]);
    }
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_origin.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLElement} element
 * @param {string} origin
 */
function applyOrigin(element, origin) {
    const trimmedOrigin = origin.trim();
    if (trimmedOrigin === "auto") {
        return;
    }
    const splittedOrigin = trimmedOrigin.split(" ");
    if (splittedOrigin.length !== 2) {
        return;
    }
    const firstOrigin = regexps/* REGXP_LENGTH.exec */.eT.exec(splittedOrigin[0]);
    const secondOrigin = regexps/* REGXP_LENGTH.exec */.eT.exec(splittedOrigin[1]);
    if (firstOrigin !== null && secondOrigin !== null) {
        if (firstOrigin[2] === "px" ||
            firstOrigin[2] === "%" ||
            firstOrigin[2] === "em") {
            element.style.left = firstOrigin[1] + firstOrigin[2];
        }
        else if (firstOrigin[2] === "c") {
            addClassName(element, "proportional-style");
            element.setAttribute("data-proportional-left", firstOrigin[1]);
        }
        else {
            log/* default.warn */.Z.warn("TTML Parser: unhandled origin unit:", firstOrigin[2]);
        }
        if (secondOrigin[2] === "px" ||
            secondOrigin[2] === "%" ||
            secondOrigin[2] === "em") {
            element.style.top = secondOrigin[1] + secondOrigin[2];
        }
        else if (secondOrigin[2] === "c") {
            addClassName(element, "proportional-style");
            element.setAttribute("data-proportional-top", secondOrigin[1]);
        }
        else {
            log/* default.warn */.Z.warn("TTML Parser: unhandled origin unit:", secondOrigin[2]);
        }
    }
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/apply_padding.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {HTMLElement} element
 * @param {string} padding
 */
function applyPadding(element, padding) {
    const trimmedPadding = padding.trim();
    const splittedPadding = trimmedPadding.split(" ");
    if (splittedPadding.length < 1) {
        return;
    }
    const firstPadding = regexps/* REGXP_LENGTH.exec */.eT.exec(splittedPadding[0]);
    if (firstPadding === null) {
        return;
    }
    if (firstPadding[2] === "px" ||
        firstPadding[2] === "%" ||
        firstPadding[2] === "em") {
        const firstPaddingValue = firstPadding[1] + firstPadding[2];
        if (splittedPadding.length === 1) {
            element.style.padding = firstPaddingValue;
        }
        else if (splittedPadding.length === 2) {
            element.style.paddingTop = firstPaddingValue;
            element.style.paddingBottom = firstPaddingValue;
        }
        else {
            element.style.paddingTop = firstPaddingValue;
        }
    }
    else if (firstPadding[2] === "c") {
        addClassName(element, "proportional-style");
        if (splittedPadding.length === 1) {
            element.setAttribute("data-proportional-padding-top", firstPadding[1]);
            element.setAttribute("data-proportional-padding-bottom", firstPadding[1]);
            element.setAttribute("data-proportional-padding-left", firstPadding[1]);
            element.setAttribute("data-proportional-padding-right", firstPadding[1]);
        }
        else if (splittedPadding.length === 2) {
            element.setAttribute("data-proportional-padding-top", firstPadding[1]);
            element.setAttribute("data-proportional-padding-bottom", firstPadding[1]);
        }
        else {
            element.setAttribute("data-proportional-padding-top", firstPadding[1]);
        }
    }
    else {
        log/* default.warn */.Z.warn("TTML Parser: unhandled padding unit:", firstPadding[2]);
    }
    if (splittedPadding.length === 1) {
        return;
    }
    const secondPadding = regexps/* REGXP_LENGTH.exec */.eT.exec(splittedPadding[1]);
    if (secondPadding === null) {
        return;
    }
    if (secondPadding[2] === "px" ||
        secondPadding[2] === "%" ||
        secondPadding[2] === "em") {
        const secondPaddingValue = secondPadding[1] + secondPadding[2];
        if (splittedPadding.length < 4) {
            element.style.paddingLeft = secondPaddingValue;
            element.style.paddingRight = secondPaddingValue;
        }
        else {
            element.style.paddingRight = secondPaddingValue;
        }
    }
    else if (secondPadding[2] === "c") {
        addClassName(element, "proportional-style");
        if (splittedPadding.length < 4) {
            element.setAttribute("data-proportional-padding-left", secondPadding[1]);
            element.setAttribute("data-proportional-padding-right", secondPadding[1]);
        }
        else {
            element.setAttribute("data-proportional-padding-right", secondPadding[1]);
        }
    }
    else {
        log/* default.warn */.Z.warn("TTML Parser: unhandled padding unit:", secondPadding[2]);
    }
    if (splittedPadding.length === 2) {
        return;
    }
    const thirdPadding = regexps/* REGXP_LENGTH.exec */.eT.exec(splittedPadding[2]);
    if (thirdPadding === null) {
        return;
    }
    if (thirdPadding[2] === "px" ||
        thirdPadding[2] === "%" ||
        thirdPadding[2] === "em") {
        const thirdPaddingValue = thirdPadding[1] + thirdPadding[2];
        element.style.paddingBottom = thirdPaddingValue;
    }
    else if (thirdPadding[2] === "c") {
        addClassName(element, "proportional-style");
        element.setAttribute("data-proportional-padding-bottom", thirdPadding[1]);
    }
    else {
        log/* default.warn */.Z.warn("TTML Parser: unhandled padding unit:", thirdPadding[2]);
    }
    if (splittedPadding.length === 3) {
        return;
    }
    const fourthPadding = regexps/* REGXP_LENGTH.exec */.eT.exec(splittedPadding[3]);
    if (fourthPadding === null) {
        return;
    }
    if (fourthPadding[2] === "px" ||
        fourthPadding[2] === "%" ||
        fourthPadding[2] === "em") {
        const fourthPaddingValue = fourthPadding[1] + fourthPadding[2];
        element.style.paddingLeft = fourthPaddingValue;
    }
    else if (fourthPadding[2] === "c") {
        addClassName(element, "proportional-style");
        element.setAttribute("data-proportional-padding-left", fourthPadding[1]);
    }
    else {
        log/* default.warn */.Z.warn("TTML Parser: unhandled padding unit:", fourthPadding[2]);
    }
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/generate_css_test_outline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Try to replicate the textOutline TTML style property into CSS.
 *
 * We mock it throught the text-shadow property, translating the TTML thickness
 * into blur radius and the blur-radius into... nothing.
 *
 * @param {string} color
 * @param {string|number} thickness
 * @returns {string}
 */
function generateCSSTextOutline(color, thickness) {
    return `-1px -1px ${thickness} ${color},` +
        `1px -1px ${thickness} ${color},` +
        `-1px 1px ${thickness} ${color},` +
        `1px 1px ${thickness} ${color}`;
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/ttml_color_to_css_color.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Translate a color indicated in TTML-style to a CSS-style color.
 * @param {string} color
 * @returns {string} color
 */
function ttmlColorToCSSColor(color) {
    // TODO check all possible color fomats
    let regRes;
    regRes = regexps/* REGXP_8_HEX_COLOR.exec */.Dq.exec(color);
    if (regRes != null) {
        return "rgba(" +
            String(parseInt(regRes[1], 16)) + "," +
            String(parseInt(regRes[2], 16)) + "," +
            String(parseInt(regRes[3], 16)) + "," +
            String(parseInt(regRes[4], 16) / 255) + ")";
    }
    regRes = regexps/* REGXP_4_HEX_COLOR.exec */.YU.exec(color);
    if (regRes != null) {
        return "rgba(" +
            String(parseInt(regRes[1] + regRes[1], 16)) + "," +
            String(parseInt(regRes[2] + regRes[2], 16)) + "," +
            String(parseInt(regRes[3] + regRes[3], 16)) + "," +
            String(parseInt(regRes[4] + regRes[4], 16) / 255) + ")";
    }
    regRes = regexps/* REGXP_RGB_COLOR.exec */.GK.exec(color);
    if (regRes != null) {
        return "rgb(" +
            String(+regRes[1]) + "," +
            String(+regRes[2]) + "," +
            String(+regRes[3]) + ")";
    }
    regRes = regexps/* REGXP_RGBA_COLOR.exec */.ev.exec(color);
    if (regRes != null) {
        return "rgba(" +
            String(+regRes[1]) + "," +
            String(+regRes[2]) + "," +
            String(+regRes[3]) + "," +
            String(+regRes[4] / 255) + ")";
    }
    return color;
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/create_element.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












// Styling which can be applied to <span> from any level upper.
// Added here as an optimization
const SPAN_LEVEL_ATTRIBUTES = ["color",
    "direction",
    "display",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "textDecoration",
    "textOutline",
    "unicodeBidi",
    "visibility",
    "wrapOption"];
// TODO
// tts:showBackground (applies to region)
// tts:zIndex (applies to region)
/**
 * Apply style set for a singular text span of the current cue.
 * @param {HTMLElement} element - The text span
 * @param {Object} style - The style to apply
 */
function applyTextStyle(element, style, shouldTrimWhiteSpace) {
    // applies to span
    const color = style.color;
    if ((0,is_non_empty_string/* default */.Z)(color)) {
        element.style.color = ttmlColorToCSSColor(color);
    }
    // applies to body, div, p, region, span
    const backgroundColor = style.backgroundColor;
    if ((0,is_non_empty_string/* default */.Z)(backgroundColor)) {
        element.style.backgroundColor = ttmlColorToCSSColor(backgroundColor);
    }
    // applies to span
    const textOutline = style.textOutline;
    if ((0,is_non_empty_string/* default */.Z)(textOutline)) {
        const outlineData = textOutline
            .trim()
            .replace(/\s+/g, " ")
            .split(" ");
        const len = outlineData.length;
        if (len === 3) {
            const outlineColor = ttmlColorToCSSColor(outlineData[0]);
            const thickness = outlineData[1];
            element.style.textShadow =
                generateCSSTextOutline(outlineColor, thickness);
        }
        else if ((0,is_non_empty_string/* default */.Z)(color) && len === 1) {
            const thickness = outlineData[0];
            element.style.textShadow = generateCSSTextOutline(color, thickness);
        }
        else if (len === 2) {
            const isFirstArgAColor = /^[#A-Z]/i.test(outlineData[0]);
            const isFirstArgANumber = /^[0-9]/.test(outlineData[0]);
            // XOR-ing to be sure we get what we have
            if (isFirstArgAColor !== isFirstArgANumber) {
                if (isFirstArgAColor) {
                    const outlineColor = ttmlColorToCSSColor(outlineData[0]);
                    const thickness = outlineData[1];
                    element.style.textShadow = generateCSSTextOutline(outlineColor, thickness);
                }
                else if ((0,is_non_empty_string/* default */.Z)(color)) {
                    const thickness = outlineData[0];
                    element.style.textShadow = generateCSSTextOutline(color, thickness);
                }
            }
        }
    }
    // applies to span
    const textDecoration = style.textDecoration;
    if ((0,is_non_empty_string/* default */.Z)(textDecoration)) {
        switch (textDecoration) {
            case "noUnderline":
            case "noLineThrough":
            case "noOverline":
                element.style.textDecoration = "none";
                break;
            case "lineThrough":
                element.style.textDecoration = "line-through";
                break;
            default:
                element.style.textDecoration = textDecoration;
                break;
        }
    }
    // applies to span
    const fontFamily = style.fontFamily;
    if ((0,is_non_empty_string/* default */.Z)(fontFamily)) {
        switch (fontFamily) {
            case "proportionalSansSerif":
                element.style.fontFamily =
                    "Arial, Helvetica, Liberation Sans, sans-serif";
                break;
            // TODO monospace or sans-serif or font with both?
            case "monospaceSansSerif":
            case "sansSerif":
                element.style.fontFamily = "sans-serif";
                break;
            case "monospaceSerif":
            case "default":
                element.style.fontFamily = "Courier New, Liberation Mono, monospace";
                break;
            // TODO font with both?
            case "proportionalSerif":
                element.style.fontFamily = "serif";
                break;
            default:
                element.style.fontFamily = fontFamily;
        }
    }
    // applies to span
    const fontStyle = style.fontStyle;
    if ((0,is_non_empty_string/* default */.Z)(fontStyle)) {
        element.style.fontStyle = fontStyle;
    }
    // applies to span
    const fontWeight = style.fontWeight;
    if ((0,is_non_empty_string/* default */.Z)(fontWeight)) {
        element.style.fontWeight = fontWeight;
    }
    // applies to span
    const fontSize = style.fontSize;
    if ((0,is_non_empty_string/* default */.Z)(fontSize)) {
        applyFontSize(element, fontSize);
    }
    else {
        addClassName(element, "proportional-style");
        element.setAttribute("data-proportional-font-size", "1");
    }
    // applies to p, span
    const direction = style.direction;
    if ((0,is_non_empty_string/* default */.Z)(direction)) {
        element.style.direction = direction;
    }
    // applies to p, span
    const unicodeBidi = style.unicodeBidi;
    if ((0,is_non_empty_string/* default */.Z)(unicodeBidi)) {
        switch (unicodeBidi) {
            case "bidiOverride":
                element.style.unicodeBidi = "bidi-override";
                break;
            case "embed":
                element.style.unicodeBidi = "embed";
                break;
            default:
                element.style.unicodeBidi = "normal";
        }
    }
    // applies to body, div, p, region, span
    const visibility = style.visibility;
    if ((0,is_non_empty_string/* default */.Z)(visibility)) {
        element.style.visibility = visibility;
    }
    // applies to body, div, p, region, span
    const display = style.display;
    if (display === "none") {
        element.style.display = "none";
    }
    // applies to body, div, p, region, span
    const wrapOption = style.wrapOption;
    element.style.whiteSpace = wrapOption === "noWrap" ?
        (shouldTrimWhiteSpace ? "nowrap" : "pre") :
        (shouldTrimWhiteSpace ? "normal" : "pre-wrap");
}
/**
 * Apply style for the general text track div.
 * @param {HTMLElement} element - The <div> the style will be applied on.
 * @param {Object} style - The general style object of the paragraph.
 */
function applyGeneralStyle(element, style) {
    // Set default text color. It can be overrided by text element color.
    element.style.color = "white";
    element.style.position = "absolute";
    // applies to tt, region
    const extent = style.extent;
    if ((0,is_non_empty_string/* default */.Z)(extent)) {
        applyExtent(element, extent);
    }
    // applies to region
    const writingMode = style.writingMode;
    if ((0,is_non_empty_string/* default */.Z)(writingMode)) {
        // TODO
    }
    // applies to region
    const overflow = style.overflow;
    element.style.overflow = (0,is_non_empty_string/* default */.Z)(overflow) ? overflow :
        "hidden";
    // applies to region
    const padding = style.padding;
    if ((0,is_non_empty_string/* default */.Z)(padding)) {
        applyPadding(element, padding);
    }
    // applies to region
    const origin = style.origin;
    if ((0,is_non_empty_string/* default */.Z)(origin)) {
        applyOrigin(element, origin);
    }
    // applies to region
    const displayAlign = style.displayAlign;
    if ((0,is_non_empty_string/* default */.Z)(displayAlign)) {
        element.style.display = "flex";
        element.style.flexDirection = "column";
        switch (displayAlign) {
            case "before":
                element.style.justifyContent = "flex-start";
                break;
            case "center":
                element.style.justifyContent = "center";
                break;
            case "after":
                element.style.justifyContent = "flex-end";
                break;
        }
    }
    // applies to region
    const opacity = style.opacity;
    if ((0,is_non_empty_string/* default */.Z)(opacity)) {
        element.style.opacity = opacity;
    }
    // applies to body, div, p, region, span
    const visibility = style.visibility;
    if ((0,is_non_empty_string/* default */.Z)(visibility)) {
        element.style.visibility = visibility;
    }
    // applies to body, div, p, region, span
    const display = style.display;
    if (display === "none") {
        element.style.display = "none";
    }
}
/**
 * Apply style set for a <p> element
 * @param {HTMLElement} element - The <p> element
 * @param {Object} style - The general style object of the paragraph.
 */
function applyPStyle(element, style) {
    element.style.margin = "0px";
    // applies to body, div, p, region, span
    const paragraphBackgroundColor = style.backgroundColor;
    if ((0,is_non_empty_string/* default */.Z)(paragraphBackgroundColor)) {
        element.style.backgroundColor = ttmlColorToCSSColor(paragraphBackgroundColor);
    }
    // applies to p
    const lineHeight = style.lineHeight;
    if ((0,is_non_empty_string/* default */.Z)(lineHeight)) {
        applyLineHeight(element, lineHeight);
    }
    // applies to p
    const textAlign = style.textAlign;
    if ((0,is_non_empty_string/* default */.Z)(textAlign)) {
        switch (textAlign) {
            case "center":
                element.style.textAlign = "center";
                break;
            case "left":
            case "start":
                // TODO check what start means (difference with left, writing direction?)
                element.style.textAlign = "left";
                break;
            case "right":
            case "end":
                // TODO check what end means (difference with right, writing direction?)
                element.style.textAlign = "right";
                break;
        }
    }
}
/**
 * Creates span of text for the given #text element, with the right style.
 *
 * TODO create text elements as string? Might help performances.
 * @param {Element} el - the #text element, which text content should be
 * displayed
 * @param {Object} style - the style object for the given text
 * @param {Boolean} shouldTrimWhiteSpace - True if the space should be
 * trimmed.
 * @returns {HTMLElement}
 */
function createTextElement(el, style, shouldTrimWhiteSpace) {
    const textElement = document.createElement("span");
    let textContent = el.textContent === null ? "" :
        el.textContent;
    if (shouldTrimWhiteSpace) {
        // 1. Trim leading and trailing whitespace.
        // 2. Collapse multiple spaces into one.
        let trimmed = textContent.trim();
        trimmed = trimmed.replace(/\s+/g, " ");
        textContent = trimmed;
    }
    textElement.innerHTML = textContent;
    textElement.className = "rxp-texttrack-span";
    applyTextStyle(textElement, style, shouldTrimWhiteSpace);
    return textElement;
}
/**
 * Generate every text elements to display in a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle - The general style object of the paragraph.
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {Array.<HTMLElement>}
 */
function generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace) {
    /**
     * Recursive function, taking a node in argument and returning the
     * corresponding array of HTMLElement in order.
     * @param {Node} node - the node in question
     * @param {Object} style - the current state of the style for the node.
     * /!\ The style object can be mutated, provide a copy of it.
     * @param {Array.<Element>} spans - The spans parent of this node.
     * @param {Boolean} shouldTrimWhiteSpaceFromParent - True if the space should be
     * trimmed by default. From the parent xml:space parameter.
     * @returns {Array.<HTMLElement>}
     */
    function loop(node, style, spans, shouldTrimWhiteSpaceFromParent) {
        const childNodes = node.childNodes;
        const elements = [];
        for (let i = 0; i < childNodes.length; i++) {
            const currentNode = childNodes[i];
            if (currentNode.nodeName === "#text") {
                const { backgroundColor } = (0,get_styling/* getStylingAttributes */.U)(["backgroundColor"], spans, styles, regions);
                if ((0,is_non_empty_string/* default */.Z)(backgroundColor)) {
                    style.backgroundColor = backgroundColor;
                }
                else {
                    delete style.backgroundColor;
                }
                const el = createTextElement(currentNode, style, shouldTrimWhiteSpaceFromParent);
                elements.push(el);
            }
            else if (currentNode.nodeName === "br") {
                const br = document.createElement("BR");
                elements.push(br);
            }
            else if (currentNode.nodeName === "span" &&
                currentNode.nodeType === Node.ELEMENT_NODE &&
                currentNode.childNodes.length > 0) {
                const spaceAttribute = currentNode.getAttribute("xml:space");
                const shouldTrimWhiteSpaceOnSpan = (0,is_non_empty_string/* default */.Z)(spaceAttribute) ? spaceAttribute === "default" :
                    shouldTrimWhiteSpaceFromParent;
                // compute the new applyable style
                const newStyle = (0,object_assign/* default */.Z)({}, style, (0,get_styling/* getStylingAttributes */.U)(SPAN_LEVEL_ATTRIBUTES, [currentNode], styles, regions));
                elements.push(...loop(currentNode, newStyle, [currentNode, ...spans], shouldTrimWhiteSpaceOnSpan));
            }
        }
        return elements;
    }
    return loop(paragraph, (0,object_assign/* default */.Z)({}, paragraphStyle), [], shouldTrimWhiteSpace);
}
/**
 * @param {Element} paragraph
 * @param {Element} body
 * @param {Array.<Object>} regions
 * @param {Array.<Object>} styles
 * @param {Object} paragraphStyle
 * @param {Object}
 * @returns {HTMLElement}
 */
function createElement(paragraph, body, regions, styles, paragraphStyle, { cellResolution, shouldTrimWhiteSpace }) {
    const divs = (0,get_parent_elements_by_tag_name/* default */.Z)(paragraph, "div");
    const parentElement = document.createElement("DIV");
    parentElement.className = "rxp-texttrack-region";
    parentElement.setAttribute("data-resolution-columns", String(cellResolution.columns));
    parentElement.setAttribute("data-resolution-rows", String(cellResolution.rows));
    applyGeneralStyle(parentElement, paragraphStyle);
    if (body !== null) {
        // applies to body, div, p, region, span
        const { bodyBackgroundColor } = (0,get_styling/* getStylingAttributes */.U)(["backgroundColor"], [...divs, body], styles, regions);
        if ((0,is_non_empty_string/* default */.Z)(bodyBackgroundColor)) {
            parentElement.style.backgroundColor = ttmlColorToCSSColor(bodyBackgroundColor);
        }
    }
    const pElement = document.createElement("p");
    pElement.className = "rxp-texttrack-p";
    applyPStyle(pElement, paragraphStyle);
    const textContent = generateTextContent(paragraph, regions, styles, paragraphStyle, shouldTrimWhiteSpace);
    for (let i = 0; i < textContent.length; i++) {
        pElement.appendChild(textContent[i]);
    }
    // NOTE:
    // The following code is for the inclusion of div elements. This has no
    // advantage for now, and might only with future evolutions.
    // (This is only an indication of what the base of the code could look like).
    // if (divs.length) {
    //   let container = parentElement;
    //   for (let i = divs.length - 1; i >= 0; i--) {
    //     // TODO manage style at div level?
    //     // They are: visibility, display and backgroundColor
    //     // All these do not have any difference if applied to the <p> element
    //     // instead of the div.
    //     // The advantage might only be for multiple <p> elements dispatched
    //     // in multiple div Which we do not manage anyway for now.
    //     const divEl = document.createElement("DIV");
    //     divEl.className = "rxp-texttrack-div";
    //     container.appendChild(divEl);
    //     container = divEl;
    //   }
    //   container.appendChild(pElement);
    //   parentElement.appendChild(container);
    // } else {
    //   parentElement.appendChild(pElement);
    // }
    parentElement.appendChild(pElement);
    return parentElement;
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parse_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} parsedCue
 * @returns {Object|null}
 */
function parseCue(parsedCue) {
    const { paragraph, ttParams, body, regionStyles, idStyles, paragraphStyle, timeOffset, shouldTrimWhiteSpace, } = parsedCue;
    // Disregard empty elements:
    // TTML allows for empty elements like <div></div>.
    // If paragraph has neither time attributes, nor
    // non-whitespace text, don't try to make a cue out of it.
    if (!paragraph.hasAttribute("begin") &&
        !paragraph.hasAttribute("end") &&
        /^\s*$/.test(paragraph.textContent === null ? "" : paragraph.textContent)) {
        return null;
    }
    const { cellResolution } = ttParams;
    const { start, end } = (0,get_time_delimiters/* default */.Z)(paragraph, ttParams);
    const element = createElement(paragraph, body, regionStyles, idStyles, paragraphStyle, { cellResolution, shouldTrimWhiteSpace });
    return { start: start + timeOffset,
        end: end + timeOffset,
        element };
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/parse_ttml_to_div.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Create array of objects which should represent the given TTML text track.
 * These objects have the following structure
 *   - start {Number}: start time, in seconds, at which the cue should
 *     be displayed
 *   - end {Number}: end time, in seconds, at which the cue should
 *     be displayed
 *   - element {HTMLElement}: <div> element representing the cue, with the
 *     right style. This div should then be appended to an element having
 *     the exact size of the wanted region the text track provide cues for.
 *
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @param {number} timeOffset
 */
function parseTTMLToDiv(str, timeOffset) {
    const parsedCues = (0,parse_ttml/* default */.Z)(str, timeOffset);
    const cues = [];
    for (let i = 0; i < parsedCues.length; i++) {
        const { paragraphStyle } = parsedCues[i];
        if (shouldApplyDefaultTTMLStyle(paragraphStyle)) {
            applyDefaultTTMLStyle(paragraphStyle);
        }
        const cue = parseCue(parsedCues[i]);
        if (cue !== null) {
            cues.push(cue);
        }
    }
    return cues;
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/html/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ const html = (parseTTMLToDiv);


/***/ }),

/***/ 84944:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ ttml_native)
});

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/parse_ttml.ts + 3 modules
var parse_ttml = __webpack_require__(91366);
// EXTERNAL MODULE: ./src/compat/make_vtt_cue.ts
var make_vtt_cue = __webpack_require__(11862);
// EXTERNAL MODULE: ./src/compat/is_vtt_cue.ts
var is_vtt_cue = __webpack_require__(56003);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_time_delimiters.ts + 1 modules
var get_time_delimiters = __webpack_require__(53454);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/regexps.ts
var regexps = __webpack_require__(49289);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/native/parse_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




const TEXT_ALIGN_TO_LIGN_ALIGN = {
    left: "start",
    center: "center",
    right: "end",
    start: "start",
    end: "end",
};
/**
 * @type {Object}
 */
const TEXT_ALIGN_TO_POSITION_ALIGN = {
    left: "line-left",
    center: "center",
    right: "line-right",
};
/**
 * Parses an Element into a TextTrackCue or VTTCue.
 * /!\ Mutates the given cueElement Element
 * @param {Element} paragraph
 * @param {Number} offset
 * @param {Array.<Object>} styles
 * @param {Array.<Object>} regions
 * @param {Object} paragraphStyle
 * @param {Object} ttParams
 * @param {Boolean} shouldTrimWhiteSpace
 * @returns {TextTrackCue|null}
 */
function parseCue(parsedCue) {
    const { paragraph, timeOffset, paragraphStyle, ttParams, shouldTrimWhiteSpace, } = parsedCue;
    // Disregard empty elements:
    // TTML allows for empty elements like <div></div>.
    // If paragraph has neither time attributes, nor
    // non-whitespace text, don't try to make a cue out of it.
    if (!paragraph.hasAttribute("begin") && !paragraph.hasAttribute("end") &&
        /^\s*$/.test(paragraph.textContent === null ? "" : paragraph.textContent)) {
        return null;
    }
    const { start, end } = (0,get_time_delimiters/* default */.Z)(paragraph, ttParams);
    const text = generateTextContent(paragraph, shouldTrimWhiteSpace);
    const cue = (0,make_vtt_cue/* default */.Z)(start + timeOffset, end + timeOffset, text);
    if (cue === null) {
        return null;
    }
    if ((0,is_vtt_cue/* default */.Z)(cue)) {
        addStyle(cue, paragraphStyle);
    }
    return cue;
}
/**
 * Generate text to display for a given paragraph.
 * @param {Element} paragraph - The <p> tag.
 * @param {Boolean} shouldTrimWhiteSpaceForParagraph
 * @returns {string}
 */
function generateTextContent(paragraph, shouldTrimWhiteSpaceForParagraph) {
    /**
     * Recursive function, taking a node in argument and returning the
     * corresponding string.
     * @param {Node} node - the node in question
     * @returns {string}
     */
    function loop(node, shouldTrimWhiteSpaceFromParent) {
        const childNodes = node.childNodes;
        let text = "";
        for (let i = 0; i < childNodes.length; i++) {
            const currentNode = childNodes[i];
            if (currentNode.nodeName === "#text") {
                let textContent = currentNode.textContent;
                if (textContent === null) {
                    textContent = "";
                }
                if (shouldTrimWhiteSpaceFromParent) {
                    // 1. Trim leading and trailing whitespace.
                    // 2. Collapse multiple spaces into one.
                    let trimmed = textContent.trim();
                    trimmed = trimmed.replace(/\s+/g, " ");
                    textContent = trimmed;
                }
                // DOM Parser turns HTML escape caracters into caracters,
                // that may be misinterpreted by VTTCue API (typically, less-than sign
                // and greater-than sign can be interpreted as HTML tags signs).
                // Original escaped caracters must be conserved.
                const escapedTextContent = textContent
                    .replace(/&|\u0026/g, "&amp;")
                    .replace(/<|\u003C/g, "&lt;")
                    .replace(/>|\u2265/g, "&gt;")
                    .replace(/\u200E/g, "&lrm;")
                    .replace(/\u200F/g, "&rlm;")
                    .replace(/\u00A0/g, "&nbsp;");
                text += escapedTextContent;
            }
            else if (currentNode.nodeName === "br") {
                text += "\n";
            }
            else if (currentNode.nodeName === "span" &&
                currentNode.nodeType === Node.ELEMENT_NODE &&
                currentNode.childNodes.length > 0) {
                const spaceAttribute = currentNode.getAttribute("xml:space");
                const shouldTrimWhiteSpaceForSpan = (0,is_non_empty_string/* default */.Z)(spaceAttribute) ?
                    spaceAttribute === "default" :
                    shouldTrimWhiteSpaceFromParent;
                text += loop(currentNode, shouldTrimWhiteSpaceForSpan);
            }
        }
        return text;
    }
    return loop(paragraph, shouldTrimWhiteSpaceForParagraph);
}
/**
 * Adds applicable style properties to a cue.
 * /!\ Mutates cue argument.
 * @param {VTTCue} cue
 * @param {Object} style
 */
function addStyle(cue, style) {
    const extent = style.extent;
    if ((0,is_non_empty_string/* default */.Z)(extent)) {
        const results = regexps/* REGXP_PERCENT_VALUES.exec */._0.exec(extent);
        if (results != null) {
            // Use width value of the extent attribute for size.
            // Height value is ignored.
            cue.size = Number(results[1]);
        }
    }
    const writingMode = style.writingMode;
    // let isVerticalText = true;
    switch (writingMode) {
        case "tb":
        case "tblr":
            cue.vertical = "lr";
            break;
        case "tbrl":
            cue.vertical = "rl";
            break;
        default:
            // isVerticalText = false;
            break;
    }
    const origin = style.origin;
    if ((0,is_non_empty_string/* default */.Z)(origin)) {
        const results = regexps/* REGXP_PERCENT_VALUES.exec */._0.exec(origin);
        if (results != null) {
            // for vertical text use first coordinate of tts:origin
            // to represent line of the cue and second - for position.
            // Otherwise (horizontal), use them the other way around.
            // if (isVerticalText) {
            // TODO check and uncomment
            // cue.position = Number(results[2]);
            // cue.line = Number(results[1]);
            // } else {
            // TODO check and uncomment
            // cue.position = Number(results[1]);
            // cue.line = Number(results[2]);
            // }
            // A boolean indicating whether the line is an integer
            // number of lines (using the line dimensions of the first
            // line of the cue), or whether it is a percentage of the
            // dimension of the video. The flag is set to true when lines
            // are counted, and false otherwise.
            // TODO check and uncomment
            // cue.snapToLines = false;
        }
    }
    const align = style.align;
    if ((0,is_non_empty_string/* default */.Z)(align)) {
        cue.align = align;
        if (align === "center") {
            if (cue.align !== "center") {
                // Workaround for a Chrome bug http://crbug.com/663797
                // Chrome does not support align = "center"
                cue.align = "middle";
            }
            cue.position = "auto";
        }
        const positionAlign = TEXT_ALIGN_TO_POSITION_ALIGN[align];
        cue.positionAlign = positionAlign === undefined ? "" :
            positionAlign;
        const lineAlign = TEXT_ALIGN_TO_LIGN_ALIGN[align];
        cue.lineAlign = lineAlign === undefined ? "" :
            lineAlign;
    }
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/native/parse_ttml_to_vtt.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param str
 * @param timeOffset
 */
function parseTtmlToNative(str, timeOffset) {
    const parsedCues = (0,parse_ttml/* default */.Z)(str, timeOffset);
    const cues = [];
    for (let i = 0; i < parsedCues.length; i++) {
        const parsedCue = parsedCues[i];
        const cue = parseCue(parsedCue);
        if (cue !== null) {
            cues.push(cue);
        }
    }
    return cues;
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/native/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ const ttml_native = (parseTtmlToNative);


/***/ }),

/***/ 91366:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ parseTTMLString)
});

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(23437);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(53811);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/get_parameters.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const CELL_RESOLUTION_REGEXP = /(\d+) (\d+)/;
/**
 * Returns global parameters from a TTML Document
 * @param {Element} tt - <tt> node
 * @throws Error - Throws if the spacing style is invalid.
 * @returns {Object}
 */
function getParameters(tt) {
    const parsedFrameRate = tt.getAttribute("ttp:frameRate");
    const parsedSubFrameRate = tt.getAttribute("ttp:subFramRate");
    const parsedTickRate = tt.getAttribute("ttp:tickRate");
    const parsedFrameRateMultiplier = tt.getAttribute("ttp:frameRateMultiplier");
    const parsedSpaceStyle = tt.getAttribute("xml:space");
    const parsedCellResolution = tt.getAttribute("ttp:cellResolution");
    let cellResolution = { columns: 32,
        rows: 15 };
    if (parsedCellResolution !== null) {
        const extractedData = CELL_RESOLUTION_REGEXP.exec(parsedCellResolution);
        if (extractedData === null || extractedData.length < 3) {
            log/* default.warn */.Z.warn("TTML Parser: Invalid cellResolution");
        }
        else {
            const columns = parseInt(extractedData[1], 10);
            const rows = parseInt(extractedData[2], 10);
            if (isNaN(columns) || isNaN(rows)) {
                log/* default.warn */.Z.warn("TTML Parser: Invalid cellResolution");
            }
            else {
                cellResolution = { columns, rows };
            }
        }
    }
    if ((0,is_non_empty_string/* default */.Z)(parsedSpaceStyle) &&
        parsedSpaceStyle !== "default" &&
        parsedSpaceStyle !== "preserve") {
        throw new Error("Invalid spacing style");
    }
    let nbFrameRate = Number(parsedFrameRate);
    if (isNaN(nbFrameRate) || nbFrameRate <= 0) {
        nbFrameRate = 30;
    }
    let nbSubFrameRate = Number(parsedSubFrameRate);
    if (isNaN(nbSubFrameRate) || nbSubFrameRate <= 0) {
        nbSubFrameRate = 1;
    }
    let nbTickRate = Number(parsedTickRate);
    if (isNaN(nbTickRate) || nbTickRate <= 0) {
        nbTickRate = undefined;
    }
    let frameRate = nbFrameRate;
    const subFrameRate = nbSubFrameRate != null ? nbSubFrameRate :
        1;
    const spaceStyle = parsedSpaceStyle !== null ? parsedSpaceStyle :
        "default";
    const tickRate = nbTickRate !== undefined ? nbTickRate :
        nbFrameRate * nbSubFrameRate;
    if (parsedFrameRateMultiplier !== null) {
        const multiplierResults = /^(\d+) (\d+)$/g.exec(parsedFrameRateMultiplier);
        if (multiplierResults !== null) {
            const numerator = Number(multiplierResults[1]);
            const denominator = Number(multiplierResults[2]);
            const multiplierNum = numerator / denominator;
            frameRate = nbFrameRate * multiplierNum;
        }
    }
    return { cellResolution,
        tickRate,
        frameRate,
        subFrameRate,
        spaceStyle };
}

// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_parent_elements_by_tag_name.ts
var get_parent_elements_by_tag_name = __webpack_require__(60908);
// EXTERNAL MODULE: ./src/parsers/texttracks/ttml/get_styling.ts
var get_styling = __webpack_require__(5083);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/nodes.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {Element} tt
 * @returns {Element}
 */
function getBodyNode(tt) {
    return tt.getElementsByTagName("body")[0];
}
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getStyleNodes(tt) {
    return tt.getElementsByTagName("style");
}
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getRegionNodes(tt) {
    return tt.getElementsByTagName("region");
}
/**
 * @param {Element} tt - <tt> node
 * @returns {Array.<Element>}
 */
function getTextNodes(tt) {
    return tt.getElementsByTagName("p");
}


// EXTERNAL MODULE: ./src/utils/array_find_index.ts
var array_find_index = __webpack_require__(34612);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(54924);
;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/resolve_styles_inheritance.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Transform all styles inheriting from other styles to the same styles but with
 * the inheritance removed (by resolving those inheritance here).
 *
 * Note that the original style object is directly mutated with every
 * inheritance they had resolved and removed.
 *
 * To make a pseudo-code analogy this would be equivalent to transform those
 * two classes:
 * ```
 * class A {
 *   methodA() {}
 * }
 *
 * class B extends A {
 *   method B() {}
 * }
 * ```
 * into the same two classes without inheritance:
 * ```
 * class A {
 *   methodA() {}
 * }
 * class B {
 *   methodA() {} // inherited from class A
 *   methodB() {}
 * }
 * ```
 *
 * Doing this here allows to simplify further treatment of those styles.
 * @param {Array.<Object>} styles
 */
function resolveStylesInheritance(styles) {
    // keep track of all the indexes parsed to avoid infinite loops
    const recursivelyBrowsedIndexes = [];
    function resolveStyleInheritance(styleElt, index) {
        recursivelyBrowsedIndexes.push(index);
        for (let j = 0; j < styleElt.extendsStyles.length; j++) {
            const extendedStyleID = styleElt.extendsStyles[j];
            const extendedStyleIndex = (0,array_find_index/* default */.Z)(styles, (x) => x.id === extendedStyleID);
            if (extendedStyleIndex < 0) {
                log/* default.warn */.Z.warn("TTML Parser: unknown style inheritance: " + extendedStyleID);
            }
            else {
                const extendedStyle = styles[extendedStyleIndex];
                if ((0,array_includes/* default */.Z)(recursivelyBrowsedIndexes, extendedStyleIndex)) {
                    log/* default.warn */.Z.warn("TTML Parser: infinite style inheritance loop avoided");
                }
                else {
                    resolveStyleInheritance(extendedStyle, extendedStyleIndex);
                }
                styleElt.style = (0,object_assign/* default */.Z)({}, extendedStyle.style, styleElt.style);
            }
        }
        styleElt.extendsStyles.length = 0;
    }
    for (let i = 0; i < styles.length; i++) {
        resolveStyleInheritance(styles[i], i);
        recursivelyBrowsedIndexes.length = 0; // reset
    }
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/ttml/parse_ttml.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








const STYLE_ATTRIBUTES = ["align",
    "backgroundColor",
    "color",
    "direction",
    "display",
    "displayAlign",
    "extent",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontWeight",
    "lineHeight",
    "opacity",
    "origin",
    "overflow",
    "padding",
    "textAlign",
    "textDecoration",
    "textOutline",
    "unicodeBidi",
    "visibility",
    "wrapOption",
    "writingMode",
    // Not managed anywhere for now
    // "showBackground",
    // "zIndex",
];
/**
 * Create array of objects which should represent the given TTML text track.
 * TODO TTML parsing is still pretty heavy on the CPU.
 * Optimizations have been done, principally to avoid using too much XML APIs,
 * but we can still do better.
 * @param {string} str
 * @param {Number} timeOffset
 * @returns {Array.<Object>}
 */
function parseTTMLString(str, timeOffset) {
    const cues = [];
    const xml = new DOMParser().parseFromString(str, "text/xml");
    if (xml !== null && xml !== undefined) {
        const tts = xml.getElementsByTagName("tt");
        const tt = tts[0];
        if (tt === undefined) {
            throw new Error("invalid XML");
        }
        const body = getBodyNode(tt);
        const styleNodes = getStyleNodes(tt);
        const regionNodes = getRegionNodes(tt);
        const paragraphNodes = getTextNodes(tt);
        const ttParams = getParameters(tt);
        // construct idStyles array based on the xml as an optimization
        const idStyles = [];
        for (let i = 0; i <= styleNodes.length - 1; i++) {
            const styleNode = styleNodes[i];
            if (styleNode instanceof Element) {
                const styleID = styleNode.getAttribute("xml:id");
                if (styleID !== null) {
                    const subStyles = styleNode.getAttribute("style");
                    const extendsStyles = subStyles === null ? [] :
                        subStyles.split(" ");
                    idStyles.push({ id: styleID,
                        style: (0,get_styling/* getStylingFromElement */.b)(styleNode),
                        extendsStyles });
                }
            }
        }
        resolveStylesInheritance(idStyles);
        // construct regionStyles array based on the xml as an optimization
        const regionStyles = [];
        for (let i = 0; i <= regionNodes.length - 1; i++) {
            const regionNode = regionNodes[i];
            if (regionNode instanceof Element) {
                const regionID = regionNode.getAttribute("xml:id");
                if (regionID !== null) {
                    let regionStyle = (0,get_styling/* getStylingFromElement */.b)(regionNode);
                    const associatedStyleID = regionNode.getAttribute("style");
                    if ((0,is_non_empty_string/* default */.Z)(associatedStyleID)) {
                        const style = (0,array_find/* default */.Z)(idStyles, (x) => x.id === associatedStyleID);
                        if (style !== undefined) {
                            regionStyle = (0,object_assign/* default */.Z)({}, style.style, regionStyle);
                        }
                    }
                    regionStyles.push({ id: regionID,
                        style: regionStyle,
                        // already handled
                        extendsStyles: [] });
                }
            }
        }
        // Computing the style takes a lot of ressources.
        // To avoid too much re-computation, let's compute the body style right
        // now and do the rest progressively.
        // TODO Compute corresponding CSS style here (as soon as we now the TTML
        // style) to speed up the process even more.
        const bodyStyle = (0,get_styling/* getStylingAttributes */.U)(STYLE_ATTRIBUTES, body !== null ? [body] : [], idStyles, regionStyles);
        const bodySpaceAttribute = body !== null ? body.getAttribute("xml:space") :
            undefined;
        const shouldTrimWhiteSpaceOnBody = bodySpaceAttribute === "default" ||
            ttParams.spaceStyle === "default";
        for (let i = 0; i < paragraphNodes.length; i++) {
            const paragraph = paragraphNodes[i];
            if (paragraph instanceof Element) {
                const divs = (0,get_parent_elements_by_tag_name/* default */.Z)(paragraph, "div");
                const paragraphStyle = (0,object_assign/* default */.Z)({}, bodyStyle, (0,get_styling/* getStylingAttributes */.U)(STYLE_ATTRIBUTES, [paragraph,
                    ...divs], idStyles, regionStyles));
                const paragraphSpaceAttribute = paragraph.getAttribute("xml:space");
                const shouldTrimWhiteSpace = (0,is_non_empty_string/* default */.Z)(paragraphSpaceAttribute) ?
                    paragraphSpaceAttribute === "default" :
                    shouldTrimWhiteSpaceOnBody;
                const cue = { paragraph,
                    timeOffset,
                    idStyles,
                    regionStyles,
                    body,
                    paragraphStyle,
                    ttParams,
                    shouldTrimWhiteSpace };
                if (cue !== null) {
                    cues.push(cue);
                }
            }
        }
    }
    return cues;
}


/***/ }),

/***/ 49289:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YU": () => (/* binding */ REGXP_4_HEX_COLOR),
/* harmony export */   "Dq": () => (/* binding */ REGXP_8_HEX_COLOR),
/* harmony export */   "GK": () => (/* binding */ REGXP_RGB_COLOR),
/* harmony export */   "ev": () => (/* binding */ REGXP_RGBA_COLOR),
/* harmony export */   "eT": () => (/* binding */ REGXP_LENGTH),
/* harmony export */   "_0": () => (/* binding */ REGXP_PERCENT_VALUES),
/* harmony export */   "KO": () => (/* binding */ REGXP_TIME_COLON),
/* harmony export */   "gu": () => (/* binding */ REGXP_TIME_COLON_FRAMES),
/* harmony export */   "wf": () => (/* binding */ REGXP_TIME_COLON_MS),
/* harmony export */   "jb": () => (/* binding */ REGXP_TIME_FRAMES),
/* harmony export */   "te": () => (/* binding */ REGXP_TIME_HMS),
/* harmony export */   "Du": () => (/* binding */ REGXP_TIME_TICK)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
const REGXP_TIME_COLON_FRAMES = /^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;
// examples: 00:00:40:07 (7 frames) or 00:00:40:07.1 (7 frames, 1 subframe)
const REGXP_TIME_COLON = /^(?:(\d{2,}):)?(\d{2}):(\d{2})$/;
// examples: 01:02:43.0345555 or 02:43.03
const REGXP_TIME_COLON_MS = /^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/;
// examples: 75f or 75.5f
const REGXP_TIME_FRAMES = /^(\d*\.?\d*)f$/;
// examples: 50t or 50.5t
const REGXP_TIME_TICK = /^(\d*\.?\d*)t$/;
// examples: 3.45h, 3m or 4.20s
const REGXP_TIME_HMS = /^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/;
// examples: 50% 10%
const REGXP_PERCENT_VALUES = /^(\d{1,2}|100)% (\d{1,2}|100)%$/;
const REGXP_LENGTH = /^((?:\+|\-)?\d*(?:\.\d+)?)(px|em|c|%|rh|rw)$/;
const REGXP_8_HEX_COLOR = /^#([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})([0-9A-f]{2})$/;
const REGXP_4_HEX_COLOR = /^#([0-9A-f])([0-9A-f])([0-9A-f])([0-9A-f])$/;
const REGXP_RGB_COLOR = /^rgb\( *(\d+) *, *(\d+) *, *(\d+) *\)/;
const REGXP_RGBA_COLOR = /^rgba\( *(\d+) *, *(\d+) *, *(\d+) *, *(\d+) *\)/;



/***/ }),

/***/ 60556:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ getCueBlocks)
/* harmony export */ });
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4938);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(71368);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */
function getCueBlocks(linified, headerOffset) {
    const cueBlocks = [];
    for (let i = headerOffset; i < linified.length; i++) {
        if ((0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .isStartOfCueBlock */ .tq)(linified, i)) {
            const endOfCue = (0,_utils__WEBPACK_IMPORTED_MODULE_0__/* .findEndOfCueBlock */ .$4)(linified, i);
            cueBlocks.push(linified.slice(i, endOfCue));
            i = endOfCue;
        }
        else if ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(linified[i])) {
            // continue incrementing i until either:
            //   - empty line
            //   - end
            while ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(linified[i])) {
                i++;
            }
        }
    }
    return cueBlocks;
}


/***/ }),

/***/ 48299:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ html)
});

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/get_cue_blocks.ts
var get_cue_blocks = __webpack_require__(60556);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/utils.ts
var utils = __webpack_require__(71368);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/get_style_blocks.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Get cue blocks from a WebVTT file.
 * @param {Array.<string>} linified - Whole WebVTT file. Each new element in
 * this array is a new line.
 * @param {number} headerOffset - index of the first line after the header.
 * Used to avoid taking the header into consideration.
 * @returns {Array.<Array.<string>>}
 */
function getStyleBlocks(linified, headerOffset) {
    const styleBlocks = [];
    for (let i = headerOffset; i < linified.length; i++) { //
        if ((0,utils/* isStartOfStyleBlock */.JF)(linified, i)) {
            const startOfStyleBlock = i;
            i++;
            // continue incrementing i until either:
            //   - empty line
            //   - end of file
            while ((0,is_non_empty_string/* default */.Z)(linified[i])) {
                i++;
            }
            const styleBlock = linified.slice(startOfStyleBlock, i);
            styleBlocks.push(styleBlock);
        }
        else if ((0,is_non_empty_string/* default */.Z)(linified[i])) {
            // continue incrementing i until either:
            //   - empty line
            //   - end
            while ((0,is_non_empty_string/* default */.Z)(linified[i])) {
                i++;
            }
        }
    }
    return styleBlocks;
}

// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts + 1 modules
var parse_cue_block = __webpack_require__(40040);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_default_style_elements.ts
/**
 * Creates default classes defined in the W3 specification
 *
 * https://www.w3.org/TR/webvtt1/#default-classes
 */
const colorMap = {
    white: "#ffffff",
    lime: "#00ff00",
    cyan: "#00ffff",
    red: "#ff0000",
    yellow: "#ffff00",
    magenta: "#ff00ff",
    blue: "#0000ff",
    black: "#000000",
};
function createDefaultStyleElements() {
    return Object.keys(colorMap).reduce((result, key) => {
        result[key] = `color: ${colorMap[key]};`;
        result[`bg_${key}`] = `background-color: ${colorMap[key]};`;
        return result;
    }, {});
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parse_style_block.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse style element from WebVTT.
 * @param {Array.<Array.<string>>} styleBlocks
 * @return {Object}
 */
function parseStyleBlocks(styleBlocks) {
    const classes = createDefaultStyleElements();
    let global = "";
    styleBlocks.forEach((styleBlock) => {
        if (styleBlock.length >= 2) {
            for (let index = 1; index < styleBlock.length; index++) {
                let line = styleBlock[index];
                if (Array.isArray(/::cue {/.exec(line))) {
                    line = styleBlock[++index];
                    while ((0,is_non_empty_string/* default */.Z)(line) && (!(Array.isArray(/}/.exec(line)) ||
                        line.length === 0))) {
                        global += line;
                        line = styleBlock[++index];
                    }
                }
                else {
                    const classNames = [];
                    let cueClassLine = /::cue\(\.?(.*?)\)(?:,| {)/.exec(line);
                    while ((0,is_non_empty_string/* default */.Z)(line) && Array.isArray(cueClassLine)) {
                        classNames.push(cueClassLine[1]);
                        line = styleBlock[++index];
                        cueClassLine = /::cue\(\.?(.*?)\)(?:,| {)/.exec(line);
                    }
                    let styleContent = "";
                    while ((0,is_non_empty_string/* default */.Z)(line) && (!(Array.isArray(/}/.exec(line)) ||
                        line.length === 0))) {
                        styleContent += line;
                        line = styleBlock[++index];
                    }
                    classNames.forEach((className) => {
                        const styleElement = classes[className];
                        if (styleElement === undefined) {
                            classes[className] = styleContent;
                        }
                        else {
                            classes[className] += styleContent;
                        }
                    });
                }
            }
        }
    });
    return { classes, global };
}

// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(54924);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_styled_element.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Construct an HTMLElement/TextNode representing the given node and apply
 * the right styling on it.
 * @param {Node} baseNode
 * @param {Array.<Object>} styleElements
 * @param {Array.<string>} styleClasses
 * @returns {Node}
 */
function createStyledElement(baseNode, styleElements) {
    const HTMLTags = ["u", "i", "b"];
    const authorizedNodeNames = ["u", "i", "b", "c", "#text"];
    const mainNodeName = baseNode.nodeName.toLowerCase().split(".")[0];
    let nodeWithStyle;
    if ((0,array_includes/* default */.Z)(authorizedNodeNames, mainNodeName)) {
        if (mainNodeName === "#text") {
            const linifiedText = baseNode.wholeText
                .split("\n");
            nodeWithStyle = document.createElement("span");
            for (let i = 0; i < linifiedText.length; i++) {
                if (i > 0) {
                    nodeWithStyle.appendChild(document.createElement("br"));
                }
                if (linifiedText[i].length > 0) {
                    const textNode = document.createTextNode(linifiedText[i]);
                    nodeWithStyle.appendChild(textNode);
                }
            }
        }
        else {
            const nodeClasses = baseNode.nodeName.toLowerCase().split(".");
            const styleContents = [];
            nodeClasses.forEach(nodeClass => {
                if ((0,is_non_empty_string/* default */.Z)(styleElements[nodeClass])) {
                    styleContents.push(styleElements[nodeClass]);
                }
            });
            if (styleContents.length !== 0) { // If style must be applied
                const attr = document.createAttribute("style");
                styleContents.forEach((styleContent) => {
                    attr.value += styleContent;
                });
                const nameClass = (0,array_includes/* default */.Z)(HTMLTags, mainNodeName) ?
                    mainNodeName : "span";
                nodeWithStyle = document.createElement(nameClass);
                nodeWithStyle.setAttributeNode(attr);
            }
            else { // If style mustn't be applied. Rebuild element with tag name
                const elementTag = !(0,array_includes/* default */.Z)(HTMLTags, mainNodeName) ?
                    "span" : mainNodeName;
                nodeWithStyle = document.createElement(elementTag);
            }
            for (let j = 0; j < baseNode.childNodes.length; j++) {
                const child = createStyledElement(baseNode.childNodes[j], styleElements);
                nodeWithStyle.appendChild(child);
            }
        }
    }
    else {
        nodeWithStyle = document.createElement("span");
        for (let j = 0; j < baseNode.childNodes.length; j++) {
            const child = createStyledElement(baseNode.childNodes[j], styleElements);
            nodeWithStyle.appendChild(child);
        }
    }
    return nodeWithStyle;
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/convert_payload_to_html.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {string} text
 * @param {Array.<Object>} styleElements
 * @returns {Array.<HTMLElement>}
 */
function convertPayloadToHTML(text, styleElements) {
    const filteredText = text
        // Remove timestamp tags
        .replace(/<[0-9]{2}:[0-9]{2}.[0-9]{3}>/, "")
        // Remove tag content or attributes (e.g. <b dfgfdg> => <b>)
        .replace(/<([u,i,b,c])(\..*?)?(?: .*?)?>(.*?)<\/\1>/g, "<$1$2>$3</$1$2>");
    const parsedWebVTT = new DOMParser().parseFromString(filteredText, "text/html");
    const nodes = parsedWebVTT.body.childNodes;
    const styledElements = [];
    for (let i = 0; i < nodes.length; i++) {
        styledElements.push(createStyledElement(nodes[i], styleElements));
    }
    return styledElements;
}

// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(86293);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/create_style_attribute.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Construct a DOM attribute reflecting given cue settings
 * @param {Partial<Record<string, string>>} settings
 * @returns {Attr}
 */
function createStyleAttribute(settings) {
    const pAttr = document.createAttribute("style");
    pAttr.value = getAttrValue(settings);
    return pAttr;
}
const getAttrValue = (settings) => {
    const hasSettings = settings !== undefined && (0,object_values/* default */.Z)(settings).length !== 0;
    if (!hasSettings) {
        return "text-align:center";
    }
    const xPositioning = getPositioningX(settings);
    const yPositioning = getPositioningY(settings);
    return ("position: absolute;" +
        "margin: 0;" +
        `transform: translate(${xPositioning.offset}%,${yPositioning.offset}%);` +
        `width: ${getSizePercentage(settings.size)}%;` +
        `left: ${xPositioning.position}%;` +
        `top: ${yPositioning.position !== null ? `${yPositioning.position}%` : "auto"};` +
        `text-align: ${getAlignValue(settings.align)};`);
};
var PositionAlignment;
(function (PositionAlignment) {
    PositionAlignment["LINE_LEFT"] = "line-left";
    PositionAlignment["CENTER"] = "center";
    PositionAlignment["LINE_RIGHT"] = "line-right";
})(PositionAlignment || (PositionAlignment = {}));
var Align;
(function (Align) {
    Align["LEFT"] = "left";
    Align["CENTER"] = "center";
    Align["RIGHT"] = "right";
})(Align || (Align = {}));
var LineAlignment;
(function (LineAlignment) {
    LineAlignment["START"] = "start";
    LineAlignment["CENTER"] = "center";
    LineAlignment["END"] = "end";
})(LineAlignment || (LineAlignment = {}));
const getPositioningX = (settings) => {
    return {
        position: getXPositionPercentage(settings),
        offset: getXOffsetPercentage(settings),
    };
};
const getXPositionPercentage = (settings) => {
    const positionPercentage = getPercentageValue(settings.position);
    if (positionPercentage !== null) {
        return positionPercentage;
    }
    const align = getAlignValue(settings.align);
    const alignMap = {
        [Align.LEFT]: 0,
        [Align.CENTER]: 50,
        [Align.RIGHT]: 100,
    };
    return alignMap[align];
};
const getXOffsetPercentage = (settings) => {
    const getPositionAlignment = (positionSetting) => {
        const positionRegex = /,(line-left|line-right|center)/;
        const matches = positionRegex.exec(positionSetting);
        if (!Array.isArray(matches) || matches.length < 2) {
            return null;
        }
        return matches[1];
    };
    const positionAlignmentMap = {
        [PositionAlignment.LINE_LEFT]: 0,
        [PositionAlignment.CENTER]: -50,
        [PositionAlignment.LINE_RIGHT]: -100,
    };
    const positionAlignment = settings.position !== undefined ?
        getPositionAlignment(settings.position) :
        null;
    if (positionAlignment !== null) {
        return positionAlignmentMap[positionAlignment];
    }
    const alignMap = {
        [Align.LEFT]: 0,
        [Align.CENTER]: -50,
        [Align.RIGHT]: -100,
    };
    const align = settings.align !== undefined ?
        getAlignValue(settings.align)
        : Align.CENTER;
    return alignMap[align];
};
const getPositioningY = (settings) => {
    return {
        position: getYPositionPercentage(settings.line),
        offset: getYOffsetPercentage(settings.line),
    };
};
const getYPositionPercentage = (lineSetting) => {
    return getPercentageValue(lineSetting);
};
const getYOffsetPercentage = (lineSetting) => {
    const getLineAlignment = (line) => {
        const positionRegex = /,(start|center|end)/;
        const matches = positionRegex.exec(line);
        if (!Array.isArray(matches) || matches.length < 2) {
            return null;
        }
        return matches[1];
    };
    const lineAlignmentMap = {
        [LineAlignment.START]: 0,
        [LineAlignment.CENTER]: -50,
        [LineAlignment.END]: -100,
    };
    if (lineSetting === undefined) {
        return lineAlignmentMap[LineAlignment.START];
    }
    const lineAlignment = getLineAlignment(lineSetting);
    return lineAlignment !== null ?
        lineAlignmentMap[lineAlignment] :
        lineAlignmentMap[LineAlignment.START];
};
const getAlignValue = (alignSetting) => {
    switch (alignSetting) {
        case "left":
        case "start":
            return "left";
        case "right":
        case "end":
            return "right";
        default:
            return "center";
    }
};
const getSizePercentage = (sizeSetting) => {
    const defaultSize = 100;
    return getPercentageValueOrDefault(sizeSetting, defaultSize);
};
const getPercentageValueOrDefault = (percentageString, defaultValue) => {
    const value = getPercentageValue(percentageString);
    return value !== null ?
        value :
        defaultValue;
};
const getPercentageValue = (percentageString) => {
    if (percentageString === undefined) {
        return null;
    }
    const percentageValueRegex = /^([\d.]+)%/;
    const matches = percentageValueRegex.exec(percentageString);
    if (!Array.isArray(matches) || matches.length < 2) {
        return null;
    }
    return parseInt(matches[1], 10);
};

;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/to_html.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse cue block into an object with the following properties:
 *   - start {number}: start time at which the cue should be displayed
 *   - end {number}: end time at which the cue should be displayed
 *   - element {HTMLElement}: the cue text, translated into an HTMLElement
 *
 * Returns undefined if the cue block could not be parsed.
 * @param {Array.<string>} cueBlock
 * @param {Number} timeOffset
 * @param {Array.<Object>} classes
 * @returns {Object|undefined}
 */
function toHTML(cueObj, styling) {
    const { start, end, settings, header, payload } = cueObj;
    const region = document.createElement("div");
    const regionAttr = document.createAttribute("style");
    regionAttr.value =
        "width:100%;" +
            "height:100%;" +
            "display:flex;" +
            "flex-direction:column;" +
            "justify-content:flex-end;" +
            "align-items:center;";
    region.setAttributeNode(regionAttr);
    // Get content, format and apply style.
    const pElement = document.createElement("p");
    const pAttr = createStyleAttribute(settings);
    pElement.setAttributeNode(pAttr);
    const spanElement = document.createElement("span");
    const attr = document.createAttribute("style");
    // set color and background-color default values, as indicated in:
    // https://www.w3.org/TR/webvtt1/#applying-css-properties
    attr.value =
        "background-color:rgba(0,0,0,0.8);" +
            "color:white;";
    spanElement.setAttributeNode(attr);
    const { global, classes } = styling;
    const localStyle = (0,is_non_empty_string/* default */.Z)(header) ? classes[header] :
        undefined;
    const styles = [global, localStyle]
        .filter((s) => s !== undefined)
        .join("");
    attr.value += styles;
    spanElement.setAttributeNode(attr);
    convertPayloadToHTML(payload.join("\n"), classes)
        .forEach(element => {
        spanElement.appendChild(element);
    });
    region.appendChild(pElement);
    pElement.appendChild(spanElement);
    return { start,
        end,
        element: region };
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/parse_webvtt_to_div.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Parse WebVTT from text. Returns an array with:
 * - start : start of current cue, in seconds
 * - end : end of current cue, in seconds
 * - content : HTML formatted cue.
 *
 * Global style is parsed and applied to div element.
 * Specific style is parsed and applied to class element.
 *
 * @throws Error - Throws if the given WebVTT string is invalid.
 * @param {string} text - The whole webvtt subtitles to parse
 * @param {Number} timeOffset - Offset to add to start and end times, in seconds
 * @return {Array.<Object>}
 */
function parseWebVTT(text, timeOffset) {
    const newLineChar = /\r\n|\n|\r/g; // CRLF|LF|CR
    const linified = text.split(newLineChar);
    const cuesArray = [];
    if (/^WEBVTT( |\t|\n|\r|$)/.exec(linified[0]) === null) {
        throw new Error("Can't parse WebVTT: Invalid File.");
    }
    const firstLineAfterHeader = (0,utils/* getFirstLineAfterHeader */.yE)(linified);
    const styleBlocks = getStyleBlocks(linified, firstLineAfterHeader);
    const cueBlocks = (0,get_cue_blocks/* default */.Z)(linified, firstLineAfterHeader);
    const styles = parseStyleBlocks(styleBlocks);
    for (let i = 0; i < cueBlocks.length; i++) {
        const cueObject = (0,parse_cue_block/* default */.Z)(cueBlocks[i], timeOffset);
        if (cueObject != null) {
            const htmlCue = toHTML(cueObject, styles);
            cuesArray.push(htmlCue);
        }
    }
    return cuesArray;
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/html/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ const html = (parseWebVTT);


/***/ }),

/***/ 42262:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ webvtt_native)
});

// EXTERNAL MODULE: ./src/compat/is_vtt_cue.ts
var is_vtt_cue = __webpack_require__(56003);
// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/get_cue_blocks.ts
var get_cue_blocks = __webpack_require__(60556);
// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts + 1 modules
var parse_cue_block = __webpack_require__(40040);
// EXTERNAL MODULE: ./src/parsers/texttracks/webvtt/utils.ts
var utils = __webpack_require__(71368);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(54924);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/set_settings_on_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Add the corresponding settings on the given cue.
 * /!\ Mutates the cue given.
 * @param {Object} settings - settings for the cue, as a key-value object.
 * @param {ICompatVTTCue|TextTrackCue} cue
 */
function setSettingsOnCue(settings, cue) {
    if ((0,is_non_empty_string/* default */.Z)(settings.vertical) &&
        (settings.vertical === "rl" || settings.vertical === "lr")) {
        cue.vertical = settings.vertical;
    }
    if ((0,is_non_empty_string/* default */.Z)(settings.line)) {
        // Capture groups:
        //   1 -> percentage position
        //   2 -> optional decimals from percentage position
        //   3 -> optional follow-up of the string indicating alignment value
        //   4 -> alignment value
        const percentagePosition = /^(\d+(\.\d+)?)%(,([a-z]+))?/;
        const percentageMatches = percentagePosition.exec(settings.line);
        if (Array.isArray(percentageMatches)) {
            cue.line = Number(percentageMatches[1]);
            cue.snapToLines = false;
            if ((0,array_includes/* default */.Z)(["start", "center", "end"], percentageMatches[4])) {
                cue.lineAlign = percentageMatches[4];
            }
        }
        else {
            // Capture groups:
            //   1 -> line number
            //   2 -> optional follow-up of the string indicating alignment value
            //   3 -> alignment value
            const linePosition = /^(-?\d+)(,([a-z]+))?/;
            const lineMatches = linePosition.exec(settings.line);
            if (Array.isArray(lineMatches)) {
                cue.line = Number(lineMatches[1]);
                cue.snapToLines = true;
                if ((0,array_includes/* default */.Z)(["start", "center", "end"], lineMatches[3])) {
                    cue.lineAlign = lineMatches[3];
                }
            }
        }
    }
    if ((0,is_non_empty_string/* default */.Z)(settings.position)) {
        const positionRegex = /^([\d\.]+)%(?:,(line-left|line-right|center))?$/;
        const positionArr = positionRegex.exec(settings.position);
        if (Array.isArray(positionArr) && positionArr.length >= 2) {
            const position = parseInt(positionArr[1], 10);
            if (!isNaN(position)) {
                cue.position = position;
                if (positionArr[2] !== undefined) {
                    cue.positionAlign = positionArr[2];
                }
            }
        }
    }
    if ((0,is_non_empty_string/* default */.Z)(settings.size)) {
        cue.size = settings.size;
    }
    if (typeof settings.align === "string" &&
        (0,array_includes/* default */.Z)(["start", "center", "end", "left"], settings.align)) {
        cue.align = settings.align;
    }
}

// EXTERNAL MODULE: ./src/compat/make_vtt_cue.ts
var make_vtt_cue = __webpack_require__(11862);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/to_native_cue.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Object} cue Object
 * @returns {TextTrackCue|ICompatVTTCue|null}
 */
function toNativeCue(cueObj) {
    const { start, end, payload } = cueObj;
    const text = payload.join("\n");
    return (0,make_vtt_cue/* default */.Z)(start, end, text);
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/parse_vtt_to_cues.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */






// Simple VTT to ICompatVTTCue parser:
// Just parse cues and associated settings.
// Does not take into consideration STYLE and REGION blocks.
/**
 * Parse whole WEBVTT file into an array of cues, to be inserted in a video's
 * TrackElement.
 * @param {string} vttStr
 * @param {Number} timeOffset
 * @returns {Array.<ICompatVTTCue|TextTrackCue>}
 */
function parseVTTStringToVTTCues(vttStr, timeOffset) {
    // WEBVTT authorize CRLF, LF or CR as line terminators
    const lines = vttStr.split(/\r\n|\n|\r/);
    if (!(/^WEBVTT($| |\t)/.test(lines[0]))) {
        throw new Error("Can't parse WebVTT: Invalid file.");
    }
    const firstLineAfterHeader = (0,utils/* getFirstLineAfterHeader */.yE)(lines);
    const cueBlocks = (0,get_cue_blocks/* default */.Z)(lines, firstLineAfterHeader);
    const cues = [];
    for (let i = 0; i < cueBlocks.length; i++) {
        const cueObject = (0,parse_cue_block/* default */.Z)(cueBlocks[i], timeOffset);
        if (cueObject != null) {
            const nativeCue = toNativeCue(cueObject);
            if (nativeCue != null) {
                if ((0,is_vtt_cue/* default */.Z)(nativeCue)) {
                    setSettingsOnCue(cueObject.settings, nativeCue);
                }
                cues.push(nativeCue);
            }
        }
    }
    return cues;
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/native/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ const webvtt_native = (parseVTTStringToVTTCues);


/***/ }),

/***/ 40040:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ parseCueBlock)
});

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parse_timestamp.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a single webvtt timestamp into seconds
 * @param {string} timestampString
 * @returns {Number|undefined}
 */
function parseTimestamp(timestampString) {
    const splittedTS = timestampString.split(":").reverse();
    if ((0,is_non_empty_string/* default */.Z)(splittedTS[2]) || (0,is_non_empty_string/* default */.Z)(splittedTS[1])) {
        const hours = (0,is_non_empty_string/* default */.Z)(splittedTS[2]) ? parseInt(splittedTS[2], 10) :
            0;
        const minutes = parseInt(splittedTS[1], 10);
        const seconds = parseFloat(splittedTS[0].replace(",", "."));
        if (isNaN(hours) || isNaN(minutes) || isNaN(seconds)) {
            return undefined;
        }
        return hours * 60 * 60 + minutes * 60 + seconds;
    }
}

;// CONCATENATED MODULE: ./src/parsers/texttracks/webvtt/parse_cue_block.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse the settings part of a cue, into key-value object.
 * @param {string} settingsString
 * @returns {Object}
 */
function parseSettings(settingsString) {
    const splittedSettings = settingsString.split(/ |\t/);
    return splittedSettings
        .reduce((acc, setting) => {
        const splittedSetting = setting.split(":");
        if (splittedSetting.length === 2) {
            acc[splittedSetting[0]] = splittedSetting[1];
        }
        return acc;
    }, {});
}
/**
 * Parse the line containing the timestamp and settings in a cue.
 * The returned object has the following properties:
 *   - start {Number}: start of the cue, in seconds
 *   - end {Number}: end of the cue, in seconds
 *   - settings {Object}: settings for the cue as a key-value object.
 * @param {string} timeString
 * @returns {Object|null}
 */
function parseTimeAndSettings(timeString) {
    // RegExp for the timestamps + settings line.
    // Capture groups:
    //   1 -> start timestamp
    //   2 -> end timestamp
    //   3 - settings
    const lineRegex = /^([\d:.]+)[ |\t]+-->[ |\t]+([\d:.]+)[ |\t]*(.*)$/;
    const matches = lineRegex.exec(timeString);
    if (matches === null) {
        return null;
    }
    const start = parseTimestamp(matches[1]);
    const end = parseTimestamp(matches[2]);
    if (start == null || end == null) {
        return null;
    }
    const settings = parseSettings(matches[3]);
    return { start,
        end,
        settings };
}
/**
 * Parse cue block into a cue object which contains:
 *   - start {number}: the start of the cue as a timestamp in seconds
 *   - end {number}: the end of the cue as a timestamp in seconds
 *   - header {string|undefined}: The optional cue identifier
 *   - payload {Array.<string>}: the payload of the cue
 * @param {Array.<string>} cueLines
 * @param {Number} timeOffset
 * @returns {Object}
 */
function parseCueBlock(cueLines, timeOffset) {
    const timingRegexp = /-->/;
    let timeString;
    let payload;
    let header;
    if (!timingRegexp.test(cueLines[0])) {
        if (!timingRegexp.test(cueLines[1])) {
            // not a cue
            return null;
        }
        header = cueLines[0];
        timeString = cueLines[1];
        payload = cueLines.slice(2, cueLines.length);
    }
    else {
        timeString = cueLines[0];
        payload = cueLines.slice(1, cueLines.length);
    }
    const timeAndSettings = parseTimeAndSettings(timeString);
    if (timeAndSettings === null) {
        return null;
    }
    const { start, end, settings } = timeAndSettings;
    return { start: start + timeOffset,
        end: end + timeOffset,
        settings,
        payload,
        header };
}


/***/ }),

/***/ 71368:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "yE": () => (/* binding */ getFirstLineAfterHeader),
/* harmony export */   "tq": () => (/* binding */ isStartOfCueBlock),
/* harmony export */   "JF": () => (/* binding */ isStartOfStyleBlock),
/* harmony export */   "$4": () => (/* binding */ findEndOfCueBlock)
/* harmony export */ });
/* unused harmony exports isStartOfNoteBlock, isStartOfRegionBlock */
/* harmony import */ var _utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4938);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns first line after the WEBVTT header.
 * That is, the line after the first blank line after the first line!
 * @param {Array.<string>} linified
 * @returns {Number}
 */
function getFirstLineAfterHeader(linified) {
    let i = 0;
    while (i < linified.length) {
        if (linified[i] === "") {
            return i + 1;
        }
        i++;
    }
    return i;
}
/**
 * Returns true if the given line looks like the beginning of a Style block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfStyleBlock(lines, index) {
    return typeof lines[index] === "string" &&
        /^STYLE( .*)?$/g.test(lines[index]) &&
        // A cue identifer can also contain "STYLE". Check that we have no timings
        // on the second line
        (lines[index + 1] === undefined || lines[index + 1].indexOf("-->") < 0);
}
/**
 * Returns true if the given line looks like the beginning of a comment block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfNoteBlock(lines, index) {
    return typeof lines[index] === "string" &&
        /^NOTE( .*)?$/g.test(lines[index]) &&
        // A cue identifer can also contain "NOTE". Check that we have no timings
        // on the second line
        (lines[index + 1] === undefined || lines[index + 1].indexOf("-->") < 0);
}
/**
 * Returns true if the given line looks like the beginning of a region block.
 * @param {string} text
 * @returns {Boolean}
 */
function isStartOfRegionBlock(lines, index) {
    return typeof lines[index] === "string" &&
        /^REGION( .*)?$/g.test(lines[index]) &&
        // A cue identifer can also contain "REGION". Check that we have no timings
        // on the second line
        (lines[index + 1] === undefined || lines[index + 1].indexOf("-->") < 0);
}
/**
 * Returns true if the line given looks like the beginning of a cue.
 * You should provide to this function only lines following "empty" lines.
 * @param {Array.<string>} lines
 * @param {number} index
 * @returns {Boolean}
 */
function isStartOfCueBlock(lines, index) {
    // checked cases:
    //   - empty lines
    //   - start of a comment
    //   - start of a region
    //   - start of a style
    // Anything else whose first or second line is a timestamp line is a cue.
    const firstLine = lines[index];
    if (firstLine === undefined ||
        firstLine === "" ||
        isStartOfStyleBlock(lines, index) ||
        isStartOfRegionBlock(lines, index) ||
        isStartOfNoteBlock(lines, index)) {
        return false;
    }
    if (firstLine.indexOf("-->") >= 0) {
        return true;
    }
    const secondLine = lines[index + 1];
    return secondLine !== undefined && secondLine.indexOf("-->") >= 0;
}
/**
 * Find end of current WebVTT cue block.
 * @param {Array<string>} linified
 * @param {number} startOfCueBlock
 * @returns {number}
 */
function findEndOfCueBlock(linified, startOfCueBlock) {
    let firstEmptyLineIndex = startOfCueBlock + 1;
    // continue incrementing i until either:
    //   - empty line
    //   - end
    while ((0,_utils_is_non_empty_string__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(linified[firstEmptyLineIndex])) {
        firstEmptyLineIndex++;
    }
    return firstEmptyLineIndex;
}



/***/ }),

/***/ 9563:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ transports_dash)
});

// EXTERNAL MODULE: ./src/transports/utils/text_manifest_loader.ts
var text_manifest_loader = __webpack_require__(75691);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(41195);
// EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
var request = __webpack_require__(99703);
// EXTERNAL MODULE: ./src/utils/take_first_set.ts
var take_first_set = __webpack_require__(66365);
;// CONCATENATED MODULE: ./src/transports/dash/image_pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @param {Object} args
 * @returns {Observable}
 */
function imageLoader({ segment, url }) {
    if (segment.isInit || url === null) {
        return (0,of.of)({ type: "data-created", value: { responseData: null } });
    }
    return (0,request/* default */.ZP)({ url,
        responseType: "arraybuffer",
        sendProgressEvents: true });
}
/**
 * @param {Object} args
 * @returns {Observable}
 */
function imageParser({ response, content }) {
    const { segment, period } = content;
    const { data, isChunked } = response;
    if (content.segment.isInit) { // image init segment has no use
        return (0,of.of)({ type: "parsed-init-segment",
            value: { initializationData: null,
                protectionDataUpdate: false,
                initTimescale: undefined } });
    }
    if (isChunked) {
        throw new Error("Image data should not be downloaded in chunks");
    }
    const chunkOffset = (0,take_first_set/* default */.Z)(segment.timestampOffset, 0);
    // TODO image Parsing should be more on the buffer side, no?
    if (data === null || features/* default.imageParser */.Z.imageParser === null) {
        return (0,of.of)({ type: "parsed-segment",
            value: { chunkData: null,
                chunkInfos: { duration: segment.duration,
                    time: segment.time },
                chunkOffset,
                appendWindow: [period.start, period.end] } });
    }
    const bifObject = features/* default.imageParser */.Z.imageParser(new Uint8Array(data));
    const thumbsData = bifObject.thumbs;
    return (0,of.of)({ type: "parsed-segment",
        value: { chunkData: { data: thumbsData,
                start: 0,
                end: Number.MAX_VALUE,
                timescale: 1,
                type: "bif" },
            chunkInfos: { time: 0,
                duration: Number.MAX_VALUE,
                timescale: bifObject.timescale },
            chunkOffset,
            appendWindow: [period.start, period.end] } });
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(70252);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(92953);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(96705);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(65208);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(75688);
// EXTERNAL MODULE: ./src/manifest/index.ts + 5 modules
var src_manifest = __webpack_require__(18567);
// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(86694);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(23437);
// EXTERNAL MODULE: ./src/utils/resolve_url.ts
var resolve_url = __webpack_require__(19860);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/extract_minimum_availability_time_offset.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * From 0 to N baseURL elements takes the minimum availabilityTimeOffset
 * possible.
 *
 * `0` if no baseURL was given (which means `no delay added`: coherent with how
 * this value is used).
 *
 * Taking the minimum time allow to simplify its processing:
 * Instead of having multiple URL each with a different pool of available
 * segment at a given instant, let's always consider every URLs by aligning with
 * the one with the most segment.
 *
 * @param {Array.<Object>} baseURLs
 */
function extractMinimumAvailabilityTimeOffset(baseURLs) {
    return baseURLs.length === 0 ?
        0 :
        baseURLs.reduce((acc, baseURL) => {
            var _a;
            return Math.min((_a = baseURL.attributes.availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0, acc);
        }, Infinity);
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/get_clock_offset.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Get difference between the server's clock, in milliseconds and the return of
 * the JS function `performance.now`.
 * This property allows to calculate the server time at any moment.
 *
 * `undefined` if we could not define such offset (in which case, you could have
 * to rely on the user's clock instead).
 *
 * For example, a response of 1000 would mean that performance.now() is 1 second
 * behind the server's time.
 * @param {string} serverClock
 * @returns {number|undefined}
 */
function getClockOffset(serverClock) {
    const httpOffset = Date.parse(serverClock) - performance.now();
    if (isNaN(httpOffset)) {
        log/* default.warn */.Z.warn("DASH Parser: Invalid clock received: ", serverClock);
        return undefined;
    }
    return httpOffset;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/get_http_utc-timing_url.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {Object} mpdIR
 * @returns {string|undefined}
 */
function getHTTPUTCTimingURL(mpdIR) {
    const UTCTimingHTTP = mpdIR.children.utcTimings
        .filter((utcTiming) => utcTiming.schemeIdUri === "urn:mpeg:dash:utc:http-iso:2014" &&
        utcTiming.value !== undefined);
    return UTCTimingHTTP.length > 0 ? UTCTimingHTTP[0].value :
        undefined;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_last_time_from_adaptation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns "last time of reference" from the adaptation given, considering a
 * dynamic content.
 * Undefined if a time could not be found.
 * Null if the Adaptation has no segments (it could be that it didn't started or
 * that it already finished for example).
 *
 * We consider the earliest last time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined|null}
 */
function getLastPositionFromAdaptation(adaptation) {
    const { representations } = adaptation;
    let min = null;
    for (let i = 0; i < representations.length; i++) {
        const lastPosition = representations[i].index.getLastPosition();
        if (lastPosition === undefined) { // we cannot tell
            return undefined;
        }
        if (lastPosition !== null) {
            min = min == null ? lastPosition :
                Math.min(min, lastPosition);
        }
    }
    if (min === null) { // It means that all positions were null === no segments (yet?)
        return null;
    }
    return min;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_maximum_position.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} manifest
 * @returns {number | undefined}
 */
function getMaximumPosition(periods) {
    for (let i = periods.length - 1; i >= 0; i--) {
        const periodAdaptations = periods[i].adaptations;
        const firstAudioAdaptationFromPeriod = periodAdaptations.audio === undefined ?
            undefined :
            periodAdaptations.audio[0];
        const firstVideoAdaptationFromPeriod = periodAdaptations.video === undefined ?
            undefined :
            periodAdaptations.video[0];
        if (firstAudioAdaptationFromPeriod !== undefined ||
            firstVideoAdaptationFromPeriod !== undefined) {
            // null == no segment
            let maximumAudioPosition = null;
            let maximumVideoPosition = null;
            if (firstAudioAdaptationFromPeriod !== undefined) {
                const lastPosition = getLastPositionFromAdaptation(firstAudioAdaptationFromPeriod);
                if (lastPosition === undefined) {
                    return undefined;
                }
                maximumAudioPosition = lastPosition;
            }
            if (firstVideoAdaptationFromPeriod !== undefined) {
                const lastPosition = getLastPositionFromAdaptation(firstVideoAdaptationFromPeriod);
                if (lastPosition === undefined) {
                    return undefined;
                }
                maximumVideoPosition = lastPosition;
            }
            if ((firstAudioAdaptationFromPeriod !== undefined &&
                maximumAudioPosition === null) ||
                (firstVideoAdaptationFromPeriod !== undefined &&
                    maximumVideoPosition === null)) {
                log/* default.info */.Z.info("Parser utils: found Period with no segment. ", "Going to previous one to calculate last position");
                return undefined;
            }
            if (maximumVideoPosition !== null) {
                if (maximumAudioPosition !== null) {
                    return Math.min(maximumAudioPosition, maximumVideoPosition);
                }
                return maximumVideoPosition;
            }
            if (maximumAudioPosition !== null) {
                return maximumAudioPosition;
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_first_time_from_adaptation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns "first time of reference" from the adaptation given, considering a
 * dynamic content.
 * Undefined if a time could not be found.
 *
 * We consider the latest first time from every representations in the given
 * adaptation.
 * @param {Object} adaptation
 * @returns {Number|undefined}
 */
function getFirstPositionFromAdaptation(adaptation) {
    const { representations } = adaptation;
    let max = null;
    for (let i = 0; i < representations.length; i++) {
        const firstPosition = representations[i].index.getFirstPosition();
        if (firstPosition === undefined) { // we cannot tell
            return undefined;
        }
        if (firstPosition !== null) {
            max = max == null ? firstPosition :
                Math.max(max, firstPosition);
        }
    }
    if (max === null) { // It means that all positions were null === no segments (yet?)
        return null;
    }
    return max;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/utils/get_minimum_position.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} manifest
 * @returns {number | undefined}
 */
function getMinimumPosition(periods) {
    for (let i = 0; i <= periods.length - 1; i++) {
        const periodAdaptations = periods[i].adaptations;
        const firstAudioAdaptationFromPeriod = periodAdaptations.audio === undefined ?
            undefined :
            periodAdaptations.audio[0];
        const firstVideoAdaptationFromPeriod = periodAdaptations.video === undefined ?
            undefined :
            periodAdaptations.video[0];
        if (firstAudioAdaptationFromPeriod !== undefined ||
            firstVideoAdaptationFromPeriod !== undefined) {
            // null == no segment
            let minimumAudioPosition = null;
            let minimumVideoPosition = null;
            if (firstAudioAdaptationFromPeriod !== undefined) {
                const firstPosition = getFirstPositionFromAdaptation(firstAudioAdaptationFromPeriod);
                if (firstPosition === undefined) {
                    return undefined;
                }
                minimumAudioPosition = firstPosition;
            }
            if (firstVideoAdaptationFromPeriod !== undefined) {
                const firstPosition = getFirstPositionFromAdaptation(firstVideoAdaptationFromPeriod);
                if (firstPosition === undefined) {
                    return undefined;
                }
                minimumVideoPosition = firstPosition;
            }
            if ((firstAudioAdaptationFromPeriod !== undefined &&
                minimumAudioPosition === null) ||
                (firstVideoAdaptationFromPeriod !== undefined &&
                    minimumVideoPosition === null)) {
                log/* default.info */.Z.info("Parser utils: found Period with no segment. ", "Going to next one to calculate first position");
                return undefined;
            }
            if (minimumVideoPosition !== null) {
                if (minimumAudioPosition !== null) {
                    return Math.max(minimumAudioPosition, minimumVideoPosition);
                }
                return minimumVideoPosition;
            }
            if (minimumAudioPosition !== null) {
                return minimumAudioPosition;
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/get_minimum_and_maximum_positions.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} periods
 * @returns {Array.<number>}
 */
function getMinimumAndMaximumPosition(periods) {
    if (periods.length === 0) {
        throw new Error("DASH Parser: no period available for a dynamic content");
    }
    return [getMinimumPosition(periods),
        getMaximumPosition(periods)];
}

// EXTERNAL MODULE: ./src/utils/base64.ts
var base64 = __webpack_require__(91282);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// XML-Schema
/* eslint-disable max-len */
// <http://standards.iso.org/ittf/PubliclyAvailableStandards/MPEG-DASH_schema_files/DASH-MPD.xsd>
/* eslint-enable max-len */



const iso8601Duration = /^P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;
const rangeRe = /([0-9]+)-([0-9]+)/;
/**
 * Parse MPD boolean attributes.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed boolean - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<Boolean | Error | null>}
 */
function parseBoolean(val, displayName) {
    if (val === "true") {
        return [true, null];
    }
    if (val === "false") {
        return [false, null];
    }
    const error = new MPDError(`\`${displayName}\` property is not a boolean value but "${val}"`);
    return [false, error];
}
/**
 * Parse MPD integer attributes.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed boolean - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<number | Error | null>}
 */
function parseMPDInteger(val, displayName) {
    const toInt = parseInt(val, 10);
    if (isNaN(toInt)) {
        const error = new MPDError(`\`${displayName}\` property is not an integer value but "${val}"`);
        return [null, error];
    }
    return [toInt, null];
}
/**
 * Parse MPD float attributes.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed boolean - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<number | Error | null>}
 */
function parseMPDFloat(val, displayName) {
    const toInt = parseFloat(val);
    if (isNaN(toInt)) {
        const error = new MPDError(`\`${displayName}\` property is not an integer value but "${val}"`);
        return [null, error];
    }
    return [toInt, null];
}
/**
 * Parse MPD attributes which are either integer or boolean values.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<Boolean | number | Error | null>}
 */
function parseIntOrBoolean(val, displayName) {
    if (val === "true") {
        return [true, null];
    }
    if (val === "false") {
        return [false, null];
    }
    const toInt = parseInt(val, 10);
    if (isNaN(toInt)) {
        const error = new MPDError(`\`${displayName}\` property is not a boolean nor an integer but "${val}"`);
        return [null, error];
    }
    return [toInt, null];
}
/**
 * Parse MPD date attributes.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<Date | null | Error>}
 */
function parseDateTime(val, displayName) {
    const parsed = Date.parse(val);
    if (isNaN(parsed)) {
        const error = new MPDError(`\`${displayName}\` is in an invalid date format: "${val}"`);
        return [null, error];
    }
    return [new Date(Date.parse(val)).getTime() / 1000, null];
}
/**
 * Parse MPD ISO8601 duration attributes into seconds.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val - The value to parse
 * @param {string} displayName - The name of the property. Used for error
 * formatting.
 * @returns {Array.<number | Error | null>}
 */
function parseDuration(val, displayName) {
    if (!(0,is_non_empty_string/* default */.Z)(val)) {
        const error = new MPDError(`\`${displayName}\` property is empty`);
        return [0, error];
    }
    const match = iso8601Duration.exec(val);
    if (match === null) {
        const error = new MPDError(`\`${displayName}\` property has an unrecognized format "${val}"`);
        return [null, error];
    }
    const duration = (parseFloat((0,is_non_empty_string/* default */.Z)(match[2]) ? match[2] :
        "0") * 365 * 24 * 60 * 60 +
        parseFloat((0,is_non_empty_string/* default */.Z)(match[4]) ? match[4] :
            "0") * 30 * 24 * 60 * 60 +
        parseFloat((0,is_non_empty_string/* default */.Z)(match[6]) ? match[6] :
            "0") * 24 * 60 * 60 +
        parseFloat((0,is_non_empty_string/* default */.Z)(match[8]) ? match[8] :
            "0") * 60 * 60 +
        parseFloat((0,is_non_empty_string/* default */.Z)(match[10]) ? match[10] :
            "0") * 60 +
        parseFloat((0,is_non_empty_string/* default */.Z)(match[12]) ? match[12] :
            "0"));
    return [duration, null];
}
/**
 * Parse MPD byterange attributes into arrays of two elements: the start and
 * the end.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val
 * @param {string} displayName
 * @returns {Array.<Array.<number> | Error | null>}
 */
function parseByteRange(val, displayName) {
    const match = rangeRe.exec(val);
    if (match === null) {
        const error = new MPDError(`\`${displayName}\` property has an unrecognized format "${val}"`);
        return [null, error];
    }
    else {
        return [[+match[1], +match[2]], null];
    }
}
/**
 * Parse MPD base64 attribute into an Uint8Array.
 * the end.
 *
 * The returned value is a tuple of two elements where:
 *   1. the first value is the parsed value - or `null` if we could not parse
 *      it
 *   2. the second value is a possible error encountered while parsing this
 *      value - set to `null` if no error was encountered.
 * @param {string} val
 * @param {string} displayName
 * @returns {Uint8Array | Error | null>}
 */
function parseBase64(val, displayName) {
    try {
        return [(0,base64/* base64ToBytes */.K)(val), null];
    }
    catch (_) {
        const error = new MPDError(`\`${displayName}\` is not a valid base64 string: "${val}"`);
        return [null, error];
    }
}
/**
 * @param {Element} root
 * @returns {Object}
 */
function parseScheme(root) {
    let schemeIdUri;
    let value;
    for (let i = 0; i < root.attributes.length; i++) {
        const attribute = root.attributes[i];
        switch (attribute.name) {
            case "schemeIdUri":
                schemeIdUri = attribute.value;
                break;
            case "value":
                value = attribute.value;
                break;
        }
    }
    return { schemeIdUri,
        value };
}
/**
 * Create a function to factorize the MPD parsing logic.
 * @param {Object} dest - The destination object which will contain the parsed
 * values.
 * @param {Array.<Error>} warnings - An array which will contain every parsing
 * error encountered.
 * @return {Function}
 */
function ValueParser(dest, warnings) {
    /**
     * Parse a single value and add it to the `dest` objects.
     * If an error arised while parsing, add it at the end of the `warnings` array.
     * @param {string} objKey - The key which will be added to the `dest` object.
     * @param {string} val - The value found in the MPD which we should parse.
     * @param {Function} parsingFn - The parsing function adapted for this value.
     * @param {string} displayName - The name of the key as it appears in the MPD.
     * This is used only in error formatting,
     */
    return function (val, { asKey, parser, dashName }) {
        const [parsingResult, parsingError] = parser(val, dashName);
        if (parsingError !== null) {
            log/* default.warn */.Z.warn(parsingError.message);
            warnings.push(parsingError);
        }
        if (parsingResult !== null) {
            dest[asKey] = parsingResult;
        }
    };
}
/**
 * Error arising when parsing the MPD.
 * @class MPDError
 * @extends Error
 */
class MPDError extends Error {
    /**
     * @param {string} message
     */
    constructor(message) {
        super();
        // @see https://stackoverflow.com/questions/41102060/typescript-extending-error-class
        Object.setPrototypeOf(this, MPDError.prototype);
        this.name = "MPDError";
        this.message = message;
    }
}


;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/BaseURL.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse an BaseURL element into an BaseURL intermediate
 * representation.
 * @param {Element} adaptationSetElement - The BaseURL root element.
 * @returns {Array.<Object|undefined>}
 */
function parseBaseURL(root) {
    const attributes = {};
    const value = root.textContent;
    const warnings = [];
    const parseValue = ValueParser(attributes, warnings);
    if (value === null || value.length === 0) {
        return [undefined, warnings];
    }
    for (let i = 0; i < root.attributes.length; i++) {
        const attribute = root.attributes[i];
        switch (attribute.name) {
            case "availabilityTimeOffset":
                if (attribute.value === "INF") {
                    attributes.availabilityTimeOffset = Infinity;
                }
                else {
                    parseValue(attribute.value, { asKey: "availabilityTimeOffset",
                        parser: parseMPDInteger,
                        dashName: "availabilityTimeOffset" });
                }
                break;
        }
    }
    return [{ value, attributes },
        warnings];
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentComponent.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Parse a "ContentComponent" Element in a DASH MPD.
 * @param {Element} root
 * @returns {Object}
 */
function parseContentComponent(root) {
    const ret = {};
    for (let i = 0; i < root.attributes.length; i++) {
        const attribute = root.attributes[i];
        switch (attribute.name) {
            case "id":
                ret.id = attribute.value;
                break;
            case "lang":
                ret.language = attribute.value;
                break;
            case "contentType":
                ret.contentType = attribute.value;
                break;
            case "par":
                ret.par = attribute.value;
                break;
        }
    }
    return ret;
}

// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(26332);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/ContentProtection.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {NodeList} contentProtectionChildren
 * @Returns {Object}
 */
function parseContentProtectionChildren(contentProtectionChildren) {
    const warnings = [];
    const cencPssh = [];
    for (let i = 0; i < contentProtectionChildren.length; i++) {
        if (contentProtectionChildren[i].nodeType === Node.ELEMENT_NODE) {
            const currentElement = contentProtectionChildren[i];
            if (currentElement.nodeName === "cenc:pssh") {
                const content = currentElement.textContent;
                if (content !== null && content.length > 0) {
                    const [toUint8Array, error] = parseBase64(content, "cenc:pssh");
                    if (error !== null) {
                        log/* default.warn */.Z.warn(error.message);
                        warnings.push(error);
                    }
                    if (toUint8Array !== null) {
                        cencPssh.push(toUint8Array);
                    }
                }
            }
        }
    }
    return [{ cencPssh }, warnings];
}
/**
 * @param {Element} root
 * @returns {Object}
 */
function parseContentProtectionAttributes(root) {
    const ret = {};
    for (let i = 0; i < root.attributes.length; i++) {
        const attribute = root.attributes[i];
        switch (attribute.name) {
            case "schemeIdUri":
                ret.schemeIdUri = attribute.value;
                break;
            case "value":
                ret.value = attribute.value;
                break;
            case "cenc:default_KID":
                ret.keyId = (0,string_parsing/* hexToBytes */.nr)(attribute.value.replace(/-/g, ""));
        }
    }
    return ret;
}
/**
 * @param {Element} contentProtectionElement
 * @returns {Object}
 */
function parseContentProtection(contentProtectionElement) {
    const [children, childrenWarnings] = parseContentProtectionChildren(contentProtectionElement.childNodes);
    const attributes = parseContentProtectionAttributes(contentProtectionElement);
    return [{ children, attributes }, childrenWarnings];
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Initialization.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Element} root
 * @returns {Array.<Object>}
 */
function parseInitialization(root) {
    const parsedInitialization = {};
    const warnings = [];
    const parseValue = ValueParser(parsedInitialization, warnings);
    for (let i = 0; i < root.attributes.length; i++) {
        const attribute = root.attributes[i];
        switch (attribute.name) {
            case "range":
                parseValue(attribute.value, { asKey: "range",
                    parser: parseByteRange,
                    dashName: "range" });
                break;
            case "sourceURL":
                parsedInitialization.media = attribute.value;
                break;
        }
    }
    return [parsedInitialization, warnings];
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentBase.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Parse a SegmentBase element into a SegmentBase intermediate representation.
 * @param {Element} root - The SegmentBase root element.
 * @returns {Array}
 */
function parseSegmentBase(root) {
    const attributes = {};
    let warnings = [];
    const parseValue = ValueParser(attributes, warnings);
    const segmentBaseChildren = root.childNodes;
    for (let i = 0; i < segmentBaseChildren.length; i++) {
        if (segmentBaseChildren[i].nodeType === Node.ELEMENT_NODE) {
            const currentNode = segmentBaseChildren[i];
            if (currentNode.nodeName === "Initialization") {
                const [initialization, initializationWarnings] = parseInitialization(currentNode);
                attributes.initialization = initialization;
                warnings = warnings.concat(initializationWarnings);
            }
        }
    }
    for (let i = 0; i < root.attributes.length; i++) {
        const attr = root.attributes[i];
        switch (attr.name) {
            case "timescale":
                parseValue(attr.value, { asKey: "timescale",
                    parser: parseMPDInteger,
                    dashName: "timescale" });
                break;
            case "presentationTimeOffset":
                parseValue(attr.value, { asKey: "presentationTimeOffset",
                    parser: parseMPDFloat,
                    dashName: "presentationTimeOffset" });
                break;
            case "indexRange":
                parseValue(attr.value, { asKey: "indexRange",
                    parser: parseByteRange,
                    dashName: "indexRange" });
                break;
            case "indexRangeExact":
                parseValue(attr.value, { asKey: "indexRangeExact",
                    parser: parseBoolean,
                    dashName: "indexRangeExact" });
                break;
            case "availabilityTimeOffset":
                parseValue(attr.value, { asKey: "availabilityTimeOffset",
                    parser: parseMPDFloat,
                    dashName: "availabilityTimeOffset" });
                break;
            case "availabilityTimeComplete":
                parseValue(attr.value, { asKey: "availabilityTimeComplete",
                    parser: parseBoolean,
                    dashName: "availabilityTimeComplete" });
                break;
            case "duration":
                parseValue(attr.value, { asKey: "duration",
                    parser: parseMPDInteger,
                    dashName: "duration" });
                break;
            case "startNumber":
                parseValue(attr.value, { asKey: "startNumber",
                    parser: parseMPDInteger,
                    dashName: "startNumber" });
                break;
        }
    }
    return [attributes, warnings];
}

// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(53811);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentURL.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a SegmentURL element into a SegmentURL intermediate
 * representation.
 * @param {Element} root - The SegmentURL root element.
 * @returns {Array}
 */
function parseSegmentURL(root) {
    const parsedSegmentURL = {};
    const warnings = [];
    const parseValue = ValueParser(parsedSegmentURL, warnings);
    for (let i = 0; i < root.attributes.length; i++) {
        const attribute = root.attributes[i];
        switch (attribute.name) {
            case "media":
                parsedSegmentURL.media = attribute.value;
                break;
            case "indexRange":
                parseValue(attribute.value, { asKey: "indexRange",
                    parser: parseByteRange,
                    dashName: "indexRange" });
                break;
            case "index":
                parsedSegmentURL.index = attribute.value;
                break;
            case "mediaRange":
                parseValue(attribute.value, { asKey: "mediaRange",
                    parser: parseByteRange,
                    dashName: "mediaRange" });
                break;
        }
    }
    return [parsedSegmentURL, warnings];
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentList.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Element} root
 * @returns {Array}
 */
function parseSegmentList(root) {
    const [base, baseWarnings] = parseSegmentBase(root);
    let warnings = baseWarnings;
    const list = [];
    const segmentListChildren = root.childNodes;
    for (let i = 0; i < segmentListChildren.length; i++) {
        if (segmentListChildren[i].nodeType === Node.ELEMENT_NODE) {
            const currentNode = segmentListChildren[i];
            if (currentNode.nodeName === "SegmentURL") {
                const [segmentURL, segmentURLWarnings] = parseSegmentURL(currentNode);
                list.push(segmentURL);
                warnings = warnings.concat(segmentURLWarnings);
            }
        }
    }
    const baseDuration = base.duration;
    if (baseDuration == null) {
        throw new Error("Invalid SegmentList: no duration");
    }
    const ret = (0,object_assign/* default */.Z)(base, { list,
        // Ugly but TS is too dumb there
        duration: baseDuration });
    return [ret, warnings];
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTimeline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {Element} root
 * @returns {Function}
 */
function createSegmentTimelineParser(root) {
    let result = null;
    return function () {
        if (result === null) {
            const elements = root.getElementsByTagName("S");
            result = elements;
            return elements;
        }
        return result;
    };
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/SegmentTemplate.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Parse initialization attribute found in SegmentTemplateTemplate to
 * correspond to the initialization found in a regular segmentBase.
 * @param {string} attrValue
 * @returns {Object}
 */
function parseInitializationAttribute(attrValue) {
    return { media: attrValue };
}
/**
 * Parse a SegmentTemplate element into a SegmentTemplate intermediate
 * representation.
 * @param {Element} root - The SegmentTemplate root element.
 * @returns {Array}
 */
function parseSegmentTemplate(root) {
    const [base, segmentBaseWarnings] = parseSegmentBase(root);
    const warnings = segmentBaseWarnings;
    let timelineParser;
    // First look for a possible SegmentTimeline
    for (let i = 0; i < root.childNodes.length; i++) {
        if (root.childNodes[i].nodeType === Node.ELEMENT_NODE) {
            const currentNode = root.childNodes[i];
            if (currentNode.nodeName === "SegmentTimeline") {
                timelineParser = createSegmentTimelineParser(currentNode);
            }
        }
    }
    const ret = (0,object_assign/* default */.Z)({}, base, { duration: base.duration,
        timelineParser });
    const parseValue = ValueParser(ret, warnings);
    for (let i = 0; i < root.attributes.length; i++) {
        const attribute = root.attributes[i];
        switch (attribute.nodeName) {
            case "initialization":
                if (ret.initialization == null) {
                    ret.initialization = parseInitializationAttribute(attribute.value);
                }
                break;
            case "index":
                ret.index = attribute.value;
                break;
            case "availabilityTimeOffset":
                if (attribute.value === "INF") {
                    ret.availabilityTimeOffset = Infinity;
                }
                parseValue(attribute.value, { asKey: "availabilityTimeOffset",
                    parser: parseMPDInteger,
                    dashName: "availabilityTimeOffset" });
                break;
            case "media":
                ret.media = attribute.value;
                break;
            case "bitstreamSwitching":
                parseValue(attribute.value, { asKey: "bitstreamSwitching",
                    parser: parseBoolean,
                    dashName: "bitstreamSwitching" });
                break;
        }
    }
    return [ret, warnings];
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Representation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @param {NodeList} representationChildren
 * @returns {Object}
 */
function parseRepresentationChildren(representationChildren) {
    const children = {
        baseURLs: [],
    };
    let warnings = [];
    for (let i = 0; i < representationChildren.length; i++) {
        if (representationChildren[i].nodeType === Node.ELEMENT_NODE) {
            const currentElement = representationChildren[i];
            switch (currentElement.nodeName) {
                case "BaseURL":
                    const [baseURLObj, baseURLWarnings] = parseBaseURL(currentElement);
                    if (baseURLObj !== undefined) {
                        children.baseURLs.push(baseURLObj);
                    }
                    warnings = warnings.concat(baseURLWarnings);
                    break;
                case "InbandEventStream":
                    if (children.inbandEventStreams === undefined) {
                        children.inbandEventStreams = [];
                    }
                    children.inbandEventStreams.push(parseScheme(currentElement));
                    break;
                case "SegmentBase":
                    const [segmentBase, segmentBaseWarnings] = parseSegmentBase(currentElement);
                    children.segmentBase = segmentBase;
                    if (segmentBaseWarnings.length > 0) {
                        warnings = warnings.concat(segmentBaseWarnings);
                    }
                    break;
                case "SegmentList":
                    const [segmentList, segmentListWarnings] = parseSegmentList(currentElement);
                    warnings = warnings.concat(segmentListWarnings);
                    children.segmentList = segmentList;
                    break;
                case "SegmentTemplate":
                    const [segmentTemplate, segmentTemplateWarnings] = parseSegmentTemplate(currentElement);
                    warnings = warnings.concat(segmentTemplateWarnings);
                    children.segmentTemplate = segmentTemplate;
                    break;
            }
        }
    }
    return [children, warnings];
}
/**
 * @param {Element} representationElement
 * @returns {Array}
 */
function parseRepresentationAttributes(representationElement) {
    const attributes = {};
    const warnings = [];
    const parseValue = ValueParser(attributes, warnings);
    for (let i = 0; i < representationElement.attributes.length; i++) {
        const attr = representationElement.attributes[i];
        switch (attr.name) {
            case "audioSamplingRate":
                attributes.audioSamplingRate = attr.value;
                break;
            case "bandwidth":
                parseValue(attr.value, { asKey: "bitrate",
                    parser: parseMPDInteger,
                    dashName: "bandwidth" });
                break;
            case "codecs":
                attributes.codecs = attr.value;
                break;
            case "codingDependency":
                parseValue(attr.value, { asKey: "codingDependency",
                    parser: parseBoolean,
                    dashName: "codingDependency" });
                break;
            case "frameRate":
                attributes.frameRate = attr.value;
                break;
            case "height":
                parseValue(attr.value, { asKey: "height",
                    parser: parseMPDInteger,
                    dashName: "height" });
                break;
            case "id":
                attributes.id = attr.value;
                break;
            case "maxPlayoutRate":
                parseValue(attr.value, { asKey: "maxPlayoutRate",
                    parser: parseMPDFloat,
                    dashName: "maxPlayoutRate" });
                break;
            case "maximumSAPPeriod":
                parseValue(attr.value, { asKey: "maximumSAPPeriod",
                    parser: parseMPDFloat,
                    dashName: "maximumSAPPeriod" });
                break;
            case "mimeType":
                attributes.mimeType = attr.value;
                break;
            case "profiles":
                attributes.profiles = attr.value;
                break;
            case "qualityRanking":
                parseValue(attr.value, { asKey: "qualityRanking",
                    parser: parseMPDInteger,
                    dashName: "qualityRanking" });
                break;
            case "segmentProfiles":
                attributes.segmentProfiles = attr.value;
                break;
            case "width":
                parseValue(attr.value, { asKey: "width",
                    parser: parseMPDInteger,
                    dashName: "width" });
                break;
        }
    }
    if (attributes.bitrate === undefined) {
        warnings.push(new MPDError("No bitrate found on a Representation"));
    }
    return [attributes, warnings];
}
/**
 * @param {Element} representationElement
 * @returns {Array}
 */
function createRepresentationIntermediateRepresentation(representationElement) {
    const [children, childrenWarnings] = parseRepresentationChildren(representationElement.childNodes);
    const [attributes, attrsWarnings] = parseRepresentationAttributes(representationElement);
    const warnings = childrenWarnings.concat(attrsWarnings);
    return [{ children, attributes }, warnings];
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/AdaptationSet.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Parse child nodes from an AdaptationSet.
 * @param {NodeList} adaptationSetChildren - The AdaptationSet child nodes.
 * @returns {Array.<Object>}
 */
function parseAdaptationSetChildren(adaptationSetChildren) {
    const children = {
        baseURLs: [],
        representations: [],
    };
    const contentProtections = [];
    let warnings = [];
    for (let i = 0; i < adaptationSetChildren.length; i++) {
        if (adaptationSetChildren[i].nodeType === Node.ELEMENT_NODE) {
            const currentElement = adaptationSetChildren[i];
            switch (currentElement.nodeName) {
                case "Accessibility":
                    if (children.accessibilities === undefined) {
                        children.accessibilities = [parseScheme(currentElement)];
                    }
                    else {
                        children.accessibilities.push(parseScheme(currentElement));
                    }
                    break;
                case "BaseURL":
                    const [baseURLObj, baseURLWarnings] = parseBaseURL(currentElement);
                    if (baseURLObj !== undefined) {
                        children.baseURLs.push(baseURLObj);
                    }
                    if (baseURLWarnings.length > 0) {
                        warnings = warnings.concat(baseURLWarnings);
                    }
                    break;
                case "ContentComponent":
                    children.contentComponent = parseContentComponent(currentElement);
                    break;
                case "EssentialProperty":
                    if (children.essentialProperties == null) {
                        children.essentialProperties = [parseScheme(currentElement)];
                    }
                    else {
                        children.essentialProperties.push(parseScheme(currentElement));
                    }
                    break;
                case "InbandEventStream":
                    if (children.inbandEventStreams === undefined) {
                        children.inbandEventStreams = [];
                    }
                    children.inbandEventStreams.push(parseScheme(currentElement));
                    break;
                case "Representation":
                    const [representation, representationWarnings] = createRepresentationIntermediateRepresentation(currentElement);
                    children.representations.push(representation);
                    if (representationWarnings.length > 0) {
                        warnings = warnings.concat(representationWarnings);
                    }
                    break;
                case "Role":
                    if (children.roles == null) {
                        children.roles = [parseScheme(currentElement)];
                    }
                    else {
                        children.roles.push(parseScheme(currentElement));
                    }
                    break;
                case "SupplementalProperty":
                    if (children.supplementalProperties == null) {
                        children.supplementalProperties = [parseScheme(currentElement)];
                    }
                    else {
                        children.supplementalProperties.push(parseScheme(currentElement));
                    }
                    break;
                case "SegmentBase":
                    const [segmentBase, segmentBaseWarnings] = parseSegmentBase(currentElement);
                    children.segmentBase = segmentBase;
                    if (segmentBaseWarnings.length > 0) {
                        warnings = warnings.concat(segmentBaseWarnings);
                    }
                    break;
                case "SegmentList":
                    const [segmentList, segmentListWarnings] = parseSegmentList(currentElement);
                    children.segmentList = segmentList;
                    if (segmentListWarnings.length > 0) {
                        warnings = warnings.concat(segmentListWarnings);
                    }
                    break;
                case "SegmentTemplate":
                    const [segmentTemplate, segmentTemplateWarnings] = parseSegmentTemplate(currentElement);
                    children.segmentTemplate = segmentTemplate;
                    if (segmentTemplateWarnings.length > 0) {
                        warnings = warnings.concat(segmentTemplateWarnings);
                    }
                    break;
                case "ContentProtection":
                    const [contentProtection, contentProtectionWarnings] = parseContentProtection(currentElement);
                    if (contentProtectionWarnings.length > 0) {
                        warnings = warnings.concat(contentProtectionWarnings);
                    }
                    if (contentProtection !== undefined) {
                        contentProtections.push(contentProtection);
                    }
                    break;
                // case "Rating":
                //   children.rating = currentElement;
                //   break;
                // case "Viewpoint":
                //   children.viewpoint = currentElement;
                //   break;
            }
        }
    }
    if (contentProtections.length > 0) {
        children.contentProtections = contentProtections;
    }
    return [children, warnings];
}
/**
 * Parse every attributes from an AdaptationSet root element into a simple JS
 * object.
 * @param {Element} root - The AdaptationSet root element.
 * @returns {Array.<Object>}
 */
function parseAdaptationSetAttributes(root) {
    const parsedAdaptation = {};
    const warnings = [];
    const parseValue = ValueParser(parsedAdaptation, warnings);
    for (let i = 0; i < root.attributes.length; i++) {
        const attribute = root.attributes[i];
        switch (attribute.name) {
            case "id":
                parsedAdaptation.id = attribute.value;
                break;
            case "group":
                parseValue(attribute.value, { asKey: "group",
                    parser: parseMPDInteger,
                    dashName: "group" });
                break;
            case "lang":
                parsedAdaptation.language = attribute.value;
                break;
            case "contentType":
                parsedAdaptation.contentType = attribute.value;
                break;
            case "par":
                parsedAdaptation.par = attribute.value;
                break;
            case "minBandwidth":
                parseValue(attribute.value, { asKey: "minBitrate",
                    parser: parseMPDInteger,
                    dashName: "minBandwidth" });
                break;
            case "maxBandwidth":
                parseValue(attribute.value, { asKey: "maxBitrate",
                    parser: parseMPDInteger,
                    dashName: "maxBandwidth" });
                break;
            case "minWidth":
                parseValue(attribute.value, { asKey: "minWidth",
                    parser: parseMPDInteger,
                    dashName: "minWidth" });
                break;
            case "maxWidth":
                parseValue(attribute.value, { asKey: "maxWidth",
                    parser: parseMPDInteger,
                    dashName: "maxWidth" });
                break;
            case "minHeight":
                parseValue(attribute.value, { asKey: "minHeight",
                    parser: parseMPDInteger,
                    dashName: "minHeight" });
                break;
            case "maxHeight":
                parseValue(attribute.value, { asKey: "maxHeight",
                    parser: parseMPDInteger,
                    dashName: "maxHeight" });
                break;
            case "minFrameRate":
                {
                    parsedAdaptation.minFrameRate = attribute.value;
                }
                break;
            case "maxFrameRate":
                parsedAdaptation.maxFrameRate = attribute.value;
                break;
            case "selectionPriority":
                parseValue(attribute.value, { asKey: "selectionPriority",
                    parser: parseMPDInteger,
                    dashName: "selectionPriority" });
                break;
            case "segmentAlignment":
                parseValue(attribute.value, { asKey: "segmentAlignment",
                    parser: parseIntOrBoolean,
                    dashName: "segmentAlignment" });
                break;
            case "subsegmentAlignment":
                parseValue(attribute.value, { asKey: "subsegmentAlignment",
                    parser: parseIntOrBoolean,
                    dashName: "subsegmentAlignment" });
                break;
            case "bitstreamSwitching":
                parseValue(attribute.value, { asKey: "bitstreamSwitching",
                    parser: parseBoolean,
                    dashName: "bitstreamSwitching" });
                break;
            case "audioSamplingRate":
                parsedAdaptation.audioSamplingRate = attribute.value;
                break;
            case "codecs":
                parsedAdaptation.codecs = attribute.value;
                break;
            case "codingDependency":
                parseValue(attribute.value, { asKey: "codingDependency",
                    parser: parseBoolean,
                    dashName: "codingDependency" });
                break;
            case "frameRate":
                parsedAdaptation.frameRate = attribute.value;
                break;
            case "height":
                parseValue(attribute.value, { asKey: "height",
                    parser: parseMPDInteger,
                    dashName: "height" });
                break;
            case "maxPlayoutRate":
                parseValue(attribute.value, { asKey: "maxPlayoutRate",
                    parser: parseMPDFloat,
                    dashName: "maxPlayoutRate" });
                break;
            case "maximumSAPPeriod":
                parseValue(attribute.value, { asKey: "maximumSAPPeriod",
                    parser: parseMPDFloat,
                    dashName: "maximumSAPPeriod" });
                break;
            case "mimeType":
                parsedAdaptation.mimeType = attribute.value;
                break;
            case "profiles":
                parsedAdaptation.profiles = attribute.value;
                break;
            case "segmentProfiles":
                parsedAdaptation.segmentProfiles = attribute.value;
                break;
            case "width":
                parseValue(attribute.value, { asKey: "width",
                    parser: parseMPDInteger,
                    dashName: "width" });
                break;
        }
    }
    return [parsedAdaptation, warnings];
}
/**
 * Parse an AdaptationSet element into an AdaptationSet intermediate
 * representation.
 * @param {Element} adaptationSetElement - The AdaptationSet root element.
 * @returns {Array.<Object>}
 */
function createAdaptationSetIntermediateRepresentation(adaptationSetElement) {
    const childNodes = adaptationSetElement.childNodes;
    const [children, childrenWarnings] = parseAdaptationSetChildren(childNodes);
    const [attributes, attrsWarnings] = parseAdaptationSetAttributes(adaptationSetElement);
    const warnings = childrenWarnings.concat(attrsWarnings);
    return [{ children, attributes }, warnings];
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/EventStream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse the EventStream node to extract Event nodes and their
 * content.
 * @param {Element} element
 */
function parseEventStream(element) {
    var _a;
    const streamEvents = [];
    const attributes = { timescale: 1 };
    const warnings = [];
    const parseValue = ValueParser(attributes, warnings);
    for (let i = 0; i < element.attributes.length; i++) {
        const attribute = element.attributes[i];
        switch (attribute.name) {
            case "schemeIdUri":
                attributes.schemeId = attribute.value;
                break;
            case "timescale":
                parseValue(attribute.value, { asKey: "timescale",
                    parser: parseMPDInteger,
                    dashName: "timescale" });
                break;
            case "value":
                attributes.value = attribute.value;
                break;
            default:
                break;
        }
    }
    for (let k = 0; k < element.childNodes.length; k++) {
        const node = element.childNodes[k];
        const streamEvent = { id: undefined,
            eventPresentationTime: 0,
            duration: undefined,
            timescale: attributes.timescale, data: { type: "dash-event-stream",
                value: { schemeIdUri: (_a = attributes.schemeId) !== null && _a !== void 0 ? _a : "", timescale: attributes.timescale, element: node } } };
        const parseEventValue = ValueParser(streamEvent, warnings);
        if (node.nodeName === "Event" &&
            node.nodeType === Node.ELEMENT_NODE) {
            const eventAttributes = node.attributes;
            for (let j = 0; j < eventAttributes.length; j++) {
                const attribute = eventAttributes[j];
                switch (attribute.name) {
                    case "presentationTime":
                        parseEventValue(attribute.value, { asKey: "eventPresentationTime",
                            parser: parseMPDInteger,
                            dashName: "presentationTime" });
                        break;
                    case "duration":
                        parseEventValue(attribute.value, { asKey: "duration",
                            parser: parseMPDInteger,
                            dashName: "duration" });
                        break;
                    case "id":
                        streamEvent.id = attribute.value;
                        break;
                    default:
                        break;
                }
            }
            streamEvents.push(streamEvent);
        }
    }
    return [streamEvents, warnings];
}
/* harmony default export */ const EventStream = (parseEventStream);

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/Period.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @param {NodeList} periodChildren
 * @returns {Array}
 */
function parsePeriodChildren(periodChildren) {
    const baseURLs = [];
    const adaptations = [];
    let segmentTemplate;
    let warnings = [];
    const streamEvents = [];
    for (let i = 0; i < periodChildren.length; i++) {
        if (periodChildren[i].nodeType === Node.ELEMENT_NODE) {
            const currentElement = periodChildren[i];
            switch (currentElement.nodeName) {
                case "BaseURL":
                    const [baseURLObj, baseURLWarnings] = parseBaseURL(currentElement);
                    if (baseURLObj !== undefined) {
                        baseURLs.push(baseURLObj);
                    }
                    warnings = warnings.concat(baseURLWarnings);
                    break;
                case "AdaptationSet":
                    const [adaptation, adaptationWarnings] = createAdaptationSetIntermediateRepresentation(currentElement);
                    adaptations.push(adaptation);
                    warnings = warnings.concat(adaptationWarnings);
                    break;
                case "EventStream":
                    const [newStreamEvents, eventStreamWarnings] = EventStream(currentElement);
                    streamEvents.push(...newStreamEvents);
                    warnings = warnings.concat(eventStreamWarnings);
                    break;
                case "SegmentTemplate":
                    const [parsedSegmentTemplate, segmentTemplateWarnings] = parseSegmentTemplate(currentElement);
                    segmentTemplate = parsedSegmentTemplate;
                    if (segmentTemplateWarnings.length > 0) {
                        warnings = warnings.concat(segmentTemplateWarnings);
                    }
                    break;
            }
        }
    }
    return [{ baseURLs, adaptations, streamEvents, segmentTemplate }, warnings];
}
/**
 * @param {Element} periodElement
 * @returns {Array}
 */
function parsePeriodAttributes(periodElement) {
    const res = {};
    const warnings = [];
    const parseValue = ValueParser(res, warnings);
    for (let i = 0; i < periodElement.attributes.length; i++) {
        const attr = periodElement.attributes[i];
        switch (attr.name) {
            case "id":
                res.id = attr.value;
                break;
            case "start":
                parseValue(attr.value, { asKey: "start",
                    parser: parseDuration,
                    dashName: "start" });
                break;
            case "duration":
                parseValue(attr.value, { asKey: "duration",
                    parser: parseDuration,
                    dashName: "duration" });
                break;
            case "bitstreamSwitching":
                parseValue(attr.value, { asKey: "bitstreamSwitching",
                    parser: parseBoolean,
                    dashName: "bitstreamSwitching" });
                break;
            case "xlink:href":
                res.xlinkHref = attr.value;
                break;
            case "xlink:actuate":
                res.xlinkActuate = attr.value;
                break;
        }
    }
    return [res, warnings];
}
/**
 * @param {Element} periodElement
 * @returns {Array}
 */
function createPeriodIntermediateRepresentation(periodElement) {
    const [children, childrenWarnings] = parsePeriodChildren(periodElement.childNodes);
    const [attributes, attrsWarnings] = parsePeriodAttributes(periodElement);
    const warnings = childrenWarnings.concat(attrsWarnings);
    return [{ children, attributes }, warnings];
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/node_parsers/MPD.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse children of the MPD's root into a simple object.
 * @param {NodeList} mpdChildren
 * @returns {Array.<Object>}
 */
function parseMPDChildren(mpdChildren) {
    const baseURLs = [];
    const locations = [];
    const periods = [];
    const utcTimings = [];
    let warnings = [];
    for (let i = 0; i < mpdChildren.length; i++) {
        if (mpdChildren[i].nodeType === Node.ELEMENT_NODE) {
            const currentNode = mpdChildren[i];
            switch (currentNode.nodeName) {
                case "BaseURL":
                    const [baseURLObj, baseURLWarnings] = parseBaseURL(currentNode);
                    if (baseURLObj !== undefined) {
                        baseURLs.push(baseURLObj);
                    }
                    warnings = warnings.concat(baseURLWarnings);
                    break;
                case "Location":
                    locations.push(currentNode.textContent === null ?
                        "" :
                        currentNode.textContent);
                    break;
                case "Period":
                    const [period, periodWarnings] = createPeriodIntermediateRepresentation(currentNode);
                    periods.push(period);
                    warnings = warnings.concat(periodWarnings);
                    break;
                case "UTCTiming":
                    const utcTiming = parseScheme(currentNode);
                    utcTimings.push(utcTiming);
                    break;
            }
        }
    }
    return [{ baseURLs, locations, periods, utcTimings },
        warnings];
}
/**
 * @param {Element} root
 * @returns {Array.<Object>}
 */
function parseMPDAttributes(root) {
    const res = {};
    const warnings = [];
    const parseValue = ValueParser(res, warnings);
    for (let i = 0; i < root.attributes.length; i++) {
        const attribute = root.attributes[i];
        switch (attribute.name) {
            case "id":
                res.id = attribute.value;
                break;
            case "profiles":
                res.profiles = attribute.value;
                break;
            case "type":
                res.type = attribute.value;
                break;
            case "availabilityStartTime":
                parseValue(attribute.value, { asKey: "availabilityStartTime",
                    parser: parseDateTime,
                    dashName: "availabilityStartTime" });
                break;
            case "availabilityEndTime":
                parseValue(attribute.value, { asKey: "availabilityEndTime",
                    parser: parseDateTime,
                    dashName: "availabilityEndTime" });
                break;
            case "publishTime":
                parseValue(attribute.value, { asKey: "publishTime",
                    parser: parseDateTime,
                    dashName: "publishTime" });
                break;
            case "mediaPresentationDuration":
                parseValue(attribute.value, { asKey: "duration",
                    parser: parseDuration,
                    dashName: "mediaPresentationDuration" });
                break;
            case "minimumUpdatePeriod":
                parseValue(attribute.value, { asKey: "minimumUpdatePeriod",
                    parser: parseDuration,
                    dashName: "minimumUpdatePeriod" });
                break;
            case "minBufferTime":
                parseValue(attribute.value, { asKey: "minBufferTime",
                    parser: parseDuration,
                    dashName: "minBufferTime" });
                break;
            case "timeShiftBufferDepth":
                parseValue(attribute.value, { asKey: "timeShiftBufferDepth",
                    parser: parseDuration,
                    dashName: "timeShiftBufferDepth" });
                break;
            case "suggestedPresentationDelay":
                parseValue(attribute.value, { asKey: "suggestedPresentationDelay",
                    parser: parseDuration,
                    dashName: "suggestedPresentationDelay" });
                break;
            case "maxSegmentDuration":
                parseValue(attribute.value, { asKey: "maxSegmentDuration",
                    parser: parseDuration,
                    dashName: "maxSegmentDuration" });
                break;
            case "maxSubsegmentDuration":
                parseValue(attribute.value, { asKey: "maxSubsegmentDuration",
                    parser: parseDuration,
                    dashName: "maxSubsegmentDuration" });
                break;
        }
    }
    return [res, warnings];
}
/**
 * @param {Element} root
 * @returns {Array.<Object>}
 */
function createMPDIntermediateRepresentation(root) {
    const [children, childrenWarnings] = parseMPDChildren(root.childNodes);
    const [attributes, attrsWarnings] = parseMPDAttributes(root);
    const warnings = childrenWarnings.concat(attrsWarnings);
    return [{ children, attributes }, warnings];
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_availability_start_time.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns the base time of the Manifest.
 * @param {Object} rootAttributes
 * @param {number|undefined}
 */
function parseAvailabilityStartTime(rootAttributes, referenceDateTime) {
    if (rootAttributes.type !== "dynamic") {
        return 0;
    }
    if (rootAttributes.availabilityStartTime == null) {
        return referenceDateTime == null ? 0 : referenceDateTime;
    }
    return rootAttributes.availabilityStartTime;
}

// EXTERNAL MODULE: ./src/utils/flat_map.ts
var flat_map = __webpack_require__(7536);
// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(14638);
// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(86293);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/flatten_overlapping_periods.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Avoid periods to overlap.
 *
 * According to DASH guidelines, if a period has media duration longer than
 * the distance between the start of this period and the start of the next period,
 * use of start times implies that the client will start the playout of the next
 * period at the time stated, rather than finishing the playout of the last period.
 *
 * Even if that case if defined when period last(s) segment(s) is/are a bit longer,
 * it can be meaningful when two periods are overlapping. We will always shorten
 * the first period, and even erase it if its duration is equal to zero.
 *
 * Example (Periods are numbered under their manifest order) :
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][ Period 3 ]
 *             [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [ Period 1 ][  2  ][ Period 3 ]
 *                  [ Period 3 ]
 *
 * [ Period 1 ][ Period 2 ]       ------>  [  1  ][      Period 3     ]
 *        [      Period 3     ]
 *
 * @param {Array.<Object>} parsedPeriods
 * @return {Array.<Object>}
 */
function flattenOverlappingPeriods(parsedPeriods) {
    if (parsedPeriods.length === 0) {
        return [];
    }
    const flattenedPeriods = [parsedPeriods[0]];
    for (let i = 1; i < parsedPeriods.length; i++) {
        const parsedPeriod = parsedPeriods[i];
        let lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];
        while (lastFlattenedPeriod.duration == null ||
            (lastFlattenedPeriod.start + lastFlattenedPeriod.duration) > parsedPeriod.start) {
            log/* default.warn */.Z.warn("DASH: Updating overlapping Periods.", lastFlattenedPeriod, parsedPeriod);
            lastFlattenedPeriod.duration = parsedPeriod.start - lastFlattenedPeriod.start;
            lastFlattenedPeriod.end = parsedPeriod.start;
            if (lastFlattenedPeriod.duration <= 0) {
                flattenedPeriods.pop();
                lastFlattenedPeriod = flattenedPeriods[flattenedPeriods.length - 1];
            }
        }
        flattenedPeriods.push(parsedPeriod);
    }
    return flattenedPeriods;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/get_periods_time_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Get periods time information from current, next and previous
 * periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} manifestInfos
 * @return {Array.<Object>}
 */
function getPeriodsTimeInformation(periodsIR, manifestInfos) {
    const periodsTimeInformation = [];
    periodsIR.forEach((currentPeriod, i) => {
        let periodStart;
        if (currentPeriod.attributes.start != null) {
            periodStart = currentPeriod.attributes.start;
        }
        else {
            if (i === 0) {
                periodStart = (!manifestInfos.isDynamic ||
                    manifestInfos.availabilityStartTime == null) ?
                    0 :
                    manifestInfos.availabilityStartTime;
            }
            else {
                // take time information from previous period
                const prevPeriodInfos = periodsTimeInformation[periodsTimeInformation.length - 1];
                if (prevPeriodInfos != null && prevPeriodInfos.periodEnd != null) {
                    periodStart = prevPeriodInfos.periodEnd;
                }
                else {
                    throw new Error("Missing start time when parsing periods.");
                }
            }
        }
        let periodDuration;
        const nextPeriod = periodsIR[i + 1];
        if (currentPeriod.attributes.duration != null) {
            periodDuration = currentPeriod.attributes.duration;
        }
        else if (i === periodsIR.length - 1) {
            periodDuration = manifestInfos.duration;
        }
        else if (nextPeriod.attributes.start != null) {
            periodDuration = nextPeriod.attributes.start - periodStart;
        }
        const periodEnd = periodDuration != null ? (periodStart + periodDuration) :
            undefined;
        periodsTimeInformation.push({ periodStart,
            periodDuration,
            periodEnd });
    });
    return periodsTimeInformation;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/manifest_bounds_calculator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This class allows to easily calculate the first and last available positions
 * in a content at any time.
 *
 * That task can be an hard for dynamic DASH contents: it depends on a
 * `timeShiftBufferDepth` defined in the MPD and on the maximum possible
 * position.
 *
 * The latter can come from either a clock synchronization mechanism or the
 * indexing schemes (e.g. SegmentTemplate, SegmentTimeline etc.) of the last
 * Periods.
 * As such, it might only be known once a large chunk of the MPD has already
 * been parsed.
 *
 * By centralizing the manifest bounds calculation in this class and by giving
 * an instance of it to each parsed elements which might depend on it, we
 * ensure that we can provide it once it is known to every one of those
 * elements without needing to parse a second time the MPD.
 * @class ManifestBoundsCalculator
 */
class ManifestBoundsCalculator {
    /**
     * @param {Object} args
     */
    constructor(args) {
        this._isDynamic = args.isDynamic;
        this._timeShiftBufferDepth = !args.isDynamic ||
            args.timeShiftBufferDepth === undefined ?
            null :
            args.timeShiftBufferDepth;
    }
    /**
     * Set the last position and the position time (the value of `performance.now()`
     * at the time that position was true converted into seconds).
     *
     * @example
     * Example if you trust `Date.now()` to give you a reliable offset:
     * ```js
     * const lastPosition = Date.now();
     * const positionTime = performance.now() / 1000;
     * manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
     * ```
     *
     * @param {number} lastPosition
     * @param {number|undefined} positionTime
     */
    setLastPosition(lastPosition, positionTime) {
        this._lastPosition = lastPosition;
        this._positionTime = positionTime;
    }
    /**
     * Returns `true` if the last position and the position time
     * (for dynamic content only) have been comunicated.
     * `false` otherwise.
     * @returns {boolean}
     */
    lastPositionIsKnown() {
        if (this._isDynamic) {
            return this._positionTime != null && this._lastPosition != null;
        }
        return this._lastPosition != null;
    }
    /**
     * Estimate a minimum bound for the content from the last set segment time
     * and buffer depth.
     * Consider that it is only an estimation, not the real value.
     * @return {number|undefined}
     */
    estimateMinimumBound() {
        if (!this._isDynamic || this._timeShiftBufferDepth === null) {
            return 0;
        }
        const maximumBound = this.estimateMaximumBound();
        if (maximumBound === undefined) {
            return undefined;
        }
        const minimumBound = maximumBound - this._timeShiftBufferDepth;
        return minimumBound;
    }
    /**
     * Estimate a maximum bound for the content from the last set segment time.
     * Consider that it is only an estimation, not the real value.
     * @return {number|undefined}
     */
    estimateMaximumBound() {
        if (this._isDynamic &&
            this._positionTime != null &&
            this._lastPosition != null) {
            return Math.max((this._lastPosition - this._positionTime) +
                (performance.now() / 1000), 0);
        }
        return this._lastPosition;
    }
}

// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(54924);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/infer_adaptation_type.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/** Array grouping every possible type a parsed Adaptation can be. */
const KNOWN_ADAPTATION_TYPES = ["audio", "video", "text", "image"];
/** Different `role`s a text Adaptation can be. */
const SUPPORTED_TEXT_TYPES = ["subtitle", "caption"];
/**
 * Infers the type of adaptation from codec and mimetypes found in it.
 *
 * This follows the guidelines defined by the DASH-IF IOP:
 *   - one adaptation set contains a single media type
 *   - The order of verifications are:
 *       1. mimeType
 *       2. Role
 *       3. codec
 *
 * Note: This is based on DASH-IF-IOP-v4.0 with some more freedom.
 * @param {Array.<Object>} representations
 * @param {string|null} adaptationMimeType
 * @param {string|null} adaptationCodecs
 * @param {Array.<Object>|null} adaptationRoles
 * @returns {string} - "audio"|"video"|"text"|"image"|"metadata"|"unknown"
 */
function inferAdaptationType(representations, adaptationMimeType, adaptationCodecs, adaptationRoles) {
    function fromMimeType(mimeType, roles) {
        const topLevel = mimeType.split("/")[0];
        if ((0,array_includes/* default */.Z)(KNOWN_ADAPTATION_TYPES, topLevel)) {
            return topLevel;
        }
        if (mimeType === "application/bif") {
            return "image";
        }
        if (mimeType === "application/ttml+xml") {
            return "text";
        }
        // manage DASH-IF mp4-embedded subtitles and metadata
        if (mimeType === "application/mp4") {
            if (roles != null) {
                if ((0,array_find/* default */.Z)(roles, (role) => role.schemeIdUri === "urn:mpeg:dash:role:2011" &&
                    (0,array_includes/* default */.Z)(SUPPORTED_TEXT_TYPES, role.value)) != null) {
                    return "text";
                }
            }
            return undefined;
        }
    }
    function fromCodecs(codecs) {
        switch (codecs.substring(0, 3)) {
            case "avc":
            case "hev":
            case "hvc":
            case "vp8":
            case "vp9":
            case "av1":
                return "video";
            case "vtt":
                return "text";
            case "bif":
                return "image";
        }
        switch (codecs.substring(0, 4)) {
            case "mp4a":
                return "audio";
            case "wvtt":
            case "stpp":
                return "text";
        }
    }
    if (adaptationMimeType !== null) {
        const typeFromMimeType = fromMimeType(adaptationMimeType, adaptationRoles);
        if (typeFromMimeType !== undefined) {
            return typeFromMimeType;
        }
    }
    if (adaptationCodecs !== null) {
        const typeFromCodecs = fromCodecs(adaptationCodecs);
        if (typeFromCodecs !== undefined) {
            return typeFromCodecs;
        }
    }
    for (let i = 0; i < representations.length; i++) {
        const representation = representations[i];
        const { mimeType, codecs } = representation.attributes;
        if (mimeType !== undefined) {
            const typeFromMimeType = fromMimeType(mimeType, adaptationRoles);
            if (typeFromMimeType !== undefined) {
                return typeFromMimeType;
            }
        }
        if (codecs !== undefined) {
            const typeFromCodecs = fromCodecs(codecs);
            if (typeFromCodecs !== undefined) {
                return typeFromCodecs;
            }
        }
    }
    return undefined;
}

// EXTERNAL MODULE: ./src/parsers/manifest/utils/index_helpers.ts
var index_helpers = __webpack_require__(61443);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/get_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Construct init segment for the given index.
 * @param {Object} index
 * @param {function} isEMSGWhitelisted
 * @returns {Object}
 */
function getInitSegment(index, isEMSGWhitelisted) {
    var _a;
    const { initialization } = index;
    let privateInfos;
    if (isEMSGWhitelisted !== undefined) {
        privateInfos = { isEMSGWhitelisted };
    }
    return { id: "init",
        isInit: true,
        time: 0,
        end: 0,
        duration: 0,
        timescale: 1,
        range: initialization != null ? initialization.range :
            undefined,
        indexRange: index.indexRange, mediaURLs: (_a = initialization === null || initialization === void 0 ? void 0 : initialization.mediaURLs) !== null && _a !== void 0 ? _a : null, privateInfos,
        timestampOffset: -(index.indexTimeOffset / index.timescale) };
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/tokens.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Pad with 0 in the left of the given n argument to reach l length
 * @param {Number|string} n
 * @param {Number} l
 * @returns {string}
 */
function padLeftWithZeros(n, l) {
    const nToString = n.toString();
    if (nToString.length >= l) {
        return nToString;
    }
    const arr = new Array(l + 1).join("0") + nToString;
    return arr.slice(-l);
}
/**
 * @param {string|number} replacer
 * @returns {Function}
 */
function processFormatedToken(replacer) {
    return (_match, _format, widthStr) => {
        const width = (0,is_non_empty_string/* default */.Z)(widthStr) ? parseInt(widthStr, 10) :
            1;
        return padLeftWithZeros(String(replacer), width);
    };
}
/**
 * @param {string} representationURL
 * @param {string|undefined} media
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */
function createIndexURLs(baseURLs, media, id, bitrate) {
    if (baseURLs.length === 0) {
        return media !== undefined ? [replaceRepresentationDASHTokens(media, id, bitrate)] :
            null;
    }
    return baseURLs.map(baseURL => {
        return replaceRepresentationDASHTokens((0,resolve_url/* default */.Z)(baseURL, media), id, bitrate);
    });
}
/**
 * Replace "tokens" written in a given path (e.g. $RepresentationID$) by the corresponding
 * infos, taken from the given segment.
 * @param {string} path
 * @param {string|undefined} id
 * @param {number|undefined} bitrate
 * @returns {string}
 */
function replaceRepresentationDASHTokens(path, id, bitrate) {
    if (path.indexOf("$") === -1) {
        return path;
    }
    else {
        return path
            .replace(/\$\$/g, "$")
            .replace(/\$RepresentationID\$/g, String(id))
            .replace(/\$Bandwidth(|\%0(\d+)d)\$/g, processFormatedToken(bitrate === undefined ? 0 :
            bitrate));
    }
}
/**
 * Create function allowing to replace "tokens" in a given DASH segment URL
 * (e.g. $Time$, which has to be replaced by the segment's start time) by the
 * right information.
 * @param {number|undefined} time
 * @param {number|undefined} nb
 * @returns {Function}
 */
function createDashUrlDetokenizer(time, nb) {
    /**
     * Replace the tokens in the given `url` by the segment information defined
     * by the outer function.
     * @param {string} url
     * @returns {string}
     *
     * @throws Error - Throws if we do not have enough data to construct the URL
     */
    return function replaceTokensInUrl(url) {
        if (url.indexOf("$") === -1) {
            return url;
        }
        else {
            return url
                .replace(/\$\$/g, "$")
                .replace(/\$Number(|\%0(\d+)d)\$/g, (_x, _y, widthStr) => {
                if (nb === undefined) {
                    throw new Error("Segment number not defined in a $Number$ scheme");
                }
                return processFormatedToken(nb)(_x, _y, widthStr);
            })
                .replace(/\$Time(|\%0(\d+)d)\$/g, (_x, _y, widthStr) => {
                if (time === undefined) {
                    throw new Error("Segment time not defined in a $Time$ scheme");
                }
                return processFormatedToken(time)(_x, _y, widthStr);
            });
        }
    };
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/get_segments_from_timeline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * For the given start time and duration of a timeline element, calculate how
 * much this element should be repeated to contain the time given.
 * 0 being the same element, 1 being the next one etc.
 * @param {Number} segmentStartTime
 * @param {Number} segmentDuration
 * @param {Number} wantedTime
 * @returns {Number}
 */
function getWantedRepeatIndex(segmentStartTime, segmentDuration, wantedTime) {
    const diff = wantedTime - segmentStartTime;
    return diff > 0 ? Math.floor(diff / segmentDuration) :
        0;
}
/**
 * Get a list of Segments for the time range wanted.
 * @param {Object} index - index object, constructed by parsing the manifest.
 * @param {number} from - starting timestamp wanted, in seconds
 * @param {number} durationWanted - duration wanted, in seconds
 * @param {function} isEMSGWhitelisted
 * @param {number|undefined} maximumTime
 * @returns {Array.<Object>}
 */
function getSegmentsFromTimeline(index, from, durationWanted, isEMSGWhitelisted, maximumTime) {
    const scaledUp = (0,index_helpers/* toIndexTime */.gT)(from, index);
    const scaledTo = (0,index_helpers/* toIndexTime */.gT)(from + durationWanted, index);
    const { timeline, timescale, mediaURLs, startNumber } = index;
    let currentNumber = startNumber != null ? startNumber :
        undefined;
    const segments = [];
    const timelineLength = timeline.length;
    // TODO(pierre): use @maxSegmentDuration if possible
    let maxEncounteredDuration = timeline.length > 0 &&
        timeline[0].duration != null ? timeline[0].duration :
        0;
    for (let i = 0; i < timelineLength; i++) {
        const timelineItem = timeline[i];
        const { duration, start, range } = timelineItem;
        maxEncounteredDuration = Math.max(maxEncounteredDuration, duration);
        const repeat = (0,index_helpers/* calculateRepeat */.KF)(timelineItem, timeline[i + 1], maximumTime);
        let segmentNumberInCurrentRange = getWantedRepeatIndex(start, duration, scaledUp);
        let segmentTime = start + segmentNumberInCurrentRange * duration;
        while (segmentTime < scaledTo && segmentNumberInCurrentRange <= repeat) {
            const segmentNumber = currentNumber != null ?
                currentNumber + segmentNumberInCurrentRange : undefined;
            const detokenizedURLs = mediaURLs === null ?
                null :
                mediaURLs.map(createDashUrlDetokenizer(segmentTime, segmentNumber));
            const time = segmentTime - index.indexTimeOffset;
            const segment = { id: String(segmentTime),
                time: time / timescale,
                end: (time + duration) / timescale,
                duration: duration / timescale,
                isInit: false,
                range, timescale: 1, mediaURLs: detokenizedURLs,
                number: segmentNumber,
                timestampOffset: -(index.indexTimeOffset / timescale),
                privateInfos: { isEMSGWhitelisted } };
            segments.push(segment);
            // update segment number and segment time for the next segment
            segmentNumberInCurrentRange++;
            segmentTime = start + segmentNumberInCurrentRange * duration;
        }
        if (segmentTime >= scaledTo) {
            // we reached ``scaledTo``, we're done
            return segments;
        }
        if (currentNumber != null) {
            currentNumber += repeat + 1;
        }
    }
    return segments;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/base.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} segmentInfos
 * @returns {Boolean} - true if the segment has been added
 */
function _addSegmentInfos(index, segmentInfos) {
    if (segmentInfos.timescale !== index.timescale) {
        const { timescale } = index;
        index.timeline.push({ start: (segmentInfos.time / segmentInfos.timescale)
                * timescale,
            duration: (segmentInfos.duration / segmentInfos.timescale)
                * timescale,
            repeatCount: segmentInfos.count === undefined ?
                0 :
                segmentInfos.count,
            range: segmentInfos.range });
    }
    else {
        index.timeline.push({ start: segmentInfos.time,
            duration: segmentInfos.duration,
            repeatCount: segmentInfos.count === undefined ?
                0 :
                segmentInfos.count,
            range: segmentInfos.range });
    }
    return true;
}
class BaseRepresentationIndex {
    /**
     * @param {Object} index
     * @param {Object} context
     */
    constructor(index, context) {
        var _a, _b;
        const { periodStart, periodEnd, representationBaseURLs, representationId, representationBitrate, isEMSGWhitelisted } = context;
        const timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;
        const presentationTimeOffset = index.presentationTimeOffset != null ?
            index.presentationTimeOffset : 0;
        const indexTimeOffset = presentationTimeOffset - periodStart * timescale;
        const mediaURLs = createIndexURLs(representationBaseURLs, index.initialization !== undefined ?
            index.initialization.media :
            undefined, representationId, representationBitrate);
        // TODO If indexRange is either undefined or behind the initialization segment
        // the following logic will not work.
        // However taking the nth first bytes like `dash.js` does (where n = 1500) is
        // not straightforward as we would need to clean-up the segment after that.
        // The following logic corresponds to 100% of tested cases, so good enough for
        // now.
        const range = index.initialization !== undefined ? index.initialization.range :
            index.indexRange !== undefined ? [0, index.indexRange[0] - 1] :
                undefined;
        this._index = { indexRange: index.indexRange,
            indexTimeOffset,
            initialization: { mediaURLs, range },
            mediaURLs: createIndexURLs(representationBaseURLs, index.media, representationId, representationBitrate),
            startNumber: index.startNumber, timeline: (_b = index.timeline) !== null && _b !== void 0 ? _b : [], timescale };
        this._scaledPeriodEnd = periodEnd == null ? undefined :
            (0,index_helpers/* toIndexTime */.gT)(periodEnd, this._index);
        this._isInitialized = this._index.timeline.length > 0;
        this._isEMSGWhitelisted = isEMSGWhitelisted;
    }
    /**
     * Construct init Segment.
     * @returns {Object}
     */
    getInitSegment() {
        return getInitSegment(this._index, this._isEMSGWhitelisted);
    }
    /**
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Object>}
     */
    getSegments(_up, _to) {
        return getSegmentsFromTimeline(this._index, _up, _to, this._isEMSGWhitelisted, this._scaledPeriodEnd);
    }
    /**
     * Returns false as no Segment-Base based index should need to be refreshed.
     * @returns {Boolean}
     */
    shouldRefresh() {
        return false;
    }
    /**
     * Returns first position in index.
     * @returns {Number|null}
     */
    getFirstPosition() {
        const index = this._index;
        if (index.timeline.length === 0) {
            return null;
        }
        return (0,index_helpers/* fromIndexTime */.zG)(index.timeline[0].start, index);
    }
    /**
     * Returns last position in index.
     * @returns {Number|null}
     */
    getLastPosition() {
        const { timeline } = this._index;
        if (timeline.length === 0) {
            return null;
        }
        const lastTimelineElement = timeline[timeline.length - 1];
        const lastTime = (0,index_helpers/* getIndexSegmentEnd */.jH)(lastTimelineElement, null, this._scaledPeriodEnd);
        return (0,index_helpers/* fromIndexTime */.zG)(lastTime, this._index);
    }
    /**
     * Segments in a segmentBase scheme should stay available.
     * @returns {Boolean|undefined}
     */
    isSegmentStillAvailable() {
        return true;
    }
    /**
     * We do not check for discontinuity in SegmentBase-based indexes.
     * @returns {null}
     */
    checkDiscontinuity() {
        return null;
    }
    /**
     * @returns {boolean}
     */
    areSegmentsChronologicallyGenerated() {
        return true;
    }
    /**
     * @param {Array.<Object>} nextSegments
     * @returns {Array.<Object>}
     */
    _addSegments(nextSegments) {
        for (let i = 0; i < nextSegments.length; i++) {
            _addSegmentInfos(this._index, nextSegments[i]);
        }
        if (!this._isInitialized && this._index.timeline.length > 0) {
            this._isInitialized = true;
        }
    }
    /**
     * Returns true as SegmentBase does not get updated.
     * @returns {Boolean}
     */
    canBeOutOfSyncError() {
        return false;
    }
    /**
     * Returns true as SegmentBase does not get updated.
     * @returns {Boolean}
     */
    isFinished() {
        return true;
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
        return this._isInitialized;
    }
    /**
     * @param {Object} newIndex
     */
    _replace(newIndex) {
        this._index = newIndex._index;
    }
    _update() {
        log/* default.error */.Z.error("Base RepresentationIndex: Cannot update a SegmentList");
    }
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/list.ts
/*
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




class ListRepresentationIndex {
    /**
     * @param {Object} index
     * @param {Object} context
     */
    constructor(index, context) {
        var _a;
        const { periodStart, representationBaseURLs, representationId, representationBitrate, isEMSGWhitelisted } = context;
        this._isEMSGWhitelisted = isEMSGWhitelisted;
        this._periodStart = periodStart;
        const presentationTimeOffset = index.presentationTimeOffset != null ? index.presentationTimeOffset :
            0;
        const timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;
        const indexTimeOffset = presentationTimeOffset - periodStart * timescale;
        const list = index.list.map((lItem) => ({
            mediaURLs: createIndexURLs(representationBaseURLs, lItem.media, representationId, representationBitrate),
            mediaRange: lItem.mediaRange
        }));
        this._index = { list,
            timescale,
            duration: index.duration,
            indexTimeOffset,
            indexRange: index.indexRange,
            initialization: index.initialization == null ?
                undefined :
                { mediaURLs: createIndexURLs(representationBaseURLs, index.initialization.media, representationId, representationBitrate),
                    range: index.initialization.range } };
    }
    /**
     * Construct init Segment.
     * @returns {Object}
     */
    getInitSegment() {
        const initSegment = getInitSegment(this._index);
        if (initSegment.privateInfos === undefined) {
            initSegment.privateInfos = {};
        }
        initSegment.privateInfos.isEMSGWhitelisted = this._isEMSGWhitelisted;
        return initSegment;
    }
    /**
     * @param {Number} fromTime
     * @param {Number} duration
     * @returns {Array.<Object>}
     */
    getSegments(fromTime, dur) {
        const index = this._index;
        const { duration, list, timescale } = index;
        const durationInSeconds = duration / timescale;
        const fromTimeInPeriod = fromTime - this._periodStart;
        const [up, to] = (0,index_helpers/* getTimescaledRange */.PZ)(fromTimeInPeriod, dur, timescale);
        const length = Math.min(list.length - 1, Math.floor(to / duration));
        const segments = [];
        let i = Math.floor(up / duration);
        while (i <= length) {
            const range = list[i].mediaRange;
            const mediaURLs = list[i].mediaURLs;
            const time = i * durationInSeconds + this._periodStart;
            const segment = { id: String(i),
                time,
                isInit: false,
                range,
                duration: durationInSeconds, timescale: 1, end: time + durationInSeconds,
                mediaURLs,
                timestampOffset: -(index.indexTimeOffset / timescale),
                privateInfos: { isEMSGWhitelisted: this._isEMSGWhitelisted } };
            segments.push(segment);
            i++;
        }
        return segments;
    }
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * (If we should re-fetch the manifest)
     * @param {Number} _fromTime
     * @param {Number} toTime
     * @returns {Boolean}
     */
    shouldRefresh(_fromTime, toTime) {
        const { timescale, duration, list } = this._index;
        const scaledTo = toTime * timescale;
        const i = Math.floor(scaledTo / duration);
        return i < 0 || i >= list.length;
    }
    /**
     * Returns first position in this index, in seconds.
     * @returns {Number}
     */
    getFirstPosition() {
        return this._periodStart;
    }
    /**
     * Returns last position in this index, in seconds.
     * @returns {Number}
     */
    getLastPosition() {
        const index = this._index;
        const { duration, list } = index;
        return ((list.length * duration) / index.timescale) + this._periodStart;
    }
    /**
     * Returns true if a Segment returned by this index is still considered
     * available.
     * @param {Object} segment
     * @returns {Boolean}
     */
    isSegmentStillAvailable() {
        return true;
    }
    /**
     * We do not check for discontinuity in SegmentList-based indexes.
     * @returns {null}
     */
    checkDiscontinuity() {
        return null;
    }
    /**
     * @returns {boolean}
     */
    areSegmentsChronologicallyGenerated() {
        return true;
    }
    /**
     * SegmentList should not be updated.
     * @returns {Boolean}
     */
    canBeOutOfSyncError() {
        return false;
    }
    /**
     * @returns {Boolean}
     */
    isFinished() {
        return true;
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
        return true;
    }
    /**
     * @param {Object} newIndex
     */
    _replace(newIndex) {
        this._index = newIndex._index;
    }
    /**
     * @param {Object} newIndex
     */
    _update() {
        log/* default.error */.Z.error("List RepresentationIndex: Cannot update a SegmentList");
    }
}

// EXTERNAL MODULE: ./src/errors/network_error.ts
var network_error = __webpack_require__(12081);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/clear_timeline_from_position.ts
var clear_timeline_from_position = __webpack_require__(2259);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/is_segment_still_available.ts
var is_segment_still_available = __webpack_require__(91434);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/update_segment_timeline.ts
var update_segment_timeline = __webpack_require__(71140);
;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/is_period_fulfilled.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { DEFAULT_MAXIMUM_TIME_ROUNDING_ERROR } = config/* default */.Z;
/**
 * In Javascript, numbers are encoded in a way that a floating number may be
 * represented internally with a rounding error.
 *
 * As the period end is the result of a multiplication between a floating or integer
 * number (period end * timescale), this function takes into account the potential
 * rounding error to tell if the period is fulfilled with content.
 * @param {number} timescale
 * @param {number} lastSegmentEnd
 * @param {number} periodEnd
 * @returns {boolean}
 */
function isPeriodFulfilled(timescale, lastSegmentEnd, periodEnd) {
    const scaledRoundingError = DEFAULT_MAXIMUM_TIME_ROUNDING_ERROR * timescale;
    return (lastSegmentEnd + scaledRoundingError) >= periodEnd;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/convert_element_to_index_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Translate parsed `S` node into Segment compatible with this index:
 * Find out the start, repeatCount and duration of each of these.
 *
 * @param {Object} item - parsed `S` node
 * @param {Object|null} previousItem - the previously parsed Segment (related
 * to the `S` node coming just before). If `null`, we're talking about the first
 * segment.
 * @param {Object|null} nextItem - the `S` node coming next. If `null`, we're
 * talking about the last segment.
 * @param {number} timelineStart - Absolute start for the timeline. In the same
 * timescale than the given `S` nodes.
 * @returns {Object|null}
 */
function convertElementsToIndexSegment(item, previousItem, nextItem, timelineStart) {
    let start = item.start;
    let duration = item.duration;
    const repeatCount = item.repeatCount;
    if (start == null) {
        if (previousItem == null) {
            start = timelineStart;
        }
        else if (previousItem.duration != null) {
            start = previousItem.start +
                (previousItem.duration * (previousItem.repeatCount + 1));
        }
    }
    if ((duration == null || isNaN(duration)) &&
        nextItem != null && nextItem.start != null && !isNaN(nextItem.start) &&
        start != null && !isNaN(start)) {
        duration = nextItem.start - start;
    }
    if ((start != null && !isNaN(start)) &&
        (duration != null && !isNaN(duration)) &&
        (repeatCount == null || !isNaN(repeatCount))) {
        return { start,
            duration,
            repeatCount: repeatCount === undefined ? 0 :
                repeatCount };
    }
    log/* default.warn */.Z.warn("DASH: A \"S\" Element could not have been parsed.");
    return null;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/parse_s_element.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse a given <S> element in the MPD into a JS Object.
 * @param {Element} root
 * @returns {Object}
 */
function parseSElement(root) {
    const parsedS = {};
    for (let j = 0; j < root.attributes.length; j++) {
        const attribute = root.attributes[j];
        switch (attribute.name) {
            case "t":
                const start = parseInt(attribute.value, 10);
                if (isNaN(start)) {
                    log/* default.warn */.Z.warn(`DASH: invalid t ("${attribute.value}")`);
                }
                else {
                    parsedS.start = start;
                }
                break;
            case "d":
                const duration = parseInt(attribute.value, 10);
                if (isNaN(duration)) {
                    log/* default.warn */.Z.warn(`DASH: invalid d ("${attribute.value}")`);
                }
                else {
                    parsedS.duration = duration;
                }
                break;
            case "r":
                const repeatCount = parseInt(attribute.value, 10);
                if (isNaN(repeatCount)) {
                    log/* default.warn */.Z.warn(`DASH: invalid r ("${attribute.value}")`);
                }
                else {
                    parsedS.repeatCount = repeatCount;
                }
                break;
        }
    }
    return parsedS;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/construct_timeline_from_elements.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Allows to generate the "timeline" for the "Timeline" RepresentationIndex.
 * Call this function when the timeline is unknown.
 * This function was added to only perform that task lazily, i.e. only when
 * first needed.
 * @param {HTMLCollection} elements - All S nodes constituting the corresponding
 * SegmentTimeline node.
 * @param {number} scaledPeriodStart - Absolute start of the concerned Period,
 * in the same scale than the segments found in `elements`.
 * @returns {Array.<Object>}
 */
function constructTimelineFromElements(elements, scaledPeriodStart) {
    const initialTimeline = [];
    for (let i = 0; i < elements.length; i++) {
        initialTimeline.push(parseSElement(elements[i]));
    }
    const timeline = [];
    for (let i = 0; i < initialTimeline.length; i++) {
        const item = initialTimeline[i];
        const previousItem = timeline[timeline.length - 1] === undefined ?
            null :
            timeline[timeline.length - 1];
        const nextItem = initialTimeline[i + 1] === undefined ?
            null :
            initialTimeline[i + 1];
        const timelineElement = convertElementsToIndexSegment(item, previousItem, nextItem, scaledPeriodStart);
        if (timelineElement != null) {
            timeline.push(timelineElement);
        }
    }
    return timeline;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/find_first_common_start_time.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * By comparing two timelines for the same content at different points in time,
 * retrieve the index in both timelines of the first segment having the same
 * starting time.
 * Returns `null` if not found.
 * @param {Array.<Object>} prevTimeline
 * @param {HTMLCollection} newElements
 * @returns {Object|null}
 */
function findFirstCommonStartTime(prevTimeline, newElements) {
    if (prevTimeline.length === 0 || newElements.length === 0) {
        return null;
    }
    const prevInitialStart = prevTimeline[0].start;
    const newFirstTAttr = newElements[0].getAttribute("t");
    const newInitialStart = newFirstTAttr === null ? null :
        parseInt(newFirstTAttr, 10);
    if (newInitialStart === null || Number.isNaN(newInitialStart)) {
        return null;
    }
    if (prevInitialStart === newInitialStart) {
        return { prevSegmentsIdx: 0,
            newElementsIdx: 0,
            repeatNumberInPrevSegments: 0,
            repeatNumberInNewElements: 0 };
    }
    else if (prevInitialStart < newInitialStart) {
        let prevElt = prevTimeline[0];
        let prevElementIndex = 0;
        while (true) {
            if (prevElt.repeatCount > 0) {
                const diff = newInitialStart - prevElt.start;
                if (diff % prevElt.duration === 0 &&
                    diff / prevElt.duration <= prevElt.repeatCount) {
                    const repeatNumberInPrevSegments = diff / prevElt.duration;
                    return { repeatNumberInPrevSegments,
                        prevSegmentsIdx: prevElementIndex,
                        newElementsIdx: 0,
                        repeatNumberInNewElements: 0 };
                }
            }
            prevElementIndex++;
            if (prevElementIndex >= prevTimeline.length) {
                return null;
            }
            prevElt = prevTimeline[prevElementIndex];
            if (prevElt.start === newInitialStart) {
                return { prevSegmentsIdx: prevElementIndex,
                    newElementsIdx: 0,
                    repeatNumberInPrevSegments: 0,
                    repeatNumberInNewElements: 0 };
            }
            else if (prevElt.start > newInitialStart) {
                return null;
            }
        }
    }
    else {
        let newElementsIdx = 0;
        let newElt = newElements[0];
        let currentTimeOffset = newInitialStart;
        while (true) {
            const dAttr = newElt.getAttribute("d");
            const duration = dAttr === null ? null :
                parseInt(dAttr, 10);
            if (duration === null || Number.isNaN(duration)) {
                return null;
            }
            const rAttr = newElt.getAttribute("r");
            const repeatCount = rAttr === null ? null :
                parseInt(rAttr, 10);
            if (repeatCount !== null) {
                if (Number.isNaN(repeatCount) || repeatCount < 0) {
                    return null;
                }
                if (repeatCount > 0) {
                    const diff = prevInitialStart - currentTimeOffset;
                    if (diff % duration === 0 &&
                        diff / duration <= repeatCount) {
                        const repeatNumberInNewElements = diff / duration;
                        return { repeatNumberInPrevSegments: 0,
                            repeatNumberInNewElements,
                            prevSegmentsIdx: 0,
                            newElementsIdx };
                    }
                }
                currentTimeOffset += duration * (repeatCount + 1);
            }
            else {
                currentTimeOffset += duration;
            }
            newElementsIdx++;
            if (newElementsIdx >= newElements.length) {
                return null;
            }
            newElt = newElements[newElementsIdx];
            const tAttr = newElt.getAttribute("t");
            const time = tAttr === null ? null :
                parseInt(tAttr, 10);
            if (time !== null) {
                if (Number.isNaN(time)) {
                    return null;
                }
                currentTimeOffset = time;
            }
            if (currentTimeOffset === prevInitialStart) {
                return { newElementsIdx,
                    prevSegmentsIdx: 0,
                    repeatNumberInPrevSegments: 0,
                    repeatNumberInNewElements: 0 };
            }
            else if (currentTimeOffset > newInitialStart) {
                return null;
            }
        }
    }
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/construct_timeline_from_previous_timeline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





function constructTimelineFromPreviousTimeline(newElements, prevTimeline, scaledPeriodStart) {
    var _a;
    // Find first index in both timeline where a common segment is found.
    const commonStartInfo = findFirstCommonStartTime(prevTimeline, newElements);
    if (commonStartInfo === null) {
        log/* default.warn */.Z.warn("DASH: Cannot perform \"based\" update. Common segment not found.");
        return constructTimelineFromElements(newElements, scaledPeriodStart);
    }
    const { prevSegmentsIdx, newElementsIdx, repeatNumberInPrevSegments, repeatNumberInNewElements } = commonStartInfo;
    /** Guess of the number of elements in common. */
    const numberCommonEltGuess = prevTimeline.length - prevSegmentsIdx;
    const lastCommonEltNewEltsIdx = numberCommonEltGuess + newElementsIdx - 1;
    if (lastCommonEltNewEltsIdx >= newElements.length) {
        log/* default.info */.Z.info("DASH: Cannot perform \"based\" update. New timeline too short");
        return constructTimelineFromElements(newElements, scaledPeriodStart);
    }
    // Remove elements which are not available anymore
    const newTimeline = prevTimeline.slice(prevSegmentsIdx);
    if (repeatNumberInPrevSegments > 0) {
        const commonEltInOldTimeline = newTimeline[0];
        commonEltInOldTimeline.start += commonEltInOldTimeline.duration *
            repeatNumberInPrevSegments;
        newTimeline[0].repeatCount -= repeatNumberInPrevSegments;
    }
    if (repeatNumberInNewElements > 0 && newElementsIdx !== 0) {
        log/* default.info */.Z.info("DASH: Cannot perform \"based\" update. " +
            "The new timeline has a different form.");
        return constructTimelineFromElements(newElements, scaledPeriodStart);
    }
    const prevLastElement = newTimeline[newTimeline.length - 1];
    const newCommonElt = parseSElement(newElements[lastCommonEltNewEltsIdx]);
    const newRepeatCountOffseted = ((_a = newCommonElt.repeatCount) !== null && _a !== void 0 ? _a : 0) -
        repeatNumberInNewElements;
    if (newCommonElt.duration !== prevLastElement.duration ||
        prevLastElement.repeatCount > newRepeatCountOffseted) {
        log/* default.info */.Z.info("DASH: Cannot perform \"based\" update. " +
            "The new timeline has a different form at the beginning.");
        return constructTimelineFromElements(newElements, scaledPeriodStart);
    }
    if (newCommonElt.repeatCount !== undefined &&
        newCommonElt.repeatCount > prevLastElement.repeatCount) {
        prevLastElement.repeatCount = newCommonElt.repeatCount;
    }
    const newEltsToPush = [];
    const items = [];
    for (let i = lastCommonEltNewEltsIdx + 1; i < newElements.length; i++) {
        items.push(parseSElement(newElements[i]));
    }
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const previousItem = newEltsToPush[newEltsToPush.length - 1] === undefined ?
            prevLastElement :
            newEltsToPush[newEltsToPush.length - 1];
        const nextItem = items[i + 1] === undefined ?
            null :
            items[i + 1];
        const timelineElement = convertElementsToIndexSegment(item, previousItem, nextItem, scaledPeriodStart);
        if (timelineElement !== null) {
            newEltsToPush.push(timelineElement);
        }
    }
    return newTimeline.concat(newEltsToPush);
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/timeline_representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












// eslint-disable-next-line max-len

const { MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY } = config/* default */.Z;
class TimelineRepresentationIndex {
    /**
     * @param {Object} index
     * @param {Object} context
     */
    constructor(index, timelineParser, context) {
        var _a;
        const { manifestBoundsCalculator, isDynamic, representationBaseURLs, representationId, representationBitrate, periodStart, periodEnd, isEMSGWhitelisted } = context;
        const timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;
        const presentationTimeOffset = index.presentationTimeOffset != null ?
            index.presentationTimeOffset :
            0;
        const scaledStart = periodStart * timescale;
        const indexTimeOffset = presentationTimeOffset - scaledStart;
        this._manifestBoundsCalculator = manifestBoundsCalculator;
        this._isEMSGWhitelisted = isEMSGWhitelisted;
        this._lastUpdate = context.receivedTime == null ?
            performance.now() :
            context.receivedTime;
        this._unsafelyBaseOnPreviousIndex = null;
        if (context.unsafelyBaseOnPreviousRepresentation !== null &&
            context.unsafelyBaseOnPreviousRepresentation.index
                instanceof TimelineRepresentationIndex) {
            // avoid too much nested references, to keep memory down
            context.unsafelyBaseOnPreviousRepresentation
                .index._unsafelyBaseOnPreviousIndex = null;
            this._unsafelyBaseOnPreviousIndex = context
                .unsafelyBaseOnPreviousRepresentation.index;
        }
        this._isDynamic = isDynamic;
        this._parseTimeline = timelineParser;
        this._index = { indexRange: index.indexRange,
            indexTimeOffset,
            initialization: index.initialization == null ?
                undefined :
                {
                    mediaURLs: createIndexURLs(representationBaseURLs, index.initialization.media, representationId, representationBitrate),
                    range: index.initialization.range,
                },
            mediaURLs: createIndexURLs(representationBaseURLs, index.media, representationId, representationBitrate),
            startNumber: index.startNumber,
            timeline: null,
            timescale };
        this._scaledPeriodStart = (0,index_helpers/* toIndexTime */.gT)(periodStart, this._index);
        this._scaledPeriodEnd = periodEnd == null ? undefined :
            (0,index_helpers/* toIndexTime */.gT)(periodEnd, this._index);
    }
    /**
     * Construct init Segment.
     * @returns {Object}
     */
    getInitSegment() {
        return getInitSegment(this._index, this._isEMSGWhitelisted);
    }
    /**
     * Asks for segments to download for a given time range.
     * @param {Number} from - Beginning of the time wanted, in seconds
     * @param {Number} duration - duration wanted, in seconds
     * @returns {Array.<Object>}
     */
    getSegments(from, duration) {
        this._refreshTimeline(); // clear timeline if needed
        if (this._index.timeline === null) {
            this._index.timeline = this._getTimeline();
        }
        // destructuring to please TypeScript
        const { mediaURLs, startNumber, timeline, timescale, indexTimeOffset } = this._index;
        return getSegmentsFromTimeline({ mediaURLs,
            startNumber,
            timeline,
            timescale,
            indexTimeOffset }, from, duration, this._isEMSGWhitelisted, this._scaledPeriodEnd);
    }
    /**
     * Returns true if the index should be refreshed.
     * @param {Number} _up
     * @param {Number} to
     * @returns {Boolean}
     */
    shouldRefresh() {
        // DASH Manifest based on a SegmentTimeline should have minimumUpdatePeriod
        // attribute which should be sufficient to know when to refresh it.
        return false;
    }
    /**
     * Returns the starting time, in seconds, of the earliest segment currently
     * available.
     * Returns null if nothing is in the index
     * @returns {Number|null}
     */
    getFirstPosition() {
        this._refreshTimeline();
        if (this._index.timeline === null) {
            this._index.timeline = this._getTimeline();
        }
        const timeline = this._index.timeline;
        return timeline.length === 0 ? null :
            (0,index_helpers/* fromIndexTime */.zG)(timeline[0].start, this._index);
    }
    /**
     * Returns the ending time, in seconds, of the last segment currently
     * available.
     * Returns null if nothing is in the index
     * @returns {Number|null}
     */
    getLastPosition() {
        this._refreshTimeline();
        if (this._index.timeline === null) {
            this._index.timeline = this._getTimeline();
        }
        const lastTime = TimelineRepresentationIndex.getIndexEnd(this._index.timeline, this._scaledPeriodStart);
        return lastTime === null ? null :
            (0,index_helpers/* fromIndexTime */.zG)(lastTime, this._index);
    }
    /**
     * Returns true if a Segment returned by this index is still considered
     * available.
     * Returns false if it is not available anymore.
     * Returns undefined if we cannot know whether it is still available or not.
     * @param {Object} segment
     * @returns {Boolean|undefined}
     */
    isSegmentStillAvailable(segment) {
        if (segment.isInit) {
            return true;
        }
        this._refreshTimeline();
        if (this._index.timeline === null) {
            this._index.timeline = this._getTimeline();
        }
        const { timeline, timescale, indexTimeOffset } = this._index;
        return (0,is_segment_still_available/* default */.Z)(segment, timeline, timescale, indexTimeOffset);
    }
    /**
     * Checks if the time given is in a discontinuity. That is:
     *   - We're on the upper bound of the current range (end of the range - time
     *     is inferior to the timescale)
     *   - The next range starts after the end of the current range.
     * @param {Number} time
     * @returns {Number|null}
     */
    checkDiscontinuity(time) {
        this._refreshTimeline();
        let timeline = this._index.timeline;
        if (timeline === null) {
            timeline = this._getTimeline();
            this._index.timeline = timeline;
        }
        return (0,index_helpers/* checkDiscontinuity */._j)({ timeline,
            timescale: this._index.timescale,
            indexTimeOffset: this._index.indexTimeOffset }, time, this._scaledPeriodEnd);
    }
    /**
     * @param {Error} error
     * @returns {Boolean}
     */
    canBeOutOfSyncError(error) {
        if (!this._isDynamic) {
            return false;
        }
        return error instanceof network_error/* default */.Z &&
            error.isHttpError(404);
    }
    areSegmentsChronologicallyGenerated() {
        return true;
    }
    /**
     * Replace this RepresentationIndex with one from a new version of the
     * Manifest.
     * @param {Object} newIndex
     */
    _replace(newIndex) {
        this._parseTimeline = newIndex._parseTimeline;
        this._index = newIndex._index;
        this._isDynamic = newIndex._isDynamic;
        this._scaledPeriodStart = newIndex._scaledPeriodStart;
        this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
        this._lastUpdate = newIndex._lastUpdate;
        this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
    }
    /**
     * Update this RepresentationIndex with a shorter version of it coming from a
     * new version of the MPD.
     * @param {Object} newIndex
     */
    _update(newIndex) {
        if (this._index.timeline === null) {
            this._index.timeline = this._getTimeline();
        }
        if (newIndex._index.timeline === null) {
            newIndex._index.timeline = newIndex._getTimeline();
        }
        (0,update_segment_timeline/* default */.Z)(this._index.timeline, newIndex._index.timeline);
        this._isDynamic = newIndex._isDynamic;
        this._scaledPeriodStart = newIndex._scaledPeriodStart;
        this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
        this._lastUpdate = newIndex._lastUpdate;
    }
    /**
     * Returns `true` if this RepresentationIndex currently contains its last
     * segment.
     * Returns `false` if it's still pending.
     * @returns {Boolean}
     */
    isFinished() {
        if (!this._isDynamic) {
            return true;
        }
        if (this._index.timeline === null) {
            this._index.timeline = this._getTimeline();
        }
        const { timeline } = this._index;
        if (this._scaledPeriodEnd === undefined || timeline.length === 0) {
            return false;
        }
        const lastTimelineElement = timeline[timeline.length - 1];
        const lastTime = (0,index_helpers/* getIndexSegmentEnd */.jH)(lastTimelineElement, null, this._scaledPeriodEnd);
        return isPeriodFulfilled(this._index.timescale, lastTime, this._scaledPeriodEnd);
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
        return true;
    }
    /**
     * Clean-up timeline to remove segment information which should not be
     * available due to timeshifting.
     */
    _refreshTimeline() {
        if (this._index.timeline === null) {
            this._index.timeline = this._getTimeline();
        }
        const firstPosition = this._manifestBoundsCalculator.estimateMinimumBound();
        if (firstPosition == null) {
            return; // we don't know yet
        }
        const scaledFirstPosition = (0,index_helpers/* toIndexTime */.gT)(firstPosition, this._index);
        (0,clear_timeline_from_position/* default */.Z)(this._index.timeline, scaledFirstPosition);
    }
    static getIndexEnd(timeline, scaledPeriodEnd) {
        if (timeline.length <= 0) {
            return null;
        }
        return (0,index_helpers/* getIndexSegmentEnd */.jH)(timeline[timeline.length - 1], null, scaledPeriodEnd);
    }
    /**
     * Allows to generate the "timeline" for this RepresentationIndex.
     * Call this function when the timeline is unknown.
     * This function was added to only perform that task lazily, i.e. only when
     * first needed.
     * After calling it, every now unneeded variable will be freed from memory.
     * This means that calling _getTimeline more than once will just return an
     * empty array.
     *
     * /!\ Please note that this structure should follow the exact same structure
     * than a SegmentTimeline element in the corresponding MPD.
     * This means:
     *   - It should have the same amount of elements in its array than there was
     *     `<S>` elements in the SegmentTimeline.
     *   - Each of those same elements should have the same start time, the same
     *     duration and the same repeat counter than what could be deduced from
     *     the SegmentTimeline.
     * This is needed to be able to run parsing optimization when refreshing the
     * MPD. Not doing so could lead to the RxPlayer not being able to play the
     * stream anymore.
     * @returns {Array.<Object>}
     */
    _getTimeline() {
        if (this._parseTimeline === null) {
            if (this._index.timeline !== null) {
                return this._index.timeline;
            }
            log/* default.error */.Z.error("DASH: Timeline already lazily parsed.");
            return [];
        }
        const newElements = this._parseTimeline();
        this._parseTimeline = null; // Free memory
        if (this._unsafelyBaseOnPreviousIndex === null ||
            newElements.length < MIN_DASH_S_ELEMENTS_TO_PARSE_UNSAFELY) {
            // Just completely parse the current timeline
            return constructTimelineFromElements(newElements, this._scaledPeriodStart);
        }
        // Construct previously parsed timeline if not already done
        let prevTimeline;
        if (this._unsafelyBaseOnPreviousIndex._index.timeline === null) {
            prevTimeline = this._unsafelyBaseOnPreviousIndex._getTimeline();
            this._unsafelyBaseOnPreviousIndex._index.timeline = prevTimeline;
        }
        else {
            prevTimeline = this._unsafelyBaseOnPreviousIndex._index.timeline;
        }
        this._unsafelyBaseOnPreviousIndex = null; // Free memory
        return constructTimelineFromPreviousTimeline(newElements, prevTimeline, this._scaledPeriodStart);
    }
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/timeline/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const timeline = (TimelineRepresentationIndex);

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/indexes/template.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




const { MINIMUM_SEGMENT_SIZE } = config/* default */.Z;
/**
 * IRepresentationIndex implementation for DASH' SegmentTemplate without a
 * SegmentTimeline.
 * @class TemplateRepresentationIndex
 */
class TemplateRepresentationIndex {
    /**
     * @param {Object} index
     * @param {Object} context
     */
    constructor(index, context) {
        var _a;
        const { aggressiveMode, availabilityTimeOffset, manifestBoundsCalculator, isDynamic, periodEnd, periodStart, representationBaseURLs, representationId, representationBitrate, isEMSGWhitelisted } = context;
        const timescale = (_a = index.timescale) !== null && _a !== void 0 ? _a : 1;
        this._availabilityTimeOffset = availabilityTimeOffset;
        this._manifestBoundsCalculator = manifestBoundsCalculator;
        this._aggressiveMode = aggressiveMode;
        const presentationTimeOffset = index.presentationTimeOffset != null ?
            index.presentationTimeOffset :
            0;
        const scaledStart = periodStart * timescale;
        const indexTimeOffset = presentationTimeOffset - scaledStart;
        if (index.duration === undefined) {
            throw new Error("Invalid SegmentTemplate: no duration");
        }
        this._index = { duration: index.duration,
            timescale,
            indexRange: index.indexRange,
            indexTimeOffset,
            initialization: index.initialization == null ?
                undefined :
                { mediaURLs: createIndexURLs(representationBaseURLs, index.initialization.media, representationId, representationBitrate),
                    range: index.initialization.range },
            mediaURLs: createIndexURLs(representationBaseURLs, index.media, representationId, representationBitrate),
            presentationTimeOffset,
            startNumber: index.startNumber };
        this._isDynamic = isDynamic;
        this._periodStart = periodStart;
        this._scaledPeriodEnd = periodEnd == null ? undefined :
            (periodEnd - periodStart) * timescale;
        this._isEMSGWhitelisted = isEMSGWhitelisted;
    }
    /**
     * Construct init Segment.
     * @returns {Object}
     */
    getInitSegment() {
        return getInitSegment(this._index, this._isEMSGWhitelisted);
    }
    /**
     * @param {Number} fromTime
     * @param {Number} dur
     * @returns {Array.<Object>}
     */
    getSegments(fromTime, dur) {
        const index = this._index;
        const { duration, startNumber, timescale, mediaURLs } = index;
        const scaledStart = this._periodStart * timescale;
        const scaledEnd = this._scaledPeriodEnd;
        // Convert the asked position to the right timescales, and consider them
        // relatively to the Period's start.
        const upFromPeriodStart = fromTime * timescale - scaledStart;
        const toFromPeriodStart = (fromTime + dur) * timescale - scaledStart;
        const firstSegmentStart = this._getFirstSegmentStart();
        const lastSegmentStart = this._getLastSegmentStart();
        if (firstSegmentStart == null || lastSegmentStart == null) {
            return [];
        }
        const startPosition = Math.max(firstSegmentStart, upFromPeriodStart);
        const lastWantedStartPosition = Math.min(lastSegmentStart, toFromPeriodStart);
        if ((lastWantedStartPosition + duration) <= startPosition) {
            return [];
        }
        const segments = [];
        // number corresponding to the Period's start
        const numberOffset = startNumber == null ? 1 :
            startNumber;
        // calcul initial time from Period start, where the first segment would have
        // the `0` number
        let numberIndexedToZero = Math.floor(startPosition / duration);
        for (let timeFromPeriodStart = numberIndexedToZero * duration; timeFromPeriodStart <= lastWantedStartPosition; timeFromPeriodStart += duration) {
            // To obtain the real number, adds the real number from the Period's start
            const realNumber = numberIndexedToZero + numberOffset;
            const realDuration = scaledEnd != null &&
                timeFromPeriodStart + duration > scaledEnd ?
                scaledEnd - timeFromPeriodStart :
                duration;
            const realTime = timeFromPeriodStart + scaledStart;
            const manifestTime = timeFromPeriodStart + this._index.presentationTimeOffset;
            const detokenizedURLs = mediaURLs === null ?
                null :
                mediaURLs.map(createDashUrlDetokenizer(manifestTime, realNumber));
            const args = { id: String(realNumber),
                number: realNumber,
                time: realTime / timescale,
                end: (realTime + realDuration) / timescale,
                duration: realDuration / timescale, timescale: 1, isInit: false,
                scaledDuration: realDuration / timescale,
                mediaURLs: detokenizedURLs,
                timestampOffset: -(index.indexTimeOffset / timescale),
                privateInfos: {
                    isEMSGWhitelisted: this._isEMSGWhitelisted,
                } };
            segments.push(args);
            numberIndexedToZero++;
        }
        return segments;
    }
    /**
     * Returns first possible position in the index, in seconds.
     * @returns {number|null|undefined}
     */
    getFirstPosition() {
        const firstSegmentStart = this._getFirstSegmentStart();
        if (firstSegmentStart == null) {
            return firstSegmentStart; // return undefined or null
        }
        return (firstSegmentStart / this._index.timescale) + this._periodStart;
    }
    /**
     * Returns last possible position in the index, in seconds.
     * @returns {number|null}
     */
    getLastPosition() {
        const lastSegmentStart = this._getLastSegmentStart();
        if (lastSegmentStart == null) {
            // In that case (null or undefined), getLastPosition should reflect
            // the result of getLastSegmentStart, as the meaning is the same for
            // the two functions. So, we return the result of the latter.
            return lastSegmentStart;
        }
        const lastSegmentEnd = lastSegmentStart + this._index.duration;
        return (lastSegmentEnd / this._index.timescale) + this._periodStart;
    }
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * We never have to refresh a SegmentTemplate-based manifest.
     * @returns {Boolean}
     */
    shouldRefresh() {
        return false;
    }
    /**
     * We cannot check for discontinuity in SegmentTemplate-based indexes.
     * @returns {null}
     */
    checkDiscontinuity() {
        return null;
    }
    /**
     * @returns {Boolean}
     */
    areSegmentsChronologicallyGenerated() {
        return true;
    }
    /**
     * Returns `true` if the given segment should still be available as of now
     * (not removed since and still request-able).
     * Returns `false` if that's not the case.
     * Returns `undefined` if we do not know whether that's the case or not.
     * @param {Object} segment
     * @returns {boolean|undefined}
     */
    isSegmentStillAvailable(segment) {
        if (segment.isInit) {
            return true;
        }
        const segmentsForTime = this.getSegments(segment.time, 0.1);
        if (segmentsForTime.length === 0) {
            return false;
        }
        return segmentsForTime[0].time === segment.time &&
            segmentsForTime[0].end === segment.end &&
            segmentsForTime[0].number === segment.number;
    }
    /**
     * SegmentTemplate without a SegmentTimeline should not be updated.
     * @returns {Boolean}
     */
    canBeOutOfSyncError() {
        return false;
    }
    /**
     * @returns {Boolean}
     */
    isFinished() {
        if (!this._isDynamic) {
            return true;
        }
        if (this._scaledPeriodEnd === undefined) {
            return false;
        }
        const { timescale } = this._index;
        const lastSegmentStart = this._getLastSegmentStart();
        // As last segment start is null if live time is before
        // current period, consider the index not to be finished.
        if (lastSegmentStart == null) {
            return false;
        }
        const lastSegmentEnd = lastSegmentStart + this._index.duration;
        return isPeriodFulfilled(timescale, lastSegmentEnd, this._scaledPeriodEnd);
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
        return true;
    }
    /**
     * @param {Object} newIndex
     */
    _replace(newIndex) {
        this._index = newIndex._index;
        this._aggressiveMode = newIndex._aggressiveMode;
        this._isDynamic = newIndex._isDynamic;
        this._periodStart = newIndex._periodStart;
        this._scaledPeriodEnd = newIndex._scaledPeriodEnd;
        this._manifestBoundsCalculator = newIndex._manifestBoundsCalculator;
    }
    /**
     * @param {Object} newIndex
     */
    _update(newIndex) {
        // As segments are not declared individually, as long as this Representation
        // is present, we have every information we need
        this._replace(newIndex);
    }
    /**
     * Returns the timescaled start of the first segment that should be available,
     * relatively to the start of the Period.
     * @returns {number | null | undefined}
     */
    _getFirstSegmentStart() {
        if (!this._isDynamic) {
            return 0; // it is the start of the Period
        }
        // 1 - check that this index is already available
        if (this._scaledPeriodEnd === 0 || this._scaledPeriodEnd === undefined) {
            // /!\ The scaled max position augments continuously and might not
            // reflect exactly the real server-side value. As segments are
            // generated discretely.
            const maximumBound = this._manifestBoundsCalculator.estimateMaximumBound();
            if (maximumBound !== undefined && maximumBound < this._periodStart) {
                // Maximum position is before this period.
                // No segment is yet available here
                return null;
            }
        }
        const { duration, timescale } = this._index;
        const firstPosition = this._manifestBoundsCalculator.estimateMinimumBound();
        if (firstPosition === undefined) {
            return undefined;
        }
        const segmentTime = firstPosition > this._periodStart ?
            (firstPosition - this._periodStart) * timescale :
            0;
        const numberIndexedToZero = Math.floor(segmentTime / duration);
        return numberIndexedToZero * duration;
    }
    /**
     * Returns the timescaled start of the last segment that should be available,
     * relatively to the start of the Period.
     * Returns null if live time is before current period.
     * @returns {number|null|undefined}
     */
    _getLastSegmentStart() {
        var _a;
        const { duration, timescale } = this._index;
        if (this._isDynamic) {
            const lastPos = this._manifestBoundsCalculator.estimateMaximumBound();
            if (lastPos === undefined) {
                return undefined;
            }
            const agressiveModeOffset = this._aggressiveMode ? (duration / timescale) :
                0;
            if (this._scaledPeriodEnd != null &&
                this._scaledPeriodEnd <
                    (lastPos + agressiveModeOffset - this._periodStart) * this._index.timescale) {
                if (this._scaledPeriodEnd < duration) {
                    return null;
                }
                return (Math.floor(this._scaledPeriodEnd / duration) - 1) * duration;
            }
            // /!\ The scaled last position augments continuously and might not
            // reflect exactly the real server-side value. As segments are
            // generated discretely.
            const scaledLastPosition = (lastPos - this._periodStart) * timescale;
            // Maximum position is before this period.
            // No segment is yet available here
            if (scaledLastPosition < 0) {
                return null;
            }
            const availabilityTimeOffset = ((this._availabilityTimeOffset !== undefined ? this._availabilityTimeOffset : 0) +
                agressiveModeOffset) * timescale;
            const numberOfSegmentsAvailable = Math.floor((scaledLastPosition + availabilityTimeOffset) / duration);
            return numberOfSegmentsAvailable <= 0 ?
                null :
                (numberOfSegmentsAvailable - 1) * duration;
        }
        else {
            const maximumTime = (_a = this._scaledPeriodEnd) !== null && _a !== void 0 ? _a : 0;
            const numberIndexedToZero = Math.ceil(maximumTime / duration) - 1;
            const regularLastSegmentStart = numberIndexedToZero * duration;
            // In some SegmentTemplate, we could think that there is one more
            // segment that there actually is due to a very little difference between
            // the period's duration and a multiple of a segment's duration.
            // Check that we're within a good margin
            const minimumDuration = MINIMUM_SEGMENT_SIZE * timescale;
            if (maximumTime - regularLastSegmentStart > minimumDuration ||
                numberIndexedToZero === 0) {
                return regularLastSegmentStart;
            }
            return (numberIndexedToZero - 1) * duration;
        }
    }
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/resolve_base_urls.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Array.<string>} currentBaseURLs
 * @param {Array.<Object>} newBaseURLs
 * @returns {Array.<string>}
 */
function resolveBaseURLs(currentBaseURLs, newBaseURLs) {
    const result = [];
    if (newBaseURLs.length === 0) {
        return currentBaseURLs;
    }
    else if (currentBaseURLs.length === 0) {
        for (let i = 0; i < newBaseURLs.length; i++) {
            if (!(0,array_includes/* default */.Z)(result, newBaseURLs[i].value)) {
                result.push(newBaseURLs[i].value);
            }
        }
        return result;
    }
    else {
        for (let i = 0; i < currentBaseURLs.length; i++) {
            const rootURL = currentBaseURLs[i];
            for (let j = 0; j < newBaseURLs.length; j++) {
                const newURL = (0,resolve_url/* default */.Z)(rootURL, newBaseURLs[j].value);
                if (!(0,array_includes/* default */.Z)(result, newURL)) {
                    result.push(newURL);
                }
            }
        }
    }
    return result;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// eslint-disable-next-line max-len



/**
 * Parse the specific segment indexing information found in a representation
 * into a IRepresentationIndex implementation.
 * @param {Array.<Object>} representation
 * @param {Object} representationInfos
 * @returns {Array.<Object>}
 */
function parseRepresentationIndex(representation, representationInfos) {
    var _a, _b;
    const representationBaseURLs = resolveBaseURLs(representationInfos.baseURLs, representation.children.baseURLs);
    const { aggressiveMode, availabilityTimeOffset, manifestBoundsCalculator, isDynamic, end: periodEnd, start: periodStart, receivedTime, timeShiftBufferDepth, unsafelyBaseOnPreviousRepresentation, inbandEventStreams } = representationInfos;
    const isEMSGWhitelisted = (inbandEvent) => {
        if (inbandEventStreams === undefined) {
            return false;
        }
        return inbandEventStreams
            .some(({ schemeIdUri }) => schemeIdUri === inbandEvent.schemeIdUri);
    };
    const context = { aggressiveMode,
        availabilityTimeOffset,
        unsafelyBaseOnPreviousRepresentation,
        isEMSGWhitelisted,
        manifestBoundsCalculator,
        isDynamic,
        periodEnd,
        periodStart,
        receivedTime,
        representationBaseURLs,
        representationBitrate: representation.attributes.bitrate,
        representationId: representation.attributes.id,
        timeShiftBufferDepth };
    let representationIndex;
    if (representation.children.segmentBase !== undefined) {
        const { segmentBase } = representation.children;
        context.availabilityTimeOffset =
            representationInfos.availabilityTimeOffset +
                extractMinimumAvailabilityTimeOffset(representation.children.baseURLs) +
                ((_a = segmentBase.availabilityTimeOffset) !== null && _a !== void 0 ? _a : 0);
        representationIndex = new BaseRepresentationIndex(segmentBase, context);
    }
    else if (representation.children.segmentList !== undefined) {
        const { segmentList } = representation.children;
        representationIndex = new ListRepresentationIndex(segmentList, context);
    }
    else if (representation.children.segmentTemplate !== undefined ||
        representationInfos.parentSegmentTemplates.length > 0) {
        const segmentTemplates = representationInfos.parentSegmentTemplates.slice();
        const childSegmentTemplate = representation.children.segmentTemplate;
        if (childSegmentTemplate !== undefined) {
            segmentTemplates.push(childSegmentTemplate);
        }
        const segmentTemplate = (0,object_assign/* default */.Z)({}, ...segmentTemplates /* Ugly TS Hack */);
        context.availabilityTimeOffset =
            representationInfos.availabilityTimeOffset +
                extractMinimumAvailabilityTimeOffset(representation.children.baseURLs) +
                ((_b = segmentTemplate.availabilityTimeOffset) !== null && _b !== void 0 ? _b : 0);
        const { timelineParser } = segmentTemplate;
        representationIndex = timelineParser !== undefined ?
            new timeline(segmentTemplate, timelineParser, context) :
            new TemplateRepresentationIndex(segmentTemplate, context);
    }
    else {
        const adaptationChildren = representationInfos.adaptation.children;
        if (adaptationChildren.segmentBase !== undefined) {
            const { segmentBase } = adaptationChildren;
            representationIndex = new BaseRepresentationIndex(segmentBase, context);
        }
        else if (adaptationChildren.segmentList !== undefined) {
            const { segmentList } = adaptationChildren;
            representationIndex = new ListRepresentationIndex(segmentList, context);
        }
        else {
            representationIndex = new TemplateRepresentationIndex({
                duration: Number.MAX_VALUE,
                timescale: 1,
                startNumber: 0,
                initialization: { media: "" },
                media: "",
            }, context);
        }
    }
    return representationIndex;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_representations.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Combine inband event streams from representation and
 * adaptation data.
 * @param {Object} representation
 * @param {Object} adaptation
 * @returns {undefined |Array.<Object>}
 */
function combineInbandEventStreams(representation, adaptation) {
    const newSchemeId = [];
    if (representation.children.inbandEventStreams !== undefined) {
        newSchemeId.push(...representation.children.inbandEventStreams);
    }
    if (adaptation.children.inbandEventStreams !== undefined) {
        newSchemeId.push(...adaptation.children.inbandEventStreams);
    }
    if (newSchemeId.length === 0) {
        return undefined;
    }
    return newSchemeId;
}
/**
 * Process intermediate representations to create final parsed representations.
 * @param {Array.<Object>} representationsIR
 * @param {Object} adaptationInfos
 * @returns {Array.<Object>}
 */
function parseRepresentations(representationsIR, adaptation, adaptationInfos) {
    var _a, _b;
    const parsedRepresentations = [];
    for (let reprIdx = 0; reprIdx < representationsIR.length; reprIdx++) {
        const representation = representationsIR[reprIdx];
        // Compute Representation ID
        let representationID = representation.attributes.id != null ?
            representation.attributes.id :
            (String(representation.attributes.bitrate) +
                (representation.attributes.height != null ?
                    (`-${representation.attributes.height}`) :
                    "") +
                (representation.attributes.width != null ?
                    (`-${representation.attributes.width}`) :
                    "") +
                (representation.attributes.mimeType != null ?
                    (`-${representation.attributes.mimeType}`) :
                    "") +
                (representation.attributes.codecs != null ?
                    (`-${representation.attributes.codecs}`) :
                    ""));
        // Avoid duplicate IDs
        while (parsedRepresentations.some(r => r.id === representationID)) {
            representationID += "-dup";
        }
        // Retrieve previous version of the Representation, if one.
        const unsafelyBaseOnPreviousRepresentation = (_b = (_a = adaptationInfos
            .unsafelyBaseOnPreviousAdaptation) === null || _a === void 0 ? void 0 : _a.getRepresentation(representationID)) !== null && _b !== void 0 ? _b : null;
        const inbandEventStreams = combineInbandEventStreams(representation, adaptation);
        const representationInfos = (0,object_assign/* default */.Z)({}, adaptationInfos, { unsafelyBaseOnPreviousRepresentation,
            adaptation,
            inbandEventStreams });
        const representationIndex = parseRepresentationIndex(representation, representationInfos);
        // Find bitrate
        let representationBitrate;
        if (representation.attributes.bitrate == null) {
            log/* default.warn */.Z.warn("DASH: No usable bitrate found in the Representation.");
            representationBitrate = 0;
        }
        else {
            representationBitrate = representation.attributes.bitrate;
        }
        // Construct Representation Base
        const parsedRepresentation = { bitrate: representationBitrate,
            index: representationIndex,
            id: representationID };
        // Add optional attributes
        let codecs;
        if (representation.attributes.codecs != null) {
            codecs = representation.attributes.codecs;
        }
        else if (adaptation.attributes.codecs != null) {
            codecs = adaptation.attributes.codecs;
        }
        if (codecs != null) {
            codecs = codecs === "mp4a.40.02" ? "mp4a.40.2" : codecs;
            parsedRepresentation.codecs = codecs;
        }
        if (representation.attributes.frameRate != null) {
            parsedRepresentation.frameRate =
                representation.attributes.frameRate;
        }
        else if (adaptation.attributes.frameRate != null) {
            parsedRepresentation.frameRate =
                adaptation.attributes.frameRate;
        }
        if (representation.attributes.height != null) {
            parsedRepresentation.height =
                representation.attributes.height;
        }
        else if (adaptation.attributes.height != null) {
            parsedRepresentation.height =
                adaptation.attributes.height;
        }
        if (representation.attributes.mimeType != null) {
            parsedRepresentation.mimeType =
                representation.attributes.mimeType;
        }
        else if (adaptation.attributes.mimeType != null) {
            parsedRepresentation.mimeType =
                adaptation.attributes.mimeType;
        }
        if (representation.attributes.width != null) {
            parsedRepresentation.width =
                representation.attributes.width;
        }
        else if (adaptation.attributes.width != null) {
            parsedRepresentation.width =
                adaptation.attributes.width;
        }
        if (adaptation.children.contentProtections != null) {
            const contentProtections = adaptation.children.contentProtections
                .reduce((acc, cp) => {
                let systemId;
                if (cp.attributes.schemeIdUri !== undefined &&
                    cp.attributes.schemeIdUri.substring(0, 9) === "urn:uuid:") {
                    systemId = cp.attributes.schemeIdUri.substring(9)
                        .replace(/-/g, "")
                        .toLowerCase();
                }
                if (cp.attributes.keyId !== undefined && cp.attributes.keyId.length > 0) {
                    acc.keyIds.push({ keyId: cp.attributes.keyId, systemId });
                }
                if (systemId !== undefined) {
                    const { cencPssh } = cp.children;
                    const values = [];
                    for (let i = 0; i < cencPssh.length; i++) {
                        const data = cencPssh[i];
                        values.push({ systemId, data });
                    }
                    if (values.length > 0) {
                        const cencInitData = (0,array_find/* default */.Z)(acc.initData, (i) => i.type === "cenc");
                        if (cencInitData === undefined) {
                            acc.initData.push({ type: "cenc", values });
                        }
                        else {
                            cencInitData.values.push(...values);
                        }
                    }
                }
                return acc;
            }, { keyIds: [], initData: [] });
            if (Object.keys(contentProtections.initData).length > 0 ||
                contentProtections.keyIds.length > 0) {
                parsedRepresentation.contentProtections = contentProtections;
            }
        }
        parsedRepresentations.push(parsedRepresentation);
    }
    return parsedRepresentations;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_adaptation_sets.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




// eslint-disable-next-line max-len




/**
 * Detect if the accessibility given defines an adaptation for the visually
 * impaired.
 * Based on DVB Document A168 (DVB-DASH) and DASH-IF 4.3.
 * @param {Object} accessibility
 * @returns {Boolean}
 */
function isVisuallyImpaired(accessibility) {
    if (accessibility == null) {
        return false;
    }
    const isVisuallyImpairedAudioDvbDash = (accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" &&
        accessibility.value === "1");
    const isVisuallyImpairedDashIf = (accessibility.schemeIdUri === "urn:mpeg:dash:role:2011" &&
        accessibility.value === "description");
    return isVisuallyImpairedAudioDvbDash || isVisuallyImpairedDashIf;
}
/**
 * Detect if the accessibility given defines an adaptation for the hard of
 * hearing.
 * Based on DVB Document A168 (DVB-DASH).
 * @param {Object} accessibility
 * @returns {Boolean}
 */
function isHardOfHearing(accessibility) {
    if (accessibility == null) {
        return false;
    }
    return (accessibility.schemeIdUri === "urn:tva:metadata:cs:AudioPurposeCS:2007" &&
        accessibility.value === "2");
}
/**
 * Detect if the accessibility given defines an AdaptationSet containing a sign
 * language interpretation.
 * Based on DASH-IF 4.3.
 * @param {Object} accessibility
 * @returns {Boolean}
 */
function hasSignLanguageInterpretation(accessibility) {
    if (accessibility == null) {
        return false;
    }
    return (accessibility.schemeIdUri === "urn:mpeg:dash:role:2011" &&
        accessibility.value === "sign");
}
/**
 * Contruct Adaptation ID from the information we have.
 * @param {Object} adaptation
 * @param {Array.<Object>} representations
 * @param {Object} infos
 * @returns {string}
 */
function getAdaptationID(adaptation, infos) {
    if ((0,is_non_empty_string/* default */.Z)(adaptation.attributes.id)) {
        return adaptation.attributes.id;
    }
    let idString = infos.type;
    if ((0,is_non_empty_string/* default */.Z)(adaptation.attributes.language)) {
        idString += `-${adaptation.attributes.language}`;
    }
    if (infos.isClosedCaption === true) {
        idString += "-cc";
    }
    if (infos.isAudioDescription === true) {
        idString += "-ad";
    }
    if (infos.isSignInterpreted === true) {
        idString += "-si";
    }
    if ((0,is_non_empty_string/* default */.Z)(adaptation.attributes.contentType)) {
        idString += `-${adaptation.attributes.contentType}`;
    }
    if ((0,is_non_empty_string/* default */.Z)(adaptation.attributes.codecs)) {
        idString += `-${adaptation.attributes.codecs}`;
    }
    if ((0,is_non_empty_string/* default */.Z)(adaptation.attributes.mimeType)) {
        idString += `-${adaptation.attributes.mimeType}`;
    }
    if ((0,is_non_empty_string/* default */.Z)(adaptation.attributes.frameRate)) {
        idString += `-${adaptation.attributes.frameRate}`;
    }
    return idString;
}
/**
 * Returns a list of ID this adaptation can be seamlessly switched to
 * @param {Object} adaptation
 * @returns {Array.<string>}
 */
function getAdaptationSetSwitchingIDs(adaptation) {
    if (adaptation.children.supplementalProperties != null) {
        const { supplementalProperties } = adaptation.children;
        for (let j = 0; j < supplementalProperties.length; j++) {
            const supplementalProperty = supplementalProperties[j];
            if (supplementalProperty.schemeIdUri ===
                "urn:mpeg:dash:adaptation-set-switching:2016" &&
                supplementalProperty.value != null) {
                return supplementalProperty.value.split(",")
                    .map(id => id.trim())
                    .filter(id => id);
            }
        }
    }
    return [];
}
/**
 * Process AdaptationSets intermediate representations to return under its final
 * form.
 * Note that the AdaptationSets returned are sorted by priority (from the most
 * priority to the least one).
 * @param {Array.<Object>} adaptationsIR
 * @param {Object} periodInfos
 * @returns {Array.<Object>}
 */
function parseAdaptationSets(adaptationsIR, periodInfos) {
    var _a, _b, _c, _d;
    const parsedAdaptations = {};
    const adaptationSwitchingInfos = {};
    const parsedAdaptationsIDs = [];
    /**
     * Index of the last parsed AdaptationSet with a Role set as "main" in
     * `parsedAdaptations` for a given type.
     * Not defined for a type with no main Adaptation inside.
     * This is used to put main AdaptationSet first in the resulting array of
     * Adaptation while still preserving the MPD order among them.
     */
    const lastMainAdaptationIndex = {};
    // first sort AdaptationSets by absolute priority.
    adaptationsIR.sort((a, b) => {
        var _a, _b;
        /* As of DASH-IF 4.3, `1` is the default value. */
        const priority1 = (_a = a.attributes.selectionPriority) !== null && _a !== void 0 ? _a : 1;
        const priority2 = (_b = b.attributes.selectionPriority) !== null && _b !== void 0 ? _b : 1;
        return priority2 - priority1;
    });
    for (let i = 0; i < adaptationsIR.length; i++) {
        const adaptation = adaptationsIR[i];
        const adaptationChildren = adaptation.children;
        const { essentialProperties, roles } = adaptationChildren;
        const isExclusivelyTrickModeTrack = (Array.isArray(essentialProperties) &&
            essentialProperties.some((ep) => ep.schemeIdUri === "http://dashif.org/guidelines/trickmode"));
        if (isExclusivelyTrickModeTrack) {
            // We do not for the moment parse trickmode tracks
            continue;
        }
        const isMainAdaptation = Array.isArray(roles) &&
            roles.some((role) => role.value === "main") &&
            roles.some((role) => role.schemeIdUri === "urn:mpeg:dash:role:2011");
        const representationsIR = adaptation.children.representations;
        const availabilityTimeOffset = extractMinimumAvailabilityTimeOffset(adaptation.children.baseURLs) +
            periodInfos.availabilityTimeOffset;
        const adaptationMimeType = adaptation.attributes.mimeType;
        const adaptationCodecs = adaptation.attributes.codecs;
        const type = inferAdaptationType(representationsIR, (0,is_non_empty_string/* default */.Z)(adaptationMimeType) ?
            adaptationMimeType :
            null, (0,is_non_empty_string/* default */.Z)(adaptationCodecs) ?
            adaptationCodecs :
            null, adaptationChildren.roles != null ?
            adaptationChildren.roles :
            null);
        if (type === undefined) {
            continue;
        }
        const originalID = adaptation.attributes.id;
        let newID;
        const adaptationSetSwitchingIDs = getAdaptationSetSwitchingIDs(adaptation);
        const parentSegmentTemplates = [];
        if (periodInfos.segmentTemplate !== undefined) {
            parentSegmentTemplates.push(periodInfos.segmentTemplate);
        }
        if (adaptation.children.segmentTemplate !== undefined) {
            parentSegmentTemplates.push(adaptation.children.segmentTemplate);
        }
        const adaptationInfos = {
            aggressiveMode: periodInfos.aggressiveMode,
            availabilityTimeOffset,
            baseURLs: resolveBaseURLs(periodInfos.baseURLs, adaptationChildren.baseURLs),
            manifestBoundsCalculator: periodInfos.manifestBoundsCalculator,
            end: periodInfos.end,
            isDynamic: periodInfos.isDynamic,
            parentSegmentTemplates,
            receivedTime: periodInfos.receivedTime,
            start: periodInfos.start,
            timeShiftBufferDepth: periodInfos.timeShiftBufferDepth,
            unsafelyBaseOnPreviousAdaptation: null,
        };
        if (type === "video" &&
            isMainAdaptation &&
            parsedAdaptations.video !== undefined &&
            parsedAdaptations.video.length > 0 &&
            lastMainAdaptationIndex.video !== undefined) {
            // Add to the already existing main video adaptation
            // TODO remove that ugly custom logic?
            const videoMainAdaptation = parsedAdaptations.video[lastMainAdaptationIndex.video];
            adaptationInfos.unsafelyBaseOnPreviousAdaptation = (_b = (_a = periodInfos
                .unsafelyBaseOnPreviousPeriod) === null || _a === void 0 ? void 0 : _a.getAdaptation(videoMainAdaptation.id)) !== null && _b !== void 0 ? _b : null;
            const representations = parseRepresentations(representationsIR, adaptation, adaptationInfos);
            videoMainAdaptation.representations.push(...representations);
            newID = videoMainAdaptation.id;
        }
        else {
            const { accessibilities } = adaptationChildren;
            let isDub;
            if (roles !== undefined &&
                roles.some((role) => role.value === "dub")) {
                isDub = true;
            }
            let isClosedCaption;
            if (type !== "text") {
                isClosedCaption = false;
            }
            else if (accessibilities !== undefined) {
                isClosedCaption = accessibilities.some(isHardOfHearing);
            }
            let isAudioDescription;
            if (type !== "audio") {
                isAudioDescription = false;
            }
            else if (accessibilities !== undefined) {
                isAudioDescription = accessibilities.some(isVisuallyImpaired);
            }
            let isSignInterpreted;
            if (type !== "video") {
                isSignInterpreted = false;
            }
            else if (accessibilities !== undefined) {
                isSignInterpreted = accessibilities.some(hasSignLanguageInterpretation);
            }
            let adaptationID = getAdaptationID(adaptation, { isAudioDescription,
                isClosedCaption,
                isSignInterpreted,
                type });
            // Avoid duplicate IDs
            while ((0,array_includes/* default */.Z)(parsedAdaptationsIDs, adaptationID)) {
                adaptationID += "-dup";
            }
            newID = adaptationID;
            parsedAdaptationsIDs.push(adaptationID);
            adaptationInfos.unsafelyBaseOnPreviousAdaptation = (_d = (_c = periodInfos
                .unsafelyBaseOnPreviousPeriod) === null || _c === void 0 ? void 0 : _c.getAdaptation(adaptationID)) !== null && _d !== void 0 ? _d : null;
            const representations = parseRepresentations(representationsIR, adaptation, adaptationInfos);
            const parsedAdaptationSet = { id: adaptationID,
                representations,
                type };
            if (adaptation.attributes.language != null) {
                parsedAdaptationSet.language = adaptation.attributes.language;
            }
            if (isClosedCaption != null) {
                parsedAdaptationSet.closedCaption = isClosedCaption;
            }
            if (isAudioDescription != null) {
                parsedAdaptationSet.audioDescription = isAudioDescription;
            }
            if (isDub === true) {
                parsedAdaptationSet.isDub = true;
            }
            if (isSignInterpreted === true) {
                parsedAdaptationSet.isSignInterpreted = true;
            }
            const adaptationsOfTheSameType = parsedAdaptations[type];
            if (adaptationsOfTheSameType === undefined) {
                parsedAdaptations[type] = [parsedAdaptationSet];
                if (isMainAdaptation) {
                    lastMainAdaptationIndex[type] = 0;
                }
            }
            else {
                let mergedInto = null;
                // look if we have to merge this into another Adaptation
                for (let k = 0; k < adaptationSetSwitchingIDs.length; k++) {
                    const id = adaptationSetSwitchingIDs[k];
                    const switchingInfos = adaptationSwitchingInfos[id];
                    if (switchingInfos != null &&
                        switchingInfos.newID !== newID &&
                        (0,array_includes/* default */.Z)(switchingInfos.adaptationSetSwitchingIDs, originalID)) {
                        const adaptationToMergeInto = (0,array_find/* default */.Z)(adaptationsOfTheSameType, (a) => a.id === id);
                        if (adaptationToMergeInto != null &&
                            adaptationToMergeInto.audioDescription ===
                                parsedAdaptationSet.audioDescription &&
                            adaptationToMergeInto.closedCaption ===
                                parsedAdaptationSet.closedCaption &&
                            adaptationToMergeInto.language === parsedAdaptationSet.language) {
                            log/* default.info */.Z.info("DASH Parser: merging \"switchable\" AdaptationSets", originalID, id);
                            adaptationToMergeInto.representations
                                .push(...parsedAdaptationSet.representations);
                            mergedInto = adaptationToMergeInto;
                        }
                    }
                }
                if (isMainAdaptation) {
                    const oldLastMainIdx = lastMainAdaptationIndex[type];
                    const newLastMainIdx = oldLastMainIdx === undefined ? 0 :
                        oldLastMainIdx + 1;
                    if (mergedInto === null) {
                        // put "main" Adaptation after all other Main Adaptations
                        adaptationsOfTheSameType.splice(newLastMainIdx, 0, parsedAdaptationSet);
                        lastMainAdaptationIndex[type] = newLastMainIdx;
                    }
                    else {
                        const indexOf = adaptationsOfTheSameType.indexOf(mergedInto);
                        if (indexOf < 0) { // Weird, not found
                            adaptationsOfTheSameType.splice(newLastMainIdx, 0, parsedAdaptationSet);
                            lastMainAdaptationIndex[type] = newLastMainIdx;
                        }
                        else if (oldLastMainIdx === undefined || indexOf > oldLastMainIdx) {
                            // Found but was not main
                            adaptationsOfTheSameType.splice(indexOf, 1);
                            adaptationsOfTheSameType.splice(newLastMainIdx, 0, mergedInto);
                            lastMainAdaptationIndex[type] = newLastMainIdx;
                        }
                    }
                }
                else if (mergedInto === null) {
                    adaptationsOfTheSameType.push(parsedAdaptationSet);
                }
            }
        }
        if (originalID != null && adaptationSwitchingInfos[originalID] == null) {
            adaptationSwitchingInfos[originalID] = { newID,
                adaptationSetSwitchingIDs };
        }
    }
    return parsedAdaptations;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_periods.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




// eslint-disable-next-line max-len






const generatePeriodID = (0,id_generator/* default */.Z)();
/**
 * Process intermediate periods to create final parsed periods.
 * @param {Array.<Object>} periodsIR
 * @param {Object} contextInfos
 * @returns {Array.<Object>}
 */
function parsePeriods(periodsIR, contextInfos) {
    var _a, _b, _c;
    const parsedPeriods = [];
    const periodsTimeInformation = getPeriodsTimeInformation(periodsIR, contextInfos);
    if (periodsTimeInformation.length !== periodsIR.length) {
        throw new Error("MPD parsing error: the time information are incoherent.");
    }
    const { isDynamic, timeShiftBufferDepth } = contextInfos;
    const manifestBoundsCalculator = new ManifestBoundsCalculator({ isDynamic,
        timeShiftBufferDepth });
    if (!isDynamic && contextInfos.duration != null) {
        manifestBoundsCalculator.setLastPosition(contextInfos.duration);
    }
    // We parse it in reverse because we might need to deduce the buffer depth from
    // the last Periods' indexes
    for (let i = periodsIR.length - 1; i >= 0; i--) {
        const periodIR = periodsIR[i];
        const xlinkInfos = contextInfos.xlinkInfos.get(periodIR);
        const periodBaseURLs = resolveBaseURLs(contextInfos.baseURLs, periodIR.children.baseURLs);
        const { periodStart, periodDuration, periodEnd } = periodsTimeInformation[i];
        let periodID;
        if (periodIR.attributes.id == null) {
            log/* default.warn */.Z.warn("DASH: No usable id found in the Period. Generating one.");
            periodID = "gen-dash-period-" + generatePeriodID();
        }
        else {
            periodID = periodIR.attributes.id;
        }
        // Avoid duplicate IDs
        while (parsedPeriods.some(p => p.id === periodID)) {
            periodID += "-dup";
        }
        const receivedTime = xlinkInfos !== undefined ? xlinkInfos.receivedTime :
            contextInfos.receivedTime;
        const availabilityTimeOffset = extractMinimumAvailabilityTimeOffset(periodIR.children.baseURLs) +
            contextInfos.availabilityTimeOffset;
        const unsafelyBaseOnPreviousPeriod = (_b = (_a = contextInfos
            .unsafelyBaseOnPreviousManifest) === null || _a === void 0 ? void 0 : _a.getPeriod(periodID)) !== null && _b !== void 0 ? _b : null;
        const periodInfos = { aggressiveMode: contextInfos.aggressiveMode,
            availabilityTimeOffset,
            baseURLs: periodBaseURLs,
            manifestBoundsCalculator,
            end: periodEnd,
            isDynamic,
            receivedTime,
            segmentTemplate: periodIR.children.segmentTemplate,
            start: periodStart,
            timeShiftBufferDepth,
            unsafelyBaseOnPreviousPeriod };
        const adaptations = parseAdaptationSets(periodIR.children.adaptations, periodInfos);
        const streamEvents = (_c = periodIR.children.streamEvents) === null || _c === void 0 ? void 0 : _c.map((event) => {
            var _a;
            const start = (((_a = event.eventPresentationTime) !== null && _a !== void 0 ? _a : 0) / event.timescale) + periodStart;
            const end = event.duration !== undefined ? start + event.duration / event.timescale :
                undefined;
            return { start,
                end,
                data: event.data,
                id: event.id };
        });
        const parsedPeriod = { id: periodID,
            start: periodStart,
            end: periodEnd,
            duration: periodDuration,
            adaptations,
            streamEvents };
        parsedPeriods.unshift(parsedPeriod);
        if (!manifestBoundsCalculator.lastPositionIsKnown()) {
            const lastPosition = getMaximumLastPosition(adaptations);
            if (!isDynamic) {
                if (typeof lastPosition === "number") {
                    manifestBoundsCalculator.setLastPosition(lastPosition);
                }
            }
            else {
                if (typeof lastPosition === "number") {
                    const positionTime = performance.now() / 1000;
                    manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
                }
                else {
                    const guessedLastPositionFromClock = guessLastPositionFromClock(contextInfos, periodStart);
                    if (guessedLastPositionFromClock !== undefined) {
                        const [guessedLastPosition, guessedPositionTime] = guessedLastPositionFromClock;
                        manifestBoundsCalculator.setLastPosition(guessedLastPosition, guessedPositionTime);
                    }
                }
            }
        }
    }
    if (contextInfos.isDynamic && !manifestBoundsCalculator.lastPositionIsKnown()) {
        // Guess a last time the last position
        const guessedLastPositionFromClock = guessLastPositionFromClock(contextInfos, 0);
        if (guessedLastPositionFromClock !== undefined) {
            const [lastPosition, positionTime] = guessedLastPositionFromClock;
            manifestBoundsCalculator.setLastPosition(lastPosition, positionTime);
        }
    }
    return flattenOverlappingPeriods(parsedPeriods);
}
/**
 * Try to guess the "last position", which is the last position
 * available in the manifest in seconds, and the "position time", the time
 * (`performance.now()`) in which the last position was collected.
 *
 * These values allows to retrieve at any time in the future the new last
 * position, by substracting the position time to the last position, and
 * adding to it the new value returned by `performance.now`.
 *
 * The last position and position time are returned by this function if and only if
 * it would indicate a last position superior to the `minimumTime` given.
 *
 * This last part allows for example to detect which Period is likely to be the
 * "current" one in multi-periods contents. By giving the Period's start as a
 * `minimumTime`, you ensure that you will get a value only if the current time
 * is in that period.
 *
 * This is useful as guessing the live time from the clock can be seen as a last
 * resort. By detecting that the current time is before the currently considered
 * Period, we can just parse and look at the previous Period. If we can guess
 * the live time more directly from that previous one, we might be better off
 * than just using the clock.
 *
 * @param {Object} contextInfos
 * @param {number} minimumTime
 * @returns {Array.<number|undefined>}
 */
function guessLastPositionFromClock(contextInfos, minimumTime) {
    if (contextInfos.clockOffset != null) {
        const lastPosition = contextInfos.clockOffset / 1000 -
            contextInfos.availabilityStartTime;
        const positionTime = performance.now() / 1000;
        const timeInSec = positionTime + lastPosition;
        if (timeInSec >= minimumTime) {
            return [timeInSec, positionTime];
        }
    }
    else {
        const now = Date.now() / 1000;
        if (now >= minimumTime) {
            log/* default.warn */.Z.warn("DASH Parser: no clock synchronization mechanism found." +
                " Using the system clock instead.");
            const lastPosition = now - contextInfos.availabilityStartTime;
            const positionTime = performance.now() / 1000;
            return [lastPosition, positionTime];
        }
    }
    return undefined;
}
/**
 * Try to extract the last position declared for any segments in a Period:
 *   - If at least a single index' last position is defined, take the maximum
 *     among them.
 *   - If segments are available but we cannot define the last position
 *     return undefined.
 *   - If no segment are available in that period, return null
 * @param {Object} adaptationsPerType
 * @returns {number|null|undefined}
 */
function getMaximumLastPosition(adaptationsPerType) {
    let maxEncounteredPosition = null;
    let allIndexAreEmpty = true;
    const adaptationsVal = (0,object_values/* default */.Z)(adaptationsPerType)
        .filter((ada) => ada != null);
    const allAdaptations = (0,flat_map/* default */.Z)(adaptationsVal, (adaptationsForType) => adaptationsForType);
    for (let adapIndex = 0; adapIndex < allAdaptations.length; adapIndex++) {
        const representations = allAdaptations[adapIndex].representations;
        for (let repIndex = 0; repIndex < representations.length; repIndex++) {
            const representation = representations[repIndex];
            const position = representation.index.getLastPosition();
            if (position !== null) {
                allIndexAreEmpty = false;
                if (typeof position === "number") {
                    maxEncounteredPosition =
                        maxEncounteredPosition == null ? position :
                            Math.max(maxEncounteredPosition, position);
                }
            }
        }
    }
    if (maxEncounteredPosition != null) {
        return maxEncounteredPosition;
    }
    else if (allIndexAreEmpty) {
        return null;
    }
    return undefined;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_mpd.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




// eslint-disable-next-line max-len









const { DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0 } = config/* default */.Z;
/**
 * @param {Element} root - The MPD root.
 * @param {Object} args
 * @returns {Object}
 */
function parseMPD(root, args) {
    // Transform whole MPD into a parsed JS object representation
    const [mpdIR, warnings] = createMPDIntermediateRepresentation(root);
    return loadExternalRessourcesAndParse(mpdIR, args, warnings);
}
/**
 * Checks if xlinks needs to be loaded before actually parsing the manifest.
 * @param {Object} mpdIR
 * @param {Object} args
 * @param {Array.<Object>} warnings
 * @returns {Object}
 */
function loadExternalRessourcesAndParse(mpdIR, args, warnings, hasLoadedClock) {
    const { children: rootChildren, attributes: rootAttributes } = mpdIR;
    const xlinkInfos = new WeakMap();
    if (args.externalClockOffset == null) {
        const isDynamic = rootAttributes.type === "dynamic";
        const directTiming = (0,array_find/* default */.Z)(rootChildren.utcTimings, (utcTiming) => {
            return utcTiming.schemeIdUri === "urn:mpeg:dash:utc:direct:2014" &&
                utcTiming.value != null;
        });
        const clockOffsetFromDirectUTCTiming = directTiming != null &&
            directTiming.value != null ? getClockOffset(directTiming.value) :
            undefined;
        let clockOffset = clockOffsetFromDirectUTCTiming != null &&
            !isNaN(clockOffsetFromDirectUTCTiming) ?
            clockOffsetFromDirectUTCTiming :
            undefined;
        if (clockOffset != null) {
            args.externalClockOffset = clockOffset;
        }
        else if (isDynamic && hasLoadedClock !== true) {
            const UTCTimingHTTPURL = getHTTPUTCTimingURL(mpdIR);
            if (UTCTimingHTTPURL != null && UTCTimingHTTPURL.length > 0) {
                // TODO fetch UTCTiming and XLinks at the same time
                return {
                    type: "needs-ressources",
                    value: {
                        ressources: [UTCTimingHTTPURL],
                        continue: function continueParsingMPD(loadedRessources) {
                            if (loadedRessources.length !== 1) {
                                throw new Error("DASH parser: wrong number of loaded ressources.");
                            }
                            clockOffset = getClockOffset(loadedRessources[0].responseData);
                            args.externalClockOffset = clockOffset;
                            return loadExternalRessourcesAndParse(mpdIR, args, warnings, true);
                        },
                    },
                };
            }
        }
    }
    const xlinksToLoad = [];
    for (let i = 0; i < rootChildren.periods.length; i++) {
        const { xlinkHref, xlinkActuate } = rootChildren.periods[i].attributes;
        if (xlinkHref != null && xlinkActuate === "onLoad") {
            xlinksToLoad.push({ index: i, ressource: xlinkHref });
        }
    }
    if (xlinksToLoad.length === 0) {
        return parseCompleteIntermediateRepresentation(mpdIR, args, warnings, xlinkInfos);
    }
    return {
        type: "needs-ressources",
        value: {
            ressources: xlinksToLoad.map(({ ressource }) => ressource),
            continue: function continueParsingMPD(loadedRessources) {
                if (loadedRessources.length !== xlinksToLoad.length) {
                    throw new Error("DASH parser: wrong number of loaded ressources.");
                }
                // Note: It is important to go from the last index to the first index in
                // the resulting array, as we will potentially add elements to the array
                for (let i = loadedRessources.length - 1; i >= 0; i--) {
                    const index = xlinksToLoad[i].index;
                    const { responseData: xlinkData, receivedTime, sendingTime, url } = loadedRessources[i];
                    const wrappedData = "<root>" + xlinkData + "</root>";
                    const dataAsXML = new DOMParser().parseFromString(wrappedData, "text/xml");
                    if (dataAsXML == null || dataAsXML.children.length === 0) {
                        throw new Error("DASH parser: Invalid external ressources");
                    }
                    const periods = dataAsXML.children[0].children;
                    const periodsIR = [];
                    for (let j = 0; j < periods.length; j++) {
                        if (periods[j].nodeType === Node.ELEMENT_NODE) {
                            const [periodIR, periodWarnings] = createPeriodIntermediateRepresentation(periods[j]);
                            xlinkInfos.set(periodIR, { receivedTime, sendingTime, url });
                            periodsIR.push(periodIR);
                            if (periodWarnings.length > 0) {
                                warnings.push(...periodWarnings);
                            }
                        }
                    }
                    // replace original "xlinked" periods by the real deal
                    rootChildren.periods.splice(index, 1, ...periodsIR);
                }
                return loadExternalRessourcesAndParse(mpdIR, args, warnings);
            },
        },
    };
}
/**
 * Parse the MPD intermediate representation into a regular Manifest.
 * @param {Object} mpdIR
 * @param {Object} args
 * @param {Array.<Object>} warnings
 * @param {Object} xlinkInfos
 * @returns {Object}
 */
function parseCompleteIntermediateRepresentation(mpdIR, args, warnings, xlinkInfos) {
    var _a, _b;
    const { children: rootChildren, attributes: rootAttributes } = mpdIR;
    const isDynamic = rootAttributes.type === "dynamic";
    const baseURLs = resolveBaseURLs(args.url === undefined ?
        [] :
        [(0,resolve_url/* normalizeBaseURL */.f)(args.url)], rootChildren.baseURLs);
    const availabilityStartTime = parseAvailabilityStartTime(rootAttributes, args.referenceDateTime);
    const timeShiftBufferDepth = rootAttributes.timeShiftBufferDepth;
    const { externalClockOffset: clockOffset, unsafelyBaseOnPreviousManifest } = args;
    const availabilityTimeOffset = extractMinimumAvailabilityTimeOffset(rootChildren.baseURLs);
    const manifestInfos = { aggressiveMode: args.aggressiveMode,
        availabilityStartTime,
        availabilityTimeOffset,
        baseURLs,
        clockOffset,
        duration: rootAttributes.duration,
        isDynamic,
        receivedTime: args.manifestReceivedTime,
        timeShiftBufferDepth,
        unsafelyBaseOnPreviousManifest,
        xlinkInfos };
    const parsedPeriods = parsePeriods(rootChildren.periods, manifestInfos);
    const mediaPresentationDuration = rootAttributes.duration;
    let lifetime;
    let minimumTime;
    let timeshiftDepth = null;
    let maximumTimeData;
    if (rootAttributes.minimumUpdatePeriod !== undefined &&
        rootAttributes.minimumUpdatePeriod >= 0) {
        lifetime = rootAttributes.minimumUpdatePeriod === 0 ?
            DASH_FALLBACK_LIFETIME_WHEN_MINIMUM_UPDATE_PERIOD_EQUAL_0 :
            rootAttributes.minimumUpdatePeriod;
    }
    const [contentStart, contentEnd] = getMinimumAndMaximumPosition(parsedPeriods);
    const now = performance.now();
    if (!isDynamic) {
        minimumTime = contentStart !== undefined ? contentStart :
            ((_a = parsedPeriods[0]) === null || _a === void 0 ? void 0 : _a.start) !== undefined ? parsedPeriods[0].start :
                0;
        let maximumTime;
        if (contentEnd !== undefined) {
            maximumTime = contentEnd;
        }
        else if (mediaPresentationDuration !== undefined) {
            maximumTime = mediaPresentationDuration;
        }
        else if (parsedPeriods[parsedPeriods.length - 1] !== undefined) {
            const lastPeriod = parsedPeriods[parsedPeriods.length - 1];
            maximumTime = (_b = lastPeriod.end) !== null && _b !== void 0 ? _b : (lastPeriod.duration !== undefined ?
                lastPeriod.start + lastPeriod.duration :
                undefined);
        }
        maximumTimeData = { isLinear: false, value: maximumTime !== null && maximumTime !== void 0 ? maximumTime : Infinity, time: now };
    }
    else {
        minimumTime = contentStart;
        timeshiftDepth = timeShiftBufferDepth !== null && timeShiftBufferDepth !== void 0 ? timeShiftBufferDepth : null;
        let maximumTime;
        if (contentEnd !== undefined) {
            maximumTime = contentEnd;
        }
        else {
            const ast = availabilityStartTime !== null && availabilityStartTime !== void 0 ? availabilityStartTime : 0;
            const { externalClockOffset } = args;
            if (externalClockOffset === undefined) {
                log/* default.warn */.Z.warn("DASH Parser: use system clock to define maximum position");
                maximumTime = (Date.now() / 1000) - ast;
            }
            else {
                const serverTime = performance.now() + externalClockOffset;
                maximumTime = (serverTime / 1000) - ast;
            }
        }
        maximumTimeData = { isLinear: true,
            value: maximumTime,
            time: now };
        // if the minimum calculated time is even below the buffer depth, perhaps we
        // can go even lower in terms of depth
        if (timeshiftDepth !== null && minimumTime !== undefined &&
            maximumTime - minimumTime > timeshiftDepth) {
            timeshiftDepth = maximumTime - minimumTime;
        }
    }
    const parsedMPD = {
        availabilityStartTime,
        clockOffset: args.externalClockOffset,
        isDynamic,
        isLive: isDynamic,
        periods: parsedPeriods,
        publishTime: rootAttributes.publishTime,
        suggestedPresentationDelay: rootAttributes.suggestedPresentationDelay,
        transportType: "dash",
        timeBounds: { absoluteMinimumTime: minimumTime,
            timeshiftDepth,
            maximumTimeData },
        lifetime,
        uris: args.url == null ?
            rootChildren.locations : [args.url, ...rootChildren.locations],
    };
    return { type: "done", value: { parsed: parsedMPD, warnings } };
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/parse_from_document.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Document} manifest - Original manifest as returned by the server
 * @param {Object} args
 * @returns {Object} - parsed manifest
 */
function parseFromDocument(document, args) {
    const root = document.documentElement;
    if (root == null || root.nodeName !== "MPD") {
        throw new Error("DASH Parser: document root should be MPD");
    }
    return parseMPD(root, args);
}

;// CONCATENATED MODULE: ./src/parsers/manifest/dash/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ const dash = (parseFromDocument);


// EXTERNAL MODULE: ./src/transports/utils/return_parsed_manifest.ts
var return_parsed_manifest = __webpack_require__(97275);
;// CONCATENATED MODULE: ./src/transports/dash/manifest_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Request external "xlink" ressource from a MPD.
 * @param {string} xlinkURL
 * @returns {Observable}
 */
function requestStringResource(url) {
    return (0,request/* default */.ZP)({ url,
        responseType: "text" })
        .pipe((0,filter/* filter */.h)((e) => e.type === "data-loaded"), (0,map/* map */.U)((e) => e.value));
}
/**
 * @param {Object} options
 * @returns {Function}
 */
function generateManifestParser(options) {
    const { aggressiveMode, referenceDateTime } = options;
    const serverTimeOffset = options.serverSyncInfos !== undefined ?
        options.serverSyncInfos.serverTimestamp - options.serverSyncInfos.clientTime :
        undefined;
    return function manifestParser(args) {
        var _a;
        const { response, scheduleRequest } = args;
        const argClockOffset = args.externalClockOffset;
        const loaderURL = args.url;
        const url = (_a = response.url) !== null && _a !== void 0 ? _a : loaderURL;
        const data = typeof response.responseData === "string" ?
            new DOMParser().parseFromString(response.responseData, "text/xml") :
            // TODO find a way to check if Document?
            response.responseData;
        const externalClockOffset = serverTimeOffset !== null && serverTimeOffset !== void 0 ? serverTimeOffset : argClockOffset;
        const unsafelyBaseOnPreviousManifest = args.unsafeMode ? args.previousManifest :
            null;
        const parsedManifest = dash(data, { aggressiveMode: aggressiveMode === true,
            unsafelyBaseOnPreviousManifest,
            url,
            referenceDateTime,
            externalClockOffset });
        return loadExternalResources(parsedManifest);
        function loadExternalResources(parserResponse) {
            if (parserResponse.type === "done") {
                const { warnings, parsed } = parserResponse.value;
                const warningEvents = warnings.map(warning => ({ type: "warning", value: warning }));
                const manifest = new src_manifest/* default */.ZP(parsed, options);
                return (0,concat/* concat */.z)((0,of.of)(...warningEvents), (0,return_parsed_manifest/* default */.Z)(manifest, url));
            }
            const { ressources, continue: continueParsing } = parserResponse.value;
            const externalResources$ = ressources
                .map(resource => scheduleRequest(() => requestStringResource(resource)));
            return (0,combineLatest/* combineLatest */.aj)(externalResources$)
                .pipe((0,mergeMap/* mergeMap */.zg)(loadedResources => {
                const resources = [];
                for (let i = 0; i < loadedResources.length; i++) {
                    const resource = loadedResources[i];
                    if (typeof resource.responseData !== "string") {
                        throw new Error("External DASH resources should only be strings");
                    }
                    // Normally not needed but TypeScript is just dumb here
                    resources.push((0,object_assign/* default */.Z)(resource, { responseData: resource.responseData }));
                }
                return loadExternalResources(continueParsing(resources));
            }));
        }
    };
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(30365);
// EXTERNAL MODULE: ./src/errors/request_error.ts
var request_error = __webpack_require__(13307);
// EXTERNAL MODULE: ./src/errors/error_codes.ts
var error_codes = __webpack_require__(35659);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(32825);
;// CONCATENATED MODULE: ./src/utils/request/fetch.ts
/*
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





const { DEFAULT_REQUEST_TIMEOUT } = config/* default */.Z;
const _Headers = typeof Headers === "function" ? Headers :
    null;
const _AbortController = typeof AbortController === "function" ?
    AbortController :
    null;
function fetchRequest(options) {
    let headers;
    if (!(0,is_null_or_undefined/* default */.Z)(options.headers)) {
        if ((0,is_null_or_undefined/* default */.Z)(_Headers)) {
            headers = options.headers;
        }
        else {
            headers = new _Headers();
            const headerNames = Object.keys(options.headers);
            for (let i = 0; i < headerNames.length; i++) {
                const headerName = headerNames[i];
                headers.append(headerName, options.headers[headerName]);
            }
        }
    }
    return new Observable/* Observable */.y((obs) => {
        log/* default.debug */.Z.debug("Fetch: Called with URL", options.url);
        let hasAborted = false;
        let timeouted = false;
        let isDone = false;
        const sendingTime = performance.now();
        const abortController = !(0,is_null_or_undefined/* default */.Z)(_AbortController) ? new _AbortController() :
            null;
        /**
         * Abort current fetchRequest by triggering AbortController signal.
         * @returns {void}
         */
        function abortRequest() {
            if (!isDone) {
                if (!(0,is_null_or_undefined/* default */.Z)(abortController)) {
                    abortController.abort();
                    return;
                }
                log/* default.warn */.Z.warn("Fetch: AbortController API not available.");
            }
        }
        const requestTimeout = (0,is_null_or_undefined/* default */.Z)(options.timeout) ?
            DEFAULT_REQUEST_TIMEOUT :
            options.timeout;
        const timeout = window.setTimeout(() => {
            timeouted = true;
            abortRequest();
        }, requestTimeout);
        fetch(options.url, { headers,
            method: "GET",
            signal: !(0,is_null_or_undefined/* default */.Z)(abortController) ? abortController.signal :
                undefined }).then((response) => {
            if (!(0,is_null_or_undefined/* default */.Z)(timeout)) {
                clearTimeout(timeout);
            }
            if (response.status >= 300) {
                log/* default.warn */.Z.warn("Fetch: Request HTTP Error", response);
                obs.error(new request_error/* default */.Z(response.url, response.status, error_codes/* NetworkErrorTypes.ERROR_HTTP_CODE */.br.ERROR_HTTP_CODE));
                return undefined;
            }
            if ((0,is_null_or_undefined/* default */.Z)(response.body)) {
                obs.error(new request_error/* default */.Z(response.url, response.status, error_codes/* NetworkErrorTypes.PARSE_ERROR */.br.PARSE_ERROR));
                return undefined;
            }
            const contentLengthHeader = response.headers.get("Content-Length");
            const contentLength = !(0,is_null_or_undefined/* default */.Z)(contentLengthHeader) &&
                !isNaN(+contentLengthHeader) ? +contentLengthHeader :
                undefined;
            const reader = response.body.getReader();
            let size = 0;
            return readBufferAndSendEvents();
            async function readBufferAndSendEvents() {
                const data = await reader.read();
                if (!data.done && !(0,is_null_or_undefined/* default */.Z)(data.value)) {
                    size += data.value.byteLength;
                    const currentTime = performance.now();
                    const dataChunk = { type: "data-chunk", value: { url: response.url,
                            currentTime,
                            duration: currentTime - sendingTime,
                            sendingTime,
                            chunkSize: data.value.byteLength,
                            chunk: data.value.buffer,
                            size,
                            totalSize: contentLength } };
                    obs.next(dataChunk);
                    return readBufferAndSendEvents();
                }
                else if (data.done) {
                    const receivedTime = performance.now();
                    const duration = receivedTime - sendingTime;
                    isDone = true;
                    obs.next({ type: "data-complete", value: { duration,
                            receivedTime,
                            sendingTime,
                            size,
                            status: response.status,
                            url: response.url } });
                    obs.complete();
                }
            }
        }).catch((err) => {
            if (hasAborted) {
                log/* default.debug */.Z.debug("Fetch: Request aborted.");
                return;
            }
            if (timeouted) {
                log/* default.warn */.Z.warn("Fetch: Request timeouted.");
                obs.error(new request_error/* default */.Z(options.url, 0, error_codes/* NetworkErrorTypes.TIMEOUT */.br.TIMEOUT));
                return;
            }
            log/* default.warn */.Z.warn("Fetch: Request Error", err instanceof Error ?
                err.toString() :
                "");
            obs.error(new request_error/* default */.Z(options.url, 0, error_codes/* NetworkErrorTypes.ERROR_EVENT */.br.ERROR_EVENT));
            return;
        });
        return () => {
            hasAborted = true;
            abortRequest();
        };
    });
}
/**
 * Returns true if fetch should be supported in the current browser.
 * @return {boolean}
 */
function fetchIsSupported() {
    return (typeof window.fetch === "function" &&
        !(0,is_null_or_undefined/* default */.Z)(_AbortController) &&
        !(0,is_null_or_undefined/* default */.Z)(_Headers));
}
/* harmony default export */ const request_fetch = (fetchRequest);

// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(73973);
// EXTERNAL MODULE: ./src/transports/utils/byte_range.ts
var byte_range = __webpack_require__(25602);
// EXTERNAL MODULE: ./src/transports/utils/is_webm_embedded_track.ts
var is_webm_embedded_track = __webpack_require__(55057);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(5842);
// EXTERNAL MODULE: ./src/transports/utils/check_isobmff_integrity.ts
var check_isobmff_integrity = __webpack_require__(47795);
;// CONCATENATED MODULE: ./src/transports/dash/add_segment_integrity_checks_to_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



function addSegmentIntegrityChecks(segmentLoader) {
    return (content) => segmentLoader(content).pipe((0,tap/* tap */.b)((res) => {
        if ((res.type === "data-loaded" || res.type === "data-chunk") &&
            res.value.responseData !== null &&
            typeof res.value.responseData !== "string" &&
            !(0,is_webm_embedded_track/* default */.Z)(content.representation)) {
            (0,check_isobmff_integrity/* default */.Z)(new Uint8Array(res.value.responseData), content.segment.isInit);
        }
    }));
}

// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(97308);
;// CONCATENATED MODULE: ./src/transports/dash/init_segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Perform a request for an initialization segment, agnostic to the container.
 * @param {string} url
 * @param {Object} content
 */
function initSegmentLoader(url, { segment }) {
    if (segment.range === undefined) {
        return (0,request/* default */.ZP)({ url, responseType: "arraybuffer", sendProgressEvents: true });
    }
    if (segment.indexRange === undefined) {
        return (0,request/* default */.ZP)({ url,
            headers: { Range: (0,byte_range/* default */.Z)(segment.range) },
            responseType: "arraybuffer",
            sendProgressEvents: true });
    }
    // range and indexRange are contiguous (99% of the cases)
    if (segment.range[1] + 1 === segment.indexRange[0]) {
        return (0,request/* default */.ZP)({ url,
            headers: { Range: (0,byte_range/* default */.Z)([segment.range[0],
                    segment.indexRange[1]]) },
            responseType: "arraybuffer",
            sendProgressEvents: true });
    }
    const rangeRequest$ = (0,request/* default */.ZP)({ url,
        headers: { Range: (0,byte_range/* default */.Z)(segment.range) },
        responseType: "arraybuffer",
        sendProgressEvents: false });
    const indexRequest$ = (0,request/* default */.ZP)({ url,
        headers: { Range: (0,byte_range/* default */.Z)(segment.indexRange) },
        responseType: "arraybuffer",
        sendProgressEvents: false });
    return (0,combineLatest/* combineLatest */.aj)([rangeRequest$, indexRequest$])
        .pipe((0,map/* map */.U)(([initData, indexData]) => {
        const data = (0,byte_parsing/* concat */.zo)(new Uint8Array(initData.value.responseData), new Uint8Array(indexData.value.responseData));
        const sendingTime = Math.min(initData.value.sendingTime, indexData.value.sendingTime);
        const receivedTime = Math.max(initData.value.receivedTime, indexData.value.receivedTime);
        return { type: "data-loaded",
            value: { url,
                responseData: data,
                size: initData.value.size + indexData.value.size,
                duration: receivedTime - sendingTime,
                sendingTime,
                receivedTime } };
    }));
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/scan.js
var scan = __webpack_require__(55291);
// EXTERNAL MODULE: ./src/transports/utils/find_complete_box.ts
var find_complete_box = __webpack_require__(61698);
;// CONCATENATED MODULE: ./src/transports/dash/extract_complete_chunks.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Take a chunk of ISOBMFF data and extract complete `moof`+`mdat` subsegments
 * which are ready to be decoded.
 * Returns a tuple of two containing first an array of those subsegments
 * followed by tha last un-decodable part.
 * @param {Uint8Array} buffer
 * @returns {Array}
 */
function extractCompleteChunks(buffer) {
    let _position = 0;
    const chunks = [];
    while (_position < buffer.length) {
        const currentBuffer = buffer.subarray(_position, Infinity);
        const moofIndex = (0,find_complete_box/* default */.Z)(currentBuffer, 0x6D6F6F66 /* moof */);
        if (moofIndex < 0) {
            // no moof, not a segment.
            return [chunks, currentBuffer];
        }
        const moofLen = (0,byte_parsing/* be4toi */.pX)(buffer, moofIndex + _position);
        const moofEnd = _position + moofIndex + moofLen;
        if (moofEnd > buffer.length) {
            // not a complete moof segment
            return [chunks, currentBuffer];
        }
        const mdatIndex = (0,find_complete_box/* default */.Z)(currentBuffer, 0x6D646174 /* mdat */);
        if (mdatIndex < 0) {
            // no mdat, not a segment.
            return [chunks, currentBuffer];
        }
        const mdatLen = (0,byte_parsing/* be4toi */.pX)(buffer, mdatIndex + _position);
        const mdatEnd = _position + mdatIndex + mdatLen;
        if (mdatEnd > buffer.length) {
            // not a complete mdat segment
            return [chunks, currentBuffer];
        }
        const maxEnd = Math.max(moofEnd, mdatEnd);
        const chunk = buffer.subarray(_position, maxEnd);
        chunks.push(chunk);
        _position = maxEnd;
    }
    return [chunks, null];
}

;// CONCATENATED MODULE: ./src/transports/dash/low_latency_segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







function lowLatencySegmentLoader(url, args) {
    const { segment } = args;
    const headers = segment.range !== undefined ? { Range: (0,byte_range/* default */.Z)(segment.range) } :
        undefined;
    return request_fetch({ url, headers })
        .pipe((0,scan/* scan */.R)((acc, evt) => {
        if (evt.type === "data-complete") {
            if (acc.partialChunk !== null) {
                log/* default.warn */.Z.warn("DASH Pipelines: remaining chunk does not belong to any segment");
            }
            return { event: evt, completeChunks: [], partialChunk: null };
        }
        const data = new Uint8Array(evt.value.chunk);
        const concatenated = acc.partialChunk !== null ? (0,byte_parsing/* concat */.zo)(acc.partialChunk, data) :
            data;
        const [completeChunks, partialChunk] = extractCompleteChunks(concatenated);
        return { event: evt, completeChunks, partialChunk };
    }, { event: null, completeChunks: [], partialChunk: null }), (0,mergeMap/* mergeMap */.zg)((evt) => {
        const emitted = [];
        for (let i = 0; i < evt.completeChunks.length; i++) {
            emitted.push({ type: "data-chunk",
                value: { responseData: evt.completeChunks[i] } });
        }
        const { event } = evt;
        if (event !== null && event.type === "data-chunk") {
            const { value } = event;
            emitted.push({ type: "progress",
                value: { duration: value.duration,
                    size: value.size,
                    totalSize: value.totalSize } });
        }
        else if (event !== null && event.type === "data-complete") {
            const { value } = event;
            emitted.push({ type: "data-chunk-complete",
                value: { duration: value.duration,
                    receivedTime: value.receivedTime,
                    sendingTime: value.sendingTime,
                    size: value.size,
                    url: value.url } });
        }
        return (0,of.of)(...emitted);
    }));
}

;// CONCATENATED MODULE: ./src/transports/dash/segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */
function regularSegmentLoader(url, args, lowLatencyMode) {
    if (args.segment.isInit) {
        return initSegmentLoader(url, args);
    }
    const isWEBM = (0,is_webm_embedded_track/* default */.Z)(args.representation);
    if (lowLatencyMode && !isWEBM) {
        if (fetchIsSupported()) {
            return lowLatencySegmentLoader(url, args);
        }
        else {
            (0,warn_once/* default */.Z)("DASH: Your browser does not have the fetch API. You will have " +
                "a higher chance of rebuffering when playing close to the live edge");
        }
    }
    const { segment } = args;
    return (0,request/* default */.ZP)({ url,
        responseType: "arraybuffer",
        sendProgressEvents: true,
        headers: segment.range !== undefined ?
            { Range: (0,byte_range/* default */.Z)(segment.range) } :
            undefined });
}
/**
 * @param {Object} config
 * @returns {Function}
 */
function generateSegmentLoader({ lowLatencyMode, segmentLoader: customSegmentLoader, checkMediaSegmentIntegrity }) {
    return checkMediaSegmentIntegrity !== true ? segmentLoader :
        addSegmentIntegrityChecks(segmentLoader);
    /**
     * @param {Object} content
     * @returns {Observable}
     */
    function segmentLoader(content) {
        const { url } = content;
        if (url == null) {
            return (0,of.of)({ type: "data-created", value: { responseData: null } });
        }
        if (lowLatencyMode || customSegmentLoader === undefined) {
            return regularSegmentLoader(url, content, lowLatencyMode);
        }
        const args = { adaptation: content.adaptation,
            manifest: content.manifest,
            period: content.period,
            representation: content.representation,
            segment: content.segment,
            transport: "dash",
            url };
        return new Observable/* Observable */.y((obs) => {
            let hasFinished = false;
            let hasFallbacked = false;
            /**
             * Callback triggered when the custom segment loader has a response.
             * @param {Object} args
             */
            const resolve = (_args) => {
                if (!hasFallbacked) {
                    hasFinished = true;
                    obs.next({ type: "data-loaded", value: { responseData: _args.data,
                            size: _args.size,
                            duration: _args.duration } });
                    obs.complete();
                }
            };
            /**
             * Callback triggered when the custom segment loader fails
             * @param {*} err - The corresponding error encountered
             */
            const reject = (err = {}) => {
                if (!hasFallbacked) {
                    hasFinished = true;
                    obs.error(err);
                }
            };
            const progress = (_args) => {
                if (!hasFallbacked) {
                    obs.next({ type: "progress", value: { duration: _args.duration,
                            size: _args.size,
                            totalSize: _args.totalSize } });
                }
            };
            /**
             * Callback triggered when the custom segment loader wants to fallback to
             * the "regular" implementation
             */
            const fallback = () => {
                hasFallbacked = true;
                const regular$ = regularSegmentLoader(url, content, lowLatencyMode);
                // HACK What is TypeScript/RxJS doing here??????
                /* eslint-disable import/no-deprecated */
                /* eslint-disable @typescript-eslint/ban-ts-comment */
                // @ts-ignore
                regular$.subscribe(obs);
                /* eslint-enable import/no-deprecated */
                /* eslint-enable @typescript-eslint/ban-ts-comment */
            };
            const callbacks = { reject, resolve, progress, fallback };
            const abort = customSegmentLoader(args, callbacks);
            return () => {
                if (!hasFinished && !hasFallbacked && typeof abort === "function") {
                    abort();
                }
            };
        });
    }
}

// EXTERNAL MODULE: ./src/parsers/containers/isobmff/utils.ts
var utils = __webpack_require__(14959);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/take_pssh_out.ts + 1 modules
var take_pssh_out = __webpack_require__(3544);
// EXTERNAL MODULE: ./src/parsers/containers/matroska/utils.ts
var matroska_utils = __webpack_require__(20077);
// EXTERNAL MODULE: ./src/transports/utils/get_isobmff_timing_infos.ts
var get_isobmff_timing_infos = __webpack_require__(95445);
;// CONCATENATED MODULE: ./src/transports/dash/get_events_out_of_emsgs.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * From an array of EMSGs with manifest validity scheme id,
 * tells if the manifest needs to be refreshed.
 * @param {Array.<Object>} emsgs
 * @param {Object} segment
 * @param {number} manifestPublishTime
 * @returns {boolean}
 */
function manifestNeedsToBeRefreshed(emsgs, manifestPublishTime) {
    if (emsgs.length <= 0) {
        return false;
    }
    const len = emsgs.length;
    for (let i = 0; i < len; i++) {
        const manifestRefreshEventFromEMSGs = emsgs[i];
        const currentManifestPublishTime = manifestPublishTime;
        const { messageData } = manifestRefreshEventFromEMSGs;
        const strPublishTime = (0,string_parsing/* utf8ToStr */.uR)(messageData);
        const eventManifestPublishTime = Date.parse(strPublishTime);
        if (currentManifestPublishTime === undefined ||
            eventManifestPublishTime === undefined ||
            isNaN(eventManifestPublishTime) ||
            // DASH-if 4.3 tells (4.5.2.1) :
            // "The media presentation time beyond the event time (indicated
            // time by presentation_time_delta) is correctly described only
            // by MPDs with publish time greater than indicated value in the
            // message_data field."
            //
            // Here, if the current manifest has its publish time inferior or
            // identical to the event manifest publish time, then the manifest needs
            // to be updated
            eventManifestPublishTime >= currentManifestPublishTime) {
            return true;
        }
    }
    return false;
}
/**
 * Get wrapped inband events and manifest refresh event from
 * parsed ISOBMFF EMSG boxes.
 * @param {Array.<Object>} parsedEMSGs
 * @param {Object} segment
 * @param {undefined | number} manifestPublishTime
 * @returns {Object}
 */
function getEventsOutOfEMSGs(parsedEMSGs, manifestPublishTime) {
    if (parsedEMSGs.length === 0) {
        return undefined;
    }
    const { manifestRefreshEventsFromEMSGs, EMSGs } = parsedEMSGs
        .reduce((acc, val) => {
        // Scheme that signals manifest update
        if (val.schemeIdUri === "urn:mpeg:dash:event:2012" &&
            // TODO support value 2 and 3
            val.value === "1") {
            if (acc.manifestRefreshEventsFromEMSGs === undefined) {
                acc.manifestRefreshEventsFromEMSGs = [];
            }
            acc.manifestRefreshEventsFromEMSGs.push(val);
        }
        else {
            if (acc.EMSGs === undefined) {
                acc.EMSGs = [];
            }
            acc.EMSGs.push(val);
        }
        return acc;
    }, { manifestRefreshEventsFromEMSGs: undefined,
        EMSGs: undefined });
    const inbandEvents = EMSGs === null || EMSGs === void 0 ? void 0 : EMSGs.map((evt) => ({ type: "emsg", value: evt }));
    const needsManifestRefresh = (manifestPublishTime === undefined ||
        manifestRefreshEventsFromEMSGs === undefined) ?
        false :
        manifestNeedsToBeRefreshed(manifestRefreshEventsFromEMSGs, manifestPublishTime);
    return { inbandEvents, needsManifestRefresh };
}

;// CONCATENATED MODULE: ./src/transports/dash/segment_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










/**
 * @param {Object} config
 * @returns {Function}
 */
function generateAudioVideoSegmentParser({ __priv_patchLastSegmentInSidx }) {
    return function audioVideoSegmentParser({ content, response, initTimescale }) {
        const { period, representation, segment, manifest } = content;
        const { data, isChunked } = response;
        const appendWindow = [period.start, period.end];
        if (data === null) {
            if (segment.isInit) {
                return (0,of.of)({ type: "parsed-init-segment", value: { initializationData: null,
                        protectionDataUpdate: false,
                        initTimescale: undefined } });
            }
            return (0,of.of)({ type: "parsed-segment", value: { chunkData: null,
                    chunkInfos: null,
                    chunkOffset: 0,
                    appendWindow } });
        }
        const chunkData = data instanceof Uint8Array ? data :
            new Uint8Array(data);
        const isWEBM = (0,is_webm_embedded_track/* default */.Z)(representation);
        if (!segment.isInit) {
            const chunkInfos = isWEBM ? null : // TODO extract time info from webm
                (0,get_isobmff_timing_infos/* default */.Z)(chunkData, isChunked, segment, initTimescale);
            const chunkOffset = (0,take_first_set/* default */.Z)(segment.timestampOffset, 0);
            if (!isWEBM) {
                const parsedEMSGs = (0,utils/* parseEmsgBoxes */.s9)(chunkData);
                if (parsedEMSGs !== undefined) {
                    const whitelistedEMSGs = parsedEMSGs.filter((evt) => {
                        if (segment.privateInfos === undefined ||
                            segment.privateInfos.isEMSGWhitelisted === undefined) {
                            return false;
                        }
                        return segment.privateInfos.isEMSGWhitelisted(evt);
                    });
                    const events = getEventsOutOfEMSGs(whitelistedEMSGs, manifest.publishTime);
                    if (events !== undefined) {
                        const { needsManifestRefresh, inbandEvents } = events;
                        return (0,of.of)({ type: "parsed-segment",
                            value: { chunkData,
                                chunkInfos,
                                chunkOffset,
                                appendWindow,
                                inbandEvents,
                                needsManifestRefresh } });
                    }
                }
            }
            return (0,of.of)({ type: "parsed-segment",
                value: { chunkData,
                    chunkInfos,
                    chunkOffset,
                    appendWindow } });
        }
        // we're handling an initialization segment
        const { indexRange } = segment;
        let nextSegments;
        if (isWEBM) {
            nextSegments = (0,matroska_utils/* getSegmentsFromCues */.$)(chunkData, 0);
        }
        else {
            nextSegments = (0,utils/* getSegmentsFromSidx */.Wf)(chunkData, Array.isArray(indexRange) ?
                indexRange[0] :
                0);
            // This is a very specific handling for streams we know have a very
            // specific problem at Canal+: The last reference gives a truncated
            // segment.
            // Sadly, people on the packaging side could not fix all legacy contents.
            // This is an easy-but-ugly fix for those.
            // TODO Cleaner way? I tried to always check the obtained segment after
            // a byte-range request but it leads to a lot of code.
            if (__priv_patchLastSegmentInSidx === true &&
                nextSegments !== null &&
                nextSegments.length > 0) {
                const lastSegment = nextSegments[nextSegments.length - 1];
                if (Array.isArray(lastSegment.range)) {
                    lastSegment.range[1] = Infinity;
                }
            }
        }
        if (representation.index instanceof BaseRepresentationIndex &&
            nextSegments !== null &&
            nextSegments.length > 0) {
            representation.index._addSegments(nextSegments);
        }
        const timescale = isWEBM ? (0,matroska_utils/* getTimeCodeScale */.i)(chunkData, 0) :
            (0,utils/* getMDHDTimescale */.LD)(chunkData);
        const parsedTimescale = (0,is_null_or_undefined/* default */.Z)(timescale) ? undefined :
            timescale;
        let protectionDataUpdate = false;
        if (!isWEBM) {
            const psshInfo = (0,take_pssh_out/* default */.Z)(chunkData);
            if (psshInfo.length > 0) {
                protectionDataUpdate = representation._addProtectionData("cenc", psshInfo);
            }
        }
        return (0,of.of)({ type: "parsed-init-segment",
            value: { initializationData: chunkData,
                protectionDataUpdate,
                initTimescale: parsedTimescale } });
    };
}

// EXTERNAL MODULE: ./src/transports/utils/is_mp4_embedded_text_track.ts
var is_mp4_embedded_text_track = __webpack_require__(53965);
;// CONCATENATED MODULE: ./src/transports/dash/text_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Perform requests for "text" segments
 * @param {boolean} lowLatencyMode
 * @returns {Function}
 */
function generateTextTrackLoader({ lowLatencyMode, checkMediaSegmentIntegrity }) {
    return checkMediaSegmentIntegrity !== true ? textTrackLoader :
        addSegmentIntegrityChecks(textTrackLoader);
    /**
     * @param {Object} args
     * @returns {Observable}
     */
    function textTrackLoader(args) {
        const { range } = args.segment;
        const { url } = args;
        if (url === null) {
            return (0,of.of)({ type: "data-created",
                value: { responseData: null } });
        }
        if (args.segment.isInit) {
            return initSegmentLoader(url, args);
        }
        const isMP4Embedded = (0,is_mp4_embedded_text_track/* default */.Z)(args.representation);
        if (lowLatencyMode && isMP4Embedded) {
            if (fetchIsSupported()) {
                return lowLatencySegmentLoader(url, args);
            }
            else {
                (0,warn_once/* default */.Z)("DASH: Your browser does not have the fetch API. You will have " +
                    "a higher chance of rebuffering when playing close to the live edge");
            }
        }
        // ArrayBuffer when in mp4 to parse isobmff manually, text otherwise
        const responseType = isMP4Embedded ? "arraybuffer" :
            "text";
        return (0,request/* default */.ZP)({ url,
            responseType,
            headers: Array.isArray(range) ?
                { Range: (0,byte_range/* default */.Z)(range) } :
                null,
            sendProgressEvents: true });
    }
}

// EXTERNAL MODULE: ./src/transports/utils/parse_text_track.ts
var parse_text_track = __webpack_require__(96190);
;// CONCATENATED MODULE: ./src/transports/dash/text_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Parse TextTrack data when it is embedded in an ISOBMFF file.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */
function parseISOBMFFEmbeddedTextTrack({ response, content, initTimescale }, __priv_patchLastSegmentInSidx) {
    const { period, representation, segment } = content;
    const { isInit, indexRange } = segment;
    const { data, isChunked } = response;
    const chunkBytes = typeof data === "string" ? (0,string_parsing/* strToUtf8 */.tG)(data) :
        data instanceof Uint8Array ? data :
            new Uint8Array(data);
    if (isInit) {
        const sidxSegments = (0,utils/* getSegmentsFromSidx */.Wf)(chunkBytes, Array.isArray(indexRange) ? indexRange[0] :
            0);
        // This is a very specific handling for streams we know have a very
        // specific problem at Canal+: The last reference gives a truncated
        // segment.
        // Sadly, people on the packaging side could not fix all legacy contents.
        // This is an easy-but-ugly fix for those.
        // TODO Cleaner way? I tried to always check the obtained segment after
        // a byte-range request but it leads to a lot of code.
        if (__priv_patchLastSegmentInSidx === true &&
            sidxSegments !== null &&
            sidxSegments.length > 0) {
            const lastSegment = sidxSegments[sidxSegments.length - 1];
            if (Array.isArray(lastSegment.range)) {
                lastSegment.range[1] = Infinity;
            }
        }
        const mdhdTimescale = (0,utils/* getMDHDTimescale */.LD)(chunkBytes);
        if (representation.index instanceof BaseRepresentationIndex &&
            sidxSegments !== null &&
            sidxSegments.length > 0) {
            representation.index._addSegments(sidxSegments);
        }
        return (0,of.of)({ type: "parsed-init-segment",
            value: { initializationData: null,
                protectionDataUpdate: false,
                initTimescale: mdhdTimescale } });
    }
    const chunkInfos = (0,get_isobmff_timing_infos/* default */.Z)(chunkBytes, isChunked, segment, initTimescale);
    const chunkData = (0,parse_text_track/* getISOBMFFEmbeddedTextTrackData */.r8)(content, chunkBytes, chunkInfos, isChunked);
    const chunkOffset = (0,take_first_set/* default */.Z)(segment.timestampOffset, 0);
    return (0,of.of)({ type: "parsed-segment",
        value: { chunkData,
            chunkInfos,
            chunkOffset,
            appendWindow: [period.start, period.end] } });
}
/**
 * Parse TextTrack data in plain text form.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */
function parsePlainTextTrack({ response, content }) {
    const { period, segment } = content;
    const { timestampOffset = 0 } = segment;
    if (segment.isInit) {
        return (0,of.of)({ type: "parsed-init-segment",
            value: { initializationData: null,
                protectionDataUpdate: false,
                initTimescale: undefined } });
    }
    const { data, isChunked } = response;
    let textTrackData;
    if (typeof data !== "string") {
        const bytesData = data instanceof Uint8Array ? data :
            new Uint8Array(data);
        textTrackData = (0,string_parsing/* utf8ToStr */.uR)(bytesData);
    }
    else {
        textTrackData = data;
    }
    const chunkData = (0,parse_text_track/* getPlainTextTrackData */.yu)(content, textTrackData, isChunked);
    return (0,of.of)({ type: "parsed-segment",
        value: { chunkData,
            chunkInfos: null,
            chunkOffset: timestampOffset,
            appendWindow: [period.start, period.end] } });
}
/**
 * @param {Object} config
 * @returns {Function}
 */
function generateTextTrackParser({ __priv_patchLastSegmentInSidx }) {
    /**
     * Parse TextTrack data.
     * @param {Object} infos
     * @returns {Observable.<Object>}
     */
    return function textTrackParser({ response, content, initTimescale }) {
        const { period, representation, segment } = content;
        const { timestampOffset = 0 } = segment;
        const { data, isChunked } = response;
        if (data === null) { // No data, just return empty infos
            if (segment.isInit) {
                return (0,of.of)({ type: "parsed-init-segment",
                    value: { initializationData: null,
                        protectionDataUpdate: false,
                        initTimescale: undefined } });
            }
            return (0,of.of)({ type: "parsed-segment",
                value: { chunkData: null,
                    chunkInfos: null,
                    chunkOffset: timestampOffset,
                    appendWindow: [period.start, period.end] } });
        }
        const isMP4 = (0,is_mp4_embedded_text_track/* default */.Z)(representation);
        if (isMP4) {
            return parseISOBMFFEmbeddedTextTrack({ response: { data, isChunked },
                content,
                initTimescale }, __priv_patchLastSegmentInSidx);
        }
        else {
            return parsePlainTextTrack({ response: { data, isChunked }, content });
        }
    };
}

;// CONCATENATED MODULE: ./src/transports/dash/pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Returns pipelines used for DASH streaming.
 * @param {Object} options
 * implementation. Used for each generated http request.
 * @returns {Object}
 */
/* harmony default export */ function pipelines(options) {
    const manifestLoader = (0,text_manifest_loader/* default */.Z)({
        customManifestLoader: options.manifestLoader,
    });
    const manifestParser = generateManifestParser(options);
    const segmentLoader = generateSegmentLoader(options);
    const audioVideoSegmentParser = generateAudioVideoSegmentParser(options);
    const textTrackLoader = generateTextTrackLoader(options);
    const textTrackParser = generateTextTrackParser(options);
    return { manifest: { loader: manifestLoader,
            parser: manifestParser },
        audio: { loader: segmentLoader,
            parser: audioVideoSegmentParser },
        video: { loader: segmentLoader,
            parser: audioVideoSegmentParser },
        text: { loader: textTrackLoader,
            parser: textTrackParser },
        image: { loader: imageLoader,
            parser: imageParser } };
}

;// CONCATENATED MODULE: ./src/transports/dash/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ const transports_dash = (pipelines);


/***/ }),

/***/ 38571:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ transports_local)
});

// EXTERNAL MODULE: ./src/manifest/index.ts + 5 modules
var src_manifest = __webpack_require__(18567);
// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(14638);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
;// CONCATENATED MODULE: ./src/parsers/manifest/local/representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class LocalRepresentationIndex {
    constructor(index, representationId, isFinished) {
        this._index = index;
        this._representationId = representationId;
        this._isFinished = isFinished;
    }
    /**
     * @returns {Object}
     */
    getInitSegment() {
        return {
            id: `${this._representationId}_init`,
            isInit: true,
            time: 0,
            end: 0,
            duration: 0,
            timescale: 1,
            mediaURLs: null,
            privateInfos: {
                localManifestInitSegment: { load: this._index.loadInitSegment }
            },
        };
    }
    /**
     * @param {Number} up
     * @param {Number} duration
     * @returns {Array.<Object>}
     */
    getSegments(up, duration) {
        const startTime = up;
        const endTime = up + duration;
        const wantedSegments = [];
        for (let i = 0; i < this._index.segments.length; i++) {
            const segment = this._index.segments[i];
            const segmentStart = segment.time;
            if (endTime <= segmentStart) {
                break;
            }
            const segmentEnd = segment.time + segment.duration;
            if (segmentEnd > startTime) {
                wantedSegments.push(segment);
            }
        }
        return wantedSegments
            .map(wantedSegment => {
            return {
                id: `${this._representationId}_${wantedSegment.time}`,
                isInit: false,
                time: wantedSegment.time,
                end: wantedSegment.time + wantedSegment.duration,
                duration: wantedSegment.duration,
                timescale: 1,
                timestampOffset: wantedSegment.timestampOffset,
                mediaURLs: null,
                privateInfos: {
                    localManifestSegment: { load: this._index.loadSegment,
                        segment: wantedSegment },
                },
            };
        });
    }
    /**
     * @returns {Number|undefined}
     */
    getFirstPosition() {
        if (this._index.segments.length === 0) {
            return undefined;
        }
        const firstSegment = this._index.segments[0];
        return firstSegment.time;
    }
    /**
     * @returns {Number|undefined}
     */
    getLastPosition() {
        if (this._index.segments.length === 0) {
            return undefined;
        }
        const lastSegment = this._index.segments[this._index.segments.length - 1];
        return lastSegment.time;
    }
    /**
     * @returns {Boolean}
     */
    shouldRefresh() {
        return false;
    }
    /**
     * @returns {Boolean}
     */
    isSegmentStillAvailable() {
        return true;
    }
    isFinished() {
        return this._isFinished;
    }
    /**
     * @returns {Boolean}
     */
    canBeOutOfSyncError() {
        return false;
    }
    /**
     * @returns {null}
     */
    checkDiscontinuity() {
        return null;
    }
    /**
     * @returns {boolean}
     */
    areSegmentsChronologicallyGenerated() {
        return false;
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
        return true;
    }
    _replace(newIndex) {
        this._isFinished = newIndex._isFinished;
        this._index.segments = newIndex._index.segments;
        this._index.loadSegment = newIndex._index.loadSegment;
        this._index.loadInitSegment = newIndex._index.loadInitSegment;
    }
    _update(newIndex) {
        this._isFinished = newIndex._isFinished;
        const newSegments = newIndex._index.segments;
        if (newSegments.length <= 0) {
            return;
        }
        const insertNewIndexAtPosition = (pos) => {
            this._index.segments.splice(pos, oldIndexLength - pos, ...newSegments);
            this._index.loadSegment = newIndex._index.loadSegment;
            this._index.loadInitSegment = newIndex._index.loadInitSegment;
        };
        const oldIndexLength = this._index.segments.length;
        const newIndexStart = newSegments[0].time;
        for (let i = oldIndexLength - 1; i >= 0; i--) {
            const currSegment = this._index.segments[i];
            if (currSegment.time === newIndexStart) {
                return insertNewIndexAtPosition(i);
            }
            else if (currSegment.time < newIndexStart) {
                if (currSegment.time + currSegment.duration > newIndexStart) {
                    // the new Manifest overlaps a previous segment (weird). Remove the latter.
                    log/* default.warn */.Z.warn("Local RepresentationIndex: Manifest update removed" +
                        " previous segments");
                    return insertNewIndexAtPosition(i);
                }
                return insertNewIndexAtPosition(i + 1);
            }
        }
        // if we got here, it means that every segments in the previous manifest are
        // after the new one. This is unusual.
        // Either the new one has more depth or it's an older one.
        const oldIndexEnd = this._index.segments[oldIndexLength - 1].time +
            this._index.segments[oldIndexLength - 1].duration;
        const newIndexEnd = newSegments[newSegments.length - 1].time +
            newSegments[newSegments.length - 1].duration;
        if (oldIndexEnd >= newIndexEnd) {
            return;
        }
        return this._replace(newIndex);
    }
}

;// CONCATENATED MODULE: ./src/parsers/manifest/local/parse_local_manifest.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Object} localManifest
 * @returns {Object}
 */
function parseLocalManifest(localManifest) {
    if (localManifest.type !== "local") {
        throw new Error("Invalid local manifest given. It misses the `type` property.");
    }
    if (localManifest.version !== "0.2") {
        throw new Error(`The current Local Manifest version (${localManifest.version})` +
            " is not compatible with the current version of the RxPlayer");
    }
    const periodIdGenerator = (0,id_generator/* default */.Z)();
    const { minimumPosition, maximumPosition, isFinished } = localManifest;
    const parsedPeriods = localManifest.periods
        .map(period => parsePeriod(period, { periodIdGenerator,
        isFinished }));
    return { availabilityStartTime: 0,
        expired: localManifest.expired,
        transportType: "local",
        isDynamic: !localManifest.isFinished,
        isLive: false,
        uris: [], timeBounds: { absoluteMinimumTime: minimumPosition !== null && minimumPosition !== void 0 ? minimumPosition : 0, timeshiftDepth: null,
            maximumTimeData: { isLinear: false,
                value: maximumPosition,
                time: performance.now() } }, periods: parsedPeriods };
}
/**
 * @param {Object} period
 * @param {Object} ctxt
 * @returns {Object}
 */
function parsePeriod(period, ctxt) {
    const { isFinished } = ctxt;
    const adaptationIdGenerator = (0,id_generator/* default */.Z)();
    return {
        id: "period-" + ctxt.periodIdGenerator(),
        start: period.start,
        end: period.end,
        duration: period.end - period.start,
        adaptations: period.adaptations
            .reduce((acc, ada) => {
            const type = ada.type;
            let adaps = acc[type];
            if (adaps === undefined) {
                adaps = [];
                acc[type] = adaps;
            }
            adaps.push(parseAdaptation(ada, { adaptationIdGenerator,
                isFinished }));
            return acc;
        }, {}),
    };
}
/**
 * @param {Object} adaptation
 * @param {Object} ctxt
 * @returns {Object}
 */
function parseAdaptation(adaptation, ctxt) {
    const { isFinished } = ctxt;
    const representationIdGenerator = (0,id_generator/* default */.Z)();
    return {
        id: "adaptation-" + ctxt.adaptationIdGenerator(),
        type: adaptation.type,
        audioDescription: adaptation.audioDescription,
        closedCaption: adaptation.closedCaption,
        language: adaptation.language,
        representations: adaptation.representations.map((representation) => parseRepresentation(representation, { representationIdGenerator,
            isFinished })),
    };
}
/**
 * @param {Object} representation
 * @returns {Object}
 */
function parseRepresentation(representation, ctxt) {
    const { isFinished } = ctxt;
    const id = "representation-" + ctxt.representationIdGenerator();
    const contentProtections = representation.contentProtections === undefined ?
        undefined :
        formatContentProtections(representation.contentProtections);
    return { id,
        bitrate: representation.bitrate,
        height: representation.height,
        width: representation.width,
        codecs: representation.codecs,
        mimeType: representation.mimeType,
        index: new LocalRepresentationIndex(representation.index, id, isFinished),
        contentProtections };
}
/**
 * Translate Local Manifest's `contentProtections` attribute to the one defined
 * for a `Manifest` structure.
 * @param {Object} localContentProtections
 * @returns {Object}
 */
function formatContentProtections(localContentProtections) {
    const keyIds = localContentProtections.keyIds;
    const initData = Object.keys(localContentProtections.initData).map((currType) => {
        var _a;
        const localInitData = (_a = localContentProtections.initData[currType]) !== null && _a !== void 0 ? _a : [];
        return { type: currType,
            values: localInitData };
    });
    return { keyIds, initData };
}

;// CONCATENATED MODULE: ./src/parsers/manifest/local/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const local = (parseLocalManifest);

// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(32825);
// EXTERNAL MODULE: ./src/transports/utils/call_custom_manifest_loader.ts
var call_custom_manifest_loader = __webpack_require__(218);
// EXTERNAL MODULE: ./src/transports/utils/return_parsed_manifest.ts
var return_parsed_manifest = __webpack_require__(97275);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(30365);
;// CONCATENATED MODULE: ./src/transports/local/segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Function} customSegmentLoader
 * @returns {Observable}
 */
function loadInitSegment(customSegmentLoader) {
    return new Observable/* Observable */.y((obs) => {
        let hasFinished = false;
        /**
         * Callback triggered when the custom segment loader has a response.
         * @param {Object} args
         */
        const resolve = (_args) => {
            hasFinished = true;
            obs.next({ type: "data-loaded",
                value: { responseData: _args.data,
                    size: _args.size,
                    duration: _args.duration } });
            obs.complete();
        };
        /**
         * Callback triggered when the custom segment loader fails
         * @param {*} err - The corresponding error encountered
         */
        const reject = (err) => {
            hasFinished = true;
            obs.error(err);
        };
        const abort = customSegmentLoader({ resolve, reject });
        return () => {
            if (!hasFinished && typeof abort === "function") {
                abort();
            }
        };
    });
}
/**
 * @param {Object} segment
 * @param {Function} customSegmentLoader
 * @returns {Observable}
 */
function loadSegment(segment, customSegmentLoader) {
    return new Observable/* Observable */.y((obs) => {
        let hasFinished = false;
        /**
         * Callback triggered when the custom segment loader has a response.
         * @param {Object} args
         */
        const resolve = (_args) => {
            hasFinished = true;
            obs.next({ type: "data-loaded",
                value: { responseData: _args.data,
                    size: _args.size,
                    duration: _args.duration } });
            obs.complete();
        };
        /**
         * Callback triggered when the custom segment loader fails
         * @param {*} err - The corresponding error encountered
         */
        const reject = (err) => {
            hasFinished = true;
            obs.error(err);
        };
        const abort = customSegmentLoader(segment, { resolve, reject });
        return () => {
            if (!hasFinished && typeof abort === "function") {
                abort();
            }
        };
    });
}
/**
 * Generic segment loader for the local Manifest.
 * @param {Object} arg
 * @returns {Observable}
 */
function segmentLoader({ segment }) {
    const privateInfos = segment.privateInfos;
    if (segment.isInit) {
        if (privateInfos === undefined ||
            (0,is_null_or_undefined/* default */.Z)(privateInfos.localManifestInitSegment)) {
            throw new Error("Segment is not a local Manifest segment");
        }
        return loadInitSegment(privateInfos.localManifestInitSegment.load);
    }
    if (privateInfos === undefined ||
        (0,is_null_or_undefined/* default */.Z)(privateInfos.localManifestSegment)) {
        throw new Error("Segment is not an local Manifest segment");
    }
    return loadSegment(privateInfos.localManifestSegment.segment, privateInfos.localManifestSegment.load);
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/utils.ts
var utils = __webpack_require__(14959);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/take_pssh_out.ts + 1 modules
var take_pssh_out = __webpack_require__(3544);
// EXTERNAL MODULE: ./src/parsers/containers/matroska/utils.ts
var matroska_utils = __webpack_require__(20077);
// EXTERNAL MODULE: ./src/utils/take_first_set.ts
var take_first_set = __webpack_require__(66365);
// EXTERNAL MODULE: ./src/transports/utils/get_isobmff_timing_infos.ts
var get_isobmff_timing_infos = __webpack_require__(95445);
// EXTERNAL MODULE: ./src/transports/utils/is_webm_embedded_track.ts
var is_webm_embedded_track = __webpack_require__(55057);
;// CONCATENATED MODULE: ./src/transports/local/segment_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







function segmentParser({ content, response, initTimescale, }) {
    const { period, segment, representation } = content;
    const { data } = response;
    const appendWindow = [period.start, period.end];
    if (data === null) {
        if (segment.isInit) {
            return (0,of.of)({ type: "parsed-init-segment",
                value: { initializationData: null,
                    protectionDataUpdate: false,
                    initTimescale: undefined } });
        }
        return (0,of.of)({ type: "parsed-segment",
            value: { chunkData: null,
                chunkInfos: null,
                chunkOffset: 0,
                appendWindow } });
    }
    const chunkData = new Uint8Array(data);
    const isWEBM = (0,is_webm_embedded_track/* default */.Z)(representation);
    if (segment.isInit) {
        let protectionDataUpdate = false;
        let timescale;
        if (isWEBM) {
            timescale = (0,matroska_utils/* getTimeCodeScale */.i)(chunkData, 0);
        }
        else {
            // assume ISOBMFF-compliance
            timescale = (0,utils/* getMDHDTimescale */.LD)(chunkData);
            const psshInfo = (0,take_pssh_out/* default */.Z)(chunkData);
            if (psshInfo.length > 0) {
                protectionDataUpdate = representation._addProtectionData("cenc", psshInfo);
            }
        }
        return (0,of.of)({ type: "parsed-init-segment",
            value: { initializationData: chunkData,
                initTimescale: (0,is_null_or_undefined/* default */.Z)(timescale) ?
                    undefined :
                    timescale,
                protectionDataUpdate } });
    }
    const chunkInfos = isWEBM ? null : // TODO extract from webm
        (0,get_isobmff_timing_infos/* default */.Z)(chunkData, false, segment, initTimescale);
    const chunkOffset = (0,take_first_set/* default */.Z)(segment.timestampOffset, 0);
    return (0,of.of)({ type: "parsed-segment",
        value: { chunkData,
            chunkInfos,
            chunkOffset,
            appendWindow } });
}

// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(26332);
// EXTERNAL MODULE: ./src/transports/utils/is_mp4_embedded_text_track.ts
var is_mp4_embedded_text_track = __webpack_require__(53965);
// EXTERNAL MODULE: ./src/transports/utils/parse_text_track.ts
var parse_text_track = __webpack_require__(96190);
;// CONCATENATED MODULE: ./src/transports/local/text_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







/**
 * Parse TextTrack data when it is embedded in an ISOBMFF file.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */
function parseISOBMFFEmbeddedTextTrack({ response, content, initTimescale }) {
    const { period, segment } = content;
    const { data, isChunked } = response;
    const chunkBytes = typeof data === "string" ? (0,string_parsing/* strToUtf8 */.tG)(data) :
        data instanceof Uint8Array ? data :
            new Uint8Array(data);
    if (segment.isInit) {
        const mdhdTimescale = (0,utils/* getMDHDTimescale */.LD)(chunkBytes);
        return (0,of.of)({ type: "parsed-init-segment",
            value: { initializationData: null,
                initTimescale: mdhdTimescale,
                protectionDataUpdate: false } });
    }
    const chunkInfos = (0,get_isobmff_timing_infos/* default */.Z)(chunkBytes, isChunked, segment, initTimescale);
    const chunkData = (0,parse_text_track/* getISOBMFFEmbeddedTextTrackData */.r8)(content, chunkBytes, chunkInfos, isChunked);
    const chunkOffset = (0,take_first_set/* default */.Z)(segment.timestampOffset, 0);
    return (0,of.of)({ type: "parsed-segment",
        value: { chunkData,
            chunkInfos,
            chunkOffset,
            appendWindow: [period.start, period.end] } });
}
/**
 * Parse TextTrack data in plain text form.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */
function parsePlainTextTrack({ response, content }) {
    const { period, segment } = content;
    if (segment.isInit) {
        return (0,of.of)({ type: "parsed-init-segment",
            value: { initializationData: null,
                initTimescale: undefined,
                protectionDataUpdate: false } });
    }
    const { data, isChunked } = response;
    let textTrackData;
    if (typeof data !== "string") {
        const bytesData = data instanceof Uint8Array ? data :
            new Uint8Array(data);
        textTrackData = (0,string_parsing/* utf8ToStr */.uR)(bytesData);
    }
    else {
        textTrackData = data;
    }
    const chunkData = (0,parse_text_track/* getPlainTextTrackData */.yu)(content, textTrackData, isChunked);
    const chunkOffset = (0,take_first_set/* default */.Z)(segment.timestampOffset, 0);
    return (0,of.of)({ type: "parsed-segment",
        value: { chunkData,
            chunkInfos: null,
            chunkOffset,
            appendWindow: [period.start, period.end] } });
}
/**
 * Parse TextTrack data.
 * @param {Object} infos
 * @returns {Observable.<Object>}
 */
function textTrackParser({ response, content, initTimescale }) {
    const { period, representation, segment } = content;
    const { data, isChunked } = response;
    if (data === null) { // No data, just return empty infos
        if (segment.isInit) {
            return (0,of.of)({ type: "parsed-init-segment",
                value: { initializationData: null,
                    protectionDataUpdate: false,
                    initTimescale: undefined } });
        }
        const chunkOffset = (0,take_first_set/* default */.Z)(segment.timestampOffset, 0);
        return (0,of.of)({ type: "parsed-segment",
            value: { chunkData: null,
                chunkInfos: null,
                chunkOffset,
                appendWindow: [period.start, period.end] } });
    }
    const isMP4 = (0,is_mp4_embedded_text_track/* default */.Z)(representation);
    if (isMP4) {
        return parseISOBMFFEmbeddedTextTrack({ response: { data, isChunked },
            content,
            initTimescale });
    }
    else {
        return parsePlainTextTrack({ response: { data, isChunked }, content });
    }
}

;// CONCATENATED MODULE: ./src/transports/local/pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Returns pipelines used for local Manifest streaming.
 * @param {Object} options
 * @returns {Object}
 */
function getLocalManifestPipelines(options) {
    const customManifestLoader = options.manifestLoader;
    const manifestPipeline = {
        loader(args) {
            if ((0,is_null_or_undefined/* default */.Z)(customManifestLoader)) {
                throw new Error("A local Manifest is not loadable through regular HTTP(S) " +
                    " calls. You have to set a `manifestLoader` when calling " +
                    "`loadVideo`");
            }
            return (0,call_custom_manifest_loader/* default */.Z)(customManifestLoader, () => {
                throw new Error("Cannot fallback from the `manifestLoader` of a " +
                    "`local` transport");
            })(args);
        },
        parser({ response }) {
            const manifestData = response.responseData;
            if (typeof manifestData !== "object") {
                throw new Error("Wrong format for the manifest data");
            }
            const parsed = local(response.responseData);
            const manifest = new src_manifest/* default */.ZP(parsed, options);
            return (0,return_parsed_manifest/* default */.Z)(manifest);
        },
    };
    const segmentPipeline = { loader: segmentLoader,
        parser: segmentParser };
    const textTrackPipeline = { loader: segmentLoader,
        parser: textTrackParser };
    const imageTrackPipeline = {
        loader: () => {
            throw new Error("Images track not supported in local transport.");
        },
        parser: () => {
            throw new Error("Images track not supported in local transport.");
        },
    };
    return { manifest: manifestPipeline,
        audio: segmentPipeline,
        video: segmentPipeline,
        text: textTrackPipeline,
        image: imageTrackPipeline };
}

;// CONCATENATED MODULE: ./src/transports/local/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const transports_local = (getLocalManifestPipelines);


/***/ }),

/***/ 39901:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ transports_metaplaylist)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(10125);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(92953);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(96705);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(65208);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(75688);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/share.js
var share = __webpack_require__(32139);
// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(41195);
// EXTERNAL MODULE: ./src/manifest/index.ts + 5 modules
var src_manifest = __webpack_require__(18567);
// EXTERNAL MODULE: ./src/manifest/adaptation.ts + 3 modules
var adaptation = __webpack_require__(40042);
// EXTERNAL MODULE: ./src/manifest/representation_index/static.ts
var representation_index_static = __webpack_require__(19327);
// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(14638);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(53811);
;// CONCATENATED MODULE: ./src/parsers/manifest/metaplaylist/representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * The MetaRepresentationIndex is wrapper for all kind of RepresentationIndex (from
 * dash, smooth, etc)
 *
 * It wraps methods from original RepresentationIndex, while taking into account
 * the time offset introduced by the MetaPlaylist content.
 *
 * It makes a bridge between the MetaPlaylist timeline, and the original
 * timeline of content. (e.g. the segment whose "meta" time is 1500, is actually a
 * segment whose original time is 200, played with an offset of 1300)
 * @class MetaRepresentationIndex
 */
class MetaRepresentationIndex {
    /**
     * Create a new `MetaRepresentationIndex`.
     * @param {Object} wrappedIndex - "Real" RepresentationIndex implementation of
     * the concerned Representation.
     * @param {Array.<number|undefined>} contentBounds - Start time and end time
     * the Representation will be played between, in seconds.
     * @param {string} transport - Transport for the "real" RepresentationIndex
     * (e.g. "dash" or "smooth").
     * @param {Object} baseContentInfos - Various information about the "real"
     * Representation.
     */
    constructor(wrappedIndex, contentBounds, transport, baseContentInfos) {
        this._wrappedIndex = wrappedIndex;
        this._timeOffset = contentBounds[0];
        this._contentEnd = contentBounds[1];
        this._transport = transport;
        this._baseContentInfos = baseContentInfos;
    }
    /**
     * Returns information about the initialization segment.
     */
    getInitSegment() {
        const segment = this._wrappedIndex.getInitSegment();
        if (segment === null) {
            return null;
        }
        return this._cloneWithPrivateInfos(segment);
    }
    /**
     * Returns information about the segments asked.
     * @param {number} up - Starting time wanted, in seconds.
     * @param {Number} duration - Amount of time wanted, in seconds
     * @returns {Array.<Object>}
     */
    getSegments(up, duration) {
        return this._wrappedIndex.getSegments(up - this._timeOffset, duration)
            .map((segment) => {
            const clonedSegment = this._cloneWithPrivateInfos(segment);
            clonedSegment.time += this._timeOffset;
            clonedSegment.end += this._timeOffset;
            return clonedSegment;
        });
    }
    /**
     * Whether this RepresentationIndex should be refreshed now.
     * Returns `false` as MetaPlaylist contents do not support underlying live
     * contents yet.
     * @returns {Boolean}
     */
    shouldRefresh() {
        return false;
    }
    /**
     * Returns first possible position the first segment plays at, in seconds.
     * `undefined` if we do not know this value.
     * @return {Number|undefined}
     */
    getFirstPosition() {
        const wrappedFirstPosition = this._wrappedIndex.getFirstPosition();
        return wrappedFirstPosition != null ? wrappedFirstPosition + this._timeOffset :
            undefined;
    }
    /**
     * Returns last possible position the last segment plays at, in seconds.
     * `undefined` if we do not know this value.
     * @return {Number|undefined}
     */
    getLastPosition() {
        const wrappedLastPosition = this._wrappedIndex.getLastPosition();
        return wrappedLastPosition != null ? wrappedLastPosition + this._timeOffset :
            undefined;
    }
    /**
     * Returns `false` if that segment is not currently available in the Manifest
     * (e.g. it corresponds to a segment which is before the current buffer
     * depth).
     * @param {Object} segment
     * @returns {boolean|undefined}
     */
    isSegmentStillAvailable(segment) {
        var _a;
        if (((_a = segment.privateInfos) === null || _a === void 0 ? void 0 : _a.metaplaylistInfos) === undefined) {
            return false;
        }
        const { originalSegment } = segment.privateInfos.metaplaylistInfos;
        return this._wrappedIndex.isSegmentStillAvailable(originalSegment);
    }
    /**
     * @param {Error} error
     * @param {Object} segment
     * @returns {Boolean}
     */
    canBeOutOfSyncError(error, segment) {
        var _a;
        if (((_a = segment.privateInfos) === null || _a === void 0 ? void 0 : _a.metaplaylistInfos) === undefined) {
            return false;
        }
        const { originalSegment } = segment.privateInfos.metaplaylistInfos;
        return this._wrappedIndex.canBeOutOfSyncError(error, originalSegment);
    }
    /**
     *
     * @param {Number} time
     * @returns {Number | null}
     */
    checkDiscontinuity(time) {
        return this._wrappedIndex.checkDiscontinuity(time - this._timeOffset);
    }
    /**
     * @returns {Boolean}
     */
    areSegmentsChronologicallyGenerated() {
        return this._wrappedIndex.areSegmentsChronologicallyGenerated();
    }
    /**
     * @returns {Boolean}
     */
    isFinished() {
        return this._wrappedIndex.isFinished();
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
        return this._wrappedIndex.isInitialized();
    }
    /**
     * @param {Object} newIndex
     */
    _replace(newIndex) {
        if (!(newIndex instanceof MetaRepresentationIndex)) {
            throw new Error("A MetaPlaylist can only be replaced with another MetaPlaylist");
        }
        this._wrappedIndex._replace(newIndex._wrappedIndex);
    }
    /**
     * @param {Object} newIndex
     */
    _update(newIndex) {
        if (!(newIndex instanceof MetaRepresentationIndex)) {
            throw new Error("A MetaPlaylist can only be updated with another MetaPlaylist");
        }
        this._wrappedIndex._update(newIndex._wrappedIndex);
    }
    /**
     * Clone the given segment, presumably coming from its original
     * RepresentationIndex, and add the linked metaplaylist privateInfos to it.
     * Return that cloned and enhanced segment.
     * @param {Object} segment
     * @returns {Object}
     */
    _cloneWithPrivateInfos(segment) {
        const clonedSegment = (0,object_assign/* default */.Z)({}, segment);
        if (clonedSegment.privateInfos === undefined) {
            clonedSegment.privateInfos = {};
        }
        clonedSegment.privateInfos.metaplaylistInfos = {
            transportType: this._transport,
            baseContent: this._baseContentInfos,
            contentStart: this._timeOffset,
            contentEnd: this._contentEnd,
            originalSegment: segment,
        };
        return clonedSegment;
    }
}

;// CONCATENATED MODULE: ./src/parsers/manifest/metaplaylist/metaplaylist_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse playlist string to JSON.
 * Returns an array of contents.
 * @param {string} data
 * @param {string} url
 * @returns {Object}
 */
function parseMetaPlaylist(data, parserOptions) {
    let parsedData;
    if (typeof data === "object" && data != null) {
        parsedData = data;
    }
    else if (typeof data === "string") {
        try {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            parsedData = JSON.parse(data);
        }
        catch (error) {
            throw new Error("MPL Parser: Bad MetaPlaylist file. Expected JSON.");
        }
    }
    else {
        throw new Error("MPL Parser: Parser input must be either a string " +
            "or the MetaPlaylist data directly.");
    }
    const { contents, version, type } = parsedData;
    if (type !== "MPL") {
        throw new Error("MPL Parser: Bad MetaPlaylist. " +
            "The `type` property is not set to `MPL`");
    }
    if (version !== "0.1") {
        throw new Error("MPL Parser: Bad MetaPlaylist version");
    }
    // quick checks
    if (contents == null || contents.length === 0) {
        throw new Error("MPL Parser: No content found.");
    }
    const ressources = [];
    for (let i = 0; i < contents.length; i++) {
        const content = contents[i];
        if (content.url == null ||
            content.startTime == null ||
            content.endTime == null ||
            content.transport == null) {
            throw new Error("MPL Parser: Malformed content.");
        }
        ressources.push({ url: content.url, transportType: content.transport });
    }
    const metaPlaylist = parsedData;
    return {
        type: "needs-manifest-loader",
        value: {
            ressources,
            continue: function parseWholeMPL(loadedRessources) {
                const parsedManifest = createManifest(metaPlaylist, loadedRessources, parserOptions);
                return { type: "done", value: parsedManifest };
            },
        },
    };
}
/**
 * From several parsed manifests, generate a single bigger manifest.
 * Each content presents a start and end time, so that periods
 * boudaries could be adapted.
 * @param {Object} mplData
 * @param {Array<Object>} manifest
 * @param {string} url
 * @returns {Object}
 */
function createManifest(mplData, manifests, parserOptions) {
    const { url, serverSyncInfos } = parserOptions;
    const clockOffset = serverSyncInfos !== undefined ?
        serverSyncInfos.serverTimestamp - serverSyncInfos.clientTime :
        undefined;
    const generateAdaptationID = (0,id_generator/* default */.Z)();
    const generateRepresentationID = (0,id_generator/* default */.Z)();
    const { contents } = mplData;
    const minimumTime = contents.length > 0 ? contents[0].startTime :
        0;
    const maximumTime = contents.length > 0 ? contents[contents.length - 1].endTime :
        0;
    const isDynamic = mplData.dynamic === true;
    let firstStart = null;
    let lastEnd = null;
    const periods = [];
    for (let iMan = 0; iMan < contents.length; iMan++) {
        const content = contents[iMan];
        firstStart = firstStart !== null ? Math.min(firstStart, content.startTime) :
            content.startTime;
        lastEnd = lastEnd !== null ? Math.max(lastEnd, content.endTime) :
            content.endTime;
        const currentManifest = manifests[iMan];
        if (currentManifest.periods.length <= 0) {
            continue;
        }
        const contentOffset = content.startTime - currentManifest.periods[0].start;
        const contentEnd = content.endTime;
        const manifestPeriods = [];
        for (let iPer = 0; iPer < currentManifest.periods.length; iPer++) {
            const currentPeriod = currentManifest.periods[iPer];
            const adaptations = adaptation/* SUPPORTED_ADAPTATIONS_TYPE.reduce */.r.reduce((acc, type) => {
                const currentAdaptations = currentPeriod.adaptations[type];
                if (currentAdaptations == null) {
                    return acc;
                }
                const adaptationsForCurrentType = [];
                for (let iAda = 0; iAda < currentAdaptations.length; iAda++) {
                    const currentAdaptation = currentAdaptations[iAda];
                    const representations = [];
                    for (let iRep = 0; iRep < currentAdaptation.representations.length; iRep++) {
                        const currentRepresentation = currentAdaptation.representations[iRep];
                        const contentInfos = {
                            manifest: currentManifest,
                            period: currentPeriod,
                            adaptation: currentAdaptation,
                            representation: currentRepresentation,
                        };
                        const newIndex = new MetaRepresentationIndex(currentRepresentation.index, [contentOffset, contentEnd], content.transport, contentInfos);
                        representations.push({
                            bitrate: currentRepresentation.bitrate,
                            index: newIndex,
                            id: currentRepresentation.id,
                            height: currentRepresentation.height,
                            width: currentRepresentation.width,
                            mimeType: currentRepresentation.mimeType,
                            frameRate: currentRepresentation.frameRate,
                            codecs: currentRepresentation.codec,
                            contentProtections: currentRepresentation.contentProtections,
                        });
                    }
                    adaptationsForCurrentType.push({
                        id: currentAdaptation.id,
                        representations,
                        type: currentAdaptation.type,
                        audioDescription: currentAdaptation.isAudioDescription,
                        closedCaption: currentAdaptation.isClosedCaption,
                        isDub: currentAdaptation.isDub,
                        language: currentAdaptation.language,
                        isSignInterpreted: currentAdaptation.isSignInterpreted,
                    });
                    acc[type] = adaptationsForCurrentType;
                }
                return acc;
            }, {});
            // TODO only first period?
            const textTracks = content.textTracks === undefined ? [] :
                content.textTracks;
            const newTextAdaptations = textTracks.map((track) => {
                const adaptationID = "gen-text-ada-" + generateAdaptationID();
                const representationID = "gen-text-rep-" + generateRepresentationID();
                return {
                    id: adaptationID,
                    type: "text",
                    language: track.language,
                    closedCaption: track.closedCaption,
                    manuallyAdded: true,
                    representations: [
                        { bitrate: 0,
                            id: representationID,
                            mimeType: track.mimeType,
                            codecs: track.codecs,
                            index: new representation_index_static/* default */.Z({ media: track.url }),
                        },
                    ],
                };
            }, []);
            if (newTextAdaptations.length > 0) {
                if (adaptations.text == null) {
                    adaptations.text = newTextAdaptations;
                }
                else {
                    adaptations.text.push(...newTextAdaptations);
                }
            }
            const newPeriod = {
                id: formatId(currentManifest.id) + "_" + formatId(currentPeriod.id),
                adaptations,
                duration: currentPeriod.duration,
                start: contentOffset + currentPeriod.start,
            };
            manifestPeriods.push(newPeriod);
        }
        for (let i = manifestPeriods.length - 1; i >= 0; i--) {
            const period = manifestPeriods[i];
            if (period.start >= content.endTime) {
                manifestPeriods.splice(i, 1);
            }
            else if (period.duration != null) {
                if (period.start + period.duration > content.endTime) {
                    period.duration = content.endTime - period.start;
                }
            }
            else if (i === manifestPeriods.length - 1) {
                period.duration = content.endTime - period.start;
            }
        }
        periods.push(...manifestPeriods);
    }
    const time = performance.now();
    const manifest = { availabilityStartTime: 0,
        clockOffset,
        suggestedPresentationDelay: 10,
        periods,
        transportType: "metaplaylist",
        isLive: isDynamic,
        isDynamic,
        uris: url == null ? [] :
            [url],
        timeBounds: { minimumTime,
            timeshiftDepth: null,
            maximumTimeData: { isLinear: false,
                value: maximumTime,
                time } },
        lifetime: mplData.pollInterval };
    return manifest;
}
function formatId(str) {
    return str.replace(/_/g, "\_");
}

;// CONCATENATED MODULE: ./src/parsers/manifest/metaplaylist/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const metaplaylist = (parseMetaPlaylist);

// EXTERNAL MODULE: ./src/utils/defer_subscriptions.ts + 6 modules
var defer_subscriptions = __webpack_require__(45150);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(32825);
// EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
var request = __webpack_require__(99703);
// EXTERNAL MODULE: ./src/transports/utils/call_custom_manifest_loader.ts
var call_custom_manifest_loader = __webpack_require__(218);
;// CONCATENATED MODULE: ./src/transports/metaplaylist/manifest_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 */
function regularManifestLoader({ url }) {
    if (url === undefined) {
        throw new Error("Cannot perform HTTP(s) request. URL not known");
    }
    return (0,request/* default */.ZP)({ url, responseType: "text" });
}
/**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */
function generateManifestLoader(options) {
    const { customManifestLoader } = options;
    if (typeof customManifestLoader !== "function") {
        return regularManifestLoader;
    }
    return (0,call_custom_manifest_loader/* default */.Z)(customManifestLoader, regularManifestLoader);
}

;// CONCATENATED MODULE: ./src/transports/metaplaylist/pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









/**
 * Get base - real - content from an offseted metaplaylist content.
 * @param {Object} segment
 * @param {number} offset
 * @returns {Object}
 */
function getOriginalContent(segment) {
    var _a;
    if (((_a = segment.privateInfos) === null || _a === void 0 ? void 0 : _a.metaplaylistInfos) === undefined) {
        throw new Error("MetaPlaylist: missing private infos");
    }
    const { manifest, period, adaptation, representation } = segment.privateInfos.metaplaylistInfos.baseContent;
    const { originalSegment } = segment.privateInfos.metaplaylistInfos;
    return { manifest,
        period,
        adaptation,
        representation,
        segment: originalSegment };
}
/**
 * Prepare any wrapped segment loader's arguments.
 * @param {Object} segment
 * @param {number} offset
 * @returns {Object}
 */
function getLoaderArguments(segment, url) {
    const content = getOriginalContent(segment);
    return (0,object_assign/* default */.Z)({ url }, content);
}
/**
 * Prepare any wrapped segment parser's arguments.
 * @param {Object} arguments
 * @param {Object} segment
 * @param {number} offset
 * @returns {Object}
 */
function getParserArguments({ initTimescale, response }, segment) {
    return { initTimescale,
        response,
        content: getOriginalContent(segment) };
}
/**
 * @param {Object} transports
 * @param {string} transportName
 * @param {Object} options
 * @returns {Object}
 */
function getTransportPipelines(transports, transportName, options) {
    const initialTransport = transports[transportName];
    if (initialTransport !== undefined) {
        return initialTransport;
    }
    const feature = features/* default.transports */.Z.transports[transportName];
    if (feature === undefined) {
        throw new Error(`MetaPlaylist: Unknown transport ${transportName}.`);
    }
    const transport = feature(options);
    transports[transportName] = transport;
    return transport;
}
/**
 * @param {Object} segment
 * @returns {Object}
 */
function getMetaPlaylistPrivateInfos(segment) {
    const { privateInfos } = segment;
    if ((privateInfos === null || privateInfos === void 0 ? void 0 : privateInfos.metaplaylistInfos) === undefined) {
        throw new Error("MetaPlaylist: Undefined transport for content for metaplaylist.");
    }
    return privateInfos.metaplaylistInfos;
}
/* harmony default export */ function pipelines(options) {
    const transports = {};
    const manifestLoader = generateManifestLoader({
        customManifestLoader: options.manifestLoader,
    });
    // remove some options that we might not want to apply to the
    // other streaming protocols used here
    const otherTransportOptions = (0,object_assign/* default */.Z)({}, options, { manifestLoader: undefined,
        supplementaryTextTracks: [],
        supplementaryImageTracks: [] });
    const manifestPipeline = {
        loader: manifestLoader,
        parser({ response, url: loaderURL, previousManifest, scheduleRequest, unsafeMode, externalClockOffset }) {
            const url = response.url === undefined ? loaderURL :
                response.url;
            const { responseData } = response;
            const parserOptions = { url,
                serverSyncInfos: options.serverSyncInfos };
            return handleParsedResult(metaplaylist(responseData, parserOptions));
            function handleParsedResult(parsedResult) {
                if (parsedResult.type === "done") {
                    const manifest = new src_manifest/* default */.ZP(parsedResult.value, options);
                    return (0,of.of)({ type: "parsed",
                        value: { manifest } });
                }
                const loaders$ = parsedResult.value.ressources.map((ressource) => {
                    const transport = getTransportPipelines(transports, ressource.transportType, otherTransportOptions);
                    const request$ = scheduleRequest(() => transport.manifest.loader({ url: ressource.url }).pipe((0,filter/* filter */.h)((e) => e.type === "data-loaded"), (0,map/* map */.U)((e) => e.value)));
                    return request$.pipe((0,mergeMap/* mergeMap */.zg)((responseValue) => {
                        return transport.manifest.parser({ response: responseValue,
                            url: ressource.url,
                            scheduleRequest,
                            previousManifest,
                            unsafeMode,
                            externalClockOffset });
                    })).pipe((0,defer_subscriptions/* default */.Z)(), (0,share/* share */.B)());
                });
                const warnings$ = loaders$.map(loader => loader.pipe((0,filter/* filter */.h)((evt) => evt.type === "warning")));
                const responses$ = loaders$.map(loader => loader.pipe((0,filter/* filter */.h)((evt) => evt.type === "parsed")));
                return (0,merge/* merge */.T)((0,combineLatest/* combineLatest */.aj)(responses$).pipe((0,mergeMap/* mergeMap */.zg)((evt) => {
                    const loadedRessources = evt.map(e => e.value.manifest);
                    return handleParsedResult(parsedResult.value.continue(loadedRessources));
                })), ...warnings$);
            }
        },
    };
    /**
     * @param {Object} segment
     * @param {Object} transports
     * @returns {Object}
     */
    function getTransportPipelinesFromSegment(segment) {
        const { transportType } = getMetaPlaylistPrivateInfos(segment);
        return getTransportPipelines(transports, transportType, otherTransportOptions);
    }
    /**
     * @param {number} contentOffset
     * @param {number} scaledContentOffset
     * @param {number|undefined} contentEnd
     * @param {Object} segmentResponse
     * @returns {Object}
     */
    function offsetTimeInfos(contentOffset, contentEnd, segmentResponse) {
        const offsetedSegmentOffset = segmentResponse.chunkOffset + contentOffset;
        if ((0,is_null_or_undefined/* default */.Z)(segmentResponse.chunkData)) {
            return { chunkInfos: segmentResponse.chunkInfos,
                chunkOffset: offsetedSegmentOffset,
                appendWindow: [undefined, undefined] };
        }
        // clone chunkInfos
        const { chunkInfos, appendWindow } = segmentResponse;
        const offsetedChunkInfos = chunkInfos === null ? null :
            (0,object_assign/* default */.Z)({}, chunkInfos);
        if (offsetedChunkInfos !== null) {
            offsetedChunkInfos.time += contentOffset;
        }
        const offsetedWindowStart = appendWindow[0] !== undefined ?
            Math.max(appendWindow[0] + contentOffset, contentOffset) :
            contentOffset;
        let offsetedWindowEnd;
        if (appendWindow[1] !== undefined) {
            offsetedWindowEnd = contentEnd !== undefined ?
                Math.min(appendWindow[1] + contentOffset, contentEnd) :
                appendWindow[1] + contentOffset;
        }
        else if (contentEnd !== undefined) {
            offsetedWindowEnd = contentEnd;
        }
        return { chunkInfos: offsetedChunkInfos,
            chunkOffset: offsetedSegmentOffset,
            appendWindow: [offsetedWindowStart, offsetedWindowEnd] };
    }
    const audioPipeline = {
        loader({ segment, url }) {
            const { audio } = getTransportPipelinesFromSegment(segment);
            return audio.loader(getLoaderArguments(segment, url));
        },
        parser(args) {
            const { content } = args;
            const { segment } = content;
            const { contentStart, contentEnd } = getMetaPlaylistPrivateInfos(segment);
            const { audio } = getTransportPipelinesFromSegment(segment);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return audio.parser(getParserArguments(args, segment))
                .pipe((0,map/* map */.U)(res => {
                if (res.type === "parsed-init-segment") {
                    return res;
                }
                const timeInfos = offsetTimeInfos(contentStart, contentEnd, res.value);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return (0,object_assign/* default */.Z)({ type: "parsed-segment",
                    value: (0,object_assign/* default */.Z)({}, res.value, timeInfos) });
            }));
        },
    };
    const videoPipeline = {
        loader({ segment, url }) {
            const { video } = getTransportPipelinesFromSegment(segment);
            return video.loader(getLoaderArguments(segment, url));
        },
        parser(args) {
            const { content } = args;
            const { segment } = content;
            const { contentStart, contentEnd } = getMetaPlaylistPrivateInfos(segment);
            const { video } = getTransportPipelinesFromSegment(segment);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return video.parser(getParserArguments(args, segment))
                .pipe((0,map/* map */.U)(res => {
                if (res.type === "parsed-init-segment") {
                    return res;
                }
                const timeInfos = offsetTimeInfos(contentStart, contentEnd, res.value);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return (0,object_assign/* default */.Z)({ type: "parsed-segment",
                    value: (0,object_assign/* default */.Z)({}, res.value, timeInfos) });
            }));
        },
    };
    const textTrackPipeline = {
        loader({ segment, url }) {
            const { text } = getTransportPipelinesFromSegment(segment);
            return text.loader(getLoaderArguments(segment, url));
        },
        parser: (args) => {
            const { content } = args;
            const { segment } = content;
            const { contentStart, contentEnd } = getMetaPlaylistPrivateInfos(segment);
            const { text } = getTransportPipelinesFromSegment(segment);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return text.parser(getParserArguments(args, segment))
                .pipe((0,map/* map */.U)(res => {
                if (res.type === "parsed-init-segment") {
                    return res;
                }
                const timeInfos = offsetTimeInfos(contentStart, contentEnd, res.value);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return (0,object_assign/* default */.Z)({ type: "parsed-segment",
                    value: (0,object_assign/* default */.Z)({}, res.value, timeInfos) });
            }));
        },
    };
    const imageTrackPipeline = {
        loader({ segment, url }) {
            const { image } = getTransportPipelinesFromSegment(segment);
            return image.loader(getLoaderArguments(segment, url));
        },
        parser(args) {
            const { content } = args;
            const { segment } = content;
            const { contentStart, contentEnd } = getMetaPlaylistPrivateInfos(segment);
            const { image } = getTransportPipelinesFromSegment(segment);
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return image.parser(getParserArguments(args, segment))
                .pipe((0,map/* map */.U)(res => {
                if (res.type === "parsed-init-segment") {
                    return res;
                }
                const timeInfos = offsetTimeInfos(contentStart, contentEnd, res.value);
                // eslint-disable-next-line @typescript-eslint/no-unsafe-return
                return (0,object_assign/* default */.Z)({ type: "parsed-segment",
                    value: (0,object_assign/* default */.Z)({}, res.value, timeInfos) });
            }));
        },
    };
    return { manifest: manifestPipeline,
        audio: audioPipeline,
        video: videoPipeline,
        text: textTrackPipeline,
        image: imageTrackPipeline };
}

;// CONCATENATED MODULE: ./src/transports/metaplaylist/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ const transports_metaplaylist = (pipelines);


/***/ }),

/***/ 56707:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ transports_smooth)
});

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(65208);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(5842);
// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(41195);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
// EXTERNAL MODULE: ./src/manifest/index.ts + 5 modules
var src_manifest = __webpack_require__(18567);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/read.ts
var read = __webpack_require__(69903);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(54924);
// EXTERNAL MODULE: ./src/utils/assert.ts
var assert = __webpack_require__(25222);
// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(97308);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(53811);
// EXTERNAL MODULE: ./src/utils/resolve_url.ts
var resolve_url = __webpack_require__(19860);
// EXTERNAL MODULE: ./src/utils/string_parsing.ts
var string_parsing = __webpack_require__(26332);
// EXTERNAL MODULE: ./src/utils/take_first_set.ts
var take_first_set = __webpack_require__(66365);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/constants.ts
var constants = __webpack_require__(63133);
;// CONCATENATED MODULE: ./src/parsers/containers/isobmff/create_box.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Speed up string to bytes conversion by memorizing the result
 *
 * The keys here are ISOBMFF box names. The values are the corresponding
 * bytes conversion for putting as an ISOBMFF boxes.
 *
 * Used by the boxName method.
 * @type {Object}
 */
const boxNamesMem = {};
/**
 * Convert the string name of an ISOBMFF box into the corresponding bytes.
 * Has a memorization mechanism to speed-up if you want to translate the
 * same string multiple times.
 * @param {string} str
 * @returns {Uint8Array}
 */
function boxName(str) {
    if (boxNamesMem[str] != null) {
        return boxNamesMem[str];
    }
    const nameInBytes = (0,string_parsing/* strToUtf8 */.tG)(str);
    boxNamesMem[str] = nameInBytes;
    return nameInBytes;
}
/**
 * Create a new ISOBMFF "box" with the given name.
 * @param {string} name - name of the box you want to create, must always
 * be 4 characters (uuid boxes not supported)
 * @param {Uint8Array} buff - content of the box
 * @returns {Uint8Array} - The entire ISOBMFF box (length+name+content)
 */
function createBox(name, buff) {
    const len = buff.length + 8;
    return len <= constants/* MAX_32_BIT_INT */.s ? (0,byte_parsing/* concat */.zo)((0,byte_parsing/* itobe4 */.kh)(len), boxName(name), buff) :
        (0,byte_parsing/* concat */.zo)((0,byte_parsing/* itobe4 */.kh)(1), boxName(name), (0,byte_parsing/* itobe8 */.el)(len + 8), buff);
}
/**
 * @param {string} name
 * @param {Array.<Uint8Array>} children
 * @returns {Uint8Array}
 */
function createBoxWithChildren(name, children) {
    return createBox(name, (0,byte_parsing/* concat */.zo)(...children));
}


;// CONCATENATED MODULE: ./src/parsers/manifest/utils/check_manifest_ids.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Ensure that no two periods, adaptations from the same period and
 * representations from the same adaptation, have the same ID.
 *
 * Log and mutate their ID if not until this is verified.
 *
 * @param {Object} manifest
 */
function checkManifestIDs(manifest) {
    const periodIDS = [];
    manifest.periods.forEach((period) => {
        const periodID = period.id;
        if ((0,array_includes/* default */.Z)(periodIDS, periodID)) {
            log/* default.warn */.Z.warn("Two periods with the same ID found. Updating.");
            const newID = periodID + "-dup";
            period.id = newID;
            checkManifestIDs(manifest);
            periodIDS.push(newID);
        }
        else {
            periodIDS.push(periodID);
        }
        const { adaptations } = period;
        const adaptationIDs = [];
        Object.keys(adaptations).forEach((type) => {
            const adaptationsForType = adaptations[type];
            if (adaptationsForType === undefined) {
                return;
            }
            adaptationsForType.forEach(adaptation => {
                const adaptationID = adaptation.id;
                if ((0,array_includes/* default */.Z)(adaptationIDs, adaptationID)) {
                    log/* default.warn */.Z.warn("Two adaptations with the same ID found. Updating.", adaptationID);
                    const newID = adaptationID + "-dup";
                    adaptation.id = newID;
                    checkManifestIDs(manifest);
                    adaptationIDs.push(newID);
                }
                else {
                    adaptationIDs.push(adaptationID);
                }
                const representationIDs = [];
                adaptation.representations.forEach(representation => {
                    const representationID = representation.id;
                    if ((0,array_includes/* default */.Z)(representationIDs, representationID)) {
                        log/* default.warn */.Z.warn("Two representations with the same ID found. Updating.", representationID);
                        const newID = representationID + "-dup";
                        representation.id = newID;
                        checkManifestIDs(manifest);
                        representationIDs.push(newID);
                    }
                    else {
                        representationIDs.push(representationID);
                    }
                });
            });
        });
    });
}

;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/get_codecs.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {string} codecPrivateData
 * @param {string|undefined} fourCC
 * @returns {string}
 */
function getAudioCodecs(codecPrivateData, fourCC) {
    let mpProfile;
    if (fourCC === "AACH") {
        mpProfile = 5; // High Efficiency AAC Profile
    }
    else {
        mpProfile = (0,is_non_empty_string/* default */.Z)(codecPrivateData) ?
            (parseInt(codecPrivateData.substring(0, 2), 16) & 0xF8) >> 3 :
            2;
    }
    if (mpProfile === 0) {
        // Return default audio codec
        return "mp4a.40.2";
    }
    return `mp4a.40.${mpProfile}`;
}
/**
 * @param {string} codecPrivateData
 * @returns {string}
 */
function getVideoCodecs(codecPrivateData) {
    // we can extract codes only if fourCC is on of "H264", "X264", "DAVC", "AVC1"
    const arr = /00000001\d7([0-9a-fA-F]{6})/.exec(codecPrivateData);
    if (arr === null || !(0,is_non_empty_string/* default */.Z)(arr[1])) {
        // Return default video codec
        return "avc1.4D401E";
    }
    return "avc1." + arr[1];
}

;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_C_nodes.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Parse C nodes to build index timeline.
 * @param {Element} nodes
 */
function parseCNodes(nodes) {
    return nodes.reduce((timeline, node, i) => {
        const dAttr = node.getAttribute("d");
        const tAttr = node.getAttribute("t");
        const rAttr = node.getAttribute("r");
        const repeatCount = rAttr !== null ? +rAttr - 1 : 0;
        let start = tAttr !== null ? +tAttr : undefined;
        let duration = dAttr !== null ? +dAttr : undefined;
        if (i === 0) { // first node
            start = start === undefined || isNaN(start) ? 0 :
                start;
        }
        else { // from second node to the end
            const prev = timeline[i - 1];
            if (start == null || isNaN(start)) {
                if (prev.duration == null || isNaN(prev.duration)) {
                    throw new Error("Smooth: Invalid CNodes. Missing timestamp.");
                }
                start = prev.start + prev.duration * (prev.repeatCount + 1);
            }
        }
        if (duration == null || isNaN(duration)) {
            const nextNode = nodes[i + 1];
            if (nextNode !== undefined) {
                const nextTAttr = nextNode.getAttribute("t");
                const nextStart = (0,is_non_empty_string/* default */.Z)(nextTAttr) ? +nextTAttr :
                    null;
                if (nextStart === null) {
                    throw new Error("Can't build index timeline from Smooth Manifest.");
                }
                duration = nextStart - start;
            }
            else {
                return timeline;
            }
        }
        timeline.push({ duration, start, repeatCount });
        return timeline;
    }, []);
}

// EXTERNAL MODULE: ./src/utils/base64.ts
var base64 = __webpack_require__(91282);
;// CONCATENATED MODULE: ./src/parsers/containers/isobmff/drm/playready.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Parse PlayReady privateData to get its Hexa-coded KeyID.
 * @param {Uint8Array} privateData
 * @returns {string}
 */
function getPlayReadyKIDFromPrivateData(data) {
    const xmlLength = (0,byte_parsing/* le2toi */.qb)(data, 8);
    const xml = (0,string_parsing/* utf16LEToStr */.wV)(data.subarray(10, xmlLength + 10));
    const doc = new DOMParser().parseFromString(xml, "application/xml");
    const kidElement = doc.querySelector("KID");
    if (kidElement === null) {
        throw new Error("Cannot parse PlayReady private data: invalid XML");
    }
    const b64guidKid = kidElement.textContent === null ? "" :
        kidElement.textContent;
    const uuidKid = (0,string_parsing/* guidToUuid */.wO)((0,base64/* base64ToBytes */.K)(b64guidKid));
    return (0,string_parsing/* bytesToHex */.ci)(uuidKid).toLowerCase();
}

;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/parse_protection_node.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * @param {Uint8Array} keyIdBytes
 * @returns {Array.<Object>}
 */
function createWidevineKeySystem(keyIdBytes) {
    return [{ systemId: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed",
            privateData: (0,byte_parsing/* concat */.zo)([0x08, 0x01, 0x12, 0x10], keyIdBytes) }];
}
/**
 * Parse "Protection" Node, which contains DRM information
 * @param {Element} protectionNode
 * @returns {Object}
 */
function parseProtectionNode(protectionNode, keySystemCreator = createWidevineKeySystem) {
    if (protectionNode.firstElementChild === null ||
        protectionNode.firstElementChild.nodeName !== "ProtectionHeader") {
        throw new Error("Protection should have ProtectionHeader child");
    }
    const header = protectionNode.firstElementChild;
    const privateData = (0,base64/* base64ToBytes */.K)(header.textContent === null ? "" :
        header.textContent);
    const keyIdHex = getPlayReadyKIDFromPrivateData(privateData);
    const keyIdBytes = (0,string_parsing/* hexToBytes */.nr)(keyIdHex);
    // remove possible braces
    const systemIdAttr = header.getAttribute("SystemID");
    const systemId = (systemIdAttr !== null ? systemIdAttr :
        "")
        .toLowerCase()
        .replace(/\{|\}/g, "");
    return {
        keyId: keyIdBytes,
        keySystems: [{
                systemId,
                privateData,
                /* keyIds: [keyIdBytes], */
            }].concat(keySystemCreator(keyIdBytes)),
    };
}

// EXTERNAL MODULE: ./src/errors/network_error.ts
var network_error = __webpack_require__(12081);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/clear_timeline_from_position.ts
var clear_timeline_from_position = __webpack_require__(2259);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/index_helpers.ts
var index_helpers = __webpack_require__(61443);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/is_segment_still_available.ts
var is_segment_still_available = __webpack_require__(91434);
// EXTERNAL MODULE: ./src/parsers/manifest/utils/update_segment_timeline.ts
var update_segment_timeline = __webpack_require__(71140);
;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/add_segment_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Add a new segment to the index.
 *
 * /!\ Mutate the given index
 * @param {Object} index
 * @param {Object} newSegment
 * @param {Object} currentSegment
 * @returns {Boolean} - true if the segment has been added
 */
function _addSegmentInfos(index, newSegment, currentSegment) {
    const { timeline, timescale } = index;
    const timelineLength = timeline.length;
    const last = timeline[timelineLength - 1];
    const scaledNewSegment = newSegment.timescale === timescale ?
        { time: newSegment.time,
            duration: newSegment.duration } :
        { time: (newSegment.time / newSegment.timescale) * timescale,
            duration: (newSegment.duration / newSegment.timescale) * timescale };
    // in some circumstances, the new segment information are only duration
    // information that we could use to deduct the start of the next segment.
    // This is the case where the new segment are associated to a current
    // segment and have the same start.
    // However, we prefer to be sure of the duration of the new segments
    // before adding such segments.
    const shouldDeductNextSegment = currentSegment.time === scaledNewSegment.time;
    if (shouldDeductNextSegment) {
        return false;
    }
    else if (scaledNewSegment.time >= (0,index_helpers/* getIndexSegmentEnd */.jH)(last, null)) {
        // if the given timing has a timestamp after the timeline end we
        // just need to push a new element in the timeline, or increase
        // the @r attribute of the last element.
        if (last.duration === scaledNewSegment.duration) {
            last.repeatCount++;
        }
        else {
            index.timeline.push({ duration: scaledNewSegment.duration,
                start: scaledNewSegment.time,
                repeatCount: 0 });
        }
        return true;
    }
    return false;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/tokens.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {string} url
 * @param {string|number} bitrate
 * @returns {string}
 */
function replaceRepresentationSmoothTokens(url, bitrate, customAttributes) {
    return url
        .replace(/\{bitrate\}/g, String(bitrate))
        .replace(/{CustomAttributes}/g, customAttributes.length > 0 ? customAttributes[0] :
        "");
}
/**
 * @param {string} url
 * @param {number} time
 * @returns {string}
 */
function replaceSegmentSmoothTokens(url, time) {
    return url.replace(/\{start time\}/g, String(time));
}


;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/representation_index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * @param {Number} start
 * @param {Number} up
 * @param {Number} duration
 * @returns {Number}
 */
function getSegmentNumber(start, up, duration) {
    const diff = up - start;
    return diff > 0 ? Math.floor(diff / duration) :
        0;
}
/**
 * Convert second-based start time and duration to the timescale of the
 * manifest's index.
 * @param {Object} index
 * @param {Number} start
 * @param {Number} duration
 * @returns {Object} - Object with two properties:
 *   - up {Number}: timescaled timestamp of the beginning time
 *   - to {Number}: timescaled timestamp of the end time (start time + duration)
 */
function normalizeRange(index, start, duration) {
    const timescale = index.timescale === undefined ||
        index.timescale === 0 ? 1 :
        index.timescale;
    return { up: start * timescale,
        to: (start + duration) * timescale };
}
/**
 * Calculate the number of times a segment repeat based on the next segment.
 * @param {Object} segment
 * @param {Object} nextSegment
 * @returns {Number}
 */
function calculateRepeat(segment, nextSegment) {
    let repeatCount = segment.repeatCount;
    // A negative value of the @r attribute of the S element indicates
    // that the duration indicated in @d attribute repeats until the
    // start of the next S element, the end of the Period or until the
    // next MPD update.
    // TODO Also for SMOOTH????
    if (segment.duration != null && repeatCount < 0) {
        const repeatEnd = nextSegment !== undefined ? nextSegment.start :
            Infinity;
        repeatCount = Math.ceil((repeatEnd - segment.start) / segment.duration) - 1;
    }
    return repeatCount;
}
/**
 * RepresentationIndex implementation for Smooth Manifests.
 *
 * Allows to interact with the index to create new Segments.
 *
 * @class SmoothRepresentationIndex
 */
class SmoothRepresentationIndex {
    constructor(index, options) {
        const { aggressiveMode, isLive, segmentPrivateInfos } = options;
        const estimatedReceivedTime = index.manifestReceivedTime == null ?
            performance.now() :
            index.manifestReceivedTime;
        this._index = index;
        this._indexValidityTime = estimatedReceivedTime;
        this._initSegmentInfos = { bitsPerSample: segmentPrivateInfos.bitsPerSample,
            channels: segmentPrivateInfos.channels,
            codecPrivateData: segmentPrivateInfos.codecPrivateData,
            packetSize: segmentPrivateInfos.packetSize,
            samplingRate: segmentPrivateInfos.samplingRate,
            timescale: index.timescale,
            protection: segmentPrivateInfos.protection };
        this._isAggressiveMode = aggressiveMode;
        this._isLive = isLive;
        if (index.timeline.length !== 0) {
            const lastItem = index.timeline[index.timeline.length - 1];
            const scaledEnd = (0,index_helpers/* getIndexSegmentEnd */.jH)(lastItem, null);
            this._initialScaledLastPosition = scaledEnd;
            if (index.isLive) {
                const scaledReceivedTime = (estimatedReceivedTime / 1000) * index.timescale;
                this._scaledLiveGap = scaledReceivedTime - scaledEnd;
            }
        }
    }
    /**
     * Construct init Segment compatible with a Smooth Manifest.
     * @returns {Object}
     */
    getInitSegment() {
        return { id: "init",
            isInit: true,
            privateInfos: { smoothInitSegment: this._initSegmentInfos },
            mediaURLs: null,
            time: 0,
            end: 0,
            duration: 0,
            timescale: 1 };
    }
    /**
     * Generate a list of Segments for a particular period of time.
     *
     * @param {Number} _up
     * @param {Number} _to
     * @returns {Array.<Object>}
     */
    getSegments(_up, _to) {
        this._refreshTimeline();
        const { up, to } = normalizeRange(this._index, _up, _to);
        const { timeline, timescale, media } = this._index;
        const isAggressive = this._isAggressiveMode;
        let currentNumber;
        const segments = [];
        const timelineLength = timeline.length;
        const maxPosition = this._scaledLiveGap == null ?
            undefined :
            ((performance.now() / 1000) * timescale) - this._scaledLiveGap;
        for (let i = 0; i < timelineLength; i++) {
            const segmentRange = timeline[i];
            const { duration, start } = segmentRange;
            const repeat = calculateRepeat(segmentRange, timeline[i + 1]);
            let segmentNumberInCurrentRange = getSegmentNumber(start, up, duration);
            let segmentTime = start + segmentNumberInCurrentRange * duration;
            const timeToAddToCheckMaxPosition = isAggressive ? 0 :
                duration;
            while (segmentTime < to &&
                segmentNumberInCurrentRange <= repeat &&
                (maxPosition == null ||
                    (segmentTime + timeToAddToCheckMaxPosition) <= maxPosition)) {
                const time = segmentTime;
                const number = currentNumber != null ?
                    currentNumber + segmentNumberInCurrentRange :
                    undefined;
                const segment = { id: String(segmentTime),
                    isInit: false,
                    time: time / timescale,
                    end: (time + duration) / timescale,
                    duration: duration / timescale, timescale: 1, number,
                    mediaURLs: [replaceSegmentSmoothTokens(media, time)],
                    privateInfos: { smoothMediaSegment: { time,
                            duration } } };
                segments.push(segment);
                // update segment number and segment time for the next segment
                segmentNumberInCurrentRange++;
                segmentTime = start + segmentNumberInCurrentRange * duration;
            }
            if (segmentTime >= to) {
                // we reached ``to``, we're done
                return segments;
            }
            if (currentNumber != null) {
                currentNumber += repeat + 1;
            }
        }
        return segments;
    }
    /**
     * Returns true if, based on the arguments, the index should be refreshed.
     * (If we should re-fetch the manifest)
     * @param {Number} up
     * @param {Number} to
     * @returns {Boolean}
     */
    shouldRefresh(up, to) {
        this._refreshTimeline();
        if (!this._index.isLive) {
            return false;
        }
        const { timeline, timescale } = this._index;
        const lastSegmentInCurrentTimeline = timeline[timeline.length - 1];
        if (lastSegmentInCurrentTimeline === undefined) {
            return false;
        }
        const repeat = lastSegmentInCurrentTimeline.repeatCount;
        const endOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + (repeat + 1) *
            lastSegmentInCurrentTimeline.duration;
        if (to * timescale < endOfLastSegmentInCurrentTimeline) {
            return false;
        }
        if (up * timescale >= endOfLastSegmentInCurrentTimeline) {
            return true;
        }
        // ----
        const startOfLastSegmentInCurrentTimeline = lastSegmentInCurrentTimeline.start + repeat *
            lastSegmentInCurrentTimeline.duration;
        return (up * timescale) > startOfLastSegmentInCurrentTimeline;
    }
    /**
     * Returns first position available in the index.
     *
     * @param {Object} index
     * @returns {Number|null}
     */
    getFirstPosition() {
        this._refreshTimeline();
        const index = this._index;
        if (index.timeline.length === 0) {
            return null;
        }
        return index.timeline[0].start / index.timescale;
    }
    /**
     * Returns last position available in the index.
     * @param {Object} index
     * @returns {Number}
     */
    getLastPosition() {
        this._refreshTimeline();
        const index = this._index;
        if (this._scaledLiveGap == null) {
            const lastTimelineElement = index.timeline[index.timeline.length - 1];
            return (0,index_helpers/* getIndexSegmentEnd */.jH)(lastTimelineElement, null) / index.timescale;
        }
        for (let i = index.timeline.length - 1; i >= 0; i--) {
            const timelineElt = index.timeline[i];
            const timescaledNow = (performance.now() / 1000) * index.timescale;
            const { start, duration, repeatCount } = timelineElt;
            for (let j = repeatCount; j >= 0; j--) {
                const end = start + (duration * (j + 1));
                const positionToReach = this._isAggressiveMode ? end - duration :
                    end;
                if (positionToReach <= timescaledNow - this._scaledLiveGap) {
                    return end / index.timescale;
                }
            }
        }
        return undefined;
    }
    /**
     * @param {number} timeSec
     * @returns {number|null}
     */
    checkDiscontinuity(timeSec) {
        this._refreshTimeline();
        return (0,index_helpers/* checkDiscontinuity */._j)(this._index, timeSec, undefined);
    }
    /**
     * @returns {boolean}
     */
    areSegmentsChronologicallyGenerated() {
        return true;
    }
    isSegmentStillAvailable(segment) {
        if (segment.isInit) {
            return true;
        }
        this._refreshTimeline();
        const { timeline, timescale } = this._index;
        return (0,is_segment_still_available/* default */.Z)(segment, timeline, timescale, 0);
    }
    /**
     * @param {Error} error
     * @returns {Boolean}
     */
    canBeOutOfSyncError(error) {
        if (!this._isLive) {
            return false;
        }
        return error instanceof network_error/* default */.Z &&
            (error.isHttpError(404) || error.isHttpError(412));
    }
    /**
     * Replace this RepresentationIndex by a newly downloaded one.
     * Check if the old index had more information about new segments and re-add
     * them if that's the case.
     * @param {Object} newIndex
     */
    _replace(newIndex) {
        const oldTimeline = this._index.timeline;
        const newTimeline = newIndex._index.timeline;
        const oldTimescale = this._index.timescale;
        const newTimescale = newIndex._index.timescale;
        this._index = newIndex._index;
        this._initialScaledLastPosition = newIndex._initialScaledLastPosition;
        this._indexValidityTime = newIndex._indexValidityTime;
        this._scaledLiveGap = newIndex._scaledLiveGap;
        if (oldTimeline.length === 0 ||
            newTimeline.length === 0 ||
            oldTimescale !== newTimescale) {
            return; // don't take risk, if something is off, take the new one
        }
        const lastOldTimelineElement = oldTimeline[oldTimeline.length - 1];
        const lastNewTimelineElement = newTimeline[newTimeline.length - 1];
        const newEnd = (0,index_helpers/* getIndexSegmentEnd */.jH)(lastNewTimelineElement, null);
        if ((0,index_helpers/* getIndexSegmentEnd */.jH)(lastOldTimelineElement, null) <= newEnd) {
            return;
        }
        for (let i = 0; i < oldTimeline.length; i++) {
            const oldTimelineRange = oldTimeline[i];
            const oldEnd = (0,index_helpers/* getIndexSegmentEnd */.jH)(oldTimelineRange, null);
            if (oldEnd === newEnd) { // just add the supplementary segments
                this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i + 1));
                return;
            }
            if (oldEnd > newEnd) { // adjust repeatCount + add supplementary segments
                if (oldTimelineRange.duration !== lastNewTimelineElement.duration) {
                    return;
                }
                const rangeDuration = newEnd - oldTimelineRange.start;
                if (rangeDuration === 0) {
                    log/* default.warn */.Z.warn("Smooth Parser: a discontinuity detected in the previous manifest" +
                        " has been resolved.");
                    this._index.timeline = this._index.timeline.concat(oldTimeline.slice(i));
                    return;
                }
                if (rangeDuration < 0 || rangeDuration % oldTimelineRange.duration !== 0) {
                    return;
                }
                const repeatWithOld = (rangeDuration / oldTimelineRange.duration) - 1;
                const relativeRepeat = oldTimelineRange.repeatCount - repeatWithOld;
                if (relativeRepeat < 0) {
                    return;
                }
                lastNewTimelineElement.repeatCount += relativeRepeat;
                const supplementarySegments = oldTimeline.slice(i + 1);
                this._index.timeline = this._index.timeline.concat(supplementarySegments);
                return;
            }
        }
    }
    _update(newIndex) {
        (0,update_segment_timeline/* default */.Z)(this._index.timeline, newIndex._index.timeline);
        this._initialScaledLastPosition = newIndex._initialScaledLastPosition;
        this._indexValidityTime = newIndex._indexValidityTime;
        this._scaledLiveGap = newIndex._scaledLiveGap;
    }
    /**
     * @returns {Boolean}
     */
    isFinished() {
        return !this._isLive;
    }
    /**
     * @returns {Boolean}
     */
    isInitialized() {
        return true;
    }
    _addSegments(nextSegments, currentSegment) {
        this._refreshTimeline();
        for (let i = 0; i < nextSegments.length; i++) {
            _addSegmentInfos(this._index, nextSegments[i], currentSegment);
        }
    }
    /**
     * Clean-up timeline to remove segment information which should not be
     * available due to the timeshift window
     */
    _refreshTimeline() {
        // clean segments before time shift buffer depth
        if (this._initialScaledLastPosition == null) {
            return;
        }
        const index = this._index;
        const { timeShiftBufferDepth } = index;
        const timeSinceLastRealUpdate = (performance.now() -
            this._indexValidityTime) / 1000;
        const lastPositionEstimate = timeSinceLastRealUpdate +
            this._initialScaledLastPosition / index.timescale;
        if (timeShiftBufferDepth != null) {
            const minimumPosition = (lastPositionEstimate - timeShiftBufferDepth) *
                index.timescale;
            (0,clear_timeline_from_position/* default */.Z)(index.timeline, minimumPosition);
        }
    }
}

;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/parseBoolean.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {*} parseBoolean
 * @returns {Boolean}
 */
function parseBoolean(val) {
    if (typeof val === "boolean") {
        return val;
    }
    else if (typeof val === "string") {
        return val.toUpperCase() === "TRUE";
    }
    else {
        return false;
    }
}

;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/utils/reduceChildren.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Reduce implementation for the children of the given element.
 * @param {Element} root
 * @param {Function} fn
 * @param {*} init
 * @returns {*}
 */
function reduceChildren(root, fn, init) {
    let node = root.firstElementChild;
    let accumulator = init;
    while (node !== null) {
        accumulator = fn(accumulator, node.nodeName, node);
        node = node.nextElementSibling;
    }
    return accumulator;
}

;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/create_parser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


















/**
 * Default value for the aggressive `mode`.
 * In this mode, segments will be returned even if we're not sure those had time
 * to be generated.
 */
const DEFAULT_AGGRESSIVE_MODE = false;
const KNOWN_ADAPTATION_TYPES = ["audio", "video", "text", "image"];
const DEFAULT_MIME_TYPES = {
    audio: "audio/mp4",
    video: "video/mp4",
    text: "application/ttml+xml",
};
const MIME_TYPES = {
    AACL: "audio/mp4",
    AVC1: "video/mp4",
    H264: "video/mp4",
    TTML: "application/ttml+xml+mp4",
};
/**
 * @param {Object|undefined} parserOptions
 * @returns {Function}
 */
function createSmoothStreamingParser(parserOptions = {}) {
    const referenceDateTime = parserOptions.referenceDateTime === undefined ?
        Date.UTC(1970, 0, 1, 0, 0, 0, 0) / 1000 :
        parserOptions.referenceDateTime;
    const minRepresentationBitrate = parserOptions.minRepresentationBitrate === undefined ?
        0 :
        parserOptions.minRepresentationBitrate;
    const { serverSyncInfos } = parserOptions;
    const serverTimeOffset = serverSyncInfos !== undefined ?
        serverSyncInfos.serverTimestamp - serverSyncInfos.clientTime :
        undefined;
    /**
     * @param {Element} q
     * @param {string} streamType
     * @return {Object}
     */
    function parseQualityLevel(q, streamType) {
        const customAttributes = reduceChildren(q, (acc, qName, qNode) => {
            if (qName === "CustomAttributes") {
                acc.push(...reduceChildren(qNode, (cAttrs, cName, cNode) => {
                    if (cName === "Attribute") {
                        const name = cNode.getAttribute("Name");
                        const value = cNode.getAttribute("Value");
                        if (name !== null && value !== null) {
                            cAttrs.push(name + "=" + value);
                        }
                    }
                    return cAttrs;
                }, []));
            }
            return acc;
        }, []);
        /**
         * @param {string} name
         * @returns {string|undefined}
         */
        function getAttribute(name) {
            const attr = q.getAttribute(name);
            return attr == null ? undefined : attr;
        }
        switch (streamType) {
            case "audio": {
                const audiotag = getAttribute("AudioTag");
                const bitsPerSample = getAttribute("BitsPerSample");
                const channels = getAttribute("Channels");
                const codecPrivateData = getAttribute("CodecPrivateData");
                const fourCC = getAttribute("FourCC");
                const packetSize = getAttribute("PacketSize");
                const samplingRate = getAttribute("SamplingRate");
                const bitrateAttr = getAttribute("Bitrate");
                const bitrate = bitrateAttr === undefined ? 0 :
                    isNaN(parseInt(bitrateAttr, 10)) ? 0 :
                        parseInt(bitrateAttr, 10);
                if ((fourCC !== undefined &&
                    MIME_TYPES[fourCC] === undefined) ||
                    codecPrivateData === undefined) {
                    log/* default.warn */.Z.warn("Smooth parser: Unsupported audio codec. Ignoring quality level.");
                    return null;
                }
                const codecs = getAudioCodecs(codecPrivateData, fourCC);
                return {
                    audiotag: audiotag !== undefined ? parseInt(audiotag, 10) : audiotag,
                    bitrate,
                    bitsPerSample: bitsPerSample !== undefined ?
                        parseInt(bitsPerSample, 10) : bitsPerSample,
                    channels: channels !== undefined ? parseInt(channels, 10) : channels,
                    codecPrivateData,
                    codecs,
                    customAttributes,
                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,
                    packetSize: packetSize !== undefined ?
                        parseInt(packetSize, 10) :
                        packetSize,
                    samplingRate: samplingRate !== undefined ?
                        parseInt(samplingRate, 10) :
                        samplingRate,
                };
            }
            case "video": {
                const codecPrivateData = getAttribute("CodecPrivateData");
                const fourCC = getAttribute("FourCC");
                const width = getAttribute("MaxWidth");
                const height = getAttribute("MaxHeight");
                const bitrateAttr = getAttribute("Bitrate");
                const bitrate = bitrateAttr === undefined ? 0 :
                    isNaN(parseInt(bitrateAttr, 10)) ? 0 :
                        parseInt(bitrateAttr, 10);
                if ((fourCC !== undefined &&
                    MIME_TYPES[fourCC] === undefined) ||
                    codecPrivateData === undefined) {
                    log/* default.warn */.Z.warn("Smooth parser: Unsupported video codec. Ignoring quality level.");
                    return null;
                }
                const codecs = getVideoCodecs(codecPrivateData);
                return {
                    bitrate,
                    customAttributes,
                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] : fourCC,
                    codecPrivateData,
                    codecs,
                    width: width !== undefined ? parseInt(width, 10) : undefined,
                    height: height !== undefined ? parseInt(height, 10) : undefined,
                };
            }
            case "text": {
                const codecPrivateData = getAttribute("CodecPrivateData");
                const fourCC = getAttribute("FourCC");
                const bitrateAttr = getAttribute("Bitrate");
                const bitrate = bitrateAttr === undefined ? 0 :
                    isNaN(parseInt(bitrateAttr, 10)) ? 0 :
                        parseInt(bitrateAttr, 10);
                return { bitrate,
                    customAttributes,
                    mimeType: fourCC !== undefined ? MIME_TYPES[fourCC] :
                        fourCC, codecPrivateData: (0,take_first_set/* default */.Z)(codecPrivateData, "") };
            }
            default:
                log/* default.error */.Z.error("Smooth Parser: Unrecognized StreamIndex type: " + streamType);
                return null;
        }
    }
    /**
     * Parse the adaptations (<StreamIndex>) tree containing
     * representations (<QualityLevels>) and timestamp indexes (<c>).
     * Indexes can be quite huge, and this function needs to
     * to be optimized.
     * @param {Object} args
     * @returns {Object}
     */
    function parseAdaptation(args) {
        const { root, timescale, rootURL, protections, timeShiftBufferDepth, manifestReceivedTime, isLive } = args;
        const timescaleAttr = root.getAttribute("Timescale");
        const _timescale = timescaleAttr === null ? timescale :
            isNaN(+timescaleAttr) ? timescale :
                +timescaleAttr;
        const typeAttribute = root.getAttribute("Type");
        if (typeAttribute === null) {
            throw new Error("StreamIndex without type.");
        }
        if (!(0,array_includes/* default */.Z)(KNOWN_ADAPTATION_TYPES, typeAttribute)) {
            log/* default.warn */.Z.warn("Smooth Parser: Unrecognized adaptation type:", typeAttribute);
        }
        const adaptationType = typeAttribute;
        const subType = root.getAttribute("Subtype");
        const language = root.getAttribute("Language");
        const baseURLAttr = root.getAttribute("Url");
        const baseURL = baseURLAttr === null ? "" :
            baseURLAttr;
        if (true) {
            (0,assert/* default */.Z)(baseURL !== "");
        }
        const { qualityLevels, cNodes } = reduceChildren(root, (res, _name, node) => {
            switch (_name) {
                case "QualityLevel":
                    const qualityLevel = parseQualityLevel(node, adaptationType);
                    if (qualityLevel === null) {
                        return res;
                    }
                    // filter out video qualityLevels with small bitrates
                    if (adaptationType !== "video" ||
                        qualityLevel.bitrate > minRepresentationBitrate) {
                        res.qualityLevels.push(qualityLevel);
                    }
                    break;
                case "c":
                    res.cNodes.push(node);
                    break;
            }
            return res;
        }, { qualityLevels: [], cNodes: [] });
        const index = { timeline: parseCNodes(cNodes),
            timescale: _timescale };
        // we assume that all qualityLevels have the same
        // codec and mimeType
        (0,assert/* default */.Z)(qualityLevels.length !== 0, "Adaptation should have at least one playable representation.");
        const adaptationID = adaptationType +
            ((0,is_non_empty_string/* default */.Z)(language) ? ("_" + language) :
                "");
        const representations = qualityLevels.map((qualityLevel) => {
            const path = (0,resolve_url/* default */.Z)(rootURL, baseURL);
            const repIndex = {
                timeline: index.timeline,
                timescale: index.timescale,
                media: replaceRepresentationSmoothTokens(path, qualityLevel.bitrate, qualityLevel.customAttributes),
                isLive,
                timeShiftBufferDepth,
                manifestReceivedTime,
            };
            const mimeType = (0,is_non_empty_string/* default */.Z)(qualityLevel.mimeType) ?
                qualityLevel.mimeType :
                DEFAULT_MIME_TYPES[adaptationType];
            const codecs = qualityLevel.codecs;
            const id = adaptationID + "_" +
                (adaptationType != null ? adaptationType + "-" :
                    "") +
                (mimeType != null ? mimeType + "-" :
                    "") +
                (codecs != null ? codecs + "-" :
                    "") +
                String(qualityLevel.bitrate);
            const keyIDs = [];
            let firstProtection;
            if (protections.length > 0) {
                firstProtection = protections[0];
                protections.forEach((protection) => {
                    const keyId = protection.keyId;
                    protection.keySystems.forEach((keySystem) => {
                        keyIDs.push({ keyId,
                            systemId: keySystem.systemId });
                    });
                });
            }
            const segmentPrivateInfos = { bitsPerSample: qualityLevel.bitsPerSample,
                channels: qualityLevel.channels,
                codecPrivateData: qualityLevel.codecPrivateData,
                packetSize: qualityLevel.packetSize,
                samplingRate: qualityLevel.samplingRate,
                // TODO set multiple protections here
                // instead of the first one
                protection: firstProtection != null ? {
                    keyId: firstProtection.keyId,
                } : undefined };
            const aggressiveMode = parserOptions.aggressiveMode == null ?
                DEFAULT_AGGRESSIVE_MODE :
                parserOptions.aggressiveMode;
            const reprIndex = new SmoothRepresentationIndex(repIndex, { aggressiveMode,
                isLive,
                segmentPrivateInfos });
            const representation = (0,object_assign/* default */.Z)({}, qualityLevel, { index: reprIndex,
                mimeType,
                codecs,
                id });
            if (keyIDs.length > 0 || firstProtection !== undefined) {
                const initDataValues = firstProtection === undefined ?
                    [] :
                    firstProtection.keySystems.map((keySystemData) => {
                        const { systemId, privateData } = keySystemData;
                        const cleanedSystemId = systemId.replace(/-/g, "");
                        const pssh = createPSSHBox(cleanedSystemId, privateData);
                        return { systemId: cleanedSystemId, data: pssh };
                    });
                if (initDataValues.length > 0) {
                    const initData = [{ type: "cenc", values: initDataValues }];
                    representation.contentProtections = { keyIds: keyIDs, initData };
                }
                else {
                    representation.contentProtections = { keyIds: keyIDs, initData: [] };
                }
            }
            return representation;
        });
        // TODO(pierre): real ad-insert support
        if (subType === "ADVT") {
            return null;
        }
        const parsedAdaptation = { id: adaptationID,
            type: adaptationType,
            representations,
            language: language == null ?
                undefined :
                language };
        if (adaptationType === "text" && subType === "DESC") {
            parsedAdaptation.closedCaption = true;
        }
        return parsedAdaptation;
    }
    function parseFromDocument(doc, url, manifestReceivedTime) {
        const rootURL = (0,resolve_url/* normalizeBaseURL */.f)(url == null ? "" : url);
        const root = doc.documentElement;
        if (root == null || root.nodeName !== "SmoothStreamingMedia") {
            throw new Error("document root should be SmoothStreamingMedia");
        }
        const majorVersionAttr = root.getAttribute("MajorVersion");
        const minorVersionAttr = root.getAttribute("MinorVersion");
        if (majorVersionAttr === null || minorVersionAttr === null ||
            !/^[2]-[0-2]$/.test(majorVersionAttr + "-" + minorVersionAttr)) {
            throw new Error("Version should be 2.0, 2.1 or 2.2");
        }
        const timescaleAttr = root.getAttribute("Timescale");
        const timescale = !(0,is_non_empty_string/* default */.Z)(timescaleAttr) ? 10000000 :
            isNaN(+timescaleAttr) ? 10000000 :
                +timescaleAttr;
        const { protections, adaptationNodes, } = reduceChildren(root, (res, name, node) => {
            switch (name) {
                case "Protection": {
                    res.protections.push(parseProtectionNode(node, parserOptions.keySystems));
                    break;
                }
                case "StreamIndex":
                    res.adaptationNodes.push(node);
                    break;
            }
            return res;
        }, {
            adaptationNodes: [],
            protections: [],
        });
        const initialAdaptations = {};
        const isLive = parseBoolean(root.getAttribute("IsLive"));
        let timeShiftBufferDepth;
        if (isLive) {
            const dvrWindowLength = root.getAttribute("DVRWindowLength");
            if (dvrWindowLength != null &&
                !isNaN(+dvrWindowLength) &&
                +dvrWindowLength !== 0) {
                timeShiftBufferDepth = +dvrWindowLength / timescale;
            }
        }
        const adaptations = adaptationNodes
            .reduce((acc, node) => {
            const adaptation = parseAdaptation({ root: node,
                rootURL,
                timescale,
                protections,
                isLive,
                timeShiftBufferDepth,
                manifestReceivedTime });
            if (adaptation === null) {
                return acc;
            }
            const type = adaptation.type;
            const adaps = acc[type];
            if (adaps === undefined) {
                acc[type] = [adaptation];
            }
            else {
                adaps.push(adaptation);
            }
            return acc;
        }, initialAdaptations);
        let suggestedPresentationDelay;
        let availabilityStartTime;
        let minimumTime;
        let timeshiftDepth = null;
        let maximumTimeData;
        const firstVideoAdaptation = adaptations.video !== undefined ?
            adaptations.video[0] :
            undefined;
        const firstAudioAdaptation = adaptations.audio !== undefined ?
            adaptations.audio[0] :
            undefined;
        let firstTimeReference;
        let lastTimeReference;
        if (firstVideoAdaptation !== undefined || firstAudioAdaptation !== undefined) {
            const firstTimeReferences = [];
            const lastTimeReferences = [];
            if (firstVideoAdaptation !== undefined) {
                const firstVideoRepresentation = firstVideoAdaptation.representations[0];
                if (firstVideoRepresentation !== undefined) {
                    const firstVideoTimeReference = firstVideoRepresentation.index.getFirstPosition();
                    const lastVideoTimeReference = firstVideoRepresentation.index.getLastPosition();
                    if (firstVideoTimeReference != null) {
                        firstTimeReferences.push(firstVideoTimeReference);
                    }
                    if (lastVideoTimeReference != null) {
                        lastTimeReferences.push(lastVideoTimeReference);
                    }
                }
            }
            if (firstAudioAdaptation !== undefined) {
                const firstAudioRepresentation = firstAudioAdaptation.representations[0];
                if (firstAudioRepresentation !== undefined) {
                    const firstAudioTimeReference = firstAudioRepresentation.index.getFirstPosition();
                    const lastAudioTimeReference = firstAudioRepresentation.index.getLastPosition();
                    if (firstAudioTimeReference != null) {
                        firstTimeReferences.push(firstAudioTimeReference);
                    }
                    if (lastAudioTimeReference != null) {
                        lastTimeReferences.push(lastAudioTimeReference);
                    }
                }
            }
            if (firstTimeReferences.length > 0) {
                firstTimeReference = Math.max(...firstTimeReferences);
            }
            if (lastTimeReferences.length > 0) {
                lastTimeReference = Math.min(...lastTimeReferences);
            }
        }
        const manifestDuration = root.getAttribute("Duration");
        const duration = (manifestDuration != null && +manifestDuration !== 0) ?
            (+manifestDuration / timescale) : undefined;
        if (isLive) {
            suggestedPresentationDelay = parserOptions.suggestedPresentationDelay;
            availabilityStartTime = referenceDateTime;
            minimumTime = firstTimeReference !== null && firstTimeReference !== void 0 ? firstTimeReference : availabilityStartTime;
            const maximumTime = lastTimeReference != null ?
                lastTimeReference :
                (Date.now() / 1000 - availabilityStartTime);
            maximumTimeData = { isLinear: true,
                value: maximumTime,
                time: performance.now() };
            timeshiftDepth = timeShiftBufferDepth !== null && timeShiftBufferDepth !== void 0 ? timeShiftBufferDepth : null;
        }
        else {
            minimumTime = firstTimeReference !== null && firstTimeReference !== void 0 ? firstTimeReference : 0;
            const maximumTime = lastTimeReference !== undefined ? lastTimeReference :
                duration !== undefined ? minimumTime + duration :
                    Infinity;
            maximumTimeData = { isLinear: false,
                value: maximumTime,
                time: performance.now() };
        }
        const periodStart = isLive ? 0 :
            minimumTime;
        const periodEnd = isLive ? undefined :
            maximumTimeData.value;
        const manifest = {
            availabilityStartTime: availabilityStartTime === undefined ?
                0 :
                availabilityStartTime,
            clockOffset: serverTimeOffset,
            isLive,
            isDynamic: isLive,
            timeBounds: { absoluteMinimumTime: minimumTime,
                timeshiftDepth,
                maximumTimeData },
            periods: [{ adaptations,
                    duration: periodEnd !== undefined ?
                        periodEnd - periodStart : duration,
                    end: periodEnd,
                    id: "gen-smooth-period-0",
                    start: periodStart }],
            suggestedPresentationDelay,
            transportType: "smooth",
            uris: url == null ? [] : [url],
        };
        checkManifestIDs(manifest);
        return manifest;
    }
    return parseFromDocument;
}
/**
 * @param {string} systemId - Hex string representing the CDM, 16 bytes.
 * @param {Uint8Array|undefined} privateData - Data associated to protection
 * specific system.
 * @returns {Uint8Array}
 */
function createPSSHBox(systemId, privateData) {
    if (systemId.length !== 32) {
        throw new Error("HSS: wrong system id length");
    }
    const version = 0;
    return createBox("pssh", (0,byte_parsing/* concat */.zo)([version, 0, 0, 0], (0,string_parsing/* hexToBytes */.nr)(systemId), 
    /** To put there KIDs if it exists (necessitate PSSH v1) */
    (0,byte_parsing/* itobe4 */.kh)(privateData.length), privateData));
}
/* harmony default export */ const create_parser = (createSmoothStreamingParser);

;// CONCATENATED MODULE: ./src/parsers/manifest/smooth/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ const smooth = (create_parser);


// EXTERNAL MODULE: ./src/utils/request/index.ts + 1 modules
var request = __webpack_require__(99703);
// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(73973);
// EXTERNAL MODULE: ./src/transports/utils/check_isobmff_integrity.ts
var check_isobmff_integrity = __webpack_require__(47795);
// EXTERNAL MODULE: ./src/transports/utils/return_parsed_manifest.ts
var return_parsed_manifest = __webpack_require__(97275);
// EXTERNAL MODULE: ./src/transports/utils/text_manifest_loader.ts
var text_manifest_loader = __webpack_require__(75691);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/utils.ts
var utils = __webpack_require__(14959);
// EXTERNAL MODULE: ./src/parsers/containers/isobmff/get_box.ts
var get_box = __webpack_require__(65489);
;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/parse_tfrf.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Uint8Array} traf
 * @returns {Array.<Object>}
 */
function parseTfrf(traf) {
    const tfrf = (0,get_box/* getUuidContent */.nR)(traf, 0xD4807EF2, 0xCA394695, 0x8E5426CB, 0x9E46A79F);
    if (tfrf === undefined) {
        return [];
    }
    const frags = [];
    const version = tfrf[0];
    const fragCount = tfrf[4];
    for (let i = 0; i < fragCount; i++) {
        let duration;
        let time;
        if (version === 1) {
            time = (0,byte_parsing/* be8toi */.pV)(tfrf, i * 16 + 5);
            duration = (0,byte_parsing/* be8toi */.pV)(tfrf, i * 16 + 5 + 8);
        }
        else {
            time = (0,byte_parsing/* be4toi */.pX)(tfrf, i * 8 + 5);
            duration = (0,byte_parsing/* be4toi */.pX)(tfrf, i * 8 + 5 + 4);
        }
        frags.push({
            time,
            duration,
        });
    }
    return frags;
}

;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/parse_tfxd.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {Uint8Array} traf
 * @returns {Object|undefined}
 */
function parseTfxd(traf) {
    const tfxd = (0,get_box/* getUuidContent */.nR)(traf, 0x6D1D9B05, 0x42D544E6, 0x80E2141D, 0xAFF757B2);
    if (tfxd === undefined) {
        return undefined;
    }
    return {
        duration: (0,byte_parsing/* be8toi */.pV)(tfxd, 12),
        time: (0,byte_parsing/* be8toi */.pV)(tfxd, 4),
    };
}

;// CONCATENATED MODULE: ./src/transports/smooth/extract_timings_infos.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Try to obtain time information from the given data.
 * @param {Uint8Array} data
 * @param {boolean} isChunked
 * @param {Object} segment
 * @param {boolean} isLive
 * @returns {Object}
 */
function extractTimingsInfos(data, isChunked, initTimescale, segment, isLive) {
    var _a;
    const nextSegments = [];
    let chunkInfos;
    let tfxdSegment;
    let tfrfSegments;
    if (isLive) {
        const traf = (0,read/* getTRAF */.XA)(data);
        if (traf !== null) {
            tfrfSegments = parseTfrf(traf);
            tfxdSegment = parseTfxd(traf);
        }
        else {
            log/* default.warn */.Z.warn("smooth: could not find traf atom");
        }
    }
    if (tfrfSegments !== undefined) {
        for (let i = 0; i < tfrfSegments.length; i++) {
            nextSegments.push({ time: tfrfSegments[i].time,
                duration: tfrfSegments[i].duration,
                timescale: initTimescale });
        }
    }
    if (tfxdSegment !== undefined) {
        chunkInfos = { time: tfxdSegment.time / initTimescale,
            duration: tfxdSegment.duration / initTimescale };
        return { nextSegments,
            chunkInfos,
            scaledSegmentTime: tfxdSegment.time };
    }
    if (isChunked) {
        return { nextSegments,
            chunkInfos: null,
            scaledSegmentTime: undefined };
    }
    const segmentDuration = segment.duration * initTimescale;
    // we could always make a mistake when reading a container.
    // If the estimate is too far from what the segment seems to imply, take
    // the segment infos instead.
    const maxDecodeTimeDelta = Math.min(initTimescale * 0.9, segmentDuration / 4);
    const trunDuration = (0,utils/* getDurationFromTrun */.MM)(data);
    const scaledSegmentTime = ((_a = segment.privateInfos) === null || _a === void 0 ? void 0 : _a.smoothMediaSegment) !== undefined ?
        segment.privateInfos.smoothMediaSegment.time :
        Math.round(segment.time * initTimescale);
    if (trunDuration !== undefined &&
        Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta) {
        chunkInfos = { time: segment.time,
            duration: trunDuration / initTimescale };
    }
    else {
        chunkInfos = { time: segment.time,
            duration: segment.duration };
    }
    return { nextSegments, chunkInfos, scaledSegmentTime };
}

// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(8886);
;// CONCATENATED MODULE: ./src/compat/can_patch_isobmff.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * TODO(pierre): fix patchSegmentInPlace to work with IE11. Maybe
 * try to put free atom inside traf children
 *
 * Returns true if the current target is tolerant enough for us to
 * simply be able to "patch" an ISOBMFF segment or if we have to create a
 * new one from scratch instead.
 * @returns {Boolean}
 */
function canPatchISOBMFFSegment() {
    return !browser_detection/* isIEOrEdge */.YM;
}

;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_boxes.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encDepth
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @returns {Uint8Array}
 */
function createAVC1Box(width, height, hRes, vRes, encName, colorDepth, avcc) {
    return createBox("avc1", (0,byte_parsing/* concat */.zo)(6, // 6 bytes reserved
    (0,byte_parsing/* itobe2 */.XT)(1), 16, // drefIdx + QuickTime reserved, zeroes
    (0,byte_parsing/* itobe2 */.XT)(width), // size 2 w
    (0,byte_parsing/* itobe2 */.XT)(height), // size 2 h
    (0,byte_parsing/* itobe2 */.XT)(hRes), 2, // reso 4 h
    (0,byte_parsing/* itobe2 */.XT)(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes
    [0, 1, encName.length], // frame count (default 1)
    (0,string_parsing/* strToUtf8 */.tG)(encName), // 1byte len + encoder name str
    (31 - encName.length), // + padding
    (0,byte_parsing/* itobe2 */.XT)(colorDepth), // color depth
    [0xFF, 0xFF], // reserved ones
    avcc // avcc atom,
    ));
}
/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes - horizontal resolution, eg 72
 * @param {Number} vRes - vertical resolution, eg 72
 * @param {string} encDepth
 * @param {Number} colorDepth - eg 24
 * @param {Uint8Array} avcc - Uint8Array representing the avcC atom
 * @param {Uint8Array} sinf - Uint8Array representing the sinf atom
 * @returns {Uint8Array}
 */
function createENCVBox(width, height, hRes, vRes, encName, colorDepth, avcc, sinf) {
    return createBox("encv", (0,byte_parsing/* concat */.zo)(6, // 6 bytes reserved
    (0,byte_parsing/* itobe2 */.XT)(1), 16, // drefIdx + QuickTime reserved, zeroes
    (0,byte_parsing/* itobe2 */.XT)(width), // size 2 w
    (0,byte_parsing/* itobe2 */.XT)(height), // size 2 h
    (0,byte_parsing/* itobe2 */.XT)(hRes), 2, // reso 4 h
    (0,byte_parsing/* itobe2 */.XT)(vRes), 2 + 4, // reso 4 v + QuickTime reserved, zeroes
    [0, 1, encName.length], // frame count (default 1)
    (0,string_parsing/* strToUtf8 */.tG)(encName), // 1byte len + encoder name str
    (31 - encName.length), // + padding
    (0,byte_parsing/* itobe2 */.XT)(colorDepth), // color depth
    [0xFF, 0xFF], // reserved ones
    avcc, // avcc atom,
    sinf));
}
/**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */
function createMP4ABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds) {
    return createBox("mp4a", (0,byte_parsing/* concat */.zo)(6, (0,byte_parsing/* itobe2 */.XT)(drefIdx), 8, (0,byte_parsing/* itobe2 */.XT)(channelsCount), (0,byte_parsing/* itobe2 */.XT)(sampleSize), 2, (0,byte_parsing/* itobe2 */.XT)(packetSize), (0,byte_parsing/* itobe2 */.XT)(sampleRate), 2, esds));
}
/**
 * @param {Number} drefIdx
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {Uint8Array} esds - Uint8Array representing the esds atom
 * @param {Uint8Array} [sinf] - Uint8Array representing the sinf atom,
 * only if name == "enca"
 * @returns {Uint8Array}
 */
function createENCABox(drefIdx, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf) {
    return createBox("enca", (0,byte_parsing/* concat */.zo)(6, (0,byte_parsing/* itobe2 */.XT)(drefIdx), 8, (0,byte_parsing/* itobe2 */.XT)(channelsCount), (0,byte_parsing/* itobe2 */.XT)(sampleSize), 2, (0,byte_parsing/* itobe2 */.XT)(packetSize), (0,byte_parsing/* itobe2 */.XT)(sampleRate), 2, esds, sinf));
}
/**
 * @param {url} Uint8Array
 * @returns {Uint8Array}
 */
function createDREFBox(url) {
    // only one description here... FIXME
    return createBox("dref", (0,byte_parsing/* concat */.zo)(7, [1], url));
}
/**
 * @param {string} majorBrand
 * @param {Array.<string>} brands
 * @returns {Uint8Array}
 */
function createFTYPBox(majorBrand, brands) {
    const content = (0,byte_parsing/* concat */.zo)(...[(0,string_parsing/* strToUtf8 */.tG)(majorBrand),
        [0, 0, 0, 1]].concat(brands.map(string_parsing/* strToUtf8 */.tG)));
    return createBox("ftyp", content);
}
/**
 * @param {string} schemeType - four letters (eg "cenc" for Common Encryption)
 * @param {Number} schemeVersion - eg 65536
 * @returns {Uint8Array}
 */
function createSCHMBox(schemeType, schemeVersion) {
    return createBox("schm", (0,byte_parsing/* concat */.zo)(4, (0,string_parsing/* strToUtf8 */.tG)(schemeType), (0,byte_parsing/* itobe4 */.kh)(schemeVersion)));
}
/**
 * Create tfdt box from a decoding time.
 * @param {number} decodeTime
 * @returns {Uint8Array}
 */
function createTfdtBox(decodeTime) {
    return createBox("tfdt", (0,byte_parsing/* concat */.zo)([1, 0, 0, 0], (0,byte_parsing/* itobe8 */.el)(decodeTime)));
}
/**
 * @returns {Uint8Array}
 */
function createVMHDBox() {
    const arr = new Uint8Array(12);
    arr[3] = 1; // QuickTime...
    return createBox("vmhd", arr);
}
/**
 * @param {Number} trackId
 * @returns {Uint8Array}
 */
function createTREXBox(trackId) {
    // default sample desc idx = 1
    return createBox("trex", (0,byte_parsing/* concat */.zo)(4, (0,byte_parsing/* itobe4 */.kh)(trackId), [0, 0, 0, 1], 12));
}
/**
 * @param {Number} length
 * @returns {Uint8Array}
 */
function createFreeBox(length) {
    return createBox("free", new Uint8Array(length - 8));
}
/**
 * @param {Number} stream
 * @param {string} codecPrivateData - hex string
 * @returns {Uint8Array}
 */
function createESDSBox(stream, codecPrivateData) {
    return createBox("esds", (0,byte_parsing/* concat */.zo)(4, [0x03, 0x19], (0,byte_parsing/* itobe2 */.XT)(stream), [0x00, 0x04, 0x11, 0x40, 0x15], 11, [0x05, 0x02], (0,string_parsing/* hexToBytes */.nr)(codecPrivateData), [0x06, 0x01, 0x02]));
}
/**
 * @param {string} dataFormat - four letters (eg "avc1")
 * @returns {Uint8Array}
 */
function createFRMABox(dataFormat) {
    return createBox("frma", (0,string_parsing/* strToUtf8 */.tG)(dataFormat));
}
/**
 * @param {Uint8Array} sps
 * @param {Uint8Array} pps
 * @param {Number} nalLen - NAL Unit length: 1, 2 or 4 bytes
 * eg: avcc(0x4d, 0x40, 0x0d, 4, 0xe1, "674d400d96560c0efcb80a70505050a0",
 * 1, "68ef3880")
 * @returns {Uint8Array}
 */
function createAVCCBox(sps, pps, nalLen) {
    const nal = (nalLen === 2) ? 0x1 :
        (nalLen === 4) ? 0x3 :
            0x0;
    // Deduce AVC Profile from SPS
    const h264Profile = sps[1];
    const h264CompatibleProfile = sps[2];
    const h264Level = sps[3];
    return createBox("avcC", (0,byte_parsing/* concat */.zo)([
        1,
        h264Profile,
        h264CompatibleProfile,
        h264Level,
        (0x3F << 2 | nal),
        (0xE0 | 1),
    ], (0,byte_parsing/* itobe2 */.XT)(sps.length), sps, [1], (0,byte_parsing/* itobe2 */.XT)(pps.length), pps));
}
/**
 * @param {string} type - "video"/"audio"/"hint"
 * @returns {Uint8Array}
 */
function createHDLRBox(type) {
    let name;
    let handlerName;
    switch (type) {
        case "video":
            name = "vide";
            handlerName = "VideoHandler";
            break;
        case "audio":
            name = "soun";
            handlerName = "SoundHandler";
            break;
        default:
            name = "hint";
            handlerName = "";
            break;
    }
    return createBox("hdlr", (0,byte_parsing/* concat */.zo)(8, (0,string_parsing/* strToUtf8 */.tG)(name), 12, (0,string_parsing/* strToUtf8 */.tG)(handlerName), 1 // handler name is C-style string (0 terminated)
    ));
}
/**
 * @param {number} timescale
 * @returns {Uint8Array}
 */
function createMDHDBox(timescale) {
    return createBox("mdhd", (0,byte_parsing/* concat */.zo)(12, (0,byte_parsing/* itobe4 */.kh)(timescale), 8));
}
/**
 * @param {Number} timescale
 * @param {Number} trackId
 * @returns {Uint8Array}
 */
function createMVHDBox(timescale, trackId) {
    return createBox("mvhd", (0,byte_parsing/* concat */.zo)(12, (0,byte_parsing/* itobe4 */.kh)(timescale), 4, [0, 1], 2, // we assume rate = 1;
    [1, 0], 10, // we assume volume = 100%;
    [0, 1], 14, // default matrix
    [0, 1], 14, // default matrix
    [64, 0, 0, 0], 26, (0,byte_parsing/* itobe2 */.XT)(trackId + 1) // next trackId (=trackId + 1);
    ));
}
/**
 * @param {Uint8Array} mfhd
 * @param {Uint8Array} tfhd
 * @param {Uint8Array} tfdt
 * @param {Uint8Array} trun
 * @returns {Uint8Array}
 */
function createSAIOBox(mfhd, tfhd, tfdt, trun) {
    return createBox("saio", (0,byte_parsing/* concat */.zo)(4, [0, 0, 0, 1], // ??
    (0,byte_parsing/* itobe4 */.kh)(mfhd.length +
        tfhd.length +
        tfdt.length +
        trun.length +
        8 + 8 + 8 + 8)));
}
/**
 * @param {Uint8Array} sencContent - including 8 bytes flags and entries count
 * @returns {Uint8Array}
 */
function createSAIZBox(sencContent) {
    if (sencContent.length === 0) {
        return createBox("saiz", new Uint8Array(0));
    }
    const flags = (0,byte_parsing/* be4toi */.pX)(sencContent, 0);
    const entries = (0,byte_parsing/* be4toi */.pX)(sencContent, 4);
    const arr = new Uint8Array(entries + 9);
    arr.set((0,byte_parsing/* itobe4 */.kh)(entries), 5);
    let i = 9;
    let j = 8;
    let pairsCnt;
    let pairsLen;
    while (j < sencContent.length) {
        j += 8; // assuming IV is 8 bytes TODO handle 16 bytes IV
        // if we have extradata for each entry
        if ((flags & 0x2) === 0x2) {
            pairsLen = 2;
            pairsCnt = (0,byte_parsing/* be2toi */.zK)(sencContent, j);
            j += (pairsCnt * 6) + 2;
        }
        else {
            pairsCnt = 0;
            pairsLen = 0;
        }
        arr[i] = pairsCnt * 6 + 8 + pairsLen;
        i++;
    }
    return createBox("saiz", arr);
}
/**
 * @returns {Uint8Array}
 */
function createSMHDBox() {
    return createBox("smhd", new Uint8Array(8));
}
/**
 * @param {Array.<Uint8Array>} representations - arrays of Uint8Array,
 * typically [avc1] or [encv, avc1]
 * @returns {Uint8Array}
 */
function createSTSDBox(reps) {
    // only one description here... FIXME
    const arrBase = [7, [reps.length]];
    return createBox("stsd", (0,byte_parsing/* concat */.zo)(...arrBase.concat(reps)));
}
/**
 * @param {Number} width
 * @param {Number} height
 * @param {Number} trackId
 * @returns {Uint8Array}
 */
function createTKHDBox(width, height, trackId) {
    return createBox("tkhd", (0,byte_parsing/* concat */.zo)((0,byte_parsing/* itobe4 */.kh)(1 + 2 + 4), 8, // we assume track is enabled,
    // in media and in preview.
    (0,byte_parsing/* itobe4 */.kh)(trackId), 20, // we assume trackId = 1;
    [1, 0, 0, 0], // we assume volume = 100%;
    [0, 1, 0, 0], 12, // default matrix
    [0, 1, 0, 0], 12, // default matrix
    [64, 0, 0, 0], // ??
    (0,byte_parsing/* itobe2 */.XT)(width), 2, // width (TODO handle fixed)
    (0,byte_parsing/* itobe2 */.XT)(height), 2 // height (TODO handle fixed)
    ));
}
/**
 * @param {Number} algId - eg 1
 * @param {Number} ivSize - eg 8
 * @param {string} keyId - Hex KID 93789920e8d6520098577df8f2dd5546
 * @returns {Uint8Array}
 */
function createTENCBox(algId, ivSize, keyId) {
    return createBox("tenc", (0,byte_parsing/* concat */.zo)(6, [algId, ivSize], keyId));
}


;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_traf_box.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


function createTrafBox(tfhd, tfdt, trun, mfhd, senc) {
    const trafs = [tfhd, tfdt, trun];
    if (senc !== undefined) {
        trafs.push(createBox("senc", senc), createSAIZBox(senc), createSAIOBox(mfhd, tfhd, tfdt, trun));
    }
    return createBoxWithChildren("traf", trafs);
}

;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/patch_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Update ISOBMFF Segment downloaded in Smooth Streaming so it is playable on
 * the browser.
 * @param {Uint8Array} segment
 * @param {Number} decodeTime
 * @return {Uint8Array}
 */
function patchSegment(segment, decodeTime) {
    const oldMoofOffsets = (0,get_box/* getBoxOffsets */.Qy)(segment, 0x6D6F6F66 /* moof */);
    if (oldMoofOffsets === null) {
        throw new Error("Smooth: Invalid ISOBMFF given");
    }
    const oldMoofContent = segment.subarray(oldMoofOffsets[1], oldMoofOffsets[2]);
    const mfhdBox = (0,get_box/* getBox */.iz)(oldMoofContent, 0x6D666864 /* mfhd */);
    const trafContent = (0,get_box/* getBoxContent */.t_)(oldMoofContent, 0x74726166 /* traf */);
    if (trafContent === null || mfhdBox === null) {
        throw new Error("Smooth: Invalid ISOBMFF given");
    }
    const tfhdOffsets = (0,get_box/* getBoxOffsets */.Qy)(trafContent, 0x74666864 /* tfhd */);
    const oldTrunOffsets = (0,get_box/* getBoxOffsets */.Qy)(trafContent, 0x7472756E /* trun */);
    if (tfhdOffsets === null || oldTrunOffsets === null) {
        throw new Error("Smooth: Invalid ISOBMFF given");
    }
    const tfhdBox = trafContent.subarray(tfhdOffsets[0], tfhdOffsets[2]);
    const oldTrunBox = trafContent.subarray(oldTrunOffsets[0], oldTrunOffsets[2]);
    // force trackId=1 since trackIds are not always reliable...
    tfhdBox.set([0, 0, 0, 1], tfhdOffsets[1] - tfhdOffsets[0] + 4 /* version + flags */);
    const tfdtBox = createTfdtBox(decodeTime);
    const newTrunBox = updateTrunDataOffset(oldTrunBox, oldTrunOffsets[1] - oldTrunOffsets[0]);
    const sencContent = (0,get_box/* getUuidContent */.nR)(trafContent, 0xA2394F52, 0x5A9B4F14, 0xA2446C42, 0x7C648DF4);
    const newTrafBox = createTrafBox(tfhdBox, tfdtBox, newTrunBox, mfhdBox, sencContent);
    const newMoof = createBoxWithChildren("moof", [mfhdBox, newTrafBox]);
    const newMoofOffsets = (0,get_box/* getBoxOffsets */.Qy)(newMoof, 0x6D6F6F66 /* moof */);
    const newTrafOffsets = (0,get_box/* getBoxOffsets */.Qy)(newTrafBox, 0x74726166 /* traf */);
    const newTrunOffsets = (0,get_box/* getBoxOffsets */.Qy)(newTrunBox, 0x7472756E /* trun */);
    if (newMoofOffsets === null || newTrafOffsets === null || newTrunOffsets === null) {
        throw new Error("Smooth: Invalid moof, trun or traf generation");
    }
    /** index of the `data_offset` property from the trun box in the whole "moof". */
    const indexOfTrunDataOffsetInMoof = (newMoofOffsets[1] - newMoofOffsets[0]) +
        mfhdBox.length +
        /* new traf size + name */
        (newTrafOffsets[1] - newTrafOffsets[0]) +
        tfhdBox.length +
        tfdtBox.length +
        /* new trun size + name */
        (newTrunOffsets[1] - newTrunOffsets[0]) +
        8 /* trun version + flags + `sample_count` */;
    const oldMoofLength = oldMoofOffsets[2] - oldMoofOffsets[0];
    const newMoofSizeDiff = newMoof.length - oldMoofLength;
    const oldMdatOffset = (0,get_box/* getBoxOffsets */.Qy)(segment, 0x6D646174 /* "mdat" */);
    if (oldMdatOffset === null) {
        throw new Error("Smooth: Invalid ISOBMFF given");
    }
    if (canPatchISOBMFFSegment() && (newMoofSizeDiff === 0 || newMoofSizeDiff <= -8)) {
        // patch trun data_offset
        const mdatContentOffset = oldMdatOffset[1];
        newMoof.set((0,byte_parsing/* itobe4 */.kh)(mdatContentOffset), indexOfTrunDataOffsetInMoof);
        segment.set(newMoof, oldMoofOffsets[0]);
        // add "free" box for the remaining space
        if (newMoofSizeDiff <= -8) {
            segment.set(createFreeBox(-newMoofSizeDiff), newMoof.length);
        }
        return segment;
    }
    else {
        // patch trun data_offset
        const mdatContentOffset = oldMdatOffset[1] + newMoofSizeDiff;
        newMoof.set((0,byte_parsing/* itobe4 */.kh)(mdatContentOffset), indexOfTrunDataOffsetInMoof);
        const newSegment = new Uint8Array(segment.length + newMoofSizeDiff);
        const beforeMoof = segment.subarray(0, oldMoofOffsets[0]);
        const afterMoof = segment.subarray(oldMoofOffsets[2], segment.length);
        newSegment.set(beforeMoof, 0);
        newSegment.set(newMoof, beforeMoof.length);
        newSegment.set(afterMoof, beforeMoof.length + newMoof.length);
        return newSegment;
    }
}
/**
 * Update `trun` box given or create a new one from it to add a data offset
 * flag and the corresponding space to set a data offset.
 * Do not do anything if the flag is already set.
 *
 * Note that the `oldTrunBox` given should not be mutated by this function but
 * the returned value CAN point to the exact same `Uint8Array`.
 *
 * @param {Uint8Array} oldTrunBox - The whole original trun box
 * @param {number} initialDataOffset - Offset at which the first value of the
 * "trun" box (the "version") is set.
 * @returns {Uint8Array}
 */
function updateTrunDataOffset(oldTrunBox, initialDataOffset) {
    const trunHasDataOffset = (oldTrunBox[initialDataOffset + 3 /* last flag */] & 0x01) > 0;
    if (trunHasDataOffset) {
        return oldTrunBox;
    }
    // If no data_offset is present, we create another "trun" with one
    const newTrunBox = new Uint8Array(oldTrunBox.length + 4);
    // copy size + name + version=1 + flags=3 + sample_count=4
    newTrunBox.set(oldTrunBox.subarray(0, initialDataOffset + 8), 0);
    // add data_offset flag
    newTrunBox[initialDataOffset + 3] = newTrunBox[initialDataOffset + 3] | 0x01;
    newTrunBox.set([0, 0, 0, 0], initialDataOffset + 8); // add data offset
    // add the rest
    newTrunBox.set(oldTrunBox.subarray(initialDataOffset + 8, oldTrunBox.length), initialDataOffset + 12);
    return (0,utils/* updateBoxLength */.J6)(newTrunBox); // update the trun box's length
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(30365);
// EXTERNAL MODULE: ./src/transports/utils/byte_range.ts
var byte_range = __webpack_require__(25602);
;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @param {Uint8Array} mvhd
 * @param {Uint8Array} mvex
 * @param {Uint8Array} trak
 * @returns {Array.<Uint8Array>}
 */
function createMOOVBox(mvhd, mvex, trak) {
    const children = [mvhd, mvex, trak];
    return createBoxWithChildren("moov", children);
}
/**
 * Create an initialization segment with the information given.
 * @param {Number} timescale
 * @param {string} type
 * @param {Uint8Array} stsd
 * @param {Uint8Array} mhd
 * @param {Number} width
 * @param {Number} height
 * @param {Array.<Object>} pssList - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */
function createInitSegment(timescale, type, stsd, mhd, width, height) {
    const stbl = createBoxWithChildren("stbl", [
        stsd,
        createBox("stts", new Uint8Array(0x08)),
        createBox("stsc", new Uint8Array(0x08)),
        createBox("stsz", new Uint8Array(0x0C)),
        createBox("stco", new Uint8Array(0x08)),
    ]);
    const url = createBox("url ", new Uint8Array([0, 0, 0, 1]));
    const dref = createDREFBox(url);
    const dinf = createBoxWithChildren("dinf", [dref]);
    const minf = createBoxWithChildren("minf", [mhd, dinf, stbl]);
    const hdlr = createHDLRBox(type);
    const mdhd = createMDHDBox(timescale); // this one is really important
    const mdia = createBoxWithChildren("mdia", [mdhd, hdlr, minf]);
    const tkhd = createTKHDBox(width, height, 1);
    const trak = createBoxWithChildren("trak", [tkhd, mdia]);
    const trex = createTREXBox(1);
    const mvex = createBoxWithChildren("mvex", [trex]);
    const mvhd = createMVHDBox(timescale, 1); // in fact, we don't give a sh** about
    // this value :O
    const moov = createMOOVBox(mvhd, mvex, trak);
    const ftyp = createFTYPBox("isom", ["isom", "iso2", "iso6", "avc1", "dash"]);
    return (0,byte_parsing/* concat */.zo)(ftyp, moov);
}

;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_video_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Return full video Init segment as Uint8Array
 * @param {Number} timescale - lowest number, this one will be set into mdhd
 * *10000 in mvhd, e.g. 1000
 * @param {Number} width
 * @param {Number} height
 * @param {Number} hRes
 * @param {Number} vRes
 * @param {Number} nalLength (1, 2 or 4)
 * @param {string} codecPrivateData
 * @param {Uint8Array} keyId - hex string representing the key Id,
 * 32 chars. eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList] - List of dict, example:
 * {systemId: "DEADBEEF", codecPrivateData: "DEAFBEEF}
 * @returns {Uint8Array}
 */
function createVideoInitSegment(timescale, width, height, hRes, vRes, nalLength, codecPrivateData, keyId) {
    const [, spsHex, ppsHex] = codecPrivateData.split("00000001");
    if (spsHex === undefined || ppsHex === undefined) {
        throw new Error("Smooth: unsupported codec private data.");
    }
    const sps = (0,string_parsing/* hexToBytes */.nr)(spsHex);
    const pps = (0,string_parsing/* hexToBytes */.nr)(ppsHex);
    // TODO NAL length is forced to 4
    const avcc = createAVCCBox(sps, pps, nalLength);
    let stsd;
    if (keyId === undefined) {
        const avc1 = createAVC1Box(width, height, hRes, vRes, "AVC Coding", 24, avcc);
        stsd = createSTSDBox([avc1]);
    }
    else {
        const tenc = createTENCBox(1, 8, keyId);
        const schi = createBoxWithChildren("schi", [tenc]);
        const schm = createSCHMBox("cenc", 65536);
        const frma = createFRMABox("avc1");
        const sinf = createBoxWithChildren("sinf", [frma, schm, schi]);
        const encv = createENCVBox(width, height, hRes, vRes, "AVC Coding", 24, avcc, sinf);
        stsd = createSTSDBox([encv]);
    }
    return createInitSegment(timescale, "video", stsd, createVMHDBox(), width, height);
}

;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/get_aaces_header.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Sampling frequencies defined in MPEG-4 Audio.
 * @type {Array.<Number>}
 */
const SAMPLING_FREQUENCIES = [
    96000,
    88200,
    64000,
    48000,
    44100,
    32000,
    24000,
    22050,
    16000,
    12000,
    11025,
    8000,
    7350,
];
/**
 * Return AAC ES Header (hexstr form)
 *
 * @param {Number} type
 *          1 = AAC Main
 *          2 = AAC LC
 *          cf http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio
 * @param {Number} frequency
 * @param {Number} chans (1 or 2)
 * @returns {string}
 */
function getAacesHeader(type, frequency, chans) {
    const freq = SAMPLING_FREQUENCIES.indexOf(frequency); // TODO : handle Idx = 15...
    let val;
    val = (type & 0x3F) << 0x4;
    val = (val | (freq & 0x1F)) << 0x4;
    val = (val | (chans & 0x1F)) << 0x3;
    return (0,string_parsing/* bytesToHex */.ci)((0,byte_parsing/* itobe2 */.XT)(val));
}

;// CONCATENATED MODULE: ./src/transports/smooth/isobmff/create_audio_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Return full audio initialization segment as Uint8Array.
 * @param {Number} timescale
 * @param {Number} channelsCount
 * @param {Number} sampleSize
 * @param {Number} packetSize
 * @param {Number} sampleRate
 * @param {string} codecPrivateData
 * @param {Uint8Array} keyId - hex string representing the key Id, 32 chars.
 * eg. a800dbed49c12c4cb8e0b25643844b9b
 * @param {Array.<Object>} [pssList]
 * @returns {Uint8Array}
 */
function createAudioInitSegment(timescale, channelsCount, sampleSize, packetSize, sampleRate, codecPrivateData, keyId) {
    const _codecPrivateData = codecPrivateData.length === 0 ?
        getAacesHeader(2, sampleRate, channelsCount) :
        codecPrivateData;
    const esds = createESDSBox(1, _codecPrivateData);
    const stsd = (() => {
        if (keyId === undefined) {
            const mp4a = createMP4ABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds);
            return createSTSDBox([mp4a]);
        }
        const tenc = createTENCBox(1, 8, keyId);
        const schi = createBoxWithChildren("schi", [tenc]);
        const schm = createSCHMBox("cenc", 65536);
        const frma = createFRMABox("mp4a");
        const sinf = createBoxWithChildren("sinf", [frma, schm, schi]);
        const enca = createENCABox(1, channelsCount, sampleSize, packetSize, sampleRate, esds, sinf);
        return createSTSDBox([enca]);
    })();
    return createInitSegment(timescale, "audio", stsd, createSMHDBox(), 0, 0);
}

;// CONCATENATED MODULE: ./src/transports/smooth/segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Segment loader triggered if there was no custom-defined one in the API.
 * @param {Object} opt
 * @returns {Observable}
 */
function regularSegmentLoader({ url, segment }) {
    let headers;
    const range = segment.range;
    if (Array.isArray(range)) {
        headers = { Range: (0,byte_range/* default */.Z)(range) };
    }
    return (0,request/* default */.ZP)({ url,
        responseType: "arraybuffer",
        headers,
        sendProgressEvents: true });
}
/**
 * Defines the url for the request, load the right loader (custom/default
 * one).
 */
const generateSegmentLoader = (customSegmentLoader) => ({ segment, representation, adaptation, period, manifest, url, }) => {
    if (segment.isInit) {
        if (segment.privateInfos === undefined ||
            segment.privateInfos.smoothInitSegment === undefined) {
            throw new Error("Smooth: Invalid segment format");
        }
        const smoothInitPrivateInfos = segment.privateInfos.smoothInitSegment;
        let responseData;
        const { codecPrivateData, timescale, protection = { keyId: undefined,
            keySystems: undefined } } = smoothInitPrivateInfos;
        if (codecPrivateData === undefined) {
            throw new Error("Smooth: no codec private data.");
        }
        switch (adaptation.type) {
            case "video": {
                const { width = 0, height = 0 } = representation;
                responseData = createVideoInitSegment(timescale, width, height, 72, 72, 4, // vRes, hRes, nal
                codecPrivateData, protection.keyId);
                break;
            }
            case "audio": {
                const { channels = 0, bitsPerSample = 0, packetSize = 0, samplingRate = 0 } = smoothInitPrivateInfos;
                responseData = createAudioInitSegment(timescale, channels, bitsPerSample, packetSize, samplingRate, codecPrivateData, protection.keyId);
                break;
            }
            default:
                if (true) {
                    (0,assert/* default */.Z)(false, "responseData should have been set");
                }
                responseData = new Uint8Array(0);
        }
        return (0,of.of)({ type: "data-created", value: { responseData } });
    }
    else if (url === null) {
        return (0,of.of)({ type: "data-created", value: { responseData: null } });
    }
    else {
        const args = { adaptation,
            manifest,
            period,
            representation,
            segment,
            transport: "smooth",
            url };
        if (typeof customSegmentLoader !== "function") {
            return regularSegmentLoader(args);
        }
        return new Observable/* Observable */.y((obs) => {
            let hasFinished = false;
            let hasFallbacked = false;
            /**
             * Callback triggered when the custom segment loader has a response.
             * @param {Object} args
             */
            const resolve = (_args) => {
                if (!hasFallbacked) {
                    hasFinished = true;
                    obs.next({ type: "data-loaded",
                        value: { responseData: _args.data,
                            size: _args.size,
                            duration: _args.duration } });
                    obs.complete();
                }
            };
            /**
             * Callback triggered when the custom segment loader fails
             * @param {*} err - The corresponding error encountered
             */
            const reject = (err = {}) => {
                if (!hasFallbacked) {
                    hasFinished = true;
                    obs.error(err);
                }
            };
            const progress = (_args) => {
                if (!hasFallbacked) {
                    obs.next({ type: "progress", value: { duration: _args.duration,
                            size: _args.size,
                            totalSize: _args.totalSize } });
                }
            };
            const fallback = () => {
                hasFallbacked = true;
                // HACK What is TypeScript/RxJS doing here??????
                /* eslint-disable import/no-deprecated */
                /* eslint-disable @typescript-eslint/ban-ts-comment */
                // @ts-ignore
                regularSegmentLoader(args).subscribe(obs);
                /* eslint-enable import/no-deprecated */
                /* eslint-enable @typescript-eslint/ban-ts-comment */
            };
            const callbacks = { reject, resolve, fallback, progress };
            const abort = customSegmentLoader(args, callbacks);
            return () => {
                if (!hasFinished && !hasFallbacked && typeof abort === "function") {
                    abort();
                }
            };
        });
    }
};
/* harmony default export */ const segment_loader = (generateSegmentLoader);

;// CONCATENATED MODULE: ./src/transports/smooth/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const ISM_REG = /(\.isml?)(\?token=\S+)?$/;
const TOKEN_REG = /\?token=(\S+)/;
/**
 * TODO Remove this logic completely from the player
 * @param {Document} doc
 * @returns {string|null}
 */
function extractISML(doc) {
    return doc.getElementsByTagName("media")[0].getAttribute("src");
}
/**
 * Returns string corresponding to the token contained in the url's querystring.
 * Empty string if no token is found.
 * @param {string} url
 * @returns {string}
 */
function extractToken(url) {
    const tokenMatch = TOKEN_REG.exec(url);
    if (tokenMatch !== null) {
        const match = tokenMatch[1];
        if (match !== undefined) {
            return match;
        }
    }
    return "";
}
/**
 * Replace/Remove token from the url's querystring
 * @param {string} url
 * @param {string} [token]
 * @returns {string}
 */
function replaceToken(url, token) {
    if ((0,is_non_empty_string/* default */.Z)(token)) {
        return url.replace(TOKEN_REG, "?token=" + token);
    }
    else {
        return url.replace(TOKEN_REG, "");
    }
}
/**
 * @param {string} url
 * @returns {string}
 */
function resolveManifest(url) {
    if (ISM_REG.test(url)) {
        (0,warn_once/* default */.Z)("Giving a isml URL to loadVideo is deprecated." +
            " Please give the Manifest URL directly");
        return url.replace(ISM_REG, "$1/manifest$2");
    }
    return url;
}


;// CONCATENATED MODULE: ./src/transports/smooth/pipelines.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

















const WSX_REG = /\.wsx?(\?token=\S+)?/;
/**
 * @param {Object} adaptation
 * @param {Object} dlSegment
 * @param {Object} nextSegments
 */
function addNextSegments(adaptation, nextSegments, dlSegment) {
    var _a;
    log/* default.debug */.Z.debug("Smooth Parser: update segments information.");
    const representations = adaptation.representations;
    for (let i = 0; i < representations.length; i++) {
        const representation = representations[i];
        if (representation.index instanceof SmoothRepresentationIndex &&
            ((_a = dlSegment === null || dlSegment === void 0 ? void 0 : dlSegment.privateInfos) === null || _a === void 0 ? void 0 : _a.smoothMediaSegment) !== undefined) {
            representation.index._addSegments(nextSegments, dlSegment.privateInfos.smoothMediaSegment);
        }
        else {
            log/* default.warn */.Z.warn("Smooth Parser: should only encounter SmoothRepresentationIndex");
        }
    }
}
/* harmony default export */ function pipelines(options) {
    const smoothManifestParser = smooth(options);
    const segmentLoader = segment_loader(options.segmentLoader);
    const manifestLoaderOptions = { customManifestLoader: options.manifestLoader };
    const manifestLoader = (0,text_manifest_loader/* default */.Z)(manifestLoaderOptions);
    const manifestPipeline = {
        resolver({ url }) {
            if (url === undefined) {
                return (0,of.of)({ url: undefined });
            }
            // TODO Remove WSX logic
            let resolving;
            if (WSX_REG.test(url)) {
                (0,warn_once/* default */.Z)("Giving WSX URL to loadVideo is deprecated." +
                    " You should only give Manifest URLs.");
                resolving = (0,request/* default */.ZP)({ url: replaceToken(url, ""),
                    responseType: "document" })
                    .pipe((0,map/* map */.U)(({ value }) => {
                    const extractedURL = extractISML(value.responseData);
                    if (extractedURL === null || extractedURL.length === 0) {
                        throw new Error("Invalid ISML");
                    }
                    return extractedURL;
                }));
            }
            else {
                resolving = (0,of.of)(url);
            }
            const token = extractToken(url);
            return resolving.pipe((0,map/* map */.U)((_url) => ({
                url: replaceToken(resolveManifest(_url), token),
            })));
        },
        loader: manifestLoader,
        parser({ response, url: reqURL }) {
            const url = response.url === undefined ? reqURL :
                response.url;
            const data = typeof response.responseData === "string" ?
                new DOMParser().parseFromString(response.responseData, "text/xml") :
                response.responseData; // TODO find a way to check if Document?
            const { receivedTime: manifestReceivedTime } = response;
            const parserResult = smoothManifestParser(data, url, manifestReceivedTime);
            const manifest = new src_manifest/* default */.ZP(parserResult, {
                representationFilter: options.representationFilter,
                supplementaryImageTracks: options.supplementaryImageTracks,
                supplementaryTextTracks: options.supplementaryTextTracks,
            });
            return (0,return_parsed_manifest/* default */.Z)(manifest, url);
        },
    };
    const segmentPipeline = {
        loader(content) {
            if (content.segment.isInit || options.checkMediaSegmentIntegrity !== true) {
                return segmentLoader(content);
            }
            return segmentLoader(content).pipe((0,tap/* tap */.b)(res => {
                if ((res.type === "data-loaded" || res.type === "data-chunk") &&
                    res.value.responseData !== null) {
                    (0,check_isobmff_integrity/* default */.Z)(new Uint8Array(res.value.responseData), content.segment.isInit);
                }
            }));
        },
        parser({ content, response, initTimescale, }) {
            var _a, _b;
            const { segment, adaptation, manifest } = content;
            const { data, isChunked } = response;
            if (data === null) {
                if (segment.isInit) {
                    return (0,of.of)({ type: "parsed-init-segment",
                        value: { initializationData: null,
                            protectionDataUpdate: false,
                            initTimescale: undefined } });
                }
                return (0,of.of)({ type: "parsed-segment",
                    value: { chunkData: null,
                        chunkInfos: null,
                        chunkOffset: 0,
                        appendWindow: [undefined, undefined] } });
            }
            const responseBuffer = data instanceof Uint8Array ? data :
                new Uint8Array(data);
            if (segment.isInit) {
                const timescale = (_b = (_a = segment.privateInfos) === null || _a === void 0 ? void 0 : _a.smoothInitSegment) === null || _b === void 0 ? void 0 : _b.timescale;
                return (0,of.of)({ type: "parsed-init-segment",
                    value: { initializationData: data,
                        // smooth init segments are crafted by hand.
                        // Their timescale is the one from the manifest.
                        initTimescale: timescale,
                        protectionDataUpdate: false } });
            }
            const timingInfos = initTimescale !== undefined ?
                extractTimingsInfos(responseBuffer, isChunked, initTimescale, segment, manifest.isLive) :
                null;
            if (timingInfos === null ||
                timingInfos.chunkInfos === null ||
                timingInfos.scaledSegmentTime === undefined) {
                throw new Error("Smooth Segment without time information");
            }
            const { nextSegments, chunkInfos, scaledSegmentTime } = timingInfos;
            const chunkData = patchSegment(responseBuffer, scaledSegmentTime);
            if (nextSegments.length > 0) {
                addNextSegments(adaptation, nextSegments, segment);
            }
            return (0,of.of)({ type: "parsed-segment",
                value: { chunkData,
                    chunkInfos,
                    chunkOffset: 0,
                    appendWindow: [undefined, undefined] } });
        },
    };
    const textTrackPipeline = {
        loader({ segment, representation, url }) {
            if (segment.isInit || url === null) {
                return (0,of.of)({ type: "data-created", value: { responseData: null } });
            }
            const isMP4 = isMP4EmbeddedTrack(representation);
            if (!isMP4 || options.checkMediaSegmentIntegrity !== true) {
                return (0,request/* default */.ZP)({ url,
                    responseType: isMP4 ? "arraybuffer" : "text",
                    sendProgressEvents: true });
            }
            return (0,request/* default */.ZP)({ url,
                responseType: "arraybuffer",
                sendProgressEvents: true })
                .pipe((0,tap/* tap */.b)(res => {
                if (res.type === "data-loaded") {
                    (0,check_isobmff_integrity/* default */.Z)(new Uint8Array(res.value.responseData), segment.isInit);
                }
            }));
        },
        parser({ content, response, initTimescale, }) {
            var _a;
            const { manifest, adaptation, representation, segment } = content;
            const { language } = adaptation;
            const isMP4 = isMP4EmbeddedTrack(representation);
            const { mimeType = "", codec = "" } = representation;
            const { data, isChunked } = response;
            if (segment.isInit) { // text init segment has no use in HSS
                return (0,of.of)({ type: "parsed-init-segment",
                    value: { initializationData: null,
                        protectionDataUpdate: false,
                        initTimescale: undefined } });
            }
            if (data === null) {
                return (0,of.of)({ type: "parsed-segment",
                    value: { chunkData: null,
                        chunkInfos: null,
                        chunkOffset: 0,
                        appendWindow: [undefined, undefined] } });
            }
            let nextSegments;
            let chunkInfos = null;
            let segmentStart;
            let segmentEnd;
            let _sdData;
            let _sdType;
            if (isMP4) {
                let chunkBytes;
                if (typeof data === "string") {
                    chunkBytes = (0,string_parsing/* strToUtf8 */.tG)(data);
                }
                else {
                    chunkBytes = data instanceof Uint8Array ? data :
                        new Uint8Array(data);
                }
                const timingInfos = initTimescale !== undefined ?
                    extractTimingsInfos(chunkBytes, isChunked, initTimescale, segment, manifest.isLive) :
                    null;
                nextSegments = timingInfos === null || timingInfos === void 0 ? void 0 : timingInfos.nextSegments;
                chunkInfos = (_a = timingInfos === null || timingInfos === void 0 ? void 0 : timingInfos.chunkInfos) !== null && _a !== void 0 ? _a : null;
                if (chunkInfos === null) {
                    if (isChunked) {
                        log/* default.warn */.Z.warn("Smooth: Unavailable time data for current text track.");
                    }
                    else {
                        segmentStart = segment.time;
                        segmentEnd = segment.end;
                    }
                }
                else {
                    segmentStart = chunkInfos.time;
                    segmentEnd = chunkInfos.duration !== undefined ?
                        chunkInfos.time + chunkInfos.duration :
                        segment.end;
                }
                const lcCodec = codec.toLowerCase();
                if (mimeType === "application/ttml+xml+mp4" ||
                    lcCodec === "stpp" ||
                    lcCodec === "stpp.ttml.im1t") {
                    _sdType = "ttml";
                }
                else if (lcCodec === "wvtt") {
                    _sdType = "vtt";
                }
                else {
                    throw new Error(`could not find a text-track parser for the type ${mimeType}`);
                }
                const mdat = (0,read/* getMDAT */.Le)(chunkBytes);
                _sdData = mdat === null ? "" :
                    (0,string_parsing/* utf8ToStr */.uR)(mdat);
            }
            else { // not MP4
                segmentStart = segment.time;
                segmentEnd = segment.end;
                let chunkString;
                if (typeof data !== "string") {
                    const bytesData = data instanceof Uint8Array ? data :
                        new Uint8Array(data);
                    chunkString = (0,string_parsing/* utf8ToStr */.uR)(bytesData);
                }
                else {
                    chunkString = data;
                }
                switch (mimeType) {
                    case "application/x-sami":
                    case "application/smil": // TODO SMIL should be its own format, no?
                        _sdType = "sami";
                        break;
                    case "application/ttml+xml":
                        _sdType = "ttml";
                        break;
                    case "text/vtt":
                        _sdType = "vtt";
                        break;
                }
                if (_sdType === undefined) {
                    const lcCodec = codec.toLowerCase();
                    if (lcCodec === "srt") {
                        _sdType = "srt";
                    }
                    else {
                        throw new Error(`could not find a text-track parser for the type ${mimeType}`);
                    }
                }
                _sdData = chunkString;
            }
            if (chunkInfos !== null &&
                Array.isArray(nextSegments) && nextSegments.length > 0) {
                addNextSegments(adaptation, nextSegments, segment);
            }
            const chunkOffset = segmentStart !== null && segmentStart !== void 0 ? segmentStart : 0;
            return (0,of.of)({ type: "parsed-segment",
                value: { chunkData: { type: _sdType,
                        data: _sdData,
                        start: segmentStart,
                        end: segmentEnd,
                        language },
                    chunkInfos,
                    chunkOffset,
                    appendWindow: [undefined, undefined] } });
        },
    };
    const imageTrackPipeline = {
        loader({ segment, url }) {
            if (segment.isInit || url === null) {
                // image do not need an init segment. Passthrough directly to the parser
                return (0,of.of)({ type: "data-created", value: { responseData: null } });
            }
            return (0,request/* default */.ZP)({ url,
                responseType: "arraybuffer",
                sendProgressEvents: true });
        },
        parser({ response, content }) {
            const { data, isChunked } = response;
            if (content.segment.isInit) { // image init segment has no use
                return (0,of.of)({ type: "parsed-init-segment",
                    value: { initializationData: null,
                        protectionDataUpdate: false,
                        initTimescale: undefined } });
            }
            if (isChunked) {
                throw new Error("Image data should not be downloaded in chunks");
            }
            // TODO image Parsing should be more on the buffer side, no?
            if (data === null || features/* default.imageParser */.Z.imageParser === null) {
                return (0,of.of)({ type: "parsed-segment",
                    value: { chunkData: null,
                        chunkInfos: null,
                        chunkOffset: 0,
                        appendWindow: [undefined, undefined] } });
            }
            const bifObject = features/* default.imageParser */.Z.imageParser(new Uint8Array(data));
            const thumbsData = bifObject.thumbs;
            return (0,of.of)({ type: "parsed-segment",
                value: { chunkData: { data: thumbsData,
                        start: 0,
                        end: Number.MAX_VALUE,
                        timescale: 1,
                        type: "bif" },
                    chunkInfos: { time: 0,
                        duration: Number.MAX_VALUE,
                        timescale: bifObject.timescale },
                    chunkOffset: 0,
                    protectionDataUpdate: false,
                    appendWindow: [undefined, undefined] } });
        },
    };
    return { manifest: manifestPipeline,
        audio: segmentPipeline,
        video: segmentPipeline,
        text: textTrackPipeline,
        image: imageTrackPipeline };
}
/**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */
function isMP4EmbeddedTrack(representation) {
    return typeof representation.mimeType === "string" &&
        representation.mimeType.indexOf("mp4") >= 0;
}

;// CONCATENATED MODULE: ./src/transports/smooth/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * /!\ This file is feature-switchable.
 * It always should be imported through the `features` object.
 */

/* harmony default export */ const transports_smooth = (pipelines);


/***/ }),

/***/ 25602:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ byteRange)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns text-formatted byteRange (`bytes=$start-$end?)`
 * @param {Array.<string|Number>} arr
 * @returns {string}
 */
function byteRange([start, end]) {
    return end === Infinity ? `bytes=${start}-` :
        `bytes=${start}-${end}`;
}


/***/ }),

/***/ 218:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ callCustomManifestLoader)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30365);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function callCustomManifestLoader(customManifestLoader, fallbackManifestLoader) {
    return (args) => {
        return new rxjs__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y((obs) => {
            const { url } = args;
            const timeAPIsDelta = Date.now() - performance.now();
            let hasFinished = false;
            let hasFallbacked = false;
            /**
             * Callback triggered when the custom manifest loader has a response.
             * @param {Object} args
             */
            const resolve = (_args) => {
                if (!hasFallbacked) {
                    hasFinished = true;
                    const receivedTime = _args.receivingTime !== undefined ? _args.receivingTime - timeAPIsDelta :
                        undefined;
                    const sendingTime = _args.sendingTime !== undefined ? _args.sendingTime - timeAPIsDelta :
                        undefined;
                    obs.next({ type: "data-loaded",
                        value: { responseData: _args.data,
                            size: _args.size,
                            duration: _args.duration,
                            url: _args.url,
                            receivedTime, sendingTime } });
                    obs.complete();
                }
            };
            /**
             * Callback triggered when the custom manifest loader fails
             * @param {*} err - The corresponding error encountered
             */
            const reject = (err) => {
                if (!hasFallbacked) {
                    hasFinished = true;
                    obs.error(err);
                }
            };
            /**
             * Callback triggered when the custom manifest loader wants to fallback to
             * the "regular" implementation
             */
            const fallback = () => {
                hasFallbacked = true;
                fallbackManifestLoader(args).subscribe(obs);
            };
            const callbacks = { reject, resolve, fallback };
            const abort = customManifestLoader(url, callbacks);
            return () => {
                if (!hasFinished && !hasFallbacked && typeof abort === "function") {
                    abort();
                }
            };
        });
    };
}


/***/ }),

/***/ 47795:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ checkISOBMFFIntegrity)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12353);
/* harmony import */ var _find_complete_box__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61698);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Check if an ISOBMFF segment has all the right box needed to be decoded.
 * Throw if that's not the case.
 * @param {Uint8Array} buffer - The whole ISOBMFF segment
 * @param {boolean} isInitSegment - `true` if this is an initialization segment,
 * `false` otherwise.
 */
function checkISOBMFFIntegrity(buffer, isInitSegment) {
    if (isInitSegment) {
        const ftypIndex = (0,_find_complete_box__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(buffer, 0x66747970 /* ftyp */);
        if (ftypIndex < 0) {
            throw new _errors__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z("INTEGRITY_ERROR", "Incomplete `ftyp` box");
        }
        const moovIndex = (0,_find_complete_box__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(buffer, 0x6D6F6F76 /* moov */);
        if (moovIndex < 0) {
            throw new _errors__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z("INTEGRITY_ERROR", "Incomplete `moov` box");
        }
    }
    else {
        const moofIndex = (0,_find_complete_box__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(buffer, 0x6D6F6F66 /* moof */);
        if (moofIndex < 0) {
            throw new _errors__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z("INTEGRITY_ERROR", "Incomplete `moof` box");
        }
        const mdatIndex = (0,_find_complete_box__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(buffer, 0x6D646174 /* mdat */);
        if (mdatIndex < 0) {
            throw new _errors__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z("INTEGRITY_ERROR", "Incomplete `mdat` box");
        }
    }
}


/***/ }),

/***/ 61698:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ findCompleteBox)
/* harmony export */ });
/* harmony import */ var _utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97308);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Find the offset for the first declaration of the given box in an isobmff.
 * Returns -1 if not found or if incomplete.
 *
 * This function does not throw or log in case of partial segments.
 * @param {Uint8Array} buf - the isobmff
 * @param {Number} wantedName
 * @returns {Number} - Offset where the box begins. -1 if not found.
 */
function findCompleteBox(buf, wantedName) {
    const len = buf.length;
    let i = 0;
    while (i + 8 <= len) {
        let size = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .pX)(buf, i);
        if (size === 0) {
            size = len - i;
        }
        else if (size === 1) {
            if (i + 16 > len) {
                return -1;
            }
            size = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be8toi */ .pV)(buf, i + 8);
        }
        if (isNaN(size) || size <= 0) { // should not happen
            return -1;
        }
        const name = (0,_utils_byte_parsing__WEBPACK_IMPORTED_MODULE_0__/* .be4toi */ .pX)(buf, i + 4);
        if (name === wantedName) {
            if (i + size <= len) {
                return i;
            }
            return -1;
        }
        i += size;
    }
    return -1;
}


/***/ }),

/***/ 95445:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ getISOBMFFTimingInfos)
/* harmony export */ });
/* harmony import */ var _parsers_containers_isobmff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14959);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Get precize start and duration of a chunk.
 * @param {UInt8Array} buffer - An ISOBMFF container (at least a `moof` + a
 * `mdat` box.
 * @param {Boolean} isChunked - If true, the whole segment was chunked into
 * multiple parts and buffer is one of them. If false, buffer is the whole
 * segment.
 * @param {Object} segment
 * @param {Array.<Object>|undefined} sidxSegments - Segments from sidx. Here
 * pre-parsed for performance reasons as it is usually available when
 * this function is called.
 * @param {number|undefined} initTimescale
 * @returns {Object}
 */
function getISOBMFFTimingInfos(buffer, isChunked, segment, initTimescale) {
    const baseDecodeTime = (0,_parsers_containers_isobmff__WEBPACK_IMPORTED_MODULE_0__/* .getTrackFragmentDecodeTime */ .Qx)(buffer);
    if (baseDecodeTime === undefined || initTimescale === undefined) {
        return null;
    }
    const startTime = segment.timestampOffset !== undefined ?
        baseDecodeTime + (segment.timestampOffset * initTimescale) :
        baseDecodeTime;
    const trunDuration = (0,_parsers_containers_isobmff__WEBPACK_IMPORTED_MODULE_0__/* .getDurationFromTrun */ .MM)(buffer);
    if (isChunked) { // when chunked, no mean to know the duration for now
        return { time: startTime / initTimescale,
            duration: trunDuration !== undefined ? trunDuration / initTimescale :
                undefined };
    }
    let duration;
    const segmentDuration = segment.duration * initTimescale;
    // we could always make a mistake when reading a container.
    // If the estimate is too far from what the segment seems to imply, take
    // the segment infos instead.
    const maxDecodeTimeDelta = Math.min(initTimescale * 0.9, segmentDuration / 4);
    if (trunDuration !== undefined &&
        Math.abs(trunDuration - segmentDuration) <= maxDecodeTimeDelta) {
        duration = trunDuration;
    }
    return { time: startTime / initTimescale,
        duration: duration !== undefined ? duration / initTimescale :
            duration };
}


/***/ }),

/***/ 53965:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ isMP4EmbeddedTextTrack)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns true if the given texttrack segment represents a textrack embedded
 * in a mp4 file.
 * @param {Representation} representation
 * @returns {Boolean}
 */
function isMP4EmbeddedTextTrack(representation) {
    return representation.mimeType === "application/mp4";
}


/***/ }),

/***/ 55057:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ isWEBMEmbeddedTrack)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {Object} representation
 * @returns {boolean}
 */
function isWEBMEmbeddedTrack(representation) {
    return representation.mimeType === "video/webm" ||
        representation.mimeType === "audio/webm";
}


/***/ }),

/***/ 96190:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r8": () => (/* binding */ getISOBMFFEmbeddedTextTrackData),
/* harmony export */   "yu": () => (/* binding */ getPlainTextTrackData)
/* harmony export */ });
/* unused harmony exports extractTextTrackFromISOBMFF, getISOBMFFTextTrackFormat, getPlainTextTrackFormat */
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6077);
/* harmony import */ var _parsers_containers_isobmff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(69903);
/* harmony import */ var _utils_string_parsing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26332);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Return plain text text track from the given ISOBMFF.
 * @param {Uint8Array} chunkBytes
 * @returns {string}
 */
function extractTextTrackFromISOBMFF(chunkBytes) {
    const mdat = (0,_parsers_containers_isobmff__WEBPACK_IMPORTED_MODULE_0__/* .getMDAT */ .Le)(chunkBytes);
    return mdat === null ? "" :
        (0,_utils_string_parsing__WEBPACK_IMPORTED_MODULE_1__/* .utf8ToStr */ .uR)(mdat);
}
/**
 * Returns the a string expliciting the format of a text track when that text
 * track is embedded into a ISOBMFF file.
 * @param {Object} representation
 * @returns {string}
 */
function getISOBMFFTextTrackFormat(representation) {
    const codec = representation.codec;
    if (codec === undefined) {
        throw new Error("Cannot parse subtitles: unknown format");
    }
    switch (codec.toLowerCase()) {
        case "stpp": // stpp === TTML in MP4
        case "stpp.ttml.im1t":
            return "ttml";
        case "wvtt": // wvtt === WebVTT in MP4
            return "vtt";
    }
    throw new Error("The codec used for the subtitles " +
        `"${codec}" is not managed yet.`);
}
/**
 * Returns the a string expliciting the format of a text track in plain text.
 * @param {Object} representation
 * @returns {string}
 */
function getPlainTextTrackFormat(representation) {
    const { mimeType = "" } = representation;
    switch (representation.mimeType) {
        case "application/ttml+xml":
            return "ttml";
        case "application/x-sami":
        case "application/smil":
            return "sami";
        case "text/vtt":
            return "vtt";
    }
    const { codec = "" } = representation;
    const codeLC = codec.toLowerCase();
    if (codeLC === "srt") {
        return "srt";
    }
    throw new Error(`could not find a text-track parser for the type ${mimeType}`);
}
/**
 * @param {Object} content
 * @param {ArrayBuffer|UInt8Array|null} chunkData
 * @param {Object|null} chunkInfos
 * @param {boolean} isChunked
 * @returns {Object|null}
 */
function getISOBMFFEmbeddedTextTrackData({ segment, adaptation, representation }, chunkBytes, chunkInfos, isChunked) {
    if (segment.isInit) {
        return null;
    }
    let startTime;
    let endTime;
    if (chunkInfos === null) {
        if (!isChunked) {
            _log__WEBPACK_IMPORTED_MODULE_2__/* .default.warn */ .Z.warn("Transport: Unavailable time data for current text track.");
        }
        else {
            startTime = segment.time;
            endTime = segment.end;
        }
    }
    else {
        startTime = chunkInfos.time;
        if (chunkInfos.duration !== undefined) {
            endTime = startTime + chunkInfos.duration;
        }
        else if (!isChunked) {
            endTime = startTime + segment.duration;
        }
    }
    const type = getISOBMFFTextTrackFormat(representation);
    const textData = extractTextTrackFromISOBMFF(chunkBytes);
    return { data: textData,
        type,
        language: adaptation.language,
        start: startTime,
        end: endTime };
}
/**
 * @param {Object} content
 * @param {ArrayBuffer|UInt8Array|null} chunkData
 * @param {Object|null} chunkInfos
 * @param {boolean} isChunked
 * @returns {Object|null}
 */
function getPlainTextTrackData({ segment, adaptation, representation }, textTrackData, isChunked) {
    if (segment.isInit) {
        return null;
    }
    if (isChunked) {
        _log__WEBPACK_IMPORTED_MODULE_2__/* .default.warn */ .Z.warn("Transport: Unavailable time data for current text track.");
    }
    const type = getPlainTextTrackFormat(representation);
    return { data: textTrackData,
        type,
        language: adaptation.language };
}


/***/ }),

/***/ 97275:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ returnParsedManifest)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(65637);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70252);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * As a Manifest instance is obtained, emit the right `warning` events
 * (according to the Manifest's `parsingErrors` property`) followed by the right
 * `parsed` event, as expected from a Manifest parser.
 * @param {Manifest} manifest
 * @param {string|undefined} url
 * @returns {Observable}
 */
function returnParsedManifest(manifest, url) {
    const warningEvts$ = (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(...manifest.parsingErrors.map(error => ({
        type: "warning",
        value: error,
    })));
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_1__/* .concat */ .z)(warningEvts$, (0,rxjs__WEBPACK_IMPORTED_MODULE_0__.of)({ type: "parsed", value: { manifest, url } }));
}


/***/ }),

/***/ 75691:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ generateManifestLoader)
/* harmony export */ });
/* harmony import */ var _utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32825);
/* harmony import */ var _utils_request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(99703);
/* harmony import */ var _call_custom_manifest_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(218);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Manifest loader triggered if there was no custom-defined one in the API.
 * @param {string} url
 * @returns {Observable}
 */
function regularManifestLoader({ url }) {
    if (url === undefined) {
        throw new Error("Cannot perform HTTP(s) request. URL not known");
    }
    return (0,_utils_request__WEBPACK_IMPORTED_MODULE_0__/* .default */ .ZP)({ url, responseType: "text" });
}
/**
 * Generate a manifest loader for the application
 * @param {Function} [customManifestLoader]
 * @returns {Function}
 */
function generateManifestLoader({ customManifestLoader }) {
    if ((0,_utils_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(customManifestLoader)) {
        return regularManifestLoader;
    }
    return (0,_call_custom_manifest_loader__WEBPACK_IMPORTED_MODULE_2__/* .default */ .Z)(customManifestLoader, regularManifestLoader);
}


/***/ }),

/***/ 90387:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ areArraysOfNumbersEqual)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Check if two two arrays containing only numbers are equal.
 * @param {Array.<number>|TypedArray} arr1
 * @param {Array.<number>|TypedArray} arr2
 * @returns {Boolean}
 */
function areArraysOfNumbersEqual(arr1, arr2) {
    if (arr1.length !== arr2.length) {
        return false;
    }
    for (let i = arr1.length - 1; i >= 0; i--) {
        if (arr1[i] !== arr2[i]) {
            return false;
        }
    }
    return true;
}


/***/ }),

/***/ 23437:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ arrayFind)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable no-restricted-properties */
/**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */
function arrayFind(arr, predicate, thisArg) {
    if (typeof Array.prototype.find === "function") {
        return arr.find(predicate, thisArg);
    }
    const len = arr.length >>> 0;
    for (let i = 0; i < len; i++) {
        const val = arr[i];
        if (predicate.call(thisArg, val, i, arr)) {
            return val;
        }
    }
    return undefined;
}


/***/ }),

/***/ 34612:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ arrayFindIndex)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-return */
/* eslint-disable no-restricted-properties */
/**
 * Array.prototype.find ponyfill.
 * @param {Array} arr
 * @param {Function} predicate
 * @param {*} context
 * @returns {boolean}
 */
function arrayFindIndex(arr, predicate, thisArg) {
    if (typeof Array.prototype.findIndex === "function") {
        return arr.findIndex(predicate, thisArg);
    }
    const len = arr.length >>> 0;
    for (let i = 0; i < len; i++) {
        if (predicate.call(thisArg, arr[i], i, arr)) {
            return i;
        }
    }
    return -1;
}


/***/ }),

/***/ 54924:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ arrayIncludes)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Array.prototype.includes ponyfill.
 * Returns ``true`` if the given array ``arr`` contains the element
 * ``searchElement``. false ``otherwise``.
 *
 * Inspired from MDN polyfill, but ponyfilled instead
 *
 * @example
 * ```js
 * arrayIncludes([1, 2, 3], 3);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 7);
 * // => false
 *
 * const obj = { a: 4 };
 * arrayIncludes([obj, { b: 7 }, { a: 3 }], obj);
 * // => true
 *
 * // does not perform deep equality
 * arrayIncludes([{ a: 4 }, { b: 7 }, { a: 3 }], { a: 4 });
 * // => false
 *
 * // the third argument state the starting index. 0 if not set.
 *
 * arrayIncludes([1, 2, 3], 2, 1);
 * // => true
 *
 * arrayIncludes([1, 2, 3], 2, 2);
 * // => false
 * ```
 *
 * @param {Array} arr
 * @param {*} searchElement
 * @param {number} [fromIndex]
 * @returns {boolean}
 */
function arrayIncludes(arr, searchElement, fromIndex) {
    /* eslint-disable @typescript-eslint/unbound-method */
    // eslint-disable-next-line no-restricted-properties
    if (typeof Array.prototype.includes === "function") {
        /* eslint-enable @typescript-eslint/unbound-method */
        // eslint-disable-next-line no-restricted-properties
        return arr.includes(searchElement, fromIndex);
    }
    const len = arr.length >>> 0;
    if (len === 0) {
        return false;
    }
    const n = fromIndex | 0;
    let k = n >= 0 ?
        Math.min(n, len - 1) :
        Math.max(len + n, 0);
    const areTheSame = (x, y) => x === y ||
        // Viva las JavaScriptas!
        (typeof x === "number" &&
            typeof y === "number" &&
            isNaN(x) && isNaN(y));
    while (k < len) {
        if (areTheSame(arr[k], searchElement)) {
            return true;
        }
        k++;
    }
    return false;
}


/***/ }),

/***/ 25222:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ assert),
/* harmony export */   "u": () => (/* binding */ assertInterface)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22090);
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32825);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Throw an AssertionError if the given assertion is false.
 * @param {boolean} assertion
 * @param {string} [message] - Optional message property for the AssertionError.
 * @throws AssertionError - Throws if the assertion given is false
 */
function assert(assertion, message) {
    if (!assertion) {
        throw new _errors__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z(message === undefined ? "invalid assertion" :
            message);
    }
}
/**
 * Throws if the given Object does not respect the interface.
 * @param {Object} o
 * @param {Object} iface - Contains the checked keynames of o and link them
 * to their types (obtained through the typeof operator).
 * @param {string} [name="object"] - name of the _interface_
 * @throws AssertionError - The argument o given is not an object
 * @throws AssertionError - The _interface_ is not respected.
 */
function assertInterface(o, iface, name = "object") {
    assert(!(0,_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(o), `${name} should be an object`);
    for (const k in iface) {
        if (iface.hasOwnProperty(k)) {
            /* eslint-disable max-len  */
            /* eslint-disable @typescript-eslint/restrict-template-expressions */
            assert(typeof o[k] === iface[k], `${name} should have property ${k} as a ${iface[k]}`);
            /* eslint-enable max-len */
            /* eslint-enable @typescript-eslint/restrict-template-expressions */
        }
    }
}


/***/ }),

/***/ 76709:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ assertUnreachable)
/* harmony export */ });
/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22090);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * TypeScript hack to make sure a code path is never taken.
 *
 * This can for example be used to ensure that a switch statement handle all
 * possible cases by adding a default clause calling assertUnreachable with
 * an argument (it doesn't matter which one).
 *
 * @example
 * function parseBinary(str : "0" | "1") : number {
 *   switch (str) {
 *     case "0:
 *       return 0;
 *     case "1":
 *       return 1;
 *     default:
 *       // branch never taken. If it can be, TypeScript will yell at us because
 *       // its argument (here, `str`) is not of the right type.
 *       assertUnreachable(str);
 *   }
 * }
 * @param {*} _
 * @throws AssertionError - Throw an AssertionError when called. If we're
 * sufficiently strict with how we use TypeScript, this should never happen.
 */
function assertUnreachable(_) {
    throw new _errors__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z("Unreachable path taken");
}


/***/ }),

/***/ 91282:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "J": () => (/* binding */ bytesToBase64),
/* harmony export */   "K": () => (/* binding */ base64ToBytes)
/* harmony export */ });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6077);
/* eslint-disable */
/*
MIT License
Copyright (c) 2020 Egor Nepomnyaschih
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
 */

/*
// This constant can also be computed with the following algorithm:
const base64abc = [],
  A = "A".charCodeAt(0),
  a = "a".charCodeAt(0),
  n = "0".charCodeAt(0);
for (let i = 0; i < 26; ++i) {
  base64abc.push(String.fromCharCode(A + i));
}
for (let i = 0; i < 26; ++i) {
  base64abc.push(String.fromCharCode(a + i));
}
for (let i = 0; i < 10; ++i) {
  base64abc.push(String.fromCharCode(n + i));
}
base64abc.push("+");
base64abc.push("/");
 */
const base64abc = [
    "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M",
    "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
    "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m",
    "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
    "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/",
];
/*
// This constant can also be computed with the following algorithm:
const l = 256, base64codes = new Uint8Array(l);
for (let i = 0; i < l; ++i) {
  base64codes[i] = 255; // invalid character
}
base64abc.forEach((char, index) => {
  base64codes[char.charCodeAt(0)] = index;
});
base64codes["=".charCodeAt(0)] = 0; // ignored anyway, so we just need to prevent an error
 */
const base64codes = [
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63,
    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255,
    255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255,
    255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
];
/**
 * Obtain the value corresponding to a base64 char code.
 * /!\ Can throw if the char code given is invalid.
 * @param {number} charCode
 * @returns {number}
 */
function getBase64Code(charCode) {
    if (charCode >= base64codes.length) {
        throw new Error("Unable to parse base64 string.");
    }
    const code = base64codes[charCode];
    if (code === 255) {
        throw new Error("Unable to parse base64 string.");
    }
    return code;
}
/**
 * Convert an array of bytes into a base64 string.
 * @param {Array.<number>|Uint8Array} bytes
 * @returns {string}
 */
function bytesToBase64(bytes) {
    let result = "";
    let i;
    const length = bytes.length;
    for (i = 2; i < length; i += 3) {
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
        result += base64abc[((bytes[i - 1] & 0x0F) << 2) | (bytes[i] >> 6)];
        result += base64abc[bytes[i] & 0x3F];
    }
    if (i === length + 1) { // 1 octet yet to write
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[(bytes[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === length) { // 2 octets yet to write
        result += base64abc[bytes[i - 2] >> 2];
        result += base64abc[((bytes[i - 2] & 0x03) << 4) | (bytes[i - 1] >> 4)];
        result += base64abc[(bytes[i - 1] & 0x0F) << 2];
        result += "=";
    }
    return result;
}
/**
 * Convert a base64 string into the corresponding Uint8Array containing its
 * corresponding binary data.
 * /!\ Can throw if an invalid base64 string was given.
 * @param {Array.<number>|Uint8Array} bytes
 * @returns {string}
 */
function base64ToBytes(str) {
    const paddingNeeded = str.length % 4;
    let paddedStr = str;
    if (paddingNeeded !== 0) {
        _log__WEBPACK_IMPORTED_MODULE_0__/* .default.warn */ .Z.warn("base64ToBytes: base64 given miss padding");
        paddedStr += paddingNeeded === 3 ? "=" :
            paddingNeeded === 2 ? "==" :
                "==="; // invalid, but we will catch it
    }
    const index = paddedStr.indexOf("=");
    if (index !== -1 && index < paddedStr.length - 2) {
        throw new Error("Unable to parse base64 string.");
    }
    const missingOctets = paddedStr.endsWith("==") ? 2 :
        paddedStr.endsWith("=") ? 1 : 0;
    const n = paddedStr.length;
    const result = new Uint8Array((n / 4) * 3);
    let buffer;
    for (let i = 0, j = 0; i < n; i += 4, j += 3) {
        buffer = getBase64Code(paddedStr.charCodeAt(i)) << 18 |
            getBase64Code(paddedStr.charCodeAt(i + 1)) << 12 |
            getBase64Code(paddedStr.charCodeAt(i + 2)) << 6 |
            getBase64Code(paddedStr.charCodeAt(i + 3));
        result[j] = buffer >> 16;
        result[j + 1] = (buffer >> 8) & 0xFF;
        result[j + 2] = buffer & 0xFF;
    }
    return result.subarray(0, result.length - missingOctets);
}


/***/ }),

/***/ 97308:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "zo": () => (/* binding */ concat),
/* harmony export */   "zK": () => (/* binding */ be2toi),
/* harmony export */   "QI": () => (/* binding */ be3toi),
/* harmony export */   "pX": () => (/* binding */ be4toi),
/* harmony export */   "pV": () => (/* binding */ be8toi),
/* harmony export */   "qb": () => (/* binding */ le2toi),
/* harmony export */   "dN": () => (/* binding */ le4toi),
/* harmony export */   "XT": () => (/* binding */ itobe2),
/* harmony export */   "kh": () => (/* binding */ itobe4),
/* harmony export */   "el": () => (/* binding */ itobe8),
/* harmony export */   "O_": () => (/* binding */ itole4),
/* harmony export */   "_f": () => (/* binding */ toUint8Array)
/* harmony export */ });
/* unused harmony exports le8toi, itole2, isABEqualBytes */
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns a Uint8Array from the arguments given, in order:
 *   - if the next argument given is a number N set the N next bytes to 0.
 *   - else set the next bytes to the argument given.
 * @param {...(Number|Uint8Array)} args
 * @returns {Uint8Array}
 */
function concat(...args) {
    const l = args.length;
    let i = -1;
    let len = 0;
    let arg;
    while (++i < l) {
        arg = args[i];
        len += (typeof arg === "number") ? arg : arg.length;
    }
    const arr = new Uint8Array(len);
    let offset = 0;
    i = -1;
    while (++i < l) {
        arg = args[i];
        if (typeof arg === "number") {
            offset += arg;
        }
        else if (arg.length > 0) {
            arr.set(arg, offset);
            offset += arg.length;
        }
    }
    return arr;
}
/**
 * Translate groups of 2 big-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be2toi(bytes, offset) {
    return ((bytes[offset + 0] << 8) +
        (bytes[offset + 1] << 0));
}
/**
 * Translate groups of 3 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be3toi(bytes, offset) {
    return ((bytes[offset + 0] * 0x0010000) +
        (bytes[offset + 1] * 0x0000100) +
        (bytes[offset + 2]));
}
/**
 * Translate groups of 4 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be4toi(bytes, offset) {
    return ((bytes[offset + 0] * 0x1000000) +
        (bytes[offset + 1] * 0x0010000) +
        (bytes[offset + 2] * 0x0000100) +
        (bytes[offset + 3]));
}
/**
 * Translate groups of 8 big-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function be8toi(bytes, offset) {
    return (((bytes[offset + 0] * 0x1000000) +
        (bytes[offset + 1] * 0x0010000) +
        (bytes[offset + 2] * 0x0000100) +
        (bytes[offset + 3])) * 0x100000000 +
        (bytes[offset + 4] * 0x1000000) +
        (bytes[offset + 5] * 0x0010000) +
        (bytes[offset + 6] * 0x0000100) +
        (bytes[offset + 7]));
}
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding big-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe2(num) {
    return new Uint8Array([(num >>> 8) & 0xFF,
        (num) & 0xFF]);
}
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding big-endian
 * bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe4(num) {
    return new Uint8Array([(num >>> 24) & 0xFF,
        (num >>> 16) & 0xFF,
        (num >>> 8) & 0xFF,
        (num) & 0xFF]);
}
/**
 * Translate Integer to a Uint8Array of length 8 of the corresponding big-endian
 * bytes.
 * /!\ If the top-most bytes are set, this might go over MAX_SAFE_INTEGER, thus
 * leading to a "bad" value.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itobe8(num) {
    const l = (num % 0x100000000);
    const h = (num - l) / 0x100000000;
    return new Uint8Array([(h >>> 24) & 0xFF,
        (h >>> 16) & 0xFF,
        (h >>> 8) & 0xFF,
        (h) & 0xFF,
        (l >>> 24) & 0xFF,
        (l >>> 16) & 0xFF,
        (l >>> 8) & 0xFF,
        (l) & 0xFF]);
}
/**
 * Translate groups of 2 little-endian bytes to Integer (from 0 up to 65535).
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function le2toi(bytes, offset) {
    return ((bytes[offset + 0] << 0) +
        (bytes[offset + 1] << 8));
}
/**
 * Translate groups of 4 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function le4toi(bytes, offset) {
    return ((bytes[offset + 0]) +
        (bytes[offset + 1] * 0x0000100) +
        (bytes[offset + 2] * 0x0010000) +
        (bytes[offset + 3] * 0x1000000));
}
/**
 * Translate groups of 8 little-endian bytes to Integer.
 * @param {Uint8Array} bytes
 * @param {Number} offset - The offset (from the start of the given array)
 * @returns {Number}
 */
function le8toi(bytes, offset) {
    return (bytes[offset + 0]) +
        (bytes[offset + 1] * 0x0000100) +
        (bytes[offset + 2] * 0x0010000) +
        (bytes[offset + 3] * 0x1000000) +
        ((bytes[offset + 4]) +
            (bytes[offset + 5] * 0x0000100) +
            (bytes[offset + 6] * 0x0010000) +
            (bytes[offset + 7] * 0x1000000)) * 0x100000000;
}
/**
 * Translate Integer (from 0 up to 65535) to a Uint8Array of length 2 of
 * the corresponding little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole2(num) {
    return new Uint8Array([(num) & 0xFF,
        (num >>> 8) & 0xFF]);
}
/**
 * Translate Integer to a Uint8Array of length 4 of the corresponding
 * little-endian bytes.
 * @param {Number} num
 * @returns {Uint8Array}
 */
function itole4(num) {
    return new Uint8Array([(num) & 0xFF,
        (num >>> 8) & 0xFF,
        (num >>> 16) & 0xFF,
        (num >>> 24) & 0xFF]);
}
/**
 * Check if an ArrayBuffer is equal to the bytes given.
 * @param {ArrayBuffer} buffer
 * @param {Uint8Array} bytes
 * @returns {Boolean}
 */
function isABEqualBytes(buffer, bytes) {
    const view = new DataView(buffer);
    const len = view.byteLength;
    if (len !== bytes.length) {
        return false;
    }
    for (let i = 0; i < len; i++) {
        if (view.getUint8(i) !== bytes[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Convert any BufferSource-typed structure into the corresponding Uint8Array.
 * @param {BufferSource} input
 * @returns {Uint8Array}
 */
function toUint8Array(input) {
    return input instanceof Uint8Array ? input :
        input instanceof ArrayBuffer ? new Uint8Array(input) :
            new Uint8Array(input.buffer);
}



/***/ }),

/***/ 42121:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30365);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41981);
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(65637);
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32825);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
function castToObservable(value) {
    if (value instanceof rxjs__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return value;
    }
    /* eslint-disable-next-line @typescript-eslint/no-unsafe-member-access */
    if (!(0,_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(value) && typeof value.subscribe === "function") {
        const valObsLike = value;
        return new rxjs__WEBPACK_IMPORTED_MODULE_0__/* .Observable */ .y((obs) => {
            const sub = valObsLike.subscribe((val) => { obs.next(val); }, (err) => { obs.error(err); }, () => { obs.complete(); });
            return () => {
                if (!(0,_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(sub) && typeof sub.dispose === "function") {
                    sub.dispose();
                }
                else if (!(0,_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(sub) && typeof sub.unsubscribe === "function") {
                    sub.unsubscribe();
                }
            };
        });
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    if (!(0,_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(value) && typeof value.then === "function") {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_2__/* .from */ .D)(value);
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return (0,rxjs__WEBPACK_IMPORTED_MODULE_3__.of)(value);
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (castToObservable);


/***/ }),

/***/ 45150:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "Z": () => (/* binding */ deferSubscriptions)
});

// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(10649);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/util/Immediate.js
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;

var RESOLVED = /*@__PURE__*/function () {
  return /*@__PURE__*/Promise.resolve();
}();

var activeHandles = {};

function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }

  return false;
}

var Immediate = {
  setImmediate: function setImmediate(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    RESOLVED.then(function () {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function clearImmediate(handle) {
    findAndClearHandle(handle);
  }
};
var TestTools = {
  pending: function pending() {
    return Object.keys(activeHandles).length;
  }
};
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncAction.js + 1 modules
var AsyncAction = __webpack_require__(55733);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsapAction.js
/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */




var AsapAction = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(AsapAction, _super);

  function AsapAction(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;

    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }

  AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
    }

    scheduler.actions.push(this);
    return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
  };

  AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
    }

    if (scheduler.actions.length === 0) {
      Immediate.clearImmediate(id);
      scheduler.scheduled = undefined;
    }

    return undefined;
  };

  return AsapAction;
}(AsyncAction/* AsyncAction */.o);


// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js + 1 modules
var AsyncScheduler = __webpack_require__(62641);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/AsapScheduler.js
/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */



var AsapScheduler = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(AsapScheduler, _super);

  function AsapScheduler() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  AsapScheduler.prototype.flush = function (action) {
    this.active = true;
    this.scheduled = undefined;
    var actions = this.actions;
    var error;
    var index = -1;
    var count = actions.length;
    action = action || actions.shift();

    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (++index < count && (action = actions.shift()));

    this.active = false;

    if (error) {
      while (++index < count && (action = actions.shift())) {
        action.unsubscribe();
      }

      throw error;
    }
  };

  return AsapScheduler;
}(AsyncScheduler/* AsyncScheduler */.v);


;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/scheduler/asap.js
/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */


var asapScheduler = /*@__PURE__*/new AsapScheduler(AsapAction);
var asap = asapScheduler;
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(30365);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/isNumeric.js
var isNumeric = __webpack_require__(87967);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/observable/SubscribeOnObservable.js
/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */





var SubscribeOnObservable = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(SubscribeOnObservable, _super);

  function SubscribeOnObservable(source, delayTime, scheduler) {
    if (delayTime === void 0) {
      delayTime = 0;
    }

    if (scheduler === void 0) {
      scheduler = asap;
    }

    var _this = _super.call(this) || this;

    _this.source = source;
    _this.delayTime = delayTime;
    _this.scheduler = scheduler;

    if (!(0,isNumeric/* isNumeric */.k)(delayTime) || delayTime < 0) {
      _this.delayTime = 0;
    }

    if (!scheduler || typeof scheduler.schedule !== 'function') {
      _this.scheduler = asap;
    }

    return _this;
  }

  SubscribeOnObservable.create = function (source, delay, scheduler) {
    if (delay === void 0) {
      delay = 0;
    }

    if (scheduler === void 0) {
      scheduler = asap;
    }

    return new SubscribeOnObservable(source, delay, scheduler);
  };

  SubscribeOnObservable.dispatch = function (arg) {
    var source = arg.source,
        subscriber = arg.subscriber;
    return this.add(source.subscribe(subscriber));
  };

  SubscribeOnObservable.prototype._subscribe = function (subscriber) {
    var delay = this.delayTime;
    var source = this.source;
    var scheduler = this.scheduler;
    return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
      source: source,
      subscriber: subscriber
    });
  };

  return SubscribeOnObservable;
}(Observable/* Observable */.y);


;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/subscribeOn.js
/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

function subscribeOn(scheduler, delay) {
  if (delay === void 0) {
    delay = 0;
  }

  return function subscribeOnOperatorFunction(source) {
    return source.lift(new SubscribeOnOperator(scheduler, delay));
  };
}

var SubscribeOnOperator = /*@__PURE__*/function () {
  function SubscribeOnOperator(scheduler, delay) {
    this.scheduler = scheduler;
    this.delay = delay;
  }

  SubscribeOnOperator.prototype.call = function (subscriber, source) {
    return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
  };

  return SubscribeOnOperator;
}();
;// CONCATENATED MODULE: ./src/utils/defer_subscriptions.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * At subscription, instead of "running" the Observable right away, wait until
 * the current task has finished executing before actually running this
 * Observable.
 *
 * This can be important for example when you want in a given function to
 * exploit the same shared Observable which may send synchronous events directly
 * after subscription.
 *
 * Here, you might be left in a situation where the first element subscribing to
 * that Observable will receive those synchronous events immediately on
 * subscription. Further subscriptions on that Observable will miss out on those
 * events - even if those subscriptions happen synchronously after the first
 * one.
 *
 * Calling `deferSubscriptions` in those cases will make sure that all such
 * subscriptions can be registered before the Observable start emitting events
 * (as long as such Subscriptions are done synchronously).
 *
 * @example
 * ```js
 * const myObservable = rxjs.timer(100).pipe(mapTo("ASYNC MSG"),
 *                                           startWith("SYNCHRONOUS MSG"),
 *                                           share());
 *
 * myObservable.subscribe(x => console.log("Sub1:", x));
 * myObservable.subscribe(x => console.log("Sub2:", x));
 *
 * setTimeout(() => {
 *   myObservable.subscribe(x => console.log("Sub3:", x));
 * }, 50);
 *
 * // You will get:
 * // Sub1: SYNCHRONOUS MSG
 * // Sub1: ASYNC MSG
 * // Sub2: ASYNC MSG
 * // Sub3: ASYNC MSG
 *
 * // ------------------------------
 *
 * const myObservableDeferred = rxjs.timer(100).pipe(mapTo("ASYNC MSG"),
 *                                                   startWith("SYNCHRONOUS MSG"),
 *                                                   deferSubscriptions(),
 *                                                   // NOTE: the order is important here
 *                                                   share());
 *
 * myObservableDeferred.subscribe(x => console.log("Sub1:", x));
 * myObservableDeferred.subscribe(x => console.log("Sub2:", x));
 *
 * setTimeout(() => {
 *   myObservableDeferred.subscribe(x => console.log("Sub3:", x));
 * }, 50);
 *
 * // You will get:
 * // Sub1: SYNCHRONOUS MSG
 * // Sub2: SYNCHRONOUS MSG
 * // Sub1: ASYNC MSG
 * // Sub2: ASYNC MSG
 * // Sub3: ASYNC MSG
 * ```
 * @returns {function}
 */
function deferSubscriptions() {
    return (source) => {
        // TODO asapScheduler seems to not push the subscription in the microtask
        // queue as nextTick does but in a regular event loop queue.
        // This means that the subscription will be run even later that we wish for.
        // This is not dramatic but it could be better.
        // Either this is a problem with RxJS or this was wanted, in which case we
        // may need to add our own scheduler.
        return source.pipe(subscribeOn(asapScheduler));
    };
}


/***/ }),

/***/ 61603:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ EventEmitter),
/* harmony export */   "R": () => (/* binding */ fromEvent)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30365);
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6077);
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32825);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Simple but fully type-safe EventEmitter implementation.
 * @class EventEmitter
 */
class EventEmitter {
    constructor() {
        this._listeners = {};
    }
    /**
     * Register a new callback for an event.
     *
     * @param {string} evt - The event to register a callback to
     * @param {Function} fn - The callback to call as that event is triggered.
     * The callback will take as argument the eventual payload of the event
     * (single argument).
     */
    addEventListener(evt, fn) {
        const listeners = this._listeners[evt];
        if (!Array.isArray(listeners)) {
            this._listeners[evt] = [fn];
        }
        else {
            listeners.push(fn);
        }
    }
    /**
     * Unregister callbacks linked to events.
     * @param {string} [evt] - The event for which the callback[s] should be
     * unregistered. Set it to null or undefined to remove all callbacks
     * currently registered (for any event).
     * @param {Function} [fn] - The callback to unregister. If set to null
     * or undefined while the evt argument is set, all callbacks linked to that
     * event will be unregistered.
     */
    removeEventListener(evt, fn) {
        if ((0,_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(evt)) {
            this._listeners = {};
            return;
        }
        const listeners = this._listeners[evt];
        if (!Array.isArray(listeners)) {
            return;
        }
        if ((0,_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(fn)) {
            delete this._listeners[evt];
            return;
        }
        const index = listeners.indexOf(fn);
        if (index !== -1) {
            listeners.splice(index, 1);
        }
        if (listeners.length === 0) {
            delete this._listeners[evt];
        }
    }
    /**
     * Trigger every registered callbacks for a given event
     * @param {string} evt - The event to trigger
     * @param {*} arg - The eventual payload for that event. All triggered
     * callbacks will recieve this payload as argument.
     */
    trigger(evt, arg) {
        const listeners = this._listeners[evt];
        if (!Array.isArray(listeners)) {
            return;
        }
        listeners.slice().forEach((listener) => {
            try {
                listener(arg);
            }
            catch (e) {
                _log__WEBPACK_IMPORTED_MODULE_1__/* .default.error */ .Z.error(e, e instanceof Error ? e.stack :
                    null);
            }
        });
    }
}
/**
 * Simple redefinition of the fromEvent from rxjs to also work on our
 * implementation of EventEmitter with type-checked strings
 * @param {Object} target
 * @param {string} eventName
 * @returns {Observable}
 */
function fromEvent(target, eventName) {
    return new rxjs__WEBPACK_IMPORTED_MODULE_2__/* .Observable */ .y((obs) => {
        function handler(event) {
            obs.next(event);
        }
        target.addEventListener(eventName, handler);
        return () => {
            target.removeEventListener(eventName, handler);
        };
    });
}


/***/ }),

/***/ 15731:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ filterMap)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24251);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(65208);
/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(96705);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Special kind of map which will ignore the result when the value emitted
 * corresponds to a given token.
 *
 * This can also be performed through a `mergeMap` (by returning the `EMPTY`
 * Observable when we want to ignore events) but using `filterMap` is both more
 * straightforward and more performant.
 * @param {function} callback
 * @param {*} filteringToken
 * @returns {function}
 */
function filterMap(callback, filteringToken) {
    return (source) => (0,rxjs__WEBPACK_IMPORTED_MODULE_0__/* .defer */ .P)(() => {
        return source.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_1__/* .map */ .U)(callback), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_2__/* .filter */ .h)((x) => x !== filteringToken));
    });
}


/***/ }),

/***/ 7536:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ flatMap)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Map each element using a mapping function, then flat the result into
 * a new array.
 * @param {Array.<*>}originalArray
 * @param {Function}fn
 */
function flatMap(originalArray, fn) {
    /* eslint-disable @typescript-eslint/unbound-method */
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    /* eslint-disable @typescript-eslint/no-unsafe-return */
    /* eslint-disable @typescript-eslint/no-unsafe-call */
    if (typeof Array.prototype.flatMap === "function") {
        return originalArray.flatMap(fn);
    }
    /* eslint-enable @typescript-eslint/unbound-method */
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    /* eslint-enable @typescript-eslint/no-unsafe-return */
    /* eslint-enable @typescript-eslint/no-unsafe-call */
    return originalArray.reduce((acc, arg) => {
        const r = fn(arg);
        if (Array.isArray(r)) {
            acc.push(...r);
            return acc;
        }
        acc.push(r);
        return acc;
    }, []);
}


/***/ }),

/***/ 47125:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ getFuzzedDelay)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const FUZZ_FACTOR = 0.3;
/**
 * Perform "fuzzing" on the delay given.
 * @param {Number} retryDelay
 * @returns {Number}
 */
function getFuzzedDelay(retryDelay) {
    const fuzzingFactor = ((Math.random() * 2) - 1) * FUZZ_FACTOR;
    return retryDelay * (fuzzingFactor + 1); // Max 1.3 Min 0.7
}


/***/ }),

/***/ 13245:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ hashBuffer)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Convert given buffer to a 32bit integer hash
 *
 * This algorithm is the same one that Java `String.hashCode()` one which
 * is a fast hashing function adapted to short ASCII strings.
 * This consequently might not be the most adapted to buffers of various length
 * containing a various amount of data but still has the advantage of being
 * fast.
 *
 * As this function is used in persistent MediaKeySession storage, we probably
 * should keep this function somewhere as long as we want to support
 * MediaKeySessions persisted in old versions of the RxPlayer.
 *
 * @param {Array.<number>|TypedArray} buffer
 * @returns {number}
 */
function hashBuffer(buffer) {
    let hash = 0;
    let char;
    for (let i = 0; i < buffer.length; i++) {
        char = buffer[i];
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return hash;
}


/***/ }),

/***/ 14638:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ idGenerator)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/**
 * Creates an ID generator which generates an ID each time you call it.
 * @returns {Function}
 */
function idGenerator() {
    let prefix = "";
    let currId = -1;
    return function generateNewId() {
        currId++;
        if (currId >= Number.MAX_SAFE_INTEGER) {
            prefix += "0";
            currId = 0;
        }
        return prefix + String(currId);
    };
}


/***/ }),

/***/ 4938:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ isNonEmptyString)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {*} x
 * @returns {string}
 */
function isNonEmptyString(x) {
    return typeof x === "string" && x.length > 0;
}


/***/ }),

/***/ 32825:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ isNullOrUndefined)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns true if the argument given is either null or undefined.
 * This function was added to have a clearer alternative to `== null` which is
 * not always understood by newcomers to the code, and which can be overused when
 * only one of the possibility can arise.
 * @param {*} x
 * @returns {*}
 */
function isNullOrUndefined(x) {
    return x === null || x === undefined;
}


/***/ }),

/***/ 46211:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ZP": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11782);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_normalize__WEBPACK_IMPORTED_MODULE_0__/* .default */ .ZP);



/***/ }),

/***/ 11782:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ZP": () => (/* binding */ normalize),
  "iH": () => (/* binding */ normalizeAudioTrack),
  "Y1": () => (/* binding */ normalizeTextTrack)
});

// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(32825);
;// CONCATENATED MODULE: ./src/utils/languages/ISO_639-1_to_ISO_639-3.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Translate ISO 639-1 language codes into ISO 639-3 ones.
 */
const ISO_MAP_1_TO_3 = {
    aa: "aar",
    ab: "abk",
    ae: "ave",
    af: "afr",
    ak: "aka",
    am: "amh",
    an: "arg",
    ar: "ara",
    as: "asm",
    av: "ava",
    ay: "aym",
    az: "aze",
    ba: "bak",
    be: "bel",
    bg: "bul",
    bi: "bis",
    bm: "bam",
    bn: "ben",
    bo: "bod",
    br: "bre",
    bs: "bos",
    ca: "cat",
    ce: "che",
    ch: "cha",
    co: "cos",
    cr: "cre",
    cs: "ces",
    cu: "chu",
    // Old Slavonic, Old Bulgarian
    cv: "chv",
    cy: "cym",
    da: "dan",
    de: "deu",
    dv: "div",
    dz: "dzo",
    ee: "ewe",
    el: "ell",
    en: "eng",
    eo: "epo",
    es: "spa",
    et: "est",
    eu: "eus",
    fa: "fas",
    ff: "ful",
    fi: "fin",
    fj: "fij",
    fo: "fao",
    fr: "fra",
    fy: "fry",
    ga: "gle",
    gd: "gla",
    gl: "glg",
    gn: "grn",
    gu: "guj",
    gv: "glv",
    ha: "hau",
    he: "heb",
    hi: "hin",
    ho: "hmo",
    hr: "hrv",
    ht: "hat",
    hu: "hun",
    hy: "hye",
    hz: "her",
    ia: "ina",
    id: "ind",
    ie: "ile",
    ig: "ibo",
    ii: "iii",
    ik: "ipk",
    io: "ido",
    is: "isl",
    it: "ita",
    iu: "iku",
    ja: "jpn",
    jv: "jav",
    ka: "kat",
    kg: "kon",
    ki: "kik",
    kj: "kua",
    kk: "kaz",
    kl: "kal",
    km: "khm",
    kn: "kan",
    ko: "kor",
    kr: "kau",
    ks: "kas",
    ku: "kur",
    kv: "kom",
    kw: "cor",
    ky: "kir",
    la: "lat",
    lb: "ltz",
    lg: "lug",
    li: "lim",
    ln: "lin",
    lo: "lao",
    lt: "lit",
    lu: "lub",
    lv: "lav",
    mg: "mlg",
    mh: "mah",
    mi: "mri",
    mk: "mkd",
    ml: "mal",
    mn: "mon",
    mr: "mar",
    ms: "msa",
    mt: "mlt",
    my: "mya",
    na: "nau",
    nb: "nob",
    nd: "nde",
    ne: "nep",
    ng: "ndo",
    nl: "nld",
    nn: "nno",
    no: "nor",
    nr: "nbl",
    nv: "nav",
    ny: "nya",
    oc: "oci",
    oj: "oji",
    om: "orm",
    or: "ori",
    os: "oss",
    pa: "pan",
    pi: "pli",
    pl: "pol",
    ps: "pus",
    pt: "por",
    qu: "que",
    rm: "roh",
    rn: "run",
    ro: "ron",
    ru: "rus",
    rw: "kin",
    sa: "san",
    sc: "srd",
    sd: "snd",
    se: "sme",
    sg: "sag",
    si: "sin",
    sk: "slk",
    sl: "slv",
    sm: "smo",
    sn: "sna",
    so: "som",
    sq: "sqi",
    sr: "srp",
    ss: "ssw",
    st: "sot",
    su: "sun",
    sv: "swe",
    sw: "swa",
    ta: "tam",
    te: "tel",
    tg: "tgk",
    th: "tha",
    ti: "tir",
    tk: "tuk",
    tl: "tgl",
    tn: "tsn",
    to: "ton",
    tr: "tur",
    ts: "tso",
    tt: "tat",
    tw: "twi",
    ty: "tah",
    ug: "uig",
    uk: "ukr",
    ur: "urd",
    uz: "uzb",
    ve: "ven",
    vi: "vie",
    vo: "vol",
    wa: "wln",
    wo: "wol",
    xh: "xho",
    yi: "yid",
    yo: "yor",
    za: "zha",
    zh: "zho",
    zu: "zul", // Zulu
};
/* harmony default export */ const ISO_639_1_to_ISO_639_3 = (ISO_MAP_1_TO_3);

;// CONCATENATED MODULE: ./src/utils/languages/ISO_639-2_to_ISO_639-3.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Translate ISO 639-2 synonyms to their ISO 639-3 counterparts.
 */
const ISO_MAP_2_TO_3 = {
    alb: "sqi",
    arm: "hye",
    baq: "eus",
    bur: "mya",
    chi: "zho",
    cze: "ces",
    dut: "nld",
    fre: "fra",
    geo: "kat",
    ger: "deu",
    gre: "ell",
    ice: "isl",
    mac: "mkd",
    mao: "mri",
    may: "msa",
    per: "fas",
    slo: "slk",
    rum: "ron",
    tib: "bod",
    wel: "cym", // Welsh
};
/* harmony default export */ const ISO_639_2_to_ISO_639_3 = (ISO_MAP_2_TO_3);

;// CONCATENATED MODULE: ./src/utils/languages/normalize.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Normalize language given.
 * Basically:
 *   - converts it to lowercase.
 *   - normalize "base" (what is before the possible first "-") to an ISO639-3
 *     compatible string.
 * @param {string} _language
 * @returns {string}
 */
function normalizeLanguage(_language) {
    if ((0,is_null_or_undefined/* default */.Z)(_language) || _language === "") {
        return "";
    }
    const fields = ("" + _language).toLowerCase().split("-");
    const base = fields[0];
    const normalizedBase = normalizeBase(base);
    if ((0,is_non_empty_string/* default */.Z)(normalizedBase)) {
        return normalizedBase;
    }
    return _language;
}
/**
 * Normalize language into an ISO639-3 format.
 * Returns undefined if it failed to do so
 * @param {string} base
 * @returns {string}
 */
function normalizeBase(base) {
    let result;
    switch (base.length) {
        case 2:
            result = ISO_639_1_to_ISO_639_3[base];
            break;
        case 3:
            result = ISO_639_2_to_ISO_639_3[base];
            break;
    }
    return result;
}
/**
 * Normalize text track from a user given input into an object
 * with three properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - closedCaption {Boolean}: Whether the track is a closed caption track
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */
function normalizeTextTrack(_language) {
    if (!(0,is_null_or_undefined/* default */.Z)(_language)) {
        let language;
        let closedCaption = false;
        if (typeof _language === "string") {
            language = _language;
        }
        else {
            language = _language.language;
            if (_language.closedCaption === true) {
                closedCaption = true;
            }
        }
        return { language,
            closedCaption,
            normalized: normalizeLanguage(language) };
    }
    return _language;
}
/**
 * Normalize audio track from a user given input into an object
 * with the following properties:
 *   - language {string}: The language the user gave us
 *   - normalized {string}: An attempt to normalize the language into an
 *     ISO 639-3 code
 *   - audioDescription {Boolean}: Whether the track is a closed caption track
 *   - isDub {Boolean|undefined}: if true, this is a dub.
 * @param {Object|string|null|undefined} _language
 * @returns {Object|null|undefined}
 */
function normalizeAudioTrack(_language) {
    if ((0,is_null_or_undefined/* default */.Z)(_language)) {
        return _language;
    }
    if (typeof _language === "string") {
        return { language: _language,
            audioDescription: false,
            normalized: normalizeLanguage(_language) };
    }
    const normalized = {
        language: _language.language,
        audioDescription: _language.audioDescription === true,
        normalized: normalizeLanguage(normalizeLanguage(_language.language)),
    };
    if (_language.isDub === true) {
        normalized.isDub = true;
    }
    return normalized;
}
/* harmony default export */ const normalize = (normalizeLanguage);



/***/ }),

/***/ 41011:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Do nothing (but do it well).
 *
 * Having this definition here allow to use the same reference each time a noop
 * is needed.
 * Also, it allows to avoid telling eslint to ignore empty blocks everywhere.
 */
/* eslint-disable no-empty,@typescript-eslint/no-empty-function */
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() { }
/* eslint-enable no-empty, @typescript-eslint/no-empty-function */


/***/ }),

/***/ 53811:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function objectAssign(target, ...sources) {
    if (target === null || target === undefined) {
        throw new TypeError("Cannot convert undefined or null to object");
    }
    // eslint-disable-next-line  @typescript-eslint/no-unsafe-assignment
    const to = Object(target);
    for (let i = 0; i < sources.length; i++) {
        const source = sources[i];
        for (const key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
                /* eslint-disable @typescript-eslint/no-unsafe-member-access */
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                to[key] = source[key];
                /* eslint-enable @typescript-eslint/no-unsafe-member-access */
            }
        }
    }
    return to;
}
// eslint-disable-next-line @typescript-eslint/unbound-method, no-restricted-properties
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof Object.assign === "function" ?
    // eslint-disable-next-line no-restricted-properties
    Object.assign :
    // eslint-disable-next-line  @typescript-eslint/unbound-method
    objectAssign);


/***/ }),

/***/ 86293:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* unused harmony export objectValues */
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @param {Object|Array} o
 * @returns {Array.<*>}
 */
function objectValues(o) {
    return Object.keys(o).map((k) => o[k]);
}
// eslint-disable-next-line  @typescript-eslint/unbound-method, no-restricted-properties
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof Object.values === "function" ? Object.values :
    objectValues);



/***/ }),

/***/ 5068:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var pinkie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(18727);
/* harmony import */ var pinkie__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pinkie__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof Promise === "function" ? Promise :
    (pinkie__WEBPACK_IMPORTED_MODULE_0___default()));


/***/ }),

/***/ 26042:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JN": () => (/* binding */ convertToRanges),
/* harmony export */   "uH": () => (/* binding */ excludeFromRanges),
/* harmony export */   "F_": () => (/* binding */ getInnerAndOuterTimeRanges),
/* harmony export */   "L7": () => (/* binding */ getLeftSizeOfRange),
/* harmony export */   "XS": () => (/* binding */ getNextRangeGap),
/* harmony export */   "DD": () => (/* binding */ getPlayedSizeOfRange),
/* harmony export */   "rx": () => (/* binding */ getRange),
/* harmony export */   "at": () => (/* binding */ getSizeOfRange),
/* harmony export */   "kR": () => (/* binding */ insertInto),
/* harmony export */   "Ti": () => (/* binding */ isTimeInRange),
/* harmony export */   "A1": () => (/* binding */ isTimeInRanges),
/* harmony export */   "tn": () => (/* binding */ keepRangeIntersection)
/* harmony export */ });
/* unused harmony exports isAfter, isBefore, isTimeInTimeRanges, mergeContiguousRanges, removeEmptyRanges */
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file contains functions helping with TimeRanges management.
 *
 * For simplicity/performance reasons, many of those work with a simplified
 * "Range" object, which is an object with two keys:
 *   - start {Number}
 *   - end {Number}
 *
 * Those two corresponds to what is returned by the start and end methods of a
 * TimeRanges Object.
 *
 * You can convert from TimeRanges to Range object(s) with the getRange/
 * convertToRanges methods.
 */
// Factor for rounding errors
const EPSILON = 1 / 60;
/**
 * Check equality with a tolerance of EPSILON.
 * Used for various functions with this sort of tolerance regarding the
 * start/end of contiguous ranges.
 * @param {Number} a
 * @param {Number} b
 * @returns {Boolean}
 */
function nearlyEqual(a, b) {
    return Math.abs(a - b) < EPSILON;
}
/**
 * Construct a new range which will have, as start/end, the min/max
 * of both the range given, and the given bitrate.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Object}
 */
function createRangeUnion(range1, range2) {
    const start = Math.min(range1.start, range2.start);
    const end = Math.max(range1.end, range2.end);
    return { start, end };
}
/**
 * Clean array ranges from "empty" ranges.
 * That is, range objects which have their start equal to their end.
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */
function removeEmptyRanges(ranges) {
    for (let index = 0; index < ranges.length; index++) {
        const range = ranges[index];
        if (range.start === range.end) {
            ranges.splice(index--, 1);
        }
    }
    return ranges;
}
/**
 * /!\ Mutate the array of ranges.
 * @param {Array<Object>} ranges
 * @returns {Array<Object>}
 */
function mergeContiguousRanges(ranges) {
    for (let index = 1; index < ranges.length; index++) {
        const prevRange = ranges[index - 1];
        const currRange = ranges[index];
        if (areRangesNearlyContiguous(prevRange, currRange)) {
            const unionRange = createRangeUnion(prevRange, currRange);
            ranges.splice(--index, 2, unionRange);
        }
    }
    return ranges;
}
/**
 * True if range1 is considered _after_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function isAfter(range1, range2) {
    return range1.start >= range2.end;
}
/**
 * True if range1 is considered _before_ range2.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function isBefore(range1, range2) {
    return range1.end <= range2.start;
}
/**
 * Returns true if the time given can be considered as part of any of the given
 * ranges.
 * @param {Array.<Object>} ranges
 * @param {number} time
 * @returns {boolean}
 */
function isTimeInRanges(ranges, time) {
    for (let i = 0; i < ranges.length; i++) {
        if (isTimeInRange(ranges[i], time)) {
            return true;
        }
    }
    return false;
}
/**
 * Returns true if the time given can be considered as part of the given range.
 * @param {Object} range1
 * @param {Number} Time
 * @returns {Boolean}
 */
function isTimeInRange({ start, end }, time) {
    return start <= time && time < end;
}
/**
 * Returns true if the two ranges given are overlapping.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function areRangesOverlapping(range1, range2) {
    return isTimeInRange(range1, range2.start) ||
        range1.start < range2.end && range2.end < range1.end ||
        isTimeInRange(range2, range1.start);
}
/**
 * Returns true if the two ranges given can be considered contiguous.
 * @param {Object} range1
 * @param {Object} range2
 * @returns {Boolean}
 */
function areRangesNearlyContiguous(range1, range2) {
    return nearlyEqual(range2.start, range1.end) ||
        nearlyEqual(range2.end, range1.start);
}
/**
 * Convert from a TimeRanges object to an array of Ranges.
 * @param {TimeRanges} timeRanges
 * @returns {Array.<Object>}
 */
function convertToRanges(timeRanges) {
    const ranges = [];
    for (let i = 0; i < timeRanges.length; i++) {
        ranges.push({ start: timeRanges.start(i),
            end: timeRanges.end(i) });
    }
    return ranges;
}
/**
 * Get range object of a specific time in a TimeRanges object.
 * @param {TimeRanges} timeRanges
 * @returns {Object}
 */
function getRange(timeRanges, time) {
    for (let i = timeRanges.length - 1; i >= 0; i--) {
        const start = timeRanges.start(i);
        if (time >= start) {
            const end = timeRanges.end(i);
            if (time < end) {
                return { start,
                    end };
            }
        }
    }
    return null;
}
/**
 * Get gap from a specific time until the start of the next Range.
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Number}
 */
function getNextRangeGap(timeRanges, time) {
    const len = timeRanges.length;
    for (let i = 0; i < len; i++) {
        const start = timeRanges.start(i);
        if (time < start) {
            return start - time;
        }
    }
    return Infinity;
}
/**
 * @param {TimeRanges} timeRanges
 * @param {Number} time
 * @returns {Object} - Object with two properties:
 *   - outerRanges {Array.<Object>}: every ranges which does not contain the
 *     given time.
 *   - innerRange {Object|null}: the range which contain the given time.
 */
function getInnerAndOuterTimeRanges(timeRanges, time) {
    let innerRange = null;
    const outerRanges = [];
    for (let i = 0; i < timeRanges.length; i++) {
        const start = timeRanges.start(i);
        const end = timeRanges.end(i);
        if (time < start || time >= end) {
            outerRanges.push({ start, end });
        }
        else {
            innerRange = { start, end };
        }
    }
    return { outerRanges, innerRange };
}
/**
 * Get "size" (difference between end and start) of the range containing the
 * given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getSizeOfRange(timeRanges, currentTime) {
    const range = getRange(timeRanges, currentTime);
    return range !== null ? range.end - range.start :
        0;
}
/**
 * Get "currently played" (difference between time given and start) of the
 * range containing the given time. 0 if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getPlayedSizeOfRange(timeRanges, currentTime) {
    const range = getRange(timeRanges, currentTime);
    return range !== null ? currentTime - range.start :
        0;
}
/**
 * Get "left to play" (difference between end and time given) of the range
 * containing the given time. Infinity if the range is not found.
 * @param {TimeRanges} timeRanges
 * @param {Number} currentTime
 * @returns {Number}
 */
function getLeftSizeOfRange(timeRanges, currentTime) {
    const range = getRange(timeRanges, currentTime);
    return range !== null ? range.end - currentTime :
        Infinity;
}
/**
 * Insert a range object into an array of ranges objects, at the right place.
 * /!\ Mutate the array of ranges.
 * @param {Array.<Object>} ranges
 * @param {Object} rangeToAddArg
 * @returns {Array.<Object>}
 */
function insertInto(ranges, rangeToAddArg) {
    if (rangeToAddArg.start === rangeToAddArg.end) {
        return ranges;
    }
    let rangeToAdd = rangeToAddArg;
    // For each present range check if we need to:
    // - In case we are overlapping or contiguous:
    //   - if added range has the same bitrate as the overlapped or
    //     contiguous one, we can merge themcurrentRange
    //   - if added range has a different bitrate we need to insert it
    //     in place
    // - Need to insert in place, we we are completely, not overlapping
    //   and not contiguous in between two ranges.
    let index = 0;
    for (; index < ranges.length; index++) {
        const range = ranges[index];
        const overlapping = areRangesOverlapping(rangeToAdd, range);
        const contiguous = areRangesNearlyContiguous(rangeToAdd, range);
        // We assume ranges are ordered and two ranges can not be
        // completely overlapping.
        if (overlapping || contiguous) {
            rangeToAdd = createRangeUnion(rangeToAdd, range);
            ranges.splice(index--, 1);
        }
        else {
            // Check the case for which there is no more to do
            if (index === 0) {
                if (isBefore(rangeToAdd, ranges[0])) {
                    // First index, and we are completely before that range (and
                    // not contiguous, nor overlapping). We just need to be
                    // inserted here.
                    break;
                }
            }
            else {
                if (isBefore(ranges[index - 1], rangeToAdd)
                    && isBefore(rangeToAdd, range)) {
                    // We are exactly after the current previous range, and
                    // before the current range, while not overlapping with none
                    // of them. Insert here.
                    break;
                }
            }
        }
    }
    // Now that we are sure we don't overlap with any range, just add it.
    ranges.splice(index, 0, rangeToAdd);
    return mergeContiguousRanges(removeEmptyRanges(ranges));
}
/**
 * Returns range, from a range objects array overlapping with a range given
 * in argument. null if none is found.
 * @param {Object} range
 * @param {Array.<Object>} ranges
 * @returns {Array.<Object>}
 */
function findOverlappingRanges(range, ranges) {
    const resultingRanges = [];
    for (let i = 0; i < ranges.length; i++) {
        if (areRangesOverlapping(range, ranges[i])) {
            resultingRanges.push(ranges[i]);
        }
    }
    return resultingRanges;
}
/**
 * Returns only the intersection between the two ranges, from the first
 * ranges argument given.
 * @param {Array.<Range>} ranges1
 * @param {Array.<Range>} ranges2
 * @returns {Array.<Range>}
 */
function keepRangeIntersection(ranges1, ranges2) {
    const result = [];
    for (let i = 0; i < ranges1.length; i++) {
        const range = ranges1[i];
        const overlappingRanges = findOverlappingRanges(range, ranges2);
        if (overlappingRanges.length > 0) {
            for (let j = 0; j < overlappingRanges.length; j++) {
                const overlappingRange = overlappingRanges[j];
                result.push({ start: Math.max(range.start, overlappingRange.start),
                    end: Math.min(range.end, overlappingRange.end) });
            }
        }
    }
    return result;
}
/**
 * Exclude from the `baseRanges` everything that is in `rangesToExclude`.
 * Example:
 *
 * Let's say we have the following base ranges:
 *       |==========|        |===============| |======|    |==========|
 *
 * From which we want to "exclude" the following ranges:
 *          |=========| |==|        |===|  |=====|
 *
 * We will obtain the first ranges from which we remove the second ranges:
 * -----------------------------------------------------------------------
 *       |==========|        |===============| |======|    |==========|
 *          |=========| |==|        |===|  |=====|
 * _______________________________________________________________________
 *                                     |
 *                                     |
 *                                     V
 * -----------------------------------------------------------------------
 *       |==|                |======|   |==|     |====|    |==========|
 * -----------------------------------------------------------------------
 *
 * @param {Array.<Object} baseRanges
 * @param {Array.<Object} rangesToExclude
 * @return {Array.<Object>}
 */
function excludeFromRanges(baseRanges, rangesToExclude) {
    const result = [];
    // For every range in `baseRanges`, find overlapping ranges with
    // `rangesToExclude` and remove them.
    for (let i = 0; i < baseRanges.length; i++) {
        const range = baseRanges[i];
        const intersections = [];
        const overlappingRanges = findOverlappingRanges(range, rangesToExclude);
        if (overlappingRanges.length > 0) {
            for (let j = 0; j < overlappingRanges.length; j++) {
                const overlappingRange = overlappingRanges[j];
                intersections.push({ start: Math.max(range.start, overlappingRange.start),
                    end: Math.min(range.end, overlappingRange.end) });
            }
        }
        if (intersections.length === 0) {
            result.push(range);
        }
        else {
            let lastStart = range.start;
            for (let j = 0; j < intersections.length; j++) {
                if (intersections[j].start > lastStart) {
                    result.push({ start: lastStart,
                        end: intersections[j].start });
                }
                lastStart = intersections[j].end;
            }
            if (lastStart < range.end) {
                result.push({ start: lastStart,
                    end: range.end });
            }
        }
    }
    return result;
}
/**
 * Returns `true` if the given `time` is available in the TimeRanges object
 * given.
 * Returns `false` otherwise.
 * @param {TimeRanges} ranges
 * @param {Number} time
 * @returns {boolean}
 */
function isTimeInTimeRanges(ranges, time) {
    for (let i = 0; i < ranges.length; i++) {
        if (ranges.start(i) <= time && time < ranges.end(i)) {
            return true;
        }
    }
    return false;
}



/***/ }),

/***/ 99703:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "ZP": () => (/* binding */ utils_request)
});

// UNUSED EXPORTS: fetchIsSupported, fetchRequest, xhr

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(30365);
// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(86694);
// EXTERNAL MODULE: ./src/errors/request_error.ts
var request_error = __webpack_require__(13307);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(32825);
;// CONCATENATED MODULE: ./src/utils/request/xhr.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





const { DEFAULT_REQUEST_TIMEOUT } = config/* default */.Z;
const DEFAULT_RESPONSE_TYPE = "json";
/**
 * @param {string} data
 * @returns {Object|null}
 */
function toJSONForIE(data) {
    try {
        return JSON.parse(data);
    }
    catch (e) {
        return null;
    }
}
function request(options) {
    const requestOptions = {
        url: options.url,
        headers: options.headers,
        responseType: (0,is_null_or_undefined/* default */.Z)(options.responseType) ? DEFAULT_RESPONSE_TYPE :
            options.responseType,
        timeout: (0,is_null_or_undefined/* default */.Z)(options.timeout) ? DEFAULT_REQUEST_TIMEOUT :
            options.timeout,
    };
    return new Observable/* Observable */.y((obs) => {
        const { url, headers, responseType, timeout } = requestOptions;
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        if (timeout >= 0) {
            xhr.timeout = timeout;
        }
        xhr.responseType = responseType;
        if (xhr.responseType === "document") {
            xhr.overrideMimeType("text/xml");
        }
        if (!(0,is_null_or_undefined/* default */.Z)(headers)) {
            const _headers = headers;
            for (const key in _headers) {
                if (_headers.hasOwnProperty(key)) {
                    xhr.setRequestHeader(key, _headers[key]);
                }
            }
        }
        const sendingTime = performance.now();
        xhr.onerror = function onXHRError() {
            obs.error(new request_error/* default */.Z(url, xhr.status, "ERROR_EVENT", xhr));
        };
        xhr.ontimeout = function onXHRTimeout() {
            obs.error(new request_error/* default */.Z(url, xhr.status, "TIMEOUT", xhr));
        };
        if (options.sendProgressEvents === true) {
            xhr.onprogress = function onXHRProgress(event) {
                const currentTime = performance.now();
                obs.next({ type: "progress",
                    value: { url,
                        duration: currentTime - sendingTime,
                        sendingTime,
                        currentTime,
                        size: event.loaded,
                        totalSize: event.total } });
            };
        }
        xhr.onload = function onXHRLoad(event) {
            if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300) {
                    const receivedTime = performance.now();
                    const totalSize = xhr.response instanceof
                        ArrayBuffer ? xhr.response.byteLength :
                        event.total;
                    const status = xhr.status;
                    const loadedResponseType = xhr.responseType;
                    const _url = (0,is_non_empty_string/* default */.Z)(xhr.responseURL) ? xhr.responseURL :
                        url;
                    let responseData;
                    if (loadedResponseType === "json") {
                        // IE bug where response is string with responseType json
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                        responseData = typeof xhr.response === "object" ?
                            xhr.response :
                            toJSONForIE(xhr.responseText);
                    }
                    else {
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                        responseData = xhr.response;
                    }
                    if ((0,is_null_or_undefined/* default */.Z)(responseData)) {
                        obs.error(new request_error/* default */.Z(url, xhr.status, "PARSE_ERROR", xhr));
                        return;
                    }
                    obs.next({ type: "data-loaded",
                        value: { status,
                            url: _url,
                            responseType: loadedResponseType,
                            sendingTime,
                            receivedTime,
                            duration: receivedTime - sendingTime,
                            size: totalSize,
                            responseData } });
                    obs.complete();
                }
                else {
                    obs.error(new request_error/* default */.Z(url, xhr.status, "ERROR_HTTP_CODE", xhr));
                }
            }
        };
        xhr.send();
        return () => {
            if (!(0,is_null_or_undefined/* default */.Z)(xhr) && xhr.readyState !== 4) {
                xhr.abort();
            }
        };
    });
}
/* harmony default export */ const xhr = (request);

;// CONCATENATED MODULE: ./src/utils/request/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ const utils_request = (xhr);



/***/ }),

/***/ 19860:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ resolveURL),
/* harmony export */   "f": () => (/* binding */ normalizeBaseURL)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Scheme part of an url (e.g. "http://").
const schemeRe = /^(?:[a-z]+:)?\/\//i;
// Captures "/../" or "/./".
const selfDirRe = /\/\.{1,2}\//;
/**
 * Resolve self directory and previous directory references to obtain a
 * "normalized" url.
 * @example "https://foo.bar/baz/booz/../biz" => "https://foo.bar/baz/biz"
 * @param {string} url
 * @returns {string}
 */
function _normalizeUrl(url) {
    // fast path if no ./ or ../ are present in the url
    if (!selfDirRe.test(url)) {
        return url;
    }
    const newUrl = [];
    const oldUrl = url.split("/");
    for (let i = 0, l = oldUrl.length; i < l; i++) {
        if (oldUrl[i] === "..") {
            newUrl.pop();
        }
        else if (oldUrl[i] === ".") {
            continue;
        }
        else {
            newUrl.push(oldUrl[i]);
        }
    }
    return newUrl.join("/");
}
/**
 * Construct an url from the arguments given.
 * Basically:
 *   - The last arguments that contains a scheme (e.g. "http://") is the base
 *     of the url.
 *   - every subsequent string arguments are concatened to it.
 * @param {...string|undefined} args
 * @returns {string}
 */
function resolveURL(...args) {
    const len = args.length;
    if (len === 0) {
        return "";
    }
    let base = "";
    for (let i = 0; i < len; i++) {
        let part = args[i];
        if (typeof part !== "string" || part === "") {
            continue;
        }
        if (schemeRe.test(part)) {
            base = part;
        }
        else {
            // trim if begins with "/"
            if (part[0] === "/") {
                part = part.substring(1);
            }
            // trim if ends with "/"
            if (base[base.length - 1] === "/") {
                base = base.substring(0, base.length - 1);
            }
            base = base + "/" + part;
        }
    }
    return _normalizeUrl(base);
}
/**
 * Remove string after the last '/'.
 * @param {string} url
 * @returns {string}
 */
function normalizeBaseURL(url) {
    const indexOfLastSlash = url.lastIndexOf("/");
    if (indexOfLastSlash < 0) {
        return url;
    }
    if (schemeRe.test(url)) {
        const firstSlashIndex = url.indexOf("/");
        if (firstSlashIndex >= 0 && indexOfLastSlash === firstSlashIndex + 1) {
            // The "/" detected is actually the one from the protocol part of the URL
            // ("https://")
            return url;
        }
    }
    const indexOfQuestionMark = url.indexOf("?");
    if (indexOfQuestionMark >= 0 && indexOfQuestionMark < indexOfLastSlash) {
        // There are query parameters. Let's ignore them and re-run the logic
        // without
        return normalizeBaseURL(url.substring(0, indexOfQuestionMark));
    }
    return url.substring(0, indexOfLastSlash + 1);
}



/***/ }),

/***/ 85033:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ tryCatch)
/* harmony export */ });
/* harmony import */ var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55022);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @param {Function} func - A function you want to execute
 * @param {*} argsForFunc - The function's argument
 * @returns {*} - If it fails, returns a throwing Observable, else the
 * function's result (which should be, in most cases, an Observable).
 */
function tryCatch(func, argsForFunc) {
    try {
        return func(argsForFunc);
    }
    catch (e) {
        return (0,rxjs__WEBPACK_IMPORTED_MODULE_0__/* .throwError */ ._)(e);
    }
}


/***/ }),

/***/ 27140:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ startsWith)
/* harmony export */ });
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * String.prototype.startsWith ponyfill.
 * Indicates Whether a string starts with another substring.
 *
 * Inspired from MDN polyfill, but ponyfilled instead.
 * @param {string} completeString
 * @param {string} searchString
 * @param {number} [position]
 * @returns {boolean}
 */
function startsWith(completeString, searchString, position) {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    // eslint-disable-next-line no-restricted-properties
    if (typeof String.prototype.startsWith === "function") {
        // eslint-disable-next-line no-restricted-properties
        return completeString.startsWith(searchString, position);
    }
    const initialPosition = typeof position === "number" ? Math.max(position, 0) :
        0;
    return completeString.substring(initialPosition, initialPosition + searchString.length) === searchString;
}


/***/ }),

/***/ 26332:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ci": () => (/* binding */ bytesToHex),
/* harmony export */   "nr": () => (/* binding */ hexToBytes),
/* harmony export */   "tG": () => (/* binding */ strToUtf8),
/* harmony export */   "uR": () => (/* binding */ utf8ToStr),
/* harmony export */   "TZ": () => (/* binding */ strToUtf16LE),
/* harmony export */   "wV": () => (/* binding */ utf16LEToStr),
/* harmony export */   "wO": () => (/* binding */ guidToUuid),
/* harmony export */   "DM": () => (/* binding */ readNullTerminatedString)
/* harmony export */ });
/* unused harmony exports strToBeUtf16, beUtf16ToStr */
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6077);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25222);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const hasTextDecoder = typeof window === "object" &&
    typeof window.TextDecoder === "function";
const hasTextEncoder = typeof window === "object" &&
    typeof window.TextEncoder === "function";
/**
 * Convert a string to an Uint8Array containing the corresponding UTF-16 code
 * units in little-endian.
 * @param {string} str
 * @returns {Uint8Array}
 */
function strToUtf16LE(str) {
    const buffer = new ArrayBuffer(str.length * 2);
    const res = new Uint8Array(buffer);
    for (let i = 0; i < res.length; i += 2) {
        const value = str.charCodeAt(i / 2);
        res[i] = value & 0xFF;
        res[i + 1] = value >> 8 & 0xFF;
    }
    return res;
}
/**
 * Convert a string to an Uint8Array containing the corresponding UTF-16 code
 * units in little-endian.
 * @param {string} str
 * @returns {Uint8Array}
 */
function strToBeUtf16(str) {
    const buffer = new ArrayBuffer(str.length * 2);
    const res = new Uint8Array(buffer);
    for (let i = 0; i < res.length; i += 2) {
        const value = str.charCodeAt(i / 2);
        res[i + 1] = value & 0xFF;
        res[i] = value >> 8 & 0xFF;
    }
    return res;
}
/**
 * Construct string from the little-endian UTF-16 code units given.
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function utf16LEToStr(bytes) {
    if (hasTextDecoder) {
        try {
            // instanciation throws if the encoding is unsupported
            const decoder = new TextDecoder("utf-16le");
            return decoder.decode(bytes);
        }
        catch (e) {
            _log__WEBPACK_IMPORTED_MODULE_0__/* .default.warn */ .Z.warn("Utils: could not use TextDecoder to parse UTF-16LE, " +
                "fallbacking to another implementation", e);
        }
    }
    let str = "";
    for (let i = 0; i < bytes.length; i += 2) {
        str += String.fromCharCode((bytes[i + 1] << 8) + bytes[i]);
    }
    return str;
}
/**
 * Construct string from the little-endian UTF-16 code units given.
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function beUtf16ToStr(bytes) {
    if (hasTextDecoder) {
        try {
            // instanciation throws if the encoding is unsupported
            const decoder = new TextDecoder("utf-16be");
            return decoder.decode(bytes);
        }
        catch (e) {
            log.warn("Utils: could not use TextDecoder to parse UTF-16BE, " +
                "fallbacking to another implementation", e);
        }
    }
    let str = "";
    for (let i = 0; i < bytes.length; i += 2) {
        str += String.fromCharCode((bytes[i] << 8) + bytes[i + 1]);
    }
    return str;
}
/**
 * Convert a string to an Uint8Array containing the corresponding UTF-8 code
 * units.
 * @param {string} str
 * @returns {Uint8Array}
 */
function strToUtf8(str) {
    if (hasTextEncoder) {
        try {
            const encoder = new TextEncoder();
            return encoder.encode(str);
        }
        catch (e) {
            _log__WEBPACK_IMPORTED_MODULE_0__/* .default.warn */ .Z.warn("Utils: could not use TextEncoder to encode string into UTF-8, " +
                "fallbacking to another implementation", e);
        }
    }
    // http://stackoverflow.com/a/13691499 provides an ugly but functional solution.
    // (Note you have to dig deeper to understand it but I have more faith in
    // stackoverflow not going down in the future so I leave that link.)
    // Briefly said, `utf8Str` will contain a version of `str` where every
    // non-ASCII characters will be replaced by an escape sequence of the
    // corresponding representation of those characters in UTF-8.
    // It does sound weird and unnecessarily complicated, but it works!
    //
    // Here is actually what happens with more words. We will rely on two browser
    // APIs:
    //
    //   - `encodeURIComponent` will take a string and convert the non-ASCII
    //     characters in it into the percent-encoded version of the corresponding
    //     UTF-8 bytes
    //     Example: encodeURIComponent("") => 0xC3 0xA9 => `"%C3%A9"`
    //
    //   - `unescape` unescapes (so far so good) a percent-encoded string. But it
    //     does it in a really simple way: percent-encoded byte by percent-encoded
    //     byte into the corresponding extended ASCII representation on 8 bits.
    //     As a result, we end-up with a string which actually contains instead of
    //     each of its original characters, the UTF-8 code units (8 bits) of
    //     those characters.
    //     Let's take our previous `"" => "%C3%A9"` example. Here we would get:
    //     unecape("%C3%A9") => "\u00c3\u00a9" === "" (in extended ASCII)
    //
    // By iterating on the resulting string, we will then be able to generate a
    // Uint8Array containing the UTF-8 representation of that original string, by
    // just calling the charCodeAt API on it.
    let utf8Str;
    const pcStr = encodeURIComponent(str);
    // As "unescape" is a deprecated function we want to declare a fallback in the
    // case a browser decide to not implement it.
    if (typeof unescape === "function") {
        utf8Str = unescape(pcStr);
    }
    else {
        // Let's implement a simple unescape function (got to admit it was for the challenge)
        // http://ecma-international.org/ecma-262/9.0/#sec-unescape-string
        const isHexChar = /[0-9a-fA-F]/;
        const pcStrLen = pcStr.length;
        utf8Str = "";
        for (let i = 0; i < pcStr.length; i++) {
            let wasPercentEncoded = false;
            if (pcStr[i] === "%") {
                if (i <= pcStrLen - 6 &&
                    pcStr[i + 1] === "u" &&
                    isHexChar.test(pcStr[i + 2]) &&
                    isHexChar.test(pcStr[i + 3]) &&
                    isHexChar.test(pcStr[i + 4]) &&
                    isHexChar.test(pcStr[i + 5])) {
                    const charCode = parseInt(pcStr.substring(i + 1, i + 6), 16);
                    utf8Str += String.fromCharCode(charCode);
                    wasPercentEncoded = true;
                    i += 5; // Skip the next 5 chars
                }
                else if (i <= pcStrLen - 3 &&
                    isHexChar.test(pcStr[i + 1]) &&
                    isHexChar.test(pcStr[i + 2])) {
                    const charCode = parseInt(pcStr.substring(i + 1, i + 3), 16);
                    utf8Str += String.fromCharCode(charCode);
                    wasPercentEncoded = true;
                    i += 2; // Skip the next 2 chars
                }
            }
            if (!wasPercentEncoded) {
                utf8Str += pcStr[i];
            }
        }
    }
    // Now let's just build our array from every other bytes of that string's
    // UTF-16 representation
    const res = new Uint8Array(utf8Str.length);
    for (let i = 0; i < utf8Str.length; i++) {
        res[i] = utf8Str.charCodeAt(i) & 0xFF; // first byte should be 0x00 anyway
    }
    return res;
}
/**
 * Creates a new string from the given array of char codes.
 * @param {Uint8Array} args
 * @returns {string}
 */
function stringFromCharCodes(args) {
    const max = 16000;
    let ret = "";
    for (let i = 0; i < args.length; i += max) {
        const subArray = args.subarray(i, i + max);
        // NOTE: ugly I know, but TS is problematic here (you can try)
        ret += String.fromCharCode.apply(null, subArray);
    }
    return ret;
}
/**
 * Transform an integer into an hexadecimal string of the given length, padded
 * to the left with `0` if needed.
 * @example
 * ```
 * intToHex(5, 4); // => "0005"
 * intToHex(5, 2); // => "05"
 * intToHex(10, 1); // => "a"
 * intToHex(268, 3); // => "10c"
 * intToHex(4584, 6) // => "0011e8"
 * intToHex(123456, 4); // => "1e240" (we do nothing when going over 4 chars)
 * ```
 * @param {number} num
 * @param {number} size
 * @returns {string}
 */
function intToHex(num, size) {
    const toStr = num.toString(16);
    return toStr.length >= size ? toStr :
        new Array(size - toStr.length + 1).join("0") + toStr;
}
/**
 * Creates a string from the given Uint8Array containing utf-8 code units.
 * @param {Uint8Array} bytes
 * @returns {string}
 */
function utf8ToStr(data) {
    if (hasTextDecoder) {
        try {
            // TextDecoder use UTF-8 by default
            const decoder = new TextDecoder();
            return decoder.decode(data);
        }
        catch (e) {
            _log__WEBPACK_IMPORTED_MODULE_0__/* .default.warn */ .Z.warn("Utils: could not use TextDecoder to parse UTF-8, " +
                "fallbacking to another implementation", e);
        }
    }
    let uint8 = data;
    // If present, strip off the UTF-8 BOM.
    if (uint8[0] === 0xEF && uint8[1] === 0xBB && uint8[2] === 0xBF) {
        uint8 = uint8.subarray(3);
    }
    // We're basically doing strToUtf8 in reverse.
    // You can look at that other function for the whole story.
    // Generate string containing escaped UTF-8 code units
    const utf8Str = stringFromCharCodes(uint8);
    let escaped;
    if (typeof escape === "function") {
        // Transform UTF-8 escape sequence into percent-encoded escape sequences.
        escaped = escape(utf8Str);
    }
    else {
        // Let's implement a simple escape function
        // http://ecma-international.org/ecma-262/9.0/#sec-escape-string
        const nonEscapedChar = /[A-Za-z0-9*_\+-\.\/]/;
        escaped = "";
        for (let i = 0; i < utf8Str.length; i++) {
            if (nonEscapedChar.test(utf8Str[i])) {
                escaped += utf8Str[i];
            }
            else {
                const charCode = utf8Str.charCodeAt(i);
                escaped += charCode >= 256 ? "%u" + intToHex(charCode, 4) :
                    "%" + intToHex(charCode, 2);
            }
        }
    }
    // Decode the percent-encoded UTF-8 string into the proper JS string.
    // Example: "g#%E3%82%AC" -> "g#"
    return decodeURIComponent(escaped);
}
/**
 * Convert hex codes in a string form into the corresponding bytes.
 * @param {string} str
 * @returns {Uint8Array}
 * @throws TypeError - str.length is odd
 */
function hexToBytes(str) {
    const len = str.length;
    const arr = new Uint8Array(len / 2);
    for (let i = 0, j = 0; i < len; i += 2, j++) {
        arr[j] = parseInt(str.substring(i, i + 2), 16) & 0xFF;
    }
    return arr;
}
/**
 * Convert bytes into the corresponding hex string, with the possibility
 * to add a separator.
 * @param {Uint8Array} bytes
 * @param {string} [sep=""] - separator. Separate each two hex character.
 * @returns {string}
 */
function bytesToHex(bytes, sep = "") {
    let hex = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        hex += (bytes[i] >>> 4).toString(16);
        hex += (bytes[i] & 0xF).toString(16);
        if (sep.length > 0 && i < bytes.byteLength - 1) {
            hex += sep;
        }
    }
    return hex;
}
/**
 * Convert little-endian GUID into big-endian UUID.
 * @param {Uint8Array} guid
 * @returns {Uint8Array} - uuid
 * @throws AssertionError - The guid length is not 16
 */
function guidToUuid(guid) {
    (0,_assert__WEBPACK_IMPORTED_MODULE_1__/* .default */ .Z)(guid.length === 16, "GUID length should be 16");
    const p1A = guid[0];
    const p1B = guid[1];
    const p1C = guid[2];
    const p1D = guid[3];
    const p2A = guid[4];
    const p2B = guid[5];
    const p3A = guid[6];
    const p3B = guid[7];
    const uuid = new Uint8Array(16);
    // swapping byte endian on 4 bytes
    // [1, 2, 3, 4] => [4, 3, 2, 1]
    uuid[0] = p1D;
    uuid[1] = p1C;
    uuid[2] = p1B;
    uuid[3] = p1A;
    // swapping byte endian on 2 bytes
    // [5, 6] => [6, 5]
    uuid[4] = p2B;
    uuid[5] = p2A;
    // swapping byte endian on 2 bytes
    // [7, 8] => [8, 7]
    uuid[6] = p3B;
    uuid[7] = p3A;
    uuid.set(guid.subarray(8, 16), 8);
    return uuid;
}
/**
 * Decode string from bytes (UTF-8).
 * Keeps reading until it reaches a byte that equals to zero.
 * @param {Uint8Array} buffer
 * @param {number} offset
 * @returns {Object}
 */
function readNullTerminatedString(buffer, offset) {
    let position = offset;
    while (position < buffer.length) {
        const value = buffer[position];
        if (value === 0) {
            break;
        }
        position += 1;
    }
    const bytes = buffer.subarray(offset, position);
    return { end: position + 1,
        string: utf8ToStr(bytes) };
}



/***/ }),

/***/ 66365:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ takeFirstSet)
/* harmony export */ });
/* harmony import */ var _is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32825);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function takeFirstSet(...args) {
    let i = 0;
    const len = args.length;
    while (i < len) {
        const arg = args[i];
        if (!(0,_is_null_or_undefined__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(arg)) {
            return arg;
        }
        i++;
    }
    return undefined;
}


/***/ }),

/***/ 73973:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ warnOnce)
/* harmony export */ });
/* harmony import */ var _array_includes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54924);
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const WARNED_MESSAGES = [];
/**
 * Perform a console.warn only once in the application lifetime.
 *
 * Useful for deprecated messages, for example.
 *
 * @param {string} message
 */
function warnOnce(message) {
    if (!(0,_array_includes__WEBPACK_IMPORTED_MODULE_0__/* .default */ .Z)(WARNED_MESSAGES, message)) {
        // eslint-disable-next-line no-console
        console.warn(message);
        WARNED_MESSAGES.push(message);
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./node_modules/core-js/stable/index.js
var stable = __webpack_require__(74160);
// EXTERNAL MODULE: ./node_modules/regenerator-runtime/runtime.js
var runtime = __webpack_require__(33538);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(43745);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(26796);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subject.js
var Subject = __webpack_require__(81044);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/ReplaySubject.js + 4 modules
var ReplaySubject = __webpack_require__(4815);
// EXTERNAL MODULE: ./node_modules/tslib/tslib.es6.js
var tslib_es6 = __webpack_require__(10649);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = __webpack_require__(46101);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/BehaviorSubject.js
/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */




var BehaviorSubject = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(BehaviorSubject, _super);

  function BehaviorSubject(_value) {
    var _this = _super.call(this) || this;

    _this._value = _value;
    return _this;
  }

  Object.defineProperty(BehaviorSubject.prototype, "value", {
    get: function get() {
      return this.getValue();
    },
    enumerable: true,
    configurable: true
  });

  BehaviorSubject.prototype._subscribe = function (subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);

    if (subscription && !subscription.closed) {
      subscriber.next(this._value);
    }

    return subscription;
  };

  BehaviorSubject.prototype.getValue = function () {
    if (this.hasError) {
      throw this.thrownError;
    } else if (this.closed) {
      throw new ObjectUnsubscribedError/* ObjectUnsubscribedError */.N();
    } else {
      return this._value;
    }
  };

  BehaviorSubject.prototype.next = function (value) {
    _super.prototype.next.call(this, this._value = value);
  };

  return BehaviorSubject;
}(Subject/* Subject */.xQ);


// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/of.js
var of = __webpack_require__(65637);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/combineLatest.js
var combineLatest = __webpack_require__(92953);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/concat.js
var concat = __webpack_require__(70252);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/merge.js
var merge = __webpack_require__(10125);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/empty.js
var empty = __webpack_require__(47485);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeUntil.js
var takeUntil = __webpack_require__(28305);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/map.js
var map = __webpack_require__(65208);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js
var distinctUntilChanged = __webpack_require__(96078);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMap.js
var mergeMap = __webpack_require__(75688);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/shareReplay.js
var shareReplay = __webpack_require__(83425);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/multicast.js + 1 modules
var multicast = __webpack_require__(20596);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/publish.js
/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */


function publish(selector) {
  return selector ? (0,multicast/* multicast */.O)(function () {
    return new Subject/* Subject */.xQ();
  }, selector) : (0,multicast/* multicast */.O)(new Subject/* Subject */.xQ());
}
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/filter.js
var filter = __webpack_require__(96705);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/share.js
var share = __webpack_require__(32139);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/startWith.js
var startWith = __webpack_require__(5118);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/take.js
var take = __webpack_require__(53329);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mapTo.js
var mapTo = __webpack_require__(53059);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscriber.js
var Subscriber = __webpack_require__(50032);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/skipWhile.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function skipWhile(predicate) {
  return function (source) {
    return source.lift(new SkipWhileOperator(predicate));
  };
}

var SkipWhileOperator = /*@__PURE__*/function () {
  function SkipWhileOperator(predicate) {
    this.predicate = predicate;
  }

  SkipWhileOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
  };

  return SkipWhileOperator;
}();

var SkipWhileSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(SkipWhileSubscriber, _super);

  function SkipWhileSubscriber(destination, predicate) {
    var _this = _super.call(this, destination) || this;

    _this.predicate = predicate;
    _this.skipping = true;
    _this.index = 0;
    return _this;
  }

  SkipWhileSubscriber.prototype._next = function (value) {
    var destination = this.destination;

    if (this.skipping) {
      this.tryCallPredicate(value);
    }

    if (!this.skipping) {
      destination.next(value);
    }
  };

  SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
    try {
      var result = this.predicate(value, this.index++);
      this.skipping = Boolean(result);
    } catch (err) {
      this.destination.error(err);
    }
  };

  return SkipWhileSubscriber;
}(Subscriber/* Subscriber */.L);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMapTo.js
var switchMapTo = __webpack_require__(97228);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeMapTo.js
var mergeMapTo = __webpack_require__(2089);
// EXTERNAL MODULE: ./src/compat/event_listeners.ts + 4 modules
var event_listeners = __webpack_require__(90315);
;// CONCATENATED MODULE: ./src/compat/fullscreen.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Request fullScreen action on a given element.
 * @param {HTMLElement} elt
 */
function requestFullscreen(element) {
    if (!isFullscreen()) {
        const elt = element;
        /* eslint-disable @typescript-eslint/unbound-method */
        if (typeof elt.requestFullscreen === "function") {
            /* eslint-enable @typescript-eslint/unbound-method */
            /* eslint-disable @typescript-eslint/no-floating-promises */
            elt.requestFullscreen();
            /* eslint-enable @typescript-eslint/no-floating-promises */
        }
        else if (typeof elt.msRequestFullscreen === "function") {
            elt.msRequestFullscreen();
        }
        else if (typeof elt.mozRequestFullScreen === "function") {
            elt.mozRequestFullScreen();
        }
        else if (typeof elt.webkitRequestFullscreen === "function") {
            (
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            elt.webkitRequestFullscreen
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            )(Element.ALLOW_KEYBOARD_INPUT);
        }
    }
}
/**
 * Exit fullscreen if an element is currently in fullscreen.
 */
function exitFullscreen() {
    if (isFullscreen()) {
        const doc = document;
        /* eslint-disable @typescript-eslint/unbound-method */
        if (typeof doc.exitFullscreen === "function") {
            /* eslint-enable @typescript-eslint/unbound-method */
            /* eslint-disable @typescript-eslint/no-floating-promises */
            doc.exitFullscreen();
            /* eslint-enable @typescript-eslint/no-floating-promises */
        }
        else if (typeof doc.msExitFullscreen === "function") {
            doc.msExitFullscreen();
        }
        else if (typeof doc.mozCancelFullScreen === "function") {
            doc.mozCancelFullScreen();
        }
        else if (typeof doc.webkitExitFullscreen === "function") {
            doc.webkitExitFullscreen();
        }
    }
}
/**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */
function isFullscreen() {
    const doc = document;
    return (doc.fullscreenElement != null ||
        doc.mozFullScreenElement != null ||
        doc.webkitFullscreenElement != null ||
        doc.msFullscreenElement != null);
}


// EXTERNAL MODULE: ./src/compat/browser_detection.ts
var browser_detection = __webpack_require__(8886);
// EXTERNAL MODULE: ./src/log.ts + 1 modules
var log = __webpack_require__(6077);
;// CONCATENATED MODULE: ./src/compat/browser_version.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns either :
 * - 'null' when the current browser is not Firefox.
 * - '-1' when it is impossible to get the Firefox version
 * - A number above 0 that is the Firefox version number
 * @returns {number|null}
 */
function getFirefoxVersion() {
    if (!browser_detection/* isFirefox */.vU) {
        log/* default.warn */.Z.warn("Compat: Can't access Firefox version on no firefox browser.");
        return null;
    }
    const userAgent = navigator.userAgent;
    const match = /Firefox\/([0-9]+)\./.exec(userAgent);
    if (match === null) {
        return -1;
    }
    const result = parseInt(match[1], 10);
    if (isNaN(result)) {
        return -1;
    }
    return result;
}


;// CONCATENATED MODULE: ./src/compat/can_rely_on_video_visibility_and_size.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * This functions tells if the RxPlayer can trust on any browser data
 * about video element visibility and size.
 *
 * On Firefox (version >= 67) :
 * - The PIP feature exists but can be disabled by default according
 * to the OS and the channel used for updating / getting Firefox binaries.
 * - There is no API to know if the Picture-in-picture (PIP) is enabled
 * - There is no API to get the width of the PIP window
 *
 * The element clientWidth tells the width of the original video element, and
 * no PIP window API exists to determine its presence or width. Thus, there are
 * no way to determine the real width of the video window, as we can't know when
 * the PIP feature or window is enabled, and we can't have access to the windo
 * size information.
 *
 * Moreover, when the document is considered as hidden (e.g. in case of hidden
 * tab), as there is no way to know if the PIP feature or window is enabled,
 * we can't know if the video window is visible or not.
 * @returns {boolean}
 */
function canRelyOnVideoVisibilityAndSize() {
    var _a, _b;
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    if (!browser_detection/* isFirefox */.vU) {
        return true;
    }
    const firefoxVersion = getFirefoxVersion();
    if (firefoxVersion === null || firefoxVersion < 67) {
        return true;
    }
    return ((_b = (_a = HTMLVideoElement) === null || _a === void 0 ? void 0 : _a.prototype) === null || _b === void 0 ? void 0 : _b.requirePictureInPicture) !== undefined;
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
}

// EXTERNAL MODULE: ./src/config.ts
var config = __webpack_require__(86694);
// EXTERNAL MODULE: ./src/errors/error_codes.ts
var error_codes = __webpack_require__(35659);
// EXTERNAL MODULE: ./src/errors/media_error.ts
var media_error = __webpack_require__(3590);
// EXTERNAL MODULE: ./src/errors/is_known_error.ts
var is_known_error = __webpack_require__(70524);
// EXTERNAL MODULE: ./src/errors/other_error.ts
var other_error = __webpack_require__(12353);
;// CONCATENATED MODULE: ./src/errors/format_error.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/*
 * Format an unknown error into an API-defined error.
 * @param {*} error
 * @returns {Error}
 */
function formatError(error, { defaultCode, defaultReason }) {
    if ((0,is_known_error/* default */.Z)(error)) {
        return error;
    }
    const reason = error instanceof Error ? error.toString() :
        defaultReason;
    return new other_error/* default */.Z(defaultCode, reason);
}

// EXTERNAL MODULE: ./src/features/index.ts
var features = __webpack_require__(41195);
// EXTERNAL MODULE: ./src/manifest/index.ts + 5 modules
var manifest = __webpack_require__(18567);
// EXTERNAL MODULE: ./src/utils/are_arrays_of_numbers_equal.ts
var are_arrays_of_numbers_equal = __webpack_require__(90387);
// EXTERNAL MODULE: ./src/utils/event_emitter.ts
var event_emitter = __webpack_require__(61603);
// EXTERNAL MODULE: ./src/utils/is_null_or_undefined.ts
var is_null_or_undefined = __webpack_require__(32825);
// EXTERNAL MODULE: ./src/utils/noop.ts
var noop = __webpack_require__(41011);
// EXTERNAL MODULE: ./src/utils/object_assign.ts
var object_assign = __webpack_require__(53811);
// EXTERNAL MODULE: ./src/utils/promise.ts
var promise = __webpack_require__(5068);
// EXTERNAL MODULE: ./src/utils/ranges.ts
var ranges = __webpack_require__(26042);
// EXTERNAL MODULE: ./src/utils/warn_once.ts
var warn_once = __webpack_require__(73973);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/defer.js
var defer = __webpack_require__(24251);
// EXTERNAL MODULE: ./src/compat/eme/custom_media_keys/index.ts + 7 modules
var custom_media_keys = __webpack_require__(39013);
// EXTERNAL MODULE: ./src/core/eme/media_keys_infos_store.ts
var media_keys_infos_store = __webpack_require__(91132);
;// CONCATENATED MODULE: ./src/core/eme/dispose_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @param {Object} mediaKeysInfos
 * @returns {Observable}
 */
function disposeMediaKeys(mediaElement) {
    return (0,defer/* defer */.P)(() => {
        const currentState = media_keys_infos_store/* default.getState */.Z.getState(mediaElement);
        if (currentState === null) {
            return (0,of.of)(null);
        }
        log/* default.info */.Z.info("EME: Disposing of the current MediaKeys");
        const { loadedSessionsStore } = currentState;
        media_keys_infos_store/* default.clearState */.Z.clearState(mediaElement);
        return loadedSessionsStore.closeAllSessions()
            .pipe((0,mergeMapTo/* mergeMapTo */.j)((0,custom_media_keys/* setMediaKeys */.Y)(mediaElement, null)));
    });
}

;// CONCATENATED MODULE: ./src/core/eme/dispose_eme.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Free up all ressources taken by the EME management.
 */
function disposeEME(mediaElement) {
    disposeMediaKeys(mediaElement).subscribe(noop/* default */.Z);
}

;// CONCATENATED MODULE: ./src/core/eme/get_current_key_system.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the name of the current key system used.
 * @param {HTMLMediaElement} mediaElement
 * @returns {string|null}
 */
function getCurrentKeySystem(mediaElement) {
    const currentState = media_keys_infos_store/* default.getState */.Z.getState(mediaElement);
    return currentState == null ? null :
        currentState.keySystemOptions.type;
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/ignoreElements.js
var ignoreElements = __webpack_require__(61030);
;// CONCATENATED MODULE: ./src/compat/should_unset_media_keys.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns true if the mediakeys associated to a media element should be
 * unset once the content is stopped.
 * Depends on the target.
 * @returns {Boolean}
 */
function shouldUnsetMediaKeys() {
    return browser_detection/* isIE11 */.fq;
}

;// CONCATENATED MODULE: ./src/core/eme/clear_eme_session.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Clear EME ressources that should be cleared when the current content stops
 * its playback.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
function clearEMESession(mediaElement) {
    return (0,defer/* defer */.P)(() => {
        log/* default.info */.Z.info("EME: Clearing-up EME session.");
        if (shouldUnsetMediaKeys()) {
            log/* default.info */.Z.info("EME: disposing current MediaKeys.");
            return disposeMediaKeys(mediaElement)
                .pipe((0,ignoreElements/* ignoreElements */.l)());
        }
        const currentState = media_keys_infos_store/* default.getState */.Z.getState(mediaElement);
        if (currentState !== null &&
            currentState.keySystemOptions.closeSessionsOnStop === true) {
            log/* default.info */.Z.info("EME: closing all current sessions.");
            return currentState.loadedSessionsStore.closeAllSessions()
                .pipe((0,ignoreElements/* ignoreElements */.l)());
        }
        log/* default.info */.Z.info("EME: Nothing to clear. Returning right away. No state =", currentState === null);
        return empty/* EMPTY */.E;
    });
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/catchError.js
var catchError = __webpack_require__(7947);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Subscription.js + 1 modules
var Subscription = __webpack_require__(53310);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/finalize.js
/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */



function finalize(callback) {
  return function (source) {
    return source.lift(new FinallyOperator(callback));
  };
}

var FinallyOperator = /*@__PURE__*/function () {
  function FinallyOperator(callback) {
    this.callback = callback;
  }

  FinallyOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new FinallySubscriber(subscriber, this.callback));
  };

  return FinallyOperator;
}();

var FinallySubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(FinallySubscriber, _super);

  function FinallySubscriber(destination, callback) {
    var _this = _super.call(this, destination) || this;

    _this.add(new Subscription/* Subscription */.w(callback));

    return _this;
  }

  return FinallySubscriber;
}(Subscriber/* Subscriber */.L);
// EXTERNAL MODULE: ./src/utils/rx-try_catch.ts
var rx_try_catch = __webpack_require__(85033);
// EXTERNAL MODULE: ./src/utils/filter_map.ts
var filter_map = __webpack_require__(15731);
// EXTERNAL MODULE: ./src/errors/request_error.ts
var request_error = __webpack_require__(13307);
// EXTERNAL MODULE: ./src/errors/network_error.ts
var network_error = __webpack_require__(12081);
;// CONCATENATED MODULE: ./src/core/fetchers/utils/error_selector.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Generate a new error from the infos given.
 * @param {string} code
 * @param {Error} error
 * @returns {Error}
 */
function errorSelector(error) {
    if (error instanceof request_error/* default */.Z) {
        return new network_error/* default */.Z("PIPELINE_LOAD_ERROR", error);
    }
    return formatError(error, {
        defaultCode: "PIPELINE_LOAD_ERROR",
        defaultReason: "Unknown error when fetching the Manifest",
    });
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/timer.js
var timer = __webpack_require__(61106);
;// CONCATENATED MODULE: ./src/compat/is_offline.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Some browsers have a builtin API to know if it's connected at least to a
 * LAN network, at most to the internet.
 *
 * /!\ This feature can be dangerous as you can both have false positives and
 * false negatives.
 *
 * False positives:
 *   - you can still play local contents (on localhost) if isOffline == true
 *   - on some browsers isOffline might be true even if we're connected to a LAN
 *     or a router (it would mean we're just not able to connect to the
 *     Internet). So we can eventually play LAN contents if isOffline == true
 *
 * False negatives:
 *   - in some cases, we even might have isOffline at false when we do not have
 *     any connection:
 *       - in browsers that do not support the feature
 *       - in browsers running in some virtualization softwares where the
 *         network adapters are always connected.
 *
 * Use with these cases in mind.
 * @returns {Boolean}
 */
function isOffline() {
    /* eslint-disable @typescript-eslint/no-unnecessary-boolean-literal-compare */
    return navigator.onLine === false;
    /* eslint-enable @typescript-eslint/no-unnecessary-boolean-literal-compare */
}

// EXTERNAL MODULE: ./src/utils/get_fuzzed_delay.ts
var get_fuzzed_delay = __webpack_require__(47125);
;// CONCATENATED MODULE: ./src/core/fetchers/utils/try_urls_with_backoff.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Called on a loader error.
 * Returns whether the loader request should be retried.
 * @param {Error} error
 * @returns {Boolean} - If true, the request can be retried.
 */
function shouldRetry(error) {
    if (error instanceof request_error/* default */.Z) {
        if (error.type === error_codes/* NetworkErrorTypes.ERROR_HTTP_CODE */.br.ERROR_HTTP_CODE) {
            return error.status >= 500 ||
                error.status === 404 ||
                error.status === 415 || // some CDN seems to use that code when
                // requesting low-latency segments too much
                // in advance
                error.status === 412;
        }
        return error.type === error_codes/* NetworkErrorTypes.TIMEOUT */.br.TIMEOUT ||
            error.type === error_codes/* NetworkErrorTypes.ERROR_EVENT */.br.ERROR_EVENT;
    }
    return (0,is_known_error/* default */.Z)(error) && error.code === "INTEGRITY_ERROR";
}
/**
 * Returns true if we're pretty sure that the current error is due to the
 * user being offline.
 * @param {Error} error
 * @returns {Boolean}
 */
function isOfflineRequestError(error) {
    return error.type === error_codes/* NetworkErrorTypes.ERROR_EVENT */.br.ERROR_EVENT &&
        isOffline();
}
var REQUEST_ERROR_TYPES;
(function (REQUEST_ERROR_TYPES) {
    REQUEST_ERROR_TYPES[REQUEST_ERROR_TYPES["None"] = 0] = "None";
    REQUEST_ERROR_TYPES[REQUEST_ERROR_TYPES["Regular"] = 1] = "Regular";
    REQUEST_ERROR_TYPES[REQUEST_ERROR_TYPES["Offline"] = 2] = "Offline";
})(REQUEST_ERROR_TYPES || (REQUEST_ERROR_TYPES = {}));
/**
 * Guess the type of error obtained.
 * @param {*} error
 * @returns {number}
 */
function getRequestErrorType(error) {
    return error instanceof request_error/* default */.Z &&
        isOfflineRequestError(error) ? REQUEST_ERROR_TYPES.Offline :
        REQUEST_ERROR_TYPES.Regular;
}
/**
 * Specific algorithm used to perform segment and manifest requests.
 *
 * Here how it works:
 *
 *   1. we give it one or multiple URLs available for the element we want to
 *      request, the request callback and some options
 *
 *   2. it tries to call the request callback with the first URL:
 *        - if it works as expected, it wrap the response in a `response` event.
 *        - if it fails, it emits a `retry` event and try with the next one.
 *
 *   3. When all URLs have been tested (and failed), it decides - according to
 *      the error counters, configuration and errors received - if it can retry
 *      at least one of them, in the same order:
 *        - If it can, it increments the corresponding error counter, wait a
 *          delay (based on an exponential backoff) and restart the same logic
 *          for all retry-able URL.
 *        - If it can't it just throws the error.
 *
 * Note that there are in fact two separate counters:
 *   - one for "offline" errors
 *   - one for other xhr errors
 * Both counters are resetted if the error type changes from an error to the
 * next.
 * @param {Array.<string} obs$
 * @param {Function} request$
 * @param {Object} options - Configuration options.
 * @returns {Observable}
 */
function tryURLsWithBackoff(urls, request$, options) {
    const { baseDelay, maxDelay, maxRetryRegular, maxRetryOffline } = options;
    let retryCount = 0;
    let lastError = REQUEST_ERROR_TYPES.None;
    const urlsToTry = urls.slice();
    if (urlsToTry.length === 0) {
        log/* default.warn */.Z.warn("Fetchers: no URL given to `tryURLsWithBackoff`.");
        return empty/* EMPTY */.E;
    }
    return tryURLsRecursively(urlsToTry[0], 0);
    /**
     * Try to do the request of a given `url` which corresponds to the `index`
     * argument in the `urlsToTry` Array.
     *
     * If it fails try the next one.
     *
     * If all URLs fail, start a timer and retry the first element in that array
     * by following the configuration.
     *
     * @param {string|null} url
     * @param {number} index
     * @returns {Observable}
     */
    function tryURLsRecursively(url, index) {
        return request$(url).pipe((0,map/* map */.U)(res => ({ type: "response", value: res })), (0,catchError/* catchError */.K)((error) => {
            if (!shouldRetry(error)) { // ban this URL
                if (urlsToTry.length <= 1) { // This was the last one, throw
                    throw error;
                }
                // else, remove that element from the array and go the next URL
                urlsToTry.splice(index, 1);
                const newIndex = index >= urlsToTry.length - 1 ? 0 :
                    index;
                return tryURLsRecursively(urlsToTry[newIndex], newIndex)
                    .pipe((0,startWith/* startWith */.O)({ type: "retry", value: error }));
            }
            const currentError = getRequestErrorType(error);
            const maxRetry = currentError === REQUEST_ERROR_TYPES.Offline ? maxRetryOffline :
                maxRetryRegular;
            if (currentError !== lastError) {
                retryCount = 0;
                lastError = currentError;
            }
            if (index < urlsToTry.length - 1) { // there is still URLs to test
                const newIndex = index + 1;
                return tryURLsRecursively(urlsToTry[newIndex], newIndex)
                    .pipe((0,startWith/* startWith */.O)({ type: "retry", value: error }));
            }
            // Here, we were using the last element of the `urlsToTry` array.
            // Increment counter and restart with the first URL
            retryCount++;
            if (retryCount > maxRetry) {
                throw error;
            }
            const delay = Math.min(baseDelay * Math.pow(2, retryCount - 1), maxDelay);
            const fuzzedDelay = (0,get_fuzzed_delay/* default */.Z)(delay);
            const nextURL = urlsToTry[0];
            return (0,timer/* timer */.H)(fuzzedDelay).pipe((0,mergeMap/* mergeMap */.zg)(() => tryURLsRecursively(nextURL, 0)), (0,startWith/* startWith */.O)({ type: "retry", value: error }));
        }));
    }
}
/**
 * Lightweight version of the request algorithm, this time with only a simple
 * Observable given.
 * @param {Function} request$
 * @param {Object} options
 * @returns {Observable}
 */
function tryRequestObservableWithBackoff(request$, options) {
    // same than for a single unknown URL
    return tryURLsWithBackoff([null], () => request$, options);
}

;// CONCATENATED MODULE: ./src/core/fetchers/utils/create_request_scheduler.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





function createRequestScheduler(backoffOptions, warning$) {
    /**
     * Allow the parser to schedule a new request.
     * @param {Function} request - Function performing the request.
     * @returns {Function}
     */
    return function scheduleRequest(request) {
        return tryRequestObservableWithBackoff((0,rx_try_catch/* default */.Z)(request, undefined), backoffOptions).pipe((0,filter_map/* default */.Z)((evt) => {
            if (evt.type === "retry") {
                warning$.next(errorSelector(evt.value));
                return null;
            }
            return evt.value;
        }, null), (0,catchError/* catchError */.K)((error) => {
            throw errorSelector(error);
        }));
    };
}

;// CONCATENATED MODULE: ./src/core/fetchers/manifest/get_manifest_backoff_options.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { DEFAULT_MAX_MANIFEST_REQUEST_RETRY, DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE, INITIAL_BACKOFF_DELAY_BASE, MAX_BACKOFF_DELAY_BASE } = config/* default */.Z;
/**
 * Parse config to replace missing manifest backoff options.
 * @param {Object} backoffOptions
 * @returns {Object}
 */
function getManifestBackoffOptions({ maxRetryRegular, maxRetryOffline, lowLatencyMode }) {
    const baseDelay = lowLatencyMode ? INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY :
        INITIAL_BACKOFF_DELAY_BASE.REGULAR;
    const maxDelay = lowLatencyMode ? MAX_BACKOFF_DELAY_BASE.LOW_LATENCY :
        MAX_BACKOFF_DELAY_BASE.REGULAR;
    return {
        baseDelay,
        maxDelay,
        maxRetryRegular: maxRetryRegular !== undefined ? maxRetryRegular :
            DEFAULT_MAX_MANIFEST_REQUEST_RETRY,
        maxRetryOffline: maxRetryOffline !== undefined ?
            maxRetryOffline :
            DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE,
    };
}

;// CONCATENATED MODULE: ./src/core/fetchers/manifest/manifest_fetcher.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Class allowing to facilitate the task of loading and parsing a Manifest.
 * @class ManifestFetcher
 * @example
 * ```js
 * const manifestFetcher = new ManifestFetcher(manifestUrl, pipelines, options);
 * manifestFetcher.fetch().pipe(
 *   // Filter only responses (might also receive warning events)
 *   filter((evt) => evt.type === "response");
 *   // Parse the Manifest
 *   mergeMap(res => res.parse({ externalClockOffset }))
 *   // (again)
 *   filter((evt) => evt.type === "parsed");
 * ).subscribe(({ value }) => {
 *   console.log("Manifest:", value.manifest);
 * });
 * ```
 */
class ManifestFetcher {
    /**
     * @param {string | undefined} url
     * @param {Object} pipelines
     * @param {Object} backoffOptions
     */
    constructor(url, pipelines, backoffOptions) {
        this._manifestUrl = url;
        this._pipelines = pipelines.manifest;
        this._backoffOptions = getManifestBackoffOptions(backoffOptions);
    }
    /**
     * (re-)Load the Manifest without yet parsing it.
     *
     * You can set an `url` on which that Manifest will be requested.
     * If not set, the regular Manifest url - defined on the
     * `ManifestFetcher` instanciation - will be used instead.
     * @param {string} [url]
     * @returns {Observable}
     */
    fetch(url) {
        var _a;
        const requestUrl = url !== null && url !== void 0 ? url : this._manifestUrl;
        // TODO Remove the resolver completely in the next major version
        const resolver = (_a = this._pipelines.resolver) !== null && _a !== void 0 ? _a : of.of;
        const loader = this._pipelines.loader;
        return (0,rx_try_catch/* default */.Z)(resolver, { url: requestUrl }).pipe((0,catchError/* catchError */.K)((error) => {
            throw errorSelector(error);
        }), (0,mergeMap/* mergeMap */.zg)((loaderArgument) => {
            const loader$ = (0,rx_try_catch/* default */.Z)(loader, loaderArgument);
            return tryRequestObservableWithBackoff(loader$, this._backoffOptions).pipe((0,catchError/* catchError */.K)((error) => {
                throw errorSelector(error);
            }), (0,map/* map */.U)((evt) => {
                return evt.type === "retry" ?
                    ({ type: "warning", value: errorSelector(evt.value) }) :
                    ({
                        type: "response",
                        parse: (parserOptions) => {
                            return this._parseLoadedManifest(evt.value.value, parserOptions);
                        },
                    });
            }));
        }));
    }
    /**
     * Parse an already loaded Manifest.
     *
     * This method should be reserved for Manifests for which no request has been
     * done.
     * In other cases, it's preferable to go through the `fetch` method, so
     * information on the request can be used by the parsing process.
     * @param {*} manifest
     * @param {Object} parserOptions
     * @returns {Observable}
     */
    parse(manifest, parserOptions) {
        return this._parseLoadedManifest({ responseData: manifest,
            size: undefined,
            duration: undefined }, parserOptions);
    }
    /**
     * Parse a Manifest.
     *
     * @param {Object} loaded - Information about the loaded Manifest as well as
     * about the corresponding request.
     * @param {Object} parserOptions - Options used when parsing the Manifest.
     * @returns {Observable}
     */
    _parseLoadedManifest(loaded, parserOptions) {
        const { sendingTime, receivedTime } = loaded;
        const parsingTimeStart = performance.now();
        const schedulerWarnings$ = new Subject/* Subject */.xQ();
        const scheduleRequest = createRequestScheduler(this._backoffOptions, schedulerWarnings$);
        return (0,merge/* merge */.T)(schedulerWarnings$
            .pipe((0,map/* map */.U)(err => ({ type: "warning", value: err }))), this._pipelines.parser({ response: loaded,
            url: this._manifestUrl,
            externalClockOffset: parserOptions.externalClockOffset,
            previousManifest: parserOptions.previousManifest,
            scheduleRequest,
            unsafeMode: parserOptions.unsafeMode,
        }).pipe((0,catchError/* catchError */.K)((error) => {
            throw formatError(error, {
                defaultCode: "PIPELINE_PARSE_ERROR",
                defaultReason: "Unknown error when parsing the Manifest",
            });
        }), (0,map/* map */.U)((parsingEvt) => {
            if (parsingEvt.type === "warning") {
                const formatted = formatError(parsingEvt.value, {
                    defaultCode: "PIPELINE_PARSE_ERROR",
                    defaultReason: "Unknown error when parsing the Manifest",
                });
                return { type: "warning", value: formatted };
            }
            // 2 - send response
            const parsingTime = performance.now() - parsingTimeStart;
            return { type: "parsed", manifest: parsingEvt.value.manifest,
                sendingTime,
                receivedTime,
                parsingTime };
        }), finalize(() => { schedulerWarnings$.complete(); })));
    }
}

;// CONCATENATED MODULE: ./src/core/fetchers/manifest/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const fetchers_manifest = (ManifestFetcher);

;// CONCATENATED MODULE: ./src/core/fetchers/segment/get_segment_backoff_options.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR, DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE: get_segment_backoff_options_DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE, INITIAL_BACKOFF_DELAY_BASE: get_segment_backoff_options_INITIAL_BACKOFF_DELAY_BASE, MAX_BACKOFF_DELAY_BASE: get_segment_backoff_options_MAX_BACKOFF_DELAY_BASE } = config/* default */.Z;
/**
 * @param {string} bufferType
 * @param {Object}
 * @returns {Object}
 */
function getSegmentBackoffOptions(bufferType, { maxRetryRegular, maxRetryOffline, lowLatencyMode }) {
    return { maxRetryRegular: bufferType === "image" ? 0 :
            maxRetryRegular !== null && maxRetryRegular !== void 0 ? maxRetryRegular : DEFAULT_MAX_REQUESTS_RETRY_ON_ERROR,
        maxRetryOffline: maxRetryOffline !== null && maxRetryOffline !== void 0 ? maxRetryOffline : get_segment_backoff_options_DEFAULT_MAX_REQUESTS_RETRY_ON_OFFLINE, baseDelay: lowLatencyMode ? get_segment_backoff_options_INITIAL_BACKOFF_DELAY_BASE.LOW_LATENCY :
            get_segment_backoff_options_INITIAL_BACKOFF_DELAY_BASE.REGULAR,
        maxDelay: lowLatencyMode ? get_segment_backoff_options_MAX_BACKOFF_DELAY_BASE.LOW_LATENCY :
            get_segment_backoff_options_MAX_BACKOFF_DELAY_BASE.REGULAR };
}

;// CONCATENATED MODULE: ./src/core/fetchers/segment/prioritized_segment_fetcher.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * This function basically put in relation:
 *   - a SegmentFetcher, which will be used to perform the segment request
 *   - a prioritizer, which will handle the priority of a segment request
 *
 * and returns functions to fetch segments with a given priority.
 * @param {Object} prioritizer
 * @param {Object} fetcher
 * @returns {Object}
 */
function applyPrioritizerToSegmentFetcher(prioritizer, fetcher) {
    /**
     * The Observables returned by `createRequest` are not exactly the same than
     * the one created by the `ObservablePrioritizer`. Because we still have to
     * keep a handle on that value.
     */
    const taskHandlers = new WeakMap();
    return {
        /**
         * Create a Segment request with a given priority.
         * @param {Object} content - content to request
         * @param {Number} priority - priority at which the content should be requested.
         * Lower number == higher priority.
         * @returns {Observable}
         */
        createRequest(content, priority = 0) {
            const task = prioritizer.create(fetcher(content), priority);
            const flattenTask = task.pipe((0,map/* map */.U)((evt) => {
                return evt.type === "data" ? evt.value :
                    evt;
            }));
            taskHandlers.set(flattenTask, task);
            return flattenTask;
        },
        /**
         * Update the priority of a pending request, created through
         * `createRequest`.
         * @param {Observable} observable - The Observable returned by `createRequest`.
         * @param {Number} priority - The new priority value.
         */
        updatePriority(observable, priority) {
            const correspondingTask = taskHandlers.get(observable);
            if (correspondingTask === undefined) {
                log/* default.warn */.Z.warn("Fetchers: Cannot update the priority of a request: task not found.");
                return;
            }
            prioritizer.updatePriority(correspondingTask, priority);
        },
    };
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/Observable.js + 3 modules
var Observable = __webpack_require__(30365);
// EXTERNAL MODULE: ./src/utils/array_find_index.ts
var array_find_index = __webpack_require__(34612);
;// CONCATENATED MODULE: ./src/core/fetchers/segment/prioritizer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Create Observables which can be priorized between one another.
 *
 * With this class, you can link an Observables to a priority number.
 * The lower this number is, the more priority the resulting Observable will
 * have.
 *
 * Such returned Observables - called "tasks" - will then basically wait for
 * pending task with more priority (i.e. a lower priority number) to finish
 * before "starting".
 *
 * This only applies for non-pending tasks. For pending tasks, those are usually
 * not interrupted except in the following case:
 *
 * When a task with a "high priority" (which is a configurable priority
 * value) is created, pending tasks with a "low priority" (also configurable)
 * will be interrupted. Those tasks will be restarted when all tasks with a
 * higher priority are finished.
 *
 * You can also update the priority of an already-created task.
 *
 * ```js
 * const observable1 = Observable.timer(100).pipe(mapTo(1));
 * const observable2 = Observable.timer(100).pipe(mapTo(2));
 * const observable3 = Observable.timer(100).pipe(mapTo(3));
 * const observable4 = Observable.timer(100).pipe(mapTo(4));
 * const observable5 = Observable.timer(100).pipe(mapTo(5));
 *
 * // Instanciate ObservablePrioritizer.
 * // Also provide a `high` priority step - the maximum priority number a "high
 * // priority task" has and a `low` priority step - the minimum priority number
 * // a "low priority task" has.
 * const prioritizer = new ObservablePrioritizer({
 *   prioritySteps: { high: 0, low: 20 }
 * });
 *
 * const pObservable1 = prioritizer.create(observable1, 4);
 * const pObservable2 = prioritizer.create(observable2, 2);
 * const pObservable3 = prioritizer.create(observable3, 1);
 * const pObservable4 = prioritizer.create(observable4, 3);
 * const pObservable5 = prioritizer.create(observable5, 2);
 *
 * // start every Observables at the same time
 * observableMerge(
 *   pObservable1,
 *   pObservable2,
 *   pObservable3,
 *   pObservable4,
 *   pObservable5
 * ).subscribe((evt) => {
 *   if (evt.type === "data") {
 *     console.log(i);
 *
 *     // To spice things up, update pObservable1 priority to go before
 *     // pObservable4
 *     if (i === 5) { // if pObservable5 is currently emitting
 *       prioritizer.updatePriority(pObservable1, 1);
 *     }
 *   }
 * });
 *
 * // Result:
 * // 3
 * // 2
 * // 5
 * // 1
 * // 4
 *
 * // Note: here "1" goes before "4" only because the former's priority has been
 * // updated before the latter was started.
 * // It would be the other way around if not.
 * ```
 *
 * @class ObservablePrioritizer
 */
class ObservablePrioritizer {
    /**
     * @param {Options} prioritizerOptions
     */
    constructor({ prioritySteps }) {
        this._minPendingPriority = null;
        this._waitingQueue = [];
        this._pendingTasks = [];
        this._prioritySteps = prioritySteps;
        if (this._prioritySteps.high >= this._prioritySteps.low) {
            throw new Error("FP Error: the max high level priority should be given a lower" +
                "priority number than the min low priority.");
        }
    }
    /**
     * Create a priorized Observable from a base Observable.
     *
     * When subscribed to, this Observable will have its priority compared to
     * all the already-running Observables created from this class.
     *
     * Only if this number is inferior or equal to the priority of the
     * currently-running Observables will it be immediately started.
     * In the opposite case, we will wait for higher-priority Observables to
     * finish before starting it.
     *
     * Note that while this Observable is waiting for its turn, it is possible
     * to update its property through the updatePriority method, by providing
     * the Observable returned by this function and its new priority number.
     *
     * @param {Observable} obs
     * @param {number} priority
     * @returns {Observable}
     */
    create(obs, priority) {
        const pObs$ = new Observable/* Observable */.y((subscriber) => {
            let isStillSubscribed = true;
            // eslint-disable-next-line prefer-const
            let newTask;
            /**
             * Function allowing to start / interrupt the underlying Observable.
             * @param {Boolean} shouldRun - If `true`, the observable can run. If
             * `false` it means that it just needs to be interrupted if already
             * starte.
             */
            const trigger = (shouldRun) => {
                if (newTask.subscription !== null) {
                    newTask.subscription.unsubscribe();
                    newTask.subscription = null;
                    if (isStillSubscribed) {
                        subscriber.next({ type: "interrupted" });
                    }
                }
                if (!shouldRun) {
                    return;
                }
                this._minPendingPriority = this._minPendingPriority === null ?
                    newTask.priority :
                    Math.min(this._minPendingPriority, newTask.priority);
                this._pendingTasks.push(newTask);
                newTask.subscription = obs.subscribe((evt) => subscriber.next({ type: "data", value: evt }), (error) => {
                    subscriber.error(error);
                    newTask.subscription = null;
                    newTask.finished = true;
                    this._onTaskEnd(newTask);
                }, () => {
                    subscriber.next({ type: "ended" });
                    if (isStillSubscribed) {
                        subscriber.complete();
                    }
                    newTask.subscription = null;
                    newTask.finished = true;
                    this._onTaskEnd(newTask);
                });
            };
            newTask = { observable: pObs$,
                priority,
                trigger,
                subscription: null,
                finished: false };
            if (!this._canBeStartedNow(newTask)) {
                this._waitingQueue.push(newTask);
            }
            else {
                newTask.trigger(true);
                if (this._isRunningHighPriorityTasks()) {
                    // Note: we want to begin interrupting low-priority tasks just
                    // after starting the current one because the interrupting
                    // logic can call external code.
                    // This would mean re-entrancy, itself meaning that some weird
                    // half-state could be reached unless we're very careful.
                    // To be sure no harm is done, we put that code at the last
                    // possible position (the previous Observable sould be
                    // performing all its initialization synchronously).
                    this._interruptCancellableTasks();
                }
            }
            /** Callback called when this Observable is unsubscribed to. */
            return () => {
                isStillSubscribed = false;
                if (newTask.subscription !== null) {
                    newTask.subscription.unsubscribe();
                    newTask.subscription = null;
                }
                if (newTask.finished) { // Task already finished, we're good
                    return;
                }
                // remove it from waiting queue if in it
                const waitingQueueIndex = (0,array_find_index/* default */.Z)(this._waitingQueue, (elt) => elt.observable === pObs$);
                if (waitingQueueIndex >= 0) { // If it was still waiting for its turn
                    this._waitingQueue.splice(waitingQueueIndex, 1);
                }
                else {
                    // remove it from pending queue if in it
                    const pendingTasksIndex = (0,array_find_index/* default */.Z)(this._pendingTasks, (elt) => elt.observable === pObs$);
                    if (pendingTasksIndex < 0) {
                        log/* default.warn */.Z.warn("FP: unsubscribing non-existent task");
                        return;
                    }
                    const pendingTask = this._pendingTasks.splice(pendingTasksIndex, 1)[0];
                    if (this._pendingTasks.length === 0) {
                        this._minPendingPriority = null;
                        this._loopThroughWaitingQueue();
                    }
                    else if (this._minPendingPriority === pendingTask.priority) {
                        this._minPendingPriority =
                            Math.min(...this._pendingTasks.map(t => t.priority));
                        this._loopThroughWaitingQueue();
                    }
                }
            };
        });
        return pObs$;
    }
    /**
     * Update the priority of an Observable created through the `create` method.
     * @param {Observable} obs
     * @param {number} priority
     */
    updatePriority(obs, priority) {
        const waitingQueueIndex = (0,array_find_index/* default */.Z)(this._waitingQueue, (elt) => elt.observable === obs);
        if (waitingQueueIndex >= 0) { // If it was still waiting for its turn
            const waitingQueueElt = this._waitingQueue[waitingQueueIndex];
            if (waitingQueueElt.priority === priority) {
                return;
            }
            waitingQueueElt.priority = priority;
            if (!this._canBeStartedNow(waitingQueueElt)) {
                return;
            }
            this._startWaitingQueueTask(waitingQueueIndex);
            if (this._isRunningHighPriorityTasks()) {
                // Re-check to cancel every "cancellable" pending task
                //
                // Note: We start the task before interrupting cancellable tasks on
                // purpose.
                // Because both `_startWaitingQueueTask` and
                // `_interruptCancellableTasks` can emit events and thus call external
                // code, we could retrieve ourselves in a very weird state at this point
                // (for example, the different Observable priorities could all be
                // shuffled up, new Observables could have been started in the
                // meantime, etc.).
                //
                // By starting the task first, we ensure that this is manageable:
                // `_minPendingPriority` has already been updated to the right value at
                // the time we reached external code, the priority of the current
                // Observable has just been updated, and `_interruptCancellableTasks`
                // will ensure that we're basing ourselves on the last `priority` value
                // each time.
                // Doing it in the reverse order is an order of magnitude more difficult
                // to write and to reason about.
                this._interruptCancellableTasks();
            }
            return;
        }
        const pendingTasksIndex = (0,array_find_index/* default */.Z)(this._pendingTasks, (elt) => elt.observable === obs);
        if (pendingTasksIndex < 0) {
            log/* default.warn */.Z.warn("FP: request to update the priority of a non-existent task");
            return;
        }
        const task = this._pendingTasks[pendingTasksIndex];
        if (task.priority === priority) {
            return;
        }
        const prevPriority = task.priority;
        task.priority = priority;
        if (this._minPendingPriority === null || priority < this._minPendingPriority) {
            this._minPendingPriority = priority;
        }
        else if (this._minPendingPriority === prevPriority) { // was highest priority
            if (this._pendingTasks.length === 1) {
                this._minPendingPriority = priority;
            }
            else {
                this._minPendingPriority = Math.min(...this._pendingTasks.map(t => t.priority));
            }
            this._loopThroughWaitingQueue();
        }
        else {
            // We updated a task which already had a priority value higher than the
            // minimum to a value still superior to the minimum. Nothing can happen.
            return;
        }
        if (this._isRunningHighPriorityTasks()) {
            // Always interrupt cancellable tasks after all other side-effects, to
            // avoid re-entrancy issues
            this._interruptCancellableTasks();
        }
    }
    /**
     * Browse the current waiting queue and start all task in it that needs to be
     * started: start the ones with the lowest priority value below
     * `_minPendingPriority`.
     *
     * Private properties, such as `_minPendingPriority` are updated accordingly
     * while this method is called.
     */
    _loopThroughWaitingQueue() {
        const minWaitingPriority = this._waitingQueue.reduce((acc, elt) => {
            return acc === null || acc > elt.priority ? elt.priority :
                acc;
        }, null);
        if (minWaitingPriority === null ||
            (this._minPendingPriority !== null &&
                this._minPendingPriority < minWaitingPriority)) {
            return;
        }
        for (let i = 0; i < this._waitingQueue.length; i++) {
            const priorityToCheck = this._minPendingPriority === null ?
                minWaitingPriority :
                Math.min(this._minPendingPriority, minWaitingPriority);
            const elt = this._waitingQueue[i];
            if (elt.priority <= priorityToCheck) {
                this._startWaitingQueueTask(i);
                i--; // previous operation should have removed that element from the
                // the waiting queue
            }
        }
    }
    /**
     * Interrupt and move back to the waiting queue all pending tasks that are
     * low priority (having a higher priority number than
     * `this._prioritySteps.low`).
     */
    _interruptCancellableTasks() {
        for (let i = 0; i < this._pendingTasks.length; i++) {
            const pendingObj = this._pendingTasks[i];
            if (pendingObj.priority >= this._prioritySteps.low) {
                this._interruptPendingTask(pendingObj);
                // The previous call could have a lot of potential side-effects.
                // It is safer to re-start the function to not miss any pending
                // task that needs to be cancelled.
                return this._interruptCancellableTasks();
            }
        }
    }
    /**
     * Start task which is at the given index in the waiting queue.
     * The task will be removed from the waiting queue in the process.
     * @param {number} index
     */
    _startWaitingQueueTask(index) {
        const task = this._waitingQueue.splice(index, 1)[0];
        task.trigger(true);
    }
    /**
     * Move back pending task to the waiting queue and interrupt it.
     * @param {object} task
     */
    _interruptPendingTask(task) {
        const pendingTasksIndex = (0,array_find_index/* default */.Z)(this._pendingTasks, (elt) => elt.observable === task.observable);
        if (pendingTasksIndex < 0) {
            log/* default.warn */.Z.warn("FP: Interrupting a non-existent pending task. Aborting...");
            return;
        }
        // Stop task and put it back in the waiting queue
        this._pendingTasks.splice(pendingTasksIndex, 1);
        this._waitingQueue.push(task);
        if (this._pendingTasks.length === 0) {
            this._minPendingPriority = null;
        }
        else if (this._minPendingPriority === task.priority) {
            this._minPendingPriority = Math.min(...this._pendingTasks.map(t => t.priority));
        }
        task.trigger(false); // Interrupt at last step because it calls external code
    }
    /**
     * Logic ran when a task has ended (either errored or completed).
     * @param {Object} task
     */
    _onTaskEnd(task) {
        const pendingTasksIndex = (0,array_find_index/* default */.Z)(this._pendingTasks, (elt) => elt.observable === task.observable);
        if (pendingTasksIndex < 0) {
            return; // Happen for example when the task has been interrupted
        }
        this._pendingTasks.splice(pendingTasksIndex, 1);
        if (this._pendingTasks.length > 0) {
            if (this._minPendingPriority === task.priority) {
                this._minPendingPriority = Math.min(...this._pendingTasks.map(t => t.priority));
            }
            return; // still waiting for Observables to finish
        }
        this._minPendingPriority = null;
        this._loopThroughWaitingQueue();
    }
    /**
     * Return `true` if the given task can be started immediately based on its
     * priority.
     * @param {Object} task
     * @returns {boolean}
     */
    _canBeStartedNow(task) {
        return this._minPendingPriority === null ||
            task.priority <= this._minPendingPriority;
    }
    /**
     * Returns `true` if any running task is considered "high priority".
     * returns `false` otherwise.
     * @param {Object} task
     * @returns {boolean}
     */
    _isRunningHighPriorityTasks() {
        return this._minPendingPriority !== null &&
            this._minPendingPriority <= this._prioritySteps.high;
    }
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/tap.js
var tap = __webpack_require__(5842);
// EXTERNAL MODULE: ./src/utils/array_includes.ts
var array_includes = __webpack_require__(54924);
// EXTERNAL MODULE: ./src/utils/assert_unreachable.ts
var assert_unreachable = __webpack_require__(76709);
// EXTERNAL MODULE: ./src/utils/id_generator.ts
var id_generator = __webpack_require__(14638);
;// CONCATENATED MODULE: ./src/utils/initialization_segment_cache.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Caching object used to cache initialization segments.
 * This allow to have a faster representation switch and faster seeking.
 * @class InitializationSegmentCache
 */
class InitializationSegmentCache {
    constructor() {
        this._cache = new WeakMap();
    }
    /**
     * @param {Object} obj
     * @param {*} response
     */
    add({ representation, segment }, response) {
        if (segment.isInit) {
            this._cache.set(representation, response);
        }
    }
    /**
     * @param {Object} obj
     * @returns {*} response
     */
    get({ representation, segment }) {
        if (segment.isInit) {
            const value = this._cache.get(representation);
            if (value !== undefined) {
                return value;
            }
        }
        return null;
    }
}
/* harmony default export */ const initialization_segment_cache = (InitializationSegmentCache);

// EXTERNAL MODULE: ./src/utils/cast_to_observable.ts
var cast_to_observable = __webpack_require__(42121);
;// CONCATENATED MODULE: ./src/core/fetchers/segment/create_segment_loader.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/**
 * Returns a function allowing to load any wanted segment.
 *
 * The function returned takes in argument information about the wanted segment
 * and returns an Observable which will emit various events related to the
 * segment request (see ISegmentLoaderEvent).
 *
 * This observable will throw if, following the options given, the request and
 * possible retry all failed.
 *
 * This observable will complete after emitting all the segment's data.
 *
 * Type parameters:
 *   - T: type of the data emitted
 *
 * @param {Function} loader
 * @param {Object | undefined} cache
 * @param {Object} options
 * @returns {Function}
 */
function createSegmentLoader(loader, cache, backoffOptions) {
    /**
     * Try to retrieve the segment from the cache and if not found call the
     * pipeline's loader (with possible retries) to load it.
     * @param {Object} loaderArgument - Context for the wanted segment.
     * @returns {Observable}
     */
    function loadData(wantedContent) {
        /**
         * Call the Pipeline's loader with an exponential Backoff.
         * @returns {Observable}
         */
        function startLoaderWithBackoff() {
            var _a;
            const request$ = (url) => {
                const loaderArgument = (0,object_assign/* default */.Z)({ url }, wantedContent);
                return (0,concat/* concat */.z)((0,of.of)({ type: "request", value: loaderArgument }), (0,rx_try_catch/* default */.Z)(loader, loaderArgument));
            };
            return tryURLsWithBackoff((_a = wantedContent.segment.mediaURLs) !== null && _a !== void 0 ? _a : [null], request$, backoffOptions).pipe((0,catchError/* catchError */.K)((error) => {
                throw errorSelector(error);
            }), (0,map/* map */.U)((evt) => {
                if (evt.type === "retry") {
                    return { type: "warning", value: errorSelector(evt.value) };
                }
                else if (evt.value.type === "request") {
                    return evt.value;
                }
                const response = evt.value;
                if (response.type === "data-loaded" && cache != null) {
                    cache.add(wantedContent, response.value);
                }
                return evt.value;
            }));
        }
        const dataFromCache = cache != null ? cache.get(wantedContent) :
            null;
        if (dataFromCache != null) {
            return (0,cast_to_observable/* default */.Z)(dataFromCache).pipe((0,map/* map */.U)(response => ({ type: "cache", value: response })), (0,catchError/* catchError */.K)(startLoaderWithBackoff));
        }
        return startLoaderWithBackoff();
    }
    /**
     * Load the corresponding segment.
     * @param {Object} content
     * @returns {Observable}
     */
    return function loadSegment(content) {
        return loadData(content).pipe((0,mergeMap/* mergeMap */.zg)((arg) => {
            let metrics$;
            if ((arg.type === "data-chunk-complete" || arg.type === "data-loaded") &&
                arg.value.size !== undefined && arg.value.duration !== undefined) {
                metrics$ = (0,of.of)({ type: "metrics",
                    value: { size: arg.value.size,
                        duration: arg.value.duration,
                        content } });
            }
            else {
                metrics$ = empty/* EMPTY */.E;
            }
            switch (arg.type) {
                case "warning":
                case "request":
                case "progress":
                    return (0,of.of)(arg);
                case "cache":
                case "data-created":
                case "data-loaded":
                    return (0,concat/* concat */.z)((0,of.of)({ type: "data", value: arg.value }), metrics$);
                case "data-chunk":
                    return (0,of.of)({ type: "chunk", value: arg.value });
                case "data-chunk-complete":
                    return (0,concat/* concat */.z)((0,of.of)({ type: "chunk-complete", value: null }), metrics$);
                default:
                    (0,assert_unreachable/* default */.Z)(arg);
            }
        }));
    };
}

;// CONCATENATED MODULE: ./src/core/fetchers/segment/segment_fetcher.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








const generateRequestID = (0,id_generator/* default */.Z)();
/**
 * Create a function which will fetch and parse segments.
 * @param {string} bufferType
 * @param {Object} transport
 * @param {Subject} requests$
 * @param {Object} options
 * @returns {Function}
 */
function createSegmentFetcher(bufferType, transport, requests$, options) {
    const cache = (0,array_includes/* default */.Z)(["audio", "video"], bufferType) ?
        new initialization_segment_cache() :
        undefined;
    const segmentLoader = createSegmentLoader(transport[bufferType].loader, cache, options);
    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const segmentParser = transport[bufferType].parser; // deal with it
    /**
     * Process the segmentLoader observable to adapt it to the the rest of the
     * code:
     *   - use the requests subject for network requests and their progress
     *   - use the warning$ subject for retries' error messages
     *   - only emit the data
     * @param {Object} content
     * @returns {Observable}
     */
    return function fetchSegment(content) {
        const id = generateRequestID();
        let requestBeginSent = false;
        return segmentLoader(content).pipe((0,tap/* tap */.b)((arg) => {
            switch (arg.type) {
                case "metrics": {
                    requests$.next(arg);
                    break;
                }
                case "request": {
                    const { value } = arg;
                    // format it for ABR Handling
                    const segment = value.segment;
                    if (segment === undefined) {
                        return;
                    }
                    requestBeginSent = true;
                    requests$.next({ type: "requestBegin",
                        value: { duration: segment.duration,
                            time: segment.time,
                            requestTimestamp: performance.now(),
                            id } });
                    break;
                }
                case "progress": {
                    const { value } = arg;
                    if (value.totalSize != null && value.size < value.totalSize) {
                        requests$.next({ type: "progress",
                            value: { duration: value.duration,
                                size: value.size,
                                totalSize: value.totalSize,
                                timestamp: performance.now(),
                                id } });
                    }
                    break;
                }
            }
        }), finalize(() => {
            if (requestBeginSent) {
                requests$.next({ type: "requestEnd", value: { id } });
            }
        }), (0,filter/* filter */.h)((e) => {
            switch (e.type) {
                case "warning":
                case "chunk":
                case "chunk-complete":
                case "data":
                    return true;
                case "progress":
                case "metrics":
                case "request":
                    return false;
                default:
                    (0,assert_unreachable/* default */.Z)(e);
            }
        }), (0,mergeMap/* mergeMap */.zg)((evt) => {
            if (evt.type === "warning") {
                return (0,of.of)(evt);
            }
            if (evt.type === "chunk-complete") {
                return (0,of.of)({ type: "chunk-complete" });
            }
            const isChunked = evt.type === "chunk";
            const data = {
                type: "chunk",
                /**
                 * Parse the loaded data.
                 * @param {Object} [initTimescale]
                 * @returns {Observable}
                 */
                parse(initTimescale) {
                    const response = { data: evt.value.responseData, isChunked };
                    /* eslint-disable @typescript-eslint/no-unsafe-call */
                    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
                    /* eslint-disable @typescript-eslint/no-unsafe-return */
                    return segmentParser({ response, initTimescale, content })
                        /* eslint-enable @typescript-eslint/no-unsafe-call */
                        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
                        /* eslint-enable @typescript-eslint/no-unsafe-return */
                        .pipe((0,catchError/* catchError */.K)((error) => {
                        throw formatError(error, { defaultCode: "PIPELINE_PARSE_ERROR",
                            defaultReason: "Unknown parsing error" });
                    }));
                },
            };
            if (isChunked) {
                return (0,of.of)(data);
            }
            return (0,concat/* concat */.z)((0,of.of)(data), (0,of.of)({ type: "chunk-complete" }));
        }), (0,share/* share */.B)() // avoid multiple side effects if multiple subs
        );
    };
}

;// CONCATENATED MODULE: ./src/core/fetchers/segment/segment_fetcher_creator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





const { MIN_CANCELABLE_PRIORITY, MAX_HIGH_PRIORITY_LEVEL } = config/* default */.Z;
/**
 * Interact with the transport pipelines to download segments with the right
 * priority.
 *
 * @class SegmentFetcherCreator
 *
 * @example
 * ```js
 * const creator = new SegmentFetcherCreator(transport);
 *
 * // 2 - create a new fetcher with its backoff options
 * const fetcher = creator.createSegmentFetcher("audio", {
 *   maxRetryRegular: Infinity,
 *   maxRetryOffline: Infinity,
 * });
 *
 * // 3 - load a segment with a given priority
 * fetcher.createRequest(myContent, 1)
 *   // 4 - parse it
 *   .pipe(
 *     filter(evt => evt.type === "chunk"),
 *     mergeMap(response => response.parse());
 *   )
 *   // 5 - use it
 *   .subscribe((res) => console.log("audio chunk downloaded:", res));
 * ```
 */
class SegmentFetcherCreator {
    /**
     * @param {Object} transport
     */
    constructor(transport, options) {
        this._transport = transport;
        this._prioritizer = new ObservablePrioritizer({
            prioritySteps: { high: MAX_HIGH_PRIORITY_LEVEL,
                low: MIN_CANCELABLE_PRIORITY },
        });
        this._backoffOptions = options;
    }
    /**
     * Create a segment fetcher, allowing to easily perform segment requests.
     * @param {string} bufferType - The type of buffer concerned (e.g. "audio",
     * "video", etc.)
     * @param {Subject} requests$ - Subject through which request-related events
     * (such as those needed by the ABRManager) will be sent.
     * @returns {Object}
     */
    createSegmentFetcher(bufferType, requests$) {
        const backoffOptions = getSegmentBackoffOptions(bufferType, this._backoffOptions);
        const segmentFetcher = createSegmentFetcher(bufferType, this._transport, requests$, backoffOptions);
        return applyPrioritizerToSegmentFetcher(this._prioritizer, segmentFetcher);
    }
}

;// CONCATENATED MODULE: ./src/core/fetchers/segment/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const segment = (SegmentFetcherCreator);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/innerSubscribe.js
var innerSubscribe = __webpack_require__(90789);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/mergeScan.js
/** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */


function mergeScan(accumulator, seed, concurrent) {
  if (concurrent === void 0) {
    concurrent = Number.POSITIVE_INFINITY;
  }

  return function (source) {
    return source.lift(new MergeScanOperator(accumulator, seed, concurrent));
  };
}

var MergeScanOperator = /*@__PURE__*/function () {
  function MergeScanOperator(accumulator, seed, concurrent) {
    this.accumulator = accumulator;
    this.seed = seed;
    this.concurrent = concurrent;
  }

  MergeScanOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
  };

  return MergeScanOperator;
}();



var MergeScanSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(MergeScanSubscriber, _super);

  function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
    var _this = _super.call(this, destination) || this;

    _this.accumulator = accumulator;
    _this.acc = acc;
    _this.concurrent = concurrent;
    _this.hasValue = false;
    _this.hasCompleted = false;
    _this.buffer = [];
    _this.active = 0;
    _this.index = 0;
    return _this;
  }

  MergeScanSubscriber.prototype._next = function (value) {
    if (this.active < this.concurrent) {
      var index = this.index++;
      var destination = this.destination;
      var ish = void 0;

      try {
        var accumulator = this.accumulator;
        ish = accumulator(this.acc, value, index);
      } catch (e) {
        return destination.error(e);
      }

      this.active++;

      this._innerSub(ish);
    } else {
      this.buffer.push(value);
    }
  };

  MergeScanSubscriber.prototype._innerSub = function (ish) {
    var innerSubscriber = new innerSubscribe/* SimpleInnerSubscriber */.IY(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = (0,innerSubscribe/* innerSubscribe */.ft)(ish, innerSubscriber);

    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };

  MergeScanSubscriber.prototype._complete = function () {
    this.hasCompleted = true;

    if (this.active === 0 && this.buffer.length === 0) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }

      this.destination.complete();
    }

    this.unsubscribe();
  };

  MergeScanSubscriber.prototype.notifyNext = function (innerValue) {
    var destination = this.destination;
    this.acc = innerValue;
    this.hasValue = true;
    destination.next(innerValue);
  };

  MergeScanSubscriber.prototype.notifyComplete = function () {
    var buffer = this.buffer;
    this.active--;

    if (buffer.length > 0) {
      this._next(buffer.shift());
    } else if (this.active === 0 && this.hasCompleted) {
      if (this.hasValue === false) {
        this.destination.next(this.acc);
      }

      this.destination.complete();
    }
  };

  return MergeScanSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds);


// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/from.js + 6 modules
var from = __webpack_require__(41981);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/exhaustMap.js
/** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */




function exhaustMap(project, resultSelector) {
  if (resultSelector) {
    return function (source) {
      return source.pipe(exhaustMap(function (a, i) {
        return (0,from/* from */.D)(project(a, i)).pipe((0,map/* map */.U)(function (b, ii) {
          return resultSelector(a, b, i, ii);
        }));
      }));
    };
  }

  return function (source) {
    return source.lift(new ExhaustMapOperator(project));
  };
}

var ExhaustMapOperator = /*@__PURE__*/function () {
  function ExhaustMapOperator(project) {
    this.project = project;
  }

  ExhaustMapOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
  };

  return ExhaustMapOperator;
}();

var ExhaustMapSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(ExhaustMapSubscriber, _super);

  function ExhaustMapSubscriber(destination, project) {
    var _this = _super.call(this, destination) || this;

    _this.project = project;
    _this.hasSubscription = false;
    _this.hasCompleted = false;
    _this.index = 0;
    return _this;
  }

  ExhaustMapSubscriber.prototype._next = function (value) {
    if (!this.hasSubscription) {
      this.tryNext(value);
    }
  };

  ExhaustMapSubscriber.prototype.tryNext = function (value) {
    var result;
    var index = this.index++;

    try {
      result = this.project(value, index);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.hasSubscription = true;

    this._innerSub(result);
  };

  ExhaustMapSubscriber.prototype._innerSub = function (result) {
    var innerSubscriber = new innerSubscribe/* SimpleInnerSubscriber */.IY(this);
    var destination = this.destination;
    destination.add(innerSubscriber);
    var innerSubscription = (0,innerSubscribe/* innerSubscribe */.ft)(result, innerSubscriber);

    if (innerSubscription !== innerSubscriber) {
      destination.add(innerSubscription);
    }
  };

  ExhaustMapSubscriber.prototype._complete = function () {
    this.hasCompleted = true;

    if (!this.hasSubscription) {
      this.destination.complete();
    }

    this.unsubscribe();
  };

  ExhaustMapSubscriber.prototype.notifyNext = function (innerValue) {
    this.destination.next(innerValue);
  };

  ExhaustMapSubscriber.prototype.notifyError = function (err) {
    this.destination.error(err);
  };

  ExhaustMapSubscriber.prototype.notifyComplete = function () {
    this.hasSubscription = false;

    if (this.hasCompleted) {
      this.destination.complete();
    }
  };

  return ExhaustMapSubscriber;
}(innerSubscribe/* SimpleOuterSubscriber */.Ds);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/switchMap.js
var switchMap = __webpack_require__(17568);
;// CONCATENATED MODULE: ./src/compat/should_reload_media_source_on_decipherability_update.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Returns true if we have to reload the MediaSource due to an update in the
 * decipherability status of some segments based on the current key sytem.
 *
 * We found that on all Widevine targets tested, a simple seek is sufficient.
 * As widevine clients make a good chunk of users, we can make a difference
 * between them and others as it is for the better.
 * @param {string|null} currentKeySystem
 * @returns {Boolean}
 */
function shouldReloadMediaSourceOnDecipherabilityUpdate(currentKeySystem) {
    return currentKeySystem === null ||
        currentKeySystem.indexOf("widevine") < 0;
}

// EXTERNAL MODULE: ./src/utils/defer_subscriptions.ts + 6 modules
var defer_subscriptions = __webpack_require__(45150);
// EXTERNAL MODULE: ./src/utils/take_first_set.ts
var take_first_set = __webpack_require__(66365);
;// CONCATENATED MODULE: ./src/core/abr/ewma.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Tweaked implementation of an exponential weighted Moving Average.
 * Heavily "inspired" from the shaka-player one (Ewma).
 * @class EWMA
 */
class EWMA {
    /**
     * @param {number} halfLife
     */
    constructor(halfLife) {
        // (half-life = log(1/2) / log(Decay Factor)
        this._alpha = Math.exp(Math.log(0.5) / halfLife);
        this._lastEstimate = 0;
        this._totalWeight = 0;
    }
    /**
     * @param {number} weight
     * @param {number} value
     */
    addSample(weight, value) {
        const adjAlpha = Math.pow(this._alpha, weight);
        const newEstimate = value * (1 - adjAlpha) +
            adjAlpha * this._lastEstimate;
        if (!isNaN(newEstimate)) {
            this._lastEstimate = newEstimate;
            this._totalWeight += weight;
        }
    }
    /**
     * @returns {number} value
     */
    getEstimate() {
        const zeroFactor = 1 - Math.pow(this._alpha, this._totalWeight);
        return this._lastEstimate / zeroFactor;
    }
}

;// CONCATENATED MODULE: ./src/core/abr/bandwidth_estimator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const { ABR_MINIMUM_TOTAL_BYTES, ABR_MINIMUM_CHUNK_SIZE, ABR_FAST_EMA, ABR_SLOW_EMA } = config/* default */.Z;
/**
 * Calculate a mean bandwidth based on the bytes downloaded and the amount
 * of time needed to do so.
 *
 * Heavily "inspired" from the Shaka-Player's "ewma bandwidth estimator".
 * @class BandwidthEstimator
 */
class BandwidthEstimator {
    constructor() {
        /**
         * A fast-moving average.
         * @private
         */
        this._fastEWMA = new EWMA(ABR_FAST_EMA);
        /**
         * A slow-moving average.
         * @private
         */
        this._slowEWMA = new EWMA(ABR_SLOW_EMA);
        /**
         * Number of bytes sampled.
         * @private
         */
        this._bytesSampled = 0;
    }
    /**
     * Takes a bandwidth sample.
     * @param {number} durationMs - The amount of time, in milliseconds, for a
     *   particular request.
     * @param {number} numBytes - The total number of bytes transferred in that
     *   request.
     */
    addSample(durationInMs, numberOfBytes) {
        if (numberOfBytes < ABR_MINIMUM_CHUNK_SIZE) {
            return;
        }
        const bandwidth = numberOfBytes * 8000 / durationInMs;
        const weight = durationInMs / 1000;
        this._bytesSampled += numberOfBytes;
        this._fastEWMA.addSample(weight, bandwidth);
        this._slowEWMA.addSample(weight, bandwidth);
    }
    /**
     * Get estimate of the bandwidth, in bits per seconds.
     * @returns {Number|undefined}
     */
    getEstimate() {
        if (this._bytesSampled < ABR_MINIMUM_TOTAL_BYTES) {
            return undefined;
        }
        // Take the minimum of these two estimates.  This should have the effect of
        // adapting down quickly, but up more slowly.
        return Math.min(this._fastEWMA.getEstimate(), this._slowEWMA.getEstimate());
    }
    /**
     * Reset the bandwidth estimation.
     */
    reset() {
        this._fastEWMA = new EWMA(ABR_FAST_EMA);
        this._slowEWMA = new EWMA(ABR_SLOW_EMA);
        this._bytesSampled = 0;
    }
}

;// CONCATENATED MODULE: ./src/core/abr/create_filters.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Create Observable that merge several throttling Observables into one.
 * @param {Observable} limitWidth$ - Emit the width at which the chosen
 * Representation should be limited.
 * @param {Observable} throttleBitrate$ - Emit the maximum bitrate authorized.
 * @param {Observable} throttle$ - Also emit the maximum bitrate authorized.
 * Here for legacy reasons.
 * @returns {Observable}
 */
function createFilters(limitWidth$, throttleBitrate$, throttle$) {
    const deviceEventsArray = [];
    if (limitWidth$ != null) {
        deviceEventsArray.push(limitWidth$.pipe((0,map/* map */.U)(width => ({ width }))));
    }
    if (throttle$ != null) {
        deviceEventsArray.push(throttle$.pipe((0,map/* map */.U)(bitrate => ({ bitrate }))));
    }
    if (throttleBitrate$ != null) {
        deviceEventsArray.push(throttleBitrate$.pipe((0,map/* map */.U)(bitrate => ({ bitrate }))));
    }
    // Emit restrictions on the pools of available representations to choose
    // from.
    return deviceEventsArray.length > 0 ?
        (0,combineLatest/* combineLatest */.aj)(deviceEventsArray)
            .pipe((0,map/* map */.U)((args) => (0,object_assign/* default */.Z)({}, ...args))) :
        (0,of.of)({});
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/OuterSubscriber.js
var OuterSubscriber = __webpack_require__(6965);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/subscribeToResult.js + 1 modules
var subscribeToResult = __webpack_require__(81173);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/withLatestFrom.js
/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */



function withLatestFrom() {
  var args = [];

  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }

  return function (source) {
    var project;

    if (typeof args[args.length - 1] === 'function') {
      project = args.pop();
    }

    var observables = args;
    return source.lift(new WithLatestFromOperator(observables, project));
  };
}

var WithLatestFromOperator = /*@__PURE__*/function () {
  function WithLatestFromOperator(observables, project) {
    this.observables = observables;
    this.project = project;
  }

  WithLatestFromOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
  };

  return WithLatestFromOperator;
}();

var WithLatestFromSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(WithLatestFromSubscriber, _super);

  function WithLatestFromSubscriber(destination, observables, project) {
    var _this = _super.call(this, destination) || this;

    _this.observables = observables;
    _this.project = project;
    _this.toRespond = [];
    var len = observables.length;
    _this.values = new Array(len);

    for (var i = 0; i < len; i++) {
      _this.toRespond.push(i);
    }

    for (var i = 0; i < len; i++) {
      var observable = observables[i];

      _this.add((0,subscribeToResult/* subscribeToResult */.D)(_this, observable, undefined, i));
    }

    return _this;
  }

  WithLatestFromSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
    this.values[outerIndex] = innerValue;
    var toRespond = this.toRespond;

    if (toRespond.length > 0) {
      var found = toRespond.indexOf(outerIndex);

      if (found !== -1) {
        toRespond.splice(found, 1);
      }
    }
  };

  WithLatestFromSubscriber.prototype.notifyComplete = function () {};

  WithLatestFromSubscriber.prototype._next = function (value) {
    if (this.toRespond.length === 0) {
      var args = [value].concat(this.values);

      if (this.project) {
        this._tryProject(args);
      } else {
        this.destination.next(args);
      }
    }
  };

  WithLatestFromSubscriber.prototype._tryProject = function (args) {
    var result;

    try {
      result = this.project.apply(this, args);
    } catch (err) {
      this.destination.error(err);
      return;
    }

    this.destination.next(result);
  };

  return WithLatestFromSubscriber;
}(OuterSubscriber/* OuterSubscriber */.L);
;// CONCATENATED MODULE: ./src/core/abr/get_buffer_levels.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Return "Buffer Levels" which are steps of available buffers from which we
 * are normally able switch safely to the next available bitrate.
 * (Following an algorithm close to BOLA)
 * @param {Array.<number>} bitrates - All available bitrates, __sorted__ in
 * ascending order.
 * @returns {Array.<number>}
 */
function getBufferLevels(bitrates) {
    const logs = bitrates.map((b) => Math.log(b / bitrates[0]));
    const utilities = logs.map(l => l - logs[0] + 1); // normalize
    const gp = (utilities[utilities.length - 1] - 1) / ((bitrates.length * 2) + 10);
    const Vp = 1 / gp;
    return bitrates.map((_, i) => minBufferLevelForBitrate(i));
    /**
     * Get minimum buffer we should keep ahead to pick this bitrate.
     * @param {number} index
     * @returns {number}
     */
    function minBufferLevelForBitrate(index) {
        if (index === 0) {
            return 0;
        }
        const boundedIndex = Math.min(Math.max(1, index), bitrates.length - 1);
        return Vp * (gp + (bitrates[boundedIndex] * utilities[boundedIndex - 1] -
            bitrates[boundedIndex - 1] * utilities[boundedIndex]) / (bitrates[boundedIndex] -
            bitrates[boundedIndex - 1])) + 4;
    }
}

;// CONCATENATED MODULE: ./src/core/abr/get_estimate_from_buffer_levels.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * From the buffer gap, choose a representation.
 * @param {Object} clockTick
 * @param {Array.<Number>} bitrates
 * @param {Array.<Number>} bufferLevels
 * @returns {Object|undefined}
 */
function getEstimateFromBufferLevels(clockTick, bitrates, bufferLevels) {
    const { bufferGap, currentBitrate, currentScore, speed } = clockTick;
    if (currentBitrate == null) {
        return bitrates[0];
    }
    const currentBitrateIndex = (0,array_find_index/* default */.Z)(bitrates, b => b === currentBitrate);
    if (currentBitrateIndex < 0 || bitrates.length !== bufferLevels.length) {
        log/* default.error */.Z.error("ABR: Current Bitrate not found in the calculated levels");
        return bitrates[0];
    }
    let scaledScore;
    if (currentScore != null) {
        scaledScore = speed === 0 ? currentScore : (currentScore / speed);
    }
    if (scaledScore != null && scaledScore > 1) {
        const currentBufferLevel = bufferLevels[currentBitrateIndex];
        const nextIndex = (() => {
            for (let i = currentBitrateIndex + 1; i < bufferLevels.length; i++) {
                if (bufferLevels[i] > currentBufferLevel) {
                    return i;
                }
            }
        })();
        if (nextIndex != null) {
            const nextBufferLevel = bufferLevels[nextIndex];
            if (bufferGap >= nextBufferLevel) {
                return bitrates[nextIndex];
            }
        }
    }
    if (scaledScore == null || scaledScore < 1.15) {
        const currentBufferLevel = bufferLevels[currentBitrateIndex];
        if (bufferGap < currentBufferLevel) {
            for (let i = currentBitrateIndex - 1; i >= 0; i--) {
                if (bitrates[i] < currentBitrate) {
                    return bitrates[i];
                }
            }
            return currentBitrate;
        }
    }
    return currentBitrate;
}

;// CONCATENATED MODULE: ./src/core/abr/buffer_based_chooser.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Choose a bitrate based on the currently available buffer.
 *
 * This algorithm is based on the deviation of the BOLA algorithm.
 * It is a hybrid solution that also relies on a given bitrate's
 * "maintainability".
 * Each time a chunk is downloaded, from the ratio between the chunk duration
 * and chunk's request time, we can assume that the representation is
 * "maintanable" or not.
 * If so, we may switch to a better quality, or conversely to a worse quality.
 *
 * @param {Observable} update$
 * @param {Array.<number>} bitrates
 * @returns {Observable}
 */
function BufferBasedChooser(update$, bitrates) {
    const levelsMap = getBufferLevels(bitrates);
    log/* default.debug */.Z.debug("ABR: Steps for buffer based chooser.", levelsMap.map((l, i) => ({ bufferLevel: l, bitrate: bitrates[i] })));
    return update$.pipe((0,map/* map */.U)((clockTick) => {
        return getEstimateFromBufferLevels(clockTick, bitrates, levelsMap);
    }));
}

;// CONCATENATED MODULE: ./src/core/abr/cached_segment_detector.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { CACHE_LOAD_DURATION_THRESHOLDS } = config/* default */.Z;
/**
 * From segment download duration, tells if a segment
 * may have been loaded from cache.
 * @param {string} contentType
 * @param {number} downloadDuration
 */
function mayBeFromCache(contentType, downloadDuration) {
    const cacheLoadDurationThreshold = CACHE_LOAD_DURATION_THRESHOLDS[contentType];
    return downloadDuration < cacheLoadDurationThreshold;
}
/**
 * Returns a function used to determine if a segment was loaded
 * from cache or not.
 * @returns {function}
 */
function generateCachedSegmentDetector() {
    let hasAlreadyLoadedNonCachedContent = false;
    /**
     * Determines with request duration if a loaded chunk may have been loaded
     * from cache, and return true if should ignore the metrics for representation
     * chooser.
     * @param {Object} content
     * @param {number} duration
     * @returns {boolean}
     */
    return function shouldIgnoreMetrics(content, downloadDuration) {
        const contentType = content.adaptation.type;
        if (contentType === "text" || contentType === "image") {
            return false;
        }
        const segmentMayBeFromCache = mayBeFromCache(contentType, downloadDuration);
        if (segmentMayBeFromCache && hasAlreadyLoadedNonCachedContent) {
            // We already loaded not cached segments.
            // Do not consider cached segments anymore.
            return true;
        }
        if (!segmentMayBeFromCache && !hasAlreadyLoadedNonCachedContent) {
            // First segment not loaded from cache.
            hasAlreadyLoadedNonCachedContent = true;
        }
        return false;
    };
}

;// CONCATENATED MODULE: ./src/core/abr/filter_by_bitrate.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Get only representations lower or equal to a given bitrate.
 * If no representation is lower than the given bitrate, returns an array containing
 * all Representation(s) with the lowest available bitrate.
 * @param {Array.<Object>} representations - All Representations available
 * @param {Number} bitrate
 * @returns {Array.<Object>}
 */
function filterByBitrate(representations, bitrate) {
    if (representations.length === 0) {
        return [];
    }
    representations.sort((ra, rb) => ra.bitrate - rb.bitrate);
    const minimumBitrate = representations[0].bitrate;
    const bitrateCeil = Math.max(bitrate, minimumBitrate);
    const firstSuperiorBitrateIndex = (0,array_find_index/* default */.Z)(representations, (representation) => representation.bitrate > bitrateCeil);
    if (firstSuperiorBitrateIndex === -1) {
        return representations; // All representations have lower bitrates.
    }
    return representations.slice(0, firstSuperiorBitrateIndex);
}

// EXTERNAL MODULE: ./src/utils/array_find.ts
var array_find = __webpack_require__(23437);
;// CONCATENATED MODULE: ./src/core/abr/filter_by_width.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Filter representations based on their width:
 *   - the highest width considered will be the one linked to the first
 *     representation which has a superior width to the one given.
 * @param {Array.<Object>} representations - The representations array
 * @param {Number} width
 * @returns {Array.<Object>}
 */
function filterByWidth(representations, width) {
    const sortedRepsByWidth = representations
        .slice() // clone
        .sort((a, b) => (0,take_first_set/* default */.Z)(a.width, 0) -
        (0,take_first_set/* default */.Z)(b.width, 0));
    const repWithMaxWidth = (0,array_find/* default */.Z)(sortedRepsByWidth, (representation) => typeof representation.width === "number" &&
        representation.width >= width);
    if (repWithMaxWidth === undefined) {
        return representations;
    }
    const maxWidth = typeof repWithMaxWidth.width === "number" ? repWithMaxWidth.width :
        0;
    return representations.filter(representation => typeof representation.width === "number" ? representation.width <= maxWidth :
        true);
}

;// CONCATENATED MODULE: ./src/core/abr/network_analyzer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





const { ABR_REGULAR_FACTOR, ABR_STARVATION_DURATION_DELTA, ABR_STARVATION_FACTOR, ABR_STARVATION_GAP, OUT_OF_STARVATION_GAP } = config/* default */.Z;
/**
 * Get pending segment request(s) starting with the asked segment position.
 * @param {Object} requests
 * @param {number} position
 * @returns {Array.<Object>}
 */
function getConcernedRequests(requests, neededPosition) {
    /** Index of the request for the next needed segment, in `requests`. */
    const nextSegmentIndex = (0,array_find_index/* default */.Z)(requests, (request) => {
        if (request.duration <= 0) {
            return false;
        }
        const segmentEnd = request.time + request.duration;
        return segmentEnd > neededPosition &&
            neededPosition - request.time > -1.2;
    });
    if (nextSegmentIndex < 0) { // Not found
        return [];
    }
    const nextRequest = requests[nextSegmentIndex];
    const segmentTime = nextRequest.time;
    const filteredRequests = [nextRequest];
    // Get the possibly multiple requests for that segment's position
    for (let i = nextSegmentIndex + 1; i < requests.length; i++) {
        if (requests[i].time === segmentTime) {
            filteredRequests.push(requests[i]);
        }
        else {
            break;
        }
    }
    return filteredRequests;
}
/**
 * Estimate the __VERY__ recent bandwidth based on a single unfinished request.
 * Useful when the current bandwidth seemed to have fallen quickly.
 *
 * @param {Object} request
 * @returns {number|undefined}
 */
function estimateRequestBandwidth(request) {
    if (request.progress.length < 5) { // threshold from which we can consider
        // progress events reliably
        return undefined;
    }
    // try to infer quickly the current bitrate based on the
    // progress events
    const ewma1 = new EWMA(2);
    const { progress } = request;
    for (let i = 1; i < progress.length; i++) {
        const bytesDownloaded = progress[i].size - progress[i - 1].size;
        const timeElapsed = progress[i].timestamp - progress[i - 1].timestamp;
        const reqBitrate = (bytesDownloaded * 8) / (timeElapsed / 1000);
        ewma1.addSample(timeElapsed / 1000, reqBitrate);
    }
    return ewma1.getEstimate();
}
/**
 * Estimate remaining time for a pending request from a progress event.
 * @param {Object} lastProgressEvent
 * @param {number} bandwidthEstimate
 * @returns {number}
 */
function estimateRemainingTime(lastProgressEvent, bandwidthEstimate) {
    const remainingData = (lastProgressEvent.totalSize - lastProgressEvent.size) * 8;
    return Math.max(remainingData / bandwidthEstimate, 0);
}
/**
 * Check if the request for the most needed segment is too slow.
 * If that's the case, re-calculate the bandwidth urgently based on
 * this single request.
 * @param {Object} pendingRequests - Current pending requests.
 * @param {Object} playbackInfo - Information on the current playback.
 * @param {Object|null} currentRepresentation - The Representation being
 * presently being loaded.
 * @param {Number} lastEstimatedBitrate - Last bitrate estimate emitted.
 * @returns {Number|undefined}
 */
function estimateStarvationModeBitrate(pendingRequests, playbackInfo, currentRepresentation, lastEstimatedBitrate) {
    const { bufferGap, speed, position } = playbackInfo;
    const realBufferGap = isFinite(bufferGap) ? bufferGap :
        0;
    const nextNeededPosition = position + realBufferGap;
    const concernedRequests = getConcernedRequests(pendingRequests, nextNeededPosition);
    if (concernedRequests.length !== 1) { // 0  == no request
        // 2+ == too complicated to calculate
        return undefined;
    }
    const concernedRequest = concernedRequests[0];
    const chunkDuration = concernedRequest.duration;
    const now = performance.now();
    const lastProgressEvent = concernedRequest.progress.length > 0 ?
        concernedRequest.progress[concernedRequest.progress.length - 1] :
        undefined;
    // first, try to do a quick estimate from progress events
    const bandwidthEstimate = estimateRequestBandwidth(concernedRequest);
    if (lastProgressEvent !== undefined && bandwidthEstimate !== undefined) {
        const remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
        // if the remaining time does seem reliable
        if ((now - lastProgressEvent.timestamp) / 1000 <= remainingTime) {
            // Calculate estimated time spent rebuffering if we continue doing that request.
            const expectedRebufferingTime = remainingTime -
                (realBufferGap / speed);
            if (expectedRebufferingTime > 2000) {
                return bandwidthEstimate;
            }
        }
    }
    const requestElapsedTime = (now - concernedRequest.requestTimestamp) / 1000;
    const reasonableElapsedTime = requestElapsedTime <=
        ((chunkDuration * 1.5 + 2) / speed);
    if (currentRepresentation == null || reasonableElapsedTime) {
        return undefined;
    }
    // calculate a reduced bitrate from the current one
    const factor = chunkDuration / requestElapsedTime;
    const reducedBitrate = currentRepresentation.bitrate * Math.min(0.7, factor);
    if (lastEstimatedBitrate === undefined ||
        reducedBitrate < lastEstimatedBitrate) {
        return reducedBitrate;
    }
}
/**
 * Returns true if, based on the current requests, it seems that the ABR should
 * switch immediately if a lower bitrate is more adapted.
 * Returns false if it estimates that you have time before switching to a lower
 * bitrate.
 * @param {Object} playbackInfo
 * @param {Object} requests - Every requests pending, in a chronological
 * order in terms of segment time.
 * @param {number} abrStarvationGap - "Buffer gap" from which we enter a
 * "starvation mode".
 * @returns {boolean}
 */
function shouldDirectlySwitchToLowBitrate(playbackInfo, requests) {
    const realBufferGap = isFinite(playbackInfo.bufferGap) ? playbackInfo.bufferGap :
        0;
    const nextNeededPosition = playbackInfo.position + realBufferGap;
    const nextRequest = (0,array_find/* default */.Z)(requests, (r) => r.duration > 0 && (r.time + r.duration) > nextNeededPosition);
    if (nextRequest === undefined) {
        return true;
    }
    const now = performance.now();
    const lastProgressEvent = nextRequest.progress.length > 0 ?
        nextRequest.progress[nextRequest.progress.length - 1] :
        undefined;
    // first, try to do a quick estimate from progress events
    const bandwidthEstimate = estimateRequestBandwidth(nextRequest);
    if (lastProgressEvent === undefined || bandwidthEstimate === undefined) {
        return true;
    }
    const remainingTime = estimateRemainingTime(lastProgressEvent, bandwidthEstimate);
    if ((now - lastProgressEvent.timestamp) / 1000 > (remainingTime * 1.2)) {
        return true;
    }
    const expectedRebufferingTime = remainingTime -
        (realBufferGap / playbackInfo.speed);
    return expectedRebufferingTime > -1.5;
}
/**
 * Analyze the current network conditions and give a bandwidth estimate as well
 * as a maximum bitrate a Representation should be.
 * @class NetworkAnalyzer
 */
class NetworkAnalyzer {
    constructor(initialBitrate, lowLatencyMode) {
        this._initialBitrate = initialBitrate;
        this._inStarvationMode = false;
        if (lowLatencyMode) {
            this._config = { starvationGap: ABR_STARVATION_GAP.LOW_LATENCY,
                outOfStarvationGap: OUT_OF_STARVATION_GAP.LOW_LATENCY,
                starvationBitrateFactor: ABR_STARVATION_FACTOR.LOW_LATENCY,
                regularBitrateFactor: ABR_REGULAR_FACTOR.LOW_LATENCY };
        }
        else {
            this._config = { starvationGap: ABR_STARVATION_GAP.DEFAULT,
                outOfStarvationGap: OUT_OF_STARVATION_GAP.DEFAULT,
                starvationBitrateFactor: ABR_STARVATION_FACTOR.DEFAULT,
                regularBitrateFactor: ABR_REGULAR_FACTOR.DEFAULT };
        }
    }
    /**
     * Gives an estimate of the current bandwidth and of the bitrate that should
     * be considered for chosing a `representation`.
     * This estimate is only based on network metrics.
     * @param {Object} playbackInfo - Gives current information about playback
     * @param {Object} bandwidthEstimator
     * @param {Object|null} currentRepresentation
     * @param {Array.<Object>} currentRequests
     * @param {number|undefined} lastEstimatedBitrate
     * @returns {Object}
     */
    getBandwidthEstimate(playbackInfo, bandwidthEstimator, currentRepresentation, currentRequests, lastEstimatedBitrate) {
        let newBitrateCeil; // bitrate ceil for the chosen Representation
        let bandwidthEstimate;
        const localConf = this._config;
        const { bufferGap, position, duration } = playbackInfo;
        const realBufferGap = isFinite(bufferGap) ? bufferGap :
            0;
        // check if should get in/out of starvation mode
        if (isNaN(duration) ||
            realBufferGap + position < duration - ABR_STARVATION_DURATION_DELTA) {
            if (!this._inStarvationMode && realBufferGap <= localConf.starvationGap) {
                log/* default.info */.Z.info("ABR: enter starvation mode.");
                this._inStarvationMode = true;
            }
            else if (this._inStarvationMode &&
                realBufferGap >= localConf.outOfStarvationGap) {
                log/* default.info */.Z.info("ABR: exit starvation mode.");
                this._inStarvationMode = false;
            }
        }
        else if (this._inStarvationMode) {
            log/* default.info */.Z.info("ABR: exit starvation mode.");
            this._inStarvationMode = false;
        }
        // If in starvation mode, check if a quick new estimate can be done
        // from the last requests.
        // If so, cancel previous estimates and replace it by the new one
        if (this._inStarvationMode) {
            bandwidthEstimate = estimateStarvationModeBitrate(currentRequests, playbackInfo, currentRepresentation, lastEstimatedBitrate);
            if (bandwidthEstimate != null) {
                log/* default.info */.Z.info("ABR: starvation mode emergency estimate:", bandwidthEstimate);
                bandwidthEstimator.reset();
                newBitrateCeil = currentRepresentation == null ?
                    bandwidthEstimate :
                    Math.min(bandwidthEstimate, currentRepresentation.bitrate);
            }
        }
        // if newBitrateCeil is not yet defined, do the normal estimation
        if (newBitrateCeil == null) {
            bandwidthEstimate = bandwidthEstimator.getEstimate();
            if (bandwidthEstimate != null) {
                newBitrateCeil = bandwidthEstimate *
                    (this._inStarvationMode ? localConf.starvationBitrateFactor :
                        localConf.regularBitrateFactor);
            }
            else if (lastEstimatedBitrate != null) {
                newBitrateCeil = lastEstimatedBitrate *
                    (this._inStarvationMode ? localConf.starvationBitrateFactor :
                        localConf.regularBitrateFactor);
            }
            else {
                newBitrateCeil = this._initialBitrate;
            }
        }
        if (playbackInfo.speed > 1) {
            newBitrateCeil /= playbackInfo.speed;
        }
        return { bandwidthEstimate, bitrateChosen: newBitrateCeil };
    }
    /**
     * For a given wanted bitrate, tells if should switch urgently.
     * @param {number} bitrate
     * @param {Object} playbackInfo
     * @returns {boolean}
     */
    isUrgent(bitrate, currentRepresentation, currentRequests, playbackInfo) {
        if (currentRepresentation === null) {
            return true;
        }
        else if (bitrate === currentRepresentation.bitrate) {
            return false;
        }
        else if (bitrate > currentRepresentation.bitrate) {
            return !this._inStarvationMode;
        }
        return shouldDirectlySwitchToLowBitrate(playbackInfo, currentRequests);
    }
}

// EXTERNAL MODULE: ./src/utils/object_values.ts
var object_values = __webpack_require__(86293);
;// CONCATENATED MODULE: ./src/core/abr/pending_requests_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Store information about pending requests, like information about:
 *   - for which segments they are
 *   - how the request's progress goes
 * @class PendingRequestsStore
 */
class PendingRequestsStore {
    constructor() {
        this._currentRequests = {};
    }
    /**
     * Add information about a new pending request.
     * @param {string} id
     * @param {Object} payload
     */
    add(payload) {
        const { id, time, duration, requestTimestamp } = payload;
        this._currentRequests[id] = { time,
            duration,
            requestTimestamp,
            progress: [] };
    }
    /**
     * Notify of the progress of a currently pending request.
     * @param {Object} progress
     */
    addProgress(progress) {
        const request = this._currentRequests[progress.id];
        if (request == null) {
            if (true) {
                throw new Error("ABR: progress for a request not added");
            }
            log/* default.warn */.Z.warn("ABR: progress for a request not added");
            return;
        }
        request.progress.push(progress);
    }
    /**
     * Remove a request previously set as pending.
     * @param {string} id
     */
    remove(id) {
        if (this._currentRequests[id] == null) {
            if (true) {
                throw new Error("ABR: can't remove unknown request");
            }
            log/* default.warn */.Z.warn("ABR: can't remove unknown request");
        }
        delete this._currentRequests[id];
    }
    /**
     * Returns information about all pending requests, in segment's chronological
     * order.
     * @returns {Array.<Object>}
     */
    getRequests() {
        return (0,object_values/* default */.Z)(this._currentRequests)
            .filter((x) => x != null)
            .sort((reqA, reqB) => reqA.time - reqB.time);
    }
}

;// CONCATENATED MODULE: ./src/core/abr/representation_score_calculator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Calculate the "maintainability score" of a given Representation:
 *   - A score higher than 1 means that the Representation can theorically
 *     be downloaded faster than the duration of the media it represents.
 *     (e.g. a segment representing 4 seconds can be downloaded in less than 4
 *     seconds).
 *   - A score lower or equal to 1 means that the Representation cannot be
 *     downloaded
 *
 * The score follows a simple linear relation to both variables it is based
 * on:
 *   - if n seconds of content can be downloaded in 2*n seconds, the score will
 *     be `0.5`.
 *   - if n seconds of content can be downloaded in n seconds, the score will be
 *     `1`.
 *   - if n seconds of content can be downloaded in n/2 seconds, the score will
 *     be `2`.
 *   - ...
 *
 * The score is mainly here to tell you when your buffer-based guesses are
 * actually higher than the quality you should normally reach.
 *
 * /!\ Please bear in mind that we don't consider the playback rate in those
 * operations.
 * Still, integrating the playback rate a posteriori should not be difficult
 * (e.g. you can just divide the score by that rate).
 *
 * @class RepresentationScoreCalculator
 */
class RepresentationScoreCalculator {
    constructor() {
        this._currentRepresentationData = null;
        this._lastRepresentationWithGoodScore = null;
    }
    /**
     * Add new sample data.
     * @param {Representation} representation
     * @param {number} requestDuration - duration taken for doing the request for
     * the whole segment.
     * @param {number} segmentDuration - media duration of the whole segment, in
     * seconds.
     */
    addSample(representation, requestDuration, segmentDuration) {
        const ratio = segmentDuration / requestDuration;
        const oldEwma = this._getEWMA(representation);
        let currentEWMA;
        if (oldEwma != null) {
            currentEWMA = oldEwma;
            oldEwma.addSample(requestDuration, ratio);
        }
        else {
            currentEWMA = new EWMA(5);
            currentEWMA.addSample(requestDuration, ratio);
            this._currentRepresentationData = { representation, ewma: currentEWMA };
        }
        if (currentEWMA.getEstimate() > 1 &&
            this._lastRepresentationWithGoodScore !== representation) {
            log/* default.debug */.Z.debug("ABR: New last stable representation", representation);
            this._lastRepresentationWithGoodScore = representation;
        }
    }
    /**
     * Get score estimate for the given Representation.
     * undefined if no estimate is available.
     * @param {Representation} representation
     * @returns {number|undefined}
     */
    getEstimate(representation) {
        const ewma = this._getEWMA(representation);
        if (ewma != null) {
            return ewma.getEstimate();
        }
    }
    /**
     * Returns last Representation which had reached a score superior to 1.
     * This Representation is the last known one which could be maintained.
     * Useful to know if a current guess is higher than what you should
     * normally be able to play.
     * `null` if no Representation ever reach that score.
     * @returns {Representation|null}
     */
    getLastStableRepresentation() {
        return this._lastRepresentationWithGoodScore;
    }
    /**
     * Returns EWMA for the given Representation.
     * null if no EWMA is currently stored for it.
     * @param {Representation} representation
     * @returns {EWMA|null}
     */
    _getEWMA(representation) {
        if (this._currentRepresentationData != null &&
            this._currentRepresentationData.representation.id === representation.id) {
            return this._currentRepresentationData.ewma;
        }
        return null;
    }
}

;// CONCATENATED MODULE: ./src/core/abr/select_optimal_representation.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * From the given array of Representations (sorted by bitrate order ascending),
 * returns the one corresponding to the given optimal, minimum and maximum
 * bitrates.
 * @param {Array.<Representation>} representations - The representations array,
 * sorted in bitrate ascending order.
 * @param {Number} optimalBitrate - The optimal bitrate the Representation
 * should have under the current condition.
 * @param {Number} minBitrate - The minimum bitrate the chosen Representation
 * should have. We will take the Representation with the maximum bitrate if none
 * is found.
 * @param {Number} maxBitrate - The maximum bitrate the chosen Representation
 * should have. We will take the Representation with the minimum bitrate if none
 * is found.
 * @returns {Representation|undefined}
 */
function selectOptimalRepresentation(representations, optimalBitrate, minBitrate, maxBitrate) {
    const wantedBitrate = optimalBitrate <= minBitrate ? minBitrate :
        optimalBitrate >= maxBitrate ? maxBitrate :
            optimalBitrate;
    const firstIndexTooHigh = (0,array_find_index/* default */.Z)(representations, (representation) => representation.bitrate > wantedBitrate);
    if (firstIndexTooHigh === -1) {
        return representations[representations.length - 1];
    }
    else if (firstIndexTooHigh === 0) {
        return representations[0];
    }
    return representations[firstIndexTooHigh - 1];
}

;// CONCATENATED MODULE: ./src/core/abr/representation_estimator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












/**
 * Filter representations given through filters options.
 * @param {Array.<Representation>} representations
 * @param {Object} filters - Filter Object.
 * @returns {Array.<Representation>}
 */
function getFilteredRepresentations(representations, filters) {
    let _representations = representations;
    if (filters.bitrate != null) {
        _representations = filterByBitrate(_representations, filters.bitrate);
    }
    if (filters.width != null) {
        _representations = filterByWidth(_representations, filters.width);
    }
    return _representations;
}
/**
 * Estimate regularly the current network bandwidth and the best Representation
 * that can be played according to the current network and playback conditions.
 *
 * A `RepresentationEstimator` only does estimations for a given type (e.g.
 * "audio", "video" etc.) and Period.
 *
 * If estimates for multiple types and/or Periods are needed, you should
 * create as many `RepresentationEstimator`.
 * @param {Object} args
 * @returns {Observable}
 */
function RepresentationEstimator({ bandwidthEstimator, clock$, filters$, initialBitrate, lowLatencyMode, manualBitrate$, minAutoBitrate$, maxAutoBitrate$, representations, streamEvents$, }) {
    const scoreCalculator = new RepresentationScoreCalculator();
    const networkAnalyzer = new NetworkAnalyzer(initialBitrate == null ? 0 :
        initialBitrate, lowLatencyMode);
    const requestsStore = new PendingRequestsStore();
    const shouldIgnoreMetrics = generateCachedSegmentDetector();
    /**
     * Callback to call when new metrics are available
     * @param {Object} value
     */
    function onMetric(value) {
        const { duration, size, content } = value;
        if (shouldIgnoreMetrics(content, duration)) {
            // We already loaded not cached segments.
            // Do not consider cached segments anymore.
            return;
        }
        // calculate bandwidth
        bandwidthEstimator.addSample(duration, size);
        // calculate "maintainability score"
        const { segment } = content;
        const requestDuration = duration / 1000;
        const segmentDuration = segment.duration;
        const { representation } = content;
        scoreCalculator.addSample(representation, requestDuration, segmentDuration);
    }
    const metrics$ = streamEvents$.pipe((0,filter/* filter */.h)((e) => e.type === "metrics"), (0,tap/* tap */.b)(({ value }) => onMetric(value)), (0,ignoreElements/* ignoreElements */.l)());
    const requests$ = streamEvents$.pipe((0,tap/* tap */.b)((evt) => {
        switch (evt.type) {
            case "requestBegin":
                requestsStore.add(evt.value);
                break;
            case "requestEnd":
                requestsStore.remove(evt.value.id);
                break;
            case "progress":
                requestsStore.addProgress(evt.value);
                break;
        }
    }), (0,ignoreElements/* ignoreElements */.l)());
    const currentRepresentation$ = streamEvents$.pipe((0,filter/* filter */.h)((e) => e.type === "representationChange"), (0,map/* map */.U)((e) => e.value.representation), (0,startWith/* startWith */.O)(null));
    const estimate$ = (0,defer/* defer */.P)(() => {
        if (representations.length === 0) {
            throw new Error("ABRManager: no representation choice given");
        }
        if (representations.length === 1) {
            return (0,of.of)({ bitrate: undefined,
                representation: representations[0],
                manual: false,
                urgent: true,
                knownStableBitrate: undefined });
        }
        return manualBitrate$.pipe((0,switchMap/* switchMap */.w)(manualBitrate => {
            if (manualBitrate >= 0) {
                // -- MANUAL mode --
                const manualRepresentation = selectOptimalRepresentation(representations, manualBitrate, 0, Infinity);
                return (0,of.of)({
                    representation: manualRepresentation,
                    bitrate: undefined,
                    knownStableBitrate: undefined,
                    manual: true,
                    urgent: true, // a manual bitrate switch should happen immediately
                });
            }
            // -- AUTO mode --
            let lastEstimatedBitrate;
            let forceBandwidthMode = true;
            // Emit each time a buffer-based estimation should be actualized (each
            // time a segment is added).
            const bufferBasedClock$ = streamEvents$.pipe((0,filter/* filter */.h)((e) => e.type === "added-segment"), withLatestFrom(clock$), (0,map/* map */.U)(([{ value: evtValue }, { speed, position }]) => {
                const timeRanges = evtValue.buffered;
                const bufferGap = (0,ranges/* getLeftSizeOfRange */.L7)(timeRanges, position);
                const { representation } = evtValue.content;
                const currentScore = scoreCalculator.getEstimate(representation);
                const currentBitrate = representation.bitrate;
                return { bufferGap, currentBitrate, currentScore, speed };
            }));
            const bitrates = representations.map(r => r.bitrate);
            const bufferBasedEstimation$ = BufferBasedChooser(bufferBasedClock$, bitrates)
                .pipe((0,startWith/* startWith */.O)(undefined));
            return (0,combineLatest/* combineLatest */.aj)([clock$,
                minAutoBitrate$,
                maxAutoBitrate$,
                filters$,
                bufferBasedEstimation$]).pipe(withLatestFrom(currentRepresentation$), (0,map/* map */.U)(([[clock, minAutoBitrate, maxAutoBitrate, filters, bufferBasedBitrate], currentRepresentation]) => {
                const _representations = getFilteredRepresentations(representations, filters);
                const requests = requestsStore.getRequests();
                const { bandwidthEstimate, bitrateChosen } = networkAnalyzer
                    .getBandwidthEstimate(clock, bandwidthEstimator, currentRepresentation, requests, lastEstimatedBitrate);
                lastEstimatedBitrate = bandwidthEstimate;
                const stableRepresentation = scoreCalculator.getLastStableRepresentation();
                const knownStableBitrate = stableRepresentation == null ?
                    undefined :
                    stableRepresentation.bitrate / (clock.speed > 0 ? clock.speed : 1);
                const { bufferGap } = clock;
                if (!forceBandwidthMode && bufferGap <= 5) {
                    forceBandwidthMode = true;
                }
                else if (forceBandwidthMode && isFinite(bufferGap) && bufferGap > 10) {
                    forceBandwidthMode = false;
                }
                const chosenRepFromBandwidth = selectOptimalRepresentation(_representations, bitrateChosen, minAutoBitrate, maxAutoBitrate);
                if (forceBandwidthMode) {
                    log/* default.debug */.Z.debug("ABR: Choosing representation with bandwidth estimation.", chosenRepFromBandwidth);
                    return { bitrate: bandwidthEstimate,
                        representation: chosenRepFromBandwidth,
                        urgent: networkAnalyzer.isUrgent(chosenRepFromBandwidth.bitrate, currentRepresentation, requests, clock),
                        manual: false,
                        knownStableBitrate };
                }
                if (bufferBasedBitrate == null ||
                    chosenRepFromBandwidth.bitrate >= bufferBasedBitrate) {
                    log/* default.debug */.Z.debug("ABR: Choosing representation with bandwidth estimation.", chosenRepFromBandwidth);
                    return { bitrate: bandwidthEstimate,
                        representation: chosenRepFromBandwidth,
                        urgent: networkAnalyzer.isUrgent(chosenRepFromBandwidth.bitrate, currentRepresentation, requests, clock),
                        manual: false,
                        knownStableBitrate };
                }
                const chosenRepresentation = selectOptimalRepresentation(_representations, bufferBasedBitrate, minAutoBitrate, maxAutoBitrate);
                if (bufferBasedBitrate <= maxAutoBitrate) {
                    log/* default.debug */.Z.debug("ABR: Choosing representation with buffer based bitrate ceiling.", chosenRepresentation);
                }
                return { bitrate: bandwidthEstimate,
                    representation: chosenRepresentation,
                    urgent: networkAnalyzer.isUrgent(bufferBasedBitrate, currentRepresentation, requests, clock),
                    manual: false,
                    knownStableBitrate };
            }));
        }));
    });
    return (0,merge/* merge */.T)(metrics$, requests$, estimate$);
}

;// CONCATENATED MODULE: ./src/core/abr/abr_manager.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Adaptive BitRate Manager.
 *
 * Select the right Representation from the network and buffer infos it
 * receives.
 * @class ABRManager
 */
class ABRManager {
    /**
     * @param {Object} options
     */
    constructor(options) {
        this._manualBitrates = options.manualBitrates;
        this._minAutoBitrates = options.minAutoBitrates;
        this._maxAutoBitrates = options.maxAutoBitrates;
        this._initialBitrates = options.initialBitrates;
        this._throttlers = options.throttlers;
        this._bandwidthEstimators = {};
        this._lowLatencyMode = options.lowLatencyMode;
    }
    /**
     * Take type and an array of the available representations, spit out an
     * observable emitting the best representation (given the network/buffer
     * state).
     * @param {string} type
     * @param {Array.<Representation>} representations
     * @param {Observable<Object>} clock$
     * @param {Observable<Object>} streamEvents$
     * @returns {Observable}
     */
    get$(type, representations, clock$, streamEvents$) {
        const bandwidthEstimator = this._getBandwidthEstimator(type);
        const manualBitrate$ = (0,take_first_set/* default */.Z)(this._manualBitrates[type], (0,of.of)(-1));
        const minAutoBitrate$ = (0,take_first_set/* default */.Z)(this._minAutoBitrates[type], (0,of.of)(0));
        const maxAutoBitrate$ = (0,take_first_set/* default */.Z)(this._maxAutoBitrates[type], (0,of.of)(Infinity));
        const initialBitrate = (0,take_first_set/* default */.Z)(this._initialBitrates[type], 0);
        const filters$ = createFilters(this._throttlers.limitWidth[type], this._throttlers.throttleBitrate[type], this._throttlers.throttle[type]);
        return RepresentationEstimator({ bandwidthEstimator,
            streamEvents$,
            clock$,
            filters$,
            initialBitrate,
            manualBitrate$,
            minAutoBitrate$,
            maxAutoBitrate$,
            representations,
            lowLatencyMode: this._lowLatencyMode });
    }
    /**
     * @param {string} bufferType
     * @returns {Object}
     */
    _getBandwidthEstimator(bufferType) {
        const originalBandwidthEstimator = this._bandwidthEstimators[bufferType];
        if (originalBandwidthEstimator == null) {
            log/* default.debug */.Z.debug("ABR: Creating new BandwidthEstimator for ", bufferType);
            const bandwidthEstimator = new BandwidthEstimator();
            this._bandwidthEstimators[bufferType] = bandwidthEstimator;
            return bandwidthEstimator;
        }
        return originalBandwidthEstimator;
    }
}

;// CONCATENATED MODULE: ./src/core/abr/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const abr = (ABRManager);

// EXTERNAL MODULE: ./src/core/init/create_eme_manager.ts + 1 modules
var create_eme_manager = __webpack_require__(50225);
// EXTERNAL MODULE: ./src/compat/clear_element_src.ts
var clear_element_src = __webpack_require__(38815);
// EXTERNAL MODULE: ./src/compat/browser_compatibility_types.ts
var browser_compatibility_types = __webpack_require__(18909);
// EXTERNAL MODULE: ./src/utils/is_non_empty_string.ts
var is_non_empty_string = __webpack_require__(4938);
;// CONCATENATED MODULE: ./src/core/init/create_media_source.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const { onSourceOpen$ } = event_listeners;
/**
 * Dispose of ressources taken by the MediaSource:
 *   - Clear the MediaSource' SourceBuffers
 *   - Clear the mediaElement's src (stop the mediaElement)
 *   - Revoke MediaSource' URL
 * @param {HTMLMediaElement} mediaElement
 * @param {MediaSource|null} mediaSource
 * @param {string|null} mediaSourceURL
 */
function resetMediaSource(mediaElement, mediaSource, mediaSourceURL) {
    if (mediaSource !== null && mediaSource.readyState !== "closed") {
        const { readyState, sourceBuffers } = mediaSource;
        for (let i = sourceBuffers.length - 1; i >= 0; i--) {
            const sourceBuffer = sourceBuffers[i];
            try {
                if (readyState === "open") {
                    log/* default.info */.Z.info("Init: Removing SourceBuffer from mediaSource", sourceBuffer);
                    sourceBuffer.abort();
                }
                mediaSource.removeSourceBuffer(sourceBuffer);
            }
            catch (e) {
                log/* default.warn */.Z.warn("Init: Error while disposing SourceBuffer", e);
            }
        }
        if (sourceBuffers.length > 0) {
            log/* default.warn */.Z.warn("Init: Not all SourceBuffers could have been removed.");
        }
    }
    (0,clear_element_src/* default */.Z)(mediaElement);
    if (mediaSourceURL !== null) {
        try {
            log/* default.debug */.Z.debug("Init: Revoking previous URL");
            URL.revokeObjectURL(mediaSourceURL);
        }
        catch (e) {
            log/* default.warn */.Z.warn("Init: Error while revoking the media source URL", e);
        }
    }
}
/**
 * Create, on subscription, a MediaSource instance and attach it to the given
 * mediaElement element's src attribute.
 *
 * Returns an Observable which emits the MediaSource when created and attached
 * to the mediaElement element.
 * This Observable never completes. It can throw if MediaSource is not
 * available in the current environment.
 *
 * On unsubscription, the mediaElement.src is cleaned, MediaSource SourceBuffers
 * are aborted and some minor cleaning is done.
 *
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
function createMediaSource(mediaElement) {
    return new Observable/* Observable */.y((observer) => {
        if (browser_compatibility_types/* MediaSource_ */.JJ == null) {
            throw new media_error/* default */.Z("MEDIA_SOURCE_NOT_SUPPORTED", "No MediaSource Object was found in the current browser.");
        }
        // make sure the media has been correctly reset
        const oldSrc = (0,is_non_empty_string/* default */.Z)(mediaElement.src) ? mediaElement.src :
            null;
        resetMediaSource(mediaElement, null, oldSrc);
        log/* default.info */.Z.info("Init: Creating MediaSource");
        const mediaSource = new browser_compatibility_types/* MediaSource_ */.JJ();
        const objectURL = URL.createObjectURL(mediaSource);
        log/* default.info */.Z.info("Init: Attaching MediaSource URL to the media element", objectURL);
        mediaElement.src = objectURL;
        observer.next(mediaSource);
        return () => {
            resetMediaSource(mediaElement, mediaSource, objectURL);
        };
    });
}
/**
 * Create and open a new MediaSource object on the given media element.
 * Emit the MediaSource when done.
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
function openMediaSource(mediaElement) {
    return createMediaSource(mediaElement).pipe((0,mergeMap/* mergeMap */.zg)(mediaSource => {
        return onSourceOpen$(mediaSource).pipe((0,take/* take */.q)(1), (0,mapTo/* mapTo */.h)(mediaSource));
    }));
}

// EXTERNAL MODULE: ./src/core/init/events_generators.ts
var events_generators = __webpack_require__(72902);
;// CONCATENATED MODULE: ./src/core/init/get_initial_time.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


const { DEFAULT_LIVE_GAP } = config/* default */.Z;
/**
 * Returns the calculated initial time for the content described by the given
 * Manifest:
 *   1. if a start time is defined by user, calculate starting time from the
 *      manifest information
 *   2. else if the media is live, use the live edge and suggested delays from
 *      it
 *   3. else returns the minimum time announced in the manifest
 * @param {Manifest} manifest
 * @param {boolean} lowLatencyMode
 * @param {Object} startAt
 * @returns {Number}
 */
function getInitialTime(manifest, lowLatencyMode, startAt) {
    log/* default.debug */.Z.debug("Init: calculating initial time");
    if (startAt != null) {
        const min = manifest.getMinimumPosition();
        const max = manifest.getMaximumPosition();
        if (startAt.position != null) {
            log/* default.debug */.Z.debug("Init: using startAt.minimumPosition");
            return Math.max(Math.min(startAt.position, max), min);
        }
        else if (startAt.wallClockTime != null) {
            log/* default.debug */.Z.debug("Init: using startAt.wallClockTime");
            const ast = manifest.availabilityStartTime == null ?
                0 :
                manifest.availabilityStartTime;
            const position = startAt.wallClockTime - ast;
            return Math.max(Math.min(position, max), min);
        }
        else if (startAt.fromFirstPosition != null) {
            log/* default.debug */.Z.debug("Init: using startAt.fromFirstPosition");
            const { fromFirstPosition } = startAt;
            return fromFirstPosition <= 0 ? min :
                Math.min(max, min + fromFirstPosition);
        }
        else if (startAt.fromLastPosition != null) {
            log/* default.debug */.Z.debug("Init: using startAt.fromLastPosition");
            const { fromLastPosition } = startAt;
            return fromLastPosition >= 0 ? max :
                Math.max(min, max + fromLastPosition);
        }
        else if (startAt.percentage != null) {
            log/* default.debug */.Z.debug("Init: using startAt.percentage");
            const { percentage } = startAt;
            if (percentage > 100) {
                return max;
            }
            else if (percentage < 0) {
                return min;
            }
            const ratio = +percentage / 100;
            const extent = max - min;
            return min + extent * ratio;
        }
    }
    const minimumPosition = manifest.getMinimumPosition();
    if (manifest.isLive) {
        const { suggestedPresentationDelay, clockOffset } = manifest;
        const maximumPosition = manifest.getMaximumPosition();
        let liveTime;
        if (clockOffset == null) {
            log/* default.info */.Z.info("Init: no clock offset found for a live content, " +
                "starting close to maximum available position");
            liveTime = maximumPosition;
        }
        else {
            log/* default.info */.Z.info("Init: clock offset found for a live content, " +
                "checking if we can start close to it");
            const ast = manifest.availabilityStartTime == null ?
                0 :
                manifest.availabilityStartTime;
            const clockRelativeLiveTime = (performance.now() + clockOffset) / 1000 - ast;
            liveTime = Math.min(maximumPosition, clockRelativeLiveTime);
        }
        const diffFromLiveTime = suggestedPresentationDelay !== undefined ? suggestedPresentationDelay :
            lowLatencyMode ? DEFAULT_LIVE_GAP.LOW_LATENCY :
                DEFAULT_LIVE_GAP.DEFAULT;
        log/* default.debug */.Z.debug(`Init: ${liveTime} defined as the live time, applying a live gap` +
            ` of ${diffFromLiveTime}`);
        return Math.max(liveTime - diffFromLiveTime, minimumPosition);
    }
    log/* default.info */.Z.info("Init: starting at the minimum available position:", minimumPosition);
    return minimumPosition;
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/throwError.js
var throwError = __webpack_require__(55022);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/interval.js
var observable_interval = __webpack_require__(75573);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/fromEvent.js
var fromEvent = __webpack_require__(54514);
;// CONCATENATED MODULE: ./src/compat/change_source_buffer_type.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * If the changeType MSE API is implemented, update the current codec of the
 * SourceBuffer and return true if it succeeded.
 * In any other cases, return false.
 * @param {Object} sourceBuffer
 * @param {string} codec
 * @returns {boolean}
 */
function tryToChangeSourceBufferType(sourceBuffer, codec) {
    if (typeof sourceBuffer.changeType === "function") {
        try {
            sourceBuffer.changeType(codec);
        }
        catch (e) {
            log/* default.warn */.Z.warn("Could not call 'changeType' on the given SourceBuffer:", e);
            return false;
        }
        return true;
    }
    return false;
}

// EXTERNAL MODULE: ./src/utils/byte_parsing.ts
var byte_parsing = __webpack_require__(97308);
// EXTERNAL MODULE: ./src/utils/hash_buffer.ts
var hash_buffer = __webpack_require__(13245);
// EXTERNAL MODULE: ./src/core/segment_buffers/implementations/types.ts + 1 modules
var types = __webpack_require__(79860);
;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/audio_video/audio_video_segment_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */











const { SOURCE_BUFFER_FLUSHING_INTERVAL } = config/* default */.Z;
/**
 * Allows to push and remove new segments to a SourceBuffer in a FIFO queue (not
 * doing so can lead to browser Errors) while keeping an inventory of what has
 * been pushed and what is being pushed.
 *
 * To work correctly, only a single AudioVideoSegmentBuffer per SourceBuffer
 * should be created.
 *
 * @class AudioVideoSegmentBuffer
 */
class AudioVideoSegmentBuffer extends types/* SegmentBuffer */.C {
    /**
     * @constructor
     * @param {string} bufferType
     * @param {string} codec
     * @param {SourceBuffer} sourceBuffer
     */
    constructor(bufferType, codec, mediaSource) {
        super();
        const sourceBuffer = mediaSource.addSourceBuffer(codec);
        this._destroy$ = new Subject/* Subject */.xQ();
        this.bufferType = bufferType;
        this._mediaSource = mediaSource;
        this._sourceBuffer = sourceBuffer;
        this._queue = [];
        this._pendingTask = null;
        this._lastInitSegment = null;
        this.codec = codec;
        // Some browsers (happened with firefox 66) sometimes "forget" to send us
        // `update` or `updateend` events.
        // In that case, we're completely unable to continue the queue here and
        // stay locked in a waiting state.
        // This interval is here to check at regular intervals if the underlying
        // SourceBuffer is currently updating.
        (0,observable_interval/* interval */.F)(SOURCE_BUFFER_FLUSHING_INTERVAL).pipe((0,tap/* tap */.b)(() => this._flush()), (0,takeUntil/* takeUntil */.R)(this._destroy$)).subscribe();
        (0,fromEvent/* fromEvent */.R)(this._sourceBuffer, "error").pipe((0,tap/* tap */.b)((err) => this._onPendingTaskError(err)), (0,takeUntil/* takeUntil */.R)(this._destroy$)).subscribe();
        (0,fromEvent/* fromEvent */.R)(this._sourceBuffer, "updateend").pipe((0,tap/* tap */.b)(() => this._flush()), (0,takeUntil/* takeUntil */.R)(this._destroy$)).subscribe();
    }
    /**
     * Push a chunk of the media segment given to the attached SourceBuffer, in a
     * FIFO queue.
     *
     * Once all chunks of a single Segment have been given to `pushChunk`, you
     * should call `endOfSegment` to indicate that the whole Segment has been
     * pushed.
     *
     * Depending on the type of data appended, the pushed chunk might rely on an
     * initialization segment, given through the `data.initSegment` property.
     *
     * Such initialization segment will be first pushed to the SourceBuffer if the
     * last pushed segment was associated to another initialization segment.
     * This detection rely on the initialization segment's reference so you need
     * to avoid mutating in-place a initialization segment given to that function
     * (to avoid having two different values which have the same reference).
     *
     * If you don't need any initialization segment to push the wanted chunk, you
     * can just set `data.initSegment` to `null`.
     *
     * You can also only push an initialization segment by setting the
     * `data.chunk` argument to null.
     *
     * @param {Object} infos
     * @returns {Observable}
     */
    pushChunk(infos) {
        log/* default.debug */.Z.debug("AVSB: receiving order to push data to the SourceBuffer", this.bufferType, infos);
        return this._addToQueue({ type: types/* SegmentBufferOperation.Push */.f.Push,
            value: infos });
    }
    /**
     * Remove buffered data (added to the same FIFO queue than `pushChunk`).
     * @param {number} start - start position, in seconds
     * @param {number} end - end position, in seconds
     * @returns {Observable}
     */
    removeBuffer(start, end) {
        log/* default.debug */.Z.debug("AVSB: receiving order to remove data from the SourceBuffer", this.bufferType, start, end);
        return this._addToQueue({ type: types/* SegmentBufferOperation.Remove */.f.Remove,
            value: { start, end } });
    }
    /**
     * Indicate that every chunks from a Segment has been given to pushChunk so
     * far.
     * This will update our internal Segment inventory accordingly.
     * The returned Observable will emit and complete successively once the whole
     * segment has been pushed and this indication is acknowledged.
     * @param {Object} infos
     * @returns {Observable}
     */
    endOfSegment(infos) {
        log/* default.debug */.Z.debug("AVSB: receiving order for validating end of segment", this.bufferType, infos.segment);
        return this._addToQueue({ type: types/* SegmentBufferOperation.EndOfSegment */.f.EndOfSegment,
            value: infos });
    }
    /**
     * Returns the currently buffered data, in a TimeRanges object.
     * @returns {TimeRanges}
     */
    getBufferedRanges() {
        return this._sourceBuffer.buffered;
    }
    /**
     * Returns the list of every operations that the `AudioVideoSegmentBuffer` is
     * still processing. From the one with the highest priority (like the one
     * being processed)
     * @returns {Array.<Object>}
     */
    getPendingOperations() {
        const parseQueuedOperation = (op) => {
            // Had to be written that way for TypeScrypt
            switch (op.type) {
                case types/* SegmentBufferOperation.Push */.f.Push:
                    return { type: op.type, value: op.value };
                case types/* SegmentBufferOperation.Remove */.f.Remove:
                    return { type: op.type, value: op.value };
                case types/* SegmentBufferOperation.EndOfSegment */.f.EndOfSegment:
                    return { type: op.type, value: op.value };
            }
        };
        const queued = this._queue.map(parseQueuedOperation);
        return this._pendingTask === null ?
            queued :
            [parseQueuedOperation(this._pendingTask)].concat(queued);
    }
    /**
     * Dispose of the resources used by this AudioVideoSegmentBuffer.
     *
     * /!\ You won't be able to use the AudioVideoSegmentBuffer after calling this
     * function.
     * @private
     */
    dispose() {
        this._destroy$.next();
        this._destroy$.complete();
        if (this._pendingTask !== null) {
            this._pendingTask.subject.complete();
            this._pendingTask = null;
        }
        while (this._queue.length > 0) {
            const nextElement = this._queue.shift();
            if (nextElement !== undefined) {
                nextElement.subject.complete();
            }
        }
        if (this._mediaSource.readyState === "open") {
            try {
                this._sourceBuffer.abort();
            }
            catch (e) {
                log/* default.warn */.Z.warn(`AVSB: Failed to abort a ${this.bufferType} SourceBuffer:`, e);
            }
        }
    }
    /**
     * Called when an error arised that made the current task fail.
     * @param {Event} error
     */
    _onPendingTaskError(err) {
        this._lastInitSegment = null; // initialize init segment as a security
        if (this._pendingTask !== null) {
            const error = err instanceof Error ?
                err :
                new Error("An unknown error occured when doing operations " +
                    "on the SourceBuffer");
            this._pendingTask.subject.error(error);
        }
    }
    /**
     * When the returned observable is subscribed:
     *   1. Add your operation to the queue.
     *   2. Begin the queue if not pending.
     *
     * Cancel queued operation on unsubscription.
     * @private
     * @param {Object} operation
     * @returns {Observable}
     */
    _addToQueue(operation) {
        return new Observable/* Observable */.y((obs) => {
            const shouldRestartQueue = this._queue.length === 0 &&
                this._pendingTask === null;
            const subject = new Subject/* Subject */.xQ();
            const queueItem = (0,object_assign/* default */.Z)({ subject }, operation);
            this._queue.push(queueItem);
            const subscription = subject.subscribe(obs);
            if (shouldRestartQueue) {
                this._flush();
            }
            return () => {
                subscription.unsubscribe();
                // Remove the corresponding element from the AudioVideoSegmentBuffer's
                // queue.
                // If the operation was a pending task, it should still continue to not
                // let the AudioVideoSegmentBuffer in a weird state.
                const index = this._queue.indexOf(queueItem);
                if (index >= 0) {
                    this._queue.splice(index, 1);
                }
            };
        });
    }
    /**
     * Perform next task if one.
     * @private
     */
    _flush() {
        if (this._sourceBuffer.updating) {
            return; // still processing `this._pendingTask`
        }
        if (this._pendingTask !== null) {
            const task = this._pendingTask;
            if (task.type !== types/* SegmentBufferOperation.Push */.f.Push || task.data.length === 0) {
                // If we're here, we've finished processing the task
                switch (task.type) {
                    case types/* SegmentBufferOperation.Push */.f.Push:
                        if (task.inventoryData !== null) {
                            this._segmentInventory.insertChunk(task.inventoryData);
                        }
                        break;
                    case types/* SegmentBufferOperation.EndOfSegment */.f.EndOfSegment:
                        this._segmentInventory.completeSegment(task.value);
                        break;
                    case types/* SegmentBufferOperation.Remove */.f.Remove:
                        this.synchronizeInventory();
                        break;
                    default:
                        (0,assert_unreachable/* default */.Z)(task);
                }
                const { subject } = task;
                this._pendingTask = null;
                subject.next();
                subject.complete();
                this._flush(); // Go to next item in queue
                return;
            }
        }
        else { // if this._pendingTask is null, go to next item in queue
            const nextItem = this._queue.shift();
            if (nextItem === undefined) {
                return; // we have nothing left to do
            }
            else if (nextItem.type !== types/* SegmentBufferOperation.Push */.f.Push) {
                this._pendingTask = nextItem;
            }
            else {
                const itemValue = nextItem.value;
                let dataToPush;
                try {
                    dataToPush = this._preparePushOperation(itemValue.data);
                }
                catch (e) {
                    this._pendingTask = (0,object_assign/* default */.Z)({ data: [],
                        inventoryData: itemValue.inventoryInfos }, nextItem);
                    const error = e instanceof Error ?
                        e :
                        new Error("An unknown error occured when preparing a push operation");
                    this._lastInitSegment = null; // initialize init segment as a security
                    nextItem.subject.error(error);
                    return;
                }
                this._pendingTask = (0,object_assign/* default */.Z)({ data: dataToPush,
                    inventoryData: itemValue.inventoryInfos }, nextItem);
            }
        }
        try {
            switch (this._pendingTask.type) {
                case types/* SegmentBufferOperation.EndOfSegment */.f.EndOfSegment:
                    // nothing to do, we will just acknowledge the segment.
                    log/* default.debug */.Z.debug("AVSB: Acknowledging complete segment", this._pendingTask.value);
                    this._flush();
                    return;
                case types/* SegmentBufferOperation.Push */.f.Push:
                    const segmentData = this._pendingTask.data.shift();
                    if (segmentData === undefined) {
                        this._flush();
                        return;
                    }
                    this._sourceBuffer.appendBuffer(segmentData);
                    break;
                case types/* SegmentBufferOperation.Remove */.f.Remove:
                    const { start, end } = this._pendingTask.value;
                    log/* default.debug */.Z.debug("AVSB: removing data from SourceBuffer", this.bufferType, start, end);
                    this._sourceBuffer.remove(start, end);
                    break;
                default:
                    (0,assert_unreachable/* default */.Z)(this._pendingTask);
            }
        }
        catch (e) {
            this._onPendingTaskError(e);
        }
    }
    /**
     * A push Operation might necessitate to mutate some `SourceBuffer` and/or
     * `AudioVideoSegmentBuffer` properties and also might need to be divided into
     * multiple segments to push (exemple: when first pushing the initialization
     * data before the segment data).
     *
     * This method allows to "prepare" that push operation so that all is left is
     * to push the returned segment data one after the other (from first to last).
     * @param {Object} item
     * @returns {Object}
     */
    _preparePushOperation(data) {
        // Push operation with both an init segment and a regular segment might
        // need to be separated into two steps
        const dataToPush = [];
        const { codec, timestampOffset, appendWindow } = data;
        let hasUpdatedSourceBufferType = false;
        if (codec !== this.codec) {
            log/* default.debug */.Z.debug("AVSB: updating codec", codec);
            hasUpdatedSourceBufferType = tryToChangeSourceBufferType(this._sourceBuffer, codec);
            if (hasUpdatedSourceBufferType) {
                this.codec = codec;
            }
            else {
                log/* default.debug */.Z.debug("AVSB: could not update codec", codec, this.codec);
            }
        }
        if (this._sourceBuffer.timestampOffset !== timestampOffset) {
            const newTimestampOffset = timestampOffset;
            log/* default.debug */.Z.debug("AVSB: updating timestampOffset", this.bufferType, this._sourceBuffer.timestampOffset, newTimestampOffset);
            this._sourceBuffer.timestampOffset = newTimestampOffset;
        }
        if (appendWindow[0] === undefined) {
            if (this._sourceBuffer.appendWindowStart > 0) {
                this._sourceBuffer.appendWindowStart = 0;
            }
        }
        else if (appendWindow[0] !== this._sourceBuffer.appendWindowStart) {
            if (appendWindow[0] >= this._sourceBuffer.appendWindowEnd) {
                this._sourceBuffer.appendWindowEnd = appendWindow[0] + 1;
            }
            this._sourceBuffer.appendWindowStart = appendWindow[0];
        }
        if (appendWindow[1] === undefined) {
            if (this._sourceBuffer.appendWindowEnd !== Infinity) {
                this._sourceBuffer.appendWindowEnd = Infinity;
            }
        }
        else if (appendWindow[1] !== this._sourceBuffer.appendWindowEnd) {
            this._sourceBuffer.appendWindowEnd = appendWindow[1];
        }
        if (data.initSegment !== null &&
            (hasUpdatedSourceBufferType || !this._isLastInitSegment(data.initSegment))) {
            // Push initialization segment before the media segment
            const segmentData = data.initSegment;
            dataToPush.push(segmentData);
            const initU8 = (0,byte_parsing/* toUint8Array */._f)(segmentData);
            this._lastInitSegment = { data: initU8,
                hash: (0,hash_buffer/* default */.Z)(initU8) };
        }
        if (data.chunk !== null) {
            dataToPush.push(data.chunk);
        }
        return dataToPush;
    }
    /**
     * Return `true` if the given `segmentData` is the same segment than the last
     * initialization segment pushed to the `AudioVideoSegmentBuffer`.
     * @param {BufferSource} segmentData
     * @returns {boolean}
     */
    _isLastInitSegment(segmentData) {
        if (this._lastInitSegment === null) {
            return false;
        }
        if (this._lastInitSegment.data === segmentData) {
            return true;
        }
        const oldInit = this._lastInitSegment.data;
        if (oldInit.byteLength === segmentData.byteLength) {
            const newInitU8 = (0,byte_parsing/* toUint8Array */._f)(segmentData);
            if ((0,hash_buffer/* default */.Z)(newInitU8) === this._lastInitSegment.hash &&
                (0,are_arrays_of_numbers_equal/* default */.Z)(oldInit, newInitU8)) {
                return true;
            }
        }
        return false;
    }
}

;// CONCATENATED MODULE: ./src/core/segment_buffers/implementations/audio_video/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const audio_video = (AudioVideoSegmentBuffer);

;// CONCATENATED MODULE: ./src/core/segment_buffers/segment_buffers_store.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





const POSSIBLE_BUFFER_TYPES = ["audio",
    "video",
    "text",
    "image"];
/**
 * Allows to easily create and dispose SegmentBuffers, which are interfaces to
 * push and remove segments.
 *
 * Only one SegmentBuffer per type is allowed at the same time:
 *
 *   - SegmentBuffers linked to a "native" media buffer (relying on a
 *     SourceBuffer: "audio" and "video" here) are reused if one is
 *     re-created.
 *
 *   - SegmentBuffers for custom types (the other types of media) are aborted
 *     each time a new one of the same type is created.
 *
 * To be able to use a SegmentBuffer linked to a native media buffer, you
 * will first need to create it, but also wait until the other one is either
 * created or explicitely disabled through the `disableSegmentBuffer` method.
 * The Observable returned by `waitForUsableBuffers` will emit when
 * that is the case.
 *
 * @class SegmentBuffersStore
 */
class SegmentBuffersStore {
    /**
     * @param {HTMLMediaElement} mediaElement
     * @param {MediaSource} mediaSource
     * @constructor
     */
    constructor(mediaElement, mediaSource) {
        this._mediaElement = mediaElement;
        this._mediaSource = mediaSource;
        this._initializedSegmentBuffers = {};
        this._onNativeBufferAddedOrDisabled = [];
    }
    /**
     * Returns true if the type is linked to a "native" media buffer (i.e. relying
     * on a SourceBuffer object, native to the browser).
     * Native media buffers needed for the current content must all be created
     * before the content begins to be played and cannot be disposed during
     * playback.
     * @param {string} bufferType
     * @returns {Boolean}
     */
    static isNative(bufferType) {
        return shouldHaveNativeBuffer(bufferType);
    }
    /**
     * Get all currently available buffer types.
     * /!\ This list can evolve at runtime depending on feature switching.
     * @returns {Array.<string>}
     */
    getBufferTypes() {
        const bufferTypes = this.getNativeBufferTypes();
        if (features/* default.nativeTextTracksBuffer */.Z.nativeTextTracksBuffer != null ||
            features/* default.htmlTextTracksBuffer */.Z.htmlTextTracksBuffer != null) {
            bufferTypes.push("text");
        }
        if (features/* default.imageBuffer */.Z.imageBuffer != null) {
            bufferTypes.push("image");
        }
        return bufferTypes;
    }
    /**
     * Get all "native" buffer types that should be created before beginning to
     * push contents.
     * @returns {Array.<string>}
     */
    getNativeBufferTypes() {
        return this._mediaElement.nodeName === "AUDIO" ? ["audio"] :
            ["video", "audio"];
    }
    /**
     * Returns the current "status" of the SegmentBuffer linked to the buffer
     * type given.
     *
     * This function will return  an object containing a key named `type` which
     * can be equal to either one of those three value:
     *
     *   - "initialized": A SegmentBuffer has been created for that type.
     *     You will in this case also have a second key, `value`, which will
     *     contain the related SegmentBuffer instance.
     *     Please note that you will need to wait until
     *     `this.waitForUsableBuffers()` has emitted before pushing segment
     *     data to a SegmentBuffer relying on a SourceBuffer.
     *
     *   - "disabled": The SegmentBuffer has been explicitely disabled for this
     *     type.
     *
     *   - "uninitialized": No action has yet been yet for that SegmentBuffer.
     *
     * @param {string} bufferType
     * @returns {Object|null}
     */
    getStatus(bufferType) {
        const initializedBuffer = this._initializedSegmentBuffers[bufferType];
        return initializedBuffer === undefined ? { type: "uninitialized" } :
            initializedBuffer === null ? { type: "disabled" } :
                { type: "initialized",
                    value: initializedBuffer };
    }
    /**
     * Native media buffers (audio and video) needed for playing the current
     * content need to all be created (by creating SegmentBuffers linked to them)
     * before any one can be used.
     *
     * This function will return an Observable emitting when any and all native
     * SourceBuffers can be used.
     *
     * From https://w3c.github.io/media-source/#methods
     *   For example, a user agent may throw a QuotaExceededError
     *   exception if the media element has reached the HAVE_METADATA
     *   readyState. This can occur if the user agent's media engine
     *   does not support adding more tracks during playback.
     * @return {Observable}
     */
    waitForUsableBuffers() {
        if (this._areNativeBuffersUsable()) {
            return (0,of.of)(undefined);
        }
        return new Observable/* Observable */.y(obs => {
            this._onNativeBufferAddedOrDisabled.push(() => {
                if (this._areNativeBuffersUsable()) {
                    obs.next(undefined);
                    obs.complete();
                }
            });
        });
    }
    /**
     * Explicitely disable the SegmentBuffer for a given buffer type.
     * A call to this function is needed at least for unused native buffer types
     * (usually "audio" and "video"), to be able to emit through
     * `waitForUsableBuffers` when conditions are met.
     * @param {string}
     */
    disableSegmentBuffer(bufferType) {
        const currentValue = this._initializedSegmentBuffers[bufferType];
        if (currentValue === null) {
            log/* default.warn */.Z.warn(`SBS: The ${bufferType} SegmentBuffer was already disabled.`);
            return;
        }
        if (currentValue !== undefined) {
            throw new Error("Cannot disable an active SegmentBuffer.");
        }
        this._initializedSegmentBuffers[bufferType] = null;
        if (SegmentBuffersStore.isNative(bufferType)) {
            this._onNativeBufferAddedOrDisabled.forEach(cb => cb());
        }
    }
    /**
     * Creates a new SegmentBuffer associated to a type.
     * Reuse an already created one if a SegmentBuffer for the given type
     * already exists.
     *
     * Please note that you will need to wait until `this.waitForUsableBuffers()`
     * has emitted before pushing segment data to a SegmentBuffer of a native
     * type.
     * @param {string} bufferType
     * @param {string} codec
     * @param {Object|undefined} options
     * @returns {Object}
     */
    createSegmentBuffer(bufferType, codec, options = {}) {
        const memorizedSegmentBuffer = this._initializedSegmentBuffers[bufferType];
        if (shouldHaveNativeBuffer(bufferType)) {
            if (memorizedSegmentBuffer != null) {
                if (memorizedSegmentBuffer instanceof audio_video &&
                    memorizedSegmentBuffer.codec !== codec) {
                    log/* default.warn */.Z.warn("SB: Reusing native SegmentBuffer with codec", memorizedSegmentBuffer.codec, "for codec", codec);
                }
                else {
                    log/* default.info */.Z.info("SB: Reusing native SegmentBuffer with codec", codec);
                }
                return memorizedSegmentBuffer;
            }
            log/* default.info */.Z.info("SB: Adding native SegmentBuffer with codec", codec);
            const nativeSegmentBuffer = new audio_video(bufferType, codec, this._mediaSource);
            this._initializedSegmentBuffers[bufferType] = nativeSegmentBuffer;
            this._onNativeBufferAddedOrDisabled.forEach(cb => cb());
            return nativeSegmentBuffer;
        }
        if (memorizedSegmentBuffer != null) {
            log/* default.info */.Z.info("SB: Reusing a previous custom SegmentBuffer for the type", bufferType);
            return memorizedSegmentBuffer;
        }
        let segmentBuffer;
        if (bufferType === "text") {
            log/* default.info */.Z.info("SB: Creating a new text SegmentBuffer");
            if (options.textTrackMode === "html") {
                if (features/* default.htmlTextTracksBuffer */.Z.htmlTextTracksBuffer == null) {
                    throw new Error("HTML Text track feature not activated");
                }
                segmentBuffer = new features/* default.htmlTextTracksBuffer */.Z.htmlTextTracksBuffer(this._mediaElement, options.textTrackElement);
            }
            else {
                if (features/* default.nativeTextTracksBuffer */.Z.nativeTextTracksBuffer == null) {
                    throw new Error("Native Text track feature not activated");
                }
                segmentBuffer = new features/* default.nativeTextTracksBuffer */.Z.nativeTextTracksBuffer(this._mediaElement, options.hideNativeSubtitle === true);
            }
            this._initializedSegmentBuffers.text = segmentBuffer;
            return segmentBuffer;
        }
        else if (bufferType === "image") {
            if (features/* default.imageBuffer */.Z.imageBuffer == null) {
                throw new Error("Image buffer feature not activated");
            }
            log/* default.info */.Z.info("SB: Creating a new image SegmentBuffer");
            segmentBuffer = new features/* default.imageBuffer */.Z.imageBuffer();
            this._initializedSegmentBuffers.image = segmentBuffer;
            return segmentBuffer;
        }
        log/* default.error */.Z.error("SB: Unknown buffer type:", bufferType);
        throw new media_error/* default */.Z("BUFFER_TYPE_UNKNOWN", "The player wants to create a SegmentBuffer " +
            "of an unknown type.");
    }
    /**
     * Dispose of the active SegmentBuffer for the given type.
     * @param {string} bufferType
     */
    disposeSegmentBuffer(bufferType) {
        const memorizedSegmentBuffer = this._initializedSegmentBuffers[bufferType];
        if (memorizedSegmentBuffer == null) {
            log/* default.warn */.Z.warn("SB: Trying to dispose a SegmentBuffer that does not exist");
            return;
        }
        log/* default.info */.Z.info("SB: Aborting SegmentBuffer", bufferType);
        memorizedSegmentBuffer.dispose();
        delete this._initializedSegmentBuffers[bufferType];
    }
    /**
     * Dispose of all SegmentBuffer created on this SegmentBuffersStore.
     */
    disposeAll() {
        POSSIBLE_BUFFER_TYPES.forEach((bufferType) => {
            if (this.getStatus(bufferType).type === "initialized") {
                this.disposeSegmentBuffer(bufferType);
            }
        });
    }
    /**
     * Returns `true` when we're ready to push and decode contents to
     * SourceBuffers created by SegmentBuffers of a native buffer type.
     */
    _areNativeBuffersUsable() {
        const nativeBufferTypes = this.getNativeBufferTypes();
        const hasUnitializedBuffers = nativeBufferTypes.some(sbType => this._initializedSegmentBuffers[sbType] === undefined);
        if (hasUnitializedBuffers) {
            // one is not yet initialized/disabled
            return false;
        }
        const areAllDisabled = nativeBufferTypes.every(sbType => this._initializedSegmentBuffers[sbType] === null);
        if (areAllDisabled) {
            // they all are disabled: we can't play the content
            return false;
        }
        return true;
    }
}
/**
 * Returns true if the given buffeType has a linked SourceBuffer implementation,
 * false otherwise.
 * SourceBuffers are directly added to the MediaSource.
 * @param {string} bufferType
 * @returns {Boolean}
 */
function shouldHaveNativeBuffer(bufferType) {
    return bufferType === "audio" || bufferType === "video";
}

;// CONCATENATED MODULE: ./src/core/segment_buffers/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/* harmony default export */ const segment_buffers = (SegmentBuffersStore);


;// CONCATENATED MODULE: ./src/utils/sorted_list.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Creates an Array automatically sorted with the sorting function given to the
 * constructor when the add method is called.
 *
 * @example
 * ```js
 * const sortedList = new SortedList((a, b) => a.start - b.start);
 * const element1 = { start: 20 };
 * const element2 = { start: 10 };
 * const element3 = { start: 15 };
 *
 * sortedList.add(element1, element2);
 * console.log(sortedList.unwrap());
 * // -> [{ start: 10 }, { start : 20 }]
 *
 * sortedList.add(element3);
 * console.log(sortedList.unwrap());
 * // -> [{ start: 10 }, { start : 15 }, { start: 20 }]
 *
 * sortedList.removeElement(element2);
 * // -> [{ start: 10 }, { start: 15 }]
 * ```
 * @class SortedList
 */
class SortedList {
    /**
     * @param {Function} sortingFunction
     */
    constructor(sortingFunction) {
        this._array = [];
        this._sortingFn = sortingFunction;
    }
    /**
     * Add a new element to the List at the right place for the List to stay
     * sorted.
     *
     * /!\ The added Element will share the same reference than the given
     * argument, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @param {...*} elements
     */
    add(...elements) {
        elements.sort(this._sortingFn);
        let j = 0;
        for (let i = 0; i < elements.length; i++) {
            const element = elements[i];
            let inserted = false;
            while (!inserted && j < this._array.length) {
                if (this._sortingFn(element, this._array[j]) < 0) {
                    this._array.splice(j, 0, element);
                    inserted = true;
                }
                else {
                    j++;
                }
            }
            if (!inserted) {
                this._array.push(element);
            }
        }
    }
    /**
     * Returns the current length of the list.
     * @returns {number}
     */
    length() {
        return this._array.length;
    }
    /**
     * Returns the nth element. Throws if the index does not exist.
     *
     * /!\ The returned Element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @throws Error - Throws if the given index is negative or superior to the
     * array's length.
     * @param {number} index
     * @returns {*}
     */
    get(index) {
        if (index < 0 || index >= this._array.length) {
            throw new Error("Invalid index.");
        }
        return this._array[index];
    }
    /**
     * Find the first element corresponding to the given predicate.
     *
     * /!\ The returned element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @param {Function} fn
     * @returns {*}
     */
    findFirst(fn) {
        return (0,array_find/* default */.Z)(this._array, fn);
    }
    /**
     * Returns true if the List contains the given element.
     * @param {*} element
     * @returns {Boolean}
     */
    has(element) {
        return (0,array_includes/* default */.Z)(this._array, element);
    }
    /**
     * Remove the first occurence of the given element.
     * Returns the index of the removed element. Undefined if not found.
     * @returns {number|undefined}
     */
    removeElement(element) {
        const indexOf = this._array.indexOf(element);
        if (indexOf >= 0) {
            this._array.splice(indexOf, 1);
            return indexOf;
        }
        return undefined;
    }
    /**
     * Returns the first element.
     *
     * /!\ The returned Element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @returns {*}
     */
    head() {
        return this._array[0];
    }
    /**
     * Returns the last element.
     *
     * /!\ The returned Element shares the same reference with what is used
     * internally, any mutation on your part can lead to an un-sorted SortedList.
     * You can still re-force the sorting to happen by calling forceSort.
     * @returns {*}
     */
    last() {
        return this._array[this._array.length - 1];
    }
    /**
     * Remove the first element.
     * Returns the element removed or undefined if no element were removed.
     * @returns {*}
     */
    shift() {
        return this._array.shift();
    }
    /**
     * Remove the last element.
     * Returns the element removed or undefined if no element were removed.
     * @returns {*}
     */
    pop() {
        return this._array.pop();
    }
}

;// CONCATENATED MODULE: ./src/utils/weak_map_memory.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Memoize Function results linked to an object, through a WeakMap.
 *
 * @example
 * ```js
 * // Initialize the WeakMapMemory with its logic:
 * const memory = new WeakMapMemory(arg => {
 *   console.log("side-effect");
 *   return [arg.a, arg.b];
 * });
 *
 * const obj = { a: 1, b: 2 };
 *
 * // first time obj is given: call the function, save the result and return it:
 * const arr1 = memory.get(obj);
 * // >  "side-effect"
 * // <- [1, 2]
 *
 * // nth time obj is given, returns the saved result without calling the
 * // function:
 * const arr2 = memory.get(obj);
 * // <- [1, 2]
 *
 * // both of these use the same object, so the result is also the exact same
 * // one
 * console.log(arr1 === arr2); // => true
 *
 * // /!\ with a new object however:
 * const obj2 = { a: 1, b: 2 };
 *
 * const arr3 = memory.get(obj2);
 * // >  "side-effect"
 * // <- [1, 2]
 *
 * console.log(arr1 === arr3); // => false
 * ```
 * @class WeakMapMemory
 */
// eslint-disable-next-line @typescript-eslint/ban-types
class WeakMapMemory {
    /**
     * @param {Function}
     */
    constructor(fn) {
        this._weakMap = new WeakMap();
        this._fn = fn;
    }
    /**
     * @param {Object} obj
     * @returns {*}
     */
    get(obj) {
        const fromMemory = this._weakMap.get(obj);
        if (fromMemory === undefined) {
            const newElement = this._fn(obj);
            this._weakMap.set(obj, newElement);
            return newElement;
        }
        else {
            return fromMemory;
        }
    }
    /**
     * @param {Object} obj
     */
    destroy(obj) {
        this._weakMap.delete(obj);
    }
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/concatAll.js
var concatAll = __webpack_require__(28358);
;// CONCATENATED MODULE: ./src/core/segment_buffers/garbage_collector.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Perform cleaning of the buffer according to the values set by the user
 * at each clock tick and each times the maxBufferBehind/maxBufferAhead values
 * change.
 *
 * @param {Object} opt
 * @returns {Observable}
 */
function BufferGarbageCollector({ segmentBuffer, clock$, maxBufferBehind$, maxBufferAhead$, }) {
    return (0,combineLatest/* combineLatest */.aj)([clock$, maxBufferBehind$, maxBufferAhead$]).pipe((0,mergeMap/* mergeMap */.zg)(([currentTime, maxBufferBehind, maxBufferAhead]) => {
        return clearBuffer(segmentBuffer, currentTime, maxBufferBehind, maxBufferAhead);
    }));
}
/**
 * Remove buffer from the browser's memory based on the user's
 * maxBufferAhead / maxBufferBehind settings.
 *
 * Normally, the browser garbage-collect automatically old-added chunks of
 * buffer data when memory is scarce. However, you might want to control
 * the size of memory allocated. This function takes the current position
 * and a "depth" behind and ahead wanted for the buffer, in seconds.
 *
 * Anything older than the depth will be removed from the buffer.
 * @param {Object} segmentBuffer
 * @param {Number} position - The current position
 * @param {Number} maxBufferBehind
 * @param {Number} maxBufferAhead
 * @returns {Observable}
 */
function clearBuffer(segmentBuffer, position, maxBufferBehind, maxBufferAhead) {
    if (!isFinite(maxBufferBehind) && !isFinite(maxBufferAhead)) {
        return empty/* EMPTY */.E;
    }
    const cleanedupRanges = [];
    const { innerRange, outerRanges } = (0,ranges/* getInnerAndOuterTimeRanges */.F_)(segmentBuffer.getBufferedRanges(), position);
    const collectBufferBehind = () => {
        if (!isFinite(maxBufferBehind)) {
            return;
        }
        // begin from the oldest
        for (let i = 0; i < outerRanges.length; i++) {
            const outerRange = outerRanges[i];
            if (position - maxBufferBehind >= outerRange.end) {
                cleanedupRanges.push(outerRange);
            }
            else if (position >= outerRange.end &&
                position - maxBufferBehind > outerRange.start &&
                position - maxBufferBehind < outerRange.end) {
                cleanedupRanges.push({ start: outerRange.start,
                    end: position - maxBufferBehind });
            }
        }
        if (innerRange != null) {
            if (position - maxBufferBehind > innerRange.start) {
                cleanedupRanges.push({ start: innerRange.start,
                    end: position - maxBufferBehind });
            }
        }
    };
    const collectBufferAhead = () => {
        if (!isFinite(maxBufferAhead)) {
            return;
        }
        // begin from the oldest
        for (let i = 0; i < outerRanges.length; i++) {
            const outerRange = outerRanges[i];
            if (position + maxBufferAhead <= outerRange.start) {
                cleanedupRanges.push(outerRange);
            }
            else if (position <= outerRange.start &&
                position + maxBufferAhead < outerRange.end &&
                position + maxBufferAhead > outerRange.start) {
                cleanedupRanges.push({ start: position + maxBufferAhead,
                    end: outerRange.end });
            }
        }
        if (innerRange != null) {
            if (position + maxBufferAhead < innerRange.end) {
                cleanedupRanges.push({ start: position + maxBufferAhead,
                    end: innerRange.end });
            }
        }
    };
    collectBufferBehind();
    collectBufferAhead();
    const clean$ = (0,from/* from */.D)(cleanedupRanges.map((range) => {
        log/* default.debug */.Z.debug("GC: cleaning range from SegmentBuffer", range);
        return segmentBuffer.removeBuffer(range.start, range.end);
    })).pipe((0,concatAll/* concatAll */.u)(), (0,ignoreElements/* ignoreElements */.l)());
    return clean$;
}

;// CONCATENATED MODULE: ./src/core/stream/events_generators.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EVENTS = {
    activePeriodChanged(period) {
        return { type: "activePeriodChanged",
            value: { period } };
    },
    adaptationChange(bufferType, adaptation, period) {
        return { type: "adaptationChange",
            value: { type: bufferType,
                adaptation,
                period } };
    },
    addedSegment(content, segment, buffered, segmentData) {
        return { type: "added-segment",
            value: { content,
                segment,
                segmentData,
                buffered } };
    },
    bitrateEstimationChange(type, bitrate) {
        return { type: "bitrateEstimationChange",
            value: { type, bitrate } };
    },
    streamComplete(bufferType) {
        return { type: "complete-stream",
            value: { type: bufferType } };
    },
    endOfStream() {
        return { type: "end-of-stream",
            value: undefined };
    },
    needsManifestRefresh() {
        return { type: "needs-manifest-refresh",
            value: undefined };
    },
    manifestMightBeOufOfSync() {
        return { type: "manifest-might-be-out-of-sync",
            value: undefined };
    },
    /**
     * @param {Object} period - The Period to which the stream logic asking for a
     * media source reload is linked.
     * @param {number} reloadAt - Position at which we should reload
     * @param {boolean} reloadOnPause - If `false`, stay on pause after reloading.
     * if `true`, automatically play once reloaded.
     * @returns {Object}
     */
    needsMediaSourceReload(period, reloadAt, reloadOnPause) {
        return { type: "needs-media-source-reload",
            value: { position: reloadAt,
                autoPlay: reloadOnPause,
                period } };
    },
    needsDecipherabilityFlush(position, autoPlay, duration) {
        return { type: "needs-decipherability-flush",
            value: { position, autoPlay, duration } };
    },
    periodStreamReady(type, period, adaptation$) {
        return { type: "periodStreamReady",
            value: { type, period, adaptation$ } };
    },
    periodStreamCleared(type, period) {
        return { type: "periodStreamCleared",
            value: { type, period } };
    },
    encryptionDataEncountered(initDataInfo) {
        return { type: "encryption-data-encountered",
            value: initDataInfo };
    },
    representationChange(type, period, representation) {
        return { type: "representationChange",
            value: { type, period, representation } };
    },
    streamTerminating() {
        return { type: "stream-terminating",
            value: undefined };
    },
    resumeStream() {
        return { type: "resume-stream",
            value: undefined };
    },
    warning(value) {
        return { type: "warning", value };
    },
};
/* harmony default export */ const stream_events_generators = (EVENTS);

// EXTERNAL MODULE: ./node_modules/next-tick/index.js
var next_tick = __webpack_require__(39945);
var next_tick_default = /*#__PURE__*/__webpack_require__.n(next_tick);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeWhile.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function takeWhile(predicate, inclusive) {
  if (inclusive === void 0) {
    inclusive = false;
  }

  return function (source) {
    return source.lift(new TakeWhileOperator(predicate, inclusive));
  };
}

var TakeWhileOperator = /*@__PURE__*/function () {
  function TakeWhileOperator(predicate, inclusive) {
    this.predicate = predicate;
    this.inclusive = inclusive;
  }

  TakeWhileOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
  };

  return TakeWhileOperator;
}();

var TakeWhileSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(TakeWhileSubscriber, _super);

  function TakeWhileSubscriber(destination, predicate, inclusive) {
    var _this = _super.call(this, destination) || this;

    _this.predicate = predicate;
    _this.inclusive = inclusive;
    _this.index = 0;
    return _this;
  }

  TakeWhileSubscriber.prototype._next = function (value) {
    var destination = this.destination;
    var result;

    try {
      result = this.predicate(value, this.index++);
    } catch (err) {
      destination.error(err);
      return;
    }

    this.nextOrComplete(value, result);
  };

  TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
    var destination = this.destination;

    if (Boolean(predicateResult)) {
      destination.next(value);
    } else {
      if (this.inclusive) {
        destination.next(value);
      }

      destination.complete();
    }
  };

  return TakeWhileSubscriber;
}(Subscriber/* Subscriber */.L);
;// CONCATENATED MODULE: ./src/core/stream/representation/check_for_discontinuity.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Check if there is a soon-to-be-encountered discontinuity in the buffer that
 * won't be filled by any future segment.
 * This function will only check discontinuities for the given `checkedRange`.
 *
 * @param {Object} content - The content we are currently loading.
 * @param {Object} checkedRange - The time range that will be checked for
 * discontinuities.
 * Both `nextSegmentStart` and `bufferedSegments` arguments can only refer to
 * that range.
 * @param {number|null} nextSegmentStart - The start time in seconds of the next
 * not-yet-pushed segment that can be pushed, in the limits of `checkedRange`.
 * This includes segments which have not been loaded or pushed yet, but also
 * segments which might be re-downloaded because currently incomplete in the
 * buffer, the point being to know what is the earliest time in the buffer where
 * a segment might be pushed in the future.
 * `null` if no segment in `checkedRange` will be pushed under current buffer's
 * conditions.
 * @param {boolean} hasFinishedLoading - if `true`, all segments for the current
 * Period have been loaded and none will be loaded in the future under the
 * current buffer's state.
 * @param {Array.<Object>} bufferedSegments - Information about every segments
 * currently in the buffer, in chronological order.
 * Only segments overlapping with the given `checkedRange` will be looked at,
 * though the array given can be larger.
 */
function checkForDiscontinuity(content, checkedRange, nextSegmentStart, hasFinishedLoading, bufferedSegments) {
    const { period, adaptation, representation } = content;
    // `bufferedSegments` might also contains segments which are before
    // `checkedRange`.
    // Here we want the first one that goes over `checkedRange.start`, to  see
    // if there's a discontinuity at the beginning in the buffer
    const nextBufferedInRangeIdx = getIndexOfFirstChunkInRange(bufferedSegments, checkedRange);
    if (nextBufferedInRangeIdx === null) {
        // There's no segment currently buffered for the current range.
        if (nextSegmentStart === null) { // No segment to load in that range
            // Check if we are in a discontinuity at the end of the current Period
            if (hasFinishedLoading &&
                period.end !== undefined &&
                checkedRange.end >= period.end) {
                return { start: undefined, end: null }; // discontinuity to Period's end
            }
            // Check that there is a discontinuity announced in the Manifest there
            const discontinuityEnd = representation.index
                .checkDiscontinuity(checkedRange.start);
            if (discontinuityEnd !== null) {
                return { start: undefined,
                    end: discontinuityEnd };
            }
        }
        return null;
    }
    const nextBufferedSegment = bufferedSegments[nextBufferedInRangeIdx];
    // Check if there is a hole that won't be filled before `nextSegmentStart`
    if (
    // Next buffered segment starts after the start of the current range
    nextBufferedSegment.bufferedStart !== undefined &&
        nextBufferedSegment.bufferedStart > checkedRange.start &&
        // and no segment will fill in that hole
        (nextSegmentStart === null ||
            nextBufferedSegment.infos.segment.end <= nextSegmentStart)) {
        log/* default.debug */.Z.debug("RS: current discontinuity encountered", adaptation.type, nextBufferedSegment.bufferedStart);
        return { start: undefined,
            end: nextBufferedSegment.bufferedStart };
    }
    // Check if there's a discontinuity BETWEEN segments of the current range
    const nextHoleIdx = getIndexOfFirstDiscontinuityBetweenChunks(bufferedSegments, checkedRange, nextBufferedInRangeIdx + 1);
    // If there was a hole between two consecutives segments, and if this hole
    // comes before the next segment to load, there is a discontinuity (that hole!)
    if (nextHoleIdx !== null &&
        (nextSegmentStart === null ||
            bufferedSegments[nextHoleIdx].infos.segment.end <= nextSegmentStart)) {
        const start = bufferedSegments[nextHoleIdx - 1].bufferedEnd;
        const end = bufferedSegments[nextHoleIdx].bufferedStart;
        log/* default.debug */.Z.debug("RS: future discontinuity encountered", adaptation.type, start, end);
        return { start, end };
    }
    else if (nextSegmentStart === null) {
        // If no hole between segments and no segment to load, check for a
        // discontinuity at the end of the Period
        if (hasFinishedLoading && period.end !== undefined) { // Period is finished
            if (checkedRange.end < period.end) { // We've not reached the Period's end yet
                return null;
            }
            // Check if the last buffered segment ends before this Period's end
            // In which case there is a discontinuity between those
            const lastBufferedInPeriodIdx = getIndexOfLastChunkInPeriod(bufferedSegments, period.end);
            if (lastBufferedInPeriodIdx !== null) {
                const lastSegment = bufferedSegments[lastBufferedInPeriodIdx];
                if (lastSegment.bufferedEnd !== undefined &&
                    lastSegment.bufferedEnd < period.end) {
                    log/* default.debug */.Z.debug("RS: discontinuity encountered at the end of the current period", adaptation.type, lastSegment.bufferedEnd, period.end);
                    return { start: lastSegment.bufferedEnd,
                        end: null };
                }
            }
        }
        // At last, check if we don't have a discontinuity at the end of the current
        // range, announced in the Manifest, that is too big to be detected through
        // the previous checks.
        if (period.end !== undefined && checkedRange.end >= period.end) {
            return null; // The previous checks should have taken care of those
        }
        for (let bufIdx = bufferedSegments.length - 1; bufIdx >= 0; bufIdx--) {
            const bufSeg = bufferedSegments[bufIdx];
            if (bufSeg.bufferedStart === undefined) {
                break;
            }
            if (bufSeg.bufferedStart < checkedRange.end) {
                if (bufSeg.bufferedEnd !== undefined && bufSeg.bufferedEnd < checkedRange.end) {
                    const discontinuityEnd = representation.index
                        .checkDiscontinuity(checkedRange.end);
                    if (discontinuityEnd !== null) {
                        return { start: bufSeg.bufferedEnd,
                            end: discontinuityEnd };
                    }
                }
                return null;
            }
        }
    }
    return null;
}
/**
 * Returns the index of the first element in `bufferedChunks` that is part of
 * `range` (starts before it ends and ends after it starts).
 *
 * Returns `null` if no element is found in that range or if we cannot know the
 * index of the first element in it.
 * @param {Array.<Object>} bufferedChunks
 * @param {Object} range
 * @returns {number|null}
 */
function getIndexOfFirstChunkInRange(bufferedChunks, range) {
    for (let bufIdx = 0; bufIdx < bufferedChunks.length; bufIdx++) {
        const bufSeg = bufferedChunks[bufIdx];
        if (bufSeg.bufferedStart === undefined ||
            bufSeg.bufferedEnd === undefined ||
            bufSeg.bufferedStart >= range.end) {
            return null;
        }
        if (bufSeg.bufferedEnd > range.start) {
            return bufIdx;
        }
    }
    return null;
}
/**
 * Returns the index of the first element in `bufferedChunks` which is not
 * immediately consecutive to the one before it.
 *
 * `startFromIndex` is the index of the first segment that will be checked with
 * the element coming before it. As such, it has to be superior to 0.
 *
 * If the element at `startFromIndex` comes immediately after the one before it,
 * the element at `startFromIndex + 1` will be checked instead and so on until a
 * segment completely out of `checkedRange` (which starts after it) is detected.
 *
 * If no hole between elements is found, `null` is returned.
 * @param {Array.<Object>} bufferedChunks
 * @param {Object} range
 * @param {number} startFromIndex
 * @returns {number|null}
 */
function getIndexOfFirstDiscontinuityBetweenChunks(bufferedChunks, range, startFromIndex) {
    if (startFromIndex <= 0) {
        log/* default.error */.Z.error("RS: Asked to check a discontinuity before the first chunk.");
        return null;
    }
    for (let bufIdx = startFromIndex; bufIdx < bufferedChunks.length; bufIdx++) {
        const currSegment = bufferedChunks[bufIdx];
        const prevSegment = bufferedChunks[bufIdx - 1];
        // Exit as soon we miss information or when we go further than `checkedRange`
        if (currSegment.bufferedStart === undefined ||
            prevSegment.bufferedEnd === undefined ||
            currSegment.bufferedStart >= range.end) {
            return null;
        }
        // If there is a hole between two consecutive buffered segment
        if (currSegment.bufferedStart - prevSegment.bufferedEnd > 0) {
            return bufIdx;
        }
    }
    return null;
}
/**
 * Returns the index of the last element in `bufferedChunks` that is part of
 * `range` (starts before it ends and ends after it starts).
 *
 * Returns `null` if no element is found in that range or if we cannot know the
 * index of the last element in it.
 * @param {Array.<Object>} bufferedChunks
 * @param {number} periodEnd
 * @returns {number|null}
 */
function getIndexOfLastChunkInPeriod(bufferedChunks, periodEnd) {
    for (let bufIdx = bufferedChunks.length - 1; bufIdx >= 0; bufIdx--) {
        const bufSeg = bufferedChunks[bufIdx];
        if (bufSeg.bufferedStart === undefined) {
            return null;
        }
        if (bufSeg.bufferedStart < periodEnd) {
            return bufIdx;
        }
    }
    return null;
}

// EXTERNAL MODULE: ./src/manifest/are_same_content.ts
var are_same_content = __webpack_require__(96667);
;// CONCATENATED MODULE: ./src/core/stream/representation/get_needed_segments.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// eslint-disable-next-line max-len




const { CONTENT_REPLACEMENT_PADDING, BITRATE_REBUFFERING_RATIO, MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT, MINIMUM_SEGMENT_SIZE } = config/* default */.Z;
/**
 * Epsilon compensating for rounding errors when comparing the start and end
 * time of multiple segments.
 */
const ROUNDING_ERROR = Math.min(1 / 60, MINIMUM_SEGMENT_SIZE);
/**
 * Return the list of segments that can currently be downloaded to fill holes
 * in the buffer in the given range, including already-pushed segments currently
 * incomplete in the buffer.
 * This list might also include already-loaded segments in a higher bitrate,
 * according to the given configuration.
 * Excludes segment that are already being pushed.
 * @param {Object} args
 * @returns {Array.<Object>}
 */
function getNeededSegments({ content, currentPlaybackTime, fastSwitchThreshold, neededRange, segmentsBeingPushed, bufferedSegments, }) {
    const { representation } = content;
    const availableSegmentsForRange = representation.index
        .getSegments(neededRange.start, neededRange.end - neededRange.start);
    // Remove from `bufferedSegments` any segments we would prefer to replace:
    //   - segments in the wrong track / bad quality
    //   - garbage-collected segments
    const segmentsToKeep = bufferedSegments
        .filter((bufferedSegment) => !shouldContentBeReplaced(bufferedSegment.infos, content, currentPlaybackTime, fastSwitchThreshold))
        .filter((currentSeg, i, consideredSegments) => {
        const prevSeg = i === 0 ? null :
            consideredSegments[i - 1];
        const nextSeg = i >= consideredSegments.length - 1 ? null :
            consideredSegments[i + 1];
        return !isStartGarbageCollected(currentSeg, prevSeg, neededRange.start) &&
            !isEndGarbageCollected(currentSeg, nextSeg, neededRange.end);
    });
    const segmentsToDownload = availableSegmentsForRange.filter(segment => {
        const contentObject = (0,object_assign/* default */.Z)({ segment }, content);
        // First, check that the segment is not already being pushed
        if (segmentsBeingPushed.length > 0) {
            const isAlreadyBeingPushed = segmentsBeingPushed
                .some((pendingSegment) => (0,are_same_content/* default */.Z)(contentObject, pendingSegment));
            if (isAlreadyBeingPushed) {
                return false;
            }
        }
        const { duration, time, end } = segment;
        if (segment.isInit) {
            return true; // never skip initialization segments
        }
        if (duration < MINIMUM_SEGMENT_SIZE) {
            return false; // too small, don't download
        }
        // Check if the same segment from another Representation is not already
        // being pushed.
        if (segmentsBeingPushed.length > 0) {
            const waitForPushedSegment = segmentsBeingPushed.some((pendingSegment) => {
                if (pendingSegment.period.id !== content.period.id ||
                    pendingSegment.adaptation.id !== content.adaptation.id) {
                    return false;
                }
                const { segment: oldSegment } = pendingSegment;
                if ((oldSegment.time - ROUNDING_ERROR) > time) {
                    return false;
                }
                if ((oldSegment.end + ROUNDING_ERROR) < end) {
                    return false;
                }
                return !shouldContentBeReplaced(pendingSegment, contentObject, currentPlaybackTime, fastSwitchThreshold);
            });
            if (waitForPushedSegment) {
                return false;
            }
        }
        // check if the segment is already downloaded
        for (let i = 0; i < segmentsToKeep.length; i++) {
            const completeSeg = segmentsToKeep[i];
            const areFromSamePeriod = completeSeg.infos.period.id === content.period.id;
            // Check if content are from same period, as there can't be overlapping
            // periods, we should consider a segment as already downloaded if
            // it is from same period (but can be from different adaptation or
            // representation)
            if (areFromSamePeriod) {
                const completeSegInfos = completeSeg.infos.segment;
                if (time - completeSegInfos.time > -ROUNDING_ERROR &&
                    completeSegInfos.end - end > -ROUNDING_ERROR) {
                    return false; // already downloaded
                }
            }
        }
        // check if there is an hole in place of the segment currently
        for (let i = 0; i < segmentsToKeep.length; i++) {
            const completeSeg = segmentsToKeep[i];
            if (completeSeg.end > time) {
                // `true` if `completeSeg` starts too far after `time`
                return completeSeg.start > time + ROUNDING_ERROR ||
                    // `true` if `completeSeg` ends too soon before `end`
                    getLastContiguousSegment(segmentsToKeep, i).end < end - ROUNDING_ERROR;
            }
        }
        return true;
    });
    return segmentsToDownload;
}
/**
 * From the given array of buffered chunks (`bufferedSegments`) returns the last
 * buffered chunk contiguous with the one at the `startIndex` index given.
 * @param {Array.<Object>}
 * @param {number} startIndex
 * @returns {Object}
 */
function getLastContiguousSegment(bufferedSegments, startIndex) {
    let j = startIndex + 1;
    // go through all contiguous segments and take the last one
    while (j < bufferedSegments.length - 1 &&
        (bufferedSegments[j - 1].end + ROUNDING_ERROR) >
            bufferedSegments[j].start) {
        j++;
    }
    j--; // index of last contiguous segment
    return bufferedSegments[j];
}
/**
 * Returns `true` if segments linked to the given `oldContent` currently present
 * in the buffer should be replaced by segments coming from `currentContent`.
 * @param {Object} oldContent
 * @param {Object} currentContent
 * @param {number} currentPlaybackTime
 * @param {number} [fastSwitchThreshold]
 * @returns {boolean}
 */
function shouldContentBeReplaced(oldContent, currentContent, currentPlaybackTime, fastSwitchThreshold) {
    if (oldContent.period.id !== currentContent.period.id) {
        return false; // keep segments from another Period by default.
    }
    const { segment } = oldContent;
    if (segment.time < (currentPlaybackTime + CONTENT_REPLACEMENT_PADDING)) {
        return false;
    }
    if (oldContent.adaptation.id !== currentContent.adaptation.id) {
        return true; // replace segments from another Adaptation
    }
    return canFastSwitch(oldContent.representation, currentContent.representation, fastSwitchThreshold);
}
/**
 * Returns `true` if segments from the new Representation can replace
 * previously-loaded segments from the old Representation given.
 *
 * This behavior is called "fast-switching".
 * @param {Object} oldSegmentRepresentation
 * @param {Object} newSegmentRepresentation
 * @param {number|undefined} fastSwitchThreshold
 * @returns {boolean}
 */
function canFastSwitch(oldSegmentRepresentation, newSegmentRepresentation, fastSwitchThreshold) {
    const oldContentBitrate = oldSegmentRepresentation.bitrate;
    if (fastSwitchThreshold === undefined) {
        // only re-load comparatively-poor bitrates for the same Adaptation.
        const bitrateCeil = oldContentBitrate * BITRATE_REBUFFERING_RATIO;
        return newSegmentRepresentation.bitrate > bitrateCeil;
    }
    return oldContentBitrate < fastSwitchThreshold &&
        newSegmentRepresentation.bitrate > oldContentBitrate;
}
/**
 * From buffered segment information, return `true` if the given `currentSeg`
 * might have been garbage collected at the start.
 * Return `false` if the segment is complete at least from `maximumStartTime`.
 * @param {Object} currentSeg - The segment information for the segment in
 * question.
 * @param {Object|null} prevSeg - The segment information for the previous
 * buffered segment, if one (`null` if none).
 * @param {number} maximumStartTime - Only consider the data after that time.
 * If `currentSeg` has only been garbage collected for some data which is before
 * that time, we will return `false`.
 */
function isStartGarbageCollected(currentSeg, prevSeg, maximumStartTime) {
    if (currentSeg.bufferedStart === undefined) {
        log/* default.warn */.Z.warn("Stream: Start of a segment unknown. " +
            "Assuming it is garbage collected by default.", currentSeg);
        return true;
    }
    if (prevSeg !== null && prevSeg.bufferedEnd !== undefined &&
        (currentSeg.bufferedStart - prevSeg.bufferedEnd < 0.1)) {
        return false;
    }
    if (maximumStartTime < currentSeg.bufferedStart &&
        currentSeg.bufferedStart - currentSeg.start >
            MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
        log/* default.info */.Z.info("Stream: The start of the wanted segment has been garbage collected", currentSeg);
        return true;
    }
    return false;
}
/**
 * From buffered segment information, return `true` if the given `currentSeg`
 * might have been garbage collected at the end.
 * Return `false` if the segment is complete at least until `minimumEndTime`.
 * @param {Object} currentSeg - The segment information for the segment in
 * question.
 * @param {Object|null} nextSeg - The segment information for the next buffered
 * segment, if one (`null` if none).
 * @param {number} minimumEndTime - Only consider the data before that time.
 * If `currentSeg` has only been garbage collected for some data which is after
 * that time, we will return `false`.
 */
function isEndGarbageCollected(currentSeg, nextSeg, minimumEndTime) {
    if (currentSeg.bufferedEnd === undefined) {
        log/* default.warn */.Z.warn("Stream: End of a segment unknown. " +
            "Assuming it is garbage collected by default.", currentSeg);
        return true;
    }
    if (nextSeg !== null && nextSeg.bufferedStart !== undefined &&
        (nextSeg.bufferedStart - currentSeg.bufferedEnd < 0.1)) {
        return false;
    }
    if (minimumEndTime > currentSeg.bufferedEnd &&
        currentSeg.end - currentSeg.bufferedEnd > MAX_TIME_MISSING_FROM_COMPLETE_SEGMENT) {
        log/* default.info */.Z.info("Stream: The end of the wanted segment has been garbage collected", currentSeg);
        return true;
    }
    return false;
}

;// CONCATENATED MODULE: ./src/core/stream/representation/get_segment_priority.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { SEGMENT_PRIORITIES_STEPS } = config/* default */.Z;
/**
 * Calculate the priority number for a given time, in function of the distance
 * with the current time.
 *
 * The lower is this number, the higher should be the priority of the request.
 *
 * Note that a `timeWanted` given behind the current time will always have the
 * highest priority.
 * @param {number} timeWanted
 * @param {Object} clockTick
 * @returns {number}
 */
function getSegmentPriority(timeWanted, clockTick) {
    const currentTime = clockTick.position + clockTick.wantedTimeOffset;
    const distance = timeWanted - currentTime;
    for (let priority = 0; priority < SEGMENT_PRIORITIES_STEPS.length; priority++) {
        if (distance < SEGMENT_PRIORITIES_STEPS[priority]) {
            return priority;
        }
    }
    return SEGMENT_PRIORITIES_STEPS.length;
}

;// CONCATENATED MODULE: ./src/core/stream/representation/get_buffer_status.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





const { MINIMUM_SEGMENT_SIZE: get_buffer_status_MINIMUM_SEGMENT_SIZE } = config/* default */.Z;
/**
 * Checks on the current buffered data for the given type and Period
 * and returns what should be done to fill the buffer according to the buffer
 * goal, the Representation chosen, etc.
 * Also emits discontinuities if found, which are parts of the buffer that won't
 * be filled by any segment, even in the future.
 *
 * @param {Object} content
 * @param {Object} tick
 * @param {number|undefined} fastSwitchThreshold
 * @param {number} bufferGoal
 * @param {Object} segmentBuffer
 * @returns {Object}
 */
function getBufferStatus(content, tick, fastSwitchThreshold, bufferGoal, segmentBuffer) {
    var _a;
    const { period, representation } = content;
    segmentBuffer.synchronizeInventory();
    const wantedStartPosition = tick.position + tick.wantedTimeOffset;
    const wantedEndPosition = wantedStartPosition + bufferGoal;
    const neededRange = { start: Math.max(wantedStartPosition, period.start), end: Math.min(wantedEndPosition, (_a = period.end) !== null && _a !== void 0 ? _a : Infinity) };
    const shouldRefreshManifest = representation.index.shouldRefresh(wantedStartPosition, wantedEndPosition);
    /**
     * Every segment awaiting an "EndOfSegment" operation, which indicates that a
     * completely-loaded segment is still being pushed to the SegmentBuffer.
     */
    const segmentsBeingPushed = segmentBuffer.getPendingOperations()
        .filter((operation) => operation.type === types/* SegmentBufferOperation.EndOfSegment */.f.EndOfSegment).map(operation => operation.value);
    /** Data on every segments buffered around `neededRange`. */
    const bufferedSegments = getPlayableBufferedSegments({ start: Math.max(neededRange.start - 0.5, 0),
        end: neededRange.end + 0.5 }, segmentBuffer.getInventory());
    /** List of segments we will need to download. */
    const neededSegments = getNeededSegments({ content,
        currentPlaybackTime: tick.getCurrentTime(),
        fastSwitchThreshold,
        neededRange,
        bufferedSegments,
        segmentsBeingPushed })
        .map((segment) => ({ priority: getSegmentPriority(segment.time, tick),
        segment }));
    /**
     * `true` if the current `RepresentationStream` has loaded all the
     * needed segments for this Representation until the end of the Period.
     */
    let hasFinishedLoading;
    const lastPosition = representation.index.getLastPosition();
    if (!representation.index.isInitialized() ||
        period.end === undefined ||
        neededSegments.length > 0) {
        hasFinishedLoading = false;
    }
    else {
        if (lastPosition === undefined) {
            // We do not know the end of this index.
            // If we reached the end of the period, check that all segments are
            // available.
            hasFinishedLoading = neededRange.end >= period.end &&
                representation.index.isFinished();
        }
        else if (lastPosition === null) {
            // There is no available segment in the index currently. If the index
            // tells us it has finished generating new segments, we're done.
            hasFinishedLoading = representation.index.isFinished();
        }
        else {
            // We have a declared end. Check that our range went until the last
            // position available in the index. If that's the case and we're left
            // with no segments after filtering them, it means we already have
            // downloaded the last segments and have nothing left to do: full.
            const endOfRange = period.end !== undefined ? Math.min(period.end, lastPosition) :
                lastPosition;
            hasFinishedLoading = neededRange.end >= endOfRange &&
                representation.index.isFinished();
        }
    }
    let imminentDiscontinuity;
    if (!representation.index.isInitialized() ||
        // TODO better handle contents not chronologically generated
        (!representation.index.areSegmentsChronologicallyGenerated() &&
            !hasFinishedLoading)) {
        // We might be missing information about future segments
        imminentDiscontinuity = null;
    }
    else {
        /**
         * Start time in seconds of the next available not-yet pushed segment.
         * `null` if no segment is wanted for the current wanted range.
         */
        let nextSegmentStart = null;
        if (segmentsBeingPushed.length > 0) {
            nextSegmentStart = Math.min(...segmentsBeingPushed.map(info => info.segment.time));
        }
        if (neededSegments.length > 0) {
            nextSegmentStart = nextSegmentStart !== null ?
                Math.min(nextSegmentStart, neededSegments[0].segment.time) :
                neededSegments[0].segment.time;
        }
        imminentDiscontinuity = checkForDiscontinuity(content, neededRange, nextSegmentStart, hasFinishedLoading, bufferedSegments);
    }
    return { imminentDiscontinuity,
        hasFinishedLoading,
        neededSegments,
        shouldRefreshManifest };
}
/**
 * From the given SegmentInventory, filters the "playable" (in a supported codec
 * and not known to be undecipherable) buffered Segment Objects which overlap
 * with the given range.
 * @param {Object} neededRange
 * @param {Array.<Object>} segmentInventory
 * @returns {Array.<Object>}
 */
function getPlayableBufferedSegments(neededRange, segmentInventory) {
    const segmentRoundingError = Math.max(1 / 60, get_buffer_status_MINIMUM_SEGMENT_SIZE);
    const minEnd = neededRange.start + segmentRoundingError;
    const maxStart = neededRange.end - segmentRoundingError;
    const overlappingChunks = [];
    for (let i = segmentInventory.length - 1; i >= 0; i--) {
        const eltInventory = segmentInventory[i];
        const { representation } = eltInventory.infos;
        if (!eltInventory.partiallyPushed &&
            representation.decipherable !== false &&
            representation.isSupported) {
            const inventorySegment = eltInventory.infos.segment;
            const eltInventoryStart = inventorySegment.time /
                inventorySegment.timescale;
            const eltInventoryEnd = inventorySegment.duration == null ?
                eltInventory.end :
                eltInventoryStart + inventorySegment.duration /
                    inventorySegment.timescale;
            if ((eltInventoryEnd > minEnd && eltInventoryStart < maxStart) ||
                (eltInventory.end > minEnd && eltInventory.start < maxStart)) {
                overlappingChunks.unshift(eltInventory);
            }
        }
    }
    return overlappingChunks;
}

;// CONCATENATED MODULE: ./src/core/stream/representation/force_garbage_collection.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





const GC_GAP_CALM = config/* default.BUFFER_GC_GAPS.CALM */.Z.BUFFER_GC_GAPS.CALM;
const GC_GAP_BEEFY = config/* default.BUFFER_GC_GAPS.BEEFY */.Z.BUFFER_GC_GAPS.BEEFY;
/**
 * Run the garbage collector.
 *
 * Try to clean up buffered ranges from a low gcGap at first.
 * If it does not succeed to clean up space, use a higher gcCap.
 *
 * @param {Observable} timings$
 * @param {Object} bufferingQueue
 * @returns {Observable}
 */
function forceGarbageCollection(timings$, bufferingQueue) {
    // wait for next timing event
    return timings$.pipe((0,take/* take */.q)(1), (0,mergeMap/* mergeMap */.zg)((timing) => {
        log/* default.warn */.Z.warn("Stream: Running garbage collector");
        const buffered = bufferingQueue.getBufferedRanges();
        let cleanedupRanges = selectGCedRanges(timing.position, buffered, GC_GAP_CALM);
        // more aggressive GC if we could not find any range to clean
        if (cleanedupRanges.length === 0) {
            cleanedupRanges = selectGCedRanges(timing.position, buffered, GC_GAP_BEEFY);
        }
        log/* default.debug */.Z.debug("Stream: GC cleaning", cleanedupRanges);
        return (0,from/* from */.D)(cleanedupRanges.map(({ start, end }) => bufferingQueue.removeBuffer(start, end))).pipe((0,concatAll/* concatAll */.u)());
    }));
}
/**
 * Buffer garbage collector algorithm.
 *
 * Tries to free up some part of the ranges that are distant from the current
 * playing time.
 * See: https://w3c.github.io/media-source/#sourcebuffer-prepare-append
 *
 * @param {Number} position
 * @param {TimeRanges} buffered - current buffered ranges
 * @param {Number} gcGap - delta gap from current timestamp from which we
 * should consider cleaning up.
 * @returns {Array.<Object>} - Ranges selected for clean up
 */
function selectGCedRanges(position, buffered, gcGap) {
    const { innerRange, outerRanges } = (0,ranges/* getInnerAndOuterTimeRanges */.F_)(buffered, position);
    const cleanedupRanges = [];
    // start by trying to remove all ranges that do not contain the
    // current time and respect the gcGap
    // respect the gcGap? FIXME?
    for (let i = 0; i < outerRanges.length; i++) {
        const outerRange = outerRanges[i];
        if (position - gcGap < outerRange.end) {
            cleanedupRanges.push(outerRange);
        }
        else if (position + gcGap > outerRange.start) {
            cleanedupRanges.push(outerRange);
        }
    }
    // try to clean up some space in the current range
    if (innerRange != null) {
        log/* default.debug */.Z.debug("Stream: GC removing part of inner range", cleanedupRanges);
        if (position - gcGap > innerRange.start) {
            cleanedupRanges.push({ start: innerRange.start,
                end: position - gcGap });
        }
        if (position + gcGap < innerRange.end) {
            cleanedupRanges.push({ start: position + gcGap,
                end: innerRange.end });
        }
    }
    return cleanedupRanges;
}

;// CONCATENATED MODULE: ./src/core/stream/representation/append_segment_to_buffer.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file allows any Stream to push data to a SegmentBuffer.
 */




/**
 * Append a segment to the given segmentBuffer.
 * If it leads to a QuotaExceededError, try to run our custom range
 * _garbage collector_ then retry.
 *
 * @param {Observable} clock$
 * @param {Object} segmentBuffer
 * @param {Object} dataInfos
 * @returns {Observable}
 */
function appendSegmentToBuffer(clock$, segmentBuffer, dataInfos) {
    const append$ = segmentBuffer.pushChunk(dataInfos);
    return append$.pipe((0,catchError/* catchError */.K)((appendError) => {
        if (!(appendError instanceof Error) || appendError.name !== "QuotaExceededError") {
            const reason = appendError instanceof Error ?
                appendError.toString() :
                "An unknown error happened when pushing content";
            throw new media_error/* default */.Z("BUFFER_APPEND_ERROR", reason);
        }
        return (0,concat/* concat */.z)(forceGarbageCollection(clock$, segmentBuffer).pipe((0,ignoreElements/* ignoreElements */.l)()), append$).pipe((0,catchError/* catchError */.K)((forcedGCError) => {
            const reason = forcedGCError instanceof Error ? forcedGCError.toString() :
                "Could not clean the buffer";
            throw new media_error/* default */.Z("BUFFER_FULL_ERROR", reason);
        }));
    }));
}

;// CONCATENATED MODULE: ./src/core/stream/representation/push_init_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Push the initialization segment to the SegmentBuffer.
 * The Observable returned:
 *   - emit an event once the segment has been pushed.
 *   - throws on Error.
 * @param {Object} args
 * @returns {Observable}
 */
function pushInitSegment({ clock$, content, segment, segmentData, segmentBuffer }) {
    return (0,defer/* defer */.P)(() => {
        if (segmentData === null) {
            return empty/* EMPTY */.E;
        }
        const codec = content.representation.getMimeTypeString();
        const data = { initSegment: segmentData,
            chunk: null,
            timestampOffset: 0,
            appendWindow: [undefined, undefined],
            codec };
        return appendSegmentToBuffer(clock$, segmentBuffer, { data,
            inventoryInfos: null })
            .pipe((0,map/* map */.U)(() => {
            const buffered = segmentBuffer.getBufferedRanges();
            return stream_events_generators.addedSegment(content, segment, buffered, segmentData);
        }));
    });
}

;// CONCATENATED MODULE: ./src/core/stream/representation/push_media_segment.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






const { APPEND_WINDOW_SECURITIES } = config/* default */.Z;
/**
 * Push a given media segment (non-init segment) to a SegmentBuffer.
 * The Observable returned:
 *   - emit an event once the segment has been pushed.
 *   - throws on Error.
 * @param {Object} args
 * @returns {Observable}
 */
function pushMediaSegment({ clock$, content, initSegmentData, parsedSegment, segment, segmentBuffer }) {
    return (0,defer/* defer */.P)(() => {
        var _a, _b;
        if (parsedSegment.chunkData === null) {
            return empty/* EMPTY */.E;
        }
        const { chunkData, chunkInfos, chunkOffset, appendWindow } = parsedSegment;
        const codec = content.representation.getMimeTypeString();
        // Cutting exactly at the start or end of the appendWindow can lead to
        // cases of infinite rebuffering due to how browser handle such windows.
        // To work-around that, we add a small offset before and after those.
        const safeAppendWindow = [
            appendWindow[0] !== undefined ?
                Math.max(0, appendWindow[0] - APPEND_WINDOW_SECURITIES.START) :
                undefined,
            appendWindow[1] !== undefined ?
                appendWindow[1] + APPEND_WINDOW_SECURITIES.END :
                undefined,
        ];
        const data = { initSegment: initSegmentData,
            chunk: chunkData,
            timestampOffset: chunkOffset,
            appendWindow: safeAppendWindow,
            codec };
        let estimatedStart = (_a = chunkInfos === null || chunkInfos === void 0 ? void 0 : chunkInfos.time) !== null && _a !== void 0 ? _a : segment.time;
        const estimatedDuration = (_b = chunkInfos === null || chunkInfos === void 0 ? void 0 : chunkInfos.duration) !== null && _b !== void 0 ? _b : segment.duration;
        let estimatedEnd = estimatedStart + estimatedDuration;
        if (safeAppendWindow[0] !== undefined) {
            estimatedStart = Math.max(estimatedStart, safeAppendWindow[0]);
        }
        if (safeAppendWindow[1] !== undefined) {
            estimatedEnd = Math.min(estimatedEnd, safeAppendWindow[1]);
        }
        const inventoryInfos = (0,object_assign/* default */.Z)({ segment,
            start: estimatedStart,
            end: estimatedEnd }, content);
        return appendSegmentToBuffer(clock$, segmentBuffer, { data, inventoryInfos })
            .pipe((0,map/* map */.U)(() => {
            const buffered = segmentBuffer.getBufferedRanges();
            return stream_events_generators.addedSegment(content, segment, buffered, chunkData);
        }));
    });
}

;// CONCATENATED MODULE: ./src/core/stream/representation/representation_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file allows to create RepresentationStreams.
 *
 * A RepresentationStream downloads and push segment for a single
 * Representation (e.g. a single video stream of a given quality).
 * It chooses which segments should be downloaded according to the current
 * position and what is currently buffered.
 */











/**
 * Build up buffer for a single Representation.
 *
 * Download and push segments linked to the given Representation according
 * to what is already in the SegmentBuffer and where the playback currently is.
 *
 * Multiple RepresentationStream observables can run on the same SegmentBuffer.
 * This allows for example smooth transitions between multiple periods.
 *
 * @param {Object} args
 * @returns {Observable}
 */
function RepresentationStream({ clock$, content, segmentBuffer, segmentFetcher, terminate$, options, }) {
    const { manifest, period, adaptation, representation } = content;
    const { bufferGoal$, drmSystemId, fastSwitchThreshold$ } = options;
    const bufferType = adaptation.type;
    const initSegment = representation.index.getInitSegment();
    /**
     * Saved initialization segment state for this representation.
     * `null` if the initialization segment hasn't been loaded yet.
     */
    let initSegmentObject = initSegment === null ? { initializationData: null,
        protectionDataUpdate: false,
        initTimescale: undefined } :
        null;
    /** Segments queued for download in this RepresentationStream. */
    let downloadQueue = [];
    /** Emit to start/restart a downloading Queue. */
    const startDownloadingQueue$ = new ReplaySubject/* ReplaySubject */.t(1);
    /** Emit when the RepresentationStream asks to re-check which segments are needed. */
    const reCheckNeededSegments$ = new Subject/* Subject */.xQ();
    /**
     * Keep track of the information about the pending segment request.
     * `null` if no segment request is pending in that RepresentationStream.
     */
    let currentSegmentRequest = null;
    const status$ = (0,combineLatest/* combineLatest */.aj)([
        clock$,
        bufferGoal$,
        terminate$.pipe((0,take/* take */.q)(1), (0,startWith/* startWith */.O)(null)),
        reCheckNeededSegments$.pipe((0,startWith/* startWith */.O)(undefined))
    ]).pipe(withLatestFrom(fastSwitchThreshold$), (0,mergeMap/* mergeMap */.zg)(function ([[tick, bufferGoal, terminate], fastSwitchThreshold]) {
        const status = getBufferStatus(content, tick, fastSwitchThreshold, bufferGoal, segmentBuffer);
        const { neededSegments } = status;
        // Add initialization segment if required
        if (!representation.index.isInitialized()) {
            if (initSegment === null) {
                log/* default.warn */.Z.warn("Stream: Uninitialized index without an initialization segment");
            }
            else if (initSegmentObject !== null) {
                log/* default.warn */.Z.warn("Stream: Uninitialized index with an already loaded " +
                    "initialization segment");
            }
            else {
                neededSegments.unshift({ segment: initSegment,
                    priority: getSegmentPriority(period.start, tick) });
            }
        }
        else if (neededSegments.length > 0 &&
            initSegment !== null &&
            initSegmentObject === null) {
            // prepend initialization segment
            const initSegmentPriority = neededSegments[0].priority;
            neededSegments.unshift({ segment: initSegment,
                priority: initSegmentPriority });
        }
        const mostNeededSegment = neededSegments[0];
        if (terminate !== null) {
            downloadQueue = [];
            if (terminate.urgent) {
                log/* default.debug */.Z.debug("Stream: urgent termination request, terminate.", bufferType);
                startDownloadingQueue$.next(); // interrupt current requests
                startDownloadingQueue$.complete(); // complete the downloading queue
                return (0,of.of)(stream_events_generators.streamTerminating());
            }
            else if (currentSegmentRequest === null ||
                mostNeededSegment === undefined ||
                currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) {
                log/* default.debug */.Z.debug("Stream: cancel request and terminate.", currentSegmentRequest === null, bufferType);
                startDownloadingQueue$.next(); // interrupt the current request
                startDownloadingQueue$.complete(); // complete the downloading queue
                return (0,of.of)(stream_events_generators.streamTerminating());
            }
            else if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
                const { request$ } = currentSegmentRequest;
                currentSegmentRequest.priority = mostNeededSegment.priority;
                segmentFetcher.updatePriority(request$, mostNeededSegment.priority);
            }
            log/* default.debug */.Z.debug("Stream: terminate after request.", bufferType);
        }
        else if (mostNeededSegment === undefined) {
            if (currentSegmentRequest !== null) {
                log/* default.debug */.Z.debug("Stream: interrupt segment request.", bufferType);
            }
            downloadQueue = [];
            startDownloadingQueue$.next(); // (re-)start with an empty queue
        }
        else if (currentSegmentRequest === null) {
            log/* default.debug */.Z.debug("Stream: start downloading queue.", bufferType);
            downloadQueue = neededSegments;
            startDownloadingQueue$.next(); // restart the queue
        }
        else if (currentSegmentRequest.segment.id !== mostNeededSegment.segment.id) {
            log/* default.debug */.Z.debug("Stream: restart download queue.", bufferType);
            downloadQueue = neededSegments;
            startDownloadingQueue$.next(); // restart the queue
        }
        else if (currentSegmentRequest.priority !== mostNeededSegment.priority) {
            log/* default.debug */.Z.debug("Stream: update request priority.", bufferType);
            const { request$ } = currentSegmentRequest;
            currentSegmentRequest.priority = mostNeededSegment.priority;
            segmentFetcher.updatePriority(request$, mostNeededSegment.priority);
        }
        else {
            log/* default.debug */.Z.debug("Stream: update downloading queue", bufferType);
            // Update the previous queue to be all needed segments but the first one,
            // for which a request is already pending
            downloadQueue = neededSegments.slice().splice(1, neededSegments.length);
        }
        const bufferStatusEvt = (0,of.of)({ type: "stream-status", value: { period,
                position: tick.position,
                bufferType,
                imminentDiscontinuity: status.imminentDiscontinuity,
                hasFinishedLoading: status.hasFinishedLoading,
                neededSegments: status.neededSegments } });
        return status.shouldRefreshManifest ?
            (0,concat/* concat */.z)((0,of.of)(stream_events_generators.needsManifestRefresh()), bufferStatusEvt) :
            bufferStatusEvt;
    }), takeWhile((e) => e.type !== "stream-terminating", true));
    /**
     * `true` if the event notifying about encryption data has already been
     * constructed.
     * Allows to avoid sending multiple times protection events.
     */
    let hasSentEncryptionData = false;
    let encryptionEvent$ = empty/* EMPTY */.E;
    if (drmSystemId !== undefined) {
        const encryptionData = representation.getEncryptionData(drmSystemId);
        if (encryptionData.length > 0) {
            encryptionEvent$ = (0,of.of)(...encryptionData.map(d => stream_events_generators.encryptionDataEncountered(d)));
            hasSentEncryptionData = true;
        }
    }
    /**
     * Stream Queue:
     *   - download every segments queued sequentially
     *   - when a segment is loaded, append it to the SegmentBuffer
     */
    const streamQueue$ = startDownloadingQueue$.pipe((0,switchMap/* switchMap */.w)(() => downloadQueue.length > 0 ? loadSegmentsFromQueue() : empty/* EMPTY */.E), (0,mergeMap/* mergeMap */.zg)(onLoaderEvent));
    return (0,concat/* concat */.z)(encryptionEvent$, (0,merge/* merge */.T)(status$, streamQueue$).pipe((0,share/* share */.B)()));
    /**
     * Request every Segment in the ``downloadQueue`` on subscription.
     * Emit the data of a segment when a request succeeded.
     *
     * Important side-effects:
     *   - Mutates `currentSegmentRequest` when doing and finishing a request.
     *   - Will emit from reCheckNeededSegments$ Subject when it's done.
     *
     * Might emit warnings when a request is retried.
     *
     * Throws when the request will not be retried (configuration or un-retryable
     * error).
     * @returns {Observable}
     */
    function loadSegmentsFromQueue() {
        const requestNextSegment$ = (0,defer/* defer */.P)(() => {
            const currentNeededSegment = downloadQueue.shift();
            if (currentNeededSegment === undefined) {
                next_tick_default()(() => { reCheckNeededSegments$.next(); });
                return empty/* EMPTY */.E;
            }
            const { segment, priority } = currentNeededSegment;
            const context = { manifest, period, adaptation, representation, segment };
            const request$ = segmentFetcher.createRequest(context, priority);
            currentSegmentRequest = { segment, priority, request$ };
            return request$
                .pipe((0,mergeMap/* mergeMap */.zg)((evt) => {
                switch (evt.type) {
                    case "warning":
                        return (0,of.of)({ type: "retry", value: { segment, error: evt.value } });
                    case "chunk-complete":
                        currentSegmentRequest = null;
                        return (0,of.of)({ type: "end-of-segment", value: { segment } });
                    case "interrupted":
                        log/* default.info */.Z.info("Stream: segment request interrupted temporarly.", segment);
                        return empty/* EMPTY */.E;
                    case "chunk":
                        const initTimescale = initSegmentObject === null || initSegmentObject === void 0 ? void 0 : initSegmentObject.initTimescale;
                        return evt.parse(initTimescale).pipe((0,map/* map */.U)(parserResponse => {
                            return (0,object_assign/* default */.Z)({ segment }, parserResponse);
                        }));
                    case "ended":
                        return requestNextSegment$;
                    default:
                        (0,assert_unreachable/* default */.Z)(evt);
                }
            }));
        });
        return requestNextSegment$
            .pipe(finalize(() => { currentSegmentRequest = null; }));
    }
    /**
     * React to event from `loadSegmentsFromQueue`.
     * @param {Object} evt
     * @returns {Observable}
     */
    function onLoaderEvent(evt) {
        var _a;
        switch (evt.type) {
            case "retry":
                return (0,concat/* concat */.z)((0,of.of)({ type: "warning", value: evt.value.error }), (0,defer/* defer */.P)(() => {
                    const retriedSegment = evt.value.segment;
                    const { index } = representation;
                    if (index.isSegmentStillAvailable(retriedSegment) === false) {
                        reCheckNeededSegments$.next();
                    }
                    else if (index.canBeOutOfSyncError(evt.value.error, retriedSegment)) {
                        return (0,of.of)(stream_events_generators.manifestMightBeOufOfSync());
                    }
                    return empty/* EMPTY */.E; // else, ignore.
                }));
            case "parsed-init-segment":
                initSegmentObject = evt.value;
                // Now that the initialization segment has been parsed - which may have
                // included encryption information - take care of the encryption event
                // if not already done.
                const allEncryptionData = representation.getAllEncryptionData();
                const initEncEvt$ = !hasSentEncryptionData &&
                    allEncryptionData.length > 0 ?
                    (0,of.of)(...allEncryptionData.map(p => stream_events_generators.encryptionDataEncountered(p))) :
                    empty/* EMPTY */.E;
                const pushEvent$ = pushInitSegment({ clock$,
                    content,
                    segment: evt.segment,
                    segmentData: evt.value.initializationData,
                    segmentBuffer });
                return (0,merge/* merge */.T)(initEncEvt$, pushEvent$);
            case "parsed-segment":
                const initSegmentData = (_a = initSegmentObject === null || initSegmentObject === void 0 ? void 0 : initSegmentObject.initializationData) !== null && _a !== void 0 ? _a : null;
                const { inbandEvents, needsManifestRefresh } = evt.value;
                const manifestRefresh$ = needsManifestRefresh === true ?
                    (0,of.of)(stream_events_generators.needsManifestRefresh()) :
                    empty/* EMPTY */.E;
                const inbandEvents$ = inbandEvents !== undefined &&
                    inbandEvents.length > 0 ?
                    (0,of.of)({ type: "inband-events", value: inbandEvents }) :
                    empty/* EMPTY */.E;
                return (0,concat/* concat */.z)(manifestRefresh$, inbandEvents$, pushMediaSegment({ clock$,
                    content,
                    initSegmentData,
                    parsedSegment: evt.value,
                    segment: evt.segment,
                    segmentBuffer }));
            case "end-of-segment": {
                const { segment } = evt.value;
                return segmentBuffer.endOfSegment((0,object_assign/* default */.Z)({ segment }, content))
                    .pipe((0,ignoreElements/* ignoreElements */.l)());
            }
            default:
                (0,assert_unreachable/* default */.Z)(evt);
        }
    }
}

;// CONCATENATED MODULE: ./src/core/stream/representation/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const stream_representation = (RepresentationStream);

;// CONCATENATED MODULE: ./src/core/stream/utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Switching to another `Adaptation` and or `Representation` can necessitate a
 * complete reload of the MediaSource.
 *
 * This is done through the `INeedsMediaSourceReload` event which among other
 * things indicate the position the player should seek to after "reloading".
 * That position depends on the playback conditions at the time of the switch.
 *
 * When you already know you have to reload, you can call this function to take
 * care of that complex behavior:
 *
 *   - If `period` is not being played when that function is called, this
 *     function will emit regularly the `INeedsMediaSourceReload` event after
 *     applying the given `deltaPos` value to the reloading position.
 *
 *   - If `period` is not being when that function is called, it emits regularly
 *     the `INeedsMediaSourceReload` without applying the given `deltaPos` value
 *     to the reloading position.
 *     This is because that value is only applied when the previous Adaptation
 *     or Representation for the current Period was being played and should not
 *     be for cases like entering the current Period, or seeking _into_ th
 *     current Period.
 *     The main point of that configuration variable being to give back some
 *     context, there is no context to give back on those cases (as the Period
 *     was not already playing).
 *
 * @param {Object} period - The Period linked to the Adaptation or
 * Representation that you want to switch to.
 * @param {Observable} clock$ - Observable emitting playback conditions.
 * Has to emit last playback conditions immediately on subscribe.
 * @param {number} deltaPos - If the concerned Period is playing at the time
 * this function is called, we will add this value, in seconds, to the current
 * position to indicate the position we should reload at.
 * This value allows to give back context (by replaying some media data) after
 * a switch.
 * @returns {Observable}
 */
function reloadAfterSwitch(period, clock$, deltaPos) {
    return clock$.pipe((0,take/* take */.q)(1), // only the first (current) event interests us here
    (0,mergeMap/* mergeMap */.zg)((initialTick) => {
        var _a;
        if (period.start <= initialTick.position &&
            (period.end === undefined || period.end > initialTick.position)) {
            // if the Period was playing at the time of the switch
            const pos = initialTick.getCurrentTime() + deltaPos;
            const reloadAt = Math.min(Math.max(period.start, pos), (_a = period.end) !== null && _a !== void 0 ? _a : Infinity);
            return (0,of.of)(stream_events_generators.needsMediaSourceReload(period, reloadAt, !initialTick.isPaused));
        }
        // If the Period was not playing, just ask to reload to the exact same position
        return clock$.pipe((0,map/* map */.U)(tick => stream_events_generators.needsMediaSourceReload(period, tick.getCurrentTime(), !tick.isPaused)));
    }));
}

;// CONCATENATED MODULE: ./src/core/stream/adaptation/create_representation_estimator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * Create an "estimator$" Observable which will emit which Representation (from
 * the given `Adaptation`) is the best fit (see `IABREstimate` type definition)
 * corresponding to the current network and playback conditions.
 *
 * This function also returns two subjects that should be used to add feedback
 * helping the estimator to make its choices:
 *
 *   - `requestFeedback$`: Subject through which information about new requests
 *     and network metrics should be emitted.
 *
 *   - `streamFeedback$`: Subject through which stream-related events should be
 *      emitted.
 *
 * You can look at the types defined for both of those Subjects to have more
 * information on what data is expected. The idea is to provide as much data as
 * possible so the estimation is as adapted as possible.
 *
 * @param {Object} content
 * @param {Object} abrManager
 * @param {Observable} clock$
 * @returns {Object}
 */
function createRepresentationEstimator({ manifest, adaptation }, abrManager, clock$) {
    const streamFeedback$ = new Subject/* Subject */.xQ();
    const requestFeedback$ = new Subject/* Subject */.xQ();
    const abrEvents$ = (0,merge/* merge */.T)(streamFeedback$, requestFeedback$);
    const estimator$ = (0,concat/* concat */.z)((0,of.of)(null), // Emit directly a first time on subscription
    (0,event_emitter/* fromEvent */.R)(manifest, "decipherabilityUpdate") // then each time this event is triggered
    ).pipe((0,map/* map */.U)(() => {
        /** Representations for which a `RepresentationStream` can be created. */
        const playableRepresentations = adaptation.getPlayableRepresentations();
        if (playableRepresentations.length <= 0) {
            const noRepErr = new media_error/* default */.Z("NO_PLAYABLE_REPRESENTATION", "No Representation in the chosen " +
                "Adaptation can be played");
            throw noRepErr;
        }
        return playableRepresentations;
    }), (0,distinctUntilChanged/* distinctUntilChanged */.x)((prevRepr, newRepr) => {
        if (prevRepr.length !== newRepr.length) {
            return false;
        }
        for (let i = 0; i < newRepr.length; i++) {
            if (prevRepr[i].id !== newRepr[i].id) {
                return false;
            }
        }
        return true;
    }), (0,switchMap/* switchMap */.w)((playableRepresentations) => abrManager.get$(adaptation.type, playableRepresentations, clock$, abrEvents$)));
    return { estimator$,
        streamFeedback$,
        requestFeedback$ };
}

;// CONCATENATED MODULE: ./src/core/stream/adaptation/adaptation_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file allows to create `AdaptationStream`s.
 *
 * An `AdaptationStream` downloads and push segment for a single Adaptation
 * (e.g.  a single audio, video or text track).
 * It chooses which Representation to download mainly thanks to the
 * ABRManager, and orchestrates a RepresentationStream, which will download and
 * push segments corresponding to a chosen Representation.
 */










const { DELTA_POSITION_AFTER_RELOAD } = config/* default */.Z;
/**
 * Create new AdaptationStream Observable, which task will be to download the
 * media data for a given Adaptation (i.e. "track").
 *
 * It will rely on the ABRManager to choose at any time the best Representation
 * for this Adaptation and then run the logic to download and push the
 * corresponding segments in the SegmentBuffer.
 *
 * After being subscribed to, it will start running and will emit various events
 * to report its current status.
 *
 * @param {Object} args
 * @returns {Observable}
 */
function AdaptationStream({ abrManager, clock$, content, options, segmentBuffer, segmentFetcherCreator, wantedBufferAhead$, }) {
    const directManualBitrateSwitching = options.manualBitrateSwitchingMode === "direct";
    const { manifest, period, adaptation } = content;
    /**
     * The buffer goal ratio base itself on the value given by `wantedBufferAhead`
     * to determine a more dynamic buffer goal for a given Representation.
     *
     * It can help in cases such as : the current browser has issues with
     * buffering and tells us that we should try to bufferize less data :
     * https://developers.google.com/web/updates/2017/10/quotaexceedederror
     */
    const bufferGoalRatioMap = {};
    const { estimator$, requestFeedback$, streamFeedback$ } = createRepresentationEstimator(content, abrManager, clock$);
    /** Allows the `RepresentationStream` to easily fetch media segments. */
    const segmentFetcher = segmentFetcherCreator.createSegmentFetcher(adaptation.type, requestFeedback$);
    /**
     * Emits each time an estimate is made through the `abrEstimate$` Observable,
     * starting with the last one.
     * This allows to easily rely on that value in inner Observables which might also
     * need the last already-considered value.
     */
    const lastEstimate$ = new BehaviorSubject(null);
    /** Emits abr estimates on Subscription. */
    const abrEstimate$ = estimator$.pipe((0,tap/* tap */.b)((estimate) => { lastEstimate$.next(estimate); }), (0,defer_subscriptions/* default */.Z)(), (0,share/* share */.B)());
    /** Emit at each bitrate estimate done by the ABRManager. */
    const bitrateEstimate$ = abrEstimate$.pipe((0,filter/* filter */.h)(({ bitrate }) => bitrate != null), (0,distinctUntilChanged/* distinctUntilChanged */.x)((old, current) => old.bitrate === current.bitrate), (0,map/* map */.U)(({ bitrate }) => {
        log/* default.debug */.Z.debug(`Stream: new ${adaptation.type} bitrate estimate`, bitrate);
        return stream_events_generators.bitrateEstimationChange(adaptation.type, bitrate);
    }));
    /** Recursively create `RepresentationStream`s according to the last estimate. */
    const representationStreams$ = abrEstimate$
        .pipe(exhaustMap((estimate, i) => {
        return recursivelyCreateRepresentationStreams(estimate, i === 0);
    }));
    return (0,merge/* merge */.T)(representationStreams$, bitrateEstimate$);
    /**
     * Create `RepresentationStream`s starting with the Representation indicated in
     * `fromEstimate` argument.
     * Each time a new estimate is made, this function will create a new
     * `RepresentationStream` corresponding to that new estimate.
     * @param {Object} fromEstimate - The first estimate we should start with
     * @param {boolean} isFirstEstimate - Whether this is the first time we're
     * creating a RepresentationStream in the corresponding `AdaptationStream`.
     * This is important because manual quality switches might need a full reload
     * of the MediaSource _except_ if we are talking about the first quality chosen.
     * @returns {Observable}
     */
    function recursivelyCreateRepresentationStreams(fromEstimate, isFirstEstimate) {
        const { representation } = fromEstimate;
        // A manual bitrate switch might need an immediate feedback.
        // To do that properly, we need to reload the MediaSource
        if (directManualBitrateSwitching &&
            fromEstimate.manual &&
            !isFirstEstimate) {
            return reloadAfterSwitch(period, clock$, DELTA_POSITION_AFTER_RELOAD.bitrateSwitch);
        }
        /**
         * Emit when the current RepresentationStream should be terminated to make
         * place for a new one (e.g. when switching quality).
         */
        const terminateCurrentStream$ = lastEstimate$.pipe((0,filter/* filter */.h)((newEstimate) => newEstimate === null ||
            newEstimate.representation.id !== representation.id ||
            (newEstimate.manual && !fromEstimate.manual)), (0,take/* take */.q)(1), (0,map/* map */.U)((newEstimate) => {
            if (newEstimate === null) {
                log/* default.info */.Z.info("Stream: urgent Representation termination", adaptation.type);
                return ({ urgent: true });
            }
            if (newEstimate.urgent) {
                log/* default.info */.Z.info("Stream: urgent Representation switch", adaptation.type);
                return ({ urgent: true });
            }
            else {
                log/* default.info */.Z.info("Stream: slow Representation switch", adaptation.type);
                return ({ urgent: false });
            }
        }));
        /**
         * "Fast-switching" is a behavior allowing to replace low-quality segments
         * (i.e. with a low bitrate) with higher-quality segments (higher bitrate) in
         * the buffer.
         * This threshold defines a bitrate from which "fast-switching" is disabled.
         * For example with a fastSwitchThreshold set to `100`, segments with a
         * bitrate of `90` can be replaced. But segments with a bitrate of `100`
         * onward won't be replaced by higher quality segments.
         * Set to `undefined` to indicate that there's no threshold (anything can be
         * replaced by higher-quality segments).
         */
        const fastSwitchThreshold$ = !options.enableFastSwitching ?
            (0,of.of)(0) : // Do not fast-switch anything
            lastEstimate$.pipe((0,map/* map */.U)((estimate) => estimate === null ? undefined :
                estimate.knownStableBitrate), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
        const representationChange$ = (0,of.of)(stream_events_generators.representationChange(adaptation.type, period, representation));
        return (0,concat/* concat */.z)(representationChange$, createRepresentationStream(representation, terminateCurrentStream$, fastSwitchThreshold$)).pipe((0,tap/* tap */.b)((evt) => {
            if (evt.type === "representationChange" ||
                evt.type === "added-segment") {
                return streamFeedback$.next(evt);
            }
        }), (0,mergeMap/* mergeMap */.zg)((evt) => {
            if (evt.type === "stream-terminating") {
                const lastEstimate = lastEstimate$.getValue();
                if (lastEstimate === null) {
                    return empty/* EMPTY */.E;
                }
                return recursivelyCreateRepresentationStreams(lastEstimate, false);
            }
            return (0,of.of)(evt);
        }));
    }
    /**
     * Create and returns a new RepresentationStream Observable, linked to the
     * given Representation.
     * @param {Representation} representation
     * @returns {Observable}
     */
    function createRepresentationStream(representation, terminateCurrentStream$, fastSwitchThreshold$) {
        return (0,defer/* defer */.P)(() => {
            const oldBufferGoalRatio = bufferGoalRatioMap[representation.id];
            const bufferGoalRatio = oldBufferGoalRatio != null ? oldBufferGoalRatio :
                1;
            bufferGoalRatioMap[representation.id] = bufferGoalRatio;
            const bufferGoal$ = wantedBufferAhead$.pipe((0,map/* map */.U)((wba) => wba * bufferGoalRatio));
            log/* default.info */.Z.info("Stream: changing representation", adaptation.type, representation);
            return stream_representation({ clock$,
                content: { representation,
                    adaptation,
                    period,
                    manifest },
                segmentBuffer,
                segmentFetcher,
                terminate$: terminateCurrentStream$,
                options: { bufferGoal$,
                    drmSystemId: options.drmSystemId,
                    fastSwitchThreshold$ } })
                .pipe((0,catchError/* catchError */.K)((err) => {
                const formattedError = formatError(err, {
                    defaultCode: "NONE",
                    defaultReason: "Unknown `RepresentationStream` error",
                });
                if (formattedError.code === "BUFFER_FULL_ERROR") {
                    const wantedBufferAhead = wantedBufferAhead$.getValue();
                    const lastBufferGoalRatio = bufferGoalRatio;
                    if (lastBufferGoalRatio <= 0.25 ||
                        wantedBufferAhead * lastBufferGoalRatio <= 2) {
                        throw formattedError;
                    }
                    bufferGoalRatioMap[representation.id] = lastBufferGoalRatio - 0.25;
                    return createRepresentationStream(representation, terminateCurrentStream$, fastSwitchThreshold$);
                }
                throw formattedError;
            }));
        });
    }
}

;// CONCATENATED MODULE: ./src/core/stream/adaptation/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const stream_adaptation = (AdaptationStream);

;// CONCATENATED MODULE: ./src/core/stream/period/create_empty_adaptation_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Create empty AdaptationStream Observable, linked to a Period.
 *
 * This observable will never download any segment and just emit a "full"
 * event when reaching the end.
 * @param {Observable} streamClock$
 * @param {Observable} wantedBufferAhead$
 * @param {string} bufferType
 * @param {Object} content
 * @returns {Observable}
 */
function createEmptyAdaptationStream(streamClock$, wantedBufferAhead$, bufferType, content) {
    const { period } = content;
    let hasFinishedLoading = false;
    return (0,combineLatest/* combineLatest */.aj)([streamClock$, wantedBufferAhead$]).pipe((0,mergeMap/* mergeMap */.zg)(([clockTick, wantedBufferAhead]) => {
        const { position } = clockTick;
        if (period.end !== undefined && position + wantedBufferAhead >= period.end) {
            log/* default.debug */.Z.debug("Stream: full \"empty\" AdaptationStream", bufferType);
            hasFinishedLoading = true;
        }
        return (0,of.of)({ type: "stream-status", value: { period,
                bufferType,
                position: clockTick.position,
                imminentDiscontinuity: null,
                hasFinishedLoading,
                neededSegments: [],
                shouldRefreshManifest: false } });
    }));
}

// EXTERNAL MODULE: ./src/utils/starts_with.ts
var starts_with = __webpack_require__(27140);
;// CONCATENATED MODULE: ./src/utils/are_codecs_compatible.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * This function is a shortcut that helps differentiate two codecs
 * of the form "audio/mp4;codecs=\"av1.40.2\"".
 *
 * @param codecA
 * @param codecB
 * @returns A boolean that tell whether or not those two codecs provided are even.
 */
function areCodecsCompatible(a, b) {
    const [mimeTypeA, ...propsA] = a.split(";");
    const [mimeTypeB, ...propsB] = b.split(";");
    if (mimeTypeA !== mimeTypeB) {
        return false;
    }
    const codecsA = (0,array_find/* default */.Z)(propsA, (prop) => (0,starts_with/* default */.Z)(prop, "codecs="));
    const codecsB = (0,array_find/* default */.Z)(propsB, (prop) => (0,starts_with/* default */.Z)(prop, "codecs="));
    if (codecsA === undefined || codecsB === undefined) {
        return false;
    }
    const codecA = codecsA.substring(7);
    const codecB = codecsB.substring(7);
    if (codecA.split(".")[0] !== codecB.split(".")[0]) {
        return false;
    }
    return true;
}
/* harmony default export */ const are_codecs_compatible = (areCodecsCompatible);

;// CONCATENATED MODULE: ./src/core/stream/period/get_adaptation_switch_strategy.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



const { ADAPTATION_SWITCH_BUFFER_PADDINGS } = config/* default */.Z;
/**
 * Find out what to do when switching Adaptation, based on the current
 * situation.
 * @param {Object} segmentBuffer
 * @param {Object} period
 * @param {Object} adaptation
 * @param {Object} playbackInfo
 * @returns {Object}
 */
function getAdaptationSwitchStrategy(segmentBuffer, period, adaptation, playbackInfo, options) {
    if (segmentBuffer.codec !== undefined &&
        options.onCodecSwitch === "reload" &&
        !hasCompatibleCodec(adaptation, segmentBuffer.codec)) {
        return { type: "needs-reload", value: undefined };
    }
    const buffered = segmentBuffer.getBufferedRanges();
    if (buffered.length === 0) {
        return { type: "continue", value: undefined };
    }
    const bufferedRanges = (0,ranges/* convertToRanges */.JN)(buffered);
    const start = period.start;
    const end = period.end == null ? Infinity :
        period.end;
    const intersection = (0,ranges/* keepRangeIntersection */.tn)(bufferedRanges, [{ start, end }]);
    if (intersection.length === 0) {
        return { type: "continue", value: undefined };
    }
    segmentBuffer.synchronizeInventory();
    const inventory = segmentBuffer.getInventory();
    // Continue if we have no other Adaptation buffered in the current Period
    if (!inventory.some(buf => buf.infos.period.id === period.id &&
        buf.infos.adaptation.id !== adaptation.id)) {
        return { type: "continue", value: undefined };
    }
    /** Data already in the right Adaptation */
    const adaptationInBuffer = getBufferedRangesFromAdaptation(inventory, period, adaptation);
    /**
     * Data different from the wanted Adaptation in the Period's range.
     * /!\ Could contain some data at the end of the previous Period or at the
     * beginning of the next one.
     */
    const unwantedRange = (0,ranges/* excludeFromRanges */.uH)(intersection, adaptationInBuffer);
    if (unwantedRange.length === 0) {
        return { type: "continue", value: undefined };
    }
    const { currentTime } = playbackInfo;
    if (adaptation.type === "video" &&
        // We're playing the current Period
        (0,ranges/* isTimeInRange */.Ti)({ start, end }, currentTime) &&
        // There is data for the current position or the codecs are differents
        (playbackInfo.readyState > 1 || !adaptation.getPlayableRepresentations()
            .some(rep => { var _a; return are_codecs_compatible(rep.getMimeTypeString(), (_a = segmentBuffer.codec) !== null && _a !== void 0 ? _a : ""); })) &&
        // We're not playing the current wanted video Adaptation
        !(0,ranges/* isTimeInRanges */.A1)(adaptationInBuffer, currentTime)) {
        return { type: "needs-reload", value: undefined };
    }
    if (adaptation.type === "audio" &&
        segmentBuffer.codec !== undefined &&
        // We have been explicitly asked to reload
        options.audioTrackSwitchingMode === "direct" &&
        // We're playing the current Period
        (0,ranges/* isTimeInRange */.Ti)({ start, end }, currentTime) &&
        // There is data for the current position or the codecs are differents
        (playbackInfo.readyState > 1 || !hasCompatibleCodec(adaptation, segmentBuffer.codec)) &&
        // We're not playing the current wanted audio Adaptation yet
        !(0,ranges/* isTimeInRanges */.A1)(adaptationInBuffer, currentTime)) {
        return { type: "needs-reload", value: undefined };
    }
    // From here, clean-up data from the previous Adaptation, if one
    const rangesToExclude = [];
    // First, we don't want to accidentally remove some segments from the previous
    // Period (which overlap a little with this one)
    /** Last segment before one for the current period. */
    const lastSegmentBefore = getLastSegmentBeforePeriod(inventory, period);
    if (lastSegmentBefore !== null &&
        (lastSegmentBefore.bufferedEnd === undefined ||
            period.start - lastSegmentBefore.bufferedEnd < 1)) // Close to Period's start
     {
        // Exclude data close to the period's start to avoid cleaning
        // to much
        rangesToExclude.push({ start: 0,
            end: period.start + 1 });
    }
    // Next, exclude data around current position to avoid decoding issues
    const bufferType = adaptation.type;
    /** Ranges that won't be cleaned from the current buffer. */
    let paddingBefore = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].before;
    if (paddingBefore == null) {
        paddingBefore = 0;
    }
    let paddingAfter = ADAPTATION_SWITCH_BUFFER_PADDINGS[bufferType].after;
    if (paddingAfter == null) {
        paddingAfter = 0;
    }
    rangesToExclude.push({ start: currentTime - paddingBefore,
        end: currentTime + paddingAfter });
    // Now remove possible small range from the end if there is a segment from the
    // next Period
    if (period.end !== undefined) {
        /** first segment after for the current period. */
        const firstSegmentAfter = getFirstSegmentAfterPeriod(inventory, period);
        if (firstSegmentAfter !== null &&
            (firstSegmentAfter.bufferedStart === undefined ||
                (firstSegmentAfter.bufferedStart - period.end) < 1)) // Close to Period's end
         {
            rangesToExclude.push({ start: period.end - 1,
                end: Number.MAX_VALUE });
        }
    }
    const toRemove = (0,ranges/* excludeFromRanges */.uH)(unwantedRange, rangesToExclude);
    return toRemove.length > 0 ? { type: "clean-buffer", value: toRemove } :
        { type: "continue", value: undefined };
}
/**
 * Returns `true` if at least one codec of the Representations in the given
 * Adaptation has a codec compatible with the given SegmentBuffer's codec.
 * @param {Object} adaptation
 * @param {string} segmentBufferCodec
 * @returns {boolean}
 */
function hasCompatibleCodec(adaptation, segmentBufferCodec) {
    return adaptation.getPlayableRepresentations().some(rep => are_codecs_compatible(rep.getMimeTypeString(), segmentBufferCodec));
}
/**
 * Returns buffered ranges of what we know correspond to the given `adaptation`
 * in the SegmentBuffer.
 * @param {Object} segmentBuffer
 * @param {Object} period
 * @param {Object} adaptation
 * @returns {Array.<Object>}
 */
function getBufferedRangesFromAdaptation(inventory, period, adaptation) {
    return inventory.reduce((acc, chunk) => {
        if (chunk.infos.period.id !== period.id ||
            chunk.infos.adaptation.id !== adaptation.id) {
            return acc;
        }
        const { bufferedStart, bufferedEnd } = chunk;
        if (bufferedStart === undefined || bufferedEnd === undefined) {
            return acc;
        }
        acc.push({ start: bufferedStart, end: bufferedEnd });
        return acc;
    }, []);
}
/**
 * Returns the last segment in the `inventory` which is linked to a Period
 * before `period`.
 * @param {Array.<Object>} inventory
 * @param {Object} period
 * @returns {Object|null}
 */
function getLastSegmentBeforePeriod(inventory, period) {
    for (let i = 0; i < inventory.length; i++) {
        if (inventory[i].infos.period.start >= period.start) {
            if (i > 0) {
                return inventory[i - 1];
            }
            return null;
        }
    }
    return inventory.length > 0 ? inventory[inventory.length - 1] :
        null;
}
/**
 * Returns the first segment in the `inventory` which is linked to a Period
 * after `period`.
 * @param {Array.<Object>} inventory
 * @param {Object} period
 * @returns {Object|null}
 */
function getFirstSegmentAfterPeriod(inventory, period) {
    for (let i = 0; i < inventory.length; i++) {
        if (inventory[i].infos.period.start > period.start) {
            return inventory[i];
        }
    }
    return null;
}

;// CONCATENATED MODULE: ./src/core/stream/period/period_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













const { DELTA_POSITION_AFTER_RELOAD: period_stream_DELTA_POSITION_AFTER_RELOAD } = config/* default */.Z;
/**
 * Create single PeriodStream Observable:
 *   - Lazily create (or reuse) a SegmentBuffer for the given type.
 *   - Create a Stream linked to an Adaptation each time it changes, to
 *     download and append the corresponding segments to the SegmentBuffer.
 *   - Announce when the Stream is full or is awaiting new Segments through
 *     events
 * @param {Object} args
 * @returns {Observable}
 */
function PeriodStream({ abrManager, bufferType, clock$, content, garbageCollectors, segmentFetcherCreator, segmentBuffersStore, options, wantedBufferAhead$, }) {
    const { period } = content;
    // Emits the chosen Adaptation for the current type.
    // `null` when no Adaptation is chosen (e.g. no subtitles)
    const adaptation$ = new ReplaySubject/* ReplaySubject */.t(1);
    return adaptation$.pipe((0,switchMap/* switchMap */.w)((adaptation, switchNb) => {
        /**
         * If this is not the first Adaptation choice, we might want to apply a
         * delta to the current position so we can re-play back some media in the
         * new Adaptation to give some context back.
         * This value contains this relative position, in seconds.
         * @see reloadAfterSwitch
         */
        const relativePosAfterSwitch = switchNb === 0 ? 0 :
            bufferType === "audio" ? period_stream_DELTA_POSITION_AFTER_RELOAD.trackSwitch.audio :
                bufferType === "video" ? period_stream_DELTA_POSITION_AFTER_RELOAD.trackSwitch.video :
                    period_stream_DELTA_POSITION_AFTER_RELOAD.trackSwitch.other;
        if (adaptation === null) { // Current type is disabled for that Period
            log/* default.info */.Z.info(`Stream: Set no ${bufferType} Adaptation`, period);
            const segmentBufferStatus = segmentBuffersStore.getStatus(bufferType);
            let cleanBuffer$;
            if (segmentBufferStatus.type === "initialized") {
                log/* default.info */.Z.info(`Stream: Clearing previous ${bufferType} SegmentBuffer`);
                if (segment_buffers.isNative(bufferType)) {
                    return reloadAfterSwitch(period, clock$, relativePosAfterSwitch);
                }
                cleanBuffer$ = segmentBufferStatus.value
                    .removeBuffer(period.start, period.end == null ? Infinity :
                    period.end);
            }
            else {
                if (segmentBufferStatus.type === "uninitialized") {
                    segmentBuffersStore.disableSegmentBuffer(bufferType);
                }
                cleanBuffer$ = (0,of.of)(null);
            }
            return (0,concat/* concat */.z)(cleanBuffer$.pipe((0,mapTo/* mapTo */.h)(stream_events_generators.adaptationChange(bufferType, null, period))), createEmptyAdaptationStream(clock$, wantedBufferAhead$, bufferType, { period }));
        }
        if (segment_buffers.isNative(bufferType) &&
            segmentBuffersStore.getStatus(bufferType).type === "disabled") {
            return reloadAfterSwitch(period, clock$, relativePosAfterSwitch);
        }
        log/* default.info */.Z.info(`Stream: Updating ${bufferType} adaptation`, adaptation, period);
        const newStream$ = clock$.pipe((0,take/* take */.q)(1), (0,mergeMap/* mergeMap */.zg)((tick) => {
            const segmentBuffer = createOrReuseSegmentBuffer(segmentBuffersStore, bufferType, adaptation, options);
            const playbackInfos = { currentTime: tick.getCurrentTime(),
                readyState: tick.readyState };
            const strategy = getAdaptationSwitchStrategy(segmentBuffer, period, adaptation, playbackInfos, options);
            if (strategy.type === "needs-reload") {
                return reloadAfterSwitch(period, clock$, relativePosAfterSwitch);
            }
            const cleanBuffer$ = strategy.type === "clean-buffer" ?
                (0,concat/* concat */.z)(...strategy.value.map(({ start, end }) => segmentBuffer.removeBuffer(start, end))).pipe((0,ignoreElements/* ignoreElements */.l)()) : empty/* EMPTY */.E;
            const bufferGarbageCollector$ = garbageCollectors.get(segmentBuffer);
            const adaptationStream$ = createAdaptationStream(adaptation, segmentBuffer);
            return segmentBuffersStore.waitForUsableBuffers().pipe((0,mergeMap/* mergeMap */.zg)(() => {
                return (0,concat/* concat */.z)(cleanBuffer$, (0,merge/* merge */.T)(adaptationStream$, bufferGarbageCollector$));
            }));
        }));
        return (0,concat/* concat */.z)((0,of.of)(stream_events_generators.adaptationChange(bufferType, adaptation, period)), newStream$);
    }), (0,startWith/* startWith */.O)(stream_events_generators.periodStreamReady(bufferType, period, adaptation$)));
    /**
     * @param {Object} adaptation
     * @param {Object} segmentBuffer
     * @returns {Observable}
     */
    function createAdaptationStream(adaptation, segmentBuffer) {
        const { manifest } = content;
        const adaptationStreamClock$ = clock$.pipe((0,map/* map */.U)(tick => {
            const buffered = segmentBuffer.getBufferedRanges();
            return (0,object_assign/* default */.Z)({}, tick, { bufferGap: (0,ranges/* getLeftSizeOfRange */.L7)(buffered, tick.position) });
        }));
        return stream_adaptation({ abrManager,
            clock$: adaptationStreamClock$,
            content: { manifest, period, adaptation },
            options,
            segmentBuffer,
            segmentFetcherCreator,
            wantedBufferAhead$ }).pipe((0,catchError/* catchError */.K)((error) => {
            // Stream linked to a non-native media buffer should not impact the
            // stability of the player. ie: if a text buffer sends an error, we want
            // to continue playing without any subtitles
            if (!segment_buffers.isNative(bufferType)) {
                log/* default.error */.Z.error(`Stream: ${bufferType} Stream crashed. Aborting it.`, error);
                segmentBuffersStore.disposeSegmentBuffer(bufferType);
                const formattedError = formatError(error, {
                    defaultCode: "NONE",
                    defaultReason: "Unknown `AdaptationStream` error",
                });
                return (0,concat/* concat */.z)((0,of.of)(stream_events_generators.warning(formattedError)), createEmptyAdaptationStream(clock$, wantedBufferAhead$, bufferType, { period }));
            }
            log/* default.error */.Z.error(`Stream: ${bufferType} Stream crashed. Stopping playback.`, error);
            throw error;
        }));
    }
}
/**
 * @param {string} bufferType
 * @param {Object} adaptation
 * @returns {Object}
 */
function createOrReuseSegmentBuffer(segmentBuffersStore, bufferType, adaptation, options) {
    const segmentBufferStatus = segmentBuffersStore.getStatus(bufferType);
    if (segmentBufferStatus.type === "initialized") {
        log/* default.info */.Z.info("Stream: Reusing a previous SegmentBuffer for the type", bufferType);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return segmentBufferStatus.value;
    }
    const codec = getFirstDeclaredMimeType(adaptation);
    const sbOptions = bufferType === "text" ? options.textTrackOptions : undefined;
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return segmentBuffersStore.createSegmentBuffer(bufferType, codec, sbOptions);
}
/**
 * Get mime-type string of the first representation declared in the given
 * adaptation.
 * @param {Adaptation} adaptation
 * @returns {string}
 */
function getFirstDeclaredMimeType(adaptation) {
    const { representations } = adaptation;
    if (representations[0] == null) {
        return "";
    }
    return representations[0].getMimeTypeString();
}

;// CONCATENATED MODULE: ./src/core/stream/period/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const period = (PeriodStream);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/scan.js
var scan = __webpack_require__(55291);
;// CONCATENATED MODULE: ./src/core/stream/orchestrator/active_period_emitter.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Emit the active Period each times it changes.
 *
 * The active Period is the first Period (in chronological order) which has
 * a RepresentationStream associated for every defined BUFFER_TYPES.
 *
 * Emit null if no Period can be considered active currently.
 *
 * @example
 * For 4 BUFFER_TYPES: "AUDIO", "VIDEO", "TEXT" and "IMAGE":
 * ```
 *                     +-------------+
 *         Period 1    | Period 2    | Period 3
 * AUDIO   |=========| | |===      | |
 * VIDEO               | |=====    | |
 * TEXT    |(NO TEXT)| | |(NO TEXT)| | |====    |
 * IMAGE   |=========| | |=        | |
 *                     +-------------+
 *
 * The active Period here is Period 2 as Period 1 has no video
 * RepresentationStream.
 *
 * If we are missing a or multiple PeriodStreams in the first chronological
 * Period, like that is the case here, it generally means that we are
 * currently switching between Periods.
 *
 * For here we are surely switching from Period 1 to Period 2 beginning by the
 * video PeriodStream. As every PeriodStream is ready for Period 2, we can
 * already inform that it is the current Period.
 * ```
 *
 * @param {Array.<string>} bufferTypes - Every buffer types in the content.
 * @param {Observable} addPeriodStream$ - Emit PeriodStream information when
 * one is added.
 * @param {Observable} removePeriodStream$ - Emit PeriodStream information when
 * one is removed.
 * @returns {Observable}
 */
function ActivePeriodEmitter(buffers$) {
    const numberOfStreams = buffers$.length;
    return (0,merge/* merge */.T)(...buffers$).pipe(
    // not needed to filter, this is an optim
    (0,filter/* filter */.h)(({ type }) => type === "periodStreamCleared" ||
        type === "adaptationChange" ||
        type === "representationChange"), (0,scan/* scan */.R)((acc, evt) => {
        switch (evt.type) {
            case "periodStreamCleared":
                {
                    const { period, type } = evt.value;
                    const currentInfos = acc[period.id];
                    if (currentInfos !== undefined && currentInfos.buffers.has(type)) {
                        currentInfos.buffers.delete(type);
                        if (currentInfos.buffers.size === 0) {
                            delete acc[period.id];
                        }
                    }
                }
                break;
            case "adaptationChange": {
                // For Adaptations that are not null, we will receive a
                // `representationChange` event. We can thus skip this event and only
                // listen to the latter.
                if (evt.value.adaptation !== null) {
                    return acc;
                }
            }
            // /!\ fallthrough done on purpose
            // Note that we fall-through only when the Adaptation sent through the
            // `adaptationChange` event is `null`. This is because in those cases,
            // we won't receive any "representationChange" event. We however still
            // need to register that Period as active for the current type.
            // eslint-disable-next-line no-fallthrough
            case "representationChange":
                {
                    const { period, type } = evt.value;
                    const currentInfos = acc[period.id];
                    if (currentInfos !== undefined && !currentInfos.buffers.has(type)) {
                        currentInfos.buffers.add(type);
                    }
                    else {
                        const bufferSet = new Set();
                        bufferSet.add(type);
                        acc[period.id] = { period, buffers: bufferSet };
                    }
                }
                break;
        }
        return acc;
    }, {}), (0,map/* map */.U)((list) => {
        const activePeriodIDs = Object.keys(list);
        const completePeriods = [];
        for (let i = 0; i < activePeriodIDs.length; i++) {
            const periodInfos = list[activePeriodIDs[i]];
            if (periodInfos !== undefined && periodInfos.buffers.size === numberOfStreams) {
                completePeriods.push(periodInfos.period);
            }
        }
        return completePeriods.reduce((acc, period) => {
            if (acc === null) {
                return period;
            }
            return period.start < acc.start ? period :
                acc;
        }, null);
    }), (0,distinctUntilChanged/* distinctUntilChanged */.x)((a, b) => {
        return a === null && b === null ||
            a !== null && b !== null && a.id === b.id;
    }));
}

;// CONCATENATED MODULE: ./src/core/stream/orchestrator/are_streams_complete.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns an Observable which emits ``true`` when all PeriodStreams given are
 * _complete_.
 * Returns false otherwise.
 *
 * A PeriodStream for a given type is considered _complete_ when both of these
 * conditions are true:
 *   - it is the last PeriodStream in the content for the given type
 *   - it has finished downloading segments (it is _full_)
 *
 * Simply put a _complete_ PeriodStream for a given type means that every
 * segments needed for this Stream have been downloaded.
 *
 * When the Observable returned here emits, every Stream are finished.
 * @param {...Observable} streams
 * @returns {Observable}
 */
function areStreamsComplete(...streams) {
    /**
     * Array of Observables linked to the Array of Streams which emit:
     *   - true when the corresponding Stream is considered _complete_.
     *   - false when the corresponding Stream is considered _active_.
     * @type {Array.<Observable>}
     */
    const isCompleteArray = streams
        .map((stream) => {
        return stream.pipe((0,filter/* filter */.h)((evt) => {
            return evt.type === "complete-stream" ||
                (evt.type === "stream-status" && !evt.value.hasFinishedLoading);
        }), (0,map/* map */.U)((evt) => evt.type === "complete-stream"), (0,startWith/* startWith */.O)(false), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
    });
    return (0,combineLatest/* combineLatest */.aj)(isCompleteArray).pipe((0,map/* map */.U)((areComplete) => areComplete.every((isComplete) => isComplete)), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
}

;// CONCATENATED MODULE: ./src/core/stream/orchestrator/get_blacklisted_ranges.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns the buffered ranges which hold the given content.
 * Returns the whole buffered ranges if some of it is unknown.
 * @param {Object} segmentBuffer
 * @param {Array.<Object>} contents
 * @returns {Array.<Object>}
 */
function getBlacklistedRanges(segmentBuffer, contents) {
    if (contents.length === 0) {
        return [];
    }
    segmentBuffer.synchronizeInventory();
    const accumulator = [];
    const inventory = segmentBuffer.getInventory();
    for (let i = 0; i < inventory.length; i++) {
        const chunk = inventory[i];
        const hasContent = contents.some(content => {
            return chunk.infos.period.id === content.period.id &&
                chunk.infos.adaptation.id === content.adaptation.id &&
                chunk.infos.representation.id === content.representation.id;
        });
        if (hasContent) {
            const { bufferedStart, bufferedEnd } = chunk;
            if (bufferedStart === undefined || bufferedEnd === undefined) {
                log/* default.warn */.Z.warn("SO: No buffered start or end found from a segment.");
                const buffered = segmentBuffer.getBufferedRanges();
                const len = buffered.length;
                if (len === 0) {
                    return [];
                }
                return [{ start: buffered.start(0), end: buffered.end(len - 1) }];
            }
            const previousLastElement = accumulator[accumulator.length - 1];
            if (previousLastElement !== undefined &&
                previousLastElement.end === bufferedStart) {
                previousLastElement.end = bufferedEnd;
            }
            else {
                accumulator.push({ start: bufferedStart, end: bufferedEnd });
            }
        }
    }
    return accumulator;
}

;// CONCATENATED MODULE: ./src/core/stream/orchestrator/stream_orchestrator.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















const { MAXIMUM_MAX_BUFFER_AHEAD, MAXIMUM_MAX_BUFFER_BEHIND } = config/* default */.Z;
/**
 * Create and manage the various Stream Observables needed for the content to
 * play:
 *
 *   - Create or dispose SegmentBuffers depending on the chosen Adaptations.
 *
 *   - Push the right segments to those SegmentBuffers depending on the user's
 *     preferences, the current position, the bandwidth, the decryption
 *     conditions...
 *
 *   - Concatenate Streams for adaptation from separate Periods at the right
 *     time, to allow smooth transitions between periods.
 *
 *   - Emit various events to notify of its health and issues
 *
 * @param {Object} content
 * @param {Observable} clock$ - Emit position information
 * @param {Object} abrManager - Emit bitrate estimates and best Representation
 * to play.
 * @param {Object} segmentBuffersStore - Will be used to lazily create
 * SegmentBuffer instances associated with the current content.
 * @param {Object} segmentFetcherCreator - Allow to download segments.
 * @param {Object} options
 * @returns {Observable}
 */
function StreamOrchestrator(content, clock$, abrManager, segmentBuffersStore, segmentFetcherCreator, options) {
    const { manifest, initialPeriod } = content;
    const { maxBufferAhead$, maxBufferBehind$, wantedBufferAhead$ } = options;
    // Keep track of a unique BufferGarbageCollector created per
    // SegmentBuffer.
    const garbageCollectors = new WeakMapMemory((segmentBuffer) => {
        const { bufferType } = segmentBuffer;
        const defaultMaxBehind = MAXIMUM_MAX_BUFFER_BEHIND[bufferType] != null ?
            MAXIMUM_MAX_BUFFER_BEHIND[bufferType] :
            Infinity;
        const defaultMaxAhead = MAXIMUM_MAX_BUFFER_AHEAD[bufferType] != null ?
            MAXIMUM_MAX_BUFFER_AHEAD[bufferType] :
            Infinity;
        return BufferGarbageCollector({
            segmentBuffer,
            clock$: clock$.pipe((0,map/* map */.U)(tick => tick.position + tick.wantedTimeOffset)),
            maxBufferBehind$: maxBufferBehind$.pipe((0,map/* map */.U)(val => Math.min(val, defaultMaxBehind))),
            maxBufferAhead$: maxBufferAhead$.pipe((0,map/* map */.U)(val => Math.min(val, defaultMaxAhead))),
        });
    });
    // trigger warnings when the wanted time is before or after the manifest's
    // segments
    const outOfManifest$ = clock$.pipe((0,filter_map/* default */.Z)(({ position, wantedTimeOffset }) => {
        const offsetedPosition = wantedTimeOffset + position;
        if (offsetedPosition < manifest.getMinimumPosition()) {
            const warning = new media_error/* default */.Z("MEDIA_TIME_BEFORE_MANIFEST", "The current position is behind the " +
                "earliest time announced in the Manifest.");
            return stream_events_generators.warning(warning);
        }
        else if (offsetedPosition > manifest.getMaximumPosition()) {
            const warning = new media_error/* default */.Z("MEDIA_TIME_AFTER_MANIFEST", "The current position is after the latest " +
                "time announced in the Manifest.");
            return stream_events_generators.warning(warning);
        }
        return null;
    }, null));
    const bufferTypes = segmentBuffersStore.getBufferTypes();
    // Every PeriodStreams for every possible types
    const streamsArray = bufferTypes.map((bufferType) => {
        return manageEveryStreams(bufferType, initialPeriod)
            .pipe((0,defer_subscriptions/* default */.Z)(), (0,share/* share */.B)());
    });
    // Emits the activePeriodChanged events every time the active Period changes.
    const activePeriodChanged$ = ActivePeriodEmitter(streamsArray).pipe((0,filter/* filter */.h)((period) => period !== null), (0,map/* map */.U)(period => {
        log/* default.info */.Z.info("Stream: New active period", period);
        return stream_events_generators.activePeriodChanged(period);
    }));
    // Emits an "end-of-stream" event once every PeriodStream are complete.
    // Emits a 'resume-stream" when it's not
    const endOfStream$ = areStreamsComplete(...streamsArray)
        .pipe((0,map/* map */.U)((areComplete) => areComplete ? stream_events_generators.endOfStream() : stream_events_generators.resumeStream()));
    return (0,merge/* merge */.T)(...streamsArray, activePeriodChanged$, endOfStream$, outOfManifest$);
    /**
     * Manage creation and removal of Streams for every Periods for a given type.
     *
     * Works by creating consecutive Streams through the
     * `manageConsecutivePeriodStreams` function, and restarting it when the clock
     * goes out of the bounds of these Streams.
     * @param {string} bufferType - e.g. "audio" or "video"
     * @param {Period} basePeriod - Initial Period downloaded.
     * @returns {Observable}
     */
    function manageEveryStreams(bufferType, basePeriod) {
        // Each Period for which there is currently a Stream, chronologically
        const periodList = new SortedList((a, b) => a.start - b.start);
        const destroyStreams$ = new Subject/* Subject */.xQ();
        // When set to `true`, all the currently active PeriodStream will be destroyed
        // and re-created from the new current position if we detect it to be out of
        // their bounds.
        // This is set to false when we're in the process of creating the first
        // PeriodStream, to avoid interferences while no PeriodStream is available.
        let enableOutOfBoundsCheck = false;
        /**
         * @param {Object} period
         * @returns {Observable}
         */
        function launchConsecutiveStreamsForPeriod(period) {
            return manageConsecutivePeriodStreams(bufferType, period, destroyStreams$).pipe((0,filter_map/* default */.Z)((message) => {
                switch (message.type) {
                    case "needs-media-source-reload":
                        // Only reload the MediaSource when the more immediately required
                        // Period is the one asking for it
                        const firstPeriod = periodList.head();
                        if (firstPeriod === undefined ||
                            firstPeriod.id !== message.value.period.id) {
                            return null;
                        }
                        break;
                    case "periodStreamReady":
                        enableOutOfBoundsCheck = true;
                        periodList.add(message.value.period);
                        break;
                    case "periodStreamCleared":
                        periodList.removeElement(message.value.period);
                        break;
                }
                return message;
            }, null), (0,share/* share */.B)());
        }
        /**
         * Returns true if the given time is either:
         *   - less than the start of the chronologically first Period
         *   - more than the end of the chronologically last Period
         * @param {number} time
         * @returns {boolean}
         */
        function isOutOfPeriodList(time) {
            const head = periodList.head();
            const last = periodList.last();
            if (head == null || last == null) { // if no period
                return true;
            }
            return head.start > time ||
                (last.end == null ? Infinity :
                    last.end) < time;
        }
        // Restart the current Stream when the wanted time is in another period
        // than the ones already considered
        const restartStreamsWhenOutOfBounds$ = clock$.pipe((0,filter_map/* default */.Z)(({ position, wantedTimeOffset }) => {
            var _a;
            const time = wantedTimeOffset + position;
            if (!enableOutOfBoundsCheck || !isOutOfPeriodList(time)) {
                return null;
            }
            const nextPeriod = (_a = manifest.getPeriodForTime(time)) !== null && _a !== void 0 ? _a : manifest.getNextPeriod(time);
            if (nextPeriod === undefined) {
                return null;
            }
            log/* default.info */.Z.info("SO: Current position out of the bounds of the active periods," +
                "re-creating Streams.", bufferType, position + wantedTimeOffset);
            enableOutOfBoundsCheck = false;
            destroyStreams$.next();
            return nextPeriod;
        }, null), (0,mergeMap/* mergeMap */.zg)((newInitialPeriod) => {
            if (newInitialPeriod == null) {
                throw new media_error/* default */.Z("MEDIA_TIME_NOT_FOUND", "The wanted position is not found in the Manifest.");
            }
            return launchConsecutiveStreamsForPeriod(newInitialPeriod);
        }));
        // Free the buffer of undecipherable data
        const handleDecipherabilityUpdate$ = (0,event_emitter/* fromEvent */.R)(manifest, "decipherabilityUpdate")
            .pipe((0,mergeMap/* mergeMap */.zg)((updates) => {
            const segmentBufferStatus = segmentBuffersStore.getStatus(bufferType);
            const hasType = updates.some(update => update.adaptation.type === bufferType);
            if (!hasType || segmentBufferStatus.type !== "initialized") {
                return empty/* EMPTY */.E; // no need to stop the current Streams.
            }
            const undecipherableUpdates = updates.filter(update => update.representation.decipherable === false);
            const segmentBuffer = segmentBufferStatus.value;
            const rangesToClean = getBlacklistedRanges(segmentBuffer, undecipherableUpdates);
            if (rangesToClean.length === 0) {
                // Nothing to clean => no buffer to flush.
                return empty/* EMPTY */.E;
            }
            // We have to remove the undecipherable media data and then ask the
            // current media element to be "flushed"
            enableOutOfBoundsCheck = false;
            destroyStreams$.next();
            return (0,concat/* concat */.z)(...rangesToClean.map(({ start, end }) => segmentBuffer.removeBuffer(start, end).pipe((0,ignoreElements/* ignoreElements */.l)())), clock$.pipe((0,take/* take */.q)(1), (0,mergeMap/* mergeMap */.zg)((lastTick) => {
                return (0,concat/* concat */.z)((0,of.of)(stream_events_generators.needsDecipherabilityFlush(lastTick.position, !lastTick.isPaused, lastTick.duration)), (0,defer/* defer */.P)(() => {
                    const lastPosition = lastTick.position + lastTick.wantedTimeOffset;
                    const newInitialPeriod = manifest.getPeriodForTime(lastPosition);
                    if (newInitialPeriod == null) {
                        throw new media_error/* default */.Z("MEDIA_TIME_NOT_FOUND", "The wanted position is not found in the Manifest.");
                    }
                    return launchConsecutiveStreamsForPeriod(newInitialPeriod);
                }));
            })));
        }));
        return (0,merge/* merge */.T)(restartStreamsWhenOutOfBounds$, handleDecipherabilityUpdate$, launchConsecutiveStreamsForPeriod(basePeriod));
    }
    /**
     * Create lazily consecutive PeriodStreams:
     *
     * It first creates the PeriodStream for `basePeriod` and - once it becomes
     * full - automatically creates the next chronological one.
     * This process repeats until the PeriodStream linked to the last Period is
     * full.
     *
     * If an "old" PeriodStream becomes active again, it destroys all PeriodStream
     * coming after it (from the last chronological one to the first).
     *
     * To clean-up PeriodStreams, each one of them are also automatically
     * destroyed once the clock announces a time superior or equal to the end of
     * the concerned Period.
     *
     * A "periodStreamReady" event is sent each times a new PeriodStream is
     * created. The first one (for `basePeriod`) should be sent synchronously on
     * subscription.
     *
     * A "periodStreamCleared" event is sent each times a PeriodStream is
     * destroyed.
     * @param {string} bufferType - e.g. "audio" or "video"
     * @param {Period} basePeriod - Initial Period downloaded.
     * @param {Observable} destroy$ - Emit when/if all created Streams from this
     * point should be destroyed.
     * @returns {Observable}
     */
    function manageConsecutivePeriodStreams(bufferType, basePeriod, destroy$) {
        log/* default.info */.Z.info("SO: Creating new Stream for", bufferType, basePeriod);
        // Emits the Period of the next Period Stream when it can be created.
        const createNextPeriodStream$ = new Subject/* Subject */.xQ();
        // Emits when the Streams for the next Periods should be destroyed, if
        // created.
        const destroyNextStreams$ = new Subject/* Subject */.xQ();
        // Emits when the current position goes over the end of the current Stream.
        const endOfCurrentStream$ = clock$
            .pipe((0,filter/* filter */.h)(({ position, wantedTimeOffset }) => basePeriod.end != null &&
            (position + wantedTimeOffset) >= basePeriod.end));
        // Create Period Stream for the next Period.
        const nextPeriodStream$ = createNextPeriodStream$
            .pipe(exhaustMap((nextPeriod) => manageConsecutivePeriodStreams(bufferType, nextPeriod, destroyNextStreams$)));
        // Allows to destroy each created Stream, from the newest to the oldest,
        // once destroy$ emits.
        const destroyAll$ = destroy$.pipe((0,take/* take */.q)(1), (0,tap/* tap */.b)(() => {
            // first complete createNextStream$ to allow completion of the
            // nextPeriodStream$ observable once every further Streams have been
            // cleared.
            createNextPeriodStream$.complete();
            // emit destruction signal to the next Stream first
            destroyNextStreams$.next();
            destroyNextStreams$.complete(); // we do not need it anymore
        }), (0,share/* share */.B)() // share side-effects
        );
        // Will emit when the current Stream should be destroyed.
        const killCurrentStream$ = (0,merge/* merge */.T)(endOfCurrentStream$, destroyAll$);
        const periodStream$ = period({ abrManager,
            bufferType,
            clock$,
            content: { manifest, period: basePeriod },
            garbageCollectors,
            segmentFetcherCreator,
            segmentBuffersStore,
            options,
            wantedBufferAhead$ }).pipe((0,mergeMap/* mergeMap */.zg)((evt) => {
            if (evt.type === "stream-status") {
                if (evt.value.hasFinishedLoading) {
                    const nextPeriod = manifest.getPeriodAfter(basePeriod);
                    if (nextPeriod === null) {
                        return (0,concat/* concat */.z)((0,of.of)(evt), (0,of.of)(stream_events_generators.streamComplete(bufferType)));
                    }
                    // current Stream is full, create the next one if not
                    createNextPeriodStream$.next(nextPeriod);
                }
                else {
                    // current Stream is active, destroy next Stream if created
                    destroyNextStreams$.next();
                }
            }
            return (0,of.of)(evt);
        }), (0,share/* share */.B)());
        // Stream for the current Period.
        const currentStream$ = (0,concat/* concat */.z)(periodStream$.pipe((0,takeUntil/* takeUntil */.R)(killCurrentStream$)), (0,of.of)(stream_events_generators.periodStreamCleared(bufferType, basePeriod))
            .pipe((0,tap/* tap */.b)(() => {
            log/* default.info */.Z.info("SO: Destroying Stream for", bufferType, basePeriod);
        })));
        return (0,merge/* merge */.T)(currentStream$, nextPeriodStream$, destroyAll$.pipe((0,ignoreElements/* ignoreElements */.l)()));
    }
}

;// CONCATENATED MODULE: ./src/core/stream/orchestrator/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const orchestrator = (StreamOrchestrator);

;// CONCATENATED MODULE: ./src/core/stream/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ const stream = (orchestrator);

;// CONCATENATED MODULE: ./src/core/init/create_stream_clock.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Create clock Observable for the `Stream` part of the code.
 * @param {Observable} initClock$
 * @param {Object} streamClockArgument
 * @returns {Observable}
 */
function createStreamClock(initClock$, { autoPlay, initialPlay$, initialSeek$, manifest, speed$, startTime }) {
    let initialPlayPerformed = false;
    let initialSeekPerformed = false;
    const updateIsPaused$ = initialPlay$.pipe((0,tap/* tap */.b)(() => { initialPlayPerformed = true; }), (0,ignoreElements/* ignoreElements */.l)());
    const updateTimeOffset$ = initialSeek$.pipe((0,tap/* tap */.b)(() => { initialSeekPerformed = true; }), (0,ignoreElements/* ignoreElements */.l)());
    const clock$ = (0,combineLatest/* combineLatest */.aj)([initClock$, speed$])
        .pipe((0,map/* map */.U)(([tick, speed]) => {
        const { isLive } = manifest;
        return {
            position: tick.position,
            getCurrentTime: tick.getCurrentTime,
            duration: tick.duration,
            isPaused: initialPlayPerformed ? tick.paused :
                !autoPlay,
            liveGap: isLive ? manifest.getMaximumPosition() - tick.position :
                Infinity,
            readyState: tick.readyState,
            speed,
            stalled: tick.stalled,
            // wantedTimeOffset is an offset to add to the timing's current time to have
            // the "real" wanted position.
            // For now, this is seen when the media element has not yet seeked to its
            // initial position, the currentTime will most probably be 0 where the
            // effective starting position will be _startTime_.
            // Thus we initially set a wantedTimeOffset equal to startTime.
            wantedTimeOffset: initialSeekPerformed ? 0 :
                startTime - tick.position,
        };
    }));
    return (0,merge/* merge */.T)(updateIsPaused$, updateTimeOffset$, clock$);
}

;// CONCATENATED MODULE: ./src/core/init/duration_updater.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/** Number of seconds in a regular year. */
const YEAR_IN_SECONDS = 365 * 24 * 3600;
/**
 * Keep the MediaSource duration up-to-date with the Manifest one on
 * subscription:
 * Set the current duration initially and then update if needed after
 * each Manifest updates.
 * @param {Object} manifest
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */
function DurationUpdater(manifest, mediaSource) {
    return (0,event_emitter/* fromEvent */.R)(manifest, "manifestUpdate").pipe((0,startWith/* startWith */.O)(null), (0,tap/* tap */.b)(() => {
        const maximumPosition = manifest.getMaximumPosition();
        // Some targets poorly support setting a very high number for durations.
        // Yet, in live contents, we would prefer setting a value as high as possible
        // to still be able to seek anywhere we want to (even ahead of the Manifest if
        // we want to). As such, we put it at a safe default value of 2^32 excepted
        // when the maximum position is already relatively close to that value, where
        // we authorize exceptionally going over it.
        const newDuration = !manifest.isLive ? maximumPosition :
            Math.max(Math.pow(2, 32), maximumPosition + YEAR_IN_SECONDS);
        if (isNaN(mediaSource.duration) || !isFinite(mediaSource.duration) ||
            Math.abs(mediaSource.duration - newDuration) > 0.01) {
            log/* default.info */.Z.info("Init: Updating duration", newDuration);
            mediaSource.duration = newDuration;
        }
    }), (0,ignoreElements/* ignoreElements */.l)());
}

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/observable/race.js
var race = __webpack_require__(98925);
// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = __webpack_require__(86665);
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/takeLast.js
/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */




function takeLast(count) {
  return function takeLastOperatorFunction(source) {
    if (count === 0) {
      return (0,empty/* empty */.c)();
    } else {
      return source.lift(new TakeLastOperator(count));
    }
  };
}

var TakeLastOperator = /*@__PURE__*/function () {
  function TakeLastOperator(total) {
    this.total = total;

    if (this.total < 0) {
      throw new ArgumentOutOfRangeError/* ArgumentOutOfRangeError */.W();
    }
  }

  TakeLastOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
  };

  return TakeLastOperator;
}();

var TakeLastSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(TakeLastSubscriber, _super);

  function TakeLastSubscriber(destination, total) {
    var _this = _super.call(this, destination) || this;

    _this.total = total;
    _this.ring = new Array();
    _this.count = 0;
    return _this;
  }

  TakeLastSubscriber.prototype._next = function (value) {
    var ring = this.ring;
    var total = this.total;
    var count = this.count++;

    if (ring.length < total) {
      ring.push(value);
    } else {
      var index = count % total;
      ring[index] = value;
    }
  };

  TakeLastSubscriber.prototype._complete = function () {
    var destination = this.destination;
    var count = this.count;

    if (count > 0) {
      var total = this.count >= this.total ? this.total : this.count;
      var ring = this.ring;

      for (var i = 0; i < total; i++) {
        var idx = count++ % total;
        destination.next(ring[idx]);
      }
    }

    destination.complete();
  };

  return TakeLastSubscriber;
}(Subscriber/* Subscriber */.L);
;// CONCATENATED MODULE: ./src/core/init/end_of_stream.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




const { onRemoveSourceBuffers$, onSourceOpen$: end_of_stream_onSourceOpen$, onUpdate$ } = event_listeners;
/**
 * Get "updating" SourceBuffers from a SourceBufferList.
 * @param {SourceBufferList} sourceBuffers
 * @returns {Array.<SourceBuffer>}
 */
function getUpdatingSourceBuffers(sourceBuffers) {
    const updatingSourceBuffers = [];
    for (let i = 0; i < sourceBuffers.length; i++) {
        const SourceBuffer = sourceBuffers[i];
        if (SourceBuffer.updating) {
            updatingSourceBuffers.push(SourceBuffer);
        }
    }
    return updatingSourceBuffers;
}
/**
 * Trigger the `endOfStream` method of a MediaSource.
 *
 * If the MediaSource is ended/closed, do not call this method.
 * If SourceBuffers are updating, wait for them to be updated before closing
 * it.
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */
function triggerEndOfStream(mediaSource) {
    return (0,defer/* defer */.P)(() => {
        log/* default.debug */.Z.debug("Init: Trying to call endOfStream");
        if (mediaSource.readyState !== "open") {
            log/* default.debug */.Z.debug("Init: MediaSource not open, cancel endOfStream");
            return (0,of.of)(null);
        }
        const { sourceBuffers } = mediaSource;
        const updatingSourceBuffers = getUpdatingSourceBuffers(sourceBuffers);
        if (updatingSourceBuffers.length === 0) {
            log/* default.info */.Z.info("Init: Triggering end of stream");
            mediaSource.endOfStream();
            return (0,of.of)(null);
        }
        log/* default.debug */.Z.debug("Init: Waiting SourceBuffers to be updated before calling endOfStream.");
        const updatedSourceBuffers$ = updatingSourceBuffers
            .map((sourceBuffer) => onUpdate$(sourceBuffer).pipe((0,take/* take */.q)(1)));
        return (0,race/* race */.S3)((0,merge/* merge */.T)(...updatedSourceBuffers$).pipe(takeLast(1)), onRemoveSourceBuffers$(sourceBuffers).pipe((0,take/* take */.q)(1))).pipe((0,mergeMap/* mergeMap */.zg)(() => {
            return triggerEndOfStream(mediaSource);
        }));
    });
}
/**
 * Trigger the `endOfStream` method of a MediaSource each times it opens.
 * @see triggerEndOfStream
 * @param {MediaSource} mediaSource
 * @returns {Observable}
 */
function maintainEndOfStream(mediaSource) {
    return end_of_stream_onSourceOpen$(mediaSource).pipe((0,startWith/* startWith */.O)(null), (0,switchMap/* switchMap */.w)(() => triggerEndOfStream(mediaSource)));
}

// EXTERNAL MODULE: ./src/core/init/initial_seek_and_play.ts + 4 modules
var initial_seek_and_play = __webpack_require__(52678);
;// CONCATENATED MODULE: ./src/compat/is_playback_stuck.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * firefox fix: sometimes playback can be stalled, even if we are in a buffer.
 * TODO This seems to be about an old Firefox version. Delete it?
 * @param {number} time
 * @param {Object|null} currentRange
 * @param {string} state
 * @param {Boolean} isStalled
 * @returns {Boolean}
 */
function isPlaybackStuck(time, currentRange, state, isStalled) {
    const FREEZE_THRESHOLD = 10; // freeze threshold in seconds
    return (browser_detection/* isFirefox */.vU &&
        isStalled &&
        state === "timeupdate" &&
        currentRange != null &&
        currentRange.end - time > FREEZE_THRESHOLD);
}

;// CONCATENATED MODULE: ./src/compat/is_seeking_approximate.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * On some devices (right now only seen on Tizen), seeking through the
 * `currentTime` property can lead to the browser re-seeking once the
 * segments have been loaded to improve seeking performances (for
 * example, by seeking right to an intra video frame).
 *
 * This can lead to conflicts with the RxPlayer code.
 *
 * This boolean is only `true` on the devices where this behavior has been
 * observed.
 */
const isSeekingApproximate = browser_detection/* isTizen */.yS;
/* harmony default export */ const is_seeking_approximate = (isSeekingApproximate);

;// CONCATENATED MODULE: ./src/core/init/stall_avoider.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








const { BUFFER_DISCONTINUITY_THRESHOLD, FORCE_DISCONTINUITY_SEEK_DELAY } = config/* default */.Z;
/**
 * Work-around rounding errors with floating points by setting an acceptable,
 * very short, deviation when checking equalities.
 */
const EPSILON = 1 / 60;
/**
 * Monitor situations where playback is stalled and try to get out of those.
 * Emit "stalled" then "unstalled" respectably when an unavoidable stall is
 * encountered and exited.
 * @param {Observable} clock$ - Observable emitting the current playback
 * conditions.
 * @param {HTMLMediaElement} mediaElement - The HTMLMediaElement on which the
 * media is played.
 * @param {Object} manifest - The Manifest of the currently-played content.
 * @param {Observable} discontinuityUpdate$ - Observable emitting encountered
 * discontinuities for loaded Period and buffer types.
 * @returns {Observable}
 */
function StallAvoider(clock$, mediaElement, manifest, discontinuityUpdate$, setCurrentTime) {
    const initialDiscontinuitiesStore = [];
    /**
     * Emit every known audio and video buffer discontinuities in chronological
     * order (first ordered by Period's start, then by bufferType in any order.
     */
    const discontinuitiesStore$ = discontinuityUpdate$.pipe(withLatestFrom(clock$), // listen to clock to clean-up old discontinuities
    (0,scan/* scan */.R)((discontinuitiesStore, [evt, tick]) => updateDiscontinuitiesStore(discontinuitiesStore, evt, tick), initialDiscontinuitiesStore));
    /**
     * On some devices (right now only seen on Tizen), seeking through the
     * `currentTime` property can lead to the browser re-seeking once the
     * segments have been loaded to improve seeking performances (for
     * example, by seeking right to an intra video frame).
     * In that case, we risk being in a conflict with that behavior: if for
     * example we encounter a small discontinuity at the position the browser
     * seeks to, we will seek over it, the browser would seek back and so on.
     *
     * This variable allows to store the last known position we were seeking to
     * so we can detect when the browser seeked back (to avoid performing another
     * seek after that). When browsers seek back to a position behind a
     * discontinuity, they are usually able to skip them without our help.
     */
    let lastSeekingPosition = null;
    /**
     * In some conditions (see `lastSeekingPosition`), we might want to not
     * automatically seek over discontinuities because the browser might do it
     * itself instead.
     * In that case, we still want to perform the seek ourselves if the browser
     * doesn't do it after sufficient time.
     * This variable allows to store the timestamp at which a discontinuity began
     * to be ignored.
     */
    let ignoredStallTimeStamp = null;
    return clock$.pipe(withLatestFrom(discontinuitiesStore$), (0,map/* map */.U)(([tick, discontinuitiesStore]) => {
        const { buffered, currentRange, position, event, stalled } = tick;
        if (stalled === null) {
            return { type: "unstalled", value: null };
        }
        if (tick.seeking) {
            lastSeekingPosition = tick.position;
        }
        else if (lastSeekingPosition !== null) {
            const now = performance.now();
            if (ignoredStallTimeStamp === null) {
                ignoredStallTimeStamp = now;
            }
            if (is_seeking_approximate &&
                tick.position < lastSeekingPosition &&
                now - ignoredStallTimeStamp < FORCE_DISCONTINUITY_SEEK_DELAY) {
                return { type: "stalled", value: stalled };
            }
            lastSeekingPosition = null;
        }
        ignoredStallTimeStamp = null;
        /** Position at which data is awaited. */
        const { position: stalledPosition } = stalled;
        if (stalledPosition !== null) {
            const skippableDiscontinuity = findSeekableDiscontinuity(discontinuitiesStore, manifest, stalledPosition);
            if (skippableDiscontinuity !== null) {
                const realSeekTime = skippableDiscontinuity + 0.001;
                if (realSeekTime <= mediaElement.currentTime) {
                    log/* default.info */.Z.info("Init: position to seek already reached, no seeking", mediaElement.currentTime, realSeekTime);
                }
                else {
                    log/* default.warn */.Z.warn("SA: skippable discontinuity found in the stream", position, realSeekTime);
                    setCurrentTime(realSeekTime);
                    return stream_events_generators.warning(generateDiscontinuityError(stalledPosition, realSeekTime));
                }
            }
        }
        // Is it a browser bug? -> force seek at the same current time
        if (isPlaybackStuck(position, currentRange, event, stalled !== null)) {
            log/* default.warn */.Z.warn("Init: After freeze seek", position, currentRange);
            setCurrentTime(position);
            return stream_events_generators.warning(generateDiscontinuityError(position, position));
        }
        const freezePosition = stalledPosition !== null && stalledPosition !== void 0 ? stalledPosition : position;
        // Is it a very short discontinuity in buffer ? -> Seek at the beginning of the
        //                                                 next range
        //
        // Discontinuity check in case we are close a buffered range but still
        // calculate a stalled state. This is useful for some
        // implementation that might drop an injected segment, or in
        // case of small discontinuity in the content.
        const nextBufferRangeGap = (0,ranges/* getNextRangeGap */.XS)(buffered, freezePosition);
        if (nextBufferRangeGap < BUFFER_DISCONTINUITY_THRESHOLD) {
            const seekTo = (freezePosition + nextBufferRangeGap + EPSILON);
            if (mediaElement.currentTime < seekTo) {
                log/* default.warn */.Z.warn("Init: discontinuity encountered inferior to the threshold", freezePosition, seekTo, BUFFER_DISCONTINUITY_THRESHOLD);
                setCurrentTime(seekTo);
                return stream_events_generators.warning(generateDiscontinuityError(freezePosition, seekTo));
            }
        }
        // Are we in a discontinuity between periods ? -> Seek at the beginning of the
        //                                                next period
        for (let i = manifest.periods.length - 2; i >= 0; i--) {
            const period = manifest.periods[i];
            if (period.end !== undefined && period.end <= freezePosition) {
                if (manifest.periods[i + 1].start > freezePosition &&
                    manifest.periods[i + 1].start > mediaElement.currentTime) {
                    const nextPeriod = manifest.periods[i + 1];
                    setCurrentTime(nextPeriod.start);
                    return stream_events_generators.warning(generateDiscontinuityError(freezePosition, nextPeriod.start));
                }
                break;
            }
        }
        return { type: "stalled", value: stalled };
    }));
}
/**
 * @param {Array.<Object>} discontinuitiesStore
 * @param {Object} manifest
 * @param {number} stalledPosition
 * @returns {number|null}
 */
function findSeekableDiscontinuity(discontinuitiesStore, manifest, stalledPosition) {
    if (discontinuitiesStore.length === 0) {
        return null;
    }
    let maxDiscontinuityEnd = null;
    for (let i = 0; i < discontinuitiesStore.length; i++) {
        const { period } = discontinuitiesStore[i];
        if (period.start > stalledPosition) {
            return maxDiscontinuityEnd;
        }
        let discontinuityEnd;
        if (period.end === undefined || period.end > stalledPosition) {
            const { discontinuity, position } = discontinuitiesStore[i];
            const { start, end } = discontinuity;
            const discontinuityLowerLimit = start !== null && start !== void 0 ? start : position;
            if (stalledPosition >= (discontinuityLowerLimit - EPSILON)) {
                if (end === null) {
                    const nextPeriod = manifest.getPeriodAfter(period);
                    if (nextPeriod !== null) {
                        discontinuityEnd = nextPeriod.start + EPSILON;
                    }
                    else {
                        log/* default.warn */.Z.warn("Init: discontinuity at Period's end but no next Period");
                    }
                }
                else if (stalledPosition < (end + EPSILON)) {
                    discontinuityEnd = end + EPSILON;
                }
            }
            if (discontinuityEnd !== undefined) {
                log/* default.info */.Z.info("Init: discontinuity found", stalledPosition, discontinuityEnd);
                maxDiscontinuityEnd =
                    maxDiscontinuityEnd !== null &&
                        maxDiscontinuityEnd > discontinuityEnd ? maxDiscontinuityEnd :
                        discontinuityEnd;
            }
        }
    }
    return maxDiscontinuityEnd;
}
/**
 * Return `true` if the given event indicates that a discontinuity is present.
 * @param {Object} evt
 * @returns {Array.<Object>}
 */
function eventContainsDiscontinuity(evt) {
    return evt.discontinuity !== null;
}
/**
 * Update the `discontinuitiesStore` Object with the given event information:
 *
 *   - If that event indicates than no discontinuity is found for a Period
 *     and buffer type, remove a possible existing discontinuity for that
 *     combination.
 *
 *   - If that event indicates that a discontinuity can be found for a Period
 *     and buffer type, replace previous occurences for that combination and
 *     store it in Period's chronological order in the Array.
 * @param {Array.<Object>} discontinuitiesStore
 * @param {Object} evt
 * @param {Object} tick
 * @returns {Array.<Object>}
 */
function updateDiscontinuitiesStore(discontinuitiesStore, evt, tick) {
    // First, perform clean-up of old discontinuities
    while (discontinuitiesStore.length > 0 &&
        discontinuitiesStore[0].period.end !== undefined &&
        discontinuitiesStore[0].period.end + 10 < tick.position) {
        discontinuitiesStore.shift();
    }
    const { period, bufferType } = evt;
    if (bufferType !== "audio" && bufferType !== "video") {
        return discontinuitiesStore;
    }
    for (let i = 0; i < discontinuitiesStore.length; i++) {
        if (discontinuitiesStore[i].period.id === period.id) {
            if (discontinuitiesStore[i].bufferType === bufferType) {
                if (!eventContainsDiscontinuity(evt)) {
                    discontinuitiesStore.splice(i, 1);
                }
                else {
                    discontinuitiesStore[i] = evt;
                }
                return discontinuitiesStore;
            }
        }
        else if (discontinuitiesStore[i].period.start > period.start) {
            if (eventContainsDiscontinuity(evt)) {
                discontinuitiesStore.splice(i, 0, evt);
            }
            return discontinuitiesStore;
        }
    }
    if (eventContainsDiscontinuity(evt)) {
        discontinuitiesStore.push(evt);
    }
    return discontinuitiesStore;
}
/**
 * Generate error emitted when a discontinuity has been encountered.
 * @param {number} stalledPosition
 * @param {number} seekTo
 * @returns {Error}
 */
function generateDiscontinuityError(stalledPosition, seekTo) {
    return new media_error/* default */.Z("DISCONTINUITY_ENCOUNTERED", "A discontinuity has been encountered at position " +
        String(stalledPosition) + ", seeked at position " +
        String(seekTo));
}

;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/pairwise.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function pairwise() {
  return function (source) {
    return source.lift(new PairwiseOperator());
  };
}

var PairwiseOperator = /*@__PURE__*/function () {
  function PairwiseOperator() {}

  PairwiseOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new PairwiseSubscriber(subscriber));
  };

  return PairwiseOperator;
}();

var PairwiseSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(PairwiseSubscriber, _super);

  function PairwiseSubscriber(destination) {
    var _this = _super.call(this, destination) || this;

    _this.hasPrev = false;
    return _this;
  }

  PairwiseSubscriber.prototype._next = function (value) {
    var pair;

    if (this.hasPrev) {
      pair = [this.prev, value];
    } else {
      this.hasPrev = true;
    }

    this.prev = value;

    if (pair) {
      this.destination.next(pair);
    }
  };

  return PairwiseSubscriber;
}(Subscriber/* Subscriber */.L);
;// CONCATENATED MODULE: ./src/core/init/stream_events_emitter/are_same_stream_events.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Compare 2 events.
 * As the payload of two events may be the same, but the JS objects may not
 * have the same references, it may be difficult to compare them.
 * If two events start and end at the same moment, and possess the same id,
 * we consider the two to be the same.
 * /!\ However, the DASH-if spec does not say that the event payload
 * may be the same if these conditions are met. Thus, there are high chances
 * that it may be the case.
 * TODO See if we can compare payloads
 * @param {Object} evt1
 * @param {Object} evt2
 * @returns {Boolean}
 */
function areSameStreamEvents(evt1, evt2) {
    return evt1.id === evt2.id &&
        evt1.start === evt2.start &&
        evt1.end === evt2.end;
}
/* harmony default export */ const are_same_stream_events = (areSameStreamEvents);

;// CONCATENATED MODULE: ./src/core/init/stream_events_emitter/refresh_scheduled_events_list.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Refresh local scheduled events list
 * @param {Array.<Object>} oldScheduledEvents
 * @param {Object} manifest
 * @returns {Array.<Object>}
 */
function refreshScheduledEventsList(oldScheduledEvents, manifest) {
    const scheduledEvents = [];
    const { periods } = manifest;
    for (let i = 0; i < periods.length; i++) {
        const period = periods[i];
        const { streamEvents } = period;
        streamEvents.forEach(({ start, end, id, data }) => {
            for (let j = 0; j < oldScheduledEvents.length; j++) {
                const currentScheduledEvent = oldScheduledEvents[j];
                if (are_same_stream_events(currentScheduledEvent, { id, start, end })) {
                    scheduledEvents.push(currentScheduledEvent);
                    return;
                }
            }
            if (end === undefined) {
                const newScheduledEvent = { start,
                    id,
                    data,
                    publicEvent: { start,
                        data } };
                scheduledEvents.push(newScheduledEvent);
            }
            else {
                const newScheduledEvent = { start,
                    end,
                    id,
                    data,
                    publicEvent: { start,
                        end,
                        data } };
                scheduledEvents.push(newScheduledEvent);
            }
        });
    }
    return scheduledEvents;
}
/* harmony default export */ const refresh_scheduled_events_list = (refreshScheduledEventsList);

;// CONCATENATED MODULE: ./src/core/init/stream_events_emitter/stream_events_emitter.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





const { STREAM_EVENT_EMITTER_POLL_INTERVAL } = config/* default */.Z;
/**
 * Tells if a stream event has a duration
 * @param {Object} evt
 * @returns {Boolean}
 */
function isFiniteStreamEvent(evt) {
    return evt.end !== undefined;
}
/**
 * Get events from manifest and emit each time an event has to be emitted
 * @param {Object} manifest
 * @param {HTMLMediaElement} mediaElement
 * @returns {Observable}
 */
function streamEventsEmitter(manifest, mediaElement, clock$) {
    const eventsBeingPlayed = new WeakMap();
    let lastScheduledEvents = [];
    const scheduledEvents$ = (0,event_emitter/* fromEvent */.R)(manifest, "manifestUpdate").pipe((0,startWith/* startWith */.O)(null), (0,scan/* scan */.R)((oldScheduledEvents) => {
        return refresh_scheduled_events_list(oldScheduledEvents, manifest);
    }, []));
    /**
     * Examine playback situation from clock ticks to emit stream events and
     * prepare set onExit callbacks if needed.
     * @param {Array.<Object>} scheduledEvents
     * @param {Object} oldTick
     * @param {Object} newTick
     * @returns {Observable}
     */
    function emitStreamEvents$(scheduledEvents, oldClockTick, newClockTick) {
        const { currentTime: previousTime } = oldClockTick;
        const { isSeeking, currentTime } = newClockTick;
        const eventsToSend = [];
        const eventsToExit = [];
        for (let i = 0; i < scheduledEvents.length; i++) {
            const event = scheduledEvents[i];
            const start = event.start;
            const end = isFiniteStreamEvent(event) ? event.end :
                undefined;
            const isBeingPlayed = eventsBeingPlayed.has(event);
            if (isBeingPlayed) {
                if (start > currentTime ||
                    (end !== undefined && currentTime >= end)) {
                    if (isFiniteStreamEvent(event)) {
                        eventsToExit.push(event.publicEvent);
                    }
                    eventsBeingPlayed.delete(event);
                }
            }
            else if (start <= currentTime &&
                end !== undefined &&
                currentTime < end) {
                eventsToSend.push({ type: "stream-event",
                    value: event.publicEvent });
                eventsBeingPlayed.set(event, true);
            }
            else if (previousTime < start &&
                currentTime >= (end !== null && end !== void 0 ? end : start)) {
                if (isSeeking) {
                    eventsToSend.push({ type: "stream-event-skip",
                        value: event.publicEvent });
                }
                else {
                    eventsToSend.push({ type: "stream-event",
                        value: event.publicEvent });
                    if (isFiniteStreamEvent(event)) {
                        eventsToExit.push(event.publicEvent);
                    }
                }
            }
        }
        return (0,concat/* concat */.z)(eventsToSend.length > 0 ? (0,of.of)(...eventsToSend) :
            empty/* EMPTY */.E, eventsToExit.length > 0 ? (0,of.of)(...eventsToExit).pipe((0,tap/* tap */.b)((evt) => {
            if (typeof evt.onExit === "function") {
                evt.onExit();
            }
        }), (0,ignoreElements/* ignoreElements */.l)()) : empty/* EMPTY */.E);
    }
    /**
     * This pipe allows to control wether the polling should occur, if there
     * are scheduledEvents, or not.
     */
    return scheduledEvents$.pipe((0,tap/* tap */.b)((scheduledEvents) => lastScheduledEvents = scheduledEvents), (0,map/* map */.U)((evt) => evt.length > 0), (0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,switchMap/* switchMap */.w)((hasEvents) => {
        if (!hasEvents) {
            return empty/* EMPTY */.E;
        }
        return (0,combineLatest/* combineLatest */.aj)([
            (0,observable_interval/* interval */.F)(STREAM_EVENT_EMITTER_POLL_INTERVAL).pipe((0,startWith/* startWith */.O)(null)),
            clock$,
        ]).pipe((0,map/* map */.U)(([_, clockTick]) => {
            const { seeking } = clockTick;
            return { isSeeking: seeking,
                currentTime: mediaElement.currentTime };
        }), pairwise(), (0,mergeMap/* mergeMap */.zg)(([oldTick, newTick]) => emitStreamEvents$(lastScheduledEvents, oldTick, newTick)));
    }));
}
/* harmony default export */ const stream_events_emitter = (streamEventsEmitter);

;// CONCATENATED MODULE: ./src/core/init/stream_events_emitter/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const init_stream_events_emitter = (stream_events_emitter);

// EXTERNAL MODULE: ./src/core/init/update_playback_rate.ts
var update_playback_rate = __webpack_require__(26087);
;// CONCATENATED MODULE: ./src/core/init/load_on_media_source.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














/**
 * Returns a function allowing to load or reload the content in arguments into
 * a single or multiple MediaSources.
 * @param {Object} args
 * @returns {Function}
 */
function createMediaSourceLoader({ mediaElement, manifest, clock$, speed$, bufferOptions, abrManager, segmentFetcherCreator, setCurrentTime }) {
    /**
     * Load the content on the given MediaSource.
     * @param {MediaSource} mediaSource
     * @param {number} initialTime
     * @param {boolean} autoPlay
     */
    return function loadContentOnMediaSource(mediaSource, initialTime, autoPlay) {
        var _a;
        /** Maintains the MediaSource's duration up-to-date with the Manifest */
        const durationUpdater$ = DurationUpdater(manifest, mediaSource);
        const initialPeriod = (_a = manifest.getPeriodForTime(initialTime)) !== null && _a !== void 0 ? _a : manifest.getNextPeriod(initialTime);
        if (initialPeriod === undefined) {
            const error = new media_error/* default */.Z("MEDIA_STARTING_TIME_NOT_FOUND", "Wanted starting time not found in the Manifest.");
            return (0,throwError/* throwError */._)(error);
        }
        /** Interface to create media buffers for loaded segments. */
        const segmentBuffersStore = new segment_buffers(mediaElement, mediaSource);
        const { seek$, load$ } = (0,initial_seek_and_play/* default */.Z)({ clock$,
            mediaElement,
            startTime: initialTime,
            mustAutoPlay: autoPlay,
            setCurrentTime,
            isDirectfile: false });
        const initialPlay$ = load$.pipe((0,filter/* filter */.h)((evt) => evt !== "not-loaded-metadata"));
        const streamEvents$ = initialPlay$.pipe((0,mergeMap/* mergeMap */.zg)(() => init_stream_events_emitter(manifest, mediaElement, clock$)));
        const streamClock$ = createStreamClock(clock$, { autoPlay,
            initialPlay$,
            initialSeek$: seek$,
            manifest,
            speed$,
            startTime: initialTime });
        /** Cancel endOfStream calls when streams become active again. */
        const cancelEndOfStream$ = new Subject/* Subject */.xQ();
        /** Emits discontinuities detected by the StreamOrchestrator. */
        const discontinuityUpdate$ = new Subject/* Subject */.xQ();
        // Creates Observable which will manage every Stream for the given Content.
        const streams$ = stream({ manifest, initialPeriod }, streamClock$, abrManager, segmentBuffersStore, segmentFetcherCreator, bufferOptions).pipe((0,mergeMap/* mergeMap */.zg)((evt) => {
            switch (evt.type) {
                case "end-of-stream":
                    log/* default.debug */.Z.debug("Init: end-of-stream order received.");
                    return maintainEndOfStream(mediaSource).pipe((0,ignoreElements/* ignoreElements */.l)(), (0,takeUntil/* takeUntil */.R)(cancelEndOfStream$));
                case "resume-stream":
                    log/* default.debug */.Z.debug("Init: resume-stream order received.");
                    cancelEndOfStream$.next(null);
                    return empty/* EMPTY */.E;
                case "stream-status":
                    const { period, bufferType, imminentDiscontinuity, position } = evt.value;
                    discontinuityUpdate$.next({ period,
                        bufferType,
                        discontinuity: imminentDiscontinuity,
                        position });
                    return empty/* EMPTY */.E;
                default:
                    return (0,of.of)(evt);
            }
        }));
        /**
         * On subscription, keep the playback speed synchronized to the speed set by
         * the user on the media element and force a speed of `0` when the buffer is
         * empty, so it can build back buffer.
         */
        const playbackRate$ = (0,update_playback_rate/* default */.Z)(mediaElement, speed$, clock$, { pauseWhenStalled: true })
            .pipe((0,ignoreElements/* ignoreElements */.l)());
        /**
         * Observable trying to avoid various stalling situations, emitting "stalled"
         * events when it cannot, as well as "unstalled" events when it get out of one.
         */
        const stallAvoider$ = StallAvoider(clock$, mediaElement, manifest, discontinuityUpdate$, setCurrentTime);
        const loadedEvent$ = load$
            .pipe((0,mergeMap/* mergeMap */.zg)((evt) => {
            if (evt === "autoplay-blocked") {
                const error = new media_error/* default */.Z("MEDIA_ERR_BLOCKED_AUTOPLAY", "Cannot trigger auto-play automatically: " +
                    "your browser does not allow it.");
                return (0,of.of)(events_generators/* default.warning */.Z.warning(error), events_generators/* default.loaded */.Z.loaded(segmentBuffersStore));
            }
            else if (evt === "not-loaded-metadata") {
                const error = new media_error/* default */.Z("MEDIA_ERR_NOT_LOADED_METADATA", "Cannot load automatically: your browser " +
                    "falsely announced having loaded the content.");
                return (0,of.of)(events_generators/* default.warning */.Z.warning(error));
            }
            log/* default.debug */.Z.debug("Init: The current content is loaded.");
            return (0,of.of)(events_generators/* default.loaded */.Z.loaded(segmentBuffersStore));
        }));
        return (0,merge/* merge */.T)(durationUpdater$, loadedEvent$, playbackRate$, stallAvoider$, streams$, streamEvents$).pipe(finalize(() => {
            // clean-up every created SegmentBuffers
            segmentBuffersStore.disposeAll();
        }));
    };
}

;// CONCATENATED MODULE: ./src/utils/rx-throttle.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function throttle(func) {
    let isPending = false;
    return (...args) => {
        return new Observable/* Observable */.y((obs) => {
            if (isPending) {
                obs.complete();
                return undefined;
            }
            isPending = true;
            const funcSubscription = func(...args)
                .subscribe((i) => { obs.next(i); }, (e) => {
                isPending = false;
                obs.error(e);
            }, () => {
                isPending = false;
                obs.complete();
            });
            return () => {
                funcSubscription.unsubscribe();
                isPending = false;
            };
        });
    };
}

;// CONCATENATED MODULE: ./src/core/init/manifest_update_scheduler.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





const { FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY, MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE, MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE } = config/* default */.Z;
/**
 * Refresh the Manifest at the right time.
 * @param {Object} manifestUpdateSchedulerArguments
 * @returns {Observable}
 */
function manifestUpdateScheduler({ initialManifest, manifestFetcher, minimumManifestUpdateInterval, scheduleRefresh$, }) {
    /**
     * Fetch and parse the manifest from the URL given.
     * Throttled to avoid doing multiple simultaneous requests.
     */
    const fetchManifest = throttle((manifestURL, options) => manifestFetcher.fetch(manifestURL).pipe((0,mergeMap/* mergeMap */.zg)((response) => response.type === "warning" ?
        (0,of.of)(response) : // bubble-up warnings
        response.parse(options)), (0,share/* share */.B)()));
    // The Manifest always keeps the same Manifest
    const { manifest } = initialManifest;
    /** Number of consecutive times the parsing has been done in `unsafeMode`. */
    let consecutiveUnsafeMode = 0;
    function handleManifestRefresh$(manifestInfos) {
        const { sendingTime, parsingTime, updatingTime } = manifestInfos;
        /**
         * Total time taken to fully update the last Manifest.
         * Note: this time also includes possible requests done by the parsers.
         */
        const totalUpdateTime = parsingTime !== undefined ?
            parsingTime + (updatingTime !== null && updatingTime !== void 0 ? updatingTime : 0) :
            undefined;
        // Only perform parsing in `unsafeMode` when the last full parsing took a
        // lot of time and do not go higher than the maximum consecutive time.
        const unsafeModeEnabled = consecutiveUnsafeMode > 0 ?
            consecutiveUnsafeMode < MAX_CONSECUTIVE_MANIFEST_PARSING_IN_UNSAFE_MODE :
            totalUpdateTime !== undefined ?
                (totalUpdateTime >= MIN_MANIFEST_PARSING_TIME_TO_ENTER_UNSAFE_MODE) :
                false;
        const internalRefresh$ = scheduleRefresh$
            .pipe((0,mergeMap/* mergeMap */.zg)(({ completeRefresh, delay, canUseUnsafeMode }) => {
            const unsafeMode = canUseUnsafeMode && unsafeModeEnabled;
            return startManualRefreshTimer(delay !== null && delay !== void 0 ? delay : 0, minimumManifestUpdateInterval, sendingTime)
                .pipe((0,mapTo/* mapTo */.h)({ completeRefresh, unsafeMode }));
        }));
        const timeSinceRequest = sendingTime === undefined ? 0 :
            performance.now() - sendingTime;
        const minInterval = Math.max(minimumManifestUpdateInterval - timeSinceRequest, 0);
        let autoRefresh$;
        if (manifest.lifetime === undefined || manifest.lifetime < 0) {
            autoRefresh$ = empty/* EMPTY */.E;
        }
        else {
            let autoRefreshInterval = manifest.lifetime * 1000 - timeSinceRequest;
            if (totalUpdateTime !== undefined) {
                if (manifest.lifetime < 3 && totalUpdateTime >= 100) {
                    const defaultDelay = (3 - manifest.lifetime) * 1000 + autoRefreshInterval;
                    const newInterval = Math.max(defaultDelay, Math.max(autoRefreshInterval, 0) + totalUpdateTime);
                    log/* default.info */.Z.info("MUS: Manifest update rythm is too frequent. Postponing next request.", autoRefreshInterval, newInterval);
                    autoRefreshInterval = newInterval;
                }
                else if (totalUpdateTime >= (manifest.lifetime * 1000) / 10) {
                    const newInterval = Math.max(autoRefreshInterval, 0) + totalUpdateTime;
                    log/* default.info */.Z.info("MUS: Manifest took too long to parse. Postponing next request", autoRefreshInterval, newInterval);
                    autoRefreshInterval = newInterval;
                }
            }
            autoRefresh$ = (0,timer/* timer */.H)(Math.max(autoRefreshInterval, minInterval))
                .pipe((0,mapTo/* mapTo */.h)({ completeRefresh: false, unsafeMode: unsafeModeEnabled }));
        }
        const expired$ = manifest.expired === null ?
            empty/* EMPTY */.E :
            (0,timer/* timer */.H)(minInterval)
                .pipe((0,mergeMapTo/* mergeMapTo */.j)((0,from/* from */.D)(manifest.expired)), (0,mapTo/* mapTo */.h)({ completeRefresh: true, unsafeMode: unsafeModeEnabled }));
        // Emit when the manifest should be refreshed. Either when:
        //   - A Stream asks for it to be refreshed
        //   - its lifetime expired.
        return (0,merge/* merge */.T)(autoRefresh$, internalRefresh$, expired$).pipe((0,take/* take */.q)(1), (0,mergeMap/* mergeMap */.zg)(({ completeRefresh, unsafeMode }) => refreshManifest({ completeRefresh,
            unsafeMode })), (0,mergeMap/* mergeMap */.zg)(evt => {
            if (evt.type === "warning") {
                return (0,of.of)(evt);
            }
            return handleManifestRefresh$(evt);
        }));
    }
    return (0,defer/* defer */.P)(() => handleManifestRefresh$(initialManifest));
    /**
     * Refresh the Manifest.
     * Perform a full update if a partial update failed.
     * @param {boolean} completeRefresh
     * @returns {Observable}
     */
    function refreshManifest({ completeRefresh, unsafeMode }) {
        const manifestUpdateUrl = manifest.updateUrl;
        const fullRefresh = completeRefresh || manifestUpdateUrl === undefined;
        const refreshURL = fullRefresh ? manifest.getUrl() :
            manifestUpdateUrl;
        const externalClockOffset = manifest.clockOffset;
        if (unsafeMode) {
            consecutiveUnsafeMode += 1;
            log/* default.info */.Z.info("Init: Refreshing the Manifest in \"unsafeMode\" for the " +
                String(consecutiveUnsafeMode) + " consecutive time.");
        }
        else if (consecutiveUnsafeMode > 0) {
            log/* default.info */.Z.info("Init: Not parsing the Manifest in \"unsafeMode\" anymore after " +
                String(consecutiveUnsafeMode) + " consecutive times.");
            consecutiveUnsafeMode = 0;
        }
        return fetchManifest(refreshURL, { externalClockOffset,
            previousManifest: manifest,
            unsafeMode })
            .pipe((0,mergeMap/* mergeMap */.zg)((value) => {
            if (value.type === "warning") {
                return (0,of.of)(value);
            }
            const { manifest: newManifest, sendingTime: newSendingTime, receivedTime, parsingTime } = value;
            const updateTimeStart = performance.now();
            if (fullRefresh) {
                manifest.replace(newManifest);
            }
            else {
                try {
                    manifest.update(newManifest);
                }
                catch (e) {
                    const message = e instanceof Error ? e.message :
                        "unknown error";
                    log/* default.warn */.Z.warn(`MUS: Attempt to update Manifest failed: ${message}`, "Re-downloading the Manifest fully");
                    return startManualRefreshTimer(FAILED_PARTIAL_UPDATE_MANIFEST_REFRESH_DELAY, minimumManifestUpdateInterval, newSendingTime)
                        .pipe((0,mergeMap/* mergeMap */.zg)(() => refreshManifest({ completeRefresh: true, unsafeMode: false })));
                }
            }
            return (0,of.of)({ type: "parsed", manifest,
                sendingTime: newSendingTime,
                receivedTime,
                parsingTime,
                updatingTime: performance.now() - updateTimeStart });
        }));
    }
}
/**
 * Launch a timer Observable which will emit when it is time to refresh the
 * Manifest.
 * The timer's delay is calculated from:
 *   - a target delay (`wantedDelay`), which is the minimum time we want to wait
 *     in the best scenario
 *   - the minimum set possible interval between manifest updates
 *     (`minimumManifestUpdateInterval`)
 *   - the time at which was done the last Manifest refresh
 *     (`lastManifestRequestTime`)
 * @param {number} wantedDelay
 * @param {number} minimumManifestUpdateInterval
 * @param {number|undefined} lastManifestRequestTime
 * @returns {Observable}
 */
function startManualRefreshTimer(wantedDelay, minimumManifestUpdateInterval, lastManifestRequestTime) {
    return (0,defer/* defer */.P)(() => {
        // The value allows to set a delay relatively to the last Manifest refresh
        // (to avoid asking for it too often).
        const timeSinceLastRefresh = lastManifestRequestTime === undefined ?
            0 :
            performance.now() - lastManifestRequestTime;
        const _minInterval = Math.max(minimumManifestUpdateInterval - timeSinceLastRefresh, 0);
        return (0,timer/* timer */.H)(Math.max(wantedDelay - timeSinceLastRefresh, _minInterval));
    });
}

// EXTERNAL MODULE: ./src/core/init/throw_on_media_error.ts
var throw_on_media_error = __webpack_require__(41654);
;// CONCATENATED MODULE: ./src/core/init/initialize_media_source.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


















const { OUT_OF_SYNC_MANIFEST_REFRESH_DELAY } = config/* default */.Z;
/**
 * Begin content playback.
 *
 * Returns an Observable emitting notifications about the content lifecycle.
 * On subscription, it will perform every necessary tasks so the content can
 * play. Among them:
 *
 *   - Creates a MediaSource on the given `mediaElement` and attach to it the
 *     necessary SourceBuffer instances.
 *
 *   - download the content's Manifest and handle its refresh logic
 *
 *   - Perform EME management if needed
 *
 *   - ask for the choice of the wanted Adaptation through events (e.g. to
 *     choose a language)
 *
 *   - requests and push the right segments (according to the Adaptation choice,
 *     the current position, the network conditions etc.)
 *
 * This Observable will throw in the case where a fatal error (i.e. which has
 * stopped content playback) is encountered, with the corresponding error as a
 * payload.
 *
 * This Observable will never complete, it will always run until it is
 * unsubscribed from.
 * Unsubscription will stop playback and reset the corresponding state.
 *
 * @param {Object} args
 * @returns {Observable}
 */
function InitializeOnMediaSource({ adaptiveOptions, autoPlay, bufferOptions, clock$, keySystems, lowLatencyMode, manifest$, manifestFetcher, mediaElement, minimumManifestUpdateInterval, segmentFetcherCreator, setCurrentTime, speed$, startAt, textTrackOptions }) {
    /** Choose the right "Representation" for a given "Adaptation". */
    const abrManager = new abr(adaptiveOptions);
    /**
     * Create and open a new MediaSource object on the given media element on
     * subscription.
     * Multiple concurrent subscriptions on this Observable will obtain the same
     * created MediaSource.
     * The MediaSource will be closed when subscriptions are down to 0.
     */
    const openMediaSource$ = openMediaSource(mediaElement).pipe((0,shareReplay/* shareReplay */.d)({ refCount: true }));
    /** Send content protection data to the `EMEManager`. */
    const protectedSegments$ = new Subject/* Subject */.xQ();
    /** Create `EMEManager`, an observable which will handle content DRM. */
    const emeManager$ = (0,create_eme_manager/* default */.Z)(mediaElement, keySystems, protectedSegments$).pipe(
    // Because multiple Observables here depend on this Observable as a source,
    // we prefer deferring Subscription until those Observables are themselves
    // all subscribed to.
    // This is needed because `emeManager$` might send events synchronously
    // on subscription. In that case, it might communicate those events directly
    // after the first Subscription is done, making the next subscription miss
    // out on those events, even if that second subscription is done
    // synchronously after the first one.
    // By calling `deferSubscriptions`, we ensure that subscription to
    // `emeManager$` effectively starts after a very short delay, thus
    // ensuring that no such race condition can occur.
    (0,defer_subscriptions/* default */.Z)(), (0,share/* share */.B)());
    /**
     * Translate errors coming from the media element into RxPlayer errors
     * through a throwing Observable.
     */
    const mediaError$ = (0,throw_on_media_error/* default */.Z)(mediaElement);
    /**
     * Wait for the MediaKeys to have been created before opening the MediaSource,
     * after that second step is done, ask the EMEManager to attach the MediaKeys.
     * Steps are done in that specific order to avoid compatibility issues.
     *
     * This Observable will emit when ready both the MediaSource and useful
     * DRM-specific information.
     */
    const prepareMediaSource$ = emeManager$.pipe(mergeScan((acc, evt) => {
        switch (evt.type) {
            case "eme-disabled":
            case "attached-media-keys":
                return (0,of.of)({ isEmeReady: true,
                    drmSystemId: acc.drmSystemId });
            case "created-media-keys":
                const drmSystemId = evt.value.initializationDataSystemId;
                return openMediaSource$.pipe((0,mergeMap/* mergeMap */.zg)(() => {
                    // Now that the MediaSource has been opened and linked to the media
                    // element we can attach the MediaKeys instance to the latter.
                    evt.value.attachMediaKeys$.next();
                    // If the `disableMediaKeysAttachmentLock` option has been set to
                    // `true`, we should not wait until the MediaKeys instance has been
                    // attached to start loading the content.
                    const shouldDisableLock = evt.value.options
                        .disableMediaKeysAttachmentLock === true;
                    return shouldDisableLock ? (0,of.of)({ isEmeReady: true,
                        drmSystemId }) :
                        empty/* EMPTY */.E;
                }), (0,startWith/* startWith */.O)({ isEmeReady: false, drmSystemId }));
            default:
                return empty/* EMPTY */.E;
        }
    }, { isEmeReady: false, drmSystemId: undefined }), (0,filter/* filter */.h)((emitted) => emitted.isEmeReady), (0,take/* take */.q)(1), exhaustMap(({ drmSystemId }) => openMediaSource$
        .pipe((0,map/* map */.U)((mediaSource) => ({ mediaSource, drmSystemId })))));
    /** Load and play the content asked. */
    const loadContent$ = (0,combineLatest/* combineLatest */.aj)([manifest$,
        prepareMediaSource$]).pipe((0,mergeMap/* mergeMap */.zg)(([manifestEvt, mediaSourceInfo]) => {
        if (manifestEvt.type === "warning") {
            return (0,of.of)(manifestEvt);
        }
        const { manifest } = manifestEvt;
        const { mediaSource: initialMediaSource, drmSystemId } = mediaSourceInfo;
        log/* default.debug */.Z.debug("Init: Calculating initial time");
        const initialTime = getInitialTime(manifest, lowLatencyMode, startAt);
        log/* default.debug */.Z.debug("Init: Initial time calculated:", initialTime);
        const mediaSourceLoader = createMediaSourceLoader({
            abrManager,
            bufferOptions: (0,object_assign/* default */.Z)({ textTrackOptions, drmSystemId }, bufferOptions),
            clock$,
            manifest,
            mediaElement,
            segmentFetcherCreator,
            speed$,
            setCurrentTime,
        });
        // handle initial load and reloads
        const recursiveLoad$ = recursivelyLoadOnMediaSource(initialMediaSource, initialTime, autoPlay);
        // Emit when we want to manually update the manifest.
        const scheduleRefresh$ = new Subject/* Subject */.xQ();
        const manifestUpdate$ = manifestUpdateScheduler({ initialManifest: manifestEvt,
            manifestFetcher,
            minimumManifestUpdateInterval,
            scheduleRefresh$ });
        const manifestEvents$ = (0,merge/* merge */.T)((0,event_emitter/* fromEvent */.R)(manifest, "manifestUpdate")
            .pipe((0,mapTo/* mapTo */.h)(events_generators/* default.manifestUpdate */.Z.manifestUpdate())), (0,event_emitter/* fromEvent */.R)(manifest, "decipherabilityUpdate")
            .pipe((0,map/* map */.U)(events_generators/* default.decipherabilityUpdate */.Z.decipherabilityUpdate)));
        const setUndecipherableRepresentations$ = emeManager$.pipe((0,tap/* tap */.b)((evt) => {
            if (evt.type === "keys-update") {
                manifest.updateDeciperabilitiesBasedOnKeyIds(evt.value);
            }
            else if (evt.type === "blacklist-protection-data") {
                log/* default.info */.Z.info("Init: blacklisting Representations based on protection data.");
                manifest.addUndecipherableProtectionData(evt.value);
            }
        }), (0,ignoreElements/* ignoreElements */.l)());
        return (0,merge/* merge */.T)(manifestEvents$, manifestUpdate$, setUndecipherableRepresentations$, recursiveLoad$)
            .pipe((0,startWith/* startWith */.O)(events_generators/* default.manifestReady */.Z.manifestReady(manifest)), finalize(() => { scheduleRefresh$.complete(); }));
        /**
         * Load the content defined by the Manifest in the mediaSource given at the
         * given position and playing status.
         * This function recursively re-call itself when a MediaSource reload is
         * wanted.
         * @param {MediaSource} mediaSource
         * @param {number} startingPos
         * @param {boolean} shouldPlay
         * @returns {Observable}
         */
        function recursivelyLoadOnMediaSource(mediaSource, startingPos, shouldPlay) {
            const reloadMediaSource$ = new Subject/* Subject */.xQ();
            const mediaSourceLoader$ = mediaSourceLoader(mediaSource, startingPos, shouldPlay)
                .pipe((0,filter_map/* default */.Z)((evt) => {
                switch (evt.type) {
                    case "needs-manifest-refresh":
                        scheduleRefresh$.next({ completeRefresh: false,
                            canUseUnsafeMode: true });
                        return null;
                    case "manifest-might-be-out-of-sync":
                        scheduleRefresh$.next({
                            completeRefresh: true,
                            canUseUnsafeMode: false,
                            delay: OUT_OF_SYNC_MANIFEST_REFRESH_DELAY,
                        });
                        return null;
                    case "needs-media-source-reload":
                        reloadMediaSource$.next(evt.value);
                        return null;
                    case "needs-decipherability-flush":
                        const keySystem = getCurrentKeySystem(mediaElement);
                        if (shouldReloadMediaSourceOnDecipherabilityUpdate(keySystem)) {
                            reloadMediaSource$.next(evt.value);
                            return null;
                        }
                        // simple seek close to the current position
                        // to flush the buffers
                        const { position } = evt.value;
                        if (position + 0.001 < evt.value.duration) {
                            setCurrentTime(mediaElement.currentTime + 0.001);
                        }
                        else {
                            setCurrentTime(position);
                        }
                        return null;
                    case "encryption-data-encountered":
                        protectedSegments$.next(evt.value);
                        return null;
                }
                return evt;
            }, null));
            const currentLoad$ = mediaSourceLoader$.pipe((0,takeUntil/* takeUntil */.R)(reloadMediaSource$));
            const handleReloads$ = reloadMediaSource$.pipe((0,switchMap/* switchMap */.w)((reloadOrder) => {
                return openMediaSource(mediaElement).pipe((0,mergeMap/* mergeMap */.zg)(newMS => recursivelyLoadOnMediaSource(newMS, reloadOrder.position, reloadOrder.autoPlay)), (0,startWith/* startWith */.O)(events_generators/* default.reloadingMediaSource */.Z.reloadingMediaSource()));
            }));
            return (0,merge/* merge */.T)(handleReloads$, currentLoad$);
        }
    }));
    return (0,merge/* merge */.T)(loadContent$, mediaError$, emeManager$);
}

;// CONCATENATED MODULE: ./src/core/init/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/* harmony default export */ const init = (InitializeOnMediaSource);

// EXTERNAL MODULE: ./node_modules/rxjs/_esm5/internal/operators/refCount.js
var refCount = __webpack_require__(80950);
;// CONCATENATED MODULE: ./src/core/api/clock.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file defines a global clock for the RxPlayer.
 *
 * Each clock tick also pass information about the current state of the
 * media element to sub-parts of the player.
 */






const { SAMPLING_INTERVAL_MEDIASOURCE, SAMPLING_INTERVAL_LOW_LATENCY, SAMPLING_INTERVAL_NO_MEDIASOURCE, RESUME_GAP_AFTER_SEEKING, RESUME_GAP_AFTER_NOT_ENOUGH_DATA, RESUME_GAP_AFTER_BUFFERING, STALL_GAP } = config/* default */.Z;
/**
 * HTMLMediaElement Events for which timings are calculated and emitted.
 * @type {Array.<string>}
 */
const SCANNED_MEDIA_ELEMENTS_EVENTS = ["canplay",
    "play",
    "seeking",
    "seeked",
    "loadedmetadata",
    "ratechange"];
/**
 * Returns the amount of time in seconds the buffer should have ahead of the
 * current position before resuming playback. Based on the infos of the stall.
 * Waiting time differs between a "seeking" stall and a buffering stall.
 * @param {Object|null} stalled
 * @param {Boolean} lowLatencyMode
 * @returns {Number}
 */
function getResumeGap(stalled, lowLatencyMode) {
    if (stalled === null) {
        return 0;
    }
    const suffix = lowLatencyMode ? "LOW_LATENCY" :
        "DEFAULT";
    switch (stalled.reason) {
        case "seeking":
        case "internal-seek":
            return RESUME_GAP_AFTER_SEEKING[suffix];
        case "not-ready":
            return RESUME_GAP_AFTER_NOT_ENOUGH_DATA[suffix];
        case "buffering":
            return RESUME_GAP_AFTER_BUFFERING[suffix];
    }
}
/**
 * @param {Object} currentRange
 * @param {Number} duration
 * @param {Boolean} lowLatencyMode
 * @returns {Boolean}
 */
function hasLoadedUntilTheEnd(currentRange, duration, lowLatencyMode) {
    const suffix = lowLatencyMode ? "LOW_LATENCY" :
        "DEFAULT";
    return currentRange !== null &&
        (duration - currentRange.end) <= STALL_GAP[suffix];
}
/**
 * Generate a basic timings object from the media element and the eventName
 * which triggered the request.
 * @param {HTMLMediaElement} mediaElement
 * @param {string} event
 * @returns {Object}
 */
function getMediaInfos(mediaElement, event) {
    const { buffered, currentTime, duration, ended, paused, playbackRate, readyState, seeking } = mediaElement;
    const currentRange = (0,ranges/* getRange */.rx)(buffered, currentTime);
    return { bufferGap: currentRange !== null ? currentRange.end - currentTime :
            // TODO null/0 would probably be
            // more appropriate
            Infinity,
        buffered,
        currentRange,
        position: currentTime,
        duration,
        ended,
        paused,
        playbackRate,
        readyState,
        seeking,
        event };
}
/**
 * Infer stalled status of the media based on:
 *   - the return of the function getMediaInfos
 *   - the previous timings object.
 *
 * @param {Object} prevTimings - Previous timings object. See function to know
 * the different properties needed.
 * @param {Object} currentTimings - Current timings object. This does not need
 * to have every single infos, see function to know which properties are needed.
 * @param {Object} options
 * @returns {Object|null}
 */
function getStalledStatus(prevTimings, currentTimings, { withMediaSource, lowLatencyMode }) {
    const { event: currentEvt, position: currentTime, bufferGap, currentRange, duration, paused, readyState, ended } = currentTimings;
    const { stalled: prevStalled, event: prevEvt, position: prevTime } = prevTimings;
    const fullyLoaded = hasLoadedUntilTheEnd(currentRange, duration, lowLatencyMode);
    const canStall = (readyState >= 1 &&
        currentEvt !== "loadedmetadata" &&
        prevStalled === null &&
        !(fullyLoaded || ended));
    let stalledPosition = null;
    let shouldStall;
    let shouldUnstall;
    const stallGap = lowLatencyMode ? STALL_GAP.LOW_LATENCY :
        STALL_GAP.DEFAULT;
    if (withMediaSource) {
        if (canStall) {
            if (bufferGap <= stallGap) {
                shouldStall = true;
                stalledPosition = currentTime + bufferGap;
            }
            else if (bufferGap === Infinity) {
                shouldStall = true;
                stalledPosition = currentTime;
            }
            else if (readyState === 1) {
                shouldStall = true;
            }
        }
        else if (prevStalled !== null) {
            const resumeGap = getResumeGap(prevStalled, lowLatencyMode);
            if (shouldStall !== true && prevStalled !== null && readyState > 1 &&
                (fullyLoaded || ended || (bufferGap < Infinity && bufferGap > resumeGap))) {
                shouldUnstall = true;
            }
            else if (bufferGap === Infinity || bufferGap <= resumeGap) {
                stalledPosition = bufferGap === Infinity ? currentTime :
                    currentTime + bufferGap;
            }
        }
    }
    // when using a direct file, the media will stall and unstall on its
    // own, so we only try to detect when the media timestamp has not changed
    // between two consecutive timeupdates
    else {
        if (canStall &&
            (!paused && currentEvt === "timeupdate" &&
                prevEvt === "timeupdate" && currentTime === prevTime ||
                currentEvt === "seeking" && bufferGap === Infinity)) {
            shouldStall = true;
        }
        else if (prevStalled !== null &&
            (currentEvt !== "seeking" && currentTime !== prevTime ||
                currentEvt === "canplay" ||
                bufferGap < Infinity &&
                    (bufferGap > getResumeGap(prevStalled, lowLatencyMode) ||
                        fullyLoaded || ended))) {
            shouldUnstall = true;
        }
    }
    if (shouldUnstall === true) {
        return null;
    }
    else if (shouldStall === true || prevStalled !== null) {
        let reason;
        if (currentEvt === "seeking" ||
            prevStalled !== null && prevStalled.reason === "seeking") {
            reason = "seeking";
        }
        else if (currentTimings.seeking &&
            ((currentEvt === "internal-seeking") ||
                (prevStalled !== null && prevStalled.reason === "internal-seek"))) {
            reason = "internal-seek";
        }
        else if (currentTimings.seeking) {
            reason = "seeking";
        }
        else if (readyState === 1) {
            reason = "not-ready";
        }
        else {
            reason = "buffering";
        }
        if (prevStalled !== null && prevStalled.reason === reason) {
            return { reason: prevStalled.reason,
                timestamp: prevStalled.timestamp,
                position: stalledPosition };
        }
        return { reason,
            timestamp: performance.now(),
            position: stalledPosition };
    }
    return null;
}
/**
 * Timings observable.
 *
 * This Observable samples snapshots of player's current state:
 *   * time position
 *   * playback rate
 *   * current buffered range
 *   * gap with current buffered range ending
 *   * media duration
 *
 * In addition to sampling, this Observable also reacts to "seeking" and "play"
 * events.
 *
 * Observable is shared for performance reason: reduces the number of event
 * listeners and intervals/timeouts but also limit access to the media element
 * properties and gap calculations.
 *
 * The sampling is manual instead of based on "timeupdate" to reduce the
 * number of events.
 * @param {HTMLMediaElement} mediaElement
 * @param {Object} options
 * @returns {Observable}
 */
function createClock(mediaElement, options) {
    // Allow us to identify seek performed internally by the player.
    let internalSeekingComingCounter = 0;
    function setCurrentTime(time) {
        mediaElement.currentTime = time;
        internalSeekingComingCounter += 1;
    }
    const clock$ = (0,defer/* defer */.P)(() => {
        let lastTimings = (0,object_assign/* default */.Z)(getMediaInfos(mediaElement, "init"), { stalled: null, getCurrentTime: () => mediaElement.currentTime });
        function getCurrentClockTick(event) {
            let tmpEvt = event;
            if (tmpEvt === "seeking" && internalSeekingComingCounter > 0) {
                tmpEvt = "internal-seeking";
                internalSeekingComingCounter -= 1;
            }
            const mediaTimings = getMediaInfos(mediaElement, tmpEvt);
            const stalledState = getStalledStatus(lastTimings, mediaTimings, options);
            const timings = (0,object_assign/* default */.Z)({}, { stalled: stalledState,
                getCurrentTime: () => mediaElement.currentTime }, mediaTimings);
            log/* default.debug */.Z.debug("API: current media element state", timings);
            return timings;
        }
        const eventObs = SCANNED_MEDIA_ELEMENTS_EVENTS.map((eventName) => (0,fromEvent/* fromEvent */.R)(mediaElement, eventName)
            .pipe((0,mapTo/* mapTo */.h)(eventName)));
        const interval = options.lowLatencyMode ? SAMPLING_INTERVAL_LOW_LATENCY :
            options.withMediaSource ? SAMPLING_INTERVAL_MEDIASOURCE :
                SAMPLING_INTERVAL_NO_MEDIASOURCE;
        const interval$ = (0,observable_interval/* interval */.F)(interval)
            .pipe((0,mapTo/* mapTo */.h)("timeupdate"));
        return (0,merge/* merge */.T)(interval$, ...eventObs)
            .pipe((0,map/* map */.U)((event) => {
            lastTimings = getCurrentClockTick(event);
            if (log/* default.getLevel */.Z.getLevel() === "DEBUG") {
                log/* default.debug */.Z.debug("API: current playback timeline:\n" +
                    prettyPrintBuffered(lastTimings.buffered, lastTimings.position), `\n${event}`);
            }
            return lastTimings;
        }), (0,startWith/* startWith */.O)(lastTimings));
    }).pipe((0,multicast/* multicast */.O)(() => new ReplaySubject/* ReplaySubject */.t(1)), // Always emit the last
    (0,refCount/* refCount */.x)());
    return { clock$, setCurrentTime };
}
/**
 * Pretty print a TimeRanges Object, to see the current content of it in a
 * one-liner string.
 *
 * @example
 * This function is called by giving it directly the TimeRanges, such as:
 * ```js
 * prettyPrintBuffered(document.getElementsByTagName("video")[0].buffered);
 * ```
 *
 * Let's consider this possible return:
 *
 * ```
 * 0.00|==29.95==|29.95 ~30.05~ 60.00|==29.86==|89.86
 *          ^14
 * ```
 * This means that our video element has 29.95 seconds of buffer between 0 and
 * 29.95 seconds.
 * Then 30.05 seconds where no buffer is found.
 * Then 29.86 seconds of buffer between 60.00 and 89.86 seconds.
 *
 * A caret on the second line indicates the current time we're at.
 * The number coming after it is the current time.
 * @param {TimeRanges} buffered
 * @param {number} currentTime
 * @returns {string}
 */
function prettyPrintBuffered(buffered, currentTime) {
    let str = "";
    let currentTimeStr = "";
    for (let i = 0; i < buffered.length; i++) {
        const start = buffered.start(i);
        const end = buffered.end(i);
        const fixedStart = start.toFixed(2);
        const fixedEnd = end.toFixed(2);
        const fixedDuration = (end - start).toFixed(2);
        const newIntervalStr = `${fixedStart}|==${fixedDuration}==|${fixedEnd}`;
        str += newIntervalStr;
        if (currentTimeStr.length === 0 && end > currentTime) {
            const padBefore = str.length - Math.floor(newIntervalStr.length / 2);
            currentTimeStr = " ".repeat(padBefore) + `^${currentTime}`;
        }
        if (i < buffered.length - 1) {
            const nextStart = buffered.start(i + 1);
            const fixedDiff = (nextStart - end).toFixed(2);
            const holeStr = ` ~${fixedDiff}~ `;
            str += holeStr;
            if (currentTimeStr.length === 0 && currentTime < nextStart) {
                const padBefore = str.length - Math.floor(holeStr.length / 2);
                currentTimeStr = " ".repeat(padBefore) + `^${currentTime}`;
            }
        }
    }
    if (currentTimeStr.length === 0) {
        currentTimeStr = " ".repeat(str.length) + `^${currentTime}`;
    }
    return str + "\n" + currentTimeStr;
}
/* harmony default export */ const clock = (createClock);

;// CONCATENATED MODULE: ./src/core/api/emit_seek_events.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Returns Observable which will emit:
 *   - `"seeking"` when we are seeking in the given mediaElement
 *   - `"seeked"` when a seek is considered as finished by the given clock$
 *     Observable.
 * @param {HTMLMediaElement} mediaElement
 * @param {Observable} clock$
 * @returns {Observable}
 */
function emitSeekEvents(mediaElement, clock$) {
    return (0,defer/* defer */.P)(() => {
        if (mediaElement === null) {
            return empty/* EMPTY */.E;
        }
        const isSeeking$ = clock$.pipe((0,filter/* filter */.h)((tick) => tick.event === "seeking"), (0,mapTo/* mapTo */.h)("seeking"));
        const hasSeeked$ = isSeeking$.pipe((0,switchMapTo/* switchMapTo */.c)(clock$.pipe((0,filter/* filter */.h)((tick) => tick.event === "seeked"), (0,mapTo/* mapTo */.h)("seeked"), (0,take/* take */.q)(1))));
        const seekingEvents$ = (0,merge/* merge */.T)(isSeeking$, hasSeeked$);
        return mediaElement.seeking ? seekingEvents$.pipe((0,startWith/* startWith */.O)("seeking")) :
            seekingEvents$;
    });
}

;// CONCATENATED MODULE: ./src/core/api/get_player_state.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { FORCED_ENDED_THRESHOLD } = config/* default */.Z;
/** Player state dictionnary. */
const PLAYER_STATES = { STOPPED: "STOPPED",
    LOADED: "LOADED",
    LOADING: "LOADING",
    PLAYING: "PLAYING",
    PAUSED: "PAUSED",
    ENDED: "ENDED",
    BUFFERING: "BUFFERING",
    SEEKING: "SEEKING",
    RELOADING: "RELOADING" };
/**
 * Get state string for a _loaded_ content.
 * @param {HTMLMediaElement} mediaElement
 * @param {boolean} isPlaying - false when the player is paused. true otherwise.
 * @param {Object} stalledStatus - Current stalled state:
 *   - null when not stalled
 *   - an object with a description of the situation if stalled.
 * @returns {string}
 */
function getLoadedContentState(mediaElement, isPlaying, stalledStatus) {
    if (mediaElement.ended) {
        return PLAYER_STATES.ENDED;
    }
    if (stalledStatus !== null) {
        // On some old browsers (e.g. Chrome 54), the browser does not
        // emit an 'ended' event in some conditions. Detect if we
        // reached the end by comparing the current position and the
        // duration instead.
        const gapBetweenDurationAndCurrentTime = Math.abs(mediaElement.duration -
            mediaElement.currentTime);
        if (FORCED_ENDED_THRESHOLD != null &&
            gapBetweenDurationAndCurrentTime < FORCED_ENDED_THRESHOLD) {
            return PLAYER_STATES.ENDED;
        }
        return stalledStatus.reason === "seeking" ? PLAYER_STATES.SEEKING :
            PLAYER_STATES.BUFFERING;
    }
    return isPlaying ? PLAYER_STATES.PLAYING :
        PLAYER_STATES.PAUSED;
}

// EXTERNAL MODULE: ./src/utils/languages/normalize.ts + 2 modules
var normalize = __webpack_require__(11782);
;// CONCATENATED MODULE: ./src/core/api/option_utils.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file exports various helpers to parse options given to various APIs,
 * throw if something is wrong, and return a normalized option object.
 */







const { DEFAULT_AUDIO_TRACK_SWITCHING_MODE, DEFAULT_AUTO_PLAY, DEFAULT_CODEC_SWITCHING_BEHAVIOR, DEFAULT_ENABLE_FAST_SWITCHING, DEFAULT_INITIAL_BITRATES, DEFAULT_LIMIT_VIDEO_WIDTH, DEFAULT_MANUAL_BITRATE_SWITCHING_MODE, DEFAULT_MIN_BITRATES, DEFAULT_MAX_BITRATES, DEFAULT_MAX_BUFFER_AHEAD, DEFAULT_MAX_BUFFER_BEHIND, DEFAULT_SHOW_NATIVE_SUBTITLE, DEFAULT_STOP_AT_END, DEFAULT_TEXT_TRACK_MODE, DEFAULT_THROTTLE_WHEN_HIDDEN, DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN, DEFAULT_WANTED_BUFFER_AHEAD } = config/* default */.Z;
/**
 * Parse options given to the API constructor and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 * @param {Object|undefined} options
 * @returns {Object}
 */
function parseConstructorOptions(options) {
    let maxBufferAhead;
    let maxBufferBehind;
    let wantedBufferAhead;
    let throttleWhenHidden;
    let throttleVideoBitrateWhenHidden;
    let preferredAudioTracks;
    let preferredTextTracks;
    let preferredVideoTracks;
    let videoElement;
    let initialVideoBitrate;
    let initialAudioBitrate;
    let minAudioBitrate;
    let minVideoBitrate;
    let maxAudioBitrate;
    let maxVideoBitrate;
    if ((0,is_null_or_undefined/* default */.Z)(options.maxBufferAhead)) {
        maxBufferAhead = DEFAULT_MAX_BUFFER_AHEAD;
    }
    else {
        maxBufferAhead = Number(options.maxBufferAhead);
        if (isNaN(maxBufferAhead)) {
            throw new Error("Invalid maxBufferAhead parameter. Should be a number.");
        }
    }
    if ((0,is_null_or_undefined/* default */.Z)(options.maxBufferBehind)) {
        maxBufferBehind = DEFAULT_MAX_BUFFER_BEHIND;
    }
    else {
        maxBufferBehind = Number(options.maxBufferBehind);
        if (isNaN(maxBufferBehind)) {
            throw new Error("Invalid maxBufferBehind parameter. Should be a number.");
        }
    }
    if ((0,is_null_or_undefined/* default */.Z)(options.wantedBufferAhead)) {
        wantedBufferAhead = DEFAULT_WANTED_BUFFER_AHEAD;
    }
    else {
        wantedBufferAhead = Number(options.wantedBufferAhead);
        if (isNaN(wantedBufferAhead)) {
            /* eslint-disable max-len */
            throw new Error("Invalid wantedBufferAhead parameter. Should be a number.");
            /* eslint-enable max-len */
        }
    }
    const limitVideoWidth = (0,is_null_or_undefined/* default */.Z)(options.limitVideoWidth) ?
        DEFAULT_LIMIT_VIDEO_WIDTH :
        !!options.limitVideoWidth;
    if (!(0,is_null_or_undefined/* default */.Z)(options.throttleWhenHidden)) {
        (0,warn_once/* default */.Z)("`throttleWhenHidden` API is deprecated. Consider using " +
            "`throttleVideoBitrateWhenHidden` instead.");
        throttleWhenHidden = !!options.throttleWhenHidden;
    }
    else {
        throttleWhenHidden = DEFAULT_THROTTLE_WHEN_HIDDEN;
    }
    // `throttleWhenHidden` and `throttleVideoBitrateWhenHidden` can be in conflict
    // Do not activate the latter if the former is
    if (throttleWhenHidden) {
        throttleVideoBitrateWhenHidden = false;
    }
    else {
        throttleVideoBitrateWhenHidden =
            (0,is_null_or_undefined/* default */.Z)(options.throttleVideoBitrateWhenHidden) ?
                DEFAULT_THROTTLE_VIDEO_BITRATE_WHEN_HIDDEN :
                !!options.throttleVideoBitrateWhenHidden;
    }
    if (options.preferredTextTracks !== undefined) {
        if (!Array.isArray(options.preferredTextTracks)) {
            (0,warn_once/* default */.Z)("Invalid `preferredTextTracks` option, it should be an Array");
            preferredTextTracks = [];
        }
        else {
            preferredTextTracks = options.preferredTextTracks;
        }
    }
    else {
        preferredTextTracks = [];
    }
    if (options.preferredAudioTracks !== undefined) {
        if (!Array.isArray(options.preferredAudioTracks)) {
            (0,warn_once/* default */.Z)("Invalid `preferredAudioTracks` option, it should be an Array");
            preferredAudioTracks = [];
        }
        else {
            preferredAudioTracks = options.preferredAudioTracks;
        }
    }
    else {
        preferredAudioTracks = [];
    }
    if (options.preferredVideoTracks !== undefined) {
        if (!Array.isArray(options.preferredVideoTracks)) {
            (0,warn_once/* default */.Z)("Invalid `preferredVideoTracks` option, it should be an Array");
            preferredVideoTracks = [];
        }
        else {
            preferredVideoTracks = options.preferredVideoTracks;
        }
    }
    else {
        preferredVideoTracks = [];
    }
    if ((0,is_null_or_undefined/* default */.Z)(options.videoElement)) {
        videoElement = document.createElement("video");
    }
    else if (options.videoElement instanceof HTMLMediaElement) {
        videoElement = options.videoElement;
    }
    else {
        /* eslint-disable max-len */
        throw new Error("Invalid videoElement parameter. Should be a HTMLMediaElement.");
        /* eslint-enable max-len */
    }
    if ((0,is_null_or_undefined/* default */.Z)(options.initialVideoBitrate)) {
        initialVideoBitrate = DEFAULT_INITIAL_BITRATES.video;
    }
    else {
        initialVideoBitrate = Number(options.initialVideoBitrate);
        if (isNaN(initialVideoBitrate)) {
            /* eslint-disable max-len */
            throw new Error("Invalid initialVideoBitrate parameter. Should be a number.");
            /* eslint-enable max-len */
        }
    }
    if ((0,is_null_or_undefined/* default */.Z)(options.initialAudioBitrate)) {
        initialAudioBitrate = DEFAULT_INITIAL_BITRATES.audio;
    }
    else {
        initialAudioBitrate = Number(options.initialAudioBitrate);
        if (isNaN(initialAudioBitrate)) {
            /* eslint-disable max-len */
            throw new Error("Invalid initialAudioBitrate parameter. Should be a number.");
            /* eslint-enable max-len */
        }
    }
    if ((0,is_null_or_undefined/* default */.Z)(options.minVideoBitrate)) {
        minVideoBitrate = DEFAULT_MIN_BITRATES.video;
    }
    else {
        minVideoBitrate = Number(options.minVideoBitrate);
        if (isNaN(minVideoBitrate)) {
            throw new Error("Invalid maxVideoBitrate parameter. Should be a number.");
        }
    }
    if ((0,is_null_or_undefined/* default */.Z)(options.minAudioBitrate)) {
        minAudioBitrate = DEFAULT_MIN_BITRATES.audio;
    }
    else {
        minAudioBitrate = Number(options.minAudioBitrate);
        if (isNaN(minAudioBitrate)) {
            throw new Error("Invalid minAudioBitrate parameter. Should be a number.");
        }
    }
    if ((0,is_null_or_undefined/* default */.Z)(options.maxVideoBitrate)) {
        maxVideoBitrate = DEFAULT_MAX_BITRATES.video;
    }
    else {
        maxVideoBitrate = Number(options.maxVideoBitrate);
        if (isNaN(maxVideoBitrate)) {
            throw new Error("Invalid maxVideoBitrate parameter. Should be a number.");
        }
        else if (minVideoBitrate > maxVideoBitrate) {
            throw new Error("Invalid maxVideoBitrate parameter. Its value, \"" +
                `${maxVideoBitrate}", is inferior to the set minVideoBitrate, "` +
                `${minVideoBitrate}"`);
        }
    }
    if ((0,is_null_or_undefined/* default */.Z)(options.maxAudioBitrate)) {
        maxAudioBitrate = DEFAULT_MAX_BITRATES.audio;
    }
    else {
        maxAudioBitrate = Number(options.maxAudioBitrate);
        if (isNaN(maxAudioBitrate)) {
            throw new Error("Invalid maxAudioBitrate parameter. Should be a number.");
        }
        else if (minAudioBitrate > maxAudioBitrate) {
            throw new Error("Invalid maxAudioBitrate parameter. Its value, \"" +
                `${maxAudioBitrate}", is inferior to the set minAudioBitrate, "` +
                `${minAudioBitrate}"`);
        }
    }
    const stopAtEnd = (0,is_null_or_undefined/* default */.Z)(options.stopAtEnd) ? DEFAULT_STOP_AT_END :
        !!options.stopAtEnd;
    return { maxBufferAhead,
        maxBufferBehind,
        limitVideoWidth,
        videoElement,
        wantedBufferAhead,
        throttleWhenHidden,
        throttleVideoBitrateWhenHidden,
        preferredAudioTracks,
        preferredTextTracks,
        preferredVideoTracks,
        initialAudioBitrate,
        initialVideoBitrate,
        minAudioBitrate,
        minVideoBitrate,
        maxAudioBitrate,
        maxVideoBitrate,
        stopAtEnd };
}
/**
 * Check the format of given reload options.
 * Throw if format in invalid.
 * @param {object | undefined} options
 */
function checkReloadOptions(options) {
    var _a, _b, _c, _d;
    if (options === null ||
        (typeof options !== "object" && options !== undefined)) {
        throw new Error("API: reload - Invalid options format.");
    }
    if ((options === null || options === void 0 ? void 0 : options.reloadAt) === null ||
        (typeof (options === null || options === void 0 ? void 0 : options.reloadAt) !== "object" && (options === null || options === void 0 ? void 0 : options.reloadAt) !== undefined)) {
        throw new Error("API: reload - Invalid 'reloadAt' option format.");
    }
    if (typeof ((_a = options === null || options === void 0 ? void 0 : options.reloadAt) === null || _a === void 0 ? void 0 : _a.position) !== "number" &&
        ((_b = options === null || options === void 0 ? void 0 : options.reloadAt) === null || _b === void 0 ? void 0 : _b.position) !== undefined) {
        throw new Error("API: reload - Invalid 'reloadAt.position' option format.");
    }
    if (typeof ((_c = options === null || options === void 0 ? void 0 : options.reloadAt) === null || _c === void 0 ? void 0 : _c.relative) !== "number" &&
        ((_d = options === null || options === void 0 ? void 0 : options.reloadAt) === null || _d === void 0 ? void 0 : _d.relative) !== undefined) {
        throw new Error("API: reload - Invalid 'reloadAt.relative' option format.");
    }
}
/**
 * Parse options given to loadVideo and set default options as found
 * in the config.
 *
 * Do not mutate anything, only cross the given options and sane default options
 * (most coming from the config).
 *
 * Throws if any mandatory option is not set.
 * @param {Object|undefined} options
 * @param {Object} ctx - The player context, needed for some default values.
 * @returns {Object}
 */
function parseLoadVideoOptions(options) {
    var _a, _b, _c, _d, _e, _f;
    let url;
    let transport;
    let keySystems;
    let textTrackMode;
    let textTrackElement;
    let startAt;
    if ((0,is_null_or_undefined/* default */.Z)(options)) {
        throw new Error("No option set on loadVideo");
    }
    if (!(0,is_null_or_undefined/* default */.Z)(options.url)) {
        url = String(options.url);
    }
    else if ((0,is_null_or_undefined/* default */.Z)((_a = options.transportOptions) === null || _a === void 0 ? void 0 : _a.initialManifest) &&
        (0,is_null_or_undefined/* default */.Z)((_b = options.transportOptions) === null || _b === void 0 ? void 0 : _b.manifestLoader)) {
        throw new Error("Unable to load a content: no url set on loadVideo.\n" +
            "Please provide at least either an `url` argument, a " +
            "`transportOptions.initialManifest` option or a " +
            "`transportOptions.manifestLoader` option so the RxPlayer " +
            "can load the content.");
    }
    if ((0,is_null_or_undefined/* default */.Z)(options.transport)) {
        throw new Error("No transport set on loadVideo");
    }
    else {
        transport = String(options.transport);
    }
    const autoPlay = (0,is_null_or_undefined/* default */.Z)(options.autoPlay) ? DEFAULT_AUTO_PLAY :
        !!options.autoPlay;
    if ((0,is_null_or_undefined/* default */.Z)(options.keySystems)) {
        keySystems = [];
    }
    else {
        keySystems = Array.isArray(options.keySystems) ? options.keySystems :
            [options.keySystems];
        for (const keySystem of keySystems) {
            if (typeof keySystem.type !== "string" ||
                typeof keySystem.getLicense !== "function") {
                throw new Error("Invalid key system given: Missing type string or " +
                    "getLicense callback");
            }
        }
    }
    const lowLatencyMode = options.lowLatencyMode === undefined ?
        false :
        !!options.lowLatencyMode;
    const transportOptsArg = typeof options.transportOptions === "object" &&
        options.transportOptions !== null ?
        options.transportOptions :
        {};
    const initialManifest = (_c = options.transportOptions) === null || _c === void 0 ? void 0 : _c.initialManifest;
    const minimumManifestUpdateInterval = (_e = (_d = options.transportOptions) === null || _d === void 0 ? void 0 : _d.minimumManifestUpdateInterval) !== null && _e !== void 0 ? _e : 0;
    let audioTrackSwitchingMode = (0,is_null_or_undefined/* default */.Z)(options.audioTrackSwitchingMode)
        ? DEFAULT_AUDIO_TRACK_SWITCHING_MODE
        : options.audioTrackSwitchingMode;
    if (!(0,array_includes/* default */.Z)(["seamless", "direct"], audioTrackSwitchingMode)) {
        log/* default.warn */.Z.warn("The `audioTrackSwitchingMode` loadVideo option must match one of " +
            "the following strategy name:\n" +
            "- `seamless`\n" +
            "- `direct`\n" +
            "If badly set, " + DEFAULT_AUDIO_TRACK_SWITCHING_MODE +
            " strategy will be used as default");
        audioTrackSwitchingMode = DEFAULT_AUDIO_TRACK_SWITCHING_MODE;
    }
    let onCodecSwitch = (0,is_null_or_undefined/* default */.Z)(options.onCodecSwitch)
        ? DEFAULT_CODEC_SWITCHING_BEHAVIOR
        : options.onCodecSwitch;
    if (!(0,array_includes/* default */.Z)(["continue", "reload"], onCodecSwitch)) {
        log/* default.warn */.Z.warn("The `onCodecSwitch` loadVideo option must match one of " +
            "the following string:\n" +
            "- `continue`\n" +
            "- `reload`\n" +
            "If badly set, " + DEFAULT_CODEC_SWITCHING_BEHAVIOR +
            " will be used as default");
        onCodecSwitch = DEFAULT_CODEC_SWITCHING_BEHAVIOR;
    }
    const transportOptions = (0,object_assign/* default */.Z)({}, transportOptsArg, {
        /* eslint-disable import/no-deprecated */
        supplementaryImageTracks: [],
        supplementaryTextTracks: [],
        /* eslint-enable import/no-deprecated */
        lowLatencyMode,
    });
    // remove already parsed data to simplify the `transportOptions` object
    delete transportOptions.initialManifest;
    delete transportOptions.minimumManifestUpdateInterval;
    if (options.supplementaryTextTracks !== undefined) {
        (0,warn_once/* default */.Z)("The `supplementaryTextTracks` loadVideo option is deprecated.\n" +
            "Please use the `TextTrackRenderer` tool instead.");
        const supplementaryTextTracks = Array.isArray(options.supplementaryTextTracks) ?
            options.supplementaryTextTracks : [options.supplementaryTextTracks];
        for (const supplementaryTextTrack of supplementaryTextTracks) {
            if (typeof supplementaryTextTrack.language !== "string" ||
                typeof supplementaryTextTrack.mimeType !== "string" ||
                typeof supplementaryTextTrack.url !== "string") {
                throw new Error("Invalid supplementary text track given. " +
                    "Missing either language, mimetype or url");
            }
        }
        transportOptions.supplementaryTextTracks = supplementaryTextTracks;
    }
    if (options.supplementaryImageTracks !== undefined) {
        (0,warn_once/* default */.Z)("The `supplementaryImageTracks` loadVideo option is deprecated.\n" +
            "Please use the `parseBifThumbnails` tool instead.");
        const supplementaryImageTracks = Array.isArray(options.supplementaryImageTracks) ?
            options.supplementaryImageTracks : [options.supplementaryImageTracks];
        for (const supplementaryImageTrack of supplementaryImageTracks) {
            if (typeof supplementaryImageTrack.mimeType !== "string" ||
                typeof supplementaryImageTrack.url !== "string") {
                throw new Error("Invalid supplementary image track given. " +
                    "Missing either mimetype or url");
            }
        }
        transportOptions.supplementaryImageTracks = supplementaryImageTracks;
    }
    if ((0,is_null_or_undefined/* default */.Z)(options.textTrackMode)) {
        textTrackMode = DEFAULT_TEXT_TRACK_MODE;
    }
    else {
        if (options.textTrackMode !== "native" && options.textTrackMode !== "html") {
            throw new Error("Invalid textTrackMode.");
        }
        textTrackMode = options.textTrackMode;
    }
    if (!(0,is_null_or_undefined/* default */.Z)(options.defaultAudioTrack)) {
        (0,warn_once/* default */.Z)("The `defaultAudioTrack` loadVideo option is deprecated.\n" +
            "Please use the `preferredAudioTracks` constructor option or the" +
            "`setPreferredAudioTracks` method instead");
    }
    const defaultAudioTrack = (0,normalize/* normalizeAudioTrack */.iH)(options.defaultAudioTrack);
    if (!(0,is_null_or_undefined/* default */.Z)(options.defaultTextTrack)) {
        (0,warn_once/* default */.Z)("The `defaultTextTrack` loadVideo option is deprecated.\n" +
            "Please use the `preferredTextTracks` constructor option or the" +
            "`setPreferredTextTracks` method instead");
    }
    const defaultTextTrack = (0,normalize/* normalizeTextTrack */.Y1)(options.defaultTextTrack);
    let hideNativeSubtitle = !DEFAULT_SHOW_NATIVE_SUBTITLE;
    if (!(0,is_null_or_undefined/* default */.Z)(options.hideNativeSubtitle)) {
        (0,warn_once/* default */.Z)("The `hideNativeSubtitle` loadVideo option is deprecated");
        hideNativeSubtitle = !!options.hideNativeSubtitle;
    }
    const manualBitrateSwitchingMode = (_f = options.manualBitrateSwitchingMode) !== null && _f !== void 0 ? _f : DEFAULT_MANUAL_BITRATE_SWITCHING_MODE;
    const enableFastSwitching = (0,is_null_or_undefined/* default */.Z)(options.enableFastSwitching) ?
        DEFAULT_ENABLE_FAST_SWITCHING :
        options.enableFastSwitching;
    if (textTrackMode === "html") {
        // TODO Better way to express that in TypeScript?
        if ((0,is_null_or_undefined/* default */.Z)(options.textTrackElement)) {
            throw new Error("You have to provide a textTrackElement " +
                "in \"html\" textTrackMode.");
        }
        else if (!(options.textTrackElement instanceof HTMLElement)) {
            throw new Error("textTrackElement should be an HTMLElement.");
        }
        else {
            textTrackElement = options.textTrackElement;
        }
    }
    else if (!(0,is_null_or_undefined/* default */.Z)(options.textTrackElement)) {
        log/* default.warn */.Z.warn("API: You have set a textTrackElement without being in " +
            "an \"html\" textTrackMode. It will be ignored.");
    }
    if (!(0,is_null_or_undefined/* default */.Z)(options.startAt)) {
        // TODO Better way to express that in TypeScript?
        if (options.startAt.wallClockTime
            instanceof Date) {
            const wallClockTime = options.startAt
                .wallClockTime.getTime() / 1000;
            startAt = (0,object_assign/* default */.Z)({}, options.startAt, { wallClockTime });
        }
        else {
            startAt = options.startAt;
        }
    }
    const networkConfig = (0,is_null_or_undefined/* default */.Z)(options.networkConfig) ?
        {} :
        { manifestRetry: options.networkConfig.manifestRetry,
            offlineRetry: options.networkConfig.offlineRetry,
            segmentRetry: options.networkConfig.segmentRetry };
    // TODO without cast
    /* eslint-disable @typescript-eslint/consistent-type-assertions */
    return { autoPlay,
        defaultAudioTrack,
        defaultTextTrack,
        enableFastSwitching,
        hideNativeSubtitle,
        keySystems,
        initialManifest,
        lowLatencyMode,
        manualBitrateSwitchingMode,
        audioTrackSwitchingMode,
        minimumManifestUpdateInterval,
        networkConfig,
        onCodecSwitch,
        startAt,
        textTrackElement,
        textTrackMode,
        transport,
        transportOptions,
        url };
    /* eslint-enable @typescript-eslint/consistent-type-assertions */
}


// EXTERNAL MODULE: ./src/utils/languages/index.ts
var languages = __webpack_require__(46211);
;// CONCATENATED MODULE: ./src/core/api/track_choice_manager.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * Transform an array of IAudioTrackPreference into an array of
 * INormalizedPreferredAudioTrack to be exploited by the TrackChoiceManager.
 * @param {Array.<Object|null>}
 * @returns {Array.<Object|null>}
 */
function normalizeAudioTracks(tracks) {
    return tracks.map(t => t == null ?
        t :
        { normalized: t.language === undefined ? undefined :
                (0,languages/* default */.ZP)(t.language),
            audioDescription: t.audioDescription,
            codec: t.codec });
}
/**
 * Transform an array of ITextTrackPreference into an array of
 * INormalizedPreferredTextTrack to be exploited by the TrackChoiceManager.
 * @param {Array.<Object|null>} tracks
 * @returns {Array.<Object|null>}
 */
function normalizeTextTracks(tracks) {
    return tracks.map(t => t == null ?
        t :
        { normalized: (0,languages/* default */.ZP)(t.language),
            closedCaption: t.closedCaption });
}
/**
 * Manage audio and text tracks for all active periods.
 * Choose the audio and text tracks for each period and record this choice.
 * @class TrackChoiceManager
 */
class TrackChoiceManager {
    constructor() {
        this._periods = new SortedList((a, b) => a.period.start - b.period.start);
        this._audioChoiceMemory = new WeakMap();
        this._textChoiceMemory = new WeakMap();
        this._videoChoiceMemory = new WeakMap();
        this._preferredAudioTracks = [];
        this._preferredTextTracks = [];
        this._preferredVideoTracks = [];
    }
    /**
     * Set the list of preferred audio tracks, in preference order.
     * @param {Array.<Object>} preferredAudioTracks
     * @param {boolean} shouldApply - `true` if those preferences should be
     * applied on the currently loaded Period. `false` if it should only
     * be applied to new content.
     */
    setPreferredAudioTracks(preferredAudioTracks, shouldApply) {
        this._preferredAudioTracks = preferredAudioTracks;
        if (shouldApply) {
            this._applyAudioPreferences();
        }
    }
    /**
     * Set the list of preferred text tracks, in preference order.
     * @param {Array.<Object>} preferredTextTracks
     * @param {boolean} shouldApply - `true` if those preferences should be
     * applied on the currently loaded Periods. `false` if it should only
     * be applied to new content.
     */
    setPreferredTextTracks(preferredTextTracks, shouldApply) {
        this._preferredTextTracks = preferredTextTracks;
        if (shouldApply) {
            this._applyTextPreferences();
        }
    }
    /**
     * Set the list of preferred text tracks, in preference order.
     * @param {Array.<Object>} tracks
     * @param {boolean} shouldApply - `true` if those preferences should be
     * applied on the currently loaded Period. `false` if it should only
     * be applied to new content.
     */
    setPreferredVideoTracks(preferredVideoTracks, shouldApply) {
        this._preferredVideoTracks = preferredVideoTracks;
        if (shouldApply) {
            this._applyVideoPreferences();
        }
    }
    /**
     * Add Subject to choose Adaptation for new "audio" or "text" Period.
     * @param {string} bufferType - The concerned buffer type
     * @param {Period} period - The concerned Period.
     * @param {Subject.<Object|null>} adaptation$ - A subject through which the
     * choice will be given
     */
    addPeriod(bufferType, period, adaptation$) {
        const periodItem = getPeriodItem(this._periods, period);
        const adaptations = period.getPlayableAdaptations(bufferType);
        if (periodItem != null) {
            if (periodItem[bufferType] != null) {
                log/* default.warn */.Z.warn(`TrackChoiceManager: ${bufferType} already added for period`, period);
                return;
            }
            else {
                periodItem[bufferType] = { adaptations, adaptation$ };
            }
        }
        else {
            this._periods.add({ period,
                [bufferType]: { adaptations, adaptation$ } });
        }
    }
    /**
     * Remove Subject to choose an "audio", "video" or "text" Adaptation for a
     * Period.
     * @param {string} bufferType - The concerned buffer type
     * @param {Period} period - The concerned Period.
     */
    removePeriod(bufferType, period) {
        const periodIndex = findPeriodIndex(this._periods, period);
        if (periodIndex == null) {
            log/* default.warn */.Z.warn(`TrackChoiceManager: ${bufferType} not found for period`, period);
            return;
        }
        const periodItem = this._periods.get(periodIndex);
        if (periodItem[bufferType] == null) {
            log/* default.warn */.Z.warn(`TrackChoiceManager: ${bufferType} already removed for period`, period);
            return;
        }
        delete periodItem[bufferType];
        if (periodItem.audio == null &&
            periodItem.text == null &&
            periodItem.video == null) {
            this._periods.removeElement(periodItem);
        }
    }
    resetPeriods() {
        while (this._periods.length() > 0) {
            this._periods.pop();
        }
    }
    /**
     * Update the choice of all added Periods based on:
     *   1. What was the last chosen adaptation
     *   2. If not found, the preferences
     */
    update() {
        this._resetChosenAudioTracks();
        this._resetChosenTextTracks();
        this._resetChosenVideoTracks();
    }
    /**
     * Emit initial audio Adaptation through the given Subject based on:
     *   - the preferred audio tracks
     *   - the last choice for this period, if one
     * @param {Period} period - The concerned Period.
     */
    setInitialAudioTrack(period) {
        const periodItem = getPeriodItem(this._periods, period);
        const audioInfos = periodItem != null ? periodItem.audio :
            null;
        if (audioInfos == null || periodItem == null) {
            throw new Error("TrackChoiceManager: Given Period not found.");
        }
        const audioAdaptations = period.getPlayableAdaptations("audio");
        const chosenAudioAdaptation = this._audioChoiceMemory.get(period);
        if (chosenAudioAdaptation === null) {
            // If the Period was previously without audio, keep it that way
            audioInfos.adaptation$.next(null);
        }
        else if (chosenAudioAdaptation === undefined ||
            !(0,array_includes/* default */.Z)(audioAdaptations, chosenAudioAdaptation)) {
            // Find the optimal audio Adaptation
            const preferredAudioTracks = this._preferredAudioTracks;
            const normalizedPref = normalizeAudioTracks(preferredAudioTracks);
            const optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, normalizedPref);
            this._audioChoiceMemory.set(period, optimalAdaptation);
            audioInfos.adaptation$.next(optimalAdaptation);
        }
        else {
            audioInfos.adaptation$.next(chosenAudioAdaptation); // set last one
        }
    }
    /**
     * Emit initial text Adaptation through the given Subject based on:
     *   - the preferred text tracks
     *   - the last choice for this period, if one
     * @param {Period} period - The concerned Period.
     */
    setInitialTextTrack(period) {
        const periodItem = getPeriodItem(this._periods, period);
        const textInfos = periodItem != null ? periodItem.text :
            null;
        if (textInfos == null || periodItem == null) {
            throw new Error("TrackChoiceManager: Given Period not found.");
        }
        const textAdaptations = period.getPlayableAdaptations("text");
        const chosenTextAdaptation = this._textChoiceMemory.get(period);
        if (chosenTextAdaptation === null) {
            // If the Period was previously without text, keep it that way
            textInfos.adaptation$.next(null);
        }
        else if (chosenTextAdaptation === undefined ||
            !(0,array_includes/* default */.Z)(textAdaptations, chosenTextAdaptation)) {
            // Find the optimal text Adaptation
            const preferredTextTracks = this._preferredTextTracks;
            const normalizedPref = normalizeTextTracks(preferredTextTracks);
            const optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, normalizedPref);
            this._textChoiceMemory.set(period, optimalAdaptation);
            textInfos.adaptation$.next(optimalAdaptation);
        }
        else {
            textInfos.adaptation$.next(chosenTextAdaptation); // set last one
        }
    }
    /**
     * Emit initial video Adaptation through the given Subject based on:
     *   - the preferred video tracks
     *   - the last choice for this period, if one
     * @param {Period} period - The concerned Period.
     */
    setInitialVideoTrack(period) {
        const periodItem = getPeriodItem(this._periods, period);
        const videoInfos = periodItem != null ? periodItem.video :
            null;
        if (videoInfos == null || periodItem == null) {
            throw new Error("TrackChoiceManager: Given Period not found.");
        }
        const videoAdaptations = period.getPlayableAdaptations("video");
        const chosenVideoAdaptation = this._videoChoiceMemory.get(period);
        if (chosenVideoAdaptation === null) {
            // If the Period was previously without video, keep it that way
            videoInfos.adaptation$.next(null);
        }
        else if (chosenVideoAdaptation === undefined ||
            !(0,array_includes/* default */.Z)(videoAdaptations, chosenVideoAdaptation)) {
            const preferredVideoTracks = this._preferredVideoTracks;
            const optimalAdaptation = findFirstOptimalVideoAdaptation(videoAdaptations, preferredVideoTracks);
            this._videoChoiceMemory.set(period, optimalAdaptation);
            videoInfos.adaptation$.next(optimalAdaptation);
        }
        else {
            videoInfos.adaptation$.next(chosenVideoAdaptation); // set last one
        }
    }
    /**
     * Set audio track based on the ID of its adaptation for a given added Period.
     * @param {Period} period - The concerned Period.
     * @param {string} wantedId - adaptation id of the wanted track
     */
    setAudioTrackByID(period, wantedId) {
        const periodItem = getPeriodItem(this._periods, period);
        const audioInfos = periodItem != null ? periodItem.audio :
            null;
        if (audioInfos == null) {
            throw new Error("TrackChoiceManager: Given Period not found.");
        }
        const wantedAdaptation = (0,array_find/* default */.Z)(audioInfos.adaptations, ({ id }) => id === wantedId);
        if (wantedAdaptation === undefined) {
            throw new Error("Audio Track not found.");
        }
        const chosenAudioAdaptation = this._audioChoiceMemory.get(period);
        if (chosenAudioAdaptation === wantedAdaptation) {
            return;
        }
        this._audioChoiceMemory.set(period, wantedAdaptation);
        audioInfos.adaptation$.next(wantedAdaptation);
    }
    /**
     * Set text track based on the ID of its adaptation for a given added Period.
     * @param {Period} period - The concerned Period.
     * @param {string} wantedId - adaptation id of the wanted track
     */
    setTextTrackByID(period, wantedId) {
        const periodItem = getPeriodItem(this._periods, period);
        const textInfos = periodItem != null ? periodItem.text :
            null;
        if (textInfos == null) {
            throw new Error("TrackChoiceManager: Given Period not found.");
        }
        const wantedAdaptation = (0,array_find/* default */.Z)(textInfos.adaptations, ({ id }) => id === wantedId);
        if (wantedAdaptation === undefined) {
            throw new Error("Text Track not found.");
        }
        const chosenTextAdaptation = this._textChoiceMemory.get(period);
        if (chosenTextAdaptation === wantedAdaptation) {
            return;
        }
        this._textChoiceMemory.set(period, wantedAdaptation);
        textInfos.adaptation$.next(wantedAdaptation);
    }
    /**
     * Set video track based on the ID of its adaptation for a given added Period.
     * @param {Period} period - The concerned Period.
     * @param {string} wantedId - adaptation id of the wanted track
     *
     * @throws Error - Throws if the period given has not been added
     * @throws Error - Throws if the given id is not found in any video adaptation
     * of the given Period.
     */
    setVideoTrackByID(period, wantedId) {
        const periodItem = getPeriodItem(this._periods, period);
        const videoInfos = periodItem != null ? periodItem.video :
            null;
        if (videoInfos == null) {
            throw new Error("LanguageManager: Given Period not found.");
        }
        const wantedAdaptation = (0,array_find/* default */.Z)(videoInfos.adaptations, ({ id }) => id === wantedId);
        if (wantedAdaptation === undefined) {
            throw new Error("Video Track not found.");
        }
        const chosenVideoAdaptation = this._videoChoiceMemory.get(period);
        if (chosenVideoAdaptation === wantedAdaptation) {
            return;
        }
        this._videoChoiceMemory.set(period, wantedAdaptation);
        videoInfos.adaptation$.next(wantedAdaptation);
    }
    /**
     * Disable the current text track for a given period.
     *
     * @param {Period} period - The concerned Period.
     *
     * @throws Error - Throws if the period given has not been added
     */
    disableTextTrack(period) {
        const periodItem = getPeriodItem(this._periods, period);
        const textInfos = periodItem != null ? periodItem.text :
            null;
        if (textInfos == null) {
            throw new Error("TrackChoiceManager: Given Period not found.");
        }
        const chosenTextAdaptation = this._textChoiceMemory.get(period);
        if (chosenTextAdaptation === null) {
            return;
        }
        this._textChoiceMemory.set(period, null);
        textInfos.adaptation$.next(null);
    }
    /**
     * Disable the current video track for a given period.
     * @param {Object} period
     * @throws Error - Throws if the period given has not been added
     */
    disableVideoTrack(period) {
        const periodItem = getPeriodItem(this._periods, period);
        const videoInfos = periodItem === null || periodItem === void 0 ? void 0 : periodItem.video;
        if (videoInfos === undefined) {
            throw new Error("TrackManager: Given Period not found.");
        }
        const chosenVideoAdaptation = this._videoChoiceMemory.get(period);
        if (chosenVideoAdaptation === null) {
            return;
        }
        this._videoChoiceMemory.set(period, null);
        videoInfos.adaptation$.next(null);
    }
    /**
     * Returns an object describing the chosen audio track for the given audio
     * Period.
     *
     * Returns null is the the current audio track is disabled or not
     * set yet.
     *
     * @param {Period} period - The concerned Period.
     * @returns {Object|null} - The audio track chosen for this Period
     */
    getChosenAudioTrack(period) {
        const periodItem = getPeriodItem(this._periods, period);
        const audioInfos = periodItem != null ? periodItem.audio :
            null;
        if (audioInfos == null) {
            return null;
        }
        const chosenTrack = this._audioChoiceMemory.get(period);
        if (chosenTrack == null) {
            return null;
        }
        const audioTrack = {
            language: (0,take_first_set/* default */.Z)(chosenTrack.language, ""),
            normalized: (0,take_first_set/* default */.Z)(chosenTrack.normalizedLanguage, ""),
            audioDescription: chosenTrack.isAudioDescription === true,
            id: chosenTrack.id,
            representations: chosenTrack.representations.map(parseAudioRepresentation),
        };
        if (chosenTrack.isDub === true) {
            audioTrack.dub = true;
        }
        return audioTrack;
    }
    /**
     * Returns an object describing the chosen text track for the given text
     * Period.
     *
     * Returns null is the the current text track is disabled or not
     * set yet.
     *
     * @param {Period} period - The concerned Period.
     * @returns {Object|null} - The text track chosen for this Period
     */
    getChosenTextTrack(period) {
        const periodItem = getPeriodItem(this._periods, period);
        const textInfos = periodItem != null ? periodItem.text :
            null;
        if (textInfos == null) {
            return null;
        }
        const chosenTextAdaptation = this._textChoiceMemory.get(period);
        if (chosenTextAdaptation == null) {
            return null;
        }
        return {
            language: (0,take_first_set/* default */.Z)(chosenTextAdaptation.language, ""),
            normalized: (0,take_first_set/* default */.Z)(chosenTextAdaptation.normalizedLanguage, ""),
            closedCaption: chosenTextAdaptation.isClosedCaption === true,
            id: chosenTextAdaptation.id,
        };
    }
    /**
     * Returns an object describing the chosen video track for the given video
     * Period.
     *
     * Returns null is the the current video track is disabled or not
     * set yet.
     *
     * @param {Period} period - The concerned Period.
     * @returns {Object|null} - The video track chosen for this Period
     */
    getChosenVideoTrack(period) {
        const periodItem = getPeriodItem(this._periods, period);
        const videoInfos = periodItem != null ? periodItem.video :
            null;
        if (videoInfos == null) {
            return null;
        }
        const chosenVideoAdaptation = this._videoChoiceMemory.get(period);
        if (chosenVideoAdaptation == null) {
            return null;
        }
        const videoTrack = {
            id: chosenVideoAdaptation.id,
            representations: chosenVideoAdaptation.representations
                .map(parseVideoRepresentation),
        };
        if (chosenVideoAdaptation.isSignInterpreted === true) {
            videoTrack.signInterpreted = true;
        }
        return videoTrack;
    }
    /**
     * Returns all available audio tracks for a given Period, as an array of
     * objects.
     *
     * @returns {Array.<Object>}
     */
    getAvailableAudioTracks(period) {
        const periodItem = getPeriodItem(this._periods, period);
        const audioInfos = periodItem != null ? periodItem.audio :
            null;
        if (audioInfos == null) {
            return [];
        }
        const chosenAudioAdaptation = this._audioChoiceMemory.get(period);
        const currentId = chosenAudioAdaptation != null ? chosenAudioAdaptation.id :
            null;
        return audioInfos.adaptations
            .map((adaptation) => {
            const formatted = {
                language: (0,take_first_set/* default */.Z)(adaptation.language, ""),
                normalized: (0,take_first_set/* default */.Z)(adaptation.normalizedLanguage, ""),
                audioDescription: adaptation.isAudioDescription === true,
                id: adaptation.id,
                active: currentId == null ? false : currentId === adaptation.id,
                representations: adaptation.representations.map(parseAudioRepresentation),
            };
            if (adaptation.isDub === true) {
                formatted.dub = true;
            }
            return formatted;
        });
    }
    /**
     * Returns all available text tracks for a given Period, as an array of
     * objects.
     *
     * @param {Period} period
     * @returns {Array.<Object>}
     */
    getAvailableTextTracks(period) {
        const periodItem = getPeriodItem(this._periods, period);
        const textInfos = periodItem != null ? periodItem.text :
            null;
        if (textInfos == null) {
            return [];
        }
        const chosenTextAdaptation = this._textChoiceMemory.get(period);
        const currentId = chosenTextAdaptation != null ? chosenTextAdaptation.id :
            null;
        return textInfos.adaptations
            .map((adaptation) => ({
            language: (0,take_first_set/* default */.Z)(adaptation.language, ""),
            normalized: (0,take_first_set/* default */.Z)(adaptation.normalizedLanguage, ""),
            closedCaption: adaptation.isClosedCaption === true,
            id: adaptation.id,
            active: currentId == null ? false :
                currentId === adaptation.id,
        }));
    }
    /**
     * Returns all available video tracks for a given Period, as an array of
     * objects.
     *
     * @returns {Array.<Object>}
     */
    getAvailableVideoTracks(period) {
        const periodItem = getPeriodItem(this._periods, period);
        const videoInfos = periodItem != null ? periodItem.video :
            null;
        if (videoInfos == null) {
            return [];
        }
        const chosenVideoAdaptation = this._videoChoiceMemory.get(period);
        const currentId = chosenVideoAdaptation != null ? chosenVideoAdaptation.id :
            null;
        return videoInfos.adaptations
            .map((adaptation) => {
            const formatted = {
                id: adaptation.id,
                active: currentId === null ? false :
                    currentId === adaptation.id,
                representations: adaptation.representations.map(parseVideoRepresentation),
            };
            if (adaptation.isSignInterpreted === true) {
                formatted.signInterpreted = true;
            }
            return formatted;
        });
    }
    /**
     * Reset all audio tracks choices to corresponds to the current preferences.
     */
    _applyAudioPreferences() {
        // Remove all memorized choices and start over
        this._audioChoiceMemory = new WeakMap();
        this._resetChosenAudioTracks();
    }
    /**
     * Reset all text tracks choices to corresponds to the current preferences.
     */
    _applyTextPreferences() {
        // Remove all memorized choices and start over
        this._textChoiceMemory = new WeakMap();
        this._resetChosenTextTracks();
    }
    /**
     * Reset all video tracks choices to corresponds to the current preferences.
     */
    _applyVideoPreferences() {
        // Remove all memorized choices and start over
        this._videoChoiceMemory = new WeakMap();
        this._resetChosenVideoTracks();
    }
    /**
     * Choose again the best audio tracks for all current Periods.
     * This is based on two things:
     *   1. what was the track previously chosen for that Period (by checking
     *      `this._audioChoiceMemory`).
     *   2. If no track were previously chosen or if it is not available anymore
     *      we check the audio preferences.
     */
    _resetChosenAudioTracks() {
        const preferredAudioTracks = this._preferredAudioTracks;
        const normalizedPref = normalizeAudioTracks(preferredAudioTracks);
        const recursiveUpdateAudioTrack = (index) => {
            if (index >= this._periods.length()) {
                // we did all audio Periods, exit
                return;
            }
            const periodItem = this._periods.get(index);
            if (periodItem.audio == null) {
                // No audio choice for this period, check next one
                recursiveUpdateAudioTrack(index + 1);
                return;
            }
            const { period, audio: audioItem } = periodItem;
            const audioAdaptations = period.getPlayableAdaptations("audio");
            const chosenAudioAdaptation = this._audioChoiceMemory.get(period);
            if (chosenAudioAdaptation === null ||
                (chosenAudioAdaptation !== undefined &&
                    (0,array_includes/* default */.Z)(audioAdaptations, chosenAudioAdaptation))) {
                // Already best audio for this Period, check next one
                recursiveUpdateAudioTrack(index + 1);
                return;
            }
            const optimalAdaptation = findFirstOptimalAudioAdaptation(audioAdaptations, normalizedPref);
            this._audioChoiceMemory.set(period, optimalAdaptation);
            audioItem.adaptation$.next(optimalAdaptation);
            // previous "next" call could have changed everything, start over
            recursiveUpdateAudioTrack(0);
        };
        recursiveUpdateAudioTrack(0);
    }
    /**
     * Choose again the best text tracks for all current Periods.
     * This is based on two things:
     *   1. what was the track previously chosen for that Period (by checking
     *      `this._textChoiceMemory`).
     *   2. If no track were previously chosen or if it is not available anymore
     *      we check the text preferences.
     */
    _resetChosenTextTracks() {
        const preferredTextTracks = this._preferredTextTracks;
        const normalizedPref = normalizeTextTracks(preferredTextTracks);
        const recursiveUpdateTextTrack = (index) => {
            if (index >= this._periods.length()) {
                // we did all text Periods, exit
                return;
            }
            const periodItem = this._periods.get(index);
            if (periodItem.text == null) {
                // No text choice for this period, check next one
                recursiveUpdateTextTrack(index + 1);
                return;
            }
            const { period, text: textItem } = periodItem;
            const textAdaptations = period.getPlayableAdaptations("text");
            const chosenTextAdaptation = this._textChoiceMemory.get(period);
            if (chosenTextAdaptation === null ||
                (chosenTextAdaptation !== undefined &&
                    (0,array_includes/* default */.Z)(textAdaptations, chosenTextAdaptation))) {
                // Already best text for this Period, check next one
                recursiveUpdateTextTrack(index + 1);
                return;
            }
            const optimalAdaptation = findFirstOptimalTextAdaptation(textAdaptations, normalizedPref);
            this._textChoiceMemory.set(period, optimalAdaptation);
            textItem.adaptation$.next(optimalAdaptation);
            // previous "next" call could have changed everything, start over
            recursiveUpdateTextTrack(0);
        };
        recursiveUpdateTextTrack(0);
    }
    /**
     * Choose again the best video tracks for all current Periods.
     * This is based on two things:
     *   1. what was the track previously chosen for that Period (by checking
     *      `this._videoChoiceMemory`).
     *   2. If no track were previously chosen or if it is not available anymore
     *      we check the video preferences.
     */
    _resetChosenVideoTracks() {
        const preferredVideoTracks = this._preferredVideoTracks;
        const recursiveUpdateVideoTrack = (index) => {
            if (index >= this._periods.length()) {
                // we did all video Periods, exit
                return;
            }
            const periodItem = this._periods.get(index);
            if (periodItem.video == null) {
                // No video choice for this period, check next one
                recursiveUpdateVideoTrack(index + 1);
                return;
            }
            const { period, video: videoItem } = periodItem;
            const videoAdaptations = period.getPlayableAdaptations("video");
            const chosenVideoAdaptation = this._videoChoiceMemory.get(period);
            if (chosenVideoAdaptation === null ||
                (chosenVideoAdaptation !== undefined &&
                    (0,array_includes/* default */.Z)(videoAdaptations, chosenVideoAdaptation))) {
                // Already best video for this Period, check next one
                recursiveUpdateVideoTrack(index + 1);
                return;
            }
            const optimalAdaptation = findFirstOptimalVideoAdaptation(videoAdaptations, preferredVideoTracks);
            this._videoChoiceMemory.set(period, optimalAdaptation);
            videoItem.adaptation$.next(optimalAdaptation);
            // previous "next" call could have changed everything, start over
            recursiveUpdateVideoTrack(0);
        };
        recursiveUpdateVideoTrack(0);
    }
}
/**
 * Create a function allowing to compare audio Adaptations with a given
 * `preferredAudioTrack` preference to see if they match.
 *
 * This function is curried to be easily and optimally used in a loop context.
 *
 * @param {Object} preferredAudioTrack - The audio track preference you want to
 * compare audio Adaptations to.
 * @returns {Function} - Function taking in argument an audio Adaptation and
 * returning `true` if it matches the `preferredAudioTrack` preference (and
 * `false` otherwise.
 */
function createAudioPreferenceMatcher(preferredAudioTrack) {
    /**
     * Compares an audio Adaptation to the given `preferredAudioTrack` preference.
     * Returns `true` if it matches, false otherwise.
     * @param {Object} audioAdaptation
     * @returns {boolean}
     */
    return function matchAudioPreference(audioAdaptation) {
        var _a;
        if (preferredAudioTrack.normalized !== undefined) {
            const language = (_a = audioAdaptation.normalizedLanguage) !== null && _a !== void 0 ? _a : "";
            if (language !== preferredAudioTrack.normalized) {
                return false;
            }
        }
        if (preferredAudioTrack.audioDescription !== undefined) {
            if (preferredAudioTrack.audioDescription) {
                if (audioAdaptation.isAudioDescription !== true) {
                    return false;
                }
            }
            else if (audioAdaptation.isAudioDescription === true) {
                return false;
            }
        }
        if (preferredAudioTrack.codec === undefined) {
            return true;
        }
        const regxp = preferredAudioTrack.codec.test;
        const codecTestingFn = (rep) => rep.codec !== undefined && regxp.test(rep.codec);
        if (preferredAudioTrack.codec.all) {
            return audioAdaptation.representations.every(codecTestingFn);
        }
        return audioAdaptation.representations.some(codecTestingFn);
    };
}
/**
 * Find an optimal audio adaptation given their list and the array of preferred
 * audio tracks sorted from the most preferred to the least preferred.
 *
 * `null` if the most optimal audio adaptation is no audio adaptation.
 * @param {Array.<Adaptation>} audioAdaptations
 * @param {Array.<Object|null>} preferredAudioTracks
 * @returns {Adaptation|null}
 */
function findFirstOptimalAudioAdaptation(audioAdaptations, preferredAudioTracks) {
    if (audioAdaptations.length === 0) {
        return null;
    }
    for (let i = 0; i < preferredAudioTracks.length; i++) {
        const preferredAudioTrack = preferredAudioTracks[i];
        if (preferredAudioTrack === null) {
            return null;
        }
        const matchPreferredAudio = createAudioPreferenceMatcher(preferredAudioTrack);
        const foundAdaptation = (0,array_find/* default */.Z)(audioAdaptations, matchPreferredAudio);
        if (foundAdaptation !== undefined) {
            return foundAdaptation;
        }
    }
    // no optimal adaptation, just return the first one
    return audioAdaptations[0];
}
/**
 * Create a function allowing to compare text Adaptations with a given
 * `preferredTextTrack` preference to see if they match.
 *
 * This function is curried to be easily and optimally used in a loop context.
 *
 * @param {Object} preferredTextTrack - The text track preference you want to
 * compare text Adaptations to.
 * @returns {Function} - Function taking in argument a text Adaptation and
 * returning `true` if it matches the `preferredTextTrack` preference (and
 * `false` otherwise.
 */
function createTextPreferenceMatcher(preferredTextTrack) {
    /**
     * Compares a text Adaptation to the given `preferredTextTrack` preference.
     * Returns `true` if it matches, false otherwise.
     * @param {Object} textAdaptation
     * @returns {boolean}
     */
    return function matchTextPreference(textAdaptation) {
        return (0,take_first_set/* default */.Z)(textAdaptation.normalizedLanguage, "") === preferredTextTrack.normalized &&
            (preferredTextTrack.closedCaption ? textAdaptation.isClosedCaption === true :
                textAdaptation.isClosedCaption !== true);
    };
}
/**
 * Find an optimal text adaptation given their list and the array of preferred
 * text tracks sorted from the most preferred to the least preferred.
 *
 * `null` if the most optimal text adaptation is no text adaptation.
 * @param {Array.<Object>} textAdaptations
 * @param {Array.<Object|null>} preferredTextTracks
 * @returns {Adaptation|null}
 */
function findFirstOptimalTextAdaptation(textAdaptations, preferredTextTracks) {
    if (textAdaptations.length === 0) {
        return null;
    }
    for (let i = 0; i < preferredTextTracks.length; i++) {
        const preferredTextTrack = preferredTextTracks[i];
        if (preferredTextTrack === null) {
            return null;
        }
        const matchPreferredText = createTextPreferenceMatcher(preferredTextTrack);
        const foundAdaptation = (0,array_find/* default */.Z)(textAdaptations, matchPreferredText);
        if (foundAdaptation !== undefined) {
            return foundAdaptation;
        }
    }
    // no optimal adaptation
    return null;
}
/**
 * Create a function allowing to compare video Adaptations with a given
 * `preferredVideoTrack` preference to see if they match.
 *
 * This function is curried to be easily and optimally used in a loop context.
 *
 * @param {Object} preferredVideoTrack - The video track preference you want to
 * compare video Adaptations to.
 * @returns {Function} - Function taking in argument a video Adaptation and
 * returning `true` if it matches the `preferredVideoTrack` preference (and
 * `false` otherwise.
 */
function createVideoPreferenceMatcher(preferredVideoTrack) {
    /**
     * Compares a video Adaptation to the given `preferredVideoTrack` preference.
     * Returns `true` if it matches, false otherwise.
     * @param {Object} videoAdaptation
     * @returns {boolean}
     */
    return function matchVideoPreference(videoAdaptation) {
        if (preferredVideoTrack.signInterpreted !== undefined &&
            preferredVideoTrack.signInterpreted !== videoAdaptation.isSignInterpreted) {
            return false;
        }
        if (preferredVideoTrack.codec === undefined) {
            return true;
        }
        const regxp = preferredVideoTrack.codec.test;
        const codecTestingFn = (rep) => rep.codec !== undefined && regxp.test(rep.codec);
        if (preferredVideoTrack.codec.all) {
            return videoAdaptation.representations.every(codecTestingFn);
        }
        return videoAdaptation.representations.some(codecTestingFn);
    };
}
/**
 * Find an optimal video adaptation given their list and the array of preferred
 * video tracks sorted from the most preferred to the least preferred.
 *
 * `null` if the most optimal video adaptation is no video adaptation.
 * @param {Array.<Adaptation>} videoAdaptations
 * @param {Array.<Object|null>} preferredvideoTracks
 * @returns {Adaptation|null}
 */
function findFirstOptimalVideoAdaptation(videoAdaptations, preferredVideoTracks) {
    if (videoAdaptations.length === 0) {
        return null;
    }
    for (let i = 0; i < preferredVideoTracks.length; i++) {
        const preferredVideoTrack = preferredVideoTracks[i];
        if (preferredVideoTrack === null) {
            return null;
        }
        const matchPreferredVideo = createVideoPreferenceMatcher(preferredVideoTrack);
        const foundAdaptation = (0,array_find/* default */.Z)(videoAdaptations, matchPreferredVideo);
        if (foundAdaptation !== undefined) {
            return foundAdaptation;
        }
    }
    // no optimal adaptation, just return the first one
    return videoAdaptations[0];
}
/**
 * Returns the index of the given `period` in the given `periods`
 * SortedList.
 * Returns `undefined` if that `period` is not found.
 * @param {Object} periods
 * @param {Object} period
 * @returns {number|undefined}
 */
function findPeriodIndex(periods, period) {
    for (let i = 0; i < periods.length(); i++) {
        const periodI = periods.get(i);
        if (periodI.period.id === period.id) {
            return i;
        }
    }
}
/**
 * Returns element in the given `periods` SortedList that corresponds to the
 * `period` given.
 * Returns `undefined` if that `period` is not found.
 * @param {Object} periods
 * @param {Object} period
 * @returns {Object|undefined}
 */
function getPeriodItem(periods, period) {
    for (let i = 0; i < periods.length(); i++) {
        const periodI = periods.get(i);
        if (periodI.period.id === period.id) {
            return periodI;
        }
    }
}
/**
 * Parse video Representation into a ITMVideoRepresentation.
 * @param {Object} representation
 * @returns {Object}
 */
function parseVideoRepresentation({ id, bitrate, frameRate, width, height, codec }) {
    return { id, bitrate, frameRate, width, height, codec };
}
/**
 * Parse audio Representation into a ITMAudioRepresentation.
 * @param {Object} representation
 * @returns {Object}
 */
function parseAudioRepresentation({ id, bitrate, codec }) {
    return { id, bitrate, codec };
}

;// CONCATENATED MODULE: ./src/core/api/public_api.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file defines the public API for the RxPlayer.
 * It also starts the different sub-parts of the player on various API calls.
 */



/* eslint-disable-next-line max-len */






















/* eslint-disable @typescript-eslint/naming-convention */
const { DEFAULT_UNMUTED_VOLUME } = config/* default */.Z;
const { isActive, isVideoVisible, onEnded$, onFullscreenChange$, onPlayPause$, onPictureInPictureEvent$, onSeeking$, onTextTrackChanges$, videoWidth$ } = event_listeners;
/**
 * @class Player
 * @extends EventEmitter
 */
class Player extends event_emitter/* default */.Z {
    /**
     * @constructor
     * @param {Object} options
     */
    constructor(options = {}) {
        super();
        const { initialAudioBitrate, initialVideoBitrate, limitVideoWidth, minAudioBitrate, minVideoBitrate, maxAudioBitrate, maxBufferAhead, maxBufferBehind, maxVideoBitrate, preferredAudioTracks, preferredTextTracks, preferredVideoTracks, throttleWhenHidden, throttleVideoBitrateWhenHidden, videoElement, wantedBufferAhead, stopAtEnd } = parseConstructorOptions(options);
        // Workaround to support Firefox autoplay on FF 42.
        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1194624
        videoElement.preload = "auto";
        this.version = /* PLAYER_VERSION */ "3.24.0";
        this.log = log/* default */.Z;
        this.state = "STOPPED";
        this.videoElement = videoElement;
        this._priv_destroy$ = new Subject/* Subject */.xQ();
        this._priv_pictureInPictureEvent$ = new ReplaySubject/* ReplaySubject */.t(1);
        onPictureInPictureEvent$(videoElement)
            .pipe((0,takeUntil/* takeUntil */.R)(this._priv_destroy$))
            .subscribe(this._priv_pictureInPictureEvent$);
        /** @deprecated */
        onFullscreenChange$(videoElement)
            .pipe((0,takeUntil/* takeUntil */.R)(this._priv_destroy$))
            /* eslint-disable import/no-deprecated */
            .subscribe(() => this.trigger("fullscreenChange", this.isFullscreen()));
        /* eslint-enable import/no-deprecated */
        /** @deprecated */
        onTextTrackChanges$(videoElement.textTracks)
            .pipe((0,takeUntil/* takeUntil */.R)(this._priv_destroy$), (0,map/* map */.U)((evt) => {
            const target = evt.target;
            const arr = [];
            for (let i = 0; i < target.length; i++) {
                const textTrack = target[i];
                arr.push(textTrack);
            }
            return arr;
        }), 
        // We can have two consecutive textTrackChanges with the exact same
        // payload when we perform multiple texttrack operations before the event
        // loop is freed.
        // In that case we only want to fire one time the observable.
        (0,distinctUntilChanged/* distinctUntilChanged */.x)((textTracksA, textTracksB) => {
            if (textTracksA.length !== textTracksB.length) {
                return false;
            }
            for (let i = 0; i < textTracksA.length; i++) {
                if (textTracksA[i] !== textTracksB[i]) {
                    return false;
                }
            }
            return true;
        }))
            .subscribe((x) => this._priv_onNativeTextTracksNext(x));
        this._priv_playing$ = new ReplaySubject/* ReplaySubject */.t(1);
        this._priv_speed$ = new BehaviorSubject(videoElement.playbackRate);
        this._priv_contentLock$ = new BehaviorSubject(false);
        this._priv_bufferOptions = {
            wantedBufferAhead$: new BehaviorSubject(wantedBufferAhead),
            maxBufferAhead$: new BehaviorSubject(maxBufferAhead),
            maxBufferBehind$: new BehaviorSubject(maxBufferBehind),
        };
        this._priv_bitrateInfos = {
            lastBitrates: { audio: initialAudioBitrate,
                video: initialVideoBitrate },
            minAutoBitrates: { audio: new BehaviorSubject(minAudioBitrate),
                video: new BehaviorSubject(minVideoBitrate) },
            maxAutoBitrates: { audio: new BehaviorSubject(maxAudioBitrate),
                video: new BehaviorSubject(maxVideoBitrate) },
            manualBitrates: { audio: new BehaviorSubject(-1),
                video: new BehaviorSubject(-1) },
        };
        this._priv_throttleWhenHidden = throttleWhenHidden;
        this._priv_throttleVideoBitrateWhenHidden = throttleVideoBitrateWhenHidden;
        this._priv_limitVideoWidth = limitVideoWidth;
        this._priv_mutedMemory = DEFAULT_UNMUTED_VOLUME;
        this._priv_trackChoiceManager = null;
        this._priv_mediaElementTrackChoiceManager = null;
        this._priv_currentError = null;
        this._priv_contentInfos = null;
        this._priv_contentEventsMemory = {};
        this._priv_stopAtEnd = stopAtEnd;
        this._priv_setPlayerState(PLAYER_STATES.STOPPED);
        this._priv_preferredAudioTracks = preferredAudioTracks;
        this._priv_preferredTextTracks = preferredTextTracks;
        this._priv_preferredVideoTracks = preferredVideoTracks;
        this._priv_lastContentPlaybackInfos = {};
    }
    /** All possible Error types emitted by the RxPlayer. */
    static get ErrorTypes() {
        return error_codes/* ErrorTypes */.ZB;
    }
    /** All possible Error codes emitted by the RxPlayer. */
    static get ErrorCodes() {
        return error_codes/* ErrorCodes */.SM;
    }
    /**
     * Current log level.
     * Update current log level.
     * Should be either (by verbosity ascending):
     *   - "NONE"
     *   - "ERROR"
     *   - "WARNING"
     *   - "INFO"
     *   - "DEBUG"
     * Any other value will be translated to "NONE".
     */
    static get LogLevel() {
        return log/* default.getLevel */.Z.getLevel();
    }
    static set LogLevel(logLevel) {
        log/* default.setLevel */.Z.setLevel(logLevel);
    }
    /**
     * Stop the playback for the current content.
     */
    stop() {
        if (this._priv_contentInfos !== null) {
            this._priv_contentInfos.stop$.next();
            this._priv_contentInfos.stop$.complete();
        }
        this._priv_cleanUpCurrentContentState();
        if (this.state !== PLAYER_STATES.STOPPED) {
            this._priv_setPlayerState(PLAYER_STATES.STOPPED);
        }
    }
    /**
     * Free the resources used by the player.
     * /!\ The player cannot be "used" anymore after this method has been called.
     */
    dispose() {
        // free resources linked to the loaded content
        this.stop();
        if (this.videoElement !== null) {
            // free resources used for EME management
            disposeEME(this.videoElement);
        }
        // free Observables linked to the Player instance
        this._priv_destroy$.next();
        this._priv_destroy$.complete();
        // Complete all subjects
        this._priv_playing$.complete();
        this._priv_speed$.complete();
        this._priv_contentLock$.complete();
        this._priv_bufferOptions.wantedBufferAhead$.complete();
        this._priv_bufferOptions.maxBufferAhead$.complete();
        this._priv_bufferOptions.maxBufferBehind$.complete();
        this._priv_pictureInPictureEvent$.complete();
        this._priv_bitrateInfos.manualBitrates.video.complete();
        this._priv_bitrateInfos.manualBitrates.audio.complete();
        this._priv_bitrateInfos.minAutoBitrates.video.complete();
        this._priv_bitrateInfos.minAutoBitrates.audio.complete();
        this._priv_bitrateInfos.maxAutoBitrates.video.complete();
        this._priv_bitrateInfos.maxAutoBitrates.audio.complete();
        this._priv_lastContentPlaybackInfos = {};
        // un-attach video element
        this.videoElement = null;
    }
    /**
     * Load a new video.
     * @param {Object} opts
     */
    loadVideo(opts) {
        const options = parseLoadVideoOptions(opts);
        log/* default.info */.Z.info("API: Calling loadvideo", options);
        this._priv_lastContentPlaybackInfos = { options };
        this._priv_initializeContentPlayback(options);
    }
    /**
     * Reload last content. Init media playback without fetching again
     * the manifest.
     * @param {Object} reloadOpts
     */
    reload(reloadOpts) {
        const { options, manifest, lastPlaybackPosition } = this._priv_lastContentPlaybackInfos;
        if (options === undefined ||
            manifest === undefined ||
            lastPlaybackPosition === undefined) {
            throw new Error("API: Can't reload without having previously loaded a content.");
        }
        checkReloadOptions(reloadOpts);
        let startAtPositon;
        if (reloadOpts !== undefined &&
            reloadOpts.reloadAt !== undefined &&
            reloadOpts.reloadAt.position !== undefined) {
            startAtPositon = reloadOpts.reloadAt.position;
        }
        else {
            let playbackPosition;
            if (this.state === "STOPPED" || this.state === "ENDED") {
                playbackPosition = lastPlaybackPosition;
            }
            else {
                if (this.videoElement === null) {
                    throw new Error("Can't reload when video element does not exist.");
                }
                playbackPosition = this.videoElement.currentTime;
            }
            if (reloadOpts !== undefined &&
                reloadOpts.reloadAt !== undefined &&
                reloadOpts.reloadAt.relative !== undefined) {
                startAtPositon = reloadOpts.reloadAt.relative + playbackPosition;
            }
            else {
                startAtPositon = playbackPosition;
            }
        }
        const newOptions = Object.assign(Object.assign({}, options), { initialManifest: manifest });
        newOptions.startAt = { position: startAtPositon };
        this._priv_initializeContentPlayback(newOptions);
    }
    /**
     * From given options, initialize content playback.
     * @param {Object} options
     */
    _priv_initializeContentPlayback(options) {
        var _a, _b, _c;
        const { autoPlay, audioTrackSwitchingMode, defaultAudioTrack, defaultTextTrack, enableFastSwitching, initialManifest, keySystems, lowLatencyMode, manualBitrateSwitchingMode, minimumManifestUpdateInterval, networkConfig, onCodecSwitch, startAt, transport, transportOptions, url } = options;
        // Perform multiple checks on the given options
        if (this.videoElement === null) {
            throw new Error("the attached video element is disposed");
        }
        const isDirectFile = transport === "directfile";
        /** Subject which will emit to stop the current content. */
        const stopContent$ = new Subject/* Subject */.xQ();
        /** Future `this._priv_contentInfos` related to this content. */
        const contentInfos = { url,
            stop$: stopContent$,
            isDirectFile,
            segmentBuffersStore: null,
            thumbnails: null,
            manifest: null,
            currentPeriod: null,
            activeAdaptations: null,
            activeRepresentations: null,
            initialAudioTrack: defaultAudioTrack,
            initialTextTrack: defaultTextTrack };
        const videoElement = this.videoElement;
        /** Global "clock" used for content playback */
        const { setCurrentTime, clock$ } = clock(videoElement, {
            withMediaSource: !isDirectFile,
            lowLatencyMode,
        });
        /** Emit playback events. */
        let playback$;
        if (!isDirectFile) {
            const transportFn = features/* default.transports */.Z.transports[transport];
            if (typeof transportFn !== "function") {
                // Stop previous content and reset its state
                this.stop();
                this._priv_currentError = null;
                this._priv_playing$.next(false);
                throw new Error(`transport "${transport}" not supported`);
            }
            const transportPipelines = transportFn(transportOptions);
            const { offlineRetry, segmentRetry, manifestRetry } = networkConfig;
            /** Interface used to load and refresh the Manifest. */
            const manifestFetcher = new fetchers_manifest(url, transportPipelines, { lowLatencyMode,
                maxRetryRegular: manifestRetry,
                maxRetryOffline: offlineRetry });
            /** Interface used to download segments. */
            const segmentFetcherCreator = new segment(transportPipelines, { lowLatencyMode,
                maxRetryOffline: offlineRetry,
                maxRetryRegular: segmentRetry });
            /** Observable emitting the initial Manifest */
            let manifest$;
            if (initialManifest instanceof manifest/* default */.ZP) {
                manifest$ = (0,of.of)({ type: "parsed",
                    manifest: initialManifest });
            }
            else if (initialManifest !== undefined) {
                manifest$ = manifestFetcher.parse(initialManifest, { previousManifest: null,
                    unsafeMode: false });
            }
            else {
                manifest$ = manifestFetcher.fetch(url).pipe((0,mergeMap/* mergeMap */.zg)((response) => response.type === "warning" ?
                    (0,of.of)(response) : // bubble-up warnings
                    response.parse({ previousManifest: null, unsafeMode: false })));
            }
            // Load the Manifest right now and share it with every subscriber until
            // the content is stopped
            manifest$ = manifest$.pipe((0,takeUntil/* takeUntil */.R)(stopContent$), (0,shareReplay/* shareReplay */.d)());
            manifest$.subscribe();
            // now that the Manifest is loading, stop previous content and reset state
            // This is done after fetching the Manifest as `stop` could technically
            // take time.
            this.stop();
            this._priv_currentError = null;
            this._priv_playing$.next(false);
            this._priv_contentInfos = contentInfos;
            const relyOnVideoVisibilityAndSize = canRelyOnVideoVisibilityAndSize();
            const throttlers = { throttle: {},
                throttleBitrate: {},
                limitWidth: {} };
            if (this._priv_throttleWhenHidden) {
                if (!relyOnVideoVisibilityAndSize) {
                    log/* default.warn */.Z.warn("API: Can't apply throttleWhenHidden because " +
                        "browser can't be trusted for visibility.");
                }
                else {
                    throttlers.throttle = {
                        video: isActive().pipe((0,map/* map */.U)(active => active ? Infinity :
                            0), (0,takeUntil/* takeUntil */.R)(stopContent$)),
                    };
                }
            }
            if (this._priv_throttleVideoBitrateWhenHidden) {
                if (!relyOnVideoVisibilityAndSize) {
                    log/* default.warn */.Z.warn("API: Can't apply throttleVideoBitrateWhenHidden because " +
                        "browser can't be trusted for visibility.");
                }
                else {
                    throttlers.throttleBitrate = {
                        video: isVideoVisible(this._priv_pictureInPictureEvent$).pipe((0,map/* map */.U)(active => active ? Infinity :
                            0), (0,takeUntil/* takeUntil */.R)(stopContent$)),
                    };
                }
            }
            if (this._priv_limitVideoWidth) {
                if (!relyOnVideoVisibilityAndSize) {
                    log/* default.warn */.Z.warn("API: Can't apply limitVideoWidth because browser can't be " +
                        "trusted for video size.");
                }
                else {
                    throttlers.limitWidth = {
                        video: videoWidth$(videoElement, this._priv_pictureInPictureEvent$)
                            .pipe((0,takeUntil/* takeUntil */.R)(stopContent$)),
                    };
                }
            }
            /** Options used by the ABR Manager. */
            const adaptiveOptions = {
                initialBitrates: this._priv_bitrateInfos.lastBitrates,
                lowLatencyMode,
                manualBitrates: this._priv_bitrateInfos.manualBitrates,
                minAutoBitrates: this._priv_bitrateInfos.minAutoBitrates,
                maxAutoBitrates: this._priv_bitrateInfos.maxAutoBitrates,
                throttlers,
            };
            /** Options used by the TextTrack SegmentBuffer. */
            const textTrackOptions = options.textTrackMode === "native" ?
                { textTrackMode: "native", hideNativeSubtitle: options.hideNativeSubtitle } :
                { textTrackMode: "html", textTrackElement: options.textTrackElement };
            const bufferOptions = (0,object_assign/* default */.Z)({ audioTrackSwitchingMode,
                enableFastSwitching,
                manualBitrateSwitchingMode,
                onCodecSwitch }, this._priv_bufferOptions);
            // We've every options set up. Start everything now
            const init$ = init({ adaptiveOptions,
                autoPlay,
                bufferOptions,
                clock$,
                keySystems,
                lowLatencyMode,
                manifest$,
                manifestFetcher,
                mediaElement: videoElement,
                minimumManifestUpdateInterval,
                segmentFetcherCreator,
                setCurrentTime,
                speed$: this._priv_speed$,
                startAt,
                textTrackOptions })
                .pipe((0,takeUntil/* takeUntil */.R)(stopContent$));
            playback$ = publish()(init$);
        }
        else {
            // Stop previous content and reset its state
            this.stop();
            this._priv_currentError = null;
            this._priv_playing$.next(false);
            if (features/* default.directfile */.Z.directfile === null) {
                throw new Error("DirectFile feature not activated in your build.");
            }
            this._priv_contentInfos = contentInfos;
            this._priv_mediaElementTrackChoiceManager =
                new features/* default.directfile.mediaElementTrackChoiceManager */.Z.directfile.mediaElementTrackChoiceManager(this.videoElement);
            const preferredAudioTracks = defaultAudioTrack === undefined ?
                this._priv_preferredAudioTracks :
                [defaultAudioTrack];
            this._priv_mediaElementTrackChoiceManager
                .setPreferredAudioTracks(preferredAudioTracks, true);
            const preferredTextTracks = defaultTextTrack === undefined ?
                this._priv_preferredTextTracks :
                [defaultTextTrack];
            this._priv_mediaElementTrackChoiceManager
                .setPreferredTextTracks(preferredTextTracks, true);
            this._priv_mediaElementTrackChoiceManager
                .setPreferredVideoTracks(this._priv_preferredVideoTracks, true);
            this.trigger("availableAudioTracksChange", this._priv_mediaElementTrackChoiceManager.getAvailableAudioTracks());
            this.trigger("availableVideoTracksChange", this._priv_mediaElementTrackChoiceManager.getAvailableVideoTracks());
            this.trigger("availableTextTracksChange", this._priv_mediaElementTrackChoiceManager.getAvailableTextTracks());
            this.trigger("audioTrackChange", (_a = this._priv_mediaElementTrackChoiceManager.getChosenAudioTrack()) !== null && _a !== void 0 ? _a : null);
            this.trigger("textTrackChange", (_b = this._priv_mediaElementTrackChoiceManager.getChosenTextTrack()) !== null && _b !== void 0 ? _b : null);
            this.trigger("videoTrackChange", (_c = this._priv_mediaElementTrackChoiceManager.getChosenVideoTrack()) !== null && _c !== void 0 ? _c : null);
            this._priv_mediaElementTrackChoiceManager
                .addEventListener("availableVideoTracksChange", (val) => this.trigger("availableVideoTracksChange", val));
            this._priv_mediaElementTrackChoiceManager
                .addEventListener("availableAudioTracksChange", (val) => this.trigger("availableAudioTracksChange", val));
            this._priv_mediaElementTrackChoiceManager
                .addEventListener("availableTextTracksChange", (val) => this.trigger("availableTextTracksChange", val));
            this._priv_mediaElementTrackChoiceManager
                .addEventListener("audioTrackChange", (val) => this.trigger("audioTrackChange", val));
            this._priv_mediaElementTrackChoiceManager
                .addEventListener("videoTrackChange", (val) => this.trigger("videoTrackChange", val));
            this._priv_mediaElementTrackChoiceManager
                .addEventListener("textTrackChange", (val) => this.trigger("textTrackChange", val));
            const directfileInit$ = features/* default.directfile.initDirectFile */.Z.directfile.initDirectFile({ autoPlay,
                clock$,
                keySystems,
                mediaElement: videoElement,
                speed$: this._priv_speed$,
                startAt,
                setCurrentTime,
                url })
                .pipe((0,takeUntil/* takeUntil */.R)(stopContent$));
            playback$ = publish()(directfileInit$);
        }
        /** Emit an object when the player "stalls" and null when it un-stalls */
        const stalled$ = playback$.pipe((0,filter/* filter */.h)((evt) => evt.type === "stalled" ||
            evt.type === "unstalled"), (0,map/* map */.U)(x => x.value), (0,distinctUntilChanged/* distinctUntilChanged */.x)((wasStalled, isStalled) => {
            return wasStalled === null && isStalled === null ||
                (wasStalled !== null && isStalled !== null &&
                    wasStalled.reason === isStalled.reason);
        }));
        /** Emit when the content is considered "loaded". */
        const loaded$ = playback$.pipe((0,filter/* filter */.h)((evt) => evt.type === "loaded"), (0,share/* share */.B)());
        /** Emit when we will "reload" the MediaSource. */
        const reloading$ = playback$
            .pipe((0,filter/* filter */.h)((evt) => evt.type === "reloading-media-source"), (0,share/* share */.B)());
        /** Emit when the media element emits an "ended" event. */
        const endedEvent$ = onEnded$(videoElement);
        /** Emit when the media element emits a "seeking" event. */
        const seekingEvent$ = onSeeking$(videoElement);
        /** Emit state updates once the content is considered "loaded". */
        const loadedStateUpdates$ = (0,combineLatest/* combineLatest */.aj)([
            this._priv_playing$,
            stalled$.pipe((0,startWith/* startWith */.O)(null)),
            endedEvent$.pipe((0,startWith/* startWith */.O)(null)),
            seekingEvent$.pipe((0,startWith/* startWith */.O)(null)),
        ]).pipe((0,takeUntil/* takeUntil */.R)(stopContent$), (0,map/* map */.U)(([isPlaying, stalledStatus]) => getLoadedContentState(videoElement, isPlaying, stalledStatus)));
        /** Emit all player "state" updates. */
        const playerState$ = (0,concat/* concat */.z)((0,of.of)(PLAYER_STATES.LOADING), // Begin with LOADING
        // LOADED as soon as the first "loaded" event is sent
        loaded$.pipe((0,take/* take */.q)(1), (0,mapTo/* mapTo */.h)(PLAYER_STATES.LOADED)), (0,merge/* merge */.T)(loadedStateUpdates$
            .pipe(
        // From the first reload onward, we enter another dynamic (below)
        (0,takeUntil/* takeUntil */.R)(reloading$), skipWhile(state => state === PLAYER_STATES.PAUSED)), 
        // when reloading
        reloading$.pipe((0,switchMapTo/* switchMapTo */.c)(loaded$.pipe((0,take/* take */.q)(1), // wait for the next loaded event
        (0,mergeMapTo/* mergeMapTo */.j)(loadedStateUpdates$), // to update the state as usual
        (0,startWith/* startWith */.O)(PLAYER_STATES.RELOADING) // Starts with "RELOADING" state
        ))))).pipe((0,distinctUntilChanged/* distinctUntilChanged */.x)());
        let playbackSubscription;
        stopContent$
            .pipe((0,take/* take */.q)(1))
            .subscribe(() => {
            if (playbackSubscription !== undefined) {
                playbackSubscription.unsubscribe();
            }
        });
        // Link `_priv_onPlayPauseNext` Observable to "play"/"pause" events
        onPlayPause$(videoElement)
            .pipe((0,takeUntil/* takeUntil */.R)(stopContent$))
            .subscribe(e => this._priv_onPlayPauseNext(e.type === "play"), noop/* default */.Z);
        // Link "positionUpdate" events to the clock
        clock$
            .pipe((0,takeUntil/* takeUntil */.R)(stopContent$))
            .subscribe(x => this._priv_triggerPositionUpdate(x), noop/* default */.Z);
        // Link "seeking" and "seeked" events (once the content is loaded)
        loaded$.pipe((0,switchMapTo/* switchMapTo */.c)(emitSeekEvents(this.videoElement, clock$)), (0,takeUntil/* takeUntil */.R)(stopContent$)).subscribe((evt) => {
            log/* default.info */.Z.info(`API: Triggering "${evt}" event`);
            this.trigger(evt, null);
        });
        // Handle state updates
        playerState$
            .pipe((0,takeUntil/* takeUntil */.R)(stopContent$))
            .subscribe(x => this._priv_setPlayerState(x), noop/* default */.Z);
        (this._priv_stopAtEnd ? onEnded$(videoElement) :
            empty/* EMPTY */.E)
            .pipe((0,takeUntil/* takeUntil */.R)(stopContent$))
            .subscribe(() => {
            stopContent$.next();
            stopContent$.complete();
        });
        // Link playback events to the corresponding callbacks
        playback$.subscribe((x) => this._priv_onPlaybackEvent(x), (err) => this._priv_onPlaybackError(err), () => this._priv_onPlaybackFinished());
        // initialize the content only when the lock is inactive
        this._priv_contentLock$
            .pipe((0,filter/* filter */.h)((isLocked) => !isLocked), (0,take/* take */.q)(1), (0,takeUntil/* takeUntil */.R)(stopContent$))
            .subscribe(() => {
            // start playback!
            playbackSubscription = playback$.connect();
        });
    }
    /**
     * Returns fatal error if one for the current content.
     * null otherwise.
     * @returns {Object|null} - The current Error (`null` when no error).
     */
    getError() {
        return this._priv_currentError;
    }
    /**
     * Returns manifest/playlist object.
     * null if the player is STOPPED.
     * @deprecated
     * @returns {Manifest|null} - The current Manifest (`null` when not known).
     */
    getManifest() {
        (0,warn_once/* default */.Z)("getManifest is deprecated." +
            " Please open an issue if you used this API.");
        if (this._priv_contentInfos === null) {
            return null;
        }
        return this._priv_contentInfos.manifest;
    }
    /**
     * Returns Adaptations (tracks) for every currently playing type
     * (audio/video/text...).
     * @deprecated
     * @returns {Object|null} - The current Adaptation objects, per type (`null`
     * when none is known for now.
     */
    getCurrentAdaptations() {
        (0,warn_once/* default */.Z)("getCurrentAdaptations is deprecated." +
            " Please open an issue if you used this API.");
        if (this._priv_contentInfos === null) {
            return null;
        }
        const { currentPeriod, activeAdaptations } = this._priv_contentInfos;
        if (currentPeriod === null ||
            activeAdaptations === null ||
            (0,is_null_or_undefined/* default */.Z)(activeAdaptations[currentPeriod.id])) {
            return null;
        }
        return activeAdaptations[currentPeriod.id];
    }
    /**
     * Returns representations (qualities) for every currently playing type
     * (audio/video/text...).
     * @deprecated
     * @returns {Object|null} - The current Representation objects, per type
     * (`null` when none is known for now.
     */
    getCurrentRepresentations() {
        (0,warn_once/* default */.Z)("getCurrentRepresentations is deprecated." +
            " Please open an issue if you used this API.");
        return this._priv_getCurrentRepresentations();
    }
    /**
     * Returns the media DOM element used by the player.
     * You should not its HTML5 API directly and use the player's method instead,
     * to ensure a well-behaved player.
     * @returns {HTMLMediaElement|null} - The HTMLMediaElement used (`null` when
     * disposed)
     */
    getVideoElement() {
        return this.videoElement;
    }
    /**
     * If one returns the first native text-track element attached to the media element.
     * @deprecated
     * @returns {TextTrack} - The native TextTrack attached (`null` when none)
     */
    getNativeTextTrack() {
        (0,warn_once/* default */.Z)("getNativeTextTrack is deprecated." +
            " Please open an issue if you used this API.");
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        const videoElement = this.videoElement;
        const textTracks = videoElement.textTracks;
        if (textTracks.length > 0) {
            return videoElement.textTracks[0];
        }
        else {
            return null;
        }
    }
    /**
     * Returns the player's current state.
     * @returns {string} - The current Player's state
     */
    getPlayerState() {
        return this.state;
    }
    /**
     * Returns true if both:
     *   - a content is loaded
     *   - the content loaded is a live content
     * @returns {Boolean} - `true` if we're playing a live content, `false` otherwise.
     */
    isLive() {
        if (this._priv_contentInfos === null) {
            return false;
        }
        const { isDirectFile, manifest } = this._priv_contentInfos;
        if (isDirectFile || manifest === null) {
            return false;
        }
        return manifest.isLive;
    }
    /**
     * Returns the url of the content's manifest
     * @returns {string|undefined} - Current URL. `undefined` if not known or no
     * URL yet.
     */
    getUrl() {
        if (this._priv_contentInfos === null) {
            return undefined;
        }
        const { isDirectFile, manifest, url } = this._priv_contentInfos;
        if (isDirectFile) {
            return url;
        }
        if (manifest !== null) {
            return manifest.getUrl();
        }
        return undefined;
    }
    /**
     * Returns the video duration, in seconds.
     * NaN if no video is playing.
     * @returns {Number}
     */
    getVideoDuration() {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        return this.videoElement.duration;
    }
    /**
     * Returns in seconds the difference between:
     *   - the end of the current contiguous loaded range.
     *   - the current time
     * @returns {Number}
     */
    getVideoBufferGap() {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        const videoElement = this.videoElement;
        return (0,ranges/* getLeftSizeOfRange */.L7)(videoElement.buffered, videoElement.currentTime);
    }
    /**
     * Returns in seconds the difference between:
     *   - the end of the current contiguous loaded range.
     *   - the start of the current contiguous loaded range.
     * @returns {Number}
     */
    getVideoLoadedTime() {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        const videoElement = this.videoElement;
        return (0,ranges/* getSizeOfRange */.at)(videoElement.buffered, videoElement.currentTime);
    }
    /**
     * Returns in seconds the difference between:
     *   - the current time.
     *   - the start of the current contiguous loaded range.
     * @returns {Number}
     */
    getVideoPlayedTime() {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        const videoElement = this.videoElement;
        return (0,ranges/* getPlayedSizeOfRange */.DD)(videoElement.buffered, videoElement.currentTime);
    }
    /**
     * Get the current position, in s, in wall-clock time.
     * That is:
     *   - for live content, get a timestamp, in s, of the current played content.
     *   - for static content, returns the position from beginning in s.
     *
     * If you do not know if you want to use this method or getPosition:
     *   - If what you want is to display the current time to the user, use this
     *     one.
     *   - If what you want is to interact with the player's API or perform other
     *     actions (like statistics) with the real player data, use getPosition.
     *
     * @returns {Number}
     */
    getWallClockTime() {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        if (this._priv_contentInfos === null) {
            return this.videoElement.currentTime;
        }
        const { isDirectFile, manifest } = this._priv_contentInfos;
        if (isDirectFile) {
            return this.videoElement.currentTime;
        }
        if (manifest !== null) {
            const currentTime = this.videoElement.currentTime;
            const ast = manifest.availabilityStartTime !== undefined ?
                manifest.availabilityStartTime :
                0;
            return currentTime + ast;
        }
        return 0;
    }
    /**
     * Get the current position, in seconds, of the video element.
     *
     * If you do not know if you want to use this method or getWallClockTime:
     *   - If what you want is to display the current time to the user, use
     *     getWallClockTime.
     *   - If what you want is to interact with the player's API or perform other
     *     actions (like statistics) with the real player data, use this one.
     *
     * @returns {Number}
     */
    getPosition() {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        return this.videoElement.currentTime;
    }
    /**
     * Returns the current speed at which the video plays.
     * @returns {Number}
     */
    getPlaybackRate() {
        return this._priv_speed$.getValue();
    }
    /**
     * Update the playback rate of the video.
     * @param {Number} rate
     */
    setPlaybackRate(rate) {
        this._priv_speed$.next(rate);
    }
    /**
     * Returns all available bitrates for the current video Adaptation.
     * @returns {Array.<Number>}
     */
    getAvailableVideoBitrates() {
        if (this._priv_contentInfos === null) {
            return [];
        }
        const { currentPeriod, activeAdaptations } = this._priv_contentInfos;
        if (currentPeriod === null || activeAdaptations === null) {
            return [];
        }
        const adaptations = activeAdaptations[currentPeriod.id];
        if (adaptations === undefined || (0,is_null_or_undefined/* default */.Z)(adaptations.video)) {
            return [];
        }
        return adaptations.video.getAvailableBitrates();
    }
    /**
     * Returns all available bitrates for the current audio Adaptation.
     * @returns {Array.<Number>}
     */
    getAvailableAudioBitrates() {
        if (this._priv_contentInfos === null) {
            return [];
        }
        const { currentPeriod, activeAdaptations } = this._priv_contentInfos;
        if (currentPeriod === null || activeAdaptations === null) {
            return [];
        }
        const adaptations = activeAdaptations[currentPeriod.id];
        if (adaptations === undefined || (0,is_null_or_undefined/* default */.Z)(adaptations.audio)) {
            return [];
        }
        return adaptations.audio.getAvailableBitrates();
    }
    /**
     * Returns the manual audio bitrate set. -1 if in AUTO mode.
     * @returns {Number}
     */
    getManualAudioBitrate() {
        return this._priv_bitrateInfos.manualBitrates.audio.getValue();
    }
    /**
     * Returns the manual video bitrate set. -1 if in AUTO mode.
     * @returns {Number}
     */
    getManualVideoBitrate() {
        return this._priv_bitrateInfos.manualBitrates.video.getValue();
    }
    /**
     * Returns currently considered bitrate for video segments.
     * @returns {Number|undefined}
     */
    getVideoBitrate() {
        const representations = this._priv_getCurrentRepresentations();
        if (representations === null || (0,is_null_or_undefined/* default */.Z)(representations.video)) {
            return undefined;
        }
        return representations.video.bitrate;
    }
    /**
     * Returns currently considered bitrate for audio segments.
     * @returns {Number|undefined}
     */
    getAudioBitrate() {
        const representations = this._priv_getCurrentRepresentations();
        if (representations === null || (0,is_null_or_undefined/* default */.Z)(representations.audio)) {
            return undefined;
        }
        return representations.audio.bitrate;
    }
    /**
     * Returns minimum wanted video bitrate currently set.
     * @returns {Number}
     */
    getMinVideoBitrate() {
        return this._priv_bitrateInfos.minAutoBitrates.video.getValue();
    }
    /**
     * Returns minimum wanted audio bitrate currently set.
     * @returns {Number}
     */
    getMinAudioBitrate() {
        return this._priv_bitrateInfos.minAutoBitrates.audio.getValue();
    }
    /**
     * Returns maximum wanted video bitrate currently set.
     * @returns {Number}
     */
    getMaxVideoBitrate() {
        return this._priv_bitrateInfos.maxAutoBitrates.video.getValue();
    }
    /**
     * Returns maximum wanted audio bitrate currently set.
     * @returns {Number}
     */
    getMaxAudioBitrate() {
        return this._priv_bitrateInfos.maxAutoBitrates.audio.getValue();
    }
    /**
     * Play/Resume the current video.
     * @returns {Promise}
     */
    play() {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        const playPromise = this.videoElement.play();
        /* eslint-disable @typescript-eslint/unbound-method */
        if ((0,is_null_or_undefined/* default */.Z)(playPromise) || typeof playPromise.catch !== "function") {
            /* eslint-enable @typescript-eslint/unbound-method */
            return promise/* default.resolve */.Z.resolve();
        }
        return playPromise.catch((error) => {
            if (error.name === "NotAllowedError") {
                const warning = new media_error/* default */.Z("MEDIA_ERR_PLAY_NOT_ALLOWED", error.toString());
                this.trigger("warning", warning);
            }
            throw error;
        });
    }
    /**
     * Pause the current video.
     */
    pause() {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        this.videoElement.pause();
    }
    /**
     * Seek to a given absolute position.
     * @param {Number|Object} time
     * @returns {Number} - The time the player has seek to
     */
    seekTo(time) {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        if (this._priv_contentInfos === null) {
            throw new Error("player: no content loaded");
        }
        const { isDirectFile, manifest } = this._priv_contentInfos;
        if (!isDirectFile && manifest === null) {
            throw new Error("player: the content did not load yet");
        }
        let positionWanted;
        if (typeof time === "number") {
            positionWanted = time;
        }
        else if (typeof time === "object") {
            const timeObj = time;
            const currentTs = this.videoElement.currentTime;
            if (!(0,is_null_or_undefined/* default */.Z)(timeObj.relative)) {
                positionWanted = currentTs + timeObj.relative;
            }
            else if (!(0,is_null_or_undefined/* default */.Z)(timeObj.position)) {
                positionWanted = timeObj.position;
            }
            else if (!(0,is_null_or_undefined/* default */.Z)(timeObj.wallClockTime)) {
                positionWanted = (isDirectFile || manifest === null) ?
                    timeObj.wallClockTime :
                    timeObj.wallClockTime - (manifest.availabilityStartTime !== undefined ?
                        manifest.availabilityStartTime :
                        0);
            }
            else {
                throw new Error("invalid time object. You must set one of the " +
                    "following properties: \"relative\", \"position\" or " +
                    "\"wallClockTime\"");
            }
        }
        if (positionWanted === undefined) {
            throw new Error("invalid time given");
        }
        this.videoElement.currentTime = positionWanted;
        return positionWanted;
    }
    /**
     * Returns true if the media element is full screen.
     * @deprecated
     * @returns {Boolean}
     */
    isFullscreen() {
        (0,warn_once/* default */.Z)("isFullscreen is deprecated." +
            " Fullscreen management should now be managed by the application");
        return isFullscreen();
    }
    /**
     * Set/exit fullScreen.
     * @deprecated
     * @param {Boolean} [goFull=true] - if false, exit full screen.
     */
    setFullscreen(goFull = true) {
        (0,warn_once/* default */.Z)("setFullscreen is deprecated." +
            " Fullscreen management should now be managed by the application");
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        if (goFull) {
            requestFullscreen(this.videoElement);
        }
        else {
            exitFullscreen();
        }
    }
    /**
     * Exit from full screen mode.
     * @deprecated
     */
    exitFullscreen() {
        (0,warn_once/* default */.Z)("exitFullscreen is deprecated." +
            " Fullscreen management should now be managed by the application");
        exitFullscreen();
    }
    /**
     * Returns the current player's audio volume on the media element.
     * From 0 (no audio) to 1 (maximum volume).
     * @returns {Number}
     */
    getVolume() {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        return this.videoElement.volume;
    }
    /**
     * Set the player's audio volume. From 0 (no volume) to 1 (maximum volume).
     * @param {Number} volume
     */
    setVolume(volume) {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        const videoElement = this.videoElement;
        if (volume !== videoElement.volume) {
            videoElement.volume = volume;
            this.trigger("volumeChange", volume);
        }
    }
    /**
     * Returns true if the volume is set to 0. false otherwise.
     * @returns {Boolean}
     */
    isMute() {
        return this.getVolume() === 0;
    }
    /**
     * Set the volume to 0 and save current one for when unmuted.
     */
    mute() {
        this._priv_mutedMemory = this.getVolume();
        this.setVolume(0);
    }
    /**
     * Set the volume back to when it was when mute was last called.
     * If the volume was set to 0, set a default volume instead (see config).
     */
    unMute() {
        const vol = this.getVolume();
        if (vol === 0) {
            this.setVolume(this._priv_mutedMemory === 0 ? DEFAULT_UNMUTED_VOLUME :
                this._priv_mutedMemory);
        }
    }
    /**
     * Force the video bitrate to a given value. Act as a ceil.
     * -1 to set it on AUTO Mode
     * @param {Number} btr
     */
    setVideoBitrate(btr) {
        this._priv_bitrateInfos.manualBitrates.video.next(btr);
    }
    /**
     * Force the audio bitrate to a given value. Act as a ceil.
     * -1 to set it on AUTO Mode
     * @param {Number} btr
     */
    setAudioBitrate(btr) {
        this._priv_bitrateInfos.manualBitrates.audio.next(btr);
    }
    /**
     * Update the minimum video bitrate the user can switch to.
     * @param {Number} btr
     */
    setMinVideoBitrate(btr) {
        const maxVideoBitrate = this._priv_bitrateInfos.maxAutoBitrates.video.getValue();
        if (btr > maxVideoBitrate) {
            throw new Error("Invalid minimum video bitrate given. " +
                `Its value, "${btr}" is superior the current maximum ` +
                `video birate, "${maxVideoBitrate}".`);
        }
        this._priv_bitrateInfos.minAutoBitrates.video.next(btr);
    }
    /**
     * Update the minimum audio bitrate the user can switch to.
     * @param {Number} btr
     */
    setMinAudioBitrate(btr) {
        const maxAudioBitrate = this._priv_bitrateInfos.maxAutoBitrates.audio.getValue();
        if (btr > maxAudioBitrate) {
            throw new Error("Invalid minimum audio bitrate given. " +
                `Its value, "${btr}" is superior the current maximum ` +
                `audio birate, "${maxAudioBitrate}".`);
        }
        this._priv_bitrateInfos.minAutoBitrates.audio.next(btr);
    }
    /**
     * Update the maximum video bitrate the user can switch to.
     * @param {Number} btr
     */
    setMaxVideoBitrate(btr) {
        const minVideoBitrate = this._priv_bitrateInfos.minAutoBitrates.video.getValue();
        if (btr < minVideoBitrate) {
            throw new Error("Invalid maximum video bitrate given. " +
                `Its value, "${btr}" is inferior the current minimum ` +
                `video birate, "${minVideoBitrate}".`);
        }
        this._priv_bitrateInfos.maxAutoBitrates.video.next(btr);
    }
    /**
     * Update the maximum audio bitrate the user can switch to.
     * @param {Number} btr
     */
    setMaxAudioBitrate(btr) {
        const minAudioBitrate = this._priv_bitrateInfos.minAutoBitrates.audio.getValue();
        if (btr < minAudioBitrate) {
            throw new Error("Invalid maximum audio bitrate given. " +
                `Its value, "${btr}" is inferior the current minimum ` +
                `audio birate, "${minAudioBitrate}".`);
        }
        this._priv_bitrateInfos.maxAutoBitrates.audio.next(btr);
    }
    /**
     * Set the max buffer size for the buffer behind the current position.
     * Every buffer data before will be removed.
     * @param {Number} depthInSeconds
     */
    setMaxBufferBehind(depthInSeconds) {
        this._priv_bufferOptions.maxBufferBehind$.next(depthInSeconds);
    }
    /**
     * Set the max buffer size for the buffer behind the current position.
     * Every buffer data before will be removed.
     * @param {Number} depthInSeconds
     */
    setMaxBufferAhead(depthInSeconds) {
        this._priv_bufferOptions.maxBufferAhead$.next(depthInSeconds);
    }
    /**
     * Set the max buffer size for the buffer ahead of the current position.
     * The player will stop downloading chunks when this size is reached.
     * @param {Number} sizeInSeconds
     */
    setWantedBufferAhead(sizeInSeconds) {
        this._priv_bufferOptions.wantedBufferAhead$.next(sizeInSeconds);
    }
    /**
     * Returns the max buffer size for the buffer behind the current position.
     * @returns {Number}
     */
    getMaxBufferBehind() {
        return this._priv_bufferOptions.maxBufferBehind$.getValue();
    }
    /**
     * Returns the max buffer size for the buffer behind the current position.
     * @returns {Number}
     */
    getMaxBufferAhead() {
        return this._priv_bufferOptions.maxBufferAhead$.getValue();
    }
    /**
     * Returns the max buffer size for the buffer ahead of the current position.
     * @returns {Number}
     */
    getWantedBufferAhead() {
        return this._priv_bufferOptions.wantedBufferAhead$.getValue();
    }
    /**
     * Returns type of current keysystem (e.g. playready, widevine) if the content
     * is encrypted. null otherwise.
     * @returns {string|null}
     */
    getCurrentKeySystem() {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        return getCurrentKeySystem(this.videoElement);
    }
    /**
     * Returns every available audio tracks for the current Period.
     * @returns {Array.<Object>|null}
     */
    getAvailableAudioTracks() {
        var _a, _b;
        if (this._priv_contentInfos === null) {
            return [];
        }
        const { currentPeriod, isDirectFile } = this._priv_contentInfos;
        if (isDirectFile) {
            return (_b = (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.getAvailableAudioTracks()) !== null && _b !== void 0 ? _b : [];
        }
        if (this._priv_trackChoiceManager === null || currentPeriod === null) {
            return [];
        }
        return this._priv_trackChoiceManager.getAvailableAudioTracks(currentPeriod);
    }
    /**
     * Returns every available text tracks for the current Period.
     * @returns {Array.<Object>|null}
     */
    getAvailableTextTracks() {
        var _a, _b;
        if (this._priv_contentInfos === null) {
            return [];
        }
        const { currentPeriod, isDirectFile } = this._priv_contentInfos;
        if (isDirectFile) {
            return (_b = (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.getAvailableTextTracks()) !== null && _b !== void 0 ? _b : [];
        }
        if (this._priv_trackChoiceManager === null || currentPeriod === null) {
            return [];
        }
        return this._priv_trackChoiceManager.getAvailableTextTracks(currentPeriod);
    }
    /**
     * Returns every available video tracks for the current Period.
     * @returns {Array.<Object>|null}
     */
    getAvailableVideoTracks() {
        var _a, _b;
        if (this._priv_contentInfos === null) {
            return [];
        }
        const { currentPeriod, isDirectFile } = this._priv_contentInfos;
        if (isDirectFile) {
            return (_b = (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.getAvailableVideoTracks()) !== null && _b !== void 0 ? _b : [];
        }
        if (this._priv_trackChoiceManager === null || currentPeriod === null) {
            return [];
        }
        return this._priv_trackChoiceManager.getAvailableVideoTracks(currentPeriod);
    }
    /**
     * Returns currently chosen audio language for the current Period.
     * @returns {string}
     */
    getAudioTrack() {
        if (this._priv_contentInfos === null) {
            return undefined;
        }
        const { currentPeriod, isDirectFile } = this._priv_contentInfos;
        if (isDirectFile) {
            if (this._priv_mediaElementTrackChoiceManager === null) {
                return undefined;
            }
            return this._priv_mediaElementTrackChoiceManager.getChosenAudioTrack();
        }
        if (this._priv_trackChoiceManager === null || currentPeriod === null) {
            return undefined;
        }
        return this._priv_trackChoiceManager.getChosenAudioTrack(currentPeriod);
    }
    /**
     * Returns currently chosen subtitle for the current Period.
     * @returns {string}
     */
    getTextTrack() {
        if (this._priv_contentInfos === null) {
            return undefined;
        }
        const { currentPeriod, isDirectFile } = this._priv_contentInfos;
        if (isDirectFile) {
            if (this._priv_mediaElementTrackChoiceManager === null) {
                return undefined;
            }
            return this._priv_mediaElementTrackChoiceManager.getChosenTextTrack();
        }
        if (this._priv_trackChoiceManager === null || currentPeriod === null) {
            return undefined;
        }
        return this._priv_trackChoiceManager.getChosenTextTrack(currentPeriod);
    }
    /**
     * Returns currently chosen video track for the current Period.
     * @returns {string}
     */
    getVideoTrack() {
        if (this._priv_contentInfos === null) {
            return undefined;
        }
        const { currentPeriod, isDirectFile } = this._priv_contentInfos;
        if (isDirectFile) {
            if (this._priv_mediaElementTrackChoiceManager === null) {
                return undefined;
            }
            return this._priv_mediaElementTrackChoiceManager.getChosenVideoTrack();
        }
        if (this._priv_trackChoiceManager === null || currentPeriod === null) {
            return undefined;
        }
        return this._priv_trackChoiceManager.getChosenVideoTrack(currentPeriod);
    }
    /**
     * Update the audio language for the current Period.
     * @param {string} audioId
     * @throws Error - the current content has no TrackChoiceManager.
     * @throws Error - the given id is linked to no audio track.
     */
    setAudioTrack(audioId) {
        var _a;
        if (this._priv_contentInfos === null) {
            throw new Error("No content loaded");
        }
        const { currentPeriod, isDirectFile } = this._priv_contentInfos;
        if (isDirectFile) {
            try {
                (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.setAudioTrackById(audioId);
                return;
            }
            catch (e) {
                throw new Error("player: unknown audio track");
            }
        }
        if (this._priv_trackChoiceManager === null || currentPeriod === null) {
            throw new Error("No compatible content launched.");
        }
        try {
            this._priv_trackChoiceManager.setAudioTrackByID(currentPeriod, audioId);
        }
        catch (e) {
            throw new Error("player: unknown audio track");
        }
    }
    /**
     * Update the text language for the current Period.
     * @param {string} sub
     * @throws Error - the current content has no TrackChoiceManager.
     * @throws Error - the given id is linked to no text track.
     */
    setTextTrack(textId) {
        var _a;
        if (this._priv_contentInfos === null) {
            throw new Error("No content loaded");
        }
        const { currentPeriod, isDirectFile } = this._priv_contentInfos;
        if (isDirectFile) {
            try {
                (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.setTextTrackById(textId);
                return;
            }
            catch (e) {
                throw new Error("player: unknown text track");
            }
        }
        if (this._priv_trackChoiceManager === null || currentPeriod === null) {
            throw new Error("No compatible content launched.");
        }
        try {
            this._priv_trackChoiceManager.setTextTrackByID(currentPeriod, textId);
        }
        catch (e) {
            throw new Error("player: unknown text track");
        }
    }
    /**
     * Disable subtitles for the current content.
     */
    disableTextTrack() {
        var _a;
        if (this._priv_contentInfos === null) {
            return;
        }
        const { currentPeriod, isDirectFile } = this._priv_contentInfos;
        if (isDirectFile) {
            (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.disableTextTrack();
            return;
        }
        if (this._priv_trackChoiceManager === null || currentPeriod === null) {
            return;
        }
        return this._priv_trackChoiceManager.disableTextTrack(currentPeriod);
    }
    /**
     * Update the video track for the current Period.
     * @param {string} videoId
     * @throws Error - the current content has no TrackChoiceManager.
     * @throws Error - the given id is linked to no video track.
     */
    setVideoTrack(videoId) {
        var _a;
        if (this._priv_contentInfos === null) {
            throw new Error("No content loaded");
        }
        const { currentPeriod, isDirectFile } = this._priv_contentInfos;
        if (isDirectFile) {
            try {
                (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.setVideoTrackById(videoId);
                return;
            }
            catch (e) {
                throw new Error("player: unknown video track");
            }
        }
        if (this._priv_trackChoiceManager === null || currentPeriod === null) {
            throw new Error("No compatible content launched.");
        }
        try {
            this._priv_trackChoiceManager.setVideoTrackByID(currentPeriod, videoId);
        }
        catch (e) {
            throw new Error("player: unknown video track");
        }
    }
    /**
     * Disable video track for the current content.
     */
    disableVideoTrack() {
        if (this._priv_contentInfos === null) {
            return;
        }
        const { currentPeriod, isDirectFile } = this._priv_contentInfos;
        if (isDirectFile && this._priv_mediaElementTrackChoiceManager !== null) {
            return this._priv_mediaElementTrackChoiceManager.disableVideoTrack();
        }
        if (this._priv_trackChoiceManager === null || currentPeriod === null) {
            return;
        }
        return this._priv_trackChoiceManager.disableVideoTrack(currentPeriod);
    }
    /**
     * Returns the current list of preferred audio tracks, in preference order.
     * @returns {Array.<Object>}
     */
    getPreferredAudioTracks() {
        return this._priv_preferredAudioTracks;
    }
    /**
     * Returns the current list of preferred text tracks, in preference order.
     * @returns {Array.<Object>}
     */
    getPreferredTextTracks() {
        return this._priv_preferredTextTracks;
    }
    /**
     * Returns the current list of preferred text tracks, in preference order.
     * @returns {Array.<Object>}
     */
    getPreferredVideoTracks() {
        return this._priv_preferredVideoTracks;
    }
    /**
     * Set the list of preferred audio tracks, in preference order.
     * @param {Array.<Object>} tracks
     * @param {boolean} shouldApply - `true` if those preferences should be
     * applied on the currently loaded Period. `false` if it should only
     * be applied to new content.
     */
    setPreferredAudioTracks(tracks, shouldApply = false) {
        if (!Array.isArray(tracks)) {
            throw new Error("Invalid `setPreferredAudioTracks` argument. " +
                "Should have been an Array.");
        }
        this._priv_preferredAudioTracks = tracks;
        if (this._priv_trackChoiceManager !== null) {
            this._priv_trackChoiceManager.setPreferredAudioTracks(tracks, shouldApply);
        }
        else if (this._priv_mediaElementTrackChoiceManager !== null) {
            this._priv_mediaElementTrackChoiceManager.setPreferredAudioTracks(tracks, shouldApply);
        }
    }
    /**
     * Set the list of preferred text tracks, in preference order.
     * @param {Array.<Object>} tracks
     * @param {boolean} shouldApply - `true` if those preferences should be
     * applied on the currently loaded Periods. `false` if it should only
     * be applied to new content.
     */
    setPreferredTextTracks(tracks, shouldApply = false) {
        if (!Array.isArray(tracks)) {
            throw new Error("Invalid `setPreferredTextTracks` argument. " +
                "Should have been an Array.");
        }
        this._priv_preferredTextTracks = tracks;
        if (this._priv_trackChoiceManager !== null) {
            this._priv_trackChoiceManager.setPreferredTextTracks(tracks, shouldApply);
        }
        else if (this._priv_mediaElementTrackChoiceManager !== null) {
            this._priv_mediaElementTrackChoiceManager.setPreferredTextTracks(tracks, shouldApply);
        }
    }
    /**
     * Set the list of preferred text tracks, in preference order.
     * @param {Array.<Object>} tracks
     * @param {boolean} shouldApply - `true` if those preferences should be
     * applied on the currently loaded Period. `false` if it should only
     * be applied to new content.
     */
    setPreferredVideoTracks(tracks, shouldApply = false) {
        if (!Array.isArray(tracks)) {
            throw new Error("Invalid `setPreferredVideoTracks` argument. " +
                "Should have been an Array.");
        }
        this._priv_preferredVideoTracks = tracks;
        if (this._priv_trackChoiceManager !== null) {
            this._priv_trackChoiceManager.setPreferredVideoTracks(tracks, shouldApply);
        }
        else if (this._priv_mediaElementTrackChoiceManager !== null) {
            this._priv_mediaElementTrackChoiceManager.setPreferredVideoTracks(tracks, shouldApply);
        }
    }
    /**
     * @returns {Array.<Object>|null}
     * @deprecated
     */
    getImageTrackData() {
        (0,warn_once/* default */.Z)("`getImageTrackData` is deprecated." +
            "Please use the `parseBifThumbnails` tool instead.");
        if (this._priv_contentInfos === null) {
            return null;
        }
        /* eslint-disable import/no-deprecated */
        return this._priv_contentInfos.thumbnails;
        /* eslint-enable import/no-deprecated */
    }
    /**
     * Get minimum seek-able position.
     * @returns {number}
     */
    getMinimumPosition() {
        if (this._priv_contentInfos === null) {
            return null;
        }
        if (this._priv_contentInfos.isDirectFile) {
            return 0;
        }
        const { manifest } = this._priv_contentInfos;
        if (manifest !== null) {
            return manifest.getMinimumPosition();
        }
        return null;
    }
    /**
     * Get maximum seek-able position.
     * @returns {number}
     */
    getMaximumPosition() {
        if (this._priv_contentInfos === null) {
            return null;
        }
        const { isDirectFile, manifest } = this._priv_contentInfos;
        if (isDirectFile) {
            if (this.videoElement === null) {
                throw new Error("Disposed player");
            }
            return this.videoElement.duration;
        }
        if (manifest !== null) {
            return manifest.getMaximumPosition();
        }
        return null;
    }
    /**
     * /!\ For demo use only! Do not touch!
     *
     * Returns every chunk buffered for a given buffer type.
     * Returns `null` if no SegmentBuffer was created for this type of buffer.
     * @param {string} bufferType
     * @returns {Array.<Object>|null}
     */
    __priv_getSegmentBufferContent(bufferType) {
        if (this._priv_contentInfos === null ||
            this._priv_contentInfos.segmentBuffersStore === null) {
            return null;
        }
        const segmentBufferStatus = this._priv_contentInfos
            .segmentBuffersStore.getStatus(bufferType);
        return segmentBufferStatus.type === "initialized" ?
            segmentBufferStatus.value.getInventory() :
            null;
    }
    /**
     * Reset all state properties relative to a playing content.
     */
    _priv_cleanUpCurrentContentState() {
        var _a;
        log/* default.debug */.Z.debug("Locking `contentLock` to clean-up the current content.");
        // lock playback of new contents while cleaning up is pending
        this._priv_contentLock$.next(true);
        this._priv_contentInfos = null;
        this._priv_trackChoiceManager = null;
        (_a = this._priv_mediaElementTrackChoiceManager) === null || _a === void 0 ? void 0 : _a.dispose();
        this._priv_mediaElementTrackChoiceManager = null;
        this._priv_contentEventsMemory = {};
        // EME cleaning
        const freeUpContentLock = () => {
            log/* default.debug */.Z.debug("Unlocking `contentLock`. Next content can begin.");
            this._priv_contentLock$.next(false);
        };
        if (!(0,is_null_or_undefined/* default */.Z)(this.videoElement)) {
            clearEMESession(this.videoElement)
                .subscribe(noop/* default */.Z, (err) => {
                log/* default.error */.Z.error("API: An error arised when trying to clean-up the EME session:" +
                    (err instanceof Error ? err.toString() :
                        "Unknown Error"));
                freeUpContentLock();
            }, () => {
                log/* default.debug */.Z.debug("API: EME session cleaned-up with success!");
                freeUpContentLock();
            });
        }
        else {
            freeUpContentLock();
        }
    }
    /**
     * Triggered each time the playback Observable emits.
     *
     * React to various events.
     *
     * @param {Object} event - payload emitted
     */
    _priv_onPlaybackEvent(event) {
        switch (event.type) {
            case "inband-events":
                const inbandEvents = event.value;
                this.trigger("inbandEvents", inbandEvents);
                return;
            case "stream-event":
                this.trigger("streamEvent", event.value);
                break;
            case "stream-event-skip":
                this.trigger("streamEventSkip", event.value);
                break;
            case "activePeriodChanged":
                this._priv_onActivePeriodChanged(event.value);
                break;
            case "periodStreamReady":
                this._priv_onPeriodStreamReady(event.value);
                break;
            case "periodStreamCleared":
                this._priv_onPeriodStreamCleared(event.value);
                break;
            case "reloading-media-source":
                this._priv_onReloadingMediaSource();
                break;
            case "representationChange":
                this._priv_onRepresentationChange(event.value);
                break;
            case "adaptationChange":
                this._priv_onAdaptationChange(event.value);
                break;
            case "bitrateEstimationChange":
                this._priv_onBitrateEstimationChange(event.value);
                break;
            case "manifestReady":
                this._priv_onManifestReady(event.value);
                break;
            case "warning":
                this._priv_onPlaybackWarning(event.value);
                break;
            case "loaded":
                if (this._priv_contentInfos === null) {
                    log/* default.error */.Z.error("API: Loaded event while no content is loaded");
                    return;
                }
                this._priv_contentInfos.segmentBuffersStore = event.value.segmentBuffersStore;
                break;
            case "decipherabilityUpdate":
                this.trigger("decipherabilityUpdate", event.value);
                break;
            case "added-segment":
                if (this._priv_contentInfos === null) {
                    log/* default.error */.Z.error("API: Added segment while no content is loaded");
                    return;
                }
                // Manage image tracks
                // @deprecated
                const { content, segmentData } = event.value;
                if (content.adaptation.type === "image") {
                    if (!(0,is_null_or_undefined/* default */.Z)(segmentData) &&
                        segmentData.type === "bif") {
                        const imageData = segmentData.data;
                        /* eslint-disable import/no-deprecated */
                        this._priv_contentInfos.thumbnails = imageData;
                        this.trigger("imageTrackUpdate", { data: this._priv_contentInfos.thumbnails });
                        /* eslint-enable import/no-deprecated */
                    }
                }
        }
    }
    /**
     * Triggered when we received a fatal error.
     * Clean-up ressources and signal that the content has stopped on error.
     * @param {Error} error
     */
    _priv_onPlaybackError(error) {
        const formattedError = formatError(error, {
            defaultCode: "NONE",
            defaultReason: "An unknown error stopped content playback.",
        });
        formattedError.fatal = true;
        if (this._priv_contentInfos !== null) {
            this._priv_contentInfos.stop$.next();
            this._priv_contentInfos.stop$.complete();
        }
        this._priv_cleanUpCurrentContentState();
        this._priv_currentError = formattedError;
        log/* default.error */.Z.error("API: The player stopped because of an error:", error);
        this._priv_setPlayerState(PLAYER_STATES.STOPPED);
        // TODO This condition is here because the eventual callback called when the
        // player state is updated can launch a new content, thus the error will not
        // be here anymore, in which case triggering the "error" event is unwanted.
        // This is very ugly though, and we should probable have a better solution
        if (this._priv_currentError === formattedError) {
            this.trigger("error", formattedError);
        }
    }
    /**
     * Triggered when the playback Observable completes.
     * Clean-up ressources and signal that the content has ended.
     */
    _priv_onPlaybackFinished() {
        log/* default.info */.Z.info("API: Previous playback finished. Stopping and cleaning-up...");
        if (this._priv_contentInfos !== null) {
            this._priv_contentInfos.stop$.next();
            this._priv_contentInfos.stop$.complete();
        }
        this._priv_cleanUpCurrentContentState();
        this._priv_setPlayerState(PLAYER_STATES.ENDED);
    }
    /**
     * Triggered when we received a warning event during playback.
     * Trigger the right API event.
     * @param {Error} error
     */
    _priv_onPlaybackWarning(error) {
        const formattedError = formatError(error, {
            defaultCode: "NONE",
            defaultReason: "An unknown error happened.",
        });
        log/* default.warn */.Z.warn("API: Sending warning:", formattedError);
        this.trigger("warning", formattedError);
    }
    /**
     * Triggered when the Manifest has been loaded for the current content.
     * Initialize various private properties and emit initial event.
     * @param {Object} value
     */
    _priv_onManifestReady({ manifest }) {
        const contentInfos = this._priv_contentInfos;
        if (contentInfos === null) {
            log/* default.error */.Z.error("API: The manifest is loaded but no content is.");
            return;
        }
        contentInfos.manifest = manifest;
        this._priv_lastContentPlaybackInfos.manifest = manifest;
        const { initialAudioTrack, initialTextTrack } = contentInfos;
        this._priv_trackChoiceManager = new TrackChoiceManager();
        const preferredAudioTracks = initialAudioTrack === undefined ?
            this._priv_preferredAudioTracks :
            [initialAudioTrack];
        this._priv_trackChoiceManager.setPreferredAudioTracks(preferredAudioTracks, true);
        const preferredTextTracks = initialTextTrack === undefined ?
            this._priv_preferredTextTracks :
            [initialTextTrack];
        this._priv_trackChoiceManager.setPreferredTextTracks(preferredTextTracks, true);
        this._priv_trackChoiceManager.setPreferredVideoTracks(this._priv_preferredVideoTracks, true);
        (0,event_emitter/* fromEvent */.R)(manifest, "manifestUpdate")
            .pipe((0,takeUntil/* takeUntil */.R)(contentInfos.stop$))
            .subscribe(() => {
            // Update the tracks chosen if it changed
            if (this._priv_trackChoiceManager !== null) {
                this._priv_trackChoiceManager.update();
            }
        });
    }
    /**
     * Triggered each times the current Period Changed.
     * Store and emit initial state for the Period.
     *
     * @param {Object} value
     */
    _priv_onActivePeriodChanged({ period }) {
        var _a, _b, _c, _d, _e, _f;
        if (this._priv_contentInfos === null) {
            log/* default.error */.Z.error("API: The active period changed but no content is loaded");
            return;
        }
        this._priv_contentInfos.currentPeriod = period;
        if (this._priv_contentEventsMemory.periodChange !== period) {
            this._priv_contentEventsMemory.periodChange = period;
            this.trigger("periodChange", period);
        }
        this.trigger("availableAudioTracksChange", this.getAvailableAudioTracks());
        this.trigger("availableTextTracksChange", this.getAvailableTextTracks());
        this.trigger("availableVideoTracksChange", this.getAvailableVideoTracks());
        // Emit intial events for the Period
        if (this._priv_trackChoiceManager !== null) {
            const audioTrack = this._priv_trackChoiceManager.getChosenAudioTrack(period);
            const textTrack = this._priv_trackChoiceManager.getChosenTextTrack(period);
            const videoTrack = this._priv_trackChoiceManager.getChosenVideoTrack(period);
            this.trigger("audioTrackChange", audioTrack);
            this.trigger("textTrackChange", textTrack);
            this.trigger("videoTrackChange", videoTrack);
        }
        else {
            this.trigger("audioTrackChange", null);
            this.trigger("textTrackChange", null);
            this.trigger("videoTrackChange", null);
        }
        this._priv_triggerAvailableBitratesChangeEvent("availableAudioBitratesChange", this.getAvailableAudioBitrates());
        this._priv_triggerAvailableBitratesChangeEvent("availableVideoBitratesChange", this.getAvailableVideoBitrates());
        const audioBitrate = (_c = (_b = (_a = this._priv_getCurrentRepresentations()) === null || _a === void 0 ? void 0 : _a.audio) === null || _b === void 0 ? void 0 : _b.bitrate) !== null && _c !== void 0 ? _c : -1;
        this._priv_triggerCurrentBitrateChangeEvent("audioBitrateChange", audioBitrate);
        const videoBitrate = (_f = (_e = (_d = this._priv_getCurrentRepresentations()) === null || _d === void 0 ? void 0 : _d.video) === null || _e === void 0 ? void 0 : _e.bitrate) !== null && _f !== void 0 ? _f : -1;
        this._priv_triggerCurrentBitrateChangeEvent("videoBitrateChange", videoBitrate);
    }
    /**
     * Triggered each times a new "PeriodStream" is ready.
     * Choose the right Adaptation for the Period and emit it.
     * @param {Object} value
     */
    _priv_onPeriodStreamReady(value) {
        const { type, period, adaptation$ } = value;
        switch (type) {
            case "video":
                if (this._priv_trackChoiceManager === null) {
                    log/* default.error */.Z.error("API: TrackChoiceManager not instanciated for a new video period");
                    adaptation$.next(null);
                }
                else {
                    this._priv_trackChoiceManager.addPeriod(type, period, adaptation$);
                    this._priv_trackChoiceManager.setInitialVideoTrack(period);
                }
                break;
            case "audio":
                if (this._priv_trackChoiceManager === null) {
                    log/* default.error */.Z.error(`API: TrackChoiceManager not instanciated for a new ${type} period`);
                    adaptation$.next(null);
                }
                else {
                    this._priv_trackChoiceManager.addPeriod(type, period, adaptation$);
                    this._priv_trackChoiceManager.setInitialAudioTrack(period);
                }
                break;
            case "text":
                if (this._priv_trackChoiceManager === null) {
                    log/* default.error */.Z.error(`API: TrackChoiceManager not instanciated for a new ${type} period`);
                    adaptation$.next(null);
                }
                else {
                    this._priv_trackChoiceManager.addPeriod(type, period, adaptation$);
                    this._priv_trackChoiceManager.setInitialTextTrack(period);
                }
                break;
            default:
                const adaptations = period.adaptations[type];
                if (!(0,is_null_or_undefined/* default */.Z)(adaptations) && adaptations.length > 0) {
                    adaptation$.next(adaptations[0]);
                }
                else {
                    adaptation$.next(null);
                }
                break;
        }
    }
    /**
     * Triggered each times we "remove" a PeriodStream.
     * @param {Object} value
     */
    _priv_onPeriodStreamCleared(value) {
        const { type, period } = value;
        // Clean-up track choice from TrackChoiceManager
        switch (type) {
            case "audio":
            case "text":
            case "video":
                if (this._priv_trackChoiceManager !== null) {
                    this._priv_trackChoiceManager.removePeriod(type, period);
                }
                break;
        }
        // Clean-up stored Representation and Adaptation information
        if (this._priv_contentInfos === null) {
            return;
        }
        const { activeAdaptations, activeRepresentations } = this._priv_contentInfos;
        if (!(0,is_null_or_undefined/* default */.Z)(activeAdaptations) &&
            !(0,is_null_or_undefined/* default */.Z)(activeAdaptations[period.id])) {
            const activePeriodAdaptations = activeAdaptations[period.id];
            delete activePeriodAdaptations[type];
            if (Object.keys(activePeriodAdaptations).length === 0) {
                delete activeAdaptations[period.id];
            }
        }
        if (!(0,is_null_or_undefined/* default */.Z)(activeRepresentations) &&
            !(0,is_null_or_undefined/* default */.Z)(activeRepresentations[period.id])) {
            const activePeriodRepresentations = activeRepresentations[period.id];
            delete activePeriodRepresentations[type];
            if (Object.keys(activePeriodRepresentations).length === 0) {
                delete activeRepresentations[period.id];
            }
        }
    }
    /**
     * Triggered each time the content is re-loaded on the MediaSource.
     */
    _priv_onReloadingMediaSource() {
        if (this._priv_contentInfos !== null) {
            this._priv_contentInfos.segmentBuffersStore = null;
        }
        if (this._priv_trackChoiceManager !== null) {
            this._priv_trackChoiceManager.resetPeriods();
        }
    }
    /**
     * Triggered each times a new Adaptation is considered for the current
     * content.
     * Store given Adaptation and emit it if from the current Period.
     * @param {Object} value
     */
    _priv_onAdaptationChange({ type, adaptation, period, }) {
        if (this._priv_contentInfos === null) {
            log/* default.error */.Z.error("API: The adaptations changed but no content is loaded");
            return;
        }
        // lazily create this._priv_contentInfos.activeAdaptations
        if (this._priv_contentInfos.activeAdaptations === null) {
            this._priv_contentInfos.activeAdaptations = {};
        }
        const { activeAdaptations, currentPeriod } = this._priv_contentInfos;
        const activePeriodAdaptations = activeAdaptations[period.id];
        if ((0,is_null_or_undefined/* default */.Z)(activePeriodAdaptations)) {
            activeAdaptations[period.id] = { [type]: adaptation };
        }
        else {
            activePeriodAdaptations[type] = adaptation;
        }
        if (this._priv_trackChoiceManager !== null &&
            currentPeriod !== null && !(0,is_null_or_undefined/* default */.Z)(period) &&
            period.id === currentPeriod.id) {
            switch (type) {
                case "audio":
                    const audioTrack = this._priv_trackChoiceManager
                        .getChosenAudioTrack(currentPeriod);
                    this.trigger("audioTrackChange", audioTrack);
                    const availableAudioBitrates = this.getAvailableAudioBitrates();
                    this._priv_triggerAvailableBitratesChangeEvent("availableAudioBitratesChange", availableAudioBitrates);
                    break;
                case "text":
                    const textTrack = this._priv_trackChoiceManager
                        .getChosenTextTrack(currentPeriod);
                    this.trigger("textTrackChange", textTrack);
                    break;
                case "video":
                    const videoTrack = this._priv_trackChoiceManager
                        .getChosenVideoTrack(currentPeriod);
                    this.trigger("videoTrackChange", videoTrack);
                    const availableVideoBitrates = this.getAvailableVideoBitrates();
                    this._priv_triggerAvailableBitratesChangeEvent("availableVideoBitratesChange", availableVideoBitrates);
                    break;
            }
        }
    }
    /**
     * Triggered each times a new Representation is considered during playback.
     *
     * Store given Representation and emit it if from the current Period.
     *
     * @param {Object} obj
     */
    _priv_onRepresentationChange({ type, period, representation, }) {
        var _a;
        if (this._priv_contentInfos === null) {
            log/* default.error */.Z.error("API: The representations changed but no content is loaded");
            return;
        }
        // lazily create this._priv_contentInfos.activeRepresentations
        if (this._priv_contentInfos.activeRepresentations === null) {
            this._priv_contentInfos.activeRepresentations = {};
        }
        const { activeRepresentations, currentPeriod } = this._priv_contentInfos;
        const activePeriodRepresentations = activeRepresentations[period.id];
        if ((0,is_null_or_undefined/* default */.Z)(activePeriodRepresentations)) {
            activeRepresentations[period.id] = { [type]: representation };
        }
        else {
            activePeriodRepresentations[type] = representation;
        }
        const bitrate = (_a = representation === null || representation === void 0 ? void 0 : representation.bitrate) !== null && _a !== void 0 ? _a : -1;
        if (!(0,is_null_or_undefined/* default */.Z)(period) &&
            currentPeriod !== null &&
            currentPeriod.id === period.id) {
            if (type === "video") {
                this._priv_triggerCurrentBitrateChangeEvent("videoBitrateChange", bitrate);
            }
            else if (type === "audio") {
                this._priv_triggerCurrentBitrateChangeEvent("audioBitrateChange", bitrate);
            }
        }
    }
    /**
     * Triggered each time a bitrate estimate is calculated.
     *
     * Emit it.
     *
     * @param {Object} value
     */
    _priv_onBitrateEstimationChange({ type, bitrate, }) {
        if (bitrate !== undefined) {
            this._priv_bitrateInfos.lastBitrates[type] = bitrate;
        }
        this.trigger("bitrateEstimationChange", { type, bitrate });
    }
    /**
     * Triggered each time the videoElement alternates between play and pause.
     *
     * Emit the info through the right Subject.
     *
     * @param {Boolean} isPlaying
     */
    _priv_onPlayPauseNext(isPlaying) {
        if (this.videoElement === null) {
            throw new Error("Disposed player");
        }
        this._priv_playing$.next(isPlaying);
    }
    /**
     * Triggered each time a textTrack is added to the video DOM Element.
     *
     * Trigger the right Player Event.
     *
     * @param {Array.<TextTrackElement>} tracks
     */
    _priv_onNativeTextTracksNext(tracks) {
        this.trigger("nativeTextTracksChange", tracks);
    }
    /**
     * Triggered each time the player state updates.
     *
     * Trigger the right Player Event.
     *
     * @param {string} newState
     */
    _priv_setPlayerState(newState) {
        if (this.state !== newState) {
            this.state = newState;
            log/* default.info */.Z.info("API: playerStateChange event", newState);
            this.trigger("playerStateChange", newState);
        }
    }
    /**
     * Triggered each time a new clock tick object is emitted.
     *
     * Trigger the right Player Event
     *
     * @param {Object} clockTick
     */
    _priv_triggerPositionUpdate(clockTick) {
        var _a;
        if (this._priv_contentInfos === null) {
            log/* default.warn */.Z.warn("API: Cannot perform time update: no content loaded.");
            return;
        }
        if (this.state === PLAYER_STATES.RELOADING) {
            return;
        }
        const { isDirectFile, manifest } = this._priv_contentInfos;
        if ((!isDirectFile && manifest === null) || (0,is_null_or_undefined/* default */.Z)(clockTick)) {
            return;
        }
        this._priv_lastContentPlaybackInfos.lastPlaybackPosition = clockTick.position;
        const maximumPosition = manifest !== null ? manifest.getMaximumPosition() :
            undefined;
        const positionData = {
            position: clockTick.position,
            duration: clockTick.duration,
            playbackRate: clockTick.playbackRate,
            maximumBufferTime: maximumPosition,
            // TODO fix higher up?
            bufferGap: isFinite(clockTick.bufferGap) ? clockTick.bufferGap :
                0,
        };
        if (manifest !== null &&
            maximumPosition !== undefined &&
            manifest.isLive &&
            clockTick.position > 0) {
            const ast = (_a = manifest.availabilityStartTime) !== null && _a !== void 0 ? _a : 0;
            positionData.wallClockTime = clockTick.position + ast;
            positionData.liveGap = maximumPosition - clockTick.position;
        }
        this.trigger("positionUpdate", positionData);
    }
    /**
     * Trigger one of the "availableBitratesChange" event only if it changed from
     * the previously stored value.
     * @param {string} event
     * @param {Array.<number>} newVal
     */
    _priv_triggerAvailableBitratesChangeEvent(event, newVal) {
        const prevVal = this._priv_contentEventsMemory[event];
        if (prevVal === undefined || (0,are_arrays_of_numbers_equal/* default */.Z)(newVal, prevVal)) {
            this._priv_contentEventsMemory[event] = newVal;
            this.trigger(event, newVal);
        }
    }
    /**
     * Trigger one of the "bitrateChange" event only if it changed from the
     * previously stored value.
     * @param {string} event
     * @param {number} newVal
     */
    _priv_triggerCurrentBitrateChangeEvent(event, newVal) {
        if (newVal !== this._priv_contentEventsMemory[event]) {
            this._priv_contentEventsMemory[event] = newVal;
            this.trigger(event, newVal);
        }
    }
    _priv_getCurrentRepresentations() {
        if (this._priv_contentInfos === null) {
            return null;
        }
        const { currentPeriod, activeRepresentations } = this._priv_contentInfos;
        if (currentPeriod === null ||
            activeRepresentations === null ||
            (0,is_null_or_undefined/* default */.Z)(activeRepresentations[currentPeriod.id])) {
            return null;
        }
        return activeRepresentations[currentPeriod.id];
    }
}
Player.version = /* PLAYER_VERSION */ "3.24.0";
/* harmony default export */ const public_api = (Player);

;// CONCATENATED MODULE: ./src/core/api/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* harmony default export */ const api = (public_api);

// EXTERNAL MODULE: ./src/features/features_object.ts
var features_object = __webpack_require__(63121);
;// CONCATENATED MODULE: ./src/features/initialize_features.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-var-requires */

/**
 * Selects the features to include based on environment variables.
 *
 * @param {Object} features
 */
function initializeFeaturesObject() {
    if (true) {
        features_object/* default.emeManager */.Z.emeManager = __webpack_require__(16036)/* .default */ .ZP;
    }
    if (true) {
        features_object/* default.imageBuffer */.Z.imageBuffer = __webpack_require__(71396)/* .default */ .Z;
        features_object/* default.imageParser */.Z.imageParser = __webpack_require__(73393)/* .default */ .Z;
    }
    // Feature switching the Native TextTrack implementation
    const HAS_NATIVE_MODE =  true ||
        0;
    if (true) {
        features_object/* default.transports.smooth */.Z.transports.smooth = __webpack_require__(56707)/* .default */ .Z;
    }
    if (true) {
        features_object/* default.transports.dash */.Z.transports.dash = __webpack_require__(9563)/* .default */ .Z;
    }
    if (true) {
        features_object/* default.transports.local */.Z.transports.local = __webpack_require__(38571)/* .default */ .Z;
    }
    if (true) {
        features_object/* default.transports.metaplaylist */.Z.transports.metaplaylist = __webpack_require__(39901)/* .default */ .Z;
    }
    if (HAS_NATIVE_MODE) {
        features_object/* default.nativeTextTracksBuffer */.Z.nativeTextTracksBuffer =
            __webpack_require__(10486)/* .default */ .Z;
        if (true) {
            features_object/* default.nativeTextTracksParsers.vtt */.Z.nativeTextTracksParsers.vtt =
                __webpack_require__(42262)/* .default */ .Z;
        }
        if (true) {
            features_object/* default.nativeTextTracksParsers.ttml */.Z.nativeTextTracksParsers.ttml =
                __webpack_require__(84944)/* .default */ .Z;
        }
        if (true) {
            features_object/* default.nativeTextTracksParsers.sami */.Z.nativeTextTracksParsers.sami =
                __webpack_require__(20891)/* .default */ .Z;
        }
        if (true) {
            features_object/* default.nativeTextTracksParsers.srt */.Z.nativeTextTracksParsers.srt =
                __webpack_require__(29663)/* .default */ .Z;
        }
    }
    // Feature switching the HTML TextTrack implementation
    const HAS_HTML_MODE =  true ||
        0;
    if (HAS_HTML_MODE) {
        features_object/* default.htmlTextTracksBuffer */.Z.htmlTextTracksBuffer =
            __webpack_require__(47706)/* .default */ .Z;
        if (true) {
            features_object/* default.htmlTextTracksParsers.sami */.Z.htmlTextTracksParsers.sami =
                __webpack_require__(38397)/* .default */ .Z;
        }
        if (true) {
            features_object/* default.htmlTextTracksParsers.ttml */.Z.htmlTextTracksParsers.ttml =
                __webpack_require__(4330)/* .default */ .Z;
        }
        if (true) {
            features_object/* default.htmlTextTracksParsers.srt */.Z.htmlTextTracksParsers.srt =
                __webpack_require__(38090)/* .default */ .Z;
        }
        if (true) {
            features_object/* default.htmlTextTracksParsers.vtt */.Z.htmlTextTracksParsers.vtt =
                __webpack_require__(48299)/* .default */ .Z;
        }
    }
    if (true) {
        const initDirectFile = __webpack_require__(65309)/* .default */ .Z;
        const mediaElementTrackChoiceManager = __webpack_require__(22704)/* .default */ .Z;
        features_object/* default.directfile */.Z.directfile = { initDirectFile,
            mediaElementTrackChoiceManager };
    }
}

;// CONCATENATED MODULE: ./src/index.ts
/**
 * Copyright 2015 CANAL+ Group
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * This file exports a Player class with a default feature set (depends on the
 * environment variables set at build).
 *
 * This is the class used from a regular build.
 */



// set initial features according to environment variables
initializeFeaturesObject();
if (true) {
    log/* default.setLevel */.Z.setLevel("INFO");
}
/* harmony default export */ const src = (api);

;// CONCATENATED MODULE: ./demo/full/scripts/lib/vespertine.js


/**
 * Homemade redux and r9webapp-core inspired state management architecture.
 *
 * This function creates a new module (defined in the modules directory) and
 * give it the payload in argument.
 *
 * The module can send state updates at any time, through its state Object,
 * and returns an Object containing functions: the actions.
 *
 * The actions can then be called through the dispatch function returned here.
 *
 * As an example is simpler for everyone:
 * @example
 * ```js
 * // 1 - The module
 * const TodoList = ({ state }, { maxLength }) => {
 *   // initial state
 *   state.set({
 *     todos: [],
 *   });
 *
 *   let lastTodoId = 0;
 *   return {
 *
 *     // add a todo if max length is not yet reached
 *     ADD_TODO: function(text) {
 *       const currentTodos = state.get("todos");
 *       if (currentTodos.length >= maxLength) {
 *         return -1;
 *       }
 *
 *       const id = lastTodoId++;
 *
 *       // update state
 *       state.set({
 *         todos: [
 *           ...currentTodos,
 *           { id, text },
 *         ],
 *       });
 *
 *       // return id so it's easier to retrieve for the caller
 *       return id;
 *     },
 *
 *     // remove a todo thanks to its id
 *     REMOVE_TODO function(todoId) {
 *       const currentTodos = state.get("todos");
 *
 *       const index = currentTodos
 *        .findIndex(({ id }) => id === todoId);
 *
 *        if (index < 0) {
 *          // Returning a boolean can help the caller to realize that the todo
 *          // did not exist
 *          return false;
 *        }
 *
 *        // clone to stay immutable here
 *        const todosClone = [ ...currentTodos ];
 *
 *        todosClone.splice(index, 1);
 *        state.set({ todos: todosClone });
 *        return true;
 *     },
 *   };
 * };
 *
 * // 2 - The interactions with it
 * const todoList = createModule(TodoList, { maxLength: 2 });
 *
 * // display todos when they change ($get is asynchronous, get is synchronous)
 * todoList.$get("todos")
 *   .subscribe(todos => {
 *     display(todos);
 *   });
 * console.log(todoList.get("todos").length); // 0
 *
 * const firstId = todoList.dispatch("ADD_TODO", "do something");
 * console.log(todoList.get("todos").length); // 1
 *
 * todoList.dispatch("ADD_TODO", "do another thing");
 * console.log(todoList.get("todos").length); // 2
 *
 * todoList.dispatch("ADD_TODO", "yet another");
 * console.log(todoList.get("todos").length); // still 2 - as it's the max
 *                                            // length set
 *
 * // remove the first todo created
 * todoList.dispatch("REMOVE_TODO", firstId);
 * console.log(todoList.get("todos").length); // back to 1
 *
 * todoList.destroy(); // cleanup and stop $get subscriptions
 * ```
 *
 * @param {Function} module
 * @param {*} payload
 * @returns {Object} - Object with the following functions:
 *
 *   - dispatch: call an action from the module. Takes the name of the action
 *     (a string) + an eventual payload in argument. Returns what the action
 *     returns.
 *
 *   - get: get the entire module state, or the property named after the
 *     argument (a string).
 *
 *   - $get: same as get, but returns an observable instead. Start emitting at
 *     the first change (I do not know yet if it's better to first emit the
 *     initial value immediately).
 *
 *   - destroy: destroy the module. Completes all subscriptions.
 */

var createModule = function createModule(module, payload) {
  if (typeof module !== "function") {
    throw new Error("A module should be a function");
  }

  var moduleState = {};
  var $destroy = new Subject/* Subject */.xQ();
  var $updates = new Subject/* Subject */.xQ().pipe((0,takeUntil/* takeUntil */.R)($destroy));

  var getFromModule = function getFromModule() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (!args.length) {
      return moduleState;
    }

    if (args.length === 1) {
      return moduleState[args[0]];
    }

    return args.map(function (arg) {
      return moduleState[arg];
    });
  };

  var $getFromModule = function $getFromModule() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (!args.length) {
      return $updates;
    }

    if (args.length === 1) {
      return $updates.pipe((0,map/* map */.U)(function (state) {
        return state[args];
      }), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
    }

    var observables = args.map(function (arg) {
      return $updates.pipe((0,map/* map */.U)(function (state) {
        return state[arg];
      }), (0,distinctUntilChanged/* distinctUntilChanged */.x)());
    });
    return combineLatest/* combineLatest.apply */.aj.apply(void 0, observables);
  };

  var moduleArgs = {
    state: {
      get: getFromModule,
      set: function set(arg) {
        var newState = Object.assign(moduleState, arg);
        $updates.next(newState);
      }
    },
    $destroy: $destroy
  };
  var moduleActions = module(moduleArgs, payload);
  return {
    dispatch: function dispatch(actionName, actionPayload) {
      if (!moduleActions || typeof moduleActions[actionName] !== "function") {
        throw new Error("The " + actionName + " action does not exist on this module.");
      }

      return moduleActions[actionName](actionPayload);
    },
    get: getFromModule,
    $get: $getFromModule,
    destroy: function destroy() {
      $destroy.next();
      $destroy.complete();
    }
  };
};


;// CONCATENATED MODULE: ./demo/full/scripts/modules/player/fromPlayerEvent.js

/**
 * Simple utils converting an Event-listener-based player event into an
 * Observable.
 * @param {RxPlayer} player
 * @param {string} event
 * @returns {Observable}
 */

function fromPlayerEvent(player, event) {
  return new Observable/* Observable */.y(function (obs) {
    var func = function func(payload) {
      return obs.next(payload);
    };

    player.addEventListener(event, func);
    return function () {
      player.removeEventListener(event, func);
    };
  });
}
;// CONCATENATED MODULE: ./demo/full/scripts/modules/player/events.js



var POSITION_UPDATES_INTERVAL = 100;
var BUFFERED_DATA_UPDATES_INTERVAL = 100;
/**
 * Add event listeners to the RxPlayer to update the module's state at the right
 * time.
 * Unsubscribe when $destroy emit.
 * @param {RxPlayer} player
 * @param {Subject} state
 * @param {Subject} $destroy
 */

var linkPlayerEventsToState = function linkPlayerEventsToState(player, state, $destroy) {
  var linkPlayerEventToState = function linkPlayerEventToState(event, stateItem) {
    return fromPlayerEvent(player, event).pipe((0,takeUntil/* takeUntil */.R)($destroy)).subscribe(function (arg) {
      var _state$set;

      return state.set((_state$set = {}, _state$set[stateItem] = arg, _state$set));
    });
  };

  linkPlayerEventToState("textTrackChange", "subtitle");
  linkPlayerEventToState("audioTrackChange", "language");
  linkPlayerEventToState("videoTrackChange", "videoTrack");
  linkPlayerEventToState("videoBitrateChange", "videoBitrate");
  linkPlayerEventToState("audioBitrateChange", "audioBitrate");
  linkPlayerEventToState("error", "error");
  linkPlayerEventToState("volumeChange", "volume");
  linkPlayerEventToState("availableAudioTracksChange", "availableLanguages");
  linkPlayerEventToState("availableVideoTracksChange", "availableVideoTracks");
  linkPlayerEventToState("availableTextTracksChange", "availableSubtitles");
  linkPlayerEventToState("availableAudioBitratesChange", "availableAudioBitrates");
  linkPlayerEventToState("availableVideoBitratesChange", "availableVideoBitrates");
  fromPlayerEvent(player, "imageTrackUpdate").pipe((0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,takeUntil/* takeUntil */.R)($destroy), (0,map/* map */.U)(function (_ref) {
    var data = _ref.data;
    return data;
  })).subscribe(function (images) {
    return state.set({
      images: images
    });
  }); // use an interval for current position
  // TODO Only active for content playback

  (0,observable_interval/* interval */.F)(POSITION_UPDATES_INTERVAL).pipe((0,map/* map */.U)(function () {
    var position = player.getPosition();
    var duration = player.getVideoDuration();
    return {
      currentTime: player.getPosition(),
      wallClockDiff: player.getWallClockTime() - position,
      bufferGap: player.getVideoLoadedTime() - player.getVideoPlayedTime(),
      duration: Number.isNaN(duration) ? undefined : duration,
      minimumPosition: player.getMinimumPosition(),
      maximumPosition: player.getMaximumPosition(),
      liveGap: player.getMaximumPosition() - player.getPosition(),
      playbackPosition: player.getPlaybackRate()
    };
  }), (0,takeUntil/* takeUntil */.R)($destroy)).subscribe(function (arg) {
    state.set(arg);
  });
  fromPlayerEvent(player, "playerStateChange").pipe((0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,takeUntil/* takeUntil */.R)($destroy)).subscribe(function (arg) {
    var stateUpdates = {
      cannotLoadMetadata: false,
      hasEnded: arg === "ENDED",
      hasCurrentContent: !["STOPPED", "LOADING"].includes(arg),
      isContentLoaded: !["STOPPED", "LOADING", "RELOADING"].includes(arg),
      isBuffering: arg === "BUFFERING",
      isLoading: arg === "LOADING",
      isReloading: arg === "RELOADING",
      isSeeking: arg === "SEEKING",
      isStopped: arg === "STOPPED"
    };

    switch (arg) {
      case "ENDED":
        stateUpdates.autoPlayBlocked = false;
        stateUpdates.isPaused = true;
        break;

      case "PAUSED":
        stateUpdates.isPaused = true;
        break;

      case "PLAYING":
        stateUpdates.autoPlayBlocked = false;
        stateUpdates.isPaused = false;
        break;

      case "LOADED":
        stateUpdates.isPaused = true;
        stateUpdates.isLive = player.isLive();
        break;

      case "STOPPED":
        stateUpdates.audioBitrate = undefined;
        stateUpdates.autoPlayBlocked = false;
        stateUpdates.videoBitrate = undefined;
        stateUpdates.availableAudioBitrates = [];
        stateUpdates.availableVideoBitrates = [];
        stateUpdates.availableVideoTracks = [];
        stateUpdates.availableLanguages = [];
        stateUpdates.availableSubtitles = [];
        stateUpdates.lowLatencyMode = false;
        stateUpdates.images = [];
        stateUpdates.subtitle = null;
        stateUpdates.language = null;
        stateUpdates.videoTrack = null;
        stateUpdates.currentTime = undefined;
        stateUpdates.wallClockDiff = undefined;
        stateUpdates.bufferGap = undefined;
        stateUpdates.bufferedData = null;
        stateUpdates.duration = undefined;
        stateUpdates.minimumPosition = undefined;
        stateUpdates.maximumPosition = undefined;
        break;
    }

    if (arg !== "STOPPED") {
      // error is never cleaned up
      stateUpdates.error = null;
    }

    state.set(stateUpdates);
  }); // update bufferedData

  fromPlayerEvent(player, "playerStateChange").pipe((0,map/* map */.U)(function (playerState) {
    return playerState === "STOPPED";
  }), (0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,takeUntil/* takeUntil */.R)($destroy), (0,switchMap/* switchMap */.w)(function (isStopped) {
    if (isStopped) {
      state.set({
        bufferedData: null
      });
      return empty/* EMPTY */.E;
    }

    return (0,observable_interval/* interval */.F)(BUFFERED_DATA_UPDATES_INTERVAL).pipe((0,startWith/* startWith */.O)(0), (0,tap/* tap */.b)(function () {
      var audioContent = player.__priv_getSegmentBufferContent("audio");

      if (Array.isArray(audioContent)) {
        audioContent = audioContent.slice();
      }

      var textContent = player.__priv_getSegmentBufferContent("text");

      if (Array.isArray(textContent)) {
        textContent = textContent.slice();
      }

      var videoContent = player.__priv_getSegmentBufferContent("video");

      if (Array.isArray(videoContent)) {
        videoContent = videoContent.slice();
      }

      state.set({
        bufferedData: {
          audio: audioContent,
          video: videoContent,
          text: textContent
        }
      });
    }));
  })).subscribe();
  fromPlayerEvent(player, "warning").pipe((0,takeUntil/* takeUntil */.R)($destroy)).subscribe(function (warning) {
    if (warning === null || warning === undefined) {
      return;
    }

    switch (warning.code) {
      case "MEDIA_ERR_NOT_LOADED_METADATA":
        state.set({
          cannotLoadMetadata: true
        });
        break;

      case "MEDIA_ERR_BLOCKED_AUTOPLAY":
        state.set({
          autoPlayBlocked: true
        });
        break;
    }
  });
};


;// CONCATENATED MODULE: ./demo/full/scripts/modules/player/catchUp.js


 // Distance from live edge we try to reach when the catching up button
// is enabled.

var LIVE_GAP_GOAL_WHEN_CATCHING_UP = 3; // Distance from live edge from which we begin to update the playback rate, as
// we're considered too far from the live edge.

var CATCH_UP_CHANGE_RATE_STEP = 6; // Distance from live edge from which we are considered too far too just
// change the playback rate. In the case the current distance is superior
// to that value, we will seek to a LIVE_GAP_GOAL_WHEN_CATCHING_UP distance
// directly instead.

var CATCH_UP_SEEKING_STEP = 15; // Maximum playback rate we can set when catching up.

var MAX_RATE = 10;
/**
 * Perform actions when catch-up mode is enabled/disabled.
 *
 * When it is disabled:
 *   - Reset the playback rate if it was catching up
 *   - Disable catching up mode every time it is found to be enabled
 *
 * When it is enabled:
 *   - seek back to live if it is too far from it.
 *   - Update playback rate and `isCatchingUp` if it is far from the live edge
 *     but not enough too trigger the seek
 */

function $handleCatchUpMode($switchCatchUpMode, rxPlayer, state) {
  var isCatchingUp = false;

  function stopCatchingUp() {
    if (!isCatchingUp) {
      return empty/* EMPTY */.E;
    }

    rxPlayer.setPlaybackRate(1);
    isCatchingUp = false;
    state.set({
      isCatchingUp: isCatchingUp,
      playbackRate: 1
    });
    return (0,of.of)(false);
  }

  return $switchCatchUpMode.pipe((0,switchMap/* switchMap */.w)(function (isCatchUpEnabled) {
    return fromPlayerEvent(rxPlayer, "playerStateChange").pipe((0,startWith/* startWith */.O)(rxPlayer.getPlayerState()), (0,distinctUntilChanged/* distinctUntilChanged */.x)(), (0,map/* map */.U)(function (playerState) {
      return playerState === "LOADED" || playerState === "PLAYING" || playerState === "PAUSED" || playerState === "BUFFERING" || playerState === "SEEKING";
    }), (0,switchMap/* switchMap */.w)(function (canCatchUp) {
      if (!rxPlayer.isLive()) {
        state.set({
          isCatchUpEnabled: false
        });
        return stopCatchingUp();
      }

      state.set({
        isCatchUpEnabled: isCatchUpEnabled
      });

      if (!isCatchUpEnabled || !canCatchUp) {
        return stopCatchingUp();
      }

      return (0,observable_interval/* interval */.F)(200).pipe((0,startWith/* startWith */.O)(0), (0,map/* map */.U)(function () {
        return [rxPlayer.getMaximumPosition(), rxPlayer.getPosition()];
      }), (0,switchMap/* switchMap */.w)(function (_ref) {
        var maximumPosition = _ref[0],
            position = _ref[1];
        var liveGap = maximumPosition - position;

        if (liveGap >= CATCH_UP_SEEKING_STEP) {
          rxPlayer.seekTo(maximumPosition - LIVE_GAP_GOAL_WHEN_CATCHING_UP);
          return stopCatchingUp();
        }

        if (isCatchingUp) {
          if (liveGap <= LIVE_GAP_GOAL_WHEN_CATCHING_UP) {
            return stopCatchingUp();
          }
        } else if (liveGap < CATCH_UP_CHANGE_RATE_STEP) {
          return stopCatchingUp();
        }

        var factor = (liveGap - LIVE_GAP_GOAL_WHEN_CATCHING_UP) / 4;
        var rate = Math.round(Math.min(MAX_RATE, 1.1 + factor) * 10) / 10;

        if (rate <= 1) {
          return stopCatchingUp();
        }

        if (!isCatchingUp) {
          isCatchingUp = true;
          state.set({
            isCatchingUp: true
          });
        }

        state.set({
          playbackRate: rate
        });
        var currentPlaybackRate = rxPlayer.getPlaybackRate();

        if (rate !== currentPlaybackRate) {
          rxPlayer.setPlaybackRate(rate);
        }

        return (0,of.of)(true);
      }));
    }));
  }));
}
;// CONCATENATED MODULE: ./demo/full/scripts/modules/player/index.js
/**
 * # Player Module
 *
 * Instanciate a new RxPlayer, link its state and this module's state, provide
 * actions to allow easy interactions with the player to the rest of the
 * application.
 */






var PLAYER = function PLAYER(_ref, _ref2) {
  var $destroy = _ref.$destroy,
      state = _ref.state;
  var videoElement = _ref2.videoElement,
      textTrackElement = _ref2.textTrackElement;
  var player = new src({
    limitVideoWidth: false,
    stopAtEnd: false,
    throttleVideoBitrateWhenHidden: true,
    videoElement: videoElement
  }); // facilitate DEV mode

  window.RxPlayer = src;
  window.player = window.rxPlayer = player; // initial state. Written here to easily showcase it exhaustively

  state.set({
    audioBitrate: undefined,
    audioBitrateAuto: true,
    autoPlayBlocked: false,
    availableAudioBitrates: [],
    availableLanguages: [],
    availableSubtitles: [],
    availableVideoBitrates: [],
    availableVideoTracks: [],
    bufferGap: undefined,
    bufferedData: null,
    cannotLoadMetadata: false,
    currentTime: undefined,
    duration: undefined,
    error: null,
    hasCurrentContent: false,
    hasEnded: false,
    images: [],
    isBuffering: false,
    isCatchUpEnabled: false,
    isCatchingUp: false,
    isContentLoaded: false,
    isLive: false,
    isLoading: false,
    isPaused: false,
    isReloading: false,
    isSeeking: false,
    isStopped: true,
    language: undefined,
    liveGap: undefined,
    loadedVideo: null,
    lowLatencyMode: false,
    maximumPosition: undefined,
    minimumPosition: undefined,
    playbackRate: player.getPlaybackRate(),
    subtitle: undefined,
    videoBitrate: undefined,
    videoBitrateAuto: true,
    videoTrackId: undefined,
    volume: player.getVolume(),
    wallClockDiff: undefined
  });
  linkPlayerEventsToState(player, state, $destroy);
  var $switchCatchUpMode = new Subject/* Subject */.xQ();
  $handleCatchUpMode($switchCatchUpMode, player, state).pipe((0,takeUntil/* takeUntil */.R)($destroy)).subscribe(); // dispose of the RxPlayer when destroyed

  $destroy.subscribe(function () {
    return player.dispose();
  });
  return {
    SET_VOLUME: function SET_VOLUME(volume) {
      player.setVolume(volume);
    },
    LOAD: function LOAD(arg) {
      player.loadVideo(Object.assign({
        textTrackElement: textTrackElement,
        networkConfig: {
          segmentRetry: Infinity,
          manifestRetry: Infinity,
          offlineRetry: Infinity
        },
        manualBitrateSwitchingMode: "direct",
        transportOptions: {
          checkMediaSegmentIntegrity: true
        }
      }, arg));
      state.set({
        loadedVideo: arg,
        lowLatencyMode: arg.lowLatencyMode === true
      });
    },
    PLAY: function PLAY() {
      player.play();

      var _state$get = state.get(),
          isStopped = _state$get.isStopped,
          hasEnded = _state$get.hasEnded;

      if (!isStopped && !hasEnded) {
        state.set({
          isPaused: false
        });
      }
    },
    PAUSE: function PAUSE() {
      player.pause();

      var _state$get2 = state.get(),
          isStopped = _state$get2.isStopped,
          hasEnded = _state$get2.hasEnded;

      if (!isStopped && !hasEnded) {
        state.set({
          isPaused: true
        });
      }
    },
    STOP: function STOP() {
      player.stop();
    },
    SEEK: function SEEK(position) {
      player.seekTo({
        position: position
      });
    },
    MUTE: function MUTE() {
      player.mute();
    },
    UNMUTE: function UNMUTE() {
      player.unMute();
    },
    SET_AUDIO_BITRATE: function SET_AUDIO_BITRATE(bitrate) {
      player.setAudioBitrate(bitrate || -1);
      state.set({
        audioBitrateAuto: !bitrate
      });
    },
    SET_VIDEO_BITRATE: function SET_VIDEO_BITRATE(bitrate) {
      player.setVideoBitrate(bitrate || -1);
      state.set({
        videoBitrateAuto: !bitrate
      });
    },
    SET_AUDIO_TRACK: function SET_AUDIO_TRACK(track) {
      player.setAudioTrack(track.id);
    },
    SET_VIDEO_TRACK: function SET_VIDEO_TRACK(track) {
      player.setVideoTrack(track.id);
    },
    DISABLE_VIDEO_TRACK: function DISABLE_VIDEO_TRACK() {
      player.disableVideoTrack();
    },
    SET_SUBTITLES_TRACK: function SET_SUBTITLES_TRACK(track) {
      player.setTextTrack(track.id);
    },
    DISABLE_SUBTITLES_TRACK: function DISABLE_SUBTITLES_TRACK() {
      player.disableTextTrack();
    },
    SET_PLAYBACK_RATE: function SET_PLAYBACK_RATE(rate) {
      player.setPlaybackRate(rate);
      state.set({
        playbackRate: rate
      });
    },
    ENABLE_LIVE_CATCH_UP: function ENABLE_LIVE_CATCH_UP() {
      $switchCatchUpMode.next(true);
    },
    DISABLE_LIVE_CATCH_UP: function DISABLE_LIVE_CATCH_UP() {
      $switchCatchUpMode.next(false);
    }
  };
};

/* harmony default export */ const modules_player = (PLAYER);
;// CONCATENATED MODULE: ./demo/full/scripts/lib/withModulesState.jsx
function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }


/**
 * Higher Order component which link module(s) state to your component's prop.
 *
 * The module(s) concerned should be in your component's prop, named as you
 * wish.
 *
 * The state listened to and the corresponding prop passed to your component
 * is done when calling withModuleState.
 *
 * @example
 * ```js
 * import MyComponent from "./MyComponent.js";
 *
 * const MyEnhancedComponent = withModuleState({
 *   moduleA: {
 *     name_of_the_wanted_state_in_module_A: "wanted_resulting_prop_name",
 *     stateA1: "stateA1Prop",
 *     stateA2: "stateA2Prop",
 *   },
 *
 *   moduleB: {
 *     // Most of the time you might want to name them the same
 *     stateB1: "stateB1",
 *     stateB2: "stateB2",
 *   },
 * })(MyComponent);
 *
 * ReactDOM.render(
 *   <MyEnhancedComponent
 *     moduleA={moduleA}
 *     moduleB={moduleB}
 *   />, el);
 *
 * // in __MyComponent__, the corresponding state will be available in
 * // this.props (example: this.props.stateA1Prop). Those will be binded to the
 * // module's state, so updates will be repercuted on your module.
 *
 * // Note that module can be removed and added to the MyEnhancedComponent props
 * // component without problems. State subscriptions will be unlinked/relinked.
 * ```
 * @param {Object} moduleState
 * @returns {Function}
 */

var withModulesState = function withModulesState(modulesState) {
  return function (Comp) {
    var modulesProps = Object.keys(modulesState);
    var modulesSubscriptions = {};
    return /*#__PURE__*/function (_React$Component) {
      _inheritsLoose(_class, _React$Component);

      function _class() {
        var _this;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
        _this.state = {};
        modulesProps.forEach(function (moduleProp) {
          if (!_this.props[moduleProp]) {
            return;
          }

          var translations = modulesState[modulesProps];
          var module = _this.props[moduleProp];
          var wantedProps = Object.keys(modulesState[moduleProp]);
          wantedProps.forEach(function (state) {
            _this.state[translations[state]] = module.get(state);
          });
        });
        return _this;
      }

      var _proto = _class.prototype;

      _proto.componentDidMount = function componentDidMount() {
        var _this2 = this;

        modulesProps.forEach(function (moduleProp) {
          if (!_this2.props[moduleProp]) {
            return;
          }

          modulesSubscriptions[moduleProp] = [];
          var translations = modulesState[modulesProps];
          var module = _this2.props[moduleProp];
          var wantedProps = Object.keys(modulesState[moduleProp]);
          wantedProps.forEach(function (state) {
            var sub = module.$get(state).subscribe(function (val) {
              var _this2$setState;

              return _this2.setState((_this2$setState = {}, _this2$setState[translations[state]] = val, _this2$setState));
            });
            modulesSubscriptions[moduleProp].push(sub);
          });
        });
      };

      _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
        var _this3 = this;

        modulesProps.forEach(function (moduleProp) {
          if (!nextProps[moduleProp]) {
            if (modulesSubscriptions[moduleProp]) {
              modulesSubscriptions[moduleProp].forEach(function (sub) {
                return sub.unsubscribe();
              });
              delete modulesSubscriptions[moduleProp];
            }

            return;
          }

          if (!modulesSubscriptions[moduleProp]) {
            modulesSubscriptions[moduleProp] = [];
            var translations = modulesState[modulesProps];
            var module = nextProps[moduleProp];
            var wantedProps = Object.keys(modulesState[moduleProp]);
            wantedProps.forEach(function (state) {
              var sub = module.$get(state).subscribe(function (val) {
                var _this3$setState;

                return _this3.setState((_this3$setState = {}, _this3$setState[translations[state]] = val, _this3$setState));
              });
              modulesSubscriptions[moduleProp].push(sub);
            });
          }
        });
      };

      _proto.componentWillUnmount = function componentWillUnmount() {
        Object.keys(modulesSubscriptions).forEach(function (moduleProp) {
          modulesSubscriptions[moduleProp].forEach(function (sub) {
            return sub.unsubscribe();
          });
          delete modulesSubscriptions[moduleProp];
        });
      };

      _proto.render = function render() {
        var newProps = Object.assign({}, this.props, this.state);
        return /*#__PURE__*/react.createElement(Comp, newProps);
      };

      return _class;
    }(react.Component);
  };
};

/* harmony default export */ const lib_withModulesState = (withModulesState);
;// CONCATENATED MODULE: ./demo/full/scripts/components/Button.jsx

/**
 * Generic Button React component.
 * @param {Object} props
 * @returns {Object}
 */

function Button(_ref) {
  var ariaLabel = _ref.ariaLabel,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      onClick = _ref.onClick,
      value = _ref.value,
      disabled = _ref.disabled;

  if (disabled) {
    return /*#__PURE__*/react.createElement("button", {
      "aria-label": ariaLabel,
      disabled: true,
      className: className + " disabled"
    }, value);
  }

  return /*#__PURE__*/react.createElement("button", {
    "aria-label": ariaLabel,
    className: className,
    onClick: onClick
  }, value);
}

/* harmony default export */ const components_Button = (/*#__PURE__*/react.memo(Button));
;// CONCATENATED MODULE: ./demo/full/scripts/lib/time.js
var toSeconds = function toSeconds(timeInSeconds) {
  var toInt = parseInt(timeInSeconds);

  if (!toInt) {
    // TODO differentiate NaN from 0?
    return "00";
  }

  return String(toInt).padStart(2, "0");
};

var toMinutes = function toMinutes(timeInSeconds) {
  var toInt = parseInt(timeInSeconds);

  if (!toInt) {
    // TODO differentiate NaN from 0?
    return "00:00";
  }

  if (toInt < 60) {
    var str = String(toInt);
    return "00:" + str.padStart(2, "0");
  }

  var numberOfMinutes = parseInt(toInt / 60);
  var numberOfSecondsRemaining = toInt % 60;
  return String(numberOfMinutes).padStart(2, "0") + ":" + String(numberOfSecondsRemaining).padStart(2, "0");
};

var toHours = function toHours(timeInSeconds) {
  var toInt = parseInt(timeInSeconds);

  if (!toInt) {
    // TODO differentiate NaN from 0?
    return "00:00";
  }

  if (toInt < 60) {
    var str = String(toInt);
    return "00:" + str.padStart(2, "0");
  }

  var numberOfMinutes = parseInt(toInt / 60);
  var numberOfSecondsRemaining = toInt % 60;

  if (numberOfMinutes < 60) {
    return String(numberOfMinutes).padStart(2, "0") + ":" + String(numberOfSecondsRemaining).padStart(2, "0");
  }

  var numberOfHours = parseInt(numberOfMinutes / 60);
  var numberOfMinutesRemaining = numberOfMinutes % 60;
  return String(numberOfHours).padStart(2, "0") + ":" + String(numberOfMinutesRemaining).padStart(2, "0") + ":" + String(numberOfSecondsRemaining).padStart(2, "0");
};


;// CONCATENATED MODULE: ./demo/full/scripts/components/PositionInfos.jsx


/**
 * Text with the following structure:
 *   CURRENT_POSITION / DURATION
 * @param {Object} props
 * @returns {Object}
 */

function PositionInfos(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      _ref$position = _ref.position,
      position = _ref$position === void 0 ? 0 : _ref$position,
      _ref$duration = _ref.duration,
      duration = _ref$duration === void 0 ? 0 : _ref$duration;
  var convertTime = duration >= 60 * 60 ? toHours : toMinutes;
  return /*#__PURE__*/react.createElement("div", {
    className: "position-infos " + className
  }, /*#__PURE__*/react.createElement("span", {
    className: "current-position"
  }, convertTime(position)), /*#__PURE__*/react.createElement("span", {
    className: "separator"
  }, " / "), /*#__PURE__*/react.createElement("span", {
    className: "duration"
  }, convertTime(duration)));
}

/* harmony default export */ const components_PositionInfos = (/*#__PURE__*/react.memo(PositionInfos));
;// CONCATENATED MODULE: ./demo/full/scripts/components/LivePosition.jsx

/**
 * For now, only written "Live" (we will see for timeshifting and such)
 * @param {Object} props
 * @returns {Object}
 */

function LivePosition(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className;
  return /*#__PURE__*/react.createElement("div", {
    className: "position-infos live " + className
  }, "Live");
}

/* harmony default export */ const components_LivePosition = (/*#__PURE__*/react.memo(LivePosition));
;// CONCATENATED MODULE: ./demo/full/scripts/components/StickToLiveEdgeButton.jsx


function StickToLiveEdgeButton(_ref) {
  var isStickingToTheLiveEdge = _ref.isStickingToTheLiveEdge,
      changeStickToLiveEdge = _ref.changeStickToLiveEdge;
  return /*#__PURE__*/react.createElement("button", {
    className: "running" + (isStickingToTheLiveEdge ? " clicked" : ""),
    "aria-label": "Stay close to the live edge",
    title: "Stick to the live edge",
    onClick: function onClick() {
      return changeStickToLiveEdge(!isStickingToTheLiveEdge);
    }
  }, /*#__PURE__*/react.createElement("svg", {
    version: "1.1",
    viewBox: "0 0 21.803 21.803"
  }, /*#__PURE__*/react.createElement("path", {
    d: "m18.374 16.605l-4.076-2.101-1.107-1.773-0.757-4.503 2.219 1.092-0.375 1.494c-0.13 0.519 0.185 1.041 0.699 1.17 0.077 0.021 0.157 0.03 0.235 0.03 0.432-2e-3 0.823-0.293 0.935-0.729l0.565-2.25c0.11-0.439-0.103-0.897-0.511-1.101 0 0-5.303-2.603-5.328-2.612-0.406-0.188-0.868-0.267-1.342-0.198-0.625 0.088-1.158 0.407-1.528 0.86-0.029 0.027-2.565 3.15-2.565 3.15l-1.95 0.525c-0.514 0.141-0.818 0.668-0.679 1.184 0.116 0.43 0.505 0.713 0.93 0.713 0.083 0 0.168-0.011 0.252-0.033l2.252-0.606c0.196-0.055 0.37-0.167 0.498-0.324l1.009-1.247 0.725 4.026-1.27 1.01c-0.379 0.304-0.541 0.802-0.411 1.269l1.469 5.271c0.148 0.532 0.633 0.881 1.16 0.881 0.107 0 0.216-0.015 0.324-0.045 0.641-0.178 1.016-0.842 0.837-1.482l-1.254-4.502 1.948-1.498 1.151 1.791c0.115 0.186 0.277 0.334 0.471 0.436l4.371 2.25c0.177 0.092 0.363 0.135 0.552 0.135 0.438 0 0.856-0.238 1.072-0.653 0.303-0.6 0.07-1.325-0.521-1.63z"
  }), /*#__PURE__*/react.createElement("circle", {
    cx: "8.602",
    cy: "2.568",
    r: "2.568"
  })));
}

/* harmony default export */ const components_StickToLiveEdgeButton = (/*#__PURE__*/react.memo(StickToLiveEdgeButton));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/PlayPauseButton.jsx



/**
 * Play/Pause button.
 * Triggers the right callback on click.
 *
 * Needs 2 props:
 *   - {Object} player: the player module.
 *   - {string} [className]: An optional className to add to the
 *     button
 *
 * @param {Object} props
 * @returns {Object}
 */

function PlayPauseButton(_ref) {
  var cannotLoadMetadata = _ref.cannotLoadMetadata,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      player = _ref.player,
      isPaused = _ref.isPaused,
      isContentLoaded = _ref.isContentLoaded,
      hasEnded = _ref.hasEnded;
  var disabled = !isContentLoaded && !cannotLoadMetadata;
  var displayPause = !isPaused && isContentLoaded && !hasEnded;
  var completeClassName = "play-pause-button " + className + (disabled ? " disabled" : "");

  var play = function play() {
    return player.dispatch("PLAY");
  };

  var pause = function pause() {
    player.dispatch("DISABLE_LIVE_CATCH_UP");
    player.dispatch("PAUSE");
  };

  return /*#__PURE__*/react.createElement(components_Button, {
    ariaLabel: "Pause/Resume the content",
    className: completeClassName,
    disabled: disabled,
    onClick: displayPause ? pause : play,
    value: String.fromCharCode(displayPause ? 0xf04c : 0xf04b)
  });
}

/* harmony default export */ const controllers_PlayPauseButton = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    cannotLoadMetadata: "cannotLoadMetadata",
    isPaused: "isPaused",
    isContentLoaded: "isContentLoaded",
    hasEnded: "hasEnded",
    stopAtEnd: "stopAtEnd"
  }
})(PlayPauseButton)));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/FullScreenButton.jsx



/**
 * Add the given callback as an event listener of any "fullscreenchange" event.
 * @param {Function} listener
 */

function addFullscreenListener(listener) {
  document.addEventListener("webkitfullscreenchange", listener, false);
  document.addEventListener("mozfullscreenchange", listener, false);
  document.addEventListener("fullscreenchange", listener, false);
  document.addEventListener("MSFullscreenChange", listener, false);
}
/**
 * Remove the given callback from event listeners of any "fullscreenchange"
 * event.
 * @param {Function} listener
 */


function removeFullscreenListener(listener) {
  document.removeEventListener("webkitfullscreenchange", listener, false);
  document.removeEventListener("mozfullscreenchange", listener, false);
  document.removeEventListener("fullscreenchange", listener, false);
  document.removeEventListener("MSFullscreenChange", listener, false);
}
/**
 * Returns true if an element in the document is being displayed in fullscreen
 * mode;
 * otherwise it's false.
 * @returns {boolean}
 */


function FullScreenButton_isFullscreen() {
  return !!(document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
}
/**
 * Request fullScreen action on a given element.
 * @paras {HTMLElement} elt
 * rs-detect)
 */


function FullScreenButton_requestFullscreen(elt) {
  if (!FullScreenButton_isFullscreen()) {
    if (elt.requestFullscreen) {
      elt.requestFullscreen();
    } else if (elt.msRequestFullscreen) {
      elt.msRequestFullscreen();
    } else if (elt.mozRequestFullScreen) {
      elt.mozRequestFullScreen();
    } else if (elt.webkitRequestFullscreen) {
      // TODO Open issue in TypeScript?
      elt.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    }
  }
}
/**
 * Exit fullscreen if an element is currently in fullscreen.
 * TODO this exit fullscreen mode even if any element in the document is in
 * fullscreen, is it really what we want?
 */


function FullScreenButton_exitFullscreen() {
  if (FullScreenButton_isFullscreen()) {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    }
  }
}
/**
 * Simple fullscreen button.
 * Triggers the right callback on click.
 *
 * Needs the following props:
 *   - {Object} player: the player module.
 *   - {HTMLElement} videoElement: the element in fullscreen mode
 *   - {string} [className]: An optional className to add to the
 *     button
 *
 * @param {Object} props
 * @returns {Object}
 */


function FullscreenButton(_ref) {
  var videoElement = _ref.videoElement,
      hasCurrentContent = _ref.hasCurrentContent,
      className = _ref.className;
  var isInitiallyFullscreen = (0,react.useMemo)(function () {
    return FullScreenButton_isFullscreen();
  }, []);

  var _useState = (0,react.useState)(isInitiallyFullscreen),
      isCurrentlyFullScreen = _useState[0],
      setFullscreenValue = _useState[1];

  (0,react.useEffect)(function () {
    var fullscreenListener = function fullscreenListener() {
      var isInFullscreen = FullScreenButton_isFullscreen();

      if (!isInFullscreen) {
        videoElement.classList.remove("fullscreen");
      }

      setFullscreenValue(isInFullscreen);
    };

    addFullscreenListener(fullscreenListener);
    return function () {
      removeFullscreenListener(fullscreenListener);
    };
  }, [videoElement]);
  var setFullscreen = (0,react.useCallback)(function () {
    FullScreenButton_requestFullscreen(videoElement);
    videoElement.classList.add("fullscreen");
  }, [isCurrentlyFullScreen, videoElement]);
  return /*#__PURE__*/react.createElement(components_Button, {
    ariaLabel: "Go/Quit fullscreen",
    className: "fullscreen-button " + className,
    onClick: isCurrentlyFullScreen ? FullScreenButton_exitFullscreen : setFullscreen,
    disabled: !hasCurrentContent,
    value: String.fromCharCode(isCurrentlyFullScreen ? 0xf066 : 0xf065)
  });
}

/* harmony default export */ const FullScreenButton = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    hasCurrentContent: "hasCurrentContent"
  }
})(FullscreenButton)));
;// CONCATENATED MODULE: ./demo/full/scripts/components/ProgressBar.jsx

/**
 * Horizontal (left-to-right) progress bar component which:
 *
 *   - represents the current position and the buffer relatively to the
 *     minimum / maximum position.
 *
 *   - triggers a seek function with the clicked position on click
 *
 *   - call a onMouseMove function with the hovered position and the event when
 *     the mouse hover the component
 *
 *   - call a onMouseOut when it stops hovering it
 *
 * @param {Object} props
 * @returns {Object}
 */

function ProgressBar(_ref) {
  var seek = _ref.seek,
      position = _ref.position,
      bufferGap = _ref.bufferGap,
      minimumPosition = _ref.minimumPosition,
      maximumPosition = _ref.maximumPosition,
      onMouseOut = _ref.onMouseOut,
      _onMouseMove = _ref.onMouseMove;
  var element;
  var duration = Math.max(maximumPosition - minimumPosition, 0);

  var getMousePosition = function getMousePosition(event) {
    var rect = element.getBoundingClientRect();
    var point0 = rect.left;
    var clickPosPx = Math.max(event.clientX - point0, 0);
    var endPointPx = Math.max(rect.right - point0, 0);

    if (!endPointPx) {
      return 0;
    }

    return clickPosPx / endPointPx * duration + minimumPosition;
  }; // weird rx-player design decision. Should be fixed (or done in the
  // module)


  var bufferGapHotFix = isFinite(bufferGap) ? bufferGap : 0;
  var relativePosition = Math.max(position - minimumPosition, 0);
  var percentBuffered = Math.min((bufferGapHotFix + relativePosition) / duration, 1) * 100;
  var percentPosition = Math.min(relativePosition / duration, 1) * 100;
  return /*#__PURE__*/react.createElement("div", {
    className: "progress-bar-wrapper",
    ref: function ref(el) {
      return element = el;
    },
    onClick: function onClick(event) {
      return seek(getMousePosition(event));
    },
    onMouseOut: onMouseOut,
    onMouseMove: function onMouseMove(evt) {
      return _onMouseMove(getMousePosition(evt), evt);
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "progress-bar-current",
    style: {
      "width": percentPosition + "%"
    }
  }), /*#__PURE__*/react.createElement("div", {
    className: "progress-bar-buffered",
    style: {
      "width": percentBuffered + "%"
    }
  }));
}

/* harmony default export */ const components_ProgressBar = (/*#__PURE__*/react.memo(ProgressBar));
;// CONCATENATED MODULE: ./demo/full/scripts/components/ImageTip.jsx

/**
 * React Component which Displays an Image tip centered and on top of the
 * position wanted.
 *
 * Takes 3 props:
 *   - {Blob|string} Image - The image blob to display
 *   - {string} [className=""] - An optional className for the image
 *   - {Number} xPosition - The position on the horizontal axis where you
 *     want the image to be centered to.
 *
 * @class ImageTip
 */

function ImageTip(_ref) {
  var image = _ref.image,
      xPosition = _ref.xPosition,
      className = _ref.className;
  var wrapperEl = (0,react.useRef)(null);

  var _useState = (0,react.useState)(""),
      imageUrl = _useState[0],
      setImageUrl = _useState[1];

  (0,react.useEffect)(function () {
    var blob = new Blob([image], {
      type: "image/jpeg"
    });
    var url = URL.createObjectURL(blob);
    setImageUrl(url);
    return function () {
      URL.revokeObjectURL(url);
    };
  }, [image]);
  (0,react.useEffect)(function () {
    if (isNaN(+xPosition) || wrapperEl.current === null) {
      return null;
    }

    wrapperEl.current.style.transform = "translate(" + xPosition + "px, -136px)";
  }, [xPosition]);
  return /*#__PURE__*/react.createElement("div", {
    className: "image-tip-wrapper",
    ref: wrapperEl
  }, /*#__PURE__*/react.createElement("img", {
    className: "image-tip " + className,
    src: imageUrl
  }));
}

/* harmony default export */ const components_ImageTip = (/*#__PURE__*/react.memo(ImageTip));
;// CONCATENATED MODULE: ./demo/full/scripts/components/ToolTip.jsx

/**
 * Props:
 *   - className {string}
 *   - timeText {number}
 *   - xPosition {number}
 * @class ToolTip
 */

function ToolTip(_ref) {
  var className = _ref.className,
      offset = _ref.offset,
      text = _ref.text,
      xPosition = _ref.xPosition;
  var wrapperEl = (0,react.useRef)(null);
  (0,react.useEffect)(function () {
    if (isNaN(+xPosition) || !wrapperEl.current) {
      return null;
    }

    var rect = wrapperEl.current.getBoundingClientRect();
    var width = rect.width;
    var height = rect.height;
    var toSlideY = -height - 11;
    var toSlideX = xPosition - offset - width / 2;
    wrapperEl.current.style.transform = "translate(" + toSlideX + "px, " + toSlideY + "px)";
  });
  return /*#__PURE__*/react.createElement("div", {
    className: "tooltip-wrapper",
    ref: wrapperEl
  }, /*#__PURE__*/react.createElement("pre", {
    className: "tooltip " + className
  }, text));
}

/* harmony default export */ const components_ToolTip = (/*#__PURE__*/react.memo(ToolTip));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/ProgressBar.jsx
function ProgressBar_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; ProgressBar_setPrototypeOf(subClass, superClass); }

function ProgressBar_setPrototypeOf(o, p) { ProgressBar_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ProgressBar_setPrototypeOf(o, p); }







var Progressbar = /*#__PURE__*/function (_React$Component) {
  ProgressBar_inheritsLoose(Progressbar, _React$Component);

  function Progressbar() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      timeIndicatorVisible: false,
      timeIndicatorPosition: 0,
      timeIndicatorText: "",
      imageTipVisible: false,
      imageTipPosition: 0,
      image: null
    };
    return _this;
  }

  var _proto = Progressbar.prototype;

  _proto.showTimeIndicator = function showTimeIndicator(wallClockTime, clientX, isLive) {
    var hours;
    var minutes;
    var seconds;

    if (isLive) {
      var date = new Date(wallClockTime * 1000);
      hours = date.getHours();
      minutes = date.getMinutes();
      seconds = date.getSeconds();
    } else {
      hours = Math.floor(wallClockTime / 3600);
      minutes = Math.floor((wallClockTime - hours * 3600) / 60);
      seconds = Math.floor(wallClockTime - (minutes * 60 + hours * 3600));
    }

    var currentReadableTime = hours.toString().padStart(2, "0") + ":" + minutes.toString().padStart(2, "0") + ":" + seconds.toString().padStart(2, "0");
    this.setState({
      timeIndicatorVisible: true,
      timeIndicatorPosition: clientX,
      timeIndicatorText: currentReadableTime
    });
  };

  _proto.hideTimeIndicator = function hideTimeIndicator() {
    this.setState({
      timeIndicatorVisible: false,
      timeIndicatorPosition: 0,
      timeIndicatorText: ""
    });
  };

  _proto.showImageTip = function showImageTip(ts, clientX) {
    var images = this.props.images;

    if (!images || !images.length) {
      return;
    }

    var timestampToMs = ts * 1000;
    var imageIndex = images.findIndex(function (i) {
      return i && i.ts > timestampToMs;
    });
    var image = imageIndex === -1 ? images[images.length - 1] : images[imageIndex - 1];

    if (!image) {
      return;
    }

    this.setState({
      imageTipVisible: true,
      imageTipPosition: clientX,
      image: image.data
    });
  };

  _proto.hideImageTip = function hideImageTip() {
    this.setState({
      imageTipVisible: false,
      imageTipPosition: 0,
      image: null
    });
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$state = this.state,
        imageTipVisible = _this$state.imageTipVisible,
        imageTipPosition = _this$state.imageTipPosition,
        image = _this$state.image,
        timeIndicatorVisible = _this$state.timeIndicatorVisible,
        timeIndicatorPosition = _this$state.timeIndicatorPosition,
        timeIndicatorText = _this$state.timeIndicatorText;
    var _this$props = this.props,
        currentTime = _this$props.currentTime,
        minimumPosition = _this$props.minimumPosition,
        maximumPosition = _this$props.maximumPosition,
        isContentLoaded = _this$props.isContentLoaded,
        isLive = _this$props.isLive,
        bufferGap = _this$props.bufferGap,
        player = _this$props.player,
        onSeek = _this$props.onSeek;

    var seek = function seek(position) {
      onSeek();
      player.dispatch("SEEK", position);
    };

    var hideToolTips = function hideToolTips() {
      _this2.hideTimeIndicator();

      _this2.hideImageTip();
    };

    var onMouseMove = function onMouseMove(position, event) {
      var wallClockDiff = player.get("wallClockDiff");
      var wallClockTime = position + wallClockDiff;

      _this2.showTimeIndicator(wallClockTime, event.clientX, isLive);

      _this2.showImageTip(position, event.clientX);
    };

    var toolTipOffset = this.wrapperElement ? this.wrapperElement.getBoundingClientRect().left : 0;

    if (!isContentLoaded) {
      return /*#__PURE__*/react.createElement("div", {
        className: "progress-bar-parent",
        ref: function ref(el) {
          return _this2.wrapperElement = el;
        }
      }, /*#__PURE__*/react.createElement("div", {
        className: "progress-bar-wrapper"
      }));
    }

    return /*#__PURE__*/react.createElement("div", {
      className: "progress-bar-parent",
      ref: function ref(el) {
        return _this2.wrapperElement = el;
      }
    }, timeIndicatorVisible ? /*#__PURE__*/react.createElement(components_ToolTip, {
      className: "progress-tip",
      text: timeIndicatorText,
      xPosition: timeIndicatorPosition,
      offset: toolTipOffset
    }) : null, imageTipVisible ? /*#__PURE__*/react.createElement(components_ImageTip, {
      className: "progress-tip",
      image: image,
      xPosition: imageTipPosition - toolTipOffset
    }) : null, /*#__PURE__*/react.createElement(components_ProgressBar, {
      seek: seek,
      onMouseOut: hideToolTips,
      onMouseMove: onMouseMove,
      position: currentTime,
      minimumPosition: minimumPosition,
      maximumPosition: maximumPosition,
      bufferGap: bufferGap
    }));
  };

  return Progressbar;
}(react.Component);

/* harmony default export */ const controllers_ProgressBar = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    bufferGap: "bufferGap",
    currentTime: "currentTime",
    images: "images",
    isContentLoaded: "isContentLoaded",
    isLive: "isLive",
    minimumPosition: "minimumPosition",
    maximumPosition: "maximumPosition"
  }
})(Progressbar)));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/VolumeButton.jsx



/**
 * Simple volume button.
 * Triggers the right callback on click.
 *
 * Needs 2 props:
 *   - {Object} player: the player module.
 *   - {string} [className]: An optional className to add to the
 *     button
 *
 * @param {Object} props
 * @returns {Object}
 */

function VolumeButton(_ref) {
  var _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      player = _ref.player,
      volume = _ref.volume;
  var volumeLevelClass;
  var charCode;

  if (volume === 0) {
    volumeLevelClass = "muted";
    charCode = 0xf026;
  } else if (volume <= 0.5) {
    volumeLevelClass = "low";
    charCode = 0xf027;
  } else {
    volumeLevelClass = "high";
    charCode = 0xf028;
  }

  return /*#__PURE__*/react.createElement(components_Button, {
    ariaLabel: "Mute/Unmute audio",
    className: "volume-button " + className + " " + volumeLevelClass,
    onClick: volume === 0 ? function () {
      return player.dispatch("UNMUTE");
    } : function () {
      return player.dispatch("MUTE");
    },
    value: String.fromCharCode(charCode)
  });
}

/* harmony default export */ const controllers_VolumeButton = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    volume: "volume"
  }
})(VolumeButton)));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/VolumeBar.jsx


/**
 * Horizontal (left-to-right) volume indication component which:
 *
 *   - represents the current volume relatively to the max and min.
 *
 *   - triggers a setVolume function with the clicked volume percentage on click
 * @param {Object} props
 * @returns {Object}
 */

function VolumeBar(_ref) {
  var player = _ref.player,
      volume = _ref.volume;
  var element;

  var getMouseVolume = function getMouseVolume(event) {
    var rect = element.getBoundingClientRect();
    var point0 = rect.left;
    var clickPosPx = Math.max(event.clientX - point0, 0);
    var endPointPx = Math.max(rect.right - point0, 0);

    if (!endPointPx) {
      return 0;
    }

    return Math.min(clickPosPx / endPointPx, 1);
  };

  return /*#__PURE__*/react.createElement("div", {
    className: "volume-bar-wrapper",
    ref: function ref(el) {
      return element = el;
    },
    onClick: function onClick(evt) {
      return player.dispatch("SET_VOLUME", getMouseVolume(evt));
    }
  }, /*#__PURE__*/react.createElement("div", {
    className: "volume-bar-current",
    style: {
      "width": volume * 100 + "%"
    }
  }));
}

/* harmony default export */ const controllers_VolumeBar = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    volume: "volume"
  }
})(VolumeBar)));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/ControlBar.jsx












function ControlBar(_ref) {
  var currentTime = _ref.currentTime,
      duration = _ref.duration,
      isCatchUpEnabled = _ref.isCatchUpEnabled,
      isCatchingUp = _ref.isCatchingUp,
      isContentLoaded = _ref.isContentLoaded,
      isLive = _ref.isLive,
      isPaused = _ref.isPaused,
      isStopped = _ref.isStopped,
      liveGap = _ref.liveGap,
      lowLatencyMode = _ref.lowLatencyMode,
      maximumPosition = _ref.maximumPosition,
      playbackRate = _ref.playbackRate,
      player = _ref.player,
      stopVideo = _ref.stopVideo,
      toggleSettings = _ref.toggleSettings,
      videoElement = _ref.videoElement;

  var _changeStickToLiveEdge = (0,react.useCallback)(function (shouldStick) {
    if (shouldStick) {
      player.dispatch("ENABLE_LIVE_CATCH_UP");
    } else {
      player.dispatch("DISABLE_LIVE_CATCH_UP");
    }
  }, [player]);

  var isCloseToLive = undefined;

  if (isLive && lowLatencyMode != null && liveGap != null) {
    isCloseToLive = lowLatencyMode ? liveGap < 7 : liveGap < 18;
  }

  var positionElement = (0,react.useMemo)(function () {
    if (!isContentLoaded) {
      return null;
    } else if (isLive) {
      return /*#__PURE__*/react.createElement(components_LivePosition, null);
    } else {
      return /*#__PURE__*/react.createElement(components_PositionInfos, {
        position: currentTime,
        duration: duration
      });
    }
  }, [isContentLoaded, isLive, currentTime, duration]);
  var isAtLiveEdge = isLive && isCloseToLive && !isCatchingUp;
  return /*#__PURE__*/react.createElement("div", {
    className: "controls-bar-container"
  }, /*#__PURE__*/react.createElement(controllers_ProgressBar, {
    player: player,
    onSeek: function onSeek() {
      return _changeStickToLiveEdge(false);
    }
  }), /*#__PURE__*/react.createElement("div", {
    className: "controls-bar"
  }, /*#__PURE__*/react.createElement(controllers_PlayPauseButton, {
    className: "control-button",
    player: player
  }), /*#__PURE__*/react.createElement(components_Button, {
    className: "control-button",
    ariaLabel: "Stop playback",
    onClick: stopVideo,
    value: String.fromCharCode(0xf04d),
    disabled: isStopped
  }), isContentLoaded && isLive && lowLatencyMode ? /*#__PURE__*/react.createElement(components_StickToLiveEdgeButton, {
    isStickingToTheLiveEdge: isCatchUpEnabled,
    changeStickToLiveEdge: function changeStickToLiveEdge() {
      return _changeStickToLiveEdge(!isCatchUpEnabled);
    }
  }) : null, positionElement, isLive && isContentLoaded ? /*#__PURE__*/react.createElement(components_Button, {
    ariaLabel: isAtLiveEdge ? undefined : "Go back to live",
    className: "dot" + (isAtLiveEdge ? " live" : ""),
    onClick: function onClick() {
      if (!isAtLiveEdge) {
        player.dispatch("SEEK", maximumPosition - (lowLatencyMode ? 4 : 10));
      }
    }
  }) : null, /*#__PURE__*/react.createElement("div", {
    className: "controls-right-side"
  }, !isPaused && isCatchingUp && playbackRate > 1 ? /*#__PURE__*/react.createElement("div", {
    className: "catch-up"
  }, "Catch-up playback rate: " + playbackRate) : null, /*#__PURE__*/react.createElement(components_Button, {
    ariaLabel: "Display/Hide controls",
    disabled: !isContentLoaded,
    className: "control-button",
    onClick: toggleSettings,
    value: String.fromCharCode(0xf013)
  }), /*#__PURE__*/react.createElement("div", {
    className: "volume"
  }, /*#__PURE__*/react.createElement(controllers_VolumeButton, {
    className: "control-button",
    player: player
  }), /*#__PURE__*/react.createElement(controllers_VolumeBar, {
    className: "control-button",
    player: player
  })), /*#__PURE__*/react.createElement(FullScreenButton, {
    className: "control-button",
    player: player,
    videoElement: videoElement
  }))));
}

/* harmony default export */ const controllers_ControlBar = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    currentTime: "currentTime",
    duration: "duration",
    isCatchUpEnabled: "isCatchUpEnabled",
    isCatchingUp: "isCatchingUp",
    isContentLoaded: "isContentLoaded",
    isLive: "isLive",
    isPaused: "isPaused",
    isStopped: "isStopped",
    liveGap: "liveGap",
    lowLatencyMode: "lowLatencyMode",
    maximumPosition: "maximumPosition",
    playbackRate: "playbackRate"
  }
})(ControlBar)));
;// CONCATENATED MODULE: ./demo/full/scripts/lib/localStorage.js
var _window = window,
    localStorage = _window.localStorage;
var hasLocalStorage = !!localStorage;

if (!hasLocalStorage) {
  /* eslint-disable-next-line no-console */
  console.warn("`localStorage` is not available." + " You will not be able to store content information.");
}
/**
 * If the current browser does not support local storage, contents will be saved
 * locally in that array.
 * @type {Array.<Object>}
 */


var JS_LOCAL_STORAGE = [];
/**
 * Fetch contents saved locally.
 * @returns {Array.<Object>}
 */

function getLocalStorageContents() {
  if (!hasLocalStorage) {
    return JS_LOCAL_STORAGE;
  }

  var localStorageContents = [];
  var localContentItems = localStorage.getItem("rxPlayerLocalContents");

  if (localContentItems) {
    try {
      localStorageContents.push.apply(localStorageContents, JSON.parse(localContentItems));
    } catch (err) {
      /* eslint-disable-next-line */
      console.warn("Demo: Can't parse local storage content.");
    }
  }

  return localStorageContents;
}
/**
 * Save contents locally.
 * @param {Array.<Object>} localStorageContents
 */

function saveLocalStorageContents(localStorageContents) {
  if (!hasLocalStorage) {
    JS_LOCAL_STORAGE = localStorageContents;
    return;
  }

  localStorage.setItem("rxPlayerLocalContents", JSON.stringify(localStorageContents));
}
/**
 * Save a new content to local storage (or just to the state if localStorage
 * is not available.
 * @param {Object} content - content to save
 * @returns {Object} - The content created
 */

function storeContent(content) {
  var localStorageContents = getLocalStorageContents();
  var id = content.id;
  var index;

  if (content.id != null) {
    index = localStorageContents.findIndex(function (e) {
      return e.id === id;
    });
  } else {
    var lastContentID = localStorageContents.reduce(function (acc, val) {
      var contentId = val.id || 0;
      return Math.max(acc, contentId);
    }, 0);
    id = lastContentID + 1;
    index = -1;
  }

  var localContent = {
    drmInfos: content.drmInfos,
    fallbackKeyError: content.fallbackKeyError,
    fallbackLicenseRequest: content.fallbackLicenseRequest,
    id: id,
    localContent: true,
    lowLatency: content.lowLatency,
    name: content.name,
    transport: content.transport,
    url: content.url
  };

  if (index > -1) {
    localStorageContents.splice(index, 1, localContent);
  } else {
    localStorageContents.push(localContent);
  }

  saveLocalStorageContents(localStorageContents);
  return localContent;
}
/**
 * Remove saved content from localStorage if available.
 * @param {string} id - ID of the content you want to remove.
 * @returns {Boolean} - `false` if the object was not found. `true` otherwise.
 */

function removeStoredContent(id) {
  var localStorageContents = getLocalStorageContents();
  var idx = localStorageContents.findIndex(function (e) {
    return e.id === id;
  });

  if (idx < 0) {
    return false;
  }

  localStorageContents.splice(idx, 1);
  saveLocalStorageContents(localStorageContents);
  return true;
}
;// CONCATENATED MODULE: ./demo/full/scripts/lib/bytes.js
/**
 * Convert a string to an Uint8Array containing the corresponding UTF-16 code
 * units in little-endian.
 * @param {string} str
 * @returns {Uint8Array}
 */
function strToLeUtf16(str) {
  var buffer = new ArrayBuffer(str.length * 2);
  var res = new Uint8Array(buffer);

  for (var i = 0; i < res.length; i += 2) {
    var value = str.charCodeAt(i / 2);
    res[i] = value & 0xFF;
    res[i + 1] = value >> 8 & 0xFF;
  }

  return res;
}
/**
 * Construct string from the little-endian UTF-16 code units given.
 * @param {Uint8Array} bytes
 * @returns {string}
 */

function leUtf16ToStr(bytes) {
  var str = "";

  for (var i = 0; i < bytes.length; i += 2) {
    str += String.fromCharCode((bytes[i + 1] << 8) + bytes[i]);
  }

  return str;
}
/**
 * Convert a string to an Uint8Array containing the corresponding UTF-8 code
 * units.
 * @param {string} str
 * @returns {Uint8Array}
 */

function strToUtf8(str) {
  // http://stackoverflow.com/a/13691499 provides an ugly but functional solution.
  // (Note you have to dig deeper to understand it but I have more faith in
  // stackoverflow not going down in the future so I leave that link.)
  // Briefly said, `utf8Str` will contain a version of `str` where every
  // non-ASCII characters will be replaced by an escape sequence of the
  // corresponding representation of those characters in UTF-8.
  // It does sound weird and unnecessarily complicated, but it works!
  //
  // Here is actually what happens with more words. We will rely on two browser
  // APIs:
  //
  //   - `encodeURIComponent` will take a string and convert the non-ASCII
  //     characters in it into the percent-encoded version of the corresponding
  //     UTF-8 bytes
  //     Example: encodeURIComponent("") => 0xC3 0xA9 => `"%C3%A9"`
  //
  //   - `unescape` unescapes (so far so good) a percent-encoded string. But it
  //     does it in a really simple way: percent-encoded byte by percent-encoded
  //     byte into the corresponding extended ASCII representation on 8 bits.
  //     As a result, we end-up with a string which actually contains instead of
  //     each of its original characters, the UTF-8 code units (8 bits) of
  //     those characters.
  //     Let's take our previous `"" => "%C3%A9"` example. Here we would get:
  //     unecape("%C3%A9") => "\u00c3\u00a9" === "" (in extended ASCII)
  //
  // By iterating on the resulting string, we will then be able to generate a
  // Uint8Array containing the UTF-8 representation of that original string, by
  // just calling the charCodeAt API on it.
  var utf8Str;
  var pcStr = encodeURIComponent(str); // As "unescape" is a deprecated function we want to declare a fallback in the
  // case a browser decide to not implement it.

  if (typeof window.unescape === "function") {
    utf8Str = unescape(pcStr);
  } else {
    // simple unescape function
    // http://ecma-international.org/ecma-262/9.0/#sec-unescape-string
    var isHexChar = /[0-9a-fA-F]/;
    var pcStrLen = pcStr.length;
    utf8Str = "";

    for (var i = 0; i < pcStr.length; i++) {
      var wasPercentEncoded = false;

      if (pcStr[i] === "%") {
        if (i <= pcStrLen - 6 && pcStr[i + 1] === "u" && isHexChar.test(pcStr[i + 2]) && isHexChar.test(pcStr[i + 3]) && isHexChar.test(pcStr[i + 4]) && isHexChar.test(pcStr[i + 5])) {
          var charCode = parseInt(pcStr.substring(i + 1, i + 6), 16);
          utf8Str += String.fromCharCode(charCode);
          wasPercentEncoded = true;
          i += 5; // Skip the next 5 chars
        } else if (i <= pcStrLen - 3 && isHexChar.test(pcStr[i + 1]) && isHexChar.test(pcStr[i + 2])) {
          var _charCode = parseInt(pcStr.substring(i + 1, i + 3), 16);

          utf8Str += String.fromCharCode(_charCode);
          wasPercentEncoded = true;
          i += 2; // Skip the next 2 chars
        }
      }

      if (!wasPercentEncoded) {
        utf8Str += pcStr[i];
      }
    }
  } // Now let's just build our array from every other bytes of that string's
  // UTF-16 representation


  var res = new Uint8Array(utf8Str.length);

  for (var _i = 0; _i < utf8Str.length; _i++) {
    res[_i] = utf8Str.charCodeAt(_i) & 0xFF; // first byte should be 0x00 anyway
  }

  return res;
}
/**
 * Creates a new string from the given array of char codes.
 * @param {Uint8Array} args
 * @returns {string}
 */

function stringFromCharCodes(args) {
  var max = 16000;
  var ret = "";

  for (var i = 0; i < args.length; i += max) {
    var subArray = args.subarray(i, i + max);
    ret += String.fromCharCode.apply(null, subArray);
  }

  return ret;
}
/**
 * Transform an integer into an hexadecimal string of the given length, padded
 * to the left with `0` if needed.
 * @example
 * ```
 * intToHex(5, 4); // => "0005"
 * intToHex(5, 2); // => "05"
 * intToHex(10, 1); // => "a"
 * intToHex(268, 3); // => "10c"
 * intToHex(4584, 6) // => "0011e8"
 * intToHex(123456, 4); // => "1e240" (we do nothing when going over 4 chars)
 * ```
 * @param {number} num
 * @param {number} size
 * @returns {string}
 */

function intToHex(num, size) {
  var toStr = num.toString(16);
  return toStr.length >= size ? toStr : new Array(size - toStr.length + 1).join("0") + toStr;
}
/**
 * Creates a string from the given Uint8Array containing utf-8 code units.
 * @param {Uint8Array} bytes
 * @returns {string}
 */


function utf8ToStr(data) {
  var uint8 = data; // If present, strip off the UTF-8 BOM.

  if (uint8[0] === 0xEF && uint8[1] === 0xBB && uint8[2] === 0xBF) {
    uint8 = uint8.subarray(3);
  } // We're basically doing strToUtf8 in reverse.
  // You can look at that other function for the whole story.
  // Generate string containing escaped UTF-8 code units


  var utf8Str = stringFromCharCodes(uint8);
  var escaped;

  if (typeof window.escape !== "function") {
    // Transform UTF-8 escape sequence into percent-encoded escape sequences.
    escaped = escape(utf8Str);
  } else {
    // Let's implement a simple escape function
    // http://ecma-international.org/ecma-262/9.0/#sec-escape-string
    var nonEscapedChar = /[A-Za-z0-9*_+-./]/;
    escaped = "";

    for (var i = 0; i < utf8Str.length; i++) {
      if (nonEscapedChar.test(utf8Str[i])) {
        escaped += utf8Str[i];
      } else {
        var charCode = utf8Str.charCodeAt(i);
        escaped += charCode >= 256 ? "%u" + intToHex(charCode, 4) : "%" + intToHex(charCode, 2);
      }
    }
  } // Decode the percent-encoded UTF-8 string into the proper JS string.
  // Example: "g#%E3%82%AC" -> "g#"


  return decodeURIComponent(escaped);
}
;// CONCATENATED MODULE: ./demo/full/scripts/lib/parseDRMConfigurations.js

function parseDRMConfigurations(drmConfigurations) {
  return Promise.all(drmConfigurations.map(function (drmConfig) {
    var drm = drmConfig.drm,
        fallbackKeyError = drmConfig.fallbackKeyError,
        fallbackLicenseRequest = drmConfig.fallbackLicenseRequest,
        licenseServerUrl = drmConfig.licenseServerUrl,
        serverCertificateUrl = drmConfig.serverCertificateUrl;

    if (!licenseServerUrl) {
      return;
    }

    var type = drm.toLowerCase();
    var keySystem = {
      type: type,
      getLicense: generateGetLicense(licenseServerUrl, type, !!fallbackLicenseRequest),
      fallbackOn: {
        keyInternalError: !!fallbackKeyError,
        keyOutputRestricted: !!fallbackKeyError
      }
    };

    if (!serverCertificateUrl) {
      return keySystem;
    }

    return getServerCertificate(serverCertificateUrl).then(function (serverCertificate) {
      keySystem.serverCertificate = serverCertificate;
      return keySystem;
    });
  })).then(function (keySystems) {
    return keySystems.filter(function (ks) {
      return ks;
    });
  });
}

function getServerCertificate(url) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.responseType = "arraybuffer";

    xhr.onload = function (evt) {
      if (xhr.status >= 200 && xhr.status < 300) {
        var serverCertificate = evt.target.response;
        resolve(serverCertificate);
      } else {
        reject();
      }
    };

    xhr.onerror = function (err) {
      reject(err);
    };

    xhr.send();
  });
}

function formatPlayreadyChallenge(challenge) {
  var str = leUtf16ToStr(challenge);
  var match = /<Challenge encoding="base64encoded">(.*)<\/Challenge>/.exec(str);
  var xml = match ? atob(match[1]) :
  /* IE11 / EDGE */
  utf8ToStr(challenge); // Chromecast

  return xml;
}

function generateGetLicense(licenseServerUrl, drmType, fallbackOnLastTry) {
  var isPlayready = drmType.indexOf("playready") !== -1;
  return function (rawChallenge) {
    var challenge = isPlayready ? formatPlayreadyChallenge(rawChallenge) : rawChallenge;
    var xhr = new XMLHttpRequest();
    xhr.open("POST", licenseServerUrl, true);
    return new Promise(function (resolve, reject) {
      xhr.onerror = function () {
        var error = new Error("getLicense's request failed on an error");
        error.fallbackOnLastTry = fallbackOnLastTry;
        reject(error);
      };

      xhr.onload = function (evt) {
        if (xhr.status >= 200 && xhr.status < 300) {
          var license = evt.target.response;
          resolve(license);
        } else {
          var error = new Error("getLicense's request finished with a " + (xhr.status + " HTTP error"));
          error.noRetry = fallbackOnLastTry;
          error.fallbackOnLastTry = fallbackOnLastTry;
          reject(error);
        }
      };

      if (isPlayready) {
        xhr.setRequestHeader("content-type", "text/xml; charset=utf-8");
      } else {
        xhr.responseType = "arraybuffer";
      }

      xhr.send(challenge);
    }).then(function (license) {
      return isPlayready && typeof license === "string" ? strToUtf8(license) : license;
    });
  };
}
;// CONCATENATED MODULE: ./demo/full/scripts/lib/url_hash.js
/**
 * Parse possible information given through the "hash" part of the URL (what
 * comes after the "#" character).
 *
 * This format was done to be:
 *   - easy to parse in JavaScript
 *   - readable by a human, one should get roughly an idea of the information
 *     given just by looking at that string.
 *   - compact enough to be shareable through e-mails without cluttering it
 *   - possible to copy sub-parts of that string (example an URL contained in
 *     it) and use it without human effort (i.e. no string escaping)
 *
 * Here is how it works:
 * The format is based on a key-value scheme. The type of the key is always a
 * string and two types of value (for the moment?) can be communicated: strings
 * and booleans.
 *
 * The key is designated by a name. This is a string of any length which should
 * not contain any exclamation mark ("!") or underscore ("_") character as those
 * are reserved, but could technically contain any other characters (we are
 * though usually limited here by URL-encoding).
 * Each of those keys are prepended by an exclamation mark ("!") character.
 *
 * To communicate a boolean value, that key is immediately either followed by
 * the next key (which is again, prepended by an exclamation mark character) or
 * by the end of the whole string, which indicates the end of the data.
 * A boolean value encountered is always inferred to be `true`. To set is to
 * `false`, just remove the key from the string. There is no difference between
 * `false` and a not-defined key.
 * Example:
 * http://www.example.com/#!lowLatency!noAutoplay
 * => will get you the following JS Object:
 * ```js
 * {
 *   lowLatency: true,
 *   noAutoplay: true
 * }
 * ```
 *
 * When the key has a string as a value, things are a little different.
 * The key is followed by an underscore ("_") character and then by the length
 * of the data (the communicated string) in terms of UTF-16 code units (note:
 * a surrogate pairs is 2 code units).
 * That length itself is then converted in a base-36 number (think 0-9 then
 * a-z) to take less space in a URL.
 * Because this length can, depending on the length of the data, need one or
 * more Base-36 numbers, an equal ("=") sign is added to mark the end of this
 * length.
 * The data then starts just after that equal sign and ends at the end of the
 * announced length (followed either by the following field - prepended by an
 * exclamation mark - or the end of the string).
 * Example with both booleans and strings and a `FIELD_LENGTH` of 4:
 * http://www.example.com/#!lowLatency!manifest_1n=http://www.example.com/streaming/dash_contents/Manifest.mpd!foobar
 * => will get you
 * ```js
 * {
 *   lowLatency: true,
 *   manifest: "http://www.example.com/streaming/dash_contents/Manifest.mpd",
 *   foobar: true
 * }
 * ```

 * If any invalid data is encountered, this function returns null.
 * @param {string} hashStr
 * @return {Object|null}
 */
function parseHashInURL(hashStr) {
  if (hashStr.length <= 1) {
    return null;
  }

  var parsed = {}; // Note a previous version made use of the non-percent-encodable "\" separator
  // instead of the "!" we use today.
  // To still support links done in previous version, we want to detect which
  // of those two separators is used.
  // Fortunately, the first key also starts with a separator. This means that
  // the separator should always be the second character of the hash (after
  // "#").

  var separatorChar = hashStr[1];
  var hashOffset = 2; // initial "#!"

  var hashLen = hashStr.length;

  while (hashOffset + 1 <= hashLen) {
    var unparsedStr = hashStr.substring(hashOffset);
    var nextSeparator = unparsedStr.indexOf(separatorChar);
    var nextUnderscore = unparsedStr.indexOf("_");

    if (nextUnderscore <= 0 || nextSeparator >= 0 && nextUnderscore > nextSeparator) {
      // this is a boolean
      var fieldLength = nextSeparator >= 0 ? nextSeparator : unparsedStr.length;
      var fieldName = unparsedStr.substring(0, fieldLength);
      hashOffset += fieldLength; // skip field name

      parsed[fieldName] = true;
    } else {
      // data in a string form
      var _fieldName = unparsedStr.substring(0, nextUnderscore);

      hashOffset += nextUnderscore + 1; // skip field name and its following
      // underscore

      var splitted = unparsedStr.substring(nextUnderscore + 1).split("=");

      if (!splitted.length) {
        return null;
      }

      var dataLength = splitted[0];
      var dataLengthLen = splitted[0].length + 1; // length + "="

      hashOffset += dataLengthLen;
      var lenNb = parseInt(dataLength, 36);

      if (isNaN(lenNb)) {
        return null;
      }

      var dataStart = hashOffset;
      hashOffset += lenNb;
      var data = hashStr.substring(dataStart, hashOffset);
      parsed[_fieldName] = data;
    }

    hashOffset += 1; // skip next separator
  }

  return parsed;
}
/**
 * Generate URL with hash-string which can be used to reload the page with the
 * current non-stored custom content. This can be used for example to share some
 * content with other people.
 * Returns null if it could not generate an URL for the current content.
 * @param {Object} state - The current ContentList state.
 * @returns {string|null}
 */

function generateLinkForCustomContent(_ref) {
  var autoPlay = _ref.autoPlay,
      chosenDRMType = _ref.chosenDRMType,
      customKeySystem = _ref.customKeySystem,
      fallbackKeyError = _ref.fallbackKeyError,
      fallbackLicenseRequest = _ref.fallbackLicenseRequest,
      licenseServerUrl = _ref.licenseServerUrl,
      lowLatency = _ref.lowLatency,
      manifestURL = _ref.manifestURL,
      serverCertificateUrl = _ref.serverCertificateUrl,
      transport = _ref.transport;
  var urlString = "";
  var transportString = "";
  var licenseServerUrlString = "";
  var serverCertificateUrlString = "";
  var drmTypeString = "";
  var customKeySystemString = "";

  if (manifestURL) {
    urlString = "!manifest_" + manifestURL.length.toString(36) + "=" + manifestURL;
  }

  if (transport) {
    transportString = "!tech_" + transport.length.toString(36) + "=" + transport;
  }

  if (chosenDRMType) {
    drmTypeString = "!drm_" + chosenDRMType.length.toString(36) + "=" + chosenDRMType;
  }

  if (customKeySystem) {
    customKeySystemString = "!customKeySystem_" + customKeySystem.length.toString(36) + "=" + customKeySystem;
  }

  if (licenseServerUrl) {
    licenseServerUrlString = "!licenseServ_" + licenseServerUrl.length.toString(36) + "=" + licenseServerUrl;
  }

  if (serverCertificateUrl) {
    serverCertificateUrlString = "!certServ_" + serverCertificateUrl.length.toString(36) + "=" + serverCertificateUrl;
  }

  if (!transportString) {
    return null;
  }

  return location.protocol + "//" + location.hostname + (location.port ? ":" + location.port : "") + location.pathname + (location.search ? location.search : "") + "#" + (!autoPlay ? "!noAutoplay" : "") + (lowLatency ? "!lowLatency" : "") + (fallbackKeyError ? "!fallbackKeyError" : "") + (fallbackLicenseRequest ? "!fallbackLicenseRequest" : "") + transportString + urlString + drmTypeString + customKeySystemString + licenseServerUrlString + serverCertificateUrlString;
}
;// CONCATENATED MODULE: ./demo/full/scripts/components/FocusedInput.jsx

/**
 * Simple text input which is focused when mounted.
 * Call `onChange` when updated.
 */

function FocusedInput(_ref) {
  var ariaLabel = _ref.ariaLabel,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      onChange = _ref.onChange,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? "" : _ref$value,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder;
  var inputEl = (0,react.useRef)(null);
  (0,react.useEffect)(function () {
    if (inputEl.current != null) {
      inputEl.current.focus();
    }
  }, []
  /* trigger only when mounted */
  );
  return /*#__PURE__*/react.createElement("input", {
    ref: inputEl,
    className: "input " + className,
    "aria-label": ariaLabel,
    type: "text",
    placeholder: placeholder,
    onChange: onChange,
    value: value
  });
}

/* harmony default export */ const components_FocusedInput = (/*#__PURE__*/react.memo(FocusedInput));
;// CONCATENATED MODULE: ./demo/full/scripts/components/Input.jsx

/**
 * Simple text input.
 * Call `onChange` when updated.
 * @param {Object} props
 * @returns {Object}
 */

function Input(_ref) {
  var ariaLabel = _ref.ariaLabel,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      onChange = _ref.onChange,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? "" : _ref$value,
      _ref$placeholder = _ref.placeholder,
      placeholder = _ref$placeholder === void 0 ? "" : _ref$placeholder;
  return /*#__PURE__*/react.createElement("input", {
    "aria-label": ariaLabel,
    className: "input " + className,
    type: "text",
    placeholder: placeholder,
    onChange: onChange,
    value: value
  });
}

/* harmony default export */ const components_Input = (/*#__PURE__*/react.memo(Input));
;// CONCATENATED MODULE: ./demo/full/scripts/components/Select.jsx

/**
 * Simple select list. Call the onChange call back on choice with the index of
 * the option chosen in argument.
 * @param {Object} props
 * @returns {Object}
 */

function Select(_ref) {
  var ariaLabel = _ref.ariaLabel,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      onChange = _ref.onChange,
      selected = _ref.selected,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? [] : _ref$options,
      disabled = _ref.disabled;
  var optionsEl = options.map(function (val, index) {
    return typeof val === "object" ? /*#__PURE__*/react.createElement("option", {
      key: index,
      value: index,
      disabled: val.disabled
    }, val.name) : /*#__PURE__*/react.createElement("option", {
      key: index,
      value: index
    }, val);
  });
  var selectEl = disabled ? /*#__PURE__*/react.createElement("select", {
    "aria-label": ariaLabel,
    value: selected,
    disabled: "disabled",
    onChange: onChange
  }, optionsEl) : /*#__PURE__*/react.createElement("select", {
    "aria-label": ariaLabel,
    value: selected,
    onChange: onChange
  }, optionsEl);
  return /*#__PURE__*/react.createElement("section", {
    className: "select " + className
  }, selectEl);
}

/* harmony default export */ const components_Select = (/*#__PURE__*/react.memo(Select));
;// CONCATENATED MODULE: ./demo/full/scripts/metaplaylist_url.js
var MetaPlaylistDASHSmooth = {
  "type": "MPL",
  "version": "0.1",
  "dynamic": false,
  "contents": [{
    "url": "https://www.bok.net/dash/tears_of_steel/cleartext/stream.mpd",
    "startTime": 0,
    "endTime": 733.3,
    "transport": "dash"
  }, {
    "url": "https://amssamples.streaming.mediaservices.windows.net/683f7e47-bd83-4427-b0a3-26a6c4547782/BigBuckBunny.ism/manifest",
    "startTime": 733.3,
    "endTime": 1368,
    "transport": "smooth"
  }]
};
var MetaPlaylistDASHSmoothBlob = new Blob([JSON.stringify(MetaPlaylistDASHSmooth)], {
  type: "application/json"
});
/* harmony default export */ const metaplaylist_url = (URL.createObjectURL(MetaPlaylistDASHSmoothBlob));
;// CONCATENATED MODULE: ./demo/full/scripts/contents.js

/* harmony default export */ const contents = ([{
  "name": "Tears of Steel (clear)",
  "url": "https://www.bok.net/dash/tears_of_steel/cleartext/stream.mpd",
  "transport": "dash",
  "live": false
}, {
  "name": "Tears of Steel (DRM Widevine)",
  "url": "https://demo.unified-streaming.com/video/tears-of-steel/tears-of-steel-dash-widevine.ism/.mpd",
  "transport": "dash",
  "live": false,
  "drmInfos": [{
    "licenseServerUrl": "https://cwip-shaka-proxy.appspot.com/no_auth",
    "drm": "Widevine"
  }]
}, {
  "name": "Tears of Steel (DRM PlayReady)",
  "url": "https://demo.unified-streaming.com/video/tears-of-steel/tears-of-steel-dash-playready.ism/.mpd",
  "transport": "dash",
  "live": false,
  "drmInfos": [{
    "licenseServerUrl": "https://test.playready.microsoft.com/service/rightsmanager.asmx?PlayRight=1&UseSimpleNonPersistentLicense=1",
    "drm": "Playready"
  }]
}, {
  "name": "BBC - presentationTimeOffset on audio and video",
  "url": "http://rdmedia.bbc.co.uk/dash/ondemand/testcard/1/client_manifest-pto_both-events.mpd",
  "transport": "dash",
  "live": false
}, {
  "name": "DASH-IF - Multi-Subtitles",
  "url": "https://livesim.dashif.org/dash/vod/testpic_2s/multi_subs.mpd",
  "transport": "dash",
  "live": false
}, {
  "name": "BBC - Testcard Audio-only",
  "url": "http://rdmedia.bbc.co.uk/dash/ondemand/testcard/1/client_manifest-audio.mpd",
  "transport": "dash",
  "live": false
}, {
  "name": "DASH-IF - Audio-only",
  "url": "https://dash.akamaized.net/dash264/TestCases/3a/fraunhofer/aac-lc_stereo_without_video/Sintel/sintel_audio_only_aaclc_stereo_sidx.mpd",
  "transport": "dash",
  "live": false
}, {
  "name": "DASH IF - SegmentTemplate",
  "url": "https://livesim.dashif.org/livesim/testpic_2s/Manifest.mpd",
  "transport": "dash",
  "live": true
}, {
  "name": "DASH IF - SegmentTimeline",
  "url": "https://livesim.dashif.org/livesim/segtimeline_1/testpic_2s/Manifest.mpd",
  "transport": "dash",
  "live": true
}, {
  "name": "Envivio - DASH",
  "url": "http://dash.edgesuite.net/envivio/EnvivioDash3/manifest.mpd",
  "transport": "dash"
}, {
  "name": "Unified Streaming - Timeline - A-Team",
  "url": "https://demo.unified-streaming.com/video/ateam/ateam.ism/ateam.mpd",
  "transport": "dash"
}, {
  "name": "Super SpeedWay",
  "url": "https://playready.directtaps.net/smoothstreaming/SSWSS720H264/SuperSpeedway_720.ism/Manifest",
  "transport": "smooth"
}, {
  "name": "Big Buck Bunny",
  "url": "https://amssamples.streaming.mediaservices.windows.net/683f7e47-bd83-4427-b0a3-26a6c4547782/BigBuckBunny.ism/manifest",
  "transport": "smooth"
}, // {
//   "name": "Microsoft: XBoxOne Ad",
//   "url": "https://profficialsite.origin.mediaservices.windows.net/9cc5e871-68ec-42c2-9fc7-fda95521f17d/dayoneplayready.ism/manifest",
//   "transport": "smooth",
//   "live": false,
//   "drmInfos": [{
//     "licenseServerUrl": "https://test.playready.microsoft.com/service/rightsmanager.asmx?PlayRight=1&UseSimpleNonPersistentLicense=1",
//     "drm": "Playready",
//   }],
// },
{
  "name": "Smooth Ingest",
  "url": "https://b028.wpc.azureedge.net/80B028/Samples/a38e6323-95e9-4f1f-9b38-75eba91704e4/5f2ce531-d508-49fb-8152-647eba422aec.ism/manifest",
  "transport": "smooth",
  "live": true
}, {
  "name": "Taxi 3 SoundTrack (Audio-Only)",
  "url": "https://playready.directtaps.net/smoothstreaming/ISMAAACLC/Taxi3_AACLC.ism/Manifest",
  "transport": "smooth"
}, {
  "name": "Multi-Period (5 Periods of 2 min)",
  "url": "https://download.tsi.telecom-paristech.fr/gpac/DASH_CONFORMANCE/TelecomParisTech/mp4-live-periods/mp4-live-periods-mpd.mpd",
  "transport": "dash",
  "live": false
}, {
  "name": "Big Buck Bunny WEBM",
  "url": "https://upload.wikimedia.org/wikipedia/commons/transcoded/8/88/Big_Buck_Bunny_alt.webm/Big_Buck_Bunny_alt.webm.360p.webm",
  "transport": "directfile",
  "live": false
}, {
  "name": "Big Buck Bunny MP4",
  "url": "http://download.blender.org/peach/bigbuckbunny_movies/BigBuckBunny_320x180.mp4",
  "transport": "directfile",
  "live": false
}, {
  "name": "Wikipedia test OGG (AUDIO ONLY)",
  "url": "https://upload.wikimedia.org/wikipedia/commons/f/f2/Median_test.ogg",
  "transport": "directfile",
  "live": false
}, {
  "name": "Google - Sintel webm only",
  "url": "https://storage.googleapis.com/shaka-demo-assets/sintel-webm-only/dash.mpd",
  "transport": "dash",
  "live": false
}, {
  "name": "Multi Video Tracks",
  "url": "https://utils.ssl.cdn.cra.cz/dash/1/manifest.mpd",
  "transport": "dash",
  "live": false
}, {
  "name": "Mix of DASH and Smooth VOD Contents",
  "url": metaplaylist_url,
  "transport": "metaplaylist"
}]);
;// CONCATENATED MODULE: ./demo/full/scripts/components/GenerateLinkURL.jsx

/**
 * @param {Object} props
 * @returns {Object}
 */

function GeneratedLinkURL(_ref) {
  var url = _ref.url;

  if (url === undefined || url === null || url === "") {
    return /*#__PURE__*/react.createElement("span", null, "URL: ", /*#__PURE__*/react.createElement("a", {
      className: "generated-url-link none"
    }, "Not a valid content!"));
  }

  return /*#__PURE__*/react.createElement("span", null, "URL: ", /*#__PURE__*/react.createElement("a", {
    className: "generated-url-link",
    href: url
  }, url));
}

/* harmony default export */ const GenerateLinkURL = (/*#__PURE__*/react.memo(GeneratedLinkURL));
;// CONCATENATED MODULE: ./demo/full/scripts/components/GenerateLinkButton.jsx


function GenerateLinkButton(_ref) {
  var enabled = _ref.enabled,
      onClick = _ref.onClick;
  return /*#__PURE__*/react.createElement("button", {
    "aria-label": "Generate link for the current custom button",
    className: "link" + (enabled ? " enabled" : ""),
    onClick: onClick
  }, /*#__PURE__*/react.createElement("svg", {
    "aria-hidden": "true",
    focusable: "false",
    role: "img",
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 512 512"
  }, /*#__PURE__*/react.createElement("path", {
    fill: "currentColor",
    d: "M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z"
  })));
}

/* harmony default export */ const components_GenerateLinkButton = (/*#__PURE__*/react.memo(GenerateLinkButton));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/ContentList.jsx
function ContentList_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; ContentList_setPrototypeOf(subClass, superClass); }

function ContentList_setPrototypeOf(o, p) { ContentList_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ContentList_setPrototypeOf(o, p); }












var MediaKeys_ = window.MediaKeys || window.MozMediaKeys || window.WebKitMediaKeys || window.MSMediaKeys || null;
var HAS_EME_APIs = typeof navigator.requestMediaKeySystemAccess === "function" || MediaKeys_ != null && MediaKeys_.prototype && typeof MediaKeys_.isTypeSupported === "function" || typeof HTMLVideoElement.prototype.webkitGenerateKeyRequest === "function";
var IS_HTTPS = window.location.protocol.startsWith("https");
var CUSTOM_DRM_NAME = "Other";
var TRANSPORT_TYPES = ["DASH", "Smooth", "DirectFile", "MetaPlaylist"];
var DRM_TYPES = ["Widevine", "Playready", "Clearkey", CUSTOM_DRM_NAME];
var DISABLE_ENCRYPTED_CONTENT = !HAS_EME_APIs && !IS_HTTPS;
var URL_DENOMINATIONS = {
  DASH: "URL to the MPD",
  Smooth: "URL to the Manifest",
  DirectFile: "URL to the content"
};
/**
 * Format content for using in component.
 * @param {Object} content
 * @returns {Object} - formatted content
 */

function formatContent(content) {
  var displayName = content.name;
  var isDisabled = false;
  var isLocalContent = false;

  if (IS_HTTPS) {
    if (!content.localContent && content.url.startsWith("http:")) {
      displayName = "[HTTP only] " + displayName;
      isDisabled = true;
    }
  } else if (!HAS_EME_APIs && content.drmInfos && content.drmInfos.length) {
    displayName = "[HTTPS only] " + displayName;
    isDisabled = true;
  }

  if (content.live) {
    displayName += " (live)";
  }

  if (content.localContent) {
    displayName = (hasLocalStorage ? "[Stored] " : "[Saved] ") + displayName;
    isLocalContent = true;
  }

  return {
    contentName: content.name,
    displayName: displayName,
    drmInfos: content.drmInfos,
    fallbackKeyError: !!content.fallbackKeyError,
    fallbackLicenseRequest: !!content.fallbackLicenseRequest,
    id: content.id,
    isDisabled: isDisabled,
    isLocalContent: isLocalContent,
    isLowLatency: !!content.lowLatency,
    supplementaryImageTracks: content.supplementaryImageTracks,
    supplementaryTextTracks: content.supplementaryTextTracks,
    transport: content.transport,
    url: content.url
  };
}
/**
 * Contruct list of contents per type of transport from:
 *   - contents stored in local storage (or just memory)
 *   - contents declared locally
 * @returns {Object}
 */


function constructContentList() {
  var localStorageContents = getLocalStorageContents();
  var reversedStoredContents = localStorageContents.slice().reverse();
  var storedAndRegularContents = reversedStoredContents.concat(contents);
  return TRANSPORT_TYPES.reduce(function (acc, tech) {
    var customLinkContent = {
      url: "",
      contentName: "",
      transport: tech,
      drmInfos: [],
      displayName: "Custom link",
      isLocalContent: false,
      isDisabled: false,
      isLowLatency: false
    };
    acc[tech] = [customLinkContent].concat(storedAndRegularContents.filter(function (_ref) {
      var transport = _ref.transport;
      return transport === tech.toLowerCase();
    }).map(formatContent));
    return acc;
  }, {});
}
/**
 * Generate URL with hash-string which can be used to reload the page with the
 * current stored content or demo content. This can be used for example to
 * share some content with other people.
 * Returns null if it could not generate an URL for the current content.
 * @param {Object} content - The content object as constructed in the
 * ContentList.
 * @param {Object} state - The current ContentList state.
 * @returns {string|null}
 */


function generateLinkForContent(content, _ref2) {
  var autoPlay = _ref2.autoPlay,
      transportType = _ref2.transportType,
      fallbackKeyError = _ref2.fallbackKeyError,
      fallbackLicenseRequest = _ref2.fallbackLicenseRequest;

  if (content == null) {
    return null;
  }

  var licenseServerUrl = content.drmInfos && content.drmInfos[0] && content.drmInfos[0].licenseServerUrl;
  var serverCertificateUrl = content.drmInfos && content.drmInfos[0] && content.drmInfos[0].serverCertificateUrl;
  return generateLinkForCustomContent({
    autoPlay: autoPlay,
    chosenDRMType: content.drmInfos && content.drmInfos[0] && content.drmInfos[0].drm,
    customKeySystem: content.drmInfos && content.drmInfos[0] && content.drmInfos[0].customKeySystem,
    fallbackKeyError: fallbackKeyError,
    fallbackLicenseRequest: fallbackLicenseRequest,
    manifestURL: content.url,
    licenseServerUrl: licenseServerUrl,
    lowLatency: !!content.isLowLatency,
    serverCertificateUrl: serverCertificateUrl,
    transport: transportType
  });
}
/**
 * @param {HTMLElement} checkBoxElt
 * @returns {boolean}
 */


function getCheckBoxValue(checkBoxElt) {
  return checkBoxElt.type === "checkbox" ? !!checkBoxElt.checked : !!checkBoxElt.value;
}
/**
 * Returns index of the first content to display according to all contents
 * available.
 * @param {Array.<Object>} contentList
 * @returns {number}
 */


function getIndexOfFirstEnabledContent(contentList) {
  var contentChoiceIndex = 1;

  if (contentList.length <= 0) {
    throw new Error("No content for the transport: ", TRANSPORT_TYPES[0]);
  }

  while (contentChoiceIndex < contentList.length && contentList[contentChoiceIndex].isDisabled) {
    contentChoiceIndex++;
  }

  if (contentChoiceIndex >= contentList.length) {
    return 0;
  }

  return contentChoiceIndex;
}
/**
 * @param {Array.<Object>} drmInfos
 * @param {Object} fallbacks
 * @returns {Promise.<Array.<Object>>}
 */


function getKeySystemsOption(drmInfos, _ref3) {
  var fallbackKeyError = _ref3.fallbackKeyError,
      fallbackLicenseRequest = _ref3.fallbackLicenseRequest;
  var wantedDRMs = drmInfos.map(function (drmInfo) {
    return {
      drm: drmInfo.drm === CUSTOM_DRM_NAME ? drmInfo.customKeySystem : drmInfo.drm,
      licenseServerUrl: drmInfo.licenseServerUrl,
      serverCertificateUrl: drmInfo.serverCertificateUrl,
      fallbackKeyError: fallbackKeyError,
      fallbackLicenseRequest: fallbackLicenseRequest
    };
  }).filter(function (drmInfo) {
    return drmInfo.drm !== undefined;
  });
  return parseDRMConfigurations(wantedDRMs);
}

var ContentList = /*#__PURE__*/function (_React$Component) {
  ContentList_inheritsLoose(ContentList, _React$Component);

  function ContentList() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    var contentsPerType = constructContentList();
    var transportType = TRANSPORT_TYPES[0];
    _this.state = {
      autoPlay: true,
      contentChoiceIndex: 0,
      contentNameField: "",
      contentsPerType: contentsPerType,
      chosenDRMType: DRM_TYPES[0],
      customKeySystem: "",
      currentManifestURL: "",
      displayGeneratedLink: false,
      displayDRMSettings: false,
      fallbackKeyError: false,
      fallbackLicenseRequest: false,
      isSavingOrUpdating: false,
      licenseServerUrl: "",
      lowLatencyChecked: false,
      serverCertificateUrl: "",
      transportType: transportType
    };
    return _this;
  }

  var _proto = ContentList.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var parsedHash = parseHashInURL(location.hash);

    if (parsedHash !== null) {
      var tech = parsedHash.tech;

      if (TRANSPORT_TYPES.includes(tech)) {
        var fallbackKeyError = parsedHash.fallbackKeyError,
            fallbackLicenseRequest = parsedHash.fallbackLicenseRequest,
            lowLatency = parsedHash.lowLatency;
        var newState = {
          autoPlay: !parsedHash.noAutoplay,
          contentChoiceIndex: 0,
          contentNameField: "",
          contentList: this.state.contentsPerType[tech],
          currentManifestURL: parsedHash.manifest,
          fallbackKeyError: !!fallbackKeyError,
          fallbackLicenseRequest: !!fallbackLicenseRequest,
          lowLatencyChecked: tech === "DASH" && !!lowLatency,
          transportType: tech
        };
        var chosenDRMType = DRM_TYPES.includes(parsedHash.drm) ? parsedHash.drm : undefined;

        if (chosenDRMType !== undefined) {
          newState.displayDRMSettings = true;
          newState.chosenDRMType = chosenDRMType;
          newState.customKeySystem = parsedHash.customKeySystem || "";
          newState.licenseServerUrl = parsedHash.licenseServ || "";
          newState.serverCertificateUrl = parsedHash.certServ || "";
        }

        this.setState(newState);
        return;
      }
    } // estimate first index which should be selected


    var contentList = this.state.contentsPerType[this.state.transportType];
    var firstEnabledContentIndex = getIndexOfFirstEnabledContent(contentList);
    var content = contentList[firstEnabledContentIndex];
    this.changeSelectedContent(firstEnabledContentIndex, content);
  }
  /**
   * Load the given content through the player.
   * @param {Object} content
   */
  ;

  _proto.loadContent = function loadContent(content) {
    var _this$props = this.props,
        loadVideo = _this$props.loadVideo,
        stopVideo = _this$props.stopVideo;
    var autoPlay = this.state.autoPlay;

    if (content == null) {
      stopVideo();
      return;
    }

    var url = content.url,
        transport = content.transport,
        fallbackKeyError = content.fallbackKeyError,
        fallbackLicenseRequest = content.fallbackLicenseRequest,
        supplementaryImageTracks = content.supplementaryImageTracks,
        supplementaryTextTracks = content.supplementaryTextTracks,
        isLowLatency = content.isLowLatency,
        _content$drmInfos = content.drmInfos,
        drmInfos = _content$drmInfos === void 0 ? [] : _content$drmInfos;
    getKeySystemsOption(drmInfos, {
      fallbackKeyError: fallbackKeyError,
      fallbackLicenseRequest: fallbackLicenseRequest
    }).then(function (keySystems) {
      loadVideo({
        url: url,
        transport: transport,
        autoPlay: autoPlay,
        supplementaryImageTracks: supplementaryImageTracks,
        supplementaryTextTracks: supplementaryTextTracks,
        textTrackMode: "html",
        lowLatencyMode: isLowLatency,
        keySystems: keySystems
      });
    });
  }
  /**
   * @param {string} url
   * @param {Array.<Object>} drmInfos
   * @param {boolean} autoPlay
   */
  ;

  _proto.loadUrl = function loadUrl(url, drmInfos, autoPlay) {
    var _this2 = this;

    var loadVideo = this.props.loadVideo;
    var _this$state = this.state,
        lowLatencyChecked = _this$state.lowLatencyChecked,
        fallbackKeyError = _this$state.fallbackKeyError,
        fallbackLicenseRequest = _this$state.fallbackLicenseRequest;
    getKeySystemsOption(drmInfos, {
      fallbackKeyError: fallbackKeyError,
      fallbackLicenseRequest: fallbackLicenseRequest
    }).then(function (keySystems) {
      loadVideo({
        url: url,
        transport: _this2.state.transportType.toLowerCase(),
        autoPlay: autoPlay,
        textTrackMode: "html",
        keySystems: keySystems,
        lowLatencyMode: lowLatencyChecked
      });
    });
  }
  /**
   * Update type of transport chosen.
   * @param {string} transportType
   */
  ;

  _proto.changeTransportType = function changeTransportType(transportType) {
    this.setState({
      contentChoiceIndex: 0,
      contentNameField: "",
      chosenDRMType: DRM_TYPES[0],
      customKeySystem: "",
      currentManifestURL: "",
      displayDRMSettings: false,
      displayGeneratedLink: false,
      fallbackLicenseRequest: false,
      fallbackKeyError: false,
      isSavingOrUpdating: false,
      licenseServerUrl: "",
      lowLatencyChecked: false,
      serverCertificateUrl: "",
      transportType: transportType
    });
  }
  /**
   * Change the content chosen in the list.
   * @param {number} index - index in the lsit
   * @param {Object} content - content object
   */
  ;

  _proto.changeSelectedContent = function changeSelectedContent(index, content) {
    var currentManifestURL = "";
    var contentNameField = "";
    var customKeySystem = "";
    var licenseServerUrl = "";
    var serverCertificateUrl = "";
    var hasDRMSettings = content.drmInfos != null && content.drmInfos.length > 0;
    var drm = null;
    currentManifestURL = content.url;
    contentNameField = content.contentName;
    var fallbackKeyError = !!content.fallbackKeyError;
    var fallbackLicenseRequest = !!content.fallbackLicenseRequest;
    var isLowLatency = !!content.isLowLatency;

    if (hasDRMSettings) {
      drm = content.drmInfos[0].drm;
      customKeySystem = content.drmInfos[0].customKeySystem || "";
      licenseServerUrl = content.drmInfos[0].licenseServerUrl;
      serverCertificateUrl = content.drmInfos[0].serverCertificateUrl;
    }

    this.setState({
      contentChoiceIndex: index,
      contentNameField: contentNameField,
      chosenDRMType: drm != null ? drm : DRM_TYPES[0],
      customKeySystem: customKeySystem,
      currentManifestURL: currentManifestURL,
      displayDRMSettings: hasDRMSettings,
      displayGeneratedLink: false,
      fallbackLicenseRequest: fallbackLicenseRequest,
      fallbackKeyError: fallbackKeyError,
      isSavingOrUpdating: false,
      lowLatencyChecked: isLowLatency,
      licenseServerUrl: licenseServerUrl,
      serverCertificateUrl: serverCertificateUrl
    });
  };

  _proto.render = function render() {
    var _this3 = this;

    var _this$state2 = this.state,
        autoPlay = _this$state2.autoPlay,
        contentChoiceIndex = _this$state2.contentChoiceIndex,
        contentNameField = _this$state2.contentNameField,
        contentsPerType = _this$state2.contentsPerType,
        chosenDRMType = _this$state2.chosenDRMType,
        customKeySystem = _this$state2.customKeySystem,
        currentManifestURL = _this$state2.currentManifestURL,
        displayGeneratedLink = _this$state2.displayGeneratedLink,
        displayDRMSettings = _this$state2.displayDRMSettings,
        fallbackKeyError = _this$state2.fallbackKeyError,
        fallbackLicenseRequest = _this$state2.fallbackLicenseRequest,
        isSavingOrUpdating = _this$state2.isSavingOrUpdating,
        licenseServerUrl = _this$state2.licenseServerUrl,
        lowLatencyChecked = _this$state2.lowLatencyChecked,
        serverCertificateUrl = _this$state2.serverCertificateUrl,
        transportType = _this$state2.transportType;
    var isCustomContent = contentChoiceIndex === 0;
    var isCustomDRM = chosenDRMType === CUSTOM_DRM_NAME;
    var contentsToSelect = contentsPerType[transportType];
    var chosenContent = contentsToSelect[contentChoiceIndex];
    var generatedLink = null;

    if (displayGeneratedLink) {
      generatedLink = contentChoiceIndex === 0 || isSavingOrUpdating ? generateLinkForCustomContent({
        autoPlay: autoPlay,
        chosenDRMType: displayDRMSettings ? chosenDRMType : undefined,
        customKeySystem: displayDRMSettings ? customKeySystem : undefined,
        fallbackKeyError: fallbackKeyError,
        fallbackLicenseRequest: fallbackLicenseRequest,
        manifestURL: currentManifestURL,
        licenseServerUrl: displayDRMSettings ? licenseServerUrl : undefined,
        lowLatency: lowLatencyChecked,
        serverCertificateUrl: displayDRMSettings ? serverCertificateUrl : undefined,
        transport: transportType
      }) : generateLinkForContent(chosenContent, this.state);
    }

    var hasURL = currentManifestURL !== "";
    var isLocalContent = !!(chosenContent && chosenContent.isLocalContent);

    var onTransportChange = function onTransportChange(evt) {
      var index = +evt.target.value;

      if (index >= 0) {
        var newTransportType = TRANSPORT_TYPES[index];

        _this3.changeTransportType(newTransportType); // update content selection


        var contents = contentsPerType[newTransportType];
        var firstEnabledContentIndex = getIndexOfFirstEnabledContent(contents);

        _this3.changeSelectedContent(firstEnabledContentIndex, contents[firstEnabledContentIndex]);
      }
    };

    var onContentChoiceChange = function onContentChoiceChange(evt) {
      var index = +evt.target.value;
      var content = contentsToSelect[index];

      _this3.changeSelectedContent(index, content);
    };

    var onClickLoad = function onClickLoad() {
      if (contentChoiceIndex === 0) {
        var drmInfos = [{
          licenseServerUrl: licenseServerUrl,
          serverCertificateUrl: serverCertificateUrl,
          drm: chosenDRMType,
          customKeySystem: customKeySystem
        }];

        _this3.loadUrl(currentManifestURL, drmInfos, autoPlay);
      } else {
        _this3.loadContent(contentsToSelect[contentChoiceIndex]);
      }
    };

    var saveCurrentContent = function saveCurrentContent() {
      var contentToSave = {
        name: contentNameField,
        url: currentManifestURL,
        fallbackLicenseRequest: fallbackLicenseRequest,
        fallbackKeyError: fallbackKeyError,
        lowLatency: lowLatencyChecked,
        transport: transportType.toLowerCase(),
        drmInfos: displayDRMSettings ? [{
          drm: chosenDRMType,
          customKeySystem: customKeySystem,
          licenseServerUrl: licenseServerUrl,
          serverCertificateUrl: serverCertificateUrl
        }] : undefined,
        id: chosenContent.id
      };
      var storedContent = storeContent(contentToSave); // reconstruct list of contents

      var contentList = constructContentList();

      _this3.setState({
        contentsPerType: contentList,
        isSavingOrUpdating: false
      }); // update content selection


      var contents = contentList[transportType];
      var firstEnabledContentIndex = contents.findIndex(function (c) {
        return c.id === storedContent.id;
      });

      if (firstEnabledContentIndex < 0) {
        /* eslint-disable-next-line no-console */
        console.warn("Stored content not found in local storage.");

        _this3.changeSelectedContent(0, contents[0]);
      } else {
        _this3.changeSelectedContent(firstEnabledContentIndex, contents[firstEnabledContentIndex]);
      }
    };

    var onClickSaveOrUpdate = function onClickSaveOrUpdate() {
      return _this3.setState({
        isSavingOrUpdating: true
      });
    };

    var onClickErase = function onClickErase() {
      var content = contentsToSelect[contentChoiceIndex];

      if (content) {
        var hasRemoved = removeStoredContent(content.id);

        if (hasRemoved) {
          // reconstruct list of contents
          var contentList = constructContentList();

          _this3.setState({
            contentsPerType: contentList
          }); // update content selection


          var contents = contentList[transportType];

          if (contentChoiceIndex >= contentList.length) {
            _this3.changeSelectedContent(0, contents[0]);
          } else {
            _this3.changeSelectedContent(contentChoiceIndex, contents[contentChoiceIndex]);
          }
        }
      }
    };

    var onNameInput = function onNameInput(evt) {
      return _this3.setState({
        contentNameField: evt.target.value
      });
    };

    var onManifestInput = function onManifestInput(evt) {
      return _this3.setState({
        currentManifestURL: evt.target.value
      });
    };

    var onCustomKeySystemInput = function onCustomKeySystemInput(evt) {
      return _this3.setState({
        customKeySystem: evt.target.value
      });
    };

    var onLicenseServerInput = function onLicenseServerInput(evt) {
      return _this3.setState({
        licenseServerUrl: evt.target.value
      });
    };

    var onServerCertificateInput = function onServerCertificateInput(evt) {
      return _this3.setState({
        serverCertificateUrl: evt.target.value
      });
    };

    var onChangeDisplayDRMSettings = function onChangeDisplayDRMSettings(evt) {
      var value = getCheckBoxValue(evt.target);

      if (value) {
        _this3.setState({
          displayDRMSettings: true
        });

        return;
      }

      _this3.setState({
        displayDRMSettings: false,
        licenseServerUrl: "",
        serverCertificateUrl: ""
      });
    };

    var onAutoPlayClick = function onAutoPlayClick(evt) {
      return _this3.setState({
        autoPlay: getCheckBoxValue(evt.target)
      });
    };

    var onLowLatencyClick = function onLowLatencyClick(evt) {
      _this3.setState({
        lowLatencyChecked: getCheckBoxValue(evt.target)
      });
    };

    var onDRMTypeClick = function onDRMTypeClick(type) {
      if (chosenDRMType === type) {
        return;
      }

      _this3.setState({
        chosenDRMType: type,
        customKeySystem: ""
      });
    };

    var onCancel = function onCancel() {
      _this3.setState({
        isSavingOrUpdating: false
      }); // re-load content


      _this3.changeSelectedContent(contentChoiceIndex, chosenContent);
    };

    var generateDRMButtons = function generateDRMButtons() {
      return DRM_TYPES.map(function (type) {
        return /*#__PURE__*/react.createElement(components_Button, {
          className: "choice-input-button drm-button" + (chosenDRMType === type ? " selected" : ""),
          onClick: function onClick() {
            return onDRMTypeClick(type);
          },
          value: type
        });
      });
    };

    var onClickGenerateLink = function onClickGenerateLink() {
      _this3.setState({
        displayGeneratedLink: !displayGeneratedLink
      });
    };

    var onChangeFallbackLicenseRequest = function onChangeFallbackLicenseRequest(evt) {
      _this3.setState({
        fallbackLicenseRequest: getCheckBoxValue(evt.target)
      });
    };

    var onChangeFallbackKeyError = function onChangeFallbackKeyError(evt) {
      _this3.setState({
        fallbackKeyError: getCheckBoxValue(evt.target)
      });
    };

    var selectValues = contentsToSelect.map(function (c) {
      return {
        name: c.displayName,
        disabled: c.isDisabled
      };
    });
    return /*#__PURE__*/react.createElement("div", {
      className: "choice-inputs-wrapper"
    }, /*#__PURE__*/react.createElement("span", {
      className: "generated-url" + (displayGeneratedLink ? " enabled" : "")
    }, displayGeneratedLink ? /*#__PURE__*/react.createElement(GenerateLinkURL, {
      url: generatedLink
    }) : null), /*#__PURE__*/react.createElement("div", {
      className: "content-inputs"
    }, /*#__PURE__*/react.createElement("div", {
      className: "content-inputs-selects"
    }, /*#__PURE__*/react.createElement(components_Select, {
      className: "choice-input transport-type-choice white-select",
      ariaLabel: "Select a transport",
      onChange: onTransportChange,
      options: TRANSPORT_TYPES,
      selected: TRANSPORT_TYPES.indexOf(transportType)
    }), /*#__PURE__*/react.createElement(components_Select, {
      className: "choice-input content-choice white-select",
      ariaLabel: "Select a content",
      onChange: onContentChoiceChange,
      options: selectValues,
      selected: contentChoiceIndex
    })), /*#__PURE__*/react.createElement("div", {
      className: "content-inputs-middle"
    }, isCustomContent || isLocalContent ? [/*#__PURE__*/react.createElement(components_Button, {
      className: "choice-input-button content-button enter-name-button" + (!hasURL ? " disabled" : ""),
      ariaLabel: "Save or update custom content",
      onClick: onClickSaveOrUpdate,
      disabled: !hasURL || isSavingOrUpdating,
      value: isLocalContent ? isSavingOrUpdating ? "Updating..." : "Update content" : isSavingOrUpdating ? "Saving..." : "Store content"
    }), /*#__PURE__*/react.createElement(components_GenerateLinkButton, {
      enabled: displayGeneratedLink,
      onClick: onClickGenerateLink
    })] : null, isLocalContent ? /*#__PURE__*/react.createElement(components_Button, {
      className: "choice-input-button erase-button",
      ariaLabel: "Remove custom content from saved contents",
      onClick: onClickErase,
      value: String.fromCharCode(0xf1f8)
    }) : null), /*#__PURE__*/react.createElement("div", {
      className: "choice-input-button-wrapper"
    }, /*#__PURE__*/react.createElement("div", {
      className: "auto-play"
    }, "AutoPlay", /*#__PURE__*/react.createElement("label", {
      className: "input switch"
    }, /*#__PURE__*/react.createElement("input", {
      type: "checkbox",
      "aria-label": "Enable/Disable AutoPlay",
      checked: autoPlay,
      onChange: onAutoPlayClick
    }), /*#__PURE__*/react.createElement("span", {
      className: "slider round"
    }))), /*#__PURE__*/react.createElement(components_Button, {
      className: "choice-input-button load-button",
      ariaLabel: "Load the selected content now",
      onClick: onClickLoad,
      value: String.fromCharCode(0xf144)
    }))), isCustomContent || isLocalContent && isSavingOrUpdating ? /*#__PURE__*/react.createElement("div", {
      className: "custom-input-wrapper"
    }, isSavingOrUpdating ? /*#__PURE__*/react.createElement("div", {
      className: "update-control"
    }, /*#__PURE__*/react.createElement(components_FocusedInput, {
      className: "text-input need-to-fill",
      ariaLabel: "Name of the custom content to save",
      onChange: onNameInput,
      value: contentNameField,
      placeholder: "Content name"
    }), /*#__PURE__*/react.createElement("div", {
      className: "update-control-buttons"
    }, /*#__PURE__*/react.createElement(components_Button, {
      className: "choice-input-button content-button save-button",
      ariaLabel: "Save/Update custom content",
      onClick: saveCurrentContent,
      disabled: !contentNameField || !currentManifestURL,
      value: isLocalContent ? "Update" : "Save"
    }), /*#__PURE__*/react.createElement(components_Button, {
      ariaLabel: "Cancel current modifications for the custom content",
      className: "choice-input-button content-button cancel-button",
      onClick: onCancel,
      value: "Cancel"
    }))) : null, /*#__PURE__*/react.createElement(components_Input, {
      ariaLabel: "Enter here the Manifest's URL",
      className: "text-input",
      onChange: onManifestInput,
      value: currentManifestURL,
      placeholder: (URL_DENOMINATIONS[transportType] || "URL to the " + transportType + " content") + (IS_HTTPS ? " (HTTPS only if mixed contents disabled)" : "")
    }), /*#__PURE__*/react.createElement("div", {
      className: "player-box player-box-load"
    }, /*#__PURE__*/react.createElement("span", {
      className: "encryption-checkbox custom-checkbox" + (DISABLE_ENCRYPTED_CONTENT ? " disabled" : "")
    }, (DISABLE_ENCRYPTED_CONTENT ? "[HTTPS only] " : "") + "Encrypted content", /*#__PURE__*/react.createElement("label", {
      className: "switch"
    }, /*#__PURE__*/react.createElement("input", {
      "aria-label": "Enable for an encrypted content",
      disabled: DISABLE_ENCRYPTED_CONTENT,
      name: "displayDRMSettingsTextInput",
      type: "checkbox",
      checked: displayDRMSettings,
      onChange: onChangeDisplayDRMSettings
    }), /*#__PURE__*/react.createElement("span", {
      className: "slider round"
    }))), displayDRMSettings ? /*#__PURE__*/react.createElement("div", {
      className: "drm-settings"
    }, /*#__PURE__*/react.createElement("div", {
      className: "drm-choice"
    }, generateDRMButtons()), isCustomDRM ? /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(components_Input, {
      ariaLabel: "Key system reverse domain name (e.g. \"org.w3.clearkey\")",
      className: "choice-input text-input",
      onChange: onCustomKeySystemInput,
      value: customKeySystem,
      placeholder: "Key system (reverse domain name)"
    })) : null, /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement(components_Input, {
      ariaLabel: "URL for the license server",
      className: "choice-input text-input",
      onChange: onLicenseServerInput,
      value: licenseServerUrl,
      placeholder: "License URL Server"
    })), /*#__PURE__*/react.createElement(components_Input, {
      ariaLabel: "URL for the server certificate (optional)",
      className: "choice-input text-input",
      onChange: onServerCertificateInput,
      value: serverCertificateUrl,
      placeholder: "Server certificate URL (optional)"
    }), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("span", {
      className: "custom-checkbox fallback-checkbox"
    }, /*#__PURE__*/react.createElement("span", null, "Fallback if a key is refused ", /*#__PURE__*/react.createElement("span", {
      className: "checkbox-indication"
    }, "(for content with multiple keys)")), /*#__PURE__*/react.createElement("label", {
      className: "input switch fallback-switch"
    }, /*#__PURE__*/react.createElement("input", {
      type: "checkbox",
      checked: fallbackKeyError,
      onChange: onChangeFallbackKeyError
    }), /*#__PURE__*/react.createElement("span", {
      className: "slider round"
    })))), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("span", {
      className: "custom-checkbox fallback-checkbox"
    }, /*#__PURE__*/react.createElement("span", null, "Fallback if the license request fails ", /*#__PURE__*/react.createElement("span", {
      className: "checkbox-indication"
    }, "(for content with multiple keys)")), /*#__PURE__*/react.createElement("label", {
      className: "input switch fallback-switch"
    }, /*#__PURE__*/react.createElement("input", {
      type: "checkbox",
      checked: fallbackLicenseRequest,
      onChange: onChangeFallbackLicenseRequest
    }), /*#__PURE__*/react.createElement("span", {
      className: "slider round"
    }))))) : null), transportType === "DASH" ? /*#__PURE__*/react.createElement("div", {
      className: "player-box player-box-load button-low-latency"
    }, /*#__PURE__*/react.createElement("span", {
      className: "low-latency-checkbox custom-checkbox"
    }, "Low-Latency content", /*#__PURE__*/react.createElement("label", {
      className: "input switch"
    }, /*#__PURE__*/react.createElement("input", {
      "aria-label": "Enable for a low-latency content",
      type: "checkbox",
      checked: lowLatencyChecked,
      onChange: onLowLatencyClick
    }), /*#__PURE__*/react.createElement("span", {
      className: "slider round"
    })))) : null) : null);
  };

  return ContentList;
}(react.Component);

/* harmony default export */ const controllers_ContentList = (ContentList);
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/ErrorDisplayer.jsx



var PlayerError = function PlayerError(_ref) {
  var error = _ref.error;
  var message = error && error.message ? error.message : error;
  return /*#__PURE__*/react.createElement("span", {
    className: "fatal-error"
  }, /*#__PURE__*/react.createElement("span", {
    className: "error-icon icon"
  }, String.fromCharCode(0xf071)), /*#__PURE__*/react.createElement("span", {
    className: "error-intro"
  }, "The Player encountered a fatal Error:"), /*#__PURE__*/react.createElement("span", {
    className: "error-message"
  }, message));
};

var ErrorDisplayer = function ErrorDisplayer(_ref2) {
  var error = _ref2.error;
  return /*#__PURE__*/react.createElement("div", {
    className: "player-error"
  }, error ? /*#__PURE__*/react.createElement(PlayerError, {
    error: error
  }) : null);
};

/* harmony default export */ const controllers_ErrorDisplayer = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    error: "error"
  }
})(ErrorDisplayer)));
;// CONCATENATED MODULE: ./node_modules/rxjs/_esm5/internal/operators/skip.js
/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */


function skip(count) {
  return function (source) {
    return source.lift(new SkipOperator(count));
  };
}

var SkipOperator = /*@__PURE__*/function () {
  function SkipOperator(total) {
    this.total = total;
  }

  SkipOperator.prototype.call = function (subscriber, source) {
    return source.subscribe(new SkipSubscriber(subscriber, this.total));
  };

  return SkipOperator;
}();

var SkipSubscriber = /*@__PURE__*/function (_super) {
  tslib_es6/* __extends */.ZT(SkipSubscriber, _super);

  function SkipSubscriber(destination, total) {
    var _this = _super.call(this, destination) || this;

    _this.total = total;
    _this.count = 0;
    return _this;
  }

  SkipSubscriber.prototype._next = function (x) {
    if (++this.count > this.total) {
      this.destination.next(x);
    }
  };

  return SkipSubscriber;
}(Subscriber/* Subscriber */.L);
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/LogDisplayer.jsx
function LogDisplayer_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; LogDisplayer_setPrototypeOf(subClass, superClass); }

function LogDisplayer_setPrototypeOf(o, p) { LogDisplayer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return LogDisplayer_setPrototypeOf(o, p); }






var LogElement = function LogElement(_ref) {
  var text = _ref.text,
      date = _ref.date;
  return /*#__PURE__*/react.createElement("div", {
    className: "player-log-item"
  }, date.toISOString() + " - " + text);
};

var LogDisplayer = /*#__PURE__*/function (_React$Component) {
  LogDisplayer_inheritsLoose(LogDisplayer, _React$Component);

  function LogDisplayer() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      logs: []
    }; // A weird React behavior obligates me to mutate a this._logs array instead
    // of calling setState directly to allow multiple setState in a row before
    // rendering.
    // The case seen was that this.state.logs would not change right after
    // setState, so the last addLog call would be the only one really considered

    _this._logs = []; // Only scroll to bottom if already scrolled to bottom

    _this.hasScrolledToBottom = true;
    return _this;
  }

  var _proto = LogDisplayer.prototype;

  _proto.addLog = function addLog(text) {
    this._logs = [].concat(this._logs, [{
      text: text,
      date: new Date()
    }]);
    this.setState({
      logs: this._logs.slice()
    });
  };

  _proto.resetLogs = function resetLogs() {
    this._logs = [];
    this.setState({
      logs: []
    });
  };

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    this.destructionSubject = new Subject/* Subject */.xQ();
    var player = this.props.player;
    player.$get("videoBitrateAuto").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject)).subscribe(function (vbAuto) {
      var text = "Video Bitrate selection changed to " + (vbAuto ? "automatic" : "manual");

      _this2.addLog(text);
    });
    player.$get("audioBitrateAuto").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject)).subscribe(function (abAuto) {
      var text = "Audio Bitrate selection changed to " + (abAuto ? "automatic" : "manual");

      _this2.addLog(text);
    });
    player.$get("videoBitrate").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject)).subscribe(function (vb) {
      var text = "Video Bitrate changed to " + vb;

      _this2.addLog(text);
    });
    player.$get("audioBitrate").pipe((0,takeUntil/* takeUntil */.R)(this.destructionSubject), skip(1) // skip initial value
    ).subscribe(function (ab) {
      var text = "Audio Bitrate changed to " + ab;

      _this2.addLog(text);
    });
    player.$get("error").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject), (0,filter/* filter */.h)(function (x) {
      return x;
    })).subscribe(function (error) {
      var message = error.message ? error.message : error;
      var text = "The player encountered a fatal Error: " + message;

      _this2.addLog(text);
    });
    player.$get("isLoading").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject), (0,filter/* filter */.h)(function (x) {
      return x;
    })).subscribe(function () {
      var text = "A new content is Loading.";

      _this2.addLog(text);
    });
    player.$get("hasCurrentContent").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject), (0,filter/* filter */.h)(function (x) {
      return x;
    })).subscribe(function () {
      var text = "The new content has been loaded.";

      _this2.addLog(text);
    });
    player.$get("isStopped").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject), (0,filter/* filter */.h)(function (x) {
      return x;
    })).subscribe(function () {
      var text = "The current content is stopped";

      _this2.addLog(text);
    });
    player.$get("hasEnded").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject), (0,filter/* filter */.h)(function (x) {
      return x;
    })).subscribe(function () {
      var text = "The current content has ended";

      _this2.addLog(text);
    });
    player.$get("isBuffering").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject)).subscribe(function (ib) {
      var text = ib ? "The current content is buffering" : "The current content is not buffering anymore";

      _this2.addLog(text);
    });
    player.$get("isSeeking").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject)).subscribe(function (ib) {
      var text = ib ? "The current content is seeking" : "The current content is not seeking anymore";

      _this2.addLog(text);
    });
    player.$get("availableLanguages").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject)).subscribe(function () {
      var text = "The audio track list has changed";

      _this2.addLog(text);
    });
    player.$get("availableSubtitles").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject)).subscribe(function () {
      var text = "The text track list has changed";

      _this2.addLog(text);
    });
    player.$get("availableVideoTracks").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject)).subscribe(function () {
      var text = "The video track list has changed";

      _this2.addLog(text);
    });
    player.$get("availableAudioBitrates").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject)).subscribe(function () {
      var text = "The audio bitrate list has changed";

      _this2.addLog(text);
    });
    player.$get("availableVideoBitrates").pipe(skip(1), // skip initial value
    (0,takeUntil/* takeUntil */.R)(this.destructionSubject)).subscribe(function () {
      var text = "The video bitrate list has changed";

      _this2.addLog(text);
    });
    this.scrollToBottom();

    var onScroll = function onScroll() {
      if (_this2.element.scrollHeight - _this2.element.offsetHeight === _this2.element.scrollTop) {
        _this2.hasScrolledToBottom = true;
      } else {
        _this2.hasScrolledToBottom = false;
      }
    };

    this.element.addEventListener("scroll", onScroll, {
      passive: true
    });
    this.destructionSubject.subscribe(function () {
      return _this2.element.removeEventListener("scroll", onScroll);
    });
  };

  _proto.scrollToBottom = function scrollToBottom() {
    if (this.hasScrolledToBottom) {
      this.element.scrollTop = this.element.scrollHeight;
    }
  };

  _proto.componentDidUpdate = function componentDidUpdate() {
    this.scrollToBottom();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.destructionSubject.next();
    this.destructionSubject.complete();
  };

  _proto.render = function render() {
    var _this3 = this;

    var logs = this.state.logs;
    var logTexts = logs.map(function (_ref2) {
      var text = _ref2.text,
          date = _ref2.date;
      return /*#__PURE__*/react.createElement(LogElement, {
        text: text,
        date: date
      });
    });

    var clearLogs = function clearLogs() {
      return _this3.resetLogs();
    };

    return /*#__PURE__*/react.createElement("div", {
      className: "player-logs-wrapper"
    }, /*#__PURE__*/react.createElement("div", {
      className: "player-logs-wrapper-title"
    }, "Logs"), /*#__PURE__*/react.createElement("div", {
      className: "player-logs",
      ref: function ref(el) {
        return _this3.element = el;
      }
    }, /*#__PURE__*/react.createElement(components_Button, {
      ariaLabel: "Clear all logs",
      className: "player-logs-wrapper-trash",
      onClick: clearLogs,
      value: String.fromCharCode(0xf05e)
    }), logTexts));
  };

  return LogDisplayer;
}(react.Component);

/* harmony default export */ const controllers_LogDisplayer = (/*#__PURE__*/react.memo(LogDisplayer));
;// CONCATENATED MODULE: ./demo/full/scripts/modules/ChartData.js
/* harmony default export */ const ChartData = (function (_ref, _ref2) {
  var state = _ref.state;
  var maxSize = _ref2.maxSize;
  var data = [];
  state.set({
    data: data.slice()
  });
  return {
    ADD_DATA: function ADD_DATA(val) {
      if (data.length >= maxSize) {
        data.splice(0, data.length + 1 - maxSize);
      }

      data.push({
        date: Date.now(),
        value: val
      });
      state.set({
        data: data.slice()
      });
    },
    REMOVE_DATA: function REMOVE_DATA(number) {
      if (number === void 0) {
        number = 1;
      }

      data.splice(0, number);
      state.set({
        data: data.slice()
      });
    }
  };
});
;// CONCATENATED MODULE: ./demo/full/scripts/lib/capitalizeFirstLetter.js
/**
 * @param {string} str
 * @returns {string}
 */
function capitalizeFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
;// CONCATENATED MODULE: ./demo/full/scripts/lib/shuffleArray.js
/**
 * Shuffle members of an array into a random order.
 * @param {Array.<*>} arr
 * @returns {Array.<*>}
 */
function shuffleArray(arr) {
  var clonedArr = arr.slice();
  var currentIndex = arr.length;

  while (0 !== currentIndex) {
    // Pick a remaining element...
    var randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1; // And swap it with the current element.

    var temporaryValue = clonedArr[currentIndex];
    clonedArr[currentIndex] = clonedArr[randomIndex];
    clonedArr[randomIndex] = temporaryValue;
  }

  return clonedArr;
}
;// CONCATENATED MODULE: ./demo/full/scripts/components/BufferContentGraph.jsx




var CANVAS_WIDTH = 1000;
var CANVAS_HEIGHT = 1;
var COLORS = [// "#fe4a49",
"#2ab7ca", "#fed766", "#4dd248", "#a22c28", "#556b2f", // darkolivegreen
"#add8e6", // lightblue
"#90ee90", // lightgreen
"#444444", "#40bfc1", "#57557e", "#fbe555" // "#f0134d",
];
var COLOR_CURRENT_POSITION = "#FF2323";
/**
 * Clear the whole canvas.
 * @param {Object} canvasContext
 * @param {number} width
 * @param {number} height
 */

function clearCanvas(canvasContext) {
  canvasContext.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
}
/**
 * Represent the current position in the canvas.
 * @param {number|undefined} position - The current position
 * @param {number} minimumPosition - minimum possible position represented in
 * the canvas.
 * @param {number} maximumPosition - maximum possible position represented in
 * the canvas.
 * @param {Object} canvasCtx - The canvas' 2D context
 */


function paintCurrentPosition(position, minimumPosition, maximumPosition, canvasCtx) {
  if (typeof position === "number" && position >= minimumPosition && position < maximumPosition) {
    var lengthCanvas = maximumPosition - minimumPosition;
    canvasCtx.fillStyle = COLOR_CURRENT_POSITION;
    canvasCtx.fillRect(Math.ceil((position - minimumPosition) / lengthCanvas * CANVAS_WIDTH) - 1, 0, 2, CANVAS_HEIGHT);
  }
}
/**
 * Scale given bufferedData in terms of percentage between the minimum and
 * maximum position. Filter out segment which are not part of it.
 * @param {Array.<Object>} bufferedData
 * @param {number} minimumPosition
 * @param {number} maximumPosition
 * @returns {Array.<Object>}
 */


function scaleSegments(bufferedData, minimumPosition, maximumPosition) {
  var scaledSegments = [];
  var wholeDuration = maximumPosition - minimumPosition;

  for (var i = 0; i < bufferedData.length; i++) {
    var bufferedInfos = bufferedData[i];
    var start = bufferedInfos.bufferedStart === undefined ? bufferedInfos.start : bufferedInfos.bufferedStart;
    var end = bufferedInfos.bufferedEnd === undefined ? bufferedInfos.end : bufferedInfos.bufferedEnd;

    if (end > minimumPosition && start < maximumPosition) {
      var startPoint = Math.max(start - minimumPosition, 0);
      var endPoint = Math.min(end - minimumPosition, maximumPosition);
      var scaledStart = startPoint / wholeDuration;
      var scaledEnd = endPoint / wholeDuration;
      scaledSegments.push({
        scaledStart: scaledStart,
        scaledEnd: scaledEnd,
        bufferedInfos: bufferedInfos
      });
    }
  }

  return scaledSegments;
}
/**
 * Display a graph representing what has been buffered according to the data
 * given.
 * Allow to seek on click, display the current time, and display a tooltip
 * describing the buffered data when hovering represented data.
 * @param {Object}
 */


function BufferContentGraph(_ref) {
  var currentTime = _ref.currentTime,
      data = _ref.data,
      maximumPosition = _ref.maximumPosition,
      minimumPosition = _ref.minimumPosition,
      seek = _ref.seek,
      type = _ref.type;

  var _useState = (0,react.useState)(shuffleArray(COLORS)),
      randomColors = _useState[0];

  var _useState2 = (0,react.useState)(false),
      tipVisible = _useState2[0],
      setTipVisible = _useState2[1];

  var _useState3 = (0,react.useState)(0),
      tipPosition = _useState3[0],
      setTipPosition = _useState3[1];

  var _useState4 = (0,react.useState)(""),
      tipText = _useState4[0],
      setTipText = _useState4[1];

  var canvasEl = (0,react.useRef)(null);
  var representationsEncountered = (0,react.useRef)([]);
  var duration = Math.max(maximumPosition - minimumPosition, 0);
  /**
   * Paint a given segment in the canvas
   * @param {Object} scaledSegment - Buffered segment information with added
   * "scaling" information to know where it fits in the canvas.
   * @param {Object} canvasCtx - The canvas' 2D context
   */

  function paintSegment(scaledSegment, canvasCtx) {
    var representation = scaledSegment.bufferedInfos.infos.representation;
    var indexOfRepr = representationsEncountered.current.indexOf(representation);

    if (indexOfRepr < 0) {
      representationsEncountered.current.push(representation);
      indexOfRepr = representationsEncountered.current.length - 1;
    }

    var colorIndex = indexOfRepr % COLORS.length;
    var color = randomColors[colorIndex];
    var startX = scaledSegment.scaledStart * CANVAS_WIDTH;
    var endX = scaledSegment.scaledEnd * CANVAS_WIDTH;
    canvasCtx.fillStyle = color;
    canvasCtx.fillRect(Math.ceil(startX), 0, Math.ceil(endX - startX), CANVAS_HEIGHT);
  }

  var currentSegmentsScaled = (0,react.useMemo)(function () {
    return scaleSegments(data, minimumPosition, maximumPosition);
  }, [data, minimumPosition, maximumPosition]);
  (0,react.useEffect)(function () {
    if (canvasEl === null || canvasEl === undefined) {
      return;
    }

    var ctx = canvasEl.current.getContext("2d");

    if (ctx === null) {
      return;
    }

    canvasEl.current.width = CANVAS_WIDTH;
    canvasEl.current.height = CANVAS_HEIGHT;
    clearCanvas(ctx);

    if (minimumPosition === undefined || maximumPosition === undefined || minimumPosition >= maximumPosition) {
      return;
    }

    for (var i = 0; i < currentSegmentsScaled.length; i++) {
      paintSegment(currentSegmentsScaled[i], ctx);
    }

    paintCurrentPosition(currentTime, minimumPosition, maximumPosition, ctx);
  }, [minimumPosition, maximumPosition, data]);

  var getMousePositionInPercentage = function getMousePositionInPercentage(event) {
    if (canvasEl === null || canvasEl === undefined) {
      return;
    }

    var rect = canvasEl.current.getBoundingClientRect();
    var point0 = rect.left;
    var clickPosPx = Math.max(event.clientX - point0, 0);
    var endPointPx = Math.max(rect.right - point0, 0);

    if (!endPointPx) {
      return 0;
    }

    return clickPosPx / endPointPx;
  };

  var getMousePosition = function getMousePosition(event) {
    var mousePercent = getMousePositionInPercentage(event);
    return mousePercent === undefined ? undefined : mousePercent * duration + minimumPosition;
  };

  var toolTipOffset = canvasEl !== null && canvasEl.current !== null ? canvasEl.current.getBoundingClientRect().left : 0;

  var onMouseMove = function onMouseMove(event) {
    var mousePercent = getMousePositionInPercentage(event);

    for (var i = 0; i < currentSegmentsScaled.length; i++) {
      var scaledSegment = currentSegmentsScaled[i];

      if (mousePercent >= scaledSegment.scaledStart && mousePercent < scaledSegment.scaledEnd) {
        var _scaledSegment$buffer = scaledSegment.bufferedInfos,
            start = _scaledSegment$buffer.start,
            end = _scaledSegment$buffer.end;
        var _scaledSegment$buffer2 = scaledSegment.bufferedInfos.infos,
            adaptation = _scaledSegment$buffer2.adaptation,
            representation = _scaledSegment$buffer2.representation;
        setTipVisible(true);
        setTipPosition(event.clientX);
        var newTipText = "";

        switch (adaptation.type) {
          case "video":
            newTipText += "width: " + representation.width + "\n" + ("height: " + representation.height) + "\n" + ("codec: " + representation.codec) + "\n" + ("bitrate: " + representation.bitrate) + "\n";
            break;

          case "audio":
            newTipText += "language: " + adaptation.language + "\n" + ("audioDescription: " + !!adaptation.isAudioDescription) + "\n" + ("codec: " + representation.codec) + "\n" + ("bitrate: " + representation.bitrate) + "\n";
            break;

          case "text":
            newTipText += "language: " + adaptation.language + "\n" + ("closedCaption: " + !!adaptation.isClosedCaption) + "\n";
            break;
        }

        newTipText += "segment: [" + start.toFixed(1) + ", " + end.toFixed(1) + "]";
        setTipText(newTipText);
        return;
      }
    }

    hideTip(); // if none found
  };

  var hideTip = function hideTip() {
    setTipVisible(false);
    setTipPosition(0);
    setTipText("");
  };

  return /*#__PURE__*/react.createElement("div", {
    className: "container-buffer-graph"
  }, /*#__PURE__*/react.createElement("div", {
    className: "buffer-graph-title"
  }, capitalizeFirstLetter(type) + " Buffer"), /*#__PURE__*/react.createElement("div", {
    className: "canvas-buffer-graph-container",
    onMouseLeave: hideTip,
    onMouseMove: onMouseMove
  }, tipVisible ? /*#__PURE__*/react.createElement(components_ToolTip, {
    className: "buffer-content-tip",
    text: tipText,
    xPosition: tipPosition,
    offset: toolTipOffset
  }) : null, /*#__PURE__*/react.createElement("canvas", {
    onClick: function onClick(event) {
      return seek(getMousePosition(event));
    },
    height: String(CANVAS_HEIGHT),
    width: String(CANVAS_WIDTH),
    className: "canvas-buffer-graph",
    ref: canvasEl
  })));
}
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/charts/BufferContent.jsx




function BufferContentChart(_ref) {
  var player = _ref.player,
      bufferedData = _ref.bufferedData,
      currentTime = _ref.currentTime,
      maximumPosition = _ref.maximumPosition,
      minimumPosition = _ref.minimumPosition;

  if (bufferedData === null || Object.keys(bufferedData).length === 0) {
    return /*#__PURE__*/react.createElement("div", {
      className: "buffer-content-no-content"
    }, " No content yet ");
  }

  var seek = function seek(position) {
    player.dispatch("SEEK", position);
  };

  var subCharts = Object.keys(bufferedData).filter(function (type) {
    return bufferedData[type] !== null;
  }).map(function (type) {
    return /*#__PURE__*/react.createElement(BufferContentGraph, {
      key: type,
      type: type,
      currentTime: currentTime,
      minimumPosition: minimumPosition,
      maximumPosition: maximumPosition,
      data: bufferedData[type],
      seek: seek
    });
  });

  if (subCharts.length === 0) {
    return /*#__PURE__*/react.createElement("div", {
      className: "buffer-content-no-content"
    }, " No content yet ");
  }

  return /*#__PURE__*/react.createElement("div", {
    className: "buffer-content-graphs-parent"
  }, subCharts);
}

/* harmony default export */ const BufferContent = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    bufferedData: "bufferedData",
    currentTime: "currentTime",
    minimumPosition: "minimumPosition",
    maximumPosition: "maximumPosition"
  }
})(BufferContentChart)));
// EXTERNAL MODULE: ./node_modules/chart.js/dist/Chart.js
var Chart = __webpack_require__(42281);
var Chart_default = /*#__PURE__*/__webpack_require__.n(Chart);
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/charts/BufferSize.jsx
function BufferSize_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; BufferSize_setPrototypeOf(subClass, superClass); }

function BufferSize_setPrototypeOf(o, p) { BufferSize_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return BufferSize_setPrototypeOf(o, p); }




var repeat = function repeat(str, time) {
  var ret = [];

  for (var i = time; i > 0; i--) {
    ret.push(str);
  }

  return ret;
};

var filterData = function filterData(data, duration) {
  var length = data.length;
  var until = Date.now() - duration;

  for (var i = length; i > 0; i--) {
    if (data[i - 1].date < until) {
      return data.slice(i, length);
    }
  }

  return data;
};

var BufferSizeChart = /*#__PURE__*/function (_React$Component) {
  BufferSize_inheritsLoose(BufferSizeChart, _React$Component);

  function BufferSizeChart() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      duration: 60000
    };
    return _this;
  }

  var _proto = BufferSizeChart.prototype;

  _proto.componentDidMount = function componentDidMount() {
    var _this2 = this;

    var element = this.element;

    if (!element) {
      return;
    }

    var module = this.props.module;
    var duration = this.state.duration;
    var initialData = filterData(module.get().data || [], duration);
    var canvas = element;
    var ctx = canvas.getContext("2d");
    var startingData = {
      labels: repeat("", initialData.length),
      datasets: [{
        label: "Buffer Size, in s",
        backgroundColor: "rgba(200, 100, 200, 0.2)",
        fill: true,
        data: initialData.map(function (_ref) {
          var value = _ref.value;
          return value;
        })
      }]
    };
    this.chart = new (Chart_default())(ctx, {
      type: "line",
      data: startingData,
      options: {
        // deactive animation as it f**cks all up when updating
        // TODO change chart lib or do it manually
        animation: false,
        elements: {
          point: {
            radius: 0
          }
        },
        scales: {
          xAxes: [{
            gridLines: {
              display: false
            }
          }]
        }
      }
    });
    this.subscription = module.$get("data").subscribe(function (data) {
      return _this2.onNewData(data);
    });
  };

  _proto.onNewData = function onNewData(data) {
    var duration = this.state.duration;
    var _this$chart$data$data = this.chart.data.datasets,
        oldDataset = _this$chart$data$data[0];
    var newData = filterData(data, duration).map(function (_ref2) {
      var value = _ref2.value;
      return value;
    });
    this.chart.data.datasets[0] = Object.assign({}, oldDataset, {
      data: newData
    });
    this.chart.data.labels = repeat("", newData.length);
    this.chart.update();
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  };

  _proto.render = function render() {
    var _this3 = this;

    return /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("canvas", {
      className: "bitrate-charts",
      height: "80",
      ref: function ref(el) {
        return _this3.element = el;
      }
    }));
  };

  return BufferSizeChart;
}(react.Component);

/* harmony default export */ const BufferSize = (/*#__PURE__*/react.memo(BufferSizeChart));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/charts/index.jsx
function charts_inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; charts_setPrototypeOf(subClass, superClass); }

function charts_setPrototypeOf(o, p) { charts_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return charts_setPrototypeOf(o, p); }






var BUFFER_GAP_REFRESH_TIME = 500;
var MAX_BUFFER_SIZE_LENGTH = 2000;

var ChartsManager = /*#__PURE__*/function (_React$Component) {
  charts_inheritsLoose(ChartsManager, _React$Component);

  function ChartsManager() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      displayBufferContentChart: false,
      displayBufferSizeChart: false
    };
    var player = _this.props.player;
    _this.bufferSizeChart = createModule(ChartData, {
      maxSize: MAX_BUFFER_SIZE_LENGTH
    });

    _this.bufferSizeChart.dispatch("ADD_DATA", player.get("bufferGap"));

    _this.bufferGapInterval = setInterval(function () {
      _this.bufferSizeChart.dispatch("ADD_DATA", player.get("bufferGap"));
    }, BUFFER_GAP_REFRESH_TIME);
    return _this;
  }

  var _proto = ChartsManager.prototype;

  _proto.componentWillUnmount = function componentWillUnmount() {
    clearInterval(this.bufferGapInterval);
    this.bufferSizeChart.destroy();
  };

  _proto.render = function render() {
    var _this2 = this;

    var _this$state = this.state,
        displayBufferSizeChart = _this$state.displayBufferSizeChart,
        displayBufferContentChart = _this$state.displayBufferContentChart;
    var player = this.props.player;

    var onBufferContentCheckBoxChange = function onBufferContentCheckBoxChange(e) {
      var target = e.target;
      var value = target.type === "checkbox" ? target.checked : target.value;

      _this2.setState({
        displayBufferContentChart: value
      });
    };

    var onBufferSizeCheckBoxChange = function onBufferSizeCheckBoxChange(e) {
      var target = e.target;
      var value = target.type === "checkbox" ? target.checked : target.value;

      _this2.setState({
        displayBufferSizeChart: value
      });
    };

    return /*#__PURE__*/react.createElement("div", {
      className: "player-charts"
    }, /*#__PURE__*/react.createElement("div", {
      className: "player-box"
    }, /*#__PURE__*/react.createElement("div", {
      className: "chart-checkbox"
    }, "Buffer content chart", /*#__PURE__*/react.createElement("label", {
      "class": "switch"
    }, /*#__PURE__*/react.createElement("input", {
      name: "displayBufferContentChart",
      type: "checkbox",
      "aria-label": "Display/Hide chart about the buffer's content",
      checked: this.state.displayBufferContentChart,
      onChange: onBufferContentCheckBoxChange
    }), /*#__PURE__*/react.createElement("span", {
      "class": "slider round"
    }))), displayBufferContentChart ? /*#__PURE__*/react.createElement(BufferContent, {
      player: player
    }) : null), /*#__PURE__*/react.createElement("div", {
      className: "player-box"
    }, /*#__PURE__*/react.createElement("div", {
      className: "chart-checkbox"
    }, "Buffer size chart", /*#__PURE__*/react.createElement("label", {
      "class": "switch"
    }, /*#__PURE__*/react.createElement("input", {
      "aria-label": "Display/Hide chart about the buffer's size",
      name: "displayBufferSizeChart",
      type: "checkbox",
      checked: this.state.displayBufferSizeChart,
      onChange: onBufferSizeCheckBoxChange
    }), /*#__PURE__*/react.createElement("span", {
      "class": "slider round"
    }))), displayBufferSizeChart ? /*#__PURE__*/react.createElement(BufferSize, {
      module: this.bufferSizeChart
    }) : null));
  };

  return ChartsManager;
}(react.Component);

/* harmony default export */ const charts = (/*#__PURE__*/react.memo(ChartsManager));
;// CONCATENATED MODULE: ./demo/full/scripts/components/Knob.jsx



function Knob(_ref) {
  var ariaLabel = _ref.ariaLabel,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? "" : _ref$className,
      _ref$name = _ref.name,
      name = _ref$name === void 0 ? "" : _ref$name,
      onChange = _ref.onChange,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? [] : _ref$options,
      selected = _ref.selected,
      disabled = _ref.disabled;
  return /*#__PURE__*/react.createElement("div", {
    className: "knob " + className
  }, /*#__PURE__*/react.createElement("span", {
    className: "knob-name"
  }, name), /*#__PURE__*/react.createElement(components_Select, {
    ariaLabel: ariaLabel,
    className: "knob-value",
    onChange: onChange,
    options: options,
    selected: selected,
    disabled: disabled
  }));
}

/* harmony default export */ const components_Knob = (/*#__PURE__*/react.memo(Knob));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/knobs/AudioBitrate.jsx




var AudioBitrateKnobBase = function AudioBitrateKnobBase(_ref) {
  var player = _ref.player,
      className = _ref.className,
      audioBitrateAuto = _ref.audioBitrateAuto,
      audioBitrate = _ref.audioBitrate,
      _ref$availableAudioBi = _ref.availableAudioBitrates,
      availableAudioBitrates = _ref$availableAudioBi === void 0 ? [] : _ref$availableAudioBi;
  var options = [];
  var selectedIndex;

  if (!availableAudioBitrates.length) {
    options = ["Not available"];
    selectedIndex = 0;
  } else if (availableAudioBitrates.length > 1) {
    var autoValue = audioBitrateAuto ? "auto (" + audioBitrate + ")" : "auto";
    options = [autoValue].concat(availableAudioBitrates);
    selectedIndex = audioBitrateAuto ? 0 : availableAudioBitrates.indexOf(audioBitrate) + 1 || 0;
  } else {
    options = availableAudioBitrates;
    selectedIndex = 0;
  }

  var onAudioBitrateChange = function onAudioBitrateChange(evt) {
    var index = +evt.target.value;

    if (index > 0) {
      var bitrate = availableAudioBitrates[index - 1];
      player.dispatch("SET_AUDIO_BITRATE", bitrate);
    } else {
      player.dispatch("SET_AUDIO_BITRATE");
    }
  };

  return /*#__PURE__*/react.createElement(components_Knob, {
    name: "Audio Bitrate",
    ariaLabel: "Update the audio bitrate",
    className: className,
    disabled: options.length < 2,
    onChange: onAudioBitrateChange,
    options: options,
    selected: selectedIndex
  });
};

/* harmony default export */ const AudioBitrate = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    audioBitrateAuto: "audioBitrateAuto",
    audioBitrate: "audioBitrate",
    availableAudioBitrates: "availableAudioBitrates"
  }
})(AudioBitrateKnobBase)));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/knobs/VideoBitrate.jsx




var VideoBitrateKnobBase = function VideoBitrateKnobBase(_ref) {
  var player = _ref.player,
      className = _ref.className,
      videoBitrateAuto = _ref.videoBitrateAuto,
      videoBitrate = _ref.videoBitrate,
      _ref$availableVideoBi = _ref.availableVideoBitrates,
      availableVideoBitrates = _ref$availableVideoBi === void 0 ? [] : _ref$availableVideoBi;
  var options = [];
  var selectedIndex;

  if (!availableVideoBitrates.length) {
    options = ["Not available"];
    selectedIndex = 0;
  } else if (availableVideoBitrates.length > 1) {
    var autoValue = videoBitrateAuto ? "auto (" + videoBitrate + ")" : "auto";
    options = [autoValue].concat(availableVideoBitrates);
    selectedIndex = videoBitrateAuto ? 0 : availableVideoBitrates.indexOf(videoBitrate) + 1 || 0;
  } else {
    options = availableVideoBitrates;
    selectedIndex = 0;
  }

  var onVideoBitrateChange = function onVideoBitrateChange(evt) {
    var index = +evt.target.value;

    if (index > 0) {
      var bitrate = availableVideoBitrates[index - 1];
      player.dispatch("SET_VIDEO_BITRATE", bitrate);
    } else {
      player.dispatch("SET_VIDEO_BITRATE");
    }
  };

  return /*#__PURE__*/react.createElement(components_Knob, {
    name: "Video Bitrate",
    ariaLabel: "Update the video bitrate",
    className: className,
    disabled: availableVideoBitrates.length < 2,
    onChange: onVideoBitrateChange,
    options: options,
    selected: selectedIndex
  });
};

/* harmony default export */ const VideoBitrate = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    videoBitrateAuto: "videoBitrateAuto",
    videoBitrate: "videoBitrate",
    availableVideoBitrates: "availableVideoBitrates"
  }
})(VideoBitrateKnobBase)));
;// CONCATENATED MODULE: ./demo/full/assets/languages.js
// Note: totally overkill
/* harmony default export */ const assets_languages = ({
  aaa: "Ghotuo",
  aab: "Alumu-Tesu",
  aac: "Ari",
  aad: "Amal",
  aae: "Arbresh Albanian",
  aaf: "Aranadan",
  aag: "Ambrak",
  aah: "Abu' Arapesh",
  aai: "Arifama-Miniafia",
  aak: "Ankave",
  aal: "Afade",
  aan: "Anamb",
  aao: "Algerian Saharan Arabic",
  aap: "Par Arra",
  aaq: "Eastern Abnaki",
  aar: "Afar",
  aas: "Aasx",
  aat: "Arvanitika Albanian",
  aau: "Abau",
  aaw: "Solong",
  aax: "Mandobo Atas",
  aaz: "Amarasi",
  aba: "Ab",
  abb: "Bankon",
  abc: "Ambala Ayta",
  abd: "Manide",
  abe: "Western Abnaki",
  abf: "Abai Sungai",
  abg: "Abaga",
  abh: "Tajiki Arabic",
  abi: "Abidji",
  abj: "Aka-Bea",
  abk: "Abkhazian",
  abl: "Lampung Nyo",
  abm: "Abanyom",
  abn: "Abua",
  abo: "Abon",
  abp: "Abellen Ayta",
  abq: "Abaza",
  abr: "Abron",
  abs: "Ambonese Malay",
  abt: "Ambulas",
  abu: "Abure",
  abv: "Baharna Arabic",
  abw: "Pal",
  abx: "Inabaknon",
  aby: "Aneme Wake",
  abz: "Abui",
  aca: "Achagua",
  acb: "nc",
  acd: "Gikyode",
  ace: "Achinese",
  acf: "Saint Lucian Creole French",
  ach: "Acoli",
  aci: "Aka-Cari",
  ack: "Aka-Kora",
  acl: "Akar-Bale",
  acm: "Mesopotamian Arabic",
  acn: "Achang",
  acp: "Eastern Acipa",
  acq: "Ta'izzi-Adeni Arabic",
  acr: "Achi",
  acs: "Acro",
  act: "Achterhoeks",
  acu: "Achuar-Shiwiar",
  acv: "Achumawi",
  acw: "Hijazi Arabic",
  acx: "Omani Arabic",
  acy: "Cypriot Arabic",
  acz: "Acheron",
  ada: "Adangme",
  adb: "Adabe",
  add: "Dzodinka",
  ade: "Adele",
  adf: "Dhofari Arabic",
  adg: "Andegerebinha",
  adh: "Adhola",
  adi: "Adi",
  adj: "Adioukrou",
  adl: "Galo",
  adn: "Adang",
  ado: "Abu",
  adq: "Adangbe",
  adr: "Adonara",
  ads: "Adamorobe Sign Language",
  adt: "Adnyamathanha",
  adu: "Aduge",
  adw: "Amundava",
  adx: "Amdo Tibetan",
  ady: "Adyghe",
  adz: "Adzera",
  aea: "Areba",
  aeb: "Tunisian Arabic",
  aec: "Saidi Arabic",
  aed: "Argentine Sign Language",
  aee: "Northeast Pashai",
  aek: "Haeke",
  ael: "Ambele",
  aem: "Arem",
  aen: "Armenian Sign Language",
  aeq: "Aer",
  aer: "Eastern Arrernte",
  aes: "Alsea",
  aeu: "Akeu",
  aew: "Ambakich",
  aey: "Amele",
  aez: "Aeka",
  afb: "Gulf Arabic",
  afd: "Andai",
  afe: "Putukwam",
  afg: "Afghan Sign Language",
  afh: "Afrihili",
  afi: "Akrukay",
  afk: "Nanubae",
  afn: "Defaka",
  afo: "Eloyi",
  afp: "Tapei",
  afr: "Afrikaans",
  afs: "Afro-Seminole Creole",
  aft: "Afitti",
  afu: "Awutu",
  afz: "Obokuitai",
  aga: "Aguano",
  agb: "Legbo",
  agc: "Agatu",
  agd: "Agarabi",
  age: "Angal",
  agf: "Arguni",
  agg: "Angor",
  agh: "Ngelima",
  agi: "Agariya",
  agj: "Argobba",
  agk: "Isarog Agta",
  agl: "Fembe",
  agm: "Angaataha",
  agn: "Agutaynen",
  ago: "Tainae",
  agq: "Aghem",
  agr: "Aguaruna",
  ags: "Esimbi",
  agt: "Central Cagayan Agta",
  agu: "Aguacateco",
  agv: "Remontado Dumagat",
  agw: "Kahua",
  agx: "Aghul",
  agy: "Southern Alta",
  agz: "Mt. Iriga Agta",
  aha: "Ahanta",
  ahb: "Axamb",
  ahg: "Qimant",
  ahh: "Aghu",
  ahi: "Tiagbamrin Aizi",
  ahk: "Akha",
  ahl: "Igo",
  ahm: "Mobumrin Aizi",
  ahn: "hn",
  aho: "Ahom",
  ahp: "Aproumu Aizi",
  ahr: "Ahirani",
  ahs: "Ashe",
  aht: "Ahtena",
  aia: "Arosi",
  aib: "Ainu (China)",
  aic: "Ainbai",
  aid: "Alngith",
  aie: "Amara",
  aif: "Agi",
  aig: "Antigua and Barbuda Creole English",
  aih: "Ai-Cham",
  aii: "Assyrian Neo-Aramaic",
  aij: "Lishanid Noshan",
  aik: "Ake",
  ail: "Aimele",
  aim: "Aimol",
  ain: "Ainu (Japan)",
  aio: "Aiton",
  aip: "Burumakok",
  aiq: "Aimaq",
  air: "Airoran",
  ais: "Nataoran Amis",
  ait: "Arikem",
  aiw: "Aari",
  aix: "Aighon",
  aiy: "Ali",
  aja: "Aja (Sudan)",
  ajg: "Aja (Benin)",
  aji: "Aji",
  ajn: "Andajin",
  ajp: "South Levantine Arabic",
  ajt: "Judeo-Tunisian Arabic",
  aju: "Judeo-Moroccan Arabic",
  ajw: "Ajawa",
  ajz: "Amri Karbi",
  aka: "Akan",
  akb: "Batak Angkola",
  akc: "Mpur",
  akd: "Ukpet-Ehom",
  ake: "Akawaio",
  akf: "Akpa",
  akg: "Anakalangu",
  akh: "Angal Heneng",
  aki: "Aiome",
  akj: "Aka-Jeru",
  akk: "Akkadian",
  akl: "Aklanon",
  akm: "Aka-Bo",
  ako: "Akurio",
  akp: "Siwu",
  akq: "Ak",
  akr: "Araki",
  aks: "Akaselem",
  akt: "Akolet",
  aku: "Akum",
  akv: "Akhvakh",
  akw: "Akwa",
  akx: "Aka-Kede",
  aky: "Aka-Kol",
  akz: "Alabama",
  ala: "Alago",
  alc: "Qawasqar",
  ald: "Alladian",
  ale: "Aleut",
  alf: "Alege",
  alh: "Alawa",
  ali: "Amaimon",
  alj: "Alangan",
  alk: "Alak",
  all: "Allar",
  alm: "Amblong",
  aln: "Gheg Albanian",
  alo: "Larike-Wakasihu",
  alp: "Alune",
  alq: "Algonquin",
  alr: "Alutor",
  als: "Tosk Albanian",
  alt: "Southern Altai",
  alu: "'Are'are",
  alw: "Alaba-Kabeena",
  alx: "Amol",
  aly: "Alyawarr",
  alz: "Alur",
  ama: "Amanay",
  amb: "Ambo",
  amc: "Amahuaca",
  ame: "Yanesha'",
  amf: "Hamer-Banna",
  amg: "Amurdak",
  amh: "Amharic",
  ami: "Amis",
  amj: "Amdang",
  amk: "Ambai",
  aml: "War-Jaintia",
  amm: "Ama (Papua New Guinea)",
  amn: "Amanab",
  amo: "Amo",
  amp: "Alamblak",
  amq: "Amahai",
  amr: "Amarakaeri",
  ams: "Southern Amami-Oshima",
  amt: "Amto",
  amu: "Guerrero Amuzgo",
  amv: "Ambelau",
  amw: "Western Neo-Aramaic",
  amx: "Anmatyerre",
  amy: "Ami",
  amz: "Atampaya",
  ana: "Andaqui",
  anb: "Andoa",
  anc: "Ngas",
  and: "Ansus",
  ane: "Xrc",
  anf: "Animere",
  ang: "Old English (ca. 450-1100)",
  anh: "Nend",
  ani: "Andi",
  anj: "Anor",
  ank: "Goemai",
  anl: "Anu-Hkongso Chin",
  anm: "Anal",
  ann: "Obolo",
  ano: "Andoque",
  anp: "Angika",
  anq: "Jarawa (India)",
  anr: "Andh",
  ans: "Anserma",
  ant: "Antakarinya",
  anu: "Anuak",
  anv: "Denya",
  anw: "Anaang",
  anx: "Andra-Hus",
  any: "Anyin",
  anz: "Anem",
  aoa: "Angolar",
  aob: "Abom",
  aoc: "Pemon",
  aod: "Andarum",
  aoe: "Angal Enen",
  aof: "Bragat",
  aog: "Angoram",
  aoh: "Arma",
  aoi: "Anindilyakwa",
  aoj: "Mufian",
  aok: "Arh",
  aol: "Alor",
  aom: "mie",
  aon: "Bumbita Arapesh",
  aor: "Aore",
  aos: "Taikat",
  aot: "Atong (India)",
  aou: "A'ou",
  aox: "Atorada",
  aoz: "Uab Meto",
  apb: "Sa'a",
  apc: "North Levantine Arabic",
  apd: "Sudanese Arabic",
  ape: "Bukiyip",
  apf: "Pahanan Agta",
  apg: "Ampanang",
  aph: "Athpariya",
  api: "Apiak",
  apj: "Jicarilla Apache",
  apk: "Kiowa Apache",
  apl: "Lipan Apache",
  apm: "Mescalero-Chiricahua Apache",
  apn: "Apinay",
  apo: "Ambul",
  app: "Apma",
  apq: "A-Pucikwar",
  apr: "Arop-Lokep",
  aps: "Arop-Sissano",
  apt: "Apatani",
  apu: "Apurin",
  apv: "Alapmunte",
  apw: "Western Apache",
  apx: "Aputai",
  apy: "Apala",
  apz: "Safeyoka",
  aqc: "Archi",
  aqd: "Ampari Dogon",
  aqg: "Arigidi",
  aqm: "Atohwaim",
  aqn: "Northern Alta",
  aqp: "Atakapa",
  aqr: "Arh",
  aqt: "Angait",
  aqz: "Akuntsu",
  ara: "Arabic",
  arb: "Standard Arabic",
  arc: "Official Aramaic (700-300 BCE)",
  ard: "Arabana",
  are: "Western Arrarnta",
  arg: "Aragonese",
  arh: "Arhuaco",
  ari: "Arikara",
  arj: "Arapaso",
  ark: "Arikap",
  arl: "Arabela",
  arn: "Mapudungun",
  aro: "Araona",
  arp: "Arapaho",
  arq: "Algerian Arabic",
  arr: "Karo (Brazil)",
  ars: "Najdi Arabic",
  aru: "Aru (Amazonas State)",
  arv: "Arbore",
  arw: "Arawak",
  arx: "Aru (Rodonia State)",
  ary: "Moroccan Arabic",
  arz: "Egyptian Arabic",
  asa: "Asu (Tanzania)",
  asb: "Assiniboine",
  asc: "Casuarina Coast Asmat",
  asd: "Asas",
  ase: "American Sign Language",
  asf: "Australian Sign Language",
  asg: "Cishingini",
  ash: "Abishira",
  asi: "Buruwai",
  asj: "Sari",
  ask: "Ashkun",
  asl: "Asilulu",
  asm: "Assamese",
  asn: "Xing Asurin",
  aso: "Dano",
  asp: "Algerian Sign Language",
  asq: "Austrian Sign Language",
  asr: "Asuri",
  ass: "Ipulo",
  ast: "Asturian",
  asu: "Tocantins Asurini",
  asv: "Asoa",
  asw: "Australian Aborigines Sign Language",
  asx: "Muratayak",
  asy: "Yaosakor Asmat",
  asz: "As",
  ata: "Pele-Ata",
  atb: "Zaiwa",
  atc: "Atsahuaca",
  atd: "Ata Manobo",
  ate: "Atemble",
  atg: "Ivbie North-Okpela-Arhe",
  ati: "Atti",
  atj: "Atikamekw",
  atk: "Ati",
  atl: "Mt. Iraya Agta",
  atm: "Ata",
  atn: "Ashtiani",
  ato: "Atong (Cameroon)",
  atp: "Pudtol Atta",
  atq: "Aralle-Tabulahan",
  atr: "Waimiri-Atroari",
  ats: "Gros Ventre",
  att: "Pamplona Atta",
  atu: "Reel",
  atv: "Northern Altai",
  atw: "Atsugewi",
  atx: "Arutani",
  aty: "Aneityum",
  atz: "Arta",
  aua: "Asumboa",
  aub: "Alugu",
  auc: "Waorani",
  aud: "Anuta",
  aug: "Aguna",
  auh: "Aushi",
  aui: "Anuki",
  auj: "Awjilah",
  auk: "Heyo",
  aul: "Aulua",
  aum: "Asu (Nigeria)",
  aun: "Molmo One",
  auo: "Auyokawa",
  aup: "Makayam",
  auq: "Anus",
  aur: "Aruek",
  aut: "Austral",
  auu: "Auye",
  auw: "Awyi",
  aux: "Aur",
  auy: "Awiyaana",
  auz: "Uzbeki Arabic",
  ava: "Avaric",
  avb: "Avau",
  avd: "Alviri-Vidari",
  ave: "Avestan",
  avi: "Avikam",
  avk: "Kotava",
  avl: "Eastern Egyptian Bedawi Arabic",
  avm: "Angkamuthi",
  avn: "Avatime",
  avo: "Agavotaguerra",
  avs: "Aushiri",
  avt: "Au",
  avu: "Avokaya",
  avv: "Av-Canoeiro",
  awa: "Awadhi",
  awb: "Awa (Papua New Guinea)",
  awc: "Cicipu",
  awe: "Awet",
  awg: "Anguthimri",
  awh: "Awbono",
  awi: "Aekyom",
  awk: "Awabakal",
  awm: "Arawum",
  awn: "Awngi",
  awo: "Awak",
  awr: "Awera",
  aws: "South Awyu",
  awt: "Arawet",
  awu: "Central Awyu",
  awv: "Jair Awyu",
  aww: "Awun",
  awx: "Awara",
  awy: "Edera Awyu",
  axb: "Abipon",
  axe: "Ayerrerenge",
  axg: "Mato Grosso Arra",
  axk: "Yaka (Central African Republic)",
  axl: "Lower Southern Aranda",
  axm: "Middle Armenian",
  axx: "Xrgur",
  aya: "Awar",
  ayb: "Ayizo Gbe",
  ayc: "Southern Aymara",
  ayd: "Ayabadhu",
  aye: "Ayere",
  ayg: "Ginyanga",
  ayh: "Hadrami Arabic",
  ayi: "Leyigha",
  ayk: "Akuku",
  ayl: "Libyan Arabic",
  aym: "Aymara",
  ayn: "Sanaani Arabic",
  ayo: "Ayoreo",
  ayp: "North Mesopotamian Arabic",
  ayq: "Ayi (Papua New Guinea)",
  ayr: "Central Aymara",
  ays: "Sorsogon Ayta",
  ayt: "Magbukun Ayta",
  ayu: "Ayu",
  ayy: "Tayabas Ayta",
  ayz: "Mai Brat",
  aza: "Azha",
  azb: "South Azerbaijani",
  azd: "Eastern Durango Nahuatl",
  aze: "Azerbaijani",
  azg: "San Pedro Amuzgos Amuzgo",
  azj: "North Azerbaijani",
  azm: "Ipalapa Amuzgo",
  azn: "Western Durango Nahuatl",
  azo: "Awing",
  azt: "Faire Atta",
  azz: "Highland Puebla Nahuatl",
  baa: "Babatana",
  bab: "Bainouk-Gunyuo",
  bac: "Badui",
  bae: "Bar",
  baf: "Nubaca",
  bag: "Tuki",
  bah: "Bahamas Creole English",
  baj: "Barakai",
  bak: "Bashkir",
  bal: "Baluchi",
  bam: "Bambara",
  ban: "Balinese",
  bao: "Waimaha",
  bap: "Bantawa",
  bar: "Bavarian",
  bas: "Basa (Cameroon)",
  bau: "Bada (Nigeria)",
  bav: "Vengo",
  baw: "Bambili-Bambui",
  bax: "Bamun",
  bay: "Batuley",
  bba: "Baatonum",
  bbb: "Barai",
  bbc: "Batak Toba",
  bbd: "Bau",
  bbe: "Bangba",
  bbf: "Baibai",
  bbg: "Barama",
  bbh: "Bugan",
  bbi: "Barombi",
  bbj: "Ghoml'",
  bbk: "Babanki",
  bbl: "Bats",
  bbm: "Babango",
  bbn: "Uneapa",
  bbo: "Northern Bobo Madar",
  bbp: "West Central Banda",
  bbq: "Bamali",
  bbr: "Girawa",
  bbs: "Bakpinka",
  bbt: "Mburku",
  bbu: "Kulung (Nigeria)",
  bbv: "Karnai",
  bbw: "Baba",
  bbx: "Bubia",
  bby: "Befang",
  bbz: "Babalia Creole Arabic",
  bca: "Central Bai",
  bcb: "Bainouk-Samik",
  bcc: "Southern Balochi",
  bcd: "North Babar",
  bce: "Bamenyam",
  bcf: "Bamu",
  bcg: "Baga Pokur",
  bch: "Bariai",
  bci: "Baoul",
  bcj: "Bardi",
  bck: "Bunaba",
  bcl: "Central Bikol",
  bcm: "Bannoni",
  bcn: "Bali (Nigeria)",
  bco: "Kaluli",
  bcp: "Bali (Democratic Republic of Congo)",
  bcq: "Bench",
  bcr: "Babine",
  bcs: "Kohumono",
  bct: "Bendi",
  bcu: "Awad Bing",
  bcv: "Shoo-Minda-Nye",
  bcw: "Bana",
  bcy: "Bacama",
  bcz: "Bainouk-Gunyaamolo",
  bda: "Bayot",
  bdb: "Basap",
  bdc: "Ember-Baud",
  bdd: "Bunama",
  bde: "Bade",
  bdf: "Biage",
  bdg: "Bonggi",
  bdh: "Baka (Sudan)",
  bdi: "Burun",
  bdj: "Bai",
  bdk: "Budukh",
  bdl: "Indonesian Bajau",
  bdm: "Buduma",
  bdn: "Baldemu",
  bdo: "Morom",
  bdp: "Bende",
  bdq: "Bahnar",
  bdr: "West Coast Bajau",
  bds: "Burunge",
  bdt: "Bokoto",
  bdu: "Oroko",
  bdv: "Bodo Parja",
  bdw: "Baham",
  bdx: "Budong-Budong",
  bdy: "Bandjalang",
  bdz: "Badeshi",
  bea: "Beaver",
  beb: "Bebele",
  bec: "Iceve-Maci",
  bed: "Bedoanas",
  bee: "Byangsi",
  bef: "Benabena",
  beg: "Belait",
  beh: "Biali",
  bei: "Bekati'",
  bej: "Beja",
  bek: "Bebeli",
  bel: "Belarusian",
  bem: "Bemba (Zambia)",
  ben: "Bengali",
  beo: "Beami",
  bep: "Besoa",
  beq: "Beembe",
  bes: "Besme",
  bet: "Guiberoua Bte",
  beu: "Blagar",
  bev: "Daloa Bt",
  bew: "Betawi",
  bex: "Jur Modo",
  bey: "Beli (Papua New Guinea)",
  bez: "Bena (Tanzania)",
  bfa: "Bari",
  bfb: "Pauri Bareli",
  bfc: "Panyi Bai",
  bfd: "Bafut",
  bfe: "Betaf",
  bff: "Bofi",
  bfg: "Busang Kayan",
  bfh: "Blafe",
  bfi: "British Sign Language",
  bfj: "Bafanji",
  bfk: "Ban Khor Sign Language",
  bfl: "Banda-Ndl",
  bfm: "Mmen",
  bfn: "Bunak",
  bfo: "Malba Birifor",
  bfp: "Beba",
  bfq: "Badaga",
  bfr: "Bazigar",
  bfs: "Southern Bai",
  bft: "Balti",
  bfu: "Gahri",
  bfw: "Bondo",
  bfx: "Bantayanon",
  bfy: "Bagheli",
  bfz: "Mahasu Pahari",
  bga: "Gwamhi-Wuri",
  bgb: "Bobongko",
  bgc: "Haryanvi",
  bgd: "Rathwi Bareli",
  bge: "Bauria",
  bgf: "Bangandu",
  bgg: "Bugun",
  bgi: "Giangan",
  bgj: "Bangolan",
  bgk: "Bit",
  bgl: "Bo (Laos)",
  bgn: "Western Balochi",
  bgo: "Baga Koga",
  bgp: "Eastern Balochi",
  bgq: "Bagri",
  bgr: "Bawm Chin",
  bgs: "Tagabawa",
  bgt: "Bughotu",
  bgu: "Mbongno",
  bgv: "Warkay-Bipim",
  bgw: "Bhatri",
  bgx: "Balkan Gagauz Turkish",
  bgy: "Benggoi",
  bgz: "Banggai",
  bha: "Bharia",
  bhb: "Bhili",
  bhc: "Biga",
  bhd: "Bhadrawahi",
  bhe: "Bhaya",
  bhf: "Odiai",
  bhg: "Binandere",
  bhh: "Bukharic",
  bhi: "Bhilali",
  bhj: "Bahing",
  bhl: "Bimin",
  bhm: "Bathari",
  bhn: "Bohtan Neo-Aramaic",
  bho: "Bhojpuri",
  bhp: "Bima",
  bhq: "Tukang Besi South",
  bhr: "Bara Malagasy",
  bhs: "Buwal",
  bht: "Bhattiyali",
  bhu: "Bhunjia",
  bhv: "Bahau",
  bhw: "Biak",
  bhx: "Bhalay",
  bhy: "Bhele",
  bhz: "Bada (Indonesia)",
  bia: "Badimaya",
  bib: "Bissa",
  bic: "Bikaru",
  bid: "Bidiyo",
  bie: "Bepour",
  bif: "Biafada",
  big: "Biangai",
  bij: "Vaghat-Ya-Bijim-Legeri",
  bik: "Bikol",
  bil: "Bile",
  bim: "Bimoba",
  bin: "Bini",
  bio: "Nai",
  bip: "Bila",
  biq: "Bipi",
  bir: "Bisorio",
  bis: "Bislama",
  bit: "Berinomo",
  biu: "Biete",
  biv: "Southern Birifor",
  biw: "Kol (Cameroon)",
  bix: "Bijori",
  biy: "Birhor",
  biz: "Baloi",
  bja: "Budza",
  bjb: "Banggarla",
  bjc: "Bariji",
  bje: "Biao-Jiao Mien",
  bjf: "Barzani Jewish Neo-Aramaic",
  bjg: "Bidyogo",
  bjh: "Bahinemo",
  bji: "Burji",
  bjj: "Kanauji",
  bjk: "Barok",
  bjl: "Bulu (Papua New Guinea)",
  bjm: "Bajelani",
  bjn: "Banjar",
  bjo: "Mid-Southern Banda",
  bjp: "Fanamaket",
  bjr: "Binumarien",
  bjs: "Bajan",
  bjt: "Balanta-Ganja",
  bju: "Busuu",
  bjv: "Bedjond",
  bjw: "Bakw",
  bjx: "Banao Itneg",
  bjy: "Bayali",
  bjz: "Baruga",
  bka: "Kyak",
  bkc: "Baka (Cameroon)",
  bkd: "Binukid",
  bkf: "Beeke",
  bkg: "Buraka",
  bkh: "Bakoko",
  bki: "Baki",
  bkj: "Pande",
  bkk: "Brokskat",
  bkl: "Berik",
  bkm: "Kom (Cameroon)",
  bkn: "Bukitan",
  bko: "Kwa'",
  bkp: "Boko (Democratic Republic of Congo)",
  bkq: "Bakair",
  bkr: "Bakumpai",
  bks: "Northern Sorsoganon",
  bkt: "Boloki",
  bku: "Buhid",
  bkv: "Bekwarra",
  bkw: "Bekwel",
  bkx: "Baikeno",
  bky: "Bokyi",
  bkz: "Bungku",
  bla: "Siksika",
  blb: "Bilua",
  blc: "Bella Coola",
  bld: "Bolango",
  ble: "Balanta-Kentohe",
  blf: "Buol",
  blg: "Balau",
  blh: "Kuwaa",
  bli: "Bolia",
  blj: "Bolongan",
  blk: "Pa'o Karen",
  bll: "Biloxi",
  blm: "Beli (Sudan)",
  bln: "Southern Catanduanes Bikol",
  blo: "Anii",
  blp: "Blablanga",
  blq: "Baluan-Pam",
  blr: "Blang",
  bls: "Balaesang",
  blt: "Tai Dam",
  blv: "Kibala",
  blw: "Balangao",
  blx: "Mag-Indi Ayta",
  bly: "Notre",
  blz: "Balantak",
  bma: "Lame",
  bmb: "Bembe",
  bmc: "Biem",
  bmd: "Baga Manduri",
  bme: "Limassa",
  bmf: "Bom-Kim",
  bmg: "Bamwe",
  bmh: "Kein",
  bmi: "Bagirmi",
  bmj: "Bote-Majhi",
  bmk: "Ghayavi",
  bml: "Bomboli",
  bmm: "Northern Betsimisaraka Malagasy",
  bmn: "Bina (Papua New Guinea)",
  bmo: "Bambalang",
  bmp: "Bulgebi",
  bmq: "Bomu",
  bmr: "Muinane",
  bms: "Bilma Kanuri",
  bmt: "Biao Mon",
  bmu: "Somba-Siawari",
  bmv: "Bum",
  bmw: "Bomwali",
  bmx: "Baimak",
  bmz: "Baramu",
  bna: "Bonerate",
  bnb: "Bookan",
  bnc: "Bontok",
  bnd: "Banda (Indonesia)",
  bne: "Bintauna",
  bnf: "Masiwang",
  bng: "Benga",
  bni: "Bangi",
  bnj: "Eastern Tawbuid",
  bnk: "Bierebo",
  bnl: "Boon",
  bnm: "Batanga",
  bnn: "Bunun",
  bno: "Bantoanon",
  bnp: "Bola",
  bnq: "Bantik",
  bnr: "Butmas-Tur",
  bns: "Bundeli",
  bnu: "Bentong",
  bnv: "Bonerif",
  bnw: "Bisis",
  bnx: "Bangubangu",
  bny: "Bintulu",
  bnz: "Beezen",
  boa: "Bora",
  bob: "Aweer",
  bod: "Tibetan",
  boe: "Mundabli",
  bof: "Bolon",
  bog: "Bamako Sign Language",
  boh: "Boma",
  boi: "Barbareo",
  boj: "Anjam",
  bok: "Bonjo",
  bol: "Bole",
  bom: "Berom",
  bon: "Bine",
  boo: "Tiemacw Bozo",
  bop: "Bonkiman",
  boq: "Bogaya",
  bor: "Borro",
  bos: "Bosnian",
  bot: "Bongo",
  bou: "Bondei",
  bov: "Tuwuli",
  bow: "Rema",
  box: "Buamu",
  boy: "Bodo (Central African Republic)",
  boz: "Tiyaxo Bozo",
  bpa: "Daakaka",
  bpb: "Barbacoas",
  bpd: "Banda-Banda",
  bpg: "Bonggo",
  bph: "Botlikh",
  bpi: "Bagupi",
  bpj: "Binji",
  bpk: "Orowe",
  bpl: "Broome Pearling Lugger Pidgin",
  bpm: "Biyom",
  bpn: "Dzao Min",
  bpo: "Anasi",
  bpp: "Kaure",
  bpq: "Banda Malay",
  bpr: "Koronadal Blaan",
  bps: "Sarangani Blaan",
  bpt: "Barrow Point",
  bpu: "Bongu",
  bpv: "Bian Marind",
  bpw: "Bo (Papua New Guinea)",
  bpx: "Palya Bareli",
  bpy: "Bishnupriya",
  bpz: "Bilba",
  bqa: "Tchumbuli",
  bqb: "Bagusa",
  bqc: "Boko (Benin)",
  bqd: "Bung",
  bqf: "Baga Kaloum",
  bqg: "Bago-Kusuntu",
  bqh: "Baima",
  bqi: "Bakhtiari",
  bqj: "Bandial",
  bqk: "Banda-Mbrs",
  bql: "Bilakura",
  bqm: "Wumboko",
  bqn: "Bulgarian Sign Language",
  bqo: "Balo",
  bqp: "Busa",
  bqq: "Biritai",
  bqr: "Burusu",
  bqs: "Bosngun",
  bqt: "Bamukumbit",
  bqu: "Boguru",
  bqv: "Koro Wachi",
  bqw: "Buru (Nigeria)",
  bqx: "Baangi",
  bqy: "Bengkala Sign Language",
  bqz: "Bakaka",
  bra: "Braj",
  brb: "Lave",
  brc: "Berbice Creole Dutch",
  brd: "Baraamu",
  bre: "Breton",
  brf: "Bera",
  brg: "Baure",
  brh: "Brahui",
  bri: "Mokpwe",
  brj: "Bieria",
  brk: "Birked",
  brl: "Birwa",
  brm: "Barambu",
  brn: "Boruca",
  bro: "Brokkat",
  brp: "Barapasi",
  brq: "Breri",
  brr: "Birao",
  brs: "Baras",
  brt: "Bitare",
  bru: "Eastern Bru",
  brv: "Western Bru",
  brw: "Bellari",
  brx: "Bodo (India)",
  bry: "Burui",
  brz: "Bilbil",
  bsa: "Abinomn",
  bsb: "Brunei Bisaya",
  bsc: "Bassari",
  bse: "Wushi",
  bsf: "Bauchi",
  bsg: "Bashkardi",
  bsh: "Kati",
  bsi: "Bassossi",
  bsj: "Bangwinji",
  bsk: "Burushaski",
  bsl: "Basa-Gumna",
  bsm: "Busami",
  bsn: "Barasana-Eduria",
  bso: "Buso",
  bsp: "Baga Sitemu",
  bsq: "Bassa",
  bsr: "Bassa-Kontagora",
  bss: "Akoose",
  bst: "Basketo",
  bsu: "Bahonsuai",
  bsv: "Baga Soban",
  bsw: "Baiso",
  bsx: "Yangkam",
  bsy: "Sabah Bisaya",
  bta: "Bata",
  btc: "Bati (Cameroon)",
  btd: "Batak Dairi",
  bte: "Gamo-Ningi",
  btf: "Birgit",
  btg: "Gagnoa Bt",
  bth: "Biatah Bidayuh",
  bti: "Burate",
  btj: "Bacanese Malay",
  btm: "Batak Mandailing",
  btn: "Ratagnon",
  bto: "Rinconada Bikol",
  btp: "Budibud",
  btq: "Batek",
  btr: "Baetora",
  bts: "Batak Simalungun",
  btt: "Bete-Bendi",
  btu: "Batu",
  btv: "Bateri",
  btw: "Butuanon",
  btx: "Batak Karo",
  bty: "Bobot",
  btz: "Batak Alas-Kluet",
  bua: "Buriat",
  bub: "Bua",
  buc: "Bushi",
  bud: "Ntcham",
  bue: "Beothuk",
  buf: "Bushoong",
  bug: "Buginese",
  buh: "Younuo Bunu",
  bui: "Bongili",
  buj: "Basa-Gurmana",
  buk: "Bugawac",
  bul: "Bulgarian",
  bum: "Bulu (Cameroon)",
  bun: "Sherbro",
  buo: "Terei",
  bup: "Busoa",
  buq: "Brem",
  bus: "Bokobaru",
  but: "Bungain",
  buu: "Budu",
  buv: "Bun",
  buw: "Bubi",
  bux: "Boghom",
  buy: "Bullom So",
  buz: "Bukwen",
  bva: "Barein",
  bvb: "Bube",
  bvc: "Baelelea",
  bvd: "Baeggu",
  bve: "Berau Malay",
  bvf: "Boor",
  bvg: "Bonkeng",
  bvh: "Bure",
  bvi: "Belanda Viri",
  bvj: "Baan",
  bvk: "Bukat",
  bvl: "Bolivian Sign Language",
  bvm: "Bamunka",
  bvn: "Buna",
  bvo: "Bolgo",
  bvp: "Bumang",
  bvq: "Birri",
  bvr: "Burarra",
  bvt: "Bati (Indonesia)",
  bvu: "Bukit Malay",
  bvv: "Baniva",
  bvw: "Boga",
  bvx: "Dibole",
  bvy: "Baybayanon",
  bvz: "Bauzi",
  bwa: "Bwatoo",
  bwb: "Namosi-Naitasiri-Serua",
  bwc: "Bwile",
  bwd: "Bwaidoka",
  bwe: "Bwe Karen",
  bwf: "Boselewa",
  bwg: "Barwe",
  bwh: "Bishuo",
  bwi: "Baniwa",
  bwj: "L L Bwamu",
  bwk: "Bauwaki",
  bwl: "Bwela",
  bwm: "Biwat",
  bwn: "Wunai Bunu",
  bwo: "Boro (Ethiopia)",
  bwp: "Mandobo Bawah",
  bwq: "Southern Bobo Madar",
  bwr: "Bura-Pabir",
  bws: "Bomboma",
  bwt: "Bafaw-Balong",
  bwu: "Buli (Ghana)",
  bww: "Bwa",
  bwx: "Bu-Nao Bunu",
  bwy: "Cwi Bwamu",
  bwz: "Bwisi",
  bxa: "Tairaha",
  bxb: "Belanda Bor",
  bxc: "Molengue",
  bxd: "Pela",
  bxe: "Birale",
  bxf: "Bilur",
  bxg: "Bangala",
  bxh: "Buhutu",
  bxi: "Pirlatapa",
  bxj: "Bayungu",
  bxk: "Bukusu",
  bxl: "Jalkunan",
  bxm: "Mongolia Buriat",
  bxn: "Burduna",
  bxo: "Barikanchi",
  bxp: "Bebil",
  bxq: "Beele",
  bxr: "Russia Buriat",
  bxs: "Busam",
  bxu: "China Buriat",
  bxv: "Berakou",
  bxw: "Bankagooma",
  bxz: "Binahari",
  bya: "Batak",
  byb: "Bikya",
  byc: "Ubaghara",
  byd: "Benyadu'",
  bye: "Pouye",
  byf: "Bete",
  byg: "Baygo",
  byh: "Bhujel",
  byi: "Buyu",
  byj: "Bina (Nigeria)",
  byk: "Biao",
  byl: "Bayono",
  bym: "Bidyara",
  byn: "Bilin",
  byo: "Biyo",
  byp: "Bumaji",
  byq: "Basay",
  byr: "Baruya",
  bys: "Burak",
  byt: "Berti",
  byv: "Medumba",
  byw: "Belhariya",
  byx: "Qaqet",
  byz: "Banaro",
  bza: "Bandi",
  bzb: "Andio",
  bzc: "Southern Betsimisaraka Malagasy",
  bzd: "Bribri",
  bze: "Jenaama Bozo",
  bzf: "Boikin",
  bzg: "Babuza",
  bzh: "Mapos Buang",
  bzi: "Bisu",
  bzj: "Belize Kriol English",
  bzk: "Nicaragua Creole English",
  bzl: "Boano (Sulawesi)",
  bzm: "Bolondo",
  bzn: "Boano (Maluku)",
  bzo: "Bozaba",
  bzp: "Kemberano",
  bzq: "Buli (Indonesia)",
  bzr: "Biri",
  bzs: "Brazilian Sign Language",
  bzt: "Brithenig",
  bzu: "Burmeso",
  bzv: "Naami",
  bzw: "Basa (Nigeria)",
  bzx: "Klngaxo Bozo",
  bzy: "Obanliku",
  bzz: "Evant",
  caa: "Chort",
  cab: "Garifuna",
  cac: "Chuj",
  cad: "Caddo",
  cae: "Lehar",
  caf: "Southern Carrier",
  cag: "Nivacl",
  cah: "Cahuarano",
  caj: "Chan",
  cak: "Kaqchikel",
  cal: "Carolinian",
  cam: "Cemuh",
  can: "Chambri",
  cao: "Chcobo",
  cap: "Chipaya",
  caq: "Car Nicobarese",
  car: "Galibi Carib",
  cas: "Tsiman",
  cat: "Catalan",
  cav: "Cavinea",
  caw: "Callawalla",
  cax: "Chiquitano",
  cay: "Cayuga",
  caz: "Canichana",
  cbb: "Cabiyar",
  cbc: "Carapana",
  cbd: "Carijona",
  cbg: "Chimila",
  cbi: "Chachi",
  cbj: "Ede Cabe",
  cbk: "Chavacano",
  cbl: "Bualkhaw Chin",
  cbn: "Nyahkur",
  cbo: "Izora",
  cbq: "Tsucuba",
  cbr: "Cashibo-Cacataibo",
  cbs: "Cashinahua",
  cbt: "Chayahuita",
  cbu: "Candoshi-Shapra",
  cbv: "Cacua",
  cbw: "Kinabalian",
  cby: "Carabayo",
  cca: "Cauca",
  ccc: "Chamicuro",
  ccd: "Cafundo Creole",
  cce: "Chopi",
  ccg: "Samba Daka",
  cch: "Atsam",
  ccj: "Kasanga",
  ccl: "Cutchi-Swahili",
  ccm: "Malaccan Creole Malay",
  cco: "Comaltepec Chinantec",
  ccp: "Chakma",
  ccr: "Cacaopera",
  cda: "Choni",
  cde: "Chenchu",
  cdf: "Chiru",
  cdg: "Chamari",
  cdh: "Chambeali",
  cdi: "Chodri",
  cdj: "Churahi",
  cdm: "Chepang",
  cdn: "Chaudangsi",
  cdo: "Min Dong Chinese",
  cdr: "Cinda-Regi-Tiyal",
  cds: "Chadian Sign Language",
  cdy: "Chadong",
  cdz: "Koda",
  cea: "Lower Chehalis",
  ceb: "Cebuano",
  ceg: "Chamacoco",
  cek: "Eastern Khumi Chin",
  cen: "Cen",
  ces: "Czech",
  cet: "Centm",
  cfa: "Dijim-Bwilim",
  cfd: "Cara",
  cfg: "Como Karim",
  cfm: "Falam Chin",
  cga: "Changriwa",
  cgc: "Kagayanen",
  cgg: "Chiga",
  cgk: "Chocangacakha",
  cha: "Chamorro",
  chb: "Chibcha",
  chc: "Catawba",
  chd: "Highland Oaxaca Chontal",
  che: "Chechen",
  chf: "Tabasco Chontal",
  chg: "Chagatai",
  chh: "Chinook",
  chj: "Ojitln Chinantec",
  chk: "Chuukese",
  chl: "Cahuilla",
  chm: "Mari (Russia)",
  chn: "Chinook jargon",
  cho: "Choctaw",
  chp: "Chipewyan",
  chq: "Quiotepec Chinantec",
  chr: "Cherokee",
  cht: "Choln",
  chu: "Church Slavic",
  chv: "Chuvash",
  chw: "Chuwabu",
  chx: "Chantyal",
  chy: "Cheyenne",
  chz: "Ozumacn Chinantec",
  cia: "Cia-Cia",
  cib: "Ci Gbe",
  cic: "Chickasaw",
  cid: "Chimariko",
  cie: "Cineni",
  cih: "Chinali",
  cik: "Chitkuli Kinnauri",
  cim: "Cimbrian",
  cin: "Cinta Larga",
  cip: "Chiapanec",
  cir: "Tiri",
  ciw: "Chippewa",
  ciy: "Chaima",
  cja: "Western Cham",
  cje: "Chru",
  cjh: "Upper Chehalis",
  cji: "Chamalal",
  cjk: "Chokwe",
  cjm: "Eastern Cham",
  cjn: "Chenapian",
  cjo: "Ashninka Pajonal",
  cjp: "Cabcar",
  cjs: "Shor",
  cjv: "Chuave",
  cjy: "Jinyu Chinese",
  ckb: "Central Kurdish",
  ckh: "Chak",
  ckl: "Cibak",
  ckn: "Kaang Chin",
  cko: "Anufo",
  ckq: "Kajakse",
  ckr: "Kairak",
  cks: "Tayo",
  ckt: "Chukot",
  cku: "Koasati",
  ckv: "Kavalan",
  ckx: "Caka",
  cky: "Cakfem-Mushere",
  ckz: "Cakchiquel-Quich Mixed Language",
  cla: "Ron",
  clc: "Chilcotin",
  cld: "Chaldean Neo-Aramaic",
  cle: "Lealao Chinantec",
  clh: "Chilisso",
  cli: "Chakali",
  clj: "Laitu Chin",
  clk: "Idu-Mishmi",
  cll: "Chala",
  clm: "Clallam",
  clo: "Lowland Oaxaca Chontal",
  clt: "Lautu Chin",
  clu: "Caluyanun",
  clw: "Chulym",
  cly: "Eastern Highland Chatino",
  cma: "Maa",
  cme: "Cerma",
  cmg: "Classical Mongolian",
  cmi: "Ember-Cham",
  cml: "Campalagian",
  cmm: "Michigamea",
  cmn: "Mandarin Chinese",
  cmo: "Central Mnong",
  cmr: "Mro-Khimi Chin",
  cms: "Messapic",
  cmt: "Camtho",
  cna: "Changthang",
  cnb: "Chinbon Chin",
  cnc: "Cng",
  cng: "Northern Qiang",
  cnh: "Hakha Chin",
  cni: "Ashninka",
  cnk: "Khumi Chin",
  cnl: "Lalana Chinantec",
  cno: "Con",
  cns: "Central Asmat",
  cnt: "Tepetotutla Chinantec",
  cnu: "Chenoua",
  cnw: "Ngawn Chin",
  cnx: "Middle Cornish",
  coa: "Cocos Islands Malay",
  cob: "Chicomuceltec",
  coc: "Cocopa",
  cod: "Cocama-Cocamilla",
  coe: "Koreguaje",
  cof: "Colorado",
  cog: "Chong",
  coh: "Chonyi-Dzihana-Kauma",
  coj: "Cochimi",
  cok: "Santa Teresa Cora",
  col: "Columbia-Wenatchi",
  com: "Comanche",
  con: "Cofn",
  coo: "Comox",
  cop: "Coptic",
  coq: "Coquille",
  cor: "Cornish",
  cos: "Corsican",
  cot: "Caquinte",
  cou: "Wamey",
  cov: "Cao Miao",
  cow: "Cowlitz",
  cox: "Nanti",
  coz: "Chochotec",
  cpa: "Palantla Chinantec",
  cpb: "Ucayali-Yura Ashninka",
  cpc: "Ajyninka Apurucayali",
  cpg: "Cappadocian Greek",
  cpi: "Chinese Pidgin English",
  cpn: "Cherepon",
  cpo: "Kpeego",
  cps: "Capiznon",
  cpu: "Pichis Ashninka",
  cpx: "Pu-Xian Chinese",
  cpy: "South Ucayali Ashninka",
  cqd: "Chuanqiandian Cluster Miao",
  cra: "Chara",
  crb: "Island Carib",
  crc: "Lonwolwol",
  crd: "Coeur d'Alene",
  cre: "Cree",
  crf: "Caramanta",
  crg: "Michif",
  crh: "Crimean Tatar",
  cri: "Sotomense",
  crj: "Southern East Cree",
  crk: "Plains Cree",
  crl: "Northern East Cree",
  crm: "Moose Cree",
  crn: "El Nayar Cora",
  cro: "Crow",
  crq: "Iyo'wujwa Chorote",
  crr: "Carolina Algonquian",
  crs: "Seselwa Creole French",
  crt: "Iyojwa'ja Chorote",
  crv: "Chaura",
  crw: "Chrau",
  crx: "Carrier",
  cry: "Cori",
  crz: "Cruzeo",
  csa: "Chiltepec Chinantec",
  csb: "Kashubian",
  csc: "Catalan Sign Language",
  csd: "Chiangmai Sign Language",
  cse: "Czech Sign Language",
  csf: "Cuba Sign Language",
  csg: "Chilean Sign Language",
  csh: "Asho Chin",
  csi: "Coast Miwok",
  csj: "Songlai Chin",
  csk: "Jola-Kasa",
  csl: "Chinese Sign Language",
  csm: "Central Sierra Miwok",
  csn: "Colombian Sign Language",
  cso: "Sochiapam Chinantec",
  csq: "Croatia Sign Language",
  csr: "Costa Rican Sign Language",
  css: "Southern Ohlone",
  cst: "Northern Ohlone",
  csv: "Sumtu Chin",
  csw: "Swampy Cree",
  csy: "Siyin Chin",
  csz: "Coos",
  cta: "Tataltepec Chatino",
  ctc: "Chetco",
  ctd: "Tedim Chin",
  cte: "Tepinapa Chinantec",
  ctg: "Chittagonian",
  cth: "Thaiphum Chin",
  ctl: "Tlacoatzintepec Chinantec",
  ctm: "Chitimacha",
  ctn: "Chhintange",
  cto: "Ember-Cato",
  ctp: "Western Highland Chatino",
  cts: "Northern Catanduanes Bikol",
  ctt: "Wayanad Chetti",
  ctu: "Chol",
  ctz: "Zacatepec Chatino",
  cua: "Cua",
  cub: "Cubeo",
  cuc: "Usila Chinantec",
  cug: "Chungmboko",
  cuh: "Chuka",
  cui: "Cuiba",
  cuj: "Mashco Piro",
  cuk: "San Blas Kuna",
  cul: "Culina",
  cuo: "Cumanagoto",
  cup: "Cupeo",
  cuq: "Cun",
  cur: "Chhulung",
  cut: "Teutila Cuicatec",
  cuu: "Tai Ya",
  cuv: "Cuvok",
  cuw: "Chukwa",
  cux: "Tepeuxila Cuicatec",
  cvg: "Chug",
  cvn: "Valle Nacional Chinantec",
  cwa: "Kabwa",
  cwb: "Maindo",
  cwd: "Woods Cree",
  cwe: "Kwere",
  cwg: "Chewong",
  cwt: "Kuwaataay",
  cya: "Nopala Chatino",
  cyb: "Cayubaba",
  cym: "Welsh",
  cyo: "Cuyonon",
  czh: "Huizhou Chinese",
  czk: "Knaanic",
  czn: "Zenzontepec Chatino",
  czo: "Min Zhong Chinese",
  czt: "Zotung Chin",
  daa: "Dangalat",
  dac: "Dambi",
  dad: "Marik",
  dae: "Duupa",
  dag: "Dagbani",
  dah: "Gwahatike",
  dai: "Day",
  daj: "Dar Fur Daju",
  dak: "Dakota",
  dal: "Dahalo",
  dam: "Damakawa",
  dan: "Danish",
  dao: "Daai Chin",
  daq: "Dandami Maria",
  dar: "Dargwa",
  das: "Daho-Doo",
  dau: "Dar Sila Daju",
  dav: "Taita",
  daw: "Davawenyo",
  dax: "Dayi",
  daz: "Dao",
  dba: "Bangime",
  dbb: "Deno",
  dbd: "Dadiya",
  dbe: "Dabe",
  dbf: "Edopi",
  dbg: "Dogul Dom Dogon",
  dbi: "Doka",
  dbj: "Ida'an",
  dbl: "Dyirbal",
  dbm: "Duguri",
  dbn: "Duriankere",
  dbo: "Dulbu",
  dbp: "Duwai",
  dbq: "Daba",
  dbr: "Dabarre",
  dbt: "Ben Tey Dogon",
  dbu: "Bondum Dom Dogon",
  dbv: "Dungu",
  dbw: "Bankan Tey Dogon",
  dby: "Dibiyaso",
  dcc: "Deccan",
  dcr: "Negerhollands",
  dda: "Dadi Dadi",
  ddd: "Dongotono",
  dde: "Doondo",
  ddg: "Fataluku",
  ddi: "West Goodenough",
  ddj: "Jaru",
  ddn: "Dendi (Benin)",
  ddo: "Dido",
  ddr: "Dhudhuroa",
  dds: "Donno So Dogon",
  ddw: "Dawera-Daweloor",
  dec: "Dagik",
  ded: "Dedua",
  dee: "Dewoin",
  def: "Dezfuli",
  deg: "Degema",
  deh: "Dehwari",
  dei: "Demisa",
  dek: "Dek",
  del: "Delaware",
  dem: "Dem",
  den: "Slave (Athapascan)",
  dep: "Pidgin Delaware",
  deq: "Dendi (Central African Republic)",
  der: "Deori",
  des: "Desano",
  deu: "German",
  dev: "Domung",
  dez: "Dengese",
  dga: "Southern Dagaare",
  dgb: "Bunoge Dogon",
  dgc: "Casiguran Dumagat Agta",
  dgd: "Dagaari Dioula",
  dge: "Degenan",
  dgg: "Doga",
  dgh: "Dghwede",
  dgi: "Northern Dagara",
  dgk: "Dagba",
  dgl: "Andaandi",
  dgn: "Dagoman",
  dgo: "Dogri (individual language)",
  dgr: "Dogrib",
  dgs: "Dogoso",
  dgt: "Ndra'ngith",
  dgu: "Degaru",
  dgw: "Daungwurrung",
  dgx: "Doghoro",
  dgz: "Daga",
  dhd: "Dhundari",
  dhg: "Dhangu-Djangu",
  dhi: "Dhimal",
  dhl: "Dhalandji",
  dhm: "Zemba",
  dhn: "Dhanki",
  dho: "Dhodia",
  dhr: "Dhargari",
  dhs: "Dhaiso",
  dhu: "Dhurga",
  dhv: "Dehu",
  dhw: "Dhanwar (Nepal)",
  dhx: "Dhungaloo",
  dia: "Dia",
  dib: "South Central Dinka",
  dic: "Lakota Dida",
  did: "Didinga",
  dif: "Dieri",
  dig: "Digo",
  dih: "Kumiai",
  dii: "Dimbong",
  dij: "Dai",
  dik: "Southwestern Dinka",
  dil: "Dilling",
  dim: "Dime",
  din: "Dinka",
  dio: "Dibo",
  dip: "Northeastern Dinka",
  diq: "Dimli (individual language)",
  dir: "Dirim",
  dis: "Dimasa",
  dit: "Dirari",
  diu: "Diriku",
  div: "Dhivehi",
  diw: "Northwestern Dinka",
  dix: "Dixon Reef",
  diy: "Diuwe",
  diz: "Ding",
  dja: "Djadjawurrung",
  djb: "Djinba",
  djc: "Dar Daju Daju",
  djd: "Djamindjung",
  dje: "Zarma",
  djf: "Djangun",
  dji: "Djinang",
  djj: "Djeebbana",
  djk: "Eastern Maroon Creole",
  djm: "Jamsay Dogon",
  djn: "Djauan",
  djo: "Jangkang",
  djr: "Djambarrpuyngu",
  dju: "Kapriman",
  djw: "Djawi",
  dka: "Dakpakha",
  dkk: "Dakka",
  dkr: "Kuijau",
  dks: "Southeastern Dinka",
  dkx: "Mazagway",
  dlg: "Dolgan",
  dlk: "Dahalik",
  dlm: "Dalmatian",
  dln: "Darlong",
  dma: "Duma",
  dmb: "Mombo Dogon",
  dmc: "Gavak",
  dmd: "Madhi Madhi",
  dme: "Dugwor",
  dmg: "Upper Kinabatangan",
  dmk: "Domaaki",
  dml: "Dameli",
  dmm: "Dama",
  dmo: "Kemedzung",
  dmr: "East Damar",
  dms: "Dampelas",
  dmu: "Dubu",
  dmv: "Dumpas",
  dmw: "Mudburra",
  dmx: "Dema",
  dmy: "Demta",
  dna: "Upper Grand Valley Dani",
  dnd: "Daonda",
  dne: "Ndendeule",
  dng: "Dungan",
  dni: "Lower Grand Valley Dani",
  dnj: "Dan",
  dnk: "Dengka",
  dnn: "Dzngoo",
  dnr: "Danaru",
  dnt: "Mid Grand Valley Dani",
  dnu: "Danau",
  dnv: "Danu",
  dnw: "Western Dani",
  dny: "Den",
  doa: "Dom",
  dob: "Dobu",
  doc: "Northern Dong",
  doe: "Doe",
  dof: "Domu",
  doh: "Dong",
  doi: "Dogri (macrolanguage)",
  dok: "Dondo",
  dol: "Doso",
  don: "Toura (Papua New Guinea)",
  doo: "Dongo",
  dop: "Lukpa",
  doq: "Dominican Sign Language",
  dor: "Dori'o",
  dos: "Dogos",
  dot: "Dass",
  dov: "Dombe",
  dow: "Doyayo",
  dox: "Bussa",
  doy: "Dompo",
  doz: "Dorze",
  dpp: "Papar",
  drb: "Dair",
  drc: "Minderico",
  drd: "Darmiya",
  dre: "Dolpo",
  drg: "Rungus",
  dri: "C'Lela",
  drl: "Paakantyi",
  drn: "West Damar",
  dro: "Daro-Matu Melanau",
  drq: "Dura",
  drr: "Dororo",
  drs: "Gedeo",
  drt: "Drents",
  dru: "Rukai",
  dry: "Darai",
  dsb: "Lower Sorbian",
  dse: "Dutch Sign Language",
  dsh: "Daasanach",
  dsi: "Disa",
  dsl: "Danish Sign Language",
  dsn: "Dusner",
  dso: "Desiya",
  dsq: "Tadaksahak",
  dta: "Daur",
  dtb: "Labuk-Kinabatangan Kadazan",
  dtd: "Ditidaht",
  dth: "Adithinngithigh",
  dti: "Ana Tinga Dogon",
  dtk: "Tene Kan Dogon",
  dtm: "Tomo Kan Dogon",
  dtn: "Daatsiin",
  dto: "Tommo So Dogon",
  dtp: "Kadazan Dusun",
  dtr: "Lotud",
  dts: "Toro So Dogon",
  dtt: "Toro Tegu Dogon",
  dtu: "Tebul Ure Dogon",
  dty: "Dotyali",
  dua: "Duala",
  dub: "Dubli",
  duc: "Duna",
  dud: "Hun-Saare",
  due: "Umiray Dumaget Agta",
  duf: "Dumbea",
  dug: "Duruma",
  duh: "Dungra Bhil",
  dui: "Dumun",
  duk: "Uyajitaya",
  dul: "Alabat Island Agta",
  dum: "Middle Dutch (ca. 1050-1350)",
  dun: "Dusun Deyah",
  duo: "Dupaninan Agta",
  dup: "Duano",
  duq: "Dusun Malang",
  dur: "Dii",
  dus: "Dumi",
  duu: "Drung",
  duv: "Duvle",
  duw: "Dusun Witu",
  dux: "Duungooma",
  duy: "Dicamay Agta",
  duz: "Duli-Gey",
  dva: "Duau",
  dwa: "Diri",
  dwr: "Dawro",
  dws: "Dutton World Speedwords",
  dwu: "Dhuwal",
  dww: "Dawawa",
  dwy: "Dhuwaya",
  dya: "Dyan",
  dyb: "Dyaberdyaber",
  dyd: "Dyugun",
  dyg: "Villa Viciosa Agta",
  dyi: "Djimini Senoufo",
  dym: "Yanda Dom Dogon",
  dyn: "Dyangadi",
  dyo: "Jola-Fonyi",
  dyu: "Dyula",
  dyy: "Dyaabugay",
  dza: "Tunzu",
  dze: "Djiwarli",
  dzg: "Dazaga",
  dzl: "Dzalakha",
  dzn: "Dzando",
  dzo: "Dzongkha",
  eaa: "Karenggapa",
  ebg: "Ebughu",
  ebk: "Eastern Bontok",
  ebo: "Teke-Ebo",
  ebr: "Ebri",
  ebu: "Embu",
  ecr: "Eteocretan",
  ecs: "Ecuadorian Sign Language",
  ecy: "Eteocypriot",
  eee: "E",
  efa: "Efai",
  efe: "Efe",
  efi: "Efik",
  ega: "Ega",
  egl: "Emilian",
  ego: "Eggon",
  egy: "Egyptian (Ancient)",
  ehu: "Ehueun",
  eip: "Eipomek",
  eit: "Eitiep",
  eiv: "Askopan",
  eja: "Ejamat",
  eka: "Ekajuk",
  ekc: "Eastern Karnic",
  eke: "Ekit",
  ekg: "Ekari",
  eki: "Eki",
  ekk: "Standard Estonian",
  ekl: "Kol (Bangladesh)",
  ekm: "Elip",
  eko: "Koti",
  ekp: "Ekpeye",
  ekr: "Yace",
  eky: "Eastern Kayah",
  ele: "Elepi",
  elh: "El Hugeirat",
  eli: "Nding",
  elk: "Elkei",
  ell: "Modern Greek (1453-)",
  elm: "Eleme",
  elo: "El Molo",
  elu: "Elu",
  elx: "Elamite",
  ema: "Emai-Iuleha-Ora",
  emb: "Embaloh",
  eme: "Emerillon",
  emg: "Eastern Meohang",
  emi: "Mussau-Emira",
  emk: "Eastern Maninkakan",
  emm: "Mamulique",
  emn: "Eman",
  emp: "Northern Ember",
  ems: "Pacific Gulf Yupik",
  emu: "Eastern Muria",
  emw: "Emplawas",
  emx: "Erromintxela",
  emy: "Epigraphic Mayan",
  ena: "Apali",
  enb: "Markweeta",
  enc: "En",
  end: "Ende",
  enf: "Forest Enets",
  eng: "English",
  enh: "Tundra Enets",
  enl: "Enlhet",
  enm: "Middle English (1100-1500)",
  enn: "Engenni",
  eno: "Enggano",
  enq: "Enga",
  enr: "Emumu",
  enu: "Enu",
  env: "Enwan (Edu State)",
  enw: "Enwan (Akwa Ibom State)",
  enx: "Enxet",
  eot: "Beti (Cte d'Ivoire)",
  epi: "Epie",
  epo: "Esperanto",
  era: "Eravallan",
  erg: "Sie",
  erh: "Eruwa",
  eri: "Ogea",
  erk: "South Efate",
  ero: "Horpa",
  err: "Erre",
  ers: "Ersu",
  ert: "Eritai",
  erw: "Erokwanas",
  ese: "Ese Ejja",
  esg: "Aheri Gondi",
  esh: "Eshtehardi",
  esi: "North Alaskan Inupiatun",
  esk: "Northwest Alaska Inupiatun",
  esl: "Egypt Sign Language",
  esm: "Esuma",
  esn: "Salvadoran Sign Language",
  eso: "Estonian Sign Language",
  esq: "Esselen",
  ess: "Central Siberian Yupik",
  est: "Estonian",
  esu: "Central Yupik",
  esy: "Eskayan",
  etb: "Etebi",
  etc: "Etchemin",
  eth: "Ethiopian Sign Language",
  etn: "Eton (Vanuatu)",
  eto: "Eton (Cameroon)",
  etr: "Edolo",
  ets: "Yekhee",
  ett: "Etruscan",
  etu: "Ejagham",
  etx: "Eten",
  etz: "Semimi",
  eus: "Basque",
  eve: "Even",
  evh: "Uvbie",
  evn: "Evenki",
  ewe: "Ewe",
  ewo: "Ewondo",
  ext: "Extremaduran",
  eya: "Eyak",
  eyo: "Keiyo",
  eza: "Ezaa",
  eze: "Uzekwe",
  faa: "Fasu",
  fab: "Fa d'Ambu",
  fad: "Wagi",
  faf: "Fagani",
  fag: "Finongan",
  fah: "Baissa Fali",
  fai: "Faiwol",
  faj: "Faita",
  fak: "Fang (Cameroon)",
  fal: "South Fali",
  fam: "Fam",
  fan: "Fang (Equatorial Guinea)",
  fao: "Faroese",
  fap: "Palor",
  far: "Fataleka",
  fas: "Persian",
  fat: "Fanti",
  fau: "Fayu",
  fax: "Fala",
  fay: "Southwestern Fars",
  faz: "Northwestern Fars",
  fbl: "West Albay Bikol",
  fcs: "Quebec Sign Language",
  fer: "Feroge",
  ffi: "Foia Foia",
  ffm: "Maasina Fulfulde",
  fgr: "Fongoro",
  fia: "Nobiin",
  fie: "Fyer",
  fij: "Fijian",
  fil: "Filipino",
  fin: "Finnish",
  fip: "Fipa",
  fir: "Firan",
  fit: "Tornedalen Finnish",
  fiw: "Fiwaga",
  fkk: "Kirya-Konzl",
  fkv: "Kven Finnish",
  fla: "Kalispel-Pend d'Oreille",
  flh: "Foau",
  fli: "Fali",
  fll: "North Fali",
  fln: "Flinders Island",
  flr: "Fuliiru",
  fly: "Flaaitaal",
  fmp: "Fe'fe'",
  fmu: "Far Western Muria",
  fnb: "Fanbak",
  fng: "Fanagalo",
  fni: "Fania",
  fod: "Foodo",
  foi: "Foi",
  fom: "Foma",
  fon: "Fon",
  "for": "Fore",
  fos: "Siraya",
  fpe: "Fernando Po Creole English",
  fqs: "Fas",
  fra: "French",
  frc: "Cajun French",
  frd: "Fordata",
  frk: "Frankish",
  frm: "Middle French (ca. 1400-1600)",
  fro: "Old French (842-ca. 1400)",
  frp: "Arpitan",
  frq: "Forak",
  frr: "Northern Frisian",
  frs: "Eastern Frisian",
  frt: "Fortsenal",
  fry: "Western Frisian",
  fse: "Finnish Sign Language",
  fsl: "French Sign Language",
  fss: "Finland-Swedish Sign Language",
  fub: "Adamawa Fulfulde",
  fuc: "Pulaar",
  fud: "East Futuna",
  fue: "Borgu Fulfulde",
  fuf: "Pular",
  fuh: "Western Niger Fulfulde",
  fui: "Bagirmi Fulfulde",
  fuj: "Ko",
  ful: "Fulah",
  fum: "Fum",
  fun: "Fulni",
  fuq: "Central-Eastern Niger Fulfulde",
  fur: "Friulian",
  fut: "Futuna-Aniwa",
  fuu: "Furu",
  fuv: "Nigerian Fulfulde",
  fuy: "Fuyug",
  fvr: "Fur",
  fwa: "Fwi",
  fwe: "Fwe",
  gaa: "Ga",
  gab: "Gabri",
  gac: "Mixed Great Andamanese",
  gad: "Gaddang",
  gae: "Guarequena",
  gaf: "Gende",
  gag: "Gagauz",
  gah: "Alekano",
  gai: "Borei",
  gaj: "Gadsup",
  gak: "Gamkonora",
  gal: "Galolen",
  gam: "Kandawo",
  gan: "Gan Chinese",
  gao: "Gants",
  gap: "Gal",
  gaq: "Gata'",
  gar: "Galeya",
  gas: "Adiwasi Garasia",
  gat: "Kenati",
  gau: "Mudhili Gadaba",
  gaw: "Nobonob",
  gax: "Borana-Arsi-Guji Oromo",
  gay: "Gayo",
  gaz: "West Central Oromo",
  gba: "Gbaya (Central African Republic)",
  gbb: "Kaytetye",
  gbd: "Karadjeri",
  gbe: "Niksek",
  gbf: "Gaikundi",
  gbg: "Gbanziri",
  gbh: "Defi Gbe",
  gbi: "Galela",
  gbj: "Bodo Gadaba",
  gbk: "Gaddi",
  gbl: "Gamit",
  gbm: "Garhwali",
  gbn: "Mo'da",
  gbo: "Northern Grebo",
  gbp: "Gbaya-Bossangoa",
  gbq: "Gbaya-Bozoum",
  gbr: "Gbagyi",
  gbs: "Gbesi Gbe",
  gbu: "Gagadu",
  gbv: "Gbanu",
  gbw: "Gabi-Gabi",
  gbx: "Eastern Xwla Gbe",
  gby: "Gbari",
  gbz: "Zoroastrian Dari",
  gcc: "Mali",
  gcd: "Ganggalida",
  gce: "Galice",
  gcf: "Guadeloupean Creole French",
  gcl: "Grenadian Creole English",
  gcn: "Gaina",
  gcr: "Guianese Creole French",
  gct: "Colonia Tovar German",
  gda: "Gade Lohar",
  gdb: "Pottangi Ollar Gadaba",
  gdc: "Gugu Badhun",
  gdd: "Gedaged",
  gde: "Gude",
  gdf: "Guduf-Gava",
  gdg: "Ga'dang",
  gdh: "Gadjerawang",
  gdi: "Gundi",
  gdj: "Gurdjar",
  gdk: "Gadang",
  gdl: "Dirasha",
  gdm: "Laal",
  gdn: "Umanakaina",
  gdo: "Ghodoberi",
  gdq: "Mehri",
  gdr: "Wipi",
  gds: "Ghandruk Sign Language",
  gdt: "Kungardutyi",
  gdu: "Gudu",
  gdx: "Godwari",
  gea: "Geruma",
  geb: "Kire",
  gec: "Gboloo Grebo",
  ged: "Gade",
  geg: "Gengle",
  geh: "Hutterite German",
  gei: "Gebe",
  gej: "Gen",
  gek: "Ywom",
  gel: "ut-Ma'in",
  geq: "Geme",
  ges: "Geser-Gorom",
  gev: "Eviya",
  gew: "Gera",
  gex: "Garre",
  gey: "Enya",
  gez: "Geez",
  gfk: "Patpatar",
  gft: "Gafat",
  gga: "Gao",
  ggb: "Gbii",
  ggd: "Gugadj",
  gge: "Guragone",
  ggg: "Gurgula",
  ggk: "Kungarakany",
  ggl: "Ganglau",
  ggt: "Gitua",
  ggu: "Gagu",
  ggw: "Gogodala",
  gha: "Ghadams",
  ghc: "Hiberno-Scottish Gaelic",
  ghe: "Southern Ghale",
  ghh: "Northern Ghale",
  ghk: "Geko Karen",
  ghl: "Ghulfan",
  ghn: "Ghanongga",
  gho: "Ghomara",
  ghr: "Ghera",
  ghs: "Guhu-Samane",
  ght: "Kuke",
  gia: "Kitja",
  gib: "Gibanawa",
  gic: "Gail",
  gid: "Gidar",
  gie: "Gaogbo",
  gig: "Goaria",
  gih: "Githabul",
  gil: "Gilbertese",
  gim: "Gimi (Eastern Highlands)",
  gin: "Hinukh",
  gip: "Gimi (West New Britain)",
  giq: "Green Gelao",
  gir: "Red Gelao",
  gis: "North Giziga",
  git: "Gitxsan",
  giu: "Mulao",
  giw: "White Gelao",
  gix: "Gilima",
  giy: "Giyug",
  giz: "South Giziga",
  gji: "Geji",
  gjk: "Kachi Koli",
  gjm: "Gunditjmara",
  gjn: "Gonja",
  gjr: "Gurindji Kriol",
  gju: "Gujari",
  gka: "Guya",
  gke: "Ndai",
  gkn: "Gokana",
  gko: "Kok-Nar",
  gkp: "Guinea Kpelle",
  gku: "Ungkue",
  gla: "Scottish Gaelic",
  glc: "Bon Gula",
  gld: "Nanai",
  gle: "Irish",
  glg: "Galician",
  glh: "Northwest Pashai",
  gli: "Guliguli",
  glj: "Gula Iro",
  glk: "Gilaki",
  gll: "Garlali",
  glo: "Galambu",
  glr: "Glaro-Twabo",
  glu: "Gula (Chad)",
  glv: "Manx",
  glw: "Glavda",
  gly: "Gule",
  gma: "Gambera",
  gmb: "Gula'alaa",
  gmd: "Mghd",
  gmg: "Magyi",
  gmh: "Middle High German (ca. 1050-1500)",
  gml: "Middle Low German",
  gmm: "Gbaya-Mbodomo",
  gmn: "Gimnime",
  gmu: "Gumalu",
  gmv: "Gamo",
  gmx: "Magoma",
  gmy: "Mycenaean Greek",
  gmz: "Mgbolizhia",
  gna: "Kaansa",
  gnb: "Gangte",
  gnc: "Guanche",
  gnd: "Zulgo-Gemzek",
  gne: "Ganang",
  gng: "Ngangam",
  gnh: "Lere",
  gni: "Gooniyandi",
  gnk: "//Gana",
  gnl: "Gangulu",
  gnm: "Ginuman",
  gnn: "Gumatj",
  gno: "Northern Gondi",
  gnq: "Gana",
  gnr: "Gureng Gureng",
  gnt: "Guntai",
  gnu: "Gnau",
  gnw: "Western Bolivian Guaran",
  gnz: "Ganzi",
  goa: "Guro",
  gob: "Playero",
  goc: "Gorakor",
  god: "Godi",
  goe: "Gongduk",
  gof: "Gofa",
  gog: "Gogo",
  goh: "Old High German (ca. 750-1050)",
  goi: "Gobasi",
  goj: "Gowlan",
  gok: "Gowli",
  gol: "Gola",
  gom: "Goan Konkani",
  gon: "Gondi",
  goo: "Gone Dau",
  gop: "Yeretuar",
  goq: "Gorap",
  gor: "Gorontalo",
  gos: "Gronings",
  got: "Gothic",
  gou: "Gavar",
  gow: "Gorowa",
  gox: "Gobu",
  goy: "Goundo",
  goz: "Gozarkhani",
  gpa: "Gupa-Abawa",
  gpe: "Ghanaian Pidgin English",
  gpn: "Taiap",
  gqa: "Ga'anda",
  gqi: "Guiqiong",
  gqn: "Guana (Brazil)",
  gqr: "Gor",
  gqu: "Qau",
  gra: "Rajput Garasia",
  grb: "Grebo",
  grc: "Ancient Greek (to 1453)",
  grd: "Guruntum-Mbaaru",
  grg: "Madi",
  grh: "Gbiri-Niragu",
  gri: "Ghari",
  grj: "Southern Grebo",
  grm: "Kota Marudu Talantang",
  grn: "Guarani",
  gro: "Groma",
  grq: "Gorovu",
  grr: "Taznatit",
  grs: "Gresi",
  grt: "Garo",
  gru: "Kistane",
  grv: "Central Grebo",
  grw: "Gweda",
  grx: "Guriaso",
  gry: "Barclayville Grebo",
  grz: "Guramalum",
  gse: "Ghanaian Sign Language",
  gsg: "German Sign Language",
  gsl: "Gusilay",
  gsm: "Guatemalan Sign Language",
  gsn: "Nema",
  gso: "Southwest Gbaya",
  gsp: "Wasembo",
  gss: "Greek Sign Language",
  gsw: "Swiss German",
  gta: "Guat",
  gtu: "Aghu-Tharnggala",
  gua: "Shiki",
  gub: "Guajajra",
  guc: "Wayuu",
  gud: "Yocobou Dida",
  gue: "Gurinji",
  guf: "Gupapuyngu",
  gug: "Paraguayan Guaran",
  guh: "Guahibo",
  gui: "Eastern Bolivian Guaran",
  guj: "Gujarati",
  guk: "Gumuz",
  gul: "Sea Island Creole English",
  gum: "Guambiano",
  gun: "Mby Guaran",
  guo: "Guayabero",
  gup: "Gunwinggu",
  guq: "Ach",
  gur: "Farefare",
  gus: "Guinean Sign Language",
  gut: "Malku Jaka",
  guu: "Yanomam",
  guw: "Gun",
  gux: "Gourmanchma",
  guz: "Gusii",
  gva: "Guana (Paraguay)",
  gvc: "Guanano",
  gve: "Duwet",
  gvf: "Golin",
  gvj: "Guaj",
  gvl: "Gulay",
  gvm: "Gurmana",
  gvn: "Kuku-Yalanji",
  gvo: "Gavio Do Jiparan",
  gvp: "Par Gavio",
  gvr: "Gurung",
  gvs: "Gumawana",
  gvy: "Guyani",
  gwa: "Mbato",
  gwb: "Gwa",
  gwc: "Kalami",
  gwd: "Gawwada",
  gwe: "Gweno",
  gwf: "Gowro",
  gwg: "Moo",
  gwi: "Gwichin",
  gwj: "/Gwi",
  gwm: "Awngthim",
  gwn: "Gwandara",
  gwr: "Gwere",
  gwt: "Gawar-Bati",
  gwu: "Guwamu",
  gww: "Kwini",
  gwx: "Gua",
  gxx: "W Southern",
  gya: "Northwest Gbaya",
  gyb: "Garus",
  gyd: "Kayardild",
  gye: "Gyem",
  gyf: "Gungabula",
  gyg: "Gbayi",
  gyi: "Gyele",
  gyl: "Gayil",
  gym: "Ngbere",
  gyn: "Guyanese Creole English",
  gyr: "Guarayu",
  gyy: "Gunya",
  gza: "Ganza",
  gzi: "Gazi",
  gzn: "Gane",
  haa: "Han",
  hab: "Hanoi Sign Language",
  hac: "Gurani",
  had: "Hatam",
  hae: "Eastern Oromo",
  haf: "Haiphong Sign Language",
  hag: "Hanga",
  hah: "Hahon",
  hai: "Haida",
  haj: "Hajong",
  hak: "Hakka Chinese",
  hal: "Halang",
  ham: "Hewa",
  han: "Hangaza",
  hao: "Hak",
  hap: "Hupla",
  haq: "Ha",
  har: "Harari",
  has: "Haisla",
  hat: "Haitian",
  hau: "Hausa",
  hav: "Havu",
  haw: "Hawaiian",
  hax: "Southern Haida",
  hay: "Haya",
  haz: "Hazaragi",
  hba: "Hamba",
  hbb: "Huba",
  hbn: "Heiban",
  hbo: "Ancient Hebrew",
  hbs: "Serbo-Croatian",
  hbu: "Habu",
  hca: "Andaman Creole Hindi",
  hch: "Huichol",
  hdn: "Northern Haida",
  hds: "Honduras Sign Language",
  hdy: "Hadiyya",
  hea: "Northern Qiandong Miao",
  heb: "Hebrew",
  hed: "Herd",
  heg: "Helong",
  heh: "Hehe",
  hei: "Heiltsuk",
  hem: "Hemba",
  her: "Herero",
  hgm: "Hai//om",
  hgw: "Haigwai",
  hhi: "Hoia Hoia",
  hhr: "Kerak",
  hhy: "Hoyahoya",
  hia: "Lamang",
  hib: "Hibito",
  hid: "Hidatsa",
  hif: "Fiji Hindi",
  hig: "Kamwe",
  hih: "Pamosu",
  hii: "Hinduri",
  hij: "Hijuk",
  hik: "Seit-Kaitetu",
  hil: "Hiligaynon",
  hin: "Hindi",
  hio: "Tsoa",
  hir: "Himarim",
  hit: "Hittite",
  hiw: "Hiw",
  hix: "Hixkaryna",
  hji: "Haji",
  hka: "Kahe",
  hke: "Hunde",
  hkk: "Hunjara-Kaina Ke",
  hks: "Hong Kong Sign Language",
  hla: "Halia",
  hlb: "Halbi",
  hld: "Halang Doan",
  hle: "Hlersu",
  hlt: "Matu Chin",
  hlu: "Hieroglyphic Luwian",
  hma: "Southern Mashan Hmong",
  hmb: "Humburi Senni Songhay",
  hmc: "Central Huishui Hmong",
  hmd: "Large Flowery Miao",
  hme: "Eastern Huishui Hmong",
  hmf: "Hmong Don",
  hmg: "Southwestern Guiyang Hmong",
  hmh: "Southwestern Huishui Hmong",
  hmi: "Northern Huishui Hmong",
  hmj: "Ge",
  hmk: "Maek",
  hml: "Luopohe Hmong",
  hmm: "Central Mashan Hmong",
  hmn: "Hmong",
  hmo: "Hiri Motu",
  hmp: "Northern Mashan Hmong",
  hmq: "Eastern Qiandong Miao",
  hmr: "Hmar",
  hms: "Southern Qiandong Miao",
  hmt: "Hamtai",
  hmu: "Hamap",
  hmv: "Hmong D",
  hmw: "Western Mashan Hmong",
  hmy: "Southern Guiyang Hmong",
  hmz: "Hmong Shua",
  hna: "Mina (Cameroon)",
  hnd: "Southern Hindko",
  hne: "Chhattisgarhi",
  hnh: "//Ani",
  hni: "Hani",
  hnj: "Hmong Njua",
  hnn: "Hanunoo",
  hno: "Northern Hindko",
  hns: "Caribbean Hindustani",
  hnu: "Hung",
  hoa: "Hoava",
  hob: "Mari (Madang Province)",
  hoc: "Ho",
  hod: "Holma",
  hoe: "Horom",
  hoh: "Hobyt",
  hoi: "Holikachuk",
  hoj: "Hadothi",
  hol: "Holu",
  hom: "Homa",
  hoo: "Holoholo",
  hop: "Hopi",
  hor: "Horo",
  hos: "Ho Chi Minh City Sign Language",
  hot: "Hote",
  hov: "Hovongan",
  how: "Honi",
  hoy: "Holiya",
  hoz: "Hozo",
  hpo: "Hpon",
  hps: "Hawai'i Sign Language (HSL)",
  hra: "Hrangkhol",
  hrc: "Niwer Mil",
  hre: "Hre",
  hrk: "Haruku",
  hrm: "Horned Miao",
  hro: "Haroi",
  hrp: "Nhirrpi",
  hrt: "Hrtevin",
  hru: "Hruso",
  hrv: "Croatian",
  hrw: "Warwar Feni",
  hrx: "Hunsrik",
  hrz: "Harzani",
  hsb: "Upper Sorbian",
  hsh: "Hungarian Sign Language",
  hsl: "Hausa Sign Language",
  hsn: "Xiang Chinese",
  hss: "Harsusi",
  hti: "Hoti",
  hto: "Minica Huitoto",
  hts: "Hadza",
  htu: "Hitu",
  htx: "Middle Hittite",
  hub: "Huambisa",
  huc: "Err:510",
  hud: "Huaulu",
  hue: "San Francisco Del Mar Huave",
  huf: "Humene",
  hug: "Huachipaeri",
  huh: "Huilliche",
  hui: "Huli",
  huj: "Northern Guiyang Hmong",
  huk: "Hulung",
  hul: "Hula",
  hum: "Hungana",
  hun: "Hungarian",
  huo: "Hu",
  hup: "Hupa",
  huq: "Tsat",
  hur: "Halkomelem",
  hus: "Huastec",
  hut: "Humla",
  huu: "Murui Huitoto",
  huv: "San Mateo Del Mar Huave",
  huw: "Hukumina",
  hux: "Npode Huitoto",
  huy: "Hulaul",
  huz: "Hunzib",
  hvc: "Haitian Vodoun Culture Language",
  hve: "San Dionisio Del Mar Huave",
  hvk: "Haveke",
  hvn: "Sabu",
  hvv: "Santa Mara Del Mar Huave",
  hwa: "Wan",
  hwc: "Hawai'i Creole English",
  hwo: "Hwana",
  hya: "Hya",
  hye: "Armenian",
  iai: "Iaai",
  ian: "Iatmul",
  iar: "Purari",
  iba: "Iban",
  ibb: "Ibibio",
  ibd: "Iwaidja",
  ibe: "Akpes",
  ibg: "Ibanag",
  ibh: "Bih",
  ibl: "Ibaloi",
  ibm: "Agoi",
  ibn: "Ibino",
  ibo: "Igbo",
  ibr: "Ibuoro",
  ibu: "Ibu",
  iby: "Ibani",
  ica: "Ede Ica",
  ich: "Etkywan",
  icl: "Icelandic Sign Language",
  icr: "Islander Creole English",
  ida: "Idakho-Isukha-Tiriki",
  idb: "Indo-Portuguese",
  idc: "Idon",
  idd: "Ede Idaca",
  ide: "Idere",
  idi: "Idi",
  ido: "Ido",
  idr: "Indri",
  ids: "Idesa",
  idt: "Idat",
  idu: "Idoma",
  ifa: "Amganad Ifugao",
  ifb: "Batad Ifugao",
  ife: "If",
  iff: "Ifo",
  ifk: "Tuwali Ifugao",
  ifm: "Teke-Fuumu",
  ifu: "Mayoyao Ifugao",
  ify: "Keley-I Kallahan",
  igb: "Ebira",
  ige: "Igede",
  igg: "Igana",
  igl: "Igala",
  igm: "Kanggape",
  ign: "Ignaciano",
  igo: "Isebe",
  igs: "Interglossa",
  igw: "Igwe",
  ihb: "Iha Based Pidgin",
  ihi: "Ihievbe",
  ihp: "Iha",
  ihw: "Bidhawal",
  iii: "Sichuan Yi",
  iin: "Thiin",
  ijc: "Izon",
  ije: "Biseni",
  ijj: "Ede Ije",
  ijn: "Kalabari",
  ijs: "Southeast Ijo",
  ike: "Eastern Canadian Inuktitut",
  iki: "Iko",
  ikk: "Ika",
  ikl: "Ikulu",
  iko: "Olulumo-Ikom",
  ikp: "Ikpeshi",
  ikr: "Ikaranggal",
  iks: "Inuit Sign Language",
  ikt: "Inuinnaqtun",
  iku: "Inuktitut",
  ikv: "Iku-Gora-Ankwa",
  ikw: "Ikwere",
  ikx: "Ik",
  ikz: "Ikizu",
  ila: "Ile Ape",
  ilb: "Ila",
  ile: "Interlingue",
  ilg: "Garig-Ilgar",
  ili: "Ili Turki",
  ilk: "Ilongot",
  ilm: "Iranun (Malaysia)",
  ilo: "Iloko",
  ilp: "Iranun (Philippines)",
  ils: "International Sign",
  ilu: "Ili'uun",
  ilv: "Ilue",
  ima: "Mala Malasar",
  imi: "Anamgura",
  iml: "Miluk",
  imn: "Imonda",
  imo: "Imbongu",
  imr: "Imroing",
  ims: "Marsian",
  imy: "Milyan",
  ina: "Interlingua (International Auxiliary Language Association)",
  inb: "Inga",
  ind: "Indonesian",
  ing: "Degexit'an",
  inh: "Ingush",
  inj: "Jungle Inga",
  inl: "Indonesian Sign Language",
  inm: "Minaean",
  inn: "Isinai",
  ino: "Inoke-Yate",
  inp: "Iapari",
  ins: "Indian Sign Language",
  "int": "Intha",
  inz: "Ineseo",
  ior: "Inor",
  iou: "Tuma-Irumu",
  iow: "Iowa-Oto",
  ipi: "Ipili",
  ipk: "Inupiaq",
  ipo: "Ipiko",
  iqu: "Iquito",
  iqw: "Ikwo",
  ire: "Iresim",
  irh: "Irarutu",
  iri: "Irigwe",
  irk: "Iraqw",
  irn: "Irntxe",
  irr: "Ir",
  iru: "Irula",
  irx: "Kamberau",
  iry: "Iraya",
  isa: "Isabi",
  isc: "Isconahua",
  isd: "Isnag",
  ise: "Italian Sign Language",
  isg: "Irish Sign Language",
  ish: "Esan",
  isi: "Nkem-Nkum",
  isk: "Ishkashimi",
  isl: "Icelandic",
  ism: "Masimasi",
  isn: "Isanzu",
  iso: "Isoko",
  isr: "Israeli Sign Language",
  ist: "Istriot",
  isu: "Isu (Menchum Division)",
  ita: "Italian",
  itb: "Binongan Itneg",
  itd: "Southern Tidung",
  ite: "Itene",
  iti: "Inlaod Itneg",
  itk: "Judeo-Italian",
  itl: "Itelmen",
  itm: "Itu Mbon Uzo",
  ito: "Itonama",
  itr: "Iteri",
  its: "Isekiri",
  itt: "Maeng Itneg",
  itv: "Itawit",
  itw: "Ito",
  itx: "Itik",
  ity: "Moyadan Itneg",
  itz: "Itz",
  ium: "Iu Mien",
  ivb: "Ibatan",
  ivv: "Ivatan",
  iwk: "I-Wak",
  iwm: "Iwam",
  iwo: "Iwur",
  iws: "Sepik Iwam",
  ixc: "Ixcatec",
  ixl: "Ixil",
  iya: "Iyayu",
  iyo: "Mesaka",
  iyx: "Yaka (Congo)",
  izh: "Ingrian",
  izr: "Izere",
  izz: "Izii",
  jaa: "Jamamad",
  jab: "Hyam",
  jac: "Popti'",
  jad: "Jahanka",
  jae: "Yabem",
  jaf: "Jara",
  jah: "Jah Hut",
  jaj: "Zazao",
  jak: "Jakun",
  jal: "Yalahatan",
  jam: "Jamaican Creole English",
  jan: "Jandai",
  jao: "Yanyuwa",
  jaq: "Yaqay",
  jas: "New Caledonian Javanese",
  jat: "Jakati",
  jau: "Yaur",
  jav: "Javanese",
  jax: "Jambi Malay",
  jay: "Yan-nhangu",
  jaz: "Jawe",
  jbe: "Judeo-Berber",
  jbi: "Badjiri",
  jbj: "Arandai",
  jbk: "Barikewa",
  jbn: "Nafusi",
  jbo: "Lojban",
  jbr: "Jofotek-Bromnya",
  jbt: "Jabut",
  jbu: "Jukun Takum",
  jbw: "Yawijibaya",
  jcs: "Jamaican Country Sign Language",
  jct: "Krymchak",
  jda: "Jad",
  jdg: "Jadgali",
  jdt: "Judeo-Tat",
  jeb: "Jebero",
  jee: "Jerung",
  jeh: "Jeh",
  jei: "Yei",
  jek: "Jeri Kuo",
  jel: "Yelmek",
  jen: "Dza",
  jer: "Jere",
  jet: "Manem",
  jeu: "Jonkor Bourmataguil",
  jgb: "Ngbee",
  jge: "Judeo-Georgian",
  jgk: "Gwak",
  jgo: "Ngomba",
  jhi: "Jehai",
  jhs: "Jhankot Sign Language",
  jia: "Jina",
  jib: "Jibu",
  jic: "Tol",
  jid: "Bu",
  jie: "Jilbe",
  jig: "Djingili",
  jih: "sTodsde",
  jii: "Jiiddu",
  jil: "Jilim",
  jim: "Jimi (Cameroon)",
  jio: "Jiamao",
  jiq: "Guanyinqiao",
  jit: "Jita",
  jiu: "Youle Jinuo",
  jiv: "Shuar",
  jiy: "Buyuan Jinuo",
  jje: "Jejueo",
  jjr: "Bankal",
  jka: "Kaera",
  jkm: "Mobwa Karen",
  jko: "Kubo",
  jkp: "Paku Karen",
  jkr: "Koro (India)",
  jku: "Labir",
  jle: "Ngile",
  jls: "Jamaican Sign Language",
  jma: "Dima",
  jmb: "Zumbun",
  jmc: "Machame",
  jmd: "Yamdena",
  jmi: "Jimi (Nigeria)",
  jml: "Jumli",
  jmn: "Makuri Naga",
  jmr: "Kamara",
  jms: "Mashi (Nigeria)",
  jmw: "Mouwase",
  jmx: "Western Juxtlahuaca Mixtec",
  jna: "Jangshung",
  jnd: "Jandavra",
  jng: "Yangman",
  jni: "Janji",
  jnj: "Yemsa",
  jnl: "Rawat",
  jns: "Jaunsari",
  job: "Joba",
  jod: "Wojenaka",
  jog: "Jogi",
  jor: "Jor",
  jos: "Jordanian Sign Language",
  jow: "Jowulu",
  jpa: "Jewish Palestinian Aramaic",
  jpn: "Japanese",
  jpr: "Judeo-Persian",
  jqr: "Jaqaru",
  jra: "Jarai",
  jrb: "Judeo-Arabic",
  jrr: "Jiru",
  jrt: "Jorto",
  jru: "Japrera",
  jsl: "Japanese Sign Language",
  jua: "Jma",
  jub: "Wannu",
  juc: "Jurchen",
  jud: "Worodougou",
  juh: "Hne",
  jui: "Ngadjuri",
  juk: "Wapan",
  jul: "Jirel",
  jum: "Jumjum",
  jun: "Juang",
  juo: "Jiba",
  jup: "Hupd",
  jur: "Jurna",
  jus: "Jumla Sign Language",
  jut: "Jutish",
  juu: "Ju",
  juw: "Wpha",
  juy: "Juray",
  jvd: "Javindo",
  jvn: "Caribbean Javanese",
  jwi: "Jwira-Pepesa",
  jya: "Jiarong",
  jye: "Judeo-Yemeni Arabic",
  jyy: "Jaya",
  kaa: "Kara-Kalpak",
  kab: "Kabyle",
  kac: "Kachin",
  kad: "Adara",
  kae: "Ketangalan",
  kaf: "Katso",
  kag: "Kajaman",
  kah: "Kara (Central African Republic)",
  kai: "Karekare",
  kaj: "Jju",
  kak: "Kalanguya",
  kal: "Kalaallisut",
  kam: "Kamba (Kenya)",
  kan: "Kannada",
  kao: "Xaasongaxango",
  kap: "Bezhta",
  kaq: "Capanahua",
  kas: "Kashmiri",
  kat: "Georgian",
  kau: "Kanuri",
  kav: "Katukna",
  kaw: "Kawi",
  kax: "Kao",
  kay: "Kamayur",
  kaz: "Kazakh",
  kba: "Kalarko",
  kbb: "Kaxuina",
  kbc: "Kadiwu",
  kbd: "Kabardian",
  kbe: "Kanju",
  kbg: "Khamba",
  kbh: "Cams",
  kbi: "Kaptiau",
  kbj: "Kari",
  kbk: "Grass Koiari",
  kbl: "Kanembu",
  kbm: "Iwal",
  kbn: "Kare (Central African Republic)",
  kbo: "Keliko",
  kbp: "Kabiy",
  kbq: "Kamano",
  kbr: "Kafa",
  kbs: "Kande",
  kbt: "Abadi",
  kbu: "Kabutra",
  kbv: "Dera (Indonesia)",
  kbw: "Kaiep",
  kbx: "Ap Ma",
  kby: "Manga Kanuri",
  kbz: "Duhwa",
  kca: "Khanty",
  kcb: "Kawacha",
  kcc: "Lubila",
  kcd: "Ngklmpw Kanum",
  kce: "Kaivi",
  kcf: "Ukaan",
  kcg: "Tyap",
  kch: "Vono",
  kci: "Kamantan",
  kcj: "Kobiana",
  kck: "Kalanga",
  kcl: "Kela (Papua New Guinea)",
  kcm: "Gula (Central African Republic)",
  kcn: "Nubi",
  kco: "Kinalakna",
  kcp: "Kanga",
  kcq: "Kamo",
  kcr: "Katla",
  kcs: "Koenoem",
  kct: "Kaian",
  kcu: "Kami (Tanzania)",
  kcv: "Kete",
  kcw: "Kabwari",
  kcx: "Kachama-Ganjule",
  kcy: "Korandje",
  kcz: "Konongo",
  kda: "Worimi",
  kdc: "Kutu",
  kdd: "Yankunytjatjara",
  kde: "Makonde",
  kdf: "Mamusi",
  kdg: "Seba",
  kdh: "Tem",
  kdi: "Kumam",
  kdj: "Karamojong",
  kdk: "Num",
  kdl: "Tsikimba",
  kdm: "Kagoma",
  kdn: "Kunda",
  kdp: "Kaningdon-Nindem",
  kdq: "Koch",
  kdr: "Karaim",
  kdt: "Kuy",
  kdu: "Kadaru",
  kdw: "Koneraw",
  kdx: "Kam",
  kdy: "Keder",
  kdz: "Kwaja",
  kea: "Kabuverdianu",
  keb: "Kl",
  kec: "Keiga",
  ked: "Kerewe",
  kee: "Eastern Keres",
  kef: "Kpessi",
  keg: "Tese",
  keh: "Keak",
  kei: "Kei",
  kej: "Kadar",
  kek: "Kekch",
  kel: "Kela (Democratic Republic of Congo)",
  kem: "Kemak",
  ken: "Kenyang",
  keo: "Kakwa",
  kep: "Kaikadi",
  keq: "Kamar",
  ker: "Kera",
  kes: "Kugbo",
  ket: "Ket",
  keu: "Akebu",
  kev: "Kanikkaran",
  kew: "West Kewa",
  kex: "Kukna",
  key: "Kupia",
  kez: "Kukele",
  kfa: "Kodava",
  kfb: "Northwestern Kolami",
  kfc: "Konda-Dora",
  kfd: "Korra Koraga",
  kfe: "Kota (India)",
  kff: "Koya",
  kfg: "Kudiya",
  kfh: "Kurichiya",
  kfi: "Kannada Kurumba",
  kfj: "Kemiehua",
  kfk: "Kinnauri",
  kfl: "Kung",
  kfm: "Khunsari",
  kfn: "Kuk",
  kfo: "Koro (Cte d'Ivoire)",
  kfp: "Korwa",
  kfq: "Korku",
  kfr: "Kachhi",
  kfs: "Bilaspuri",
  kft: "Kanjari",
  kfu: "Katkari",
  kfv: "Kurmukar",
  kfw: "Kharam Naga",
  kfx: "Kullu Pahari",
  kfy: "Kumaoni",
  kfz: "Koromf",
  kga: "Koyaga",
  kgb: "Kawe",
  kge: "Komering",
  kgf: "Kube",
  kgg: "Kusunda",
  kgi: "Selangor Sign Language",
  kgj: "Gamale Kham",
  kgk: "Kaiw",
  kgl: "Kunggari",
  kgm: "Karipna",
  kgn: "Karingani",
  kgo: "Krongo",
  kgp: "Kaingang",
  kgq: "Kamoro",
  kgr: "Abun",
  kgs: "Kumbainggar",
  kgt: "Somyev",
  kgu: "Kobol",
  kgv: "Karas",
  kgw: "Karon Dori",
  kgx: "Kamaru",
  kgy: "Kyerung",
  kha: "Khasi",
  khb: "L",
  khc: "Tukang Besi North",
  khd: "Bdi Kanum",
  khe: "Korowai",
  khf: "Khuen",
  khg: "Khams Tibetan",
  khh: "Kehu",
  khj: "Kuturmi",
  khk: "Halh Mongolian",
  khl: "Lusi",
  khm: "Central Khmer",
  khn: "Khandesi",
  kho: "Khotanese",
  khp: "Kapori",
  khq: "Koyra Chiini Songhay",
  khr: "Kharia",
  khs: "Kasua",
  kht: "Khamti",
  khu: "Nkhumbi",
  khv: "Khvarshi",
  khw: "Khowar",
  khx: "Kanu",
  khy: "Kele (Democratic Republic of Congo)",
  khz: "Keapara",
  kia: "Kim",
  kib: "Koalib",
  kic: "Kickapoo",
  kid: "Koshin",
  kie: "Kibet",
  kif: "Eastern Parbate Kham",
  kig: "Kimaama",
  kih: "Kilmeri",
  kii: "Kitsai",
  kij: "Kilivila",
  kik: "Kikuyu",
  kil: "Kariya",
  kim: "Karagas",
  kin: "Kinyarwanda",
  kio: "Kiowa",
  kip: "Sheshi Kham",
  kiq: "Kosadle",
  kir: "Kirghiz",
  kis: "Kis",
  kit: "Agob",
  kiu: "Kirmanjki (individual language)",
  kiv: "Kimbu",
  kiw: "Northeast Kiwai",
  kix: "Khiamniungan Naga",
  kiy: "Kirikiri",
  kiz: "Kisi",
  kja: "Mlap",
  kjb: "Q'anjob'al",
  kjc: "Coastal Konjo",
  kjd: "Southern Kiwai",
  kje: "Kisar",
  kjf: "Khalaj",
  kjg: "Khmu",
  kjh: "Khakas",
  kji: "Zabana",
  kjj: "Khinalugh",
  kjk: "Highland Konjo",
  kjl: "Western Parbate Kham",
  kjm: "Khng",
  kjn: "Kunjen",
  kjo: "Harijan Kinnauri",
  kjp: "Pwo Eastern Karen",
  kjq: "Western Keres",
  kjr: "Kurudu",
  kjs: "East Kewa",
  kjt: "Phrae Pwo Karen",
  kju: "Kashaya",
  kjv: "Kaikavian Literary Language",
  kjx: "Ramopa",
  kjy: "Erave",
  kjz: "Bumthangkha",
  kka: "Kakanda",
  kkb: "Kwerisa",
  kkc: "Odoodee",
  kkd: "Kinuku",
  kke: "Kakabe",
  kkf: "Kalaktang Monpa",
  kkg: "Mabaka Valley Kalinga",
  kkh: "Khn",
  kki: "Kagulu",
  kkj: "Kako",
  kkk: "Kokota",
  kkl: "Kosarek Yale",
  kkm: "Kiong",
  kkn: "Kon Keu",
  kko: "Karko",
  kkp: "Gugubera",
  kkq: "Kaiku",
  kkr: "Kir-Balar",
  kks: "Giiwo",
  kkt: "Koi",
  kku: "Tumi",
  kkv: "Kangean",
  kkw: "Teke-Kukuya",
  kkx: "Kohin",
  kky: "Guguyimidjir",
  kkz: "Kaska",
  kla: "Klamath-Modoc",
  klb: "Kiliwa",
  klc: "Kolbila",
  kld: "Gamilaraay",
  kle: "Kulung (Nepal)",
  klf: "Kendeje",
  klg: "Tagakaulo",
  klh: "Weliki",
  kli: "Kalumpang",
  klj: "Turkic Khalaj",
  klk: "Kono (Nigeria)",
  kll: "Kagan Kalagan",
  klm: "Migum",
  kln: "Kalenjin",
  klo: "Kapya",
  klp: "Kamasa",
  klq: "Rumu",
  klr: "Khaling",
  kls: "Kalasha",
  klt: "Nukna",
  klu: "Klao",
  klv: "Maskelynes",
  klw: "Tado",
  klx: "Koluwawa",
  kly: "Kalao",
  klz: "Kabola",
  kma: "Konni",
  kmb: "Kimbundu",
  kmc: "Southern Dong",
  kmd: "Majukayang Kalinga",
  kme: "Bakole",
  kmf: "Kare (Papua New Guinea)",
  kmg: "Kte",
  kmh: "Kalam",
  kmi: "Kami (Nigeria)",
  kmj: "Kumarbhag Paharia",
  kmk: "Limos Kalinga",
  kml: "Tanudan Kalinga",
  kmm: "Kom (India)",
  kmn: "Awtuw",
  kmo: "Kwoma",
  kmp: "Gimme",
  kmq: "Kwama",
  kmr: "Northern Kurdish",
  kms: "Kamasau",
  kmt: "Kemtuik",
  kmu: "Kanite",
  kmv: "Karipna Creole French",
  kmw: "Komo (Democratic Republic of Congo)",
  kmx: "Waboda",
  kmy: "Koma",
  kmz: "Khorasani Turkish",
  kna: "Dera (Nigeria)",
  knb: "Lubuagan Kalinga",
  knc: "Central Kanuri",
  knd: "Konda",
  kne: "Kankanaey",
  knf: "Mankanya",
  kng: "Koongo",
  kni: "Kanufi",
  knj: "Western Kanjobal",
  knk: "Kuranko",
  knl: "Keninjal",
  knm: "Kanamar",
  knn: "Konkani (individual language)",
  kno: "Kono (Sierra Leone)",
  knp: "Kwanja",
  knq: "Kintaq",
  knr: "Kaningra",
  kns: "Kensiu",
  knt: "Panoan Katukna",
  knu: "Kono (Guinea)",
  knv: "Tabo",
  knw: "Kung-Ekoka",
  knx: "Kendayan",
  kny: "Kanyok",
  knz: "Kalams",
  koa: "Konomala",
  koc: "Kpati",
  kod: "Kodi",
  koe: "Kacipo-Balesi",
  kof: "Kubi",
  kog: "Cogui",
  koh: "Koyo",
  koi: "Komi-Permyak",
  kok: "Konkani (macrolanguage)",
  kol: "Kol (Papua New Guinea)",
  kom: "Komi",
  kon: "Kongo",
  koo: "Konzo",
  kop: "Waube",
  koq: "Kota (Gabon)",
  kor: "Korean",
  kos: "Kosraean",
  kot: "Lagwan",
  kou: "Koke",
  kov: "Kudu-Camo",
  kow: "Kugama",
  koy: "Koyukon",
  koz: "Korak",
  kpa: "Kutto",
  kpb: "Mullu Kurumba",
  kpc: "Curripaco",
  kpd: "Koba",
  kpe: "Kpelle",
  kpf: "Komba",
  kpg: "Kapingamarangi",
  kph: "Kplang",
  kpi: "Kofei",
  kpj: "Karaj",
  kpk: "Kpan",
  kpl: "Kpala",
  kpm: "Koho",
  kpn: "Kepkiriwt",
  kpo: "Ikposo",
  kpq: "Korupun-Sela",
  kpr: "Korafe-Yegha",
  kps: "Tehit",
  kpt: "Karata",
  kpu: "Kafoa",
  kpv: "Komi-Zyrian",
  kpw: "Kobon",
  kpx: "Mountain Koiali",
  kpy: "Koryak",
  kpz: "Kupsabiny",
  kqa: "Mum",
  kqb: "Kovai",
  kqc: "Doromu-Koki",
  kqd: "Koy Sanjaq Surat",
  kqe: "Kalagan",
  kqf: "Kakabai",
  kqg: "Khe",
  kqh: "Kisankasa",
  kqi: "Koitabu",
  kqj: "Koromira",
  kqk: "Kotafon Gbe",
  kql: "Kyenele",
  kqm: "Khisa",
  kqn: "Kaonde",
  kqo: "Eastern Krahn",
  kqp: "Kimr",
  kqq: "Krenak",
  kqr: "Kimaragang",
  kqs: "Northern Kissi",
  kqt: "Klias River Kadazan",
  kqu: "Seroa",
  kqv: "Okolod",
  kqw: "Kandas",
  kqx: "Mser",
  kqy: "Koorete",
  kqz: "Korana",
  kra: "Kumhali",
  krb: "Karkin",
  krc: "Karachay-Balkar",
  krd: "Kairui-Midiki",
  kre: "Panar",
  krf: "Koro (Vanuatu)",
  krh: "Kurama",
  kri: "Krio",
  krj: "Kinaray-A",
  krk: "Kerek",
  krl: "Karelian",
  krn: "Sapo",
  krp: "Korop",
  krr: "Krung",
  krs: "Gbaya (Sudan)",
  krt: "Tumari Kanuri",
  kru: "Kurukh",
  krv: "Kavet",
  krw: "Western Krahn",
  krx: "Karon",
  kry: "Kryts",
  krz: "Sota Kanum",
  ksa: "Shuwa-Zamani",
  ksb: "Shambala",
  ksc: "Southern Kalinga",
  ksd: "Kuanua",
  kse: "Kuni",
  ksf: "Bafia",
  ksg: "Kusaghe",
  ksh: "Klsch",
  ksi: "Krisa",
  ksj: "Uare",
  ksk: "Kansa",
  ksl: "Kumalu",
  ksm: "Kumba",
  ksn: "Kasiguranin",
  kso: "Kofa",
  ksp: "Kaba",
  ksq: "Kwaami",
  ksr: "Borong",
  kss: "Southern Kisi",
  kst: "Winy",
  ksu: "Khamyang",
  ksv: "Kusu",
  ksw: "S'gaw Karen",
  ksx: "Kedang",
  ksy: "Kharia Thar",
  ksz: "Kodaku",
  kta: "Katua",
  ktb: "Kambaata",
  ktc: "Kholok",
  ktd: "Kokata",
  kte: "Nubri",
  ktf: "Kwami",
  ktg: "Kalkutung",
  kth: "Karanga",
  kti: "North Muyu",
  ktj: "Plapo Krumen",
  ktk: "Kaniet",
  ktl: "Koroshi",
  ktm: "Kurti",
  ktn: "Karitina",
  kto: "Kuot",
  ktp: "Kaduo",
  ktq: "Katabaga",
  kts: "South Muyu",
  ktt: "Ketum",
  ktu: "Kituba (Democratic Republic of Congo)",
  ktv: "Eastern Katu",
  ktw: "Kato",
  ktx: "Kaxarar",
  kty: "Kango (Bas-Ul District)",
  ktz: "Ju/'hoan",
  kua: "Kuanyama",
  kub: "Kutep",
  kuc: "Kwinsu",
  kud: "'Auhelawa",
  kue: "Kuman (Papua New Guinea)",
  kuf: "Western Katu",
  kug: "Kupa",
  kuh: "Kushi",
  kui: "Kuikro-Kalaplo",
  kuj: "Kuria",
  kuk: "Kepo'",
  kul: "Kulere",
  kum: "Kumyk",
  kun: "Kunama",
  kuo: "Kumukio",
  kup: "Kunimaipa",
  kuq: "Karipuna",
  kur: "Kurdish",
  kus: "Kusaal",
  kut: "Kutenai",
  kuu: "Upper Kuskokwim",
  kuv: "Kur",
  kuw: "Kpagua",
  kux: "Kukatja",
  kuy: "Kuuku-Ya'u",
  kuz: "Kunza",
  kva: "Bagvalal",
  kvb: "Kubu",
  kvc: "Kove",
  kvd: "Kui (Indonesia)",
  kve: "Kalabakan",
  kvf: "Kabalai",
  kvg: "Kuni-Boazi",
  kvh: "Komodo",
  kvi: "Kwang",
  kvj: "Psikye",
  kvk: "Korean Sign Language",
  kvl: "Kayaw",
  kvm: "Kendem",
  kvn: "Border Kuna",
  kvo: "Dobel",
  kvp: "Kompane",
  kvq: "Geba Karen",
  kvr: "Kerinci",
  kvt: "Lahta Karen",
  kvu: "Yinbaw Karen",
  kvv: "Kola",
  kvw: "Wersing",
  kvx: "Parkari Koli",
  kvy: "Yintale Karen",
  kvz: "Tsakwambo",
  kwa: "Dw",
  kwb: "Kwa",
  kwc: "Likwala",
  kwd: "Kwaio",
  kwe: "Kwerba",
  kwf: "Kwara'ae",
  kwg: "Sara Kaba Deme",
  kwh: "Kowiai",
  kwi: "Awa-Cuaiquer",
  kwj: "Kwanga",
  kwk: "Kwakiutl",
  kwl: "Kofyar",
  kwm: "Kwambi",
  kwn: "Kwangali",
  kwo: "Kwomtari",
  kwp: "Kodia",
  kwr: "Kwer",
  kws: "Kwese",
  kwt: "Kwesten",
  kwu: "Kwakum",
  kwv: "Sara Kaba N",
  kww: "Kwinti",
  kwx: "Khirwar",
  kwy: "San Salvador Kongo",
  kwz: "Kwadi",
  kxa: "Kairiru",
  kxb: "Krobu",
  kxc: "Konso",
  kxd: "Brunei",
  kxf: "Manumanaw Karen",
  kxh: "Karo (Ethiopia)",
  kxi: "Keningau Murut",
  kxj: "Kulfa",
  kxk: "Zayein Karen",
  kxl: "Nepali Kurux",
  kxm: "Northern Khmer",
  kxn: "Kanowit-Tanjong Melanau",
  kxo: "Kano",
  kxp: "Wadiyara Koli",
  kxq: "Smrky Kanum",
  kxr: "Koro (Papua New Guinea)",
  kxs: "Kangjia",
  kxt: "Koiwat",
  kxu: "Kui (India)",
  kxv: "Kuvi",
  kxw: "Konai",
  kxx: "Likuba",
  kxy: "Kayong",
  kxz: "Kerewo",
  kya: "Kwaya",
  kyb: "Butbut Kalinga",
  kyc: "Kyaka",
  kyd: "Karey",
  kye: "Krache",
  kyf: "Kouya",
  kyg: "Keyagana",
  kyh: "Karok",
  kyi: "Kiput",
  kyj: "Karao",
  kyk: "Kamayo",
  kyl: "Kalapuya",
  kym: "Kpatili",
  kyn: "Northern Binukidnon",
  kyo: "Kelon",
  kyp: "Kang",
  kyq: "Kenga",
  kyr: "Kuruya",
  kys: "Baram Kayan",
  kyt: "Kayagar",
  kyu: "Western Kayah",
  kyv: "Kayort",
  kyw: "Kudmali",
  kyx: "Rapoisi",
  kyy: "Kambaira",
  kyz: "Kayab",
  kza: "Western Karaboro",
  kzb: "Kaibobo",
  kzc: "Bondoukou Kulango",
  kzd: "Kadai",
  kze: "Kosena",
  kzf: "Da'a Kaili",
  kzg: "Kikai",
  kzi: "Kelabit",
  kzk: "Kazukuru",
  kzl: "Kayeli",
  kzm: "Kais",
  kzn: "Kokola",
  kzo: "Kaningi",
  kzp: "Kaidipang",
  kzq: "Kaike",
  kzr: "Karang",
  kzs: "Sugut Dusun",
  kzu: "Kayupulau",
  kzv: "Komyandaret",
  kzw: "Karir-Xoc",
  kzx: "Kamarian",
  kzy: "Kango (Tshopo District)",
  kzz: "Kalabra",
  laa: "Southern Subanen",
  lab: "Linear A",
  lac: "Lacandon",
  lad: "Ladino",
  lae: "Pattani",
  laf: "Lafofa",
  lag: "Langi",
  lah: "Lahnda",
  lai: "Lambya",
  laj: "Lango (Uganda)",
  lak: "Laka (Nigeria)",
  lal: "Lalia",
  lam: "Lamba",
  lan: "Laru",
  lao: "Lao",
  lap: "Laka (Chad)",
  laq: "Qabiao",
  lar: "Larteh",
  las: "Lama (Togo)",
  lat: "Latin",
  lau: "Laba",
  lav: "Latvian",
  law: "Lauje",
  lax: "Tiwa",
  lay: "Lama Bai",
  laz: "Aribwatsa",
  lba: "Lui",
  lbb: "Label",
  lbc: "Lakkia",
  lbe: "Lak",
  lbf: "Tinani",
  lbg: "Laopang",
  lbi: "La'bi",
  lbj: "Ladakhi",
  lbk: "Central Bontok",
  lbl: "Libon Bikol",
  lbm: "Lodhi",
  lbn: "Lamet",
  lbo: "Laven",
  lbq: "Wampar",
  lbr: "Lohorung",
  lbs: "Libyan Sign Language",
  lbt: "Lachi",
  lbu: "Labu",
  lbv: "Lavatbura-Lamusong",
  lbw: "Tolaki",
  lbx: "Lawangan",
  lby: "Lamu-Lamu",
  lbz: "Lardil",
  lcc: "Legenyem",
  lcd: "Lola",
  lce: "Loncong",
  lcf: "Lubu",
  lch: "Luchazi",
  lcl: "Lisela",
  lcm: "Tungag",
  lcp: "Western Lawa",
  lcq: "Luhu",
  lcs: "Lisabata-Nuniali",
  lda: "Kla-Dan",
  ldb: "Duya",
  ldd: "Luri",
  ldg: "Lenyima",
  ldh: "Lamja-Dengsa-Tola",
  ldi: "Laari",
  ldj: "Lemoro",
  ldk: "Leelau",
  ldl: "Kaan",
  ldm: "Landoma",
  ldn: "Ladan",
  ldo: "Loo",
  ldp: "Tso",
  ldq: "Lufu",
  lea: "Lega-Shabunda",
  leb: "Lala-Bisa",
  lec: "Leco",
  led: "Lendu",
  lee: "Lyl",
  lef: "Lelemi",
  leh: "Lenje",
  lei: "Lemio",
  lej: "Lengola",
  lek: "Leipon",
  lel: "Lele (Democratic Republic of Congo)",
  lem: "Nomaande",
  len: "Lenca",
  leo: "Leti (Cameroon)",
  lep: "Lepcha",
  leq: "Lembena",
  ler: "Lenkau",
  les: "Lese",
  "let": "Lesing-Gelimi",
  leu: "Kara (Papua New Guinea)",
  lev: "Lamma",
  lew: "Ledo Kaili",
  lex: "Luang",
  ley: "Lemolang",
  lez: "Lezghian",
  lfa: "Lefa",
  lfn: "Lingua Franca Nova",
  lga: "Lungga",
  lgb: "Laghu",
  lgg: "Lugbara",
  lgh: "Laghuu",
  lgi: "Lengilu",
  lgk: "Lingarak",
  lgl: "Wala",
  lgm: "Lega-Mwenga",
  lgn: "T'apo",
  lgq: "Logba",
  lgr: "Lengo",
  lgt: "Pahi",
  lgu: "Longgu",
  lgz: "Ligenza",
  lha: "Laha (Viet Nam)",
  lhh: "Laha (Indonesia)",
  lhi: "Lahu Shi",
  lhl: "Lahul Lohar",
  lhm: "Lhomi",
  lhn: "Lahanan",
  lhp: "Lhokpu",
  lhs: "Mlahs",
  lht: "Lo-Toga",
  lhu: "Lahu",
  lia: "West-Central Limba",
  lib: "Likum",
  lic: "Hlai",
  lid: "Nyindrou",
  lie: "Likila",
  lif: "Limbu",
  lig: "Ligbi",
  lih: "Lihir",
  lij: "Ligurian",
  lik: "Lika",
  lil: "Lillooet",
  lim: "Limburgan",
  lin: "Lingala",
  lio: "Liki",
  lip: "Sekpele",
  liq: "Libido",
  lir: "Liberian English",
  lis: "Lisu",
  lit: "Lithuanian",
  liu: "Logorik",
  liv: "Liv",
  liw: "Col",
  lix: "Liabuku",
  liy: "Banda-Bambari",
  liz: "Libinza",
  lja: "Golpa",
  lje: "Rampi",
  lji: "Laiyolo",
  ljl: "Li'o",
  ljp: "Lampung Api",
  ljw: "Yirandali",
  ljx: "Yuru",
  lka: "Lakalei",
  lkb: "Kabras",
  lkc: "Kucong",
  lkd: "Lakond",
  lke: "Kenyi",
  lkh: "Lakha",
  lki: "Laki",
  lkj: "Remun",
  lkl: "Laeko-Libuat",
  lkm: "Kalaamaya",
  lkn: "Lakon",
  lko: "Khayo",
  lkr: "Pri",
  lks: "Kisa",
  lkt: "Lakota",
  lku: "Kungkari",
  lky: "Lokoya",
  lla: "Lala-Roba",
  llb: "Lolo",
  llc: "Lele (Guinea)",
  lld: "Ladin",
  lle: "Lele (Papua New Guinea)",
  llf: "Hermit",
  llg: "Lole",
  llh: "Lamu",
  lli: "Teke-Laali",
  llj: "Ladji Ladji",
  llk: "Lelak",
  lll: "Lilau",
  llm: "Lasalimu",
  lln: "Lele (Chad)",
  llo: "Khlor",
  llp: "North Efate",
  llq: "Lolak",
  lls: "Lithuanian Sign Language",
  llu: "Lau",
  llx: "Lauan",
  lma: "East Limba",
  lmb: "Merei",
  lmc: "Limilngan",
  lmd: "Lumun",
  lme: "Pv",
  lmf: "South Lembata",
  lmg: "Lamogai",
  lmh: "Lambichhong",
  lmi: "Lombi",
  lmj: "West Lembata",
  lmk: "Lamkang",
  lml: "Hano",
  lmn: "Lambadi",
  lmo: "Lombard",
  lmp: "Limbum",
  lmq: "Lamatuka",
  lmr: "Lamalera",
  lmu: "Lamenu",
  lmv: "Lomaiviti",
  lmw: "Lake Miwok",
  lmx: "Laimbue",
  lmy: "Lamboya",
  lmz: "Lumbee",
  lna: "Langbashe",
  lnb: "Mbalanhu",
  lnd: "Lundayeh",
  lng: "Langobardic",
  lnh: "Lanoh",
  lni: "Daantanai'",
  lnj: "Leningitij",
  lnl: "South Central Banda",
  lnm: "Langam",
  lnn: "Lorediakarkar",
  lno: "Lango (Sudan)",
  lns: "Lamnso'",
  lnu: "Longuda",
  lnw: "Lanima",
  lnz: "Lonzo",
  loa: "Loloda",
  lob: "Lobi",
  loc: "Inonhan",
  loe: "Saluan",
  lof: "Logol",
  log: "Logo",
  loh: "Narim",
  loi: "Loma (Cte d'Ivoire)",
  loj: "Lou",
  lok: "Loko",
  lol: "Mongo",
  lom: "Loma (Liberia)",
  lon: "Malawi Lomwe",
  loo: "Lombo",
  lop: "Lopa",
  loq: "Lobala",
  lor: "Tn",
  los: "Loniu",
  lot: "Otuho",
  lou: "Louisiana Creole",
  lov: "Lopi",
  low: "Tampias Lobu",
  lox: "Loun",
  loy: "Loke",
  loz: "Lozi",
  lpa: "Lelepa",
  lpe: "Lepki",
  lpn: "Long Phuri Naga",
  lpo: "Lipo",
  lpx: "Lopit",
  lra: "Rara Bakati'",
  lrc: "Northern Luri",
  lre: "Laurentian",
  lrg: "Laragia",
  lri: "Marachi",
  lrk: "Loarki",
  lrl: "Lari",
  lrm: "Marama",
  lrn: "Lorang",
  lro: "Laro",
  lrr: "Southern Yamphu",
  lrt: "Larantuka Malay",
  lrv: "Larevat",
  lrz: "Lemerig",
  lsa: "Lasgerdi",
  lsd: "Lishana Deni",
  lse: "Lusengo",
  lsg: "Lyons Sign Language",
  lsh: "Lish",
  lsi: "Lashi",
  lsl: "Latvian Sign Language",
  lsm: "Saamia",
  lso: "Laos Sign Language",
  lsp: "Panamanian Sign Language",
  lsr: "Aruop",
  lss: "Lasi",
  lst: "Trinidad and Tobago Sign Language",
  lsy: "Mauritian Sign Language",
  ltc: "Late Middle Chinese",
  ltg: "Latgalian",
  lth: "Thur",
  lti: "Leti (Indonesia)",
  ltn: "Latund",
  lto: "Tsotso",
  lts: "Tachoni",
  ltu: "Latu",
  ltz: "Luxembourgish",
  lua: "Luba-Lulua",
  lub: "Luba-Katanga",
  luc: "Aringa",
  lud: "Ludian",
  lue: "Luvale",
  luf: "Laua",
  lug: "Ganda",
  lui: "Luiseno",
  luj: "Luna",
  luk: "Lunanakha",
  lul: "Olu'bo",
  lum: "Luimbi",
  lun: "Lunda",
  luo: "Luo (Kenya and Tanzania)",
  lup: "Lumbu",
  luq: "Lucumi",
  lur: "Laura",
  lus: "Lushai",
  lut: "Lushootseed",
  luu: "Lumba-Yakkha",
  luv: "Luwati",
  luw: "Luo (Cameroon)",
  luy: "Luyia",
  luz: "Southern Luri",
  lva: "Maku'a",
  lvk: "Lavukaleve",
  lvs: "Standard Latvian",
  lvu: "Levuka",
  lwa: "Lwalu",
  lwe: "Lewo Eleng",
  lwg: "Wanga",
  lwh: "White Lachi",
  lwl: "Eastern Lawa",
  lwm: "Laomian",
  lwo: "Luwo",
  lwt: "Lewotobi",
  lwu: "Lawu",
  lww: "Lewo",
  lya: "Layakha",
  lyg: "Lyngngam",
  lyn: "Luyana",
  lzh: "Literary Chinese",
  lzl: "Litzlitz",
  lzn: "Leinong Naga",
  lzz: "Laz",
  maa: "San Jernimo Tecatl Mazatec",
  mab: "Yutanduchi Mixtec",
  mad: "Madurese",
  mae: "Bo-Rukul",
  maf: "Mafa",
  mag: "Magahi",
  mah: "Marshallese",
  mai: "Maithili",
  maj: "Jalapa De Daz Mazatec",
  mak: "Makasar",
  mal: "Malayalam",
  mam: "Mam",
  man: "Mandingo",
  maq: "Chiquihuitln Mazatec",
  mar: "Marathi",
  mas: "Masai",
  mat: "San Francisco Matlatzinca",
  mau: "Huautla Mazatec",
  mav: "Sater-Maw",
  maw: "Mampruli",
  max: "North Moluccan Malay",
  maz: "Central Mazahua",
  mba: "Higaonon",
  mbb: "Western Bukidnon Manobo",
  mbc: "Macushi",
  mbd: "Dibabawon Manobo",
  mbe: "Molale",
  mbf: "Baba Malay",
  mbh: "Mangseng",
  mbi: "Ilianen Manobo",
  mbj: "Nadb",
  mbk: "Malol",
  mbl: "Maxakal",
  mbm: "Ombamba",
  mbn: "Macagun",
  mbo: "Mbo (Cameroon)",
  mbp: "Malayo",
  mbq: "Maisin",
  mbr: "Nukak Mak",
  mbs: "Sarangani Manobo",
  mbt: "Matigsalug Manobo",
  mbu: "Mbula-Bwazza",
  mbv: "Mbulungish",
  mbw: "Maring",
  mbx: "Mari (East Sepik Province)",
  mby: "Memoni",
  mbz: "Amoltepec Mixtec",
  mca: "Maca",
  mcb: "Machiguenga",
  mcc: "Bitur",
  mcd: "Sharanahua",
  mce: "Itundujia Mixtec",
  mcf: "Matss",
  mcg: "Mapoyo",
  mch: "Maquiritari",
  mci: "Mese",
  mcj: "Mvanip",
  mck: "Mbunda",
  mcl: "Macaguaje",
  mcm: "Malaccan Creole Portuguese",
  mcn: "Masana",
  mco: "Coatln Mixe",
  mcp: "Makaa",
  mcq: "Ese",
  mcr: "Menya",
  mcs: "Mambai",
  mct: "Mengisa",
  mcu: "Cameroon Mambila",
  mcv: "Minanibai",
  mcw: "Mawa (Chad)",
  mcx: "Mpiemo",
  mcy: "South Watut",
  mcz: "Mawan",
  mda: "Mada (Nigeria)",
  mdb: "Morigi",
  mdc: "Male (Papua New Guinea)",
  mdd: "Mbum",
  mde: "Maba (Chad)",
  mdf: "Moksha",
  mdg: "Massalat",
  mdh: "Maguindanaon",
  mdi: "Mamvu",
  mdj: "Mangbetu",
  mdk: "Mangbutu",
  mdl: "Maltese Sign Language",
  mdm: "Mayogo",
  mdn: "Mbati",
  mdp: "Mbala",
  mdq: "Mbole",
  mdr: "Mandar",
  mds: "Maria (Papua New Guinea)",
  mdt: "Mbere",
  mdu: "Mboko",
  mdv: "Santa Luca Monteverde Mixtec",
  mdw: "Mbosi",
  mdx: "Dizin",
  mdy: "Male (Ethiopia)",
  mdz: "Suru Do Par",
  mea: "Menka",
  meb: "Ikobi",
  mec: "Mara",
  med: "Melpa",
  mee: "Mengen",
  mef: "Megam",
  meh: "Southwestern Tlaxiaco Mixtec",
  mei: "Midob",
  mej: "Meyah",
  mek: "Mekeo",
  mel: "Central Melanau",
  mem: "Mangala",
  men: "Mende (Sierra Leone)",
  meo: "Kedah Malay",
  mep: "Miriwung",
  meq: "Merey",
  mer: "Meru",
  mes: "Masmaje",
  met: "Mato",
  meu: "Motu",
  mev: "Mano",
  mew: "Maaka",
  mey: "Hassaniyya",
  mez: "Menominee",
  mfa: "Pattani Malay",
  mfb: "Bangka",
  mfc: "Mba",
  mfd: "Mendankwe-Nkwen",
  mfe: "Morisyen",
  mff: "Naki",
  mfg: "Mogofin",
  mfh: "Matal",
  mfi: "Wandala",
  mfj: "Mefele",
  mfk: "North Mofu",
  mfl: "Putai",
  mfm: "Marghi South",
  mfn: "Cross River Mbembe",
  mfo: "Mbe",
  mfp: "Makassar Malay",
  mfq: "Moba",
  mfr: "Marithiel",
  mfs: "Mexican Sign Language",
  mft: "Mokerang",
  mfu: "Mbwela",
  mfv: "Mandjak",
  mfw: "Mulaha",
  mfx: "Melo",
  mfy: "Mayo",
  mfz: "Mabaan",
  mga: "Middle Irish (900-1200)",
  mgb: "Mararit",
  mgc: "Morokodo",
  mgd: "Moru",
  mge: "Mango",
  mgf: "Maklew",
  mgg: "Mpumpong",
  mgh: "Makhuwa-Meetto",
  mgi: "Lijili",
  mgj: "Abureni",
  mgk: "Mawes",
  mgl: "Maleu-Kilenge",
  mgm: "Mambae",
  mgn: "Mbangi",
  mgo: "Meta'",
  mgp: "Eastern Magar",
  mgq: "Malila",
  mgr: "Mambwe-Lungu",
  mgs: "Manda (Tanzania)",
  mgt: "Mongol",
  mgu: "Mailu",
  mgv: "Matengo",
  mgw: "Matumbi",
  mgy: "Mbunga",
  mgz: "Mbugwe",
  mha: "Manda (India)",
  mhb: "Mahongwe",
  mhc: "Mocho",
  mhd: "Mbugu",
  mhe: "Besisi",
  mhf: "Mamaa",
  mhg: "Margu",
  mhi: "Ma'di",
  mhj: "Mogholi",
  mhk: "Mungaka",
  mhl: "Mauwake",
  mhm: "Makhuwa-Moniga",
  mhn: "Mcheno",
  mho: "Mashi (Zambia)",
  mhp: "Balinese Malay",
  mhq: "Mandan",
  mhr: "Eastern Mari",
  mhs: "Buru (Indonesia)",
  mht: "Mandahuaca",
  mhu: "Digaro-Mishmi",
  mhw: "Mbukushu",
  mhx: "Maru",
  mhy: "Ma'anyan",
  mhz: "Mor (Mor Islands)",
  mia: "Miami",
  mib: "Atatlhuca Mixtec",
  mic: "Mi'kmaq",
  mid: "Mandaic",
  mie: "Ocotepec Mixtec",
  mif: "Mofu-Gudur",
  mig: "San Miguel El Grande Mixtec",
  mih: "Chayuco Mixtec",
  mii: "Chigmecatitln Mixtec",
  mij: "Abar",
  mik: "Mikasuki",
  mil: "Peoles Mixtec",
  mim: "Alacatlatzala Mixtec",
  min: "Minangkabau",
  mio: "Pinotepa Nacional Mixtec",
  mip: "Apasco-Apoala Mixtec",
  miq: "Mskito",
  mir: "Isthmus Mixe",
  mis: "Uncoded languages",
  mit: "Southern Puebla Mixtec",
  miu: "Cacaloxtepec Mixtec",
  miw: "Akoye",
  mix: "Mixtepec Mixtec",
  miy: "Ayutla Mixtec",
  miz: "Coatzospan Mixtec",
  mjb: "Makalero",
  mjc: "San Juan Colorado Mixtec",
  mjd: "Northwest Maidu",
  mje: "Muskum",
  mjg: "Tu",
  mjh: "Mwera (Nyasa)",
  mji: "Kim Mun",
  mjj: "Mawak",
  mjk: "Matukar",
  mjl: "Mandeali",
  mjm: "Medebur",
  mjn: "Ma (Papua New Guinea)",
  mjo: "Malankuravan",
  mjp: "Malapandaram",
  mjq: "Malaryan",
  mjr: "Malavedan",
  mjs: "Miship",
  mjt: "Sauria Paharia",
  mju: "Manna-Dora",
  mjv: "Mannan",
  mjw: "Karbi",
  mjx: "Mahali",
  mjy: "Mahican",
  mjz: "Majhi",
  mka: "Mbre",
  mkb: "Mal Paharia",
  mkc: "Siliput",
  mkd: "Macedonian",
  mke: "Mawchi",
  mkf: "Miya",
  mkg: "Mak (China)",
  mki: "Dhatki",
  mkj: "Mokilese",
  mkk: "Byep",
  mkl: "Mokole",
  mkm: "Moklen",
  mkn: "Kupang Malay",
  mko: "Mingang Doso",
  mkp: "Moikodi",
  mkq: "Bay Miwok",
  mkr: "Malas",
  mks: "Silacayoapan Mixtec",
  mkt: "Vamale",
  mku: "Konyanka Maninka",
  mkv: "Mafea",
  mkw: "Kituba (Congo)",
  mkx: "Kinamiging Manobo",
  mky: "East Makian",
  mkz: "Makasae",
  mla: "Malo",
  mlb: "Mbule",
  mlc: "Cao Lan",
  mle: "Manambu",
  mlf: "Mal",
  mlg: "Malagasy",
  mlh: "Mape",
  mli: "Malimpung",
  mlj: "Miltu",
  mlk: "Ilwana",
  mll: "Malua Bay",
  mlm: "Mulam",
  mln: "Malango",
  mlo: "Mlomp",
  mlp: "Bargam",
  mlq: "Western Maninkakan",
  mlr: "Vame",
  mls: "Masalit",
  mlt: "Maltese",
  mlu: "To'abaita",
  mlv: "Motlav",
  mlw: "Moloko",
  mlx: "Malfaxal",
  mlz: "Malaynon",
  mma: "Mama",
  mmb: "Momina",
  mmc: "Michoacn Mazahua",
  mmd: "Maonan",
  mme: "Mae",
  mmf: "Mundat",
  mmg: "North Ambrym",
  mmh: "Mehinku",
  mmi: "Musar",
  mmj: "Majhwar",
  mmk: "Mukha-Dora",
  mml: "Man Met",
  mmm: "Maii",
  mmn: "Mamanwa",
  mmo: "Mangga Buang",
  mmp: "Siawi",
  mmq: "Musak",
  mmr: "Western Xiangxi Miao",
  mmt: "Malalamai",
  mmu: "Mmaala",
  mmv: "Miriti",
  mmw: "Emae",
  mmx: "Madak",
  mmy: "Migaama",
  mmz: "Mabaale",
  mna: "Mbula",
  mnb: "Muna",
  mnc: "Manchu",
  mnd: "Mond",
  mne: "Naba",
  mnf: "Mundani",
  mng: "Eastern Mnong",
  mnh: "Mono (Democratic Republic of Congo)",
  mni: "Manipuri",
  mnj: "Munji",
  mnk: "Mandinka",
  mnl: "Tiale",
  mnm: "Mapena",
  mnn: "Southern Mnong",
  mnp: "Min Bei Chinese",
  mnq: "Minriq",
  mnr: "Mono (USA)",
  mns: "Mansi",
  mnu: "Mer",
  mnv: "Rennell-Bellona",
  mnw: "Mon",
  mnx: "Manikion",
  mny: "Manyawa",
  mnz: "Moni",
  moa: "Mwan",
  moc: "Mocov",
  mod: "Mobilian",
  moe: "Montagnais",
  mog: "Mongondow",
  moh: "Mohawk",
  moi: "Mboi",
  moj: "Monzombo",
  mok: "Morori",
  mom: "Mangue",
  mon: "Mongolian",
  moo: "Monom",
  mop: "Mopn Maya",
  moq: "Mor (Bomberai Peninsula)",
  mor: "Moro",
  mos: "Mossi",
  mot: "Bar",
  mou: "Mogum",
  mov: "Mohave",
  mow: "Moi (Congo)",
  mox: "Molima",
  moy: "Shekkacho",
  moz: "Mukulu",
  mpa: "Mpoto",
  mpb: "Mullukmulluk",
  mpc: "Mangarayi",
  mpd: "Machinere",
  mpe: "Majang",
  mpg: "Marba",
  mph: "Maung",
  mpi: "Mpade",
  mpj: "Martu Wangka",
  mpk: "Mbara (Chad)",
  mpl: "Middle Watut",
  mpm: "Yosonda Mixtec",
  mpn: "Mindiri",
  mpo: "Miu",
  mpp: "Migabac",
  mpq: "Mats",
  mpr: "Vangunu",
  mps: "Dadibi",
  mpt: "Mian",
  mpu: "Makurp",
  mpv: "Mungkip",
  mpw: "Mapidian",
  mpx: "Misima-Panaeati",
  mpy: "Mapia",
  mpz: "Mpi",
  mqa: "Maba (Indonesia)",
  mqb: "Mbuko",
  mqc: "Mangole",
  mqe: "Matepi",
  mqf: "Momuna",
  mqg: "Kota Bangun Kutai Malay",
  mqh: "Tlazoyaltepec Mixtec",
  mqi: "Mariri",
  mqj: "Mamasa",
  mqk: "Rajah Kabunsuwan Manobo",
  mql: "Mbelime",
  mqm: "South Marquesan",
  mqn: "Moronene",
  mqo: "Modole",
  mqp: "Manipa",
  mqq: "Minokok",
  mqr: "Mander",
  mqs: "West Makian",
  mqt: "Mok",
  mqu: "Mandari",
  mqv: "Mosimo",
  mqw: "Murupi",
  mqx: "Mamuju",
  mqy: "Manggarai",
  mqz: "Pano",
  mra: "Mlabri",
  mrb: "Marino",
  mrc: "Maricopa",
  mrd: "Western Magar",
  mre: "Martha's Vineyard Sign Language",
  mrf: "Elseng",
  mrg: "Mising",
  mrh: "Mara Chin",
  mri: "Maori",
  mrj: "Western Mari",
  mrk: "Hmwaveke",
  mrl: "Mortlockese",
  mrm: "Merlav",
  mrn: "Cheke Holo",
  mro: "Mru",
  mrp: "Morouas",
  mrq: "North Marquesan",
  mrr: "Maria (India)",
  mrs: "Maragus",
  mrt: "Marghi Central",
  mru: "Mono (Cameroon)",
  mrv: "Mangareva",
  mrw: "Maranao",
  mrx: "Maremgi",
  mry: "Mandaya",
  mrz: "Marind",
  msa: "Malay (macrolanguage)",
  msb: "Masbatenyo",
  msc: "Sankaran Maninka",
  msd: "Yucatec Maya Sign Language",
  mse: "Musey",
  msf: "Mekwei",
  msg: "Moraid",
  msh: "Masikoro Malagasy",
  msi: "Sabah Malay",
  msj: "Ma (Democratic Republic of Congo)",
  msk: "Mansaka",
  msl: "Molof",
  msm: "Agusan Manobo",
  msn: "Vurs",
  mso: "Mombum",
  msp: "Maritsau",
  msq: "Caac",
  msr: "Mongolian Sign Language",
  mss: "West Masela",
  msu: "Musom",
  msv: "Maslam",
  msw: "Mansoanka",
  msx: "Moresada",
  msy: "Aruamu",
  msz: "Momare",
  mta: "Cotabato Manobo",
  mtb: "Anyin Morofo",
  mtc: "Munit",
  mtd: "Mualang",
  mte: "Mono (Solomon Islands)",
  mtf: "Murik (Papua New Guinea)",
  mtg: "Una",
  mth: "Munggui",
  mti: "Maiwa (Papua New Guinea)",
  mtj: "Moskona",
  mtk: "Mbe'",
  mtl: "Montol",
  mtm: "Mator",
  mtn: "Matagalpa",
  mto: "Totontepec Mixe",
  mtp: "Wich Lhamts Nocten",
  mtq: "Muong",
  mtr: "Mewari",
  mts: "Yora",
  mtt: "Mota",
  mtu: "Tututepec Mixtec",
  mtv: "Asaro'o",
  mtw: "Southern Binukidnon",
  mtx: "Tida Mixtec",
  mty: "Nabi",
  mua: "Mundang",
  mub: "Mubi",
  muc: "Ajumbu",
  mud: "Mednyj Aleut",
  mue: "Media Lengua",
  mug: "Musgu",
  muh: "Mnd",
  mui: "Musi",
  muj: "Mabire",
  muk: "Mugom",
  mul: "Multiple languages",
  mum: "Maiwala",
  muo: "Nyong",
  mup: "Malvi",
  muq: "Eastern Xiangxi Miao",
  mur: "Murle",
  mus: "Creek",
  mut: "Western Muria",
  muu: "Yaaku",
  muv: "Muthuvan",
  mux: "Bo-Ung",
  muy: "Muyang",
  muz: "Mursi",
  mva: "Manam",
  mvb: "Mattole",
  mvd: "Mamboru",
  mve: "Marwari (Pakistan)",
  mvf: "Peripheral Mongolian",
  mvg: "Yucuae Mixtec",
  mvh: "Mulgi",
  mvi: "Miyako",
  mvk: "Mekmek",
  mvl: "Mbara (Australia)",
  mvm: "Muya",
  mvn: "Minaveha",
  mvo: "Marovo",
  mvp: "Duri",
  mvq: "Moere",
  mvr: "Marau",
  mvs: "Massep",
  mvt: "Mpotovoro",
  mvu: "Marfa",
  mvv: "Tagal Murut",
  mvw: "Machinga",
  mvx: "Meoswar",
  mvy: "Indus Kohistani",
  mvz: "Mesqan",
  mwa: "Mwatebu",
  mwb: "Juwal",
  mwc: "Are",
  mwe: "Mwera (Chimwera)",
  mwf: "Murrinh-Patha",
  mwg: "Aiklep",
  mwh: "Mouk-Aria",
  mwi: "Labo",
  mwk: "Kita Maninkakan",
  mwl: "Mirandese",
  mwm: "Sar",
  mwn: "Nyamwanga",
  mwo: "Central Maewo",
  mwp: "Kala Lagaw Ya",
  mwq: "Mn Chin",
  mwr: "Marwari",
  mws: "Mwimbi-Muthambi",
  mwt: "Moken",
  mwu: "Mittu",
  mwv: "Mentawai",
  mww: "Hmong Daw",
  mwx: "Mediak",
  mwy: "Mosiro",
  mwz: "Moingi",
  mxa: "Northwest Oaxaca Mixtec",
  mxb: "Tezoatln Mixtec",
  mxc: "Manyika",
  mxd: "Modang",
  mxe: "Mele-Fila",
  mxf: "Malgbe",
  mxg: "Mbangala",
  mxh: "Mvuba",
  mxi: "Mozarabic",
  mxj: "Miju-Mishmi",
  mxk: "Monumbo",
  mxl: "Maxi Gbe",
  mxm: "Meramera",
  mxn: "Moi (Indonesia)",
  mxo: "Mbowe",
  mxp: "Tlahuitoltepec Mixe",
  mxq: "Juquila Mixe",
  mxr: "Murik (Malaysia)",
  mxs: "Huitepec Mixtec",
  mxt: "Jamiltepec Mixtec",
  mxu: "Mada (Cameroon)",
  mxv: "Metlatnoc Mixtec",
  mxw: "Namo",
  mxx: "Mahou",
  mxy: "Southeastern Nochixtln Mixtec",
  mxz: "Central Masela",
  mya: "Burmese",
  myb: "Mbay",
  myc: "Mayeka",
  myd: "Maramba",
  mye: "Myene",
  myf: "Bambassi",
  myg: "Manta",
  myh: "Makah",
  myi: "Mina (India)",
  myj: "Mangayat",
  myk: "Mamara Senoufo",
  myl: "Moma",
  mym: "Me'en",
  myo: "Anfillo",
  myp: "Pirah",
  myr: "Muniche",
  mys: "Mesmes",
  myu: "Munduruk",
  myv: "Erzya",
  myw: "Muyuw",
  myx: "Masaaba",
  myy: "Macuna",
  myz: "Classical Mandaic",
  mza: "Santa Mara Zacatepec Mixtec",
  mzb: "Tumzabt",
  mzc: "Madagascar Sign Language",
  mzd: "Malimba",
  mze: "Morawa",
  mzg: "Monastic Sign Language",
  mzh: "Wich Lhamts Gisnay",
  mzi: "Ixcatln Mazatec",
  mzj: "Manya",
  mzk: "Nigeria Mambila",
  mzl: "Mazatln Mixe",
  mzm: "Mumuye",
  mzn: "Mazanderani",
  mzo: "Matipuhy",
  mzp: "Movima",
  mzq: "Mori Atas",
  mzr: "Marbo",
  mzs: "Macanese",
  mzt: "Mintil",
  mzu: "Inapang",
  mzv: "Manza",
  mzw: "Deg",
  mzx: "Mawayana",
  mzy: "Mozambican Sign Language",
  mzz: "Maiadomu",
  naa: "Namla",
  nab: "Southern Nambikura",
  nac: "Narak",
  nae: "Naka'ela",
  naf: "Nabak",
  nag: "Naga Pidgin",
  naj: "Nalu",
  nak: "Nakanai",
  nal: "Nalik",
  nam: "Ngan'gityemerri",
  nan: "Min Nan Chinese",
  nao: "Naaba",
  nap: "Neapolitan",
  naq: "Khoekhoe",
  nar: "Iguta",
  nas: "Naasioi",
  nat: "Cahungwarya",
  nau: "Nauru",
  nav: "Navajo",
  naw: "Nawuri",
  nax: "Nakwi",
  nay: "Narrinyeri",
  naz: "Coatepec Nahuatl",
  nba: "Nyemba",
  nbb: "Ndoe",
  nbc: "Chang Naga",
  nbd: "Ngbinda",
  nbe: "Konyak Naga",
  nbg: "Nagarchal",
  nbh: "Ngamo",
  nbi: "Mao Naga",
  nbj: "Ngarinman",
  nbk: "Nake",
  nbl: "South Ndebele",
  nbm: "Ngbaka Ma'bo",
  nbn: "Kuri",
  nbo: "Nkukoli",
  nbp: "Nnam",
  nbq: "Nggem",
  nbr: "Numana-Nunku-Gbantu-Numbu",
  nbs: "Namibian Sign Language",
  nbt: "Na",
  nbu: "Rongmei Naga",
  nbv: "Ngamambo",
  nbw: "Southern Ngbandi",
  nby: "Ningera",
  nca: "Iyo",
  ncb: "Central Nicobarese",
  ncc: "Ponam",
  ncd: "Nachering",
  nce: "Yale",
  ncf: "Notsi",
  ncg: "Nisga'a",
  nch: "Central Huasteca Nahuatl",
  nci: "Classical Nahuatl",
  ncj: "Northern Puebla Nahuatl",
  nck: "Nakara",
  ncl: "Michoacn Nahuatl",
  ncm: "Nambo",
  ncn: "Nauna",
  nco: "Sibe",
  ncp: "Ndaktup",
  ncq: "Northern Katang",
  ncr: "Ncane",
  ncs: "Nicaraguan Sign Language",
  nct: "Chothe Naga",
  ncu: "Chumburung",
  ncx: "Central Puebla Nahuatl",
  ncz: "Natchez",
  nda: "Ndasa",
  ndb: "Kenswei Nsei",
  ndc: "Ndau",
  ndd: "Nde-Nsele-Nta",
  nde: "North Ndebele",
  ndf: "Nadruvian",
  ndg: "Ndengereko",
  ndh: "Ndali",
  ndi: "Samba Leko",
  ndj: "Ndamba",
  ndk: "Ndaka",
  ndl: "Ndolo",
  ndm: "Ndam",
  ndn: "Ngundi",
  ndo: "Ndonga",
  ndp: "Ndo",
  ndq: "Ndombe",
  ndr: "Ndoola",
  nds: "Low German",
  ndt: "Ndunga",
  ndu: "Dugun",
  ndv: "Ndut",
  ndw: "Ndobo",
  ndx: "Nduga",
  ndy: "Lutos",
  ndz: "Ndogo",
  nea: "Eastern Ngad'a",
  neb: "Toura (Cte d'Ivoire)",
  nec: "Nedebang",
  ned: "Nde-Gbite",
  nee: "Nlmwa-Nixumwak",
  nef: "Nefamese",
  neg: "Negidal",
  neh: "Nyenkha",
  nei: "Neo-Hittite",
  nej: "Neko",
  nek: "Neku",
  nem: "Nemi",
  nen: "Nengone",
  neo: "N-Meo",
  nep: "Nepali (macrolanguage)",
  neq: "North Central Mixe",
  ner: "Yahadian",
  nes: "Bhoti Kinnauri",
  net: "Nete",
  neu: "Neo",
  nev: "Nyaheun",
  "new": "Newari",
  nex: "Neme",
  ney: "Neyo",
  nez: "Nez Perce",
  nfa: "Dhao",
  nfd: "Ahwai",
  nfl: "Ayiwo",
  nfr: "Nafaanra",
  nfu: "Mfumte",
  nga: "Ngbaka",
  ngb: "Northern Ngbandi",
  ngc: "Ngombe (Democratic Republic of Congo)",
  ngd: "Ngando (Central African Republic)",
  nge: "Ngemba",
  ngg: "Ngbaka Manza",
  ngh: "N/u",
  ngi: "Ngizim",
  ngj: "Ngie",
  ngk: "Dalabon",
  ngl: "Lomwe",
  ngm: "Ngatik Men's Creole",
  ngn: "Ngwo",
  ngo: "Ngoni",
  ngp: "Ngulu",
  ngq: "Ngurimi",
  ngr: "Engdewu",
  ngs: "Gvoko",
  ngt: "Kriang",
  ngu: "Guerrero Nahuatl",
  ngv: "Nagumi",
  ngw: "Ngwaba",
  ngx: "Nggwahyi",
  ngy: "Tibea",
  ngz: "Ngungwel",
  nha: "Nhanda",
  nhb: "Beng",
  nhc: "Tabasco Nahuatl",
  nhd: "Chirip",
  nhe: "Eastern Huasteca Nahuatl",
  nhf: "Nhuwala",
  nhg: "Tetelcingo Nahuatl",
  nhh: "Nahari",
  nhi: "Zacatln-Ahuacatln-Tepetzintla Nahuatl",
  nhk: "Isthmus-Cosoleacaque Nahuatl",
  nhm: "Morelos Nahuatl",
  nhn: "Central Nahuatl",
  nho: "Takuu",
  nhp: "Isthmus-Pajapan Nahuatl",
  nhq: "Huaxcaleca Nahuatl",
  nhr: "Naro",
  nht: "Ometepec Nahuatl",
  nhu: "Noone",
  nhv: "Temascaltepec Nahuatl",
  nhw: "Western Huasteca Nahuatl",
  nhx: "Isthmus-Mecayapan Nahuatl",
  nhy: "Northern Oaxaca Nahuatl",
  nhz: "Santa Mara La Alta Nahuatl",
  nia: "Nias",
  nib: "Nakame",
  nid: "Ngandi",
  nie: "Niellim",
  nif: "Nek",
  nig: "Ngalakan",
  nih: "Nyiha (Tanzania)",
  nii: "Nii",
  nij: "Ngaju",
  nik: "Southern Nicobarese",
  nil: "Nila",
  nim: "Nilamba",
  nin: "Ninzo",
  nio: "Nganasan",
  niq: "Nandi",
  nir: "Nimboran",
  nis: "Nimi",
  nit: "Southeastern Kolami",
  niu: "Niuean",
  niv: "Gilyak",
  niw: "Nimo",
  nix: "Hema",
  niy: "Ngiti",
  niz: "Ningil",
  nja: "Nzanyi",
  njb: "Nocte Naga",
  njd: "Ndonde Hamba",
  njh: "Lotha Naga",
  nji: "Gudanji",
  njj: "Njen",
  njl: "Njalgulgule",
  njm: "Angami Naga",
  njn: "Liangmai Naga",
  njo: "Ao Naga",
  njr: "Njerep",
  njs: "Nisa",
  njt: "Ndyuka-Trio Pidgin",
  nju: "Ngadjunmaya",
  njx: "Kunyi",
  njy: "Njyem",
  njz: "Nyishi",
  nka: "Nkoya",
  nkb: "Khoibu Naga",
  nkc: "Nkongho",
  nkd: "Koireng",
  nke: "Duke",
  nkf: "Inpui Naga",
  nkg: "Nekgini",
  nkh: "Khezha Naga",
  nki: "Thangal Naga",
  nkj: "Nakai",
  nkk: "Nokuku",
  nkm: "Namat",
  nkn: "Nkangala",
  nko: "Nkonya",
  nkp: "Niuatoputapu",
  nkq: "Nkami",
  nkr: "Nukuoro",
  nks: "North Asmat",
  nkt: "Nyika (Tanzania)",
  nku: "Bouna Kulango",
  nkv: "Nyika (Malawi and Zambia)",
  nkw: "Nkutu",
  nkx: "Nkoroo",
  nkz: "Nkari",
  nla: "Ngombale",
  nlc: "Nalca",
  nld: "Dutch",
  nle: "East Nyala",
  nlg: "Gela",
  nli: "Grangali",
  nlj: "Nyali",
  nlk: "Ninia Yali",
  nll: "Nihali",
  nlo: "Ngul",
  nlq: "Lao Naga",
  nlu: "Nchumbulu",
  nlv: "Orizaba Nahuatl",
  nlw: "Walangama",
  nlx: "Nahali",
  nly: "Nyamal",
  nlz: "Nalgo",
  nma: "Maram Naga",
  nmb: "Big Nambas",
  nmc: "Ngam",
  nmd: "Ndumu",
  nme: "Mzieme Naga",
  nmf: "Tangkhul Naga (India)",
  nmg: "Kwasio",
  nmh: "Monsang Naga",
  nmi: "Nyam",
  nmj: "Ngombe (Central African Republic)",
  nmk: "Namakura",
  nml: "Ndemli",
  nmm: "Manangba",
  nmn: "!X",
  nmo: "Moyon Naga",
  nmp: "Nimanbur",
  nmq: "Nambya",
  nmr: "Nimbari",
  nms: "Letemboi",
  nmt: "Namonuito",
  nmu: "Northeast Maidu",
  nmv: "Ngamini",
  nmw: "Nimoa",
  nmx: "Nama (Papua New Guinea)",
  nmy: "Namuyi",
  nmz: "Nawdm",
  nna: "Nyangumarta",
  nnb: "Nande",
  nnc: "Nancere",
  nnd: "West Ambae",
  nne: "Ngandyera",
  nnf: "Ngaing",
  nng: "Maring Naga",
  nnh: "Ngiemboon",
  nni: "North Nuaulu",
  nnj: "Nyangatom",
  nnk: "Nankina",
  nnl: "Northern Rengma Naga",
  nnm: "Namia",
  nnn: "Ngete",
  nno: "Norwegian Nynorsk",
  nnp: "Wancho Naga",
  nnq: "Ngindo",
  nnr: "Narungga",
  nns: "Ningye",
  nnt: "Nanticoke",
  nnu: "Dwang",
  nnv: "Nugunu (Australia)",
  nnw: "Southern Nuni",
  nny: "Nyangga",
  nnz: "Nda'nda'",
  noa: "Woun Meu",
  nob: "Norwegian Bokml",
  noc: "Nuk",
  nod: "Northern Thai",
  noe: "Nimadi",
  nof: "Nomane",
  nog: "Nogai",
  noh: "Nomu",
  noi: "Noiri",
  noj: "Nonuya",
  nok: "Nooksack",
  nol: "Nomlaki",
  nom: "Nocamn",
  non: "Old Norse",
  nop: "Numanggang",
  noq: "Ngongo",
  nor: "Norwegian",
  nos: "Eastern Nisu",
  not: "Nomatsiguenga",
  nou: "Ewage-Notu",
  nov: "Novial",
  now: "Nyambo",
  noy: "Noy",
  noz: "Nayi",
  npa: "Nar Phu",
  npb: "Nupbikha",
  npg: "Ponyo-Gongwang Naga",
  nph: "Phom Naga",
  npi: "Nepali (individual language)",
  npl: "Southeastern Puebla Nahuatl",
  npn: "Mondropolon",
  npo: "Pochuri Naga",
  nps: "Nipsan",
  npu: "Puimei Naga",
  npx: "Noipx",
  npy: "Napu",
  nqg: "Southern Nago",
  nqk: "Kura Ede Nago",
  nql: "Ngendelengo",
  nqm: "Ndom",
  nqn: "Nen",
  nqo: "N'Ko",
  nqq: "Kyan-Karyaw Naga",
  nqy: "Akyaung Ari Naga",
  nra: "Ngom",
  nrb: "Nara",
  nrc: "Noric",
  nre: "Southern Rengma Naga",
  nrf: "Jrriais",
  nrg: "Narango",
  nri: "Chokri Naga",
  nrk: "Ngarla",
  nrl: "Ngarluma",
  nrm: "Narom",
  nrn: "Norn",
  nrp: "North Picene",
  nrr: "Norra",
  nrt: "Northern Kalapuya",
  nru: "Narua",
  nrx: "Ngurmbur",
  nrz: "Lala",
  nsa: "Sangtam Naga",
  nsc: "Nshi",
  nsd: "Southern Nisu",
  nse: "Nsenga",
  nsf: "Northwestern Nisu",
  nsg: "Ngasa",
  nsh: "Ngoshie",
  nsi: "Nigerian Sign Language",
  nsk: "Naskapi",
  nsl: "Norwegian Sign Language",
  nsm: "Sumi Naga",
  nsn: "Nehan",
  nso: "Pedi",
  nsp: "Nepalese Sign Language",
  nsq: "Northern Sierra Miwok",
  nsr: "Maritime Sign Language",
  nss: "Nali",
  nst: "Tase Naga",
  nsu: "Sierra Negra Nahuatl",
  nsv: "Southwestern Nisu",
  nsw: "Navut",
  nsx: "Nsongo",
  nsy: "Nasal",
  nsz: "Nisenan",
  ntd: "Northern Tidung",
  nte: "Nathembo",
  ntg: "Ngantangarra",
  nti: "Natioro",
  ntj: "Ngaanyatjarra",
  ntk: "Ikoma-Nata-Isenye",
  ntm: "Nateni",
  nto: "Ntomba",
  ntp: "Northern Tepehuan",
  ntr: "Delo",
  ntu: "Natgu",
  ntw: "Nottoway",
  ntx: "Tangkhul Naga (Myanmar)",
  nty: "Mantsi",
  ntz: "Natanzi",
  nua: "Yuanga",
  nuc: "Nukuini",
  nud: "Ngala",
  nue: "Ngundu",
  nuf: "Nusu",
  nug: "Nungali",
  nuh: "Ndunda",
  nui: "Ngumbi",
  nuj: "Nyole",
  nuk: "Nuu-chah-nulth",
  nul: "Nusa Laut",
  num: "Niuafo'ou",
  nun: "Anong",
  nuo: "Ngun",
  nup: "Nupe-Nupe-Tako",
  nuq: "Nukumanu",
  nur: "Nukuria",
  nus: "Nuer",
  nut: "Nung (Viet Nam)",
  nuu: "Ngbundu",
  nuv: "Northern Nuni",
  nuw: "Nguluwan",
  nux: "Mehek",
  nuy: "Nunggubuyu",
  nuz: "Tlamacazapa Nahuatl",
  nvh: "Nasarian",
  nvm: "Namiae",
  nvo: "Nyokon",
  nwa: "Nawathinehena",
  nwb: "Nyabwa",
  nwc: "Classical Newari",
  nwe: "Ngwe",
  nwg: "Ngayawung",
  nwi: "Southwest Tanna",
  nwm: "Nyamusa-Molo",
  nwo: "Nauo",
  nwr: "Nawaru",
  nwx: "Middle Newar",
  nwy: "Nottoway-Meherrin",
  nxa: "Nauete",
  nxd: "Ngando (Democratic Republic of Congo)",
  nxe: "Nage",
  nxg: "Ngad'a",
  nxi: "Nindi",
  nxk: "Koki Naga",
  nxl: "South Nuaulu",
  nxm: "Numidian",
  nxn: "Ngawun",
  nxo: "Ndambomo",
  nxq: "Naxi",
  nxr: "Ninggerum",
  nxu: "Narau",
  nxx: "Nafri",
  nya: "Nyanja",
  nyb: "Nyangbo",
  nyc: "Nyanga-li",
  nyd: "Nyore",
  nye: "Nyengo",
  nyf: "Giryama",
  nyg: "Nyindu",
  nyh: "Nyigina",
  nyi: "Ama (Sudan)",
  nyj: "Nyanga",
  nyk: "Nyaneka",
  nyl: "Nyeu",
  nym: "Nyamwezi",
  nyn: "Nyankole",
  nyo: "Nyoro",
  nyp: "Nyang'i",
  nyq: "Nayini",
  nyr: "Nyiha (Malawi)",
  nys: "Nyunga",
  nyt: "Nyawaygi",
  nyu: "Nyungwe",
  nyv: "Nyulnyul",
  nyw: "Nyaw",
  nyx: "Nganyaywana",
  nyy: "Nyakyusa-Ngonde",
  nza: "Tigon Mbembe",
  nzb: "Njebi",
  nzi: "Nzima",
  nzk: "Nzakara",
  nzm: "Zeme Naga",
  nzs: "New Zealand Sign Language",
  nzu: "Teke-Nzikou",
  nzy: "Nzakambay",
  nzz: "Nanga Dama Dogon",
  oaa: "Orok",
  oac: "Oroch",
  oar: "Old Aramaic (up to 700 BCE)",
  oav: "Old Avar",
  obi: "Obispeo",
  obk: "Southern Bontok",
  obl: "Oblo",
  obm: "Moabite",
  obo: "Obo Manobo",
  obr: "Old Burmese",
  obt: "Old Breton",
  obu: "Obulom",
  oca: "Ocaina",
  och: "Old Chinese",
  oci: "Occitan (post 1500)",
  oco: "Old Cornish",
  ocu: "Atzingo Matlatzinca",
  oda: "Odut",
  odk: "Od",
  odt: "Old Dutch",
  odu: "Odual",
  ofo: "Ofo",
  ofs: "Old Frisian",
  ofu: "Efutop",
  ogb: "Ogbia",
  ogc: "Ogbah",
  oge: "Old Georgian",
  ogg: "Ogbogolo",
  ogo: "Khana",
  ogu: "Ogbronuagum",
  oht: "Old Hittite",
  ohu: "Old Hungarian",
  oia: "Oirata",
  oin: "Inebu One",
  ojb: "Northwestern Ojibwa",
  ojc: "Central Ojibwa",
  ojg: "Eastern Ojibwa",
  oji: "Ojibwa",
  ojp: "Old Japanese",
  ojs: "Severn Ojibwa",
  ojv: "Ontong Java",
  ojw: "Western Ojibwa",
  oka: "Okanagan",
  okb: "Okobo",
  okd: "Okodia",
  oke: "Okpe (Southwestern Edo)",
  okg: "Koko Babangk",
  okh: "Koresh-e Rostam",
  oki: "Okiek",
  okj: "Oko-Juwoi",
  okk: "Kwamtim One",
  okl: "Old Kentish Sign Language",
  okm: "Middle Korean (10th-16th cent.)",
  okn: "Oki-No-Erabu",
  oko: "Old Korean (3rd-9th cent.)",
  okr: "Kirike",
  oks: "Oko-Eni-Osayen",
  oku: "Oku",
  okv: "Orokaiva",
  okx: "Okpe (Northwestern Edo)",
  ola: "Walungge",
  old: "Mochi",
  ole: "Olekha",
  olk: "Olkol",
  olm: "Oloma",
  olo: "Livvi",
  olr: "Olrat",
  olt: "Old Lithuanian",
  olu: "Kuvale",
  oma: "Omaha-Ponca",
  omb: "East Ambae",
  omc: "Mochica",
  omg: "Omagua",
  omi: "Omi",
  omk: "Omok",
  oml: "Ombo",
  omn: "Minoan",
  omo: "Utarmbung",
  omp: "Old Manipuri",
  omr: "Old Marathi",
  omt: "Omotik",
  omu: "Omurano",
  omw: "South Tairora",
  omx: "Old Mon",
  ona: "Ona",
  onb: "Lingao",
  one: "Oneida",
  ong: "Olo",
  oni: "Onin",
  onj: "Onjob",
  onk: "Kabore One",
  onn: "Onobasulu",
  ono: "Onondaga",
  onp: "Sartang",
  onr: "Northern One",
  ons: "Ono",
  ont: "Ontenu",
  onu: "Unua",
  onw: "Old Nubian",
  onx: "Onin Based Pidgin",
  ood: "Tohono O'odham",
  oog: "Ong",
  oon: "nge",
  oor: "Oorlams",
  oos: "Old Ossetic",
  opa: "Okpamheri",
  opk: "Kopkaka",
  opm: "Oksapmin",
  opo: "Opao",
  opt: "Opata",
  opy: "Ofay",
  ora: "Oroha",
  orc: "Orma",
  ore: "Orejn",
  org: "Oring",
  orh: "Oroqen",
  ori: "Oriya (macrolanguage)",
  orm: "Oromo",
  orn: "Orang Kanaq",
  oro: "Orokolo",
  orr: "Oruma",
  ors: "Orang Seletar",
  ort: "Adivasi Oriya",
  oru: "Ormuri",
  orv: "Old Russian",
  orw: "Oro Win",
  orx: "Oro",
  ory: "Odia",
  orz: "Ormu",
  osa: "Osage",
  osc: "Oscan",
  osi: "Osing",
  oso: "Ososo",
  osp: "Old Spanish",
  oss: "Ossetian",
  ost: "Osatu",
  osu: "Southern One",
  osx: "Old Saxon",
  ota: "Ottoman Turkish (1500-1928)",
  otb: "Old Tibetan",
  otd: "Ot Danum",
  ote: "Mezquital Otomi",
  oti: "Oti",
  otk: "Old Turkish",
  otl: "Tilapa Otomi",
  otm: "Eastern Highland Otomi",
  otn: "Tenango Otomi",
  otq: "Quertaro Otomi",
  otr: "Otoro",
  ots: "Estado de Mxico Otomi",
  ott: "Temoaya Otomi",
  otu: "Otuke",
  otw: "Ottawa",
  otx: "Texcatepec Otomi",
  oty: "Old Tamil",
  otz: "Ixtenco Otomi",
  oua: "Tagargrent",
  oub: "Glio-Oubi",
  oue: "Oune",
  oui: "Old Uighur",
  oum: "Ouma",
  ovd: "Elfdalian",
  owi: "Owiniga",
  owl: "Old Welsh",
  oyb: "Oy",
  oyd: "Oyda",
  oym: "Wayampi",
  oyy: "Oya'oya",
  ozm: "Koonzime",
  pab: "Parecs",
  pac: "Pacoh",
  pad: "Paumar",
  pae: "Pagibete",
  paf: "Paranawt",
  pag: "Pangasinan",
  pah: "Tenharim",
  pai: "Pe",
  pak: "Parakan",
  pal: "Pahlavi",
  pam: "Pampanga",
  pan: "Panjabi",
  pao: "Northern Paiute",
  pap: "Papiamento",
  paq: "Parya",
  par: "Panamint",
  pas: "Papasena",
  pat: "Papitalai",
  pau: "Palauan",
  pav: "Pakasnovos",
  paw: "Pawnee",
  pax: "Pankarar",
  pay: "Pech",
  paz: "Pankarar",
  pbb: "Pez",
  pbc: "Patamona",
  pbe: "Mezontla Popoloca",
  pbf: "Coyotepec Popoloca",
  pbg: "Paraujano",
  pbh: "E'apa Woromaipu",
  pbi: "Parkwa",
  pbl: "Mak (Nigeria)",
  pbn: "Kpasam",
  pbo: "Papel",
  pbp: "Badyara",
  pbr: "Pangwa",
  pbs: "Central Pame",
  pbt: "Southern Pashto",
  pbu: "Northern Pashto",
  pbv: "Pnar",
  pby: "Pyu (Papua New Guinea)",
  pca: "Santa Ins Ahuatempan Popoloca",
  pcb: "Pear",
  pcc: "Bouyei",
  pcd: "Picard",
  pce: "Ruching Palaung",
  pcf: "Paliyan",
  pcg: "Paniya",
  pch: "Pardhan",
  pci: "Duruwa",
  pcj: "Parenga",
  pck: "Paite Chin",
  pcl: "Pardhi",
  pcm: "Nigerian Pidgin",
  pcn: "Piti",
  pcp: "Pacahuara",
  pcw: "Pyapun",
  pda: "Anam",
  pdc: "Pennsylvania German",
  pdi: "Pa Di",
  pdn: "Podena",
  pdo: "Padoe",
  pdt: "Plautdietsch",
  pdu: "Kayan",
  pea: "Peranakan Indonesian",
  peb: "Eastern Pomo",
  ped: "Mala (Papua New Guinea)",
  pee: "Taje",
  pef: "Northeastern Pomo",
  peg: "Pengo",
  peh: "Bonan",
  pei: "Chichimeca-Jonaz",
  pej: "Northern Pomo",
  pek: "Penchal",
  pel: "Pekal",
  pem: "Phende",
  peo: "Old Persian (ca. 600-400 B.C.)",
  pep: "Kunja",
  peq: "Southern Pomo",
  pes: "Iranian Persian",
  pev: "Pmono",
  pex: "Petats",
  pey: "Petjo",
  pez: "Eastern Penan",
  pfa: "Pfang",
  pfe: "Peere",
  pfl: "Pfaelzisch",
  pga: "Sudanese Creole Arabic",
  pgd: "Gndhr",
  pgg: "Pangwali",
  pgi: "Pagi",
  pgk: "Rerep",
  pgl: "Primitive Irish",
  pgn: "Paelignian",
  pgs: "Pangseng",
  pgu: "Pagu",
  pgz: "Papua New Guinean Sign Language",
  pha: "Pa-Hng",
  phd: "Phudagi",
  phg: "Phuong",
  phh: "Phukha",
  phk: "Phake",
  phl: "Phalura",
  phm: "Phimbi",
  phn: "Phoenician",
  pho: "Phunoi",
  phq: "Phana'",
  phr: "Pahari-Potwari",
  pht: "Phu Thai",
  phu: "Phuan",
  phv: "Pahlavani",
  phw: "Phangduwali",
  pia: "Pima Bajo",
  pib: "Yine",
  pic: "Pinji",
  pid: "Piaroa",
  pie: "Piro",
  pif: "Pingelapese",
  pig: "Pisabo",
  pih: "Pitcairn-Norfolk",
  pii: "Pini",
  pij: "Pijao",
  pil: "Yom",
  pim: "Powhatan",
  pin: "Piame",
  pio: "Piapoco",
  pip: "Pero",
  pir: "Piratapuyo",
  pis: "Pijin",
  pit: "Pitta Pitta",
  piu: "Pintupi-Luritja",
  piv: "Pileni",
  piw: "Pimbwe",
  pix: "Piu",
  piy: "Piya-Kwonci",
  piz: "Pije",
  pjt: "Pitjantjatjara",
  pka: "Ardhamgadh Prkrit",
  pkb: "Pokomo",
  pkc: "Paekche",
  pkg: "Pak-Tong",
  pkh: "Pankhu",
  pkn: "Pakanha",
  pko: "Pkoot",
  pkp: "Pukapuka",
  pkr: "Attapady Kurumba",
  pks: "Pakistan Sign Language",
  pkt: "Maleng",
  pku: "Paku",
  pla: "Miani",
  plb: "Polonombauk",
  plc: "Central Palawano",
  pld: "Polari",
  ple: "Palu'e",
  plg: "Pilag",
  plh: "Paulohi",
  pli: "Pali",
  plj: "Polci",
  plk: "Kohistani Shina",
  pll: "Shwe Palaung",
  pln: "Palenquero",
  plo: "Oluta Popoluca",
  plp: "Palpa",
  plq: "Palaic",
  plr: "Palaka Senoufo",
  pls: "San Marcos Tlacoyalco Popoloca",
  plt: "Plateau Malagasy",
  plu: "Palikr",
  plv: "Southwest Palawano",
  plw: "Brooke's Point Palawano",
  ply: "Bolyu",
  plz: "Paluan",
  pma: "Paama",
  pmb: "Pambia",
  pmd: "Pallanganmiddang",
  pme: "Pwaamei",
  pmf: "Pamona",
  pmh: "Mhrri Prkrit",
  pmi: "Northern Pumi",
  pmj: "Southern Pumi",
  pmk: "Pamlico",
  pml: "Lingua Franca",
  pmm: "Pomo",
  pmn: "Pam",
  pmo: "Pom",
  pmq: "Northern Pame",
  pmr: "Paynamar",
  pms: "Piemontese",
  pmt: "Tuamotuan",
  pmw: "Plains Miwok",
  pmx: "Poumei Naga",
  pmy: "Papuan Malay",
  pmz: "Southern Pame",
  pna: "Punan Bah-Biau",
  pnb: "Western Panjabi",
  pnc: "Pannei",
  pne: "Western Penan",
  png: "Pongu",
  pnh: "Penrhyn",
  pni: "Aoheng",
  pnj: "Pinjarup",
  pnk: "Paunaka",
  pnl: "Paleni",
  pnm: "Punan Batu 1",
  pnn: "Pinai-Hagahai",
  pno: "Panobo",
  pnp: "Pancana",
  pnq: "Pana (Burkina Faso)",
  pnr: "Panim",
  pns: "Ponosakan",
  pnt: "Pontic",
  pnu: "Jiongnai Bunu",
  pnv: "Pinigura",
  pnw: "Panytyima",
  pnx: "Phong-Kniang",
  pny: "Pinyin",
  pnz: "Pana (Central African Republic)",
  poc: "Poqomam",
  poe: "San Juan Atzingo Popoloca",
  pof: "Poke",
  pog: "Potigura",
  poh: "Poqomchi'",
  poi: "Highland Popoluca",
  pok: "Pokang",
  pol: "Polish",
  pom: "Southeastern Pomo",
  pon: "Pohnpeian",
  poo: "Central Pomo",
  pop: "Pwapw",
  poq: "Texistepec Popoluca",
  por: "Portuguese",
  pos: "Sayula Popoluca",
  pot: "Potawatomi",
  pov: "Upper Guinea Crioulo",
  pow: "San Felipe Otlaltepec Popoloca",
  pox: "Polabian",
  poy: "Pogolo",
  ppe: "Papi",
  ppi: "Paipai",
  ppk: "Uma",
  ppl: "Pipil",
  ppm: "Papuma",
  ppn: "Papapana",
  ppo: "Folopa",
  ppp: "Pelende",
  ppq: "Pei",
  pps: "San Lus Temalacayuca Popoloca",
  ppt: "Pare",
  ppu: "Papora",
  pqa: "Pa'a",
  pqm: "Malecite-Passamaquoddy",
  prc: "Parachi",
  prd: "Parsi-Dari",
  pre: "Principense",
  prf: "Paranan",
  prg: "Prussian",
  prh: "Porohanon",
  pri: "Paic",
  prk: "Parauk",
  prl: "Peruvian Sign Language",
  prm: "Kibiri",
  prn: "Prasuni",
  pro: "Old Provenal (to 1500)",
  prp: "Parsi",
  prq: "Ashninka Peren",
  prr: "Puri",
  prs: "Dari",
  prt: "Phai",
  pru: "Puragi",
  prw: "Parawen",
  prx: "Purik",
  prz: "Providencia Sign Language",
  psa: "Asue Awyu",
  psc: "Persian Sign Language",
  psd: "Plains Indian Sign Language",
  pse: "Central Malay",
  psg: "Penang Sign Language",
  psh: "Southwest Pashai",
  psi: "Southeast Pashai",
  psl: "Puerto Rican Sign Language",
  psm: "Pauserna",
  psn: "Panasuan",
  pso: "Polish Sign Language",
  psp: "Philippine Sign Language",
  psq: "Pasi",
  psr: "Portuguese Sign Language",
  pss: "Kaulong",
  pst: "Central Pashto",
  psu: "Sauraseni Prkrit",
  psw: "Port Sandwich",
  psy: "Piscataway",
  pta: "Pai Tavytera",
  pth: "Patax H-Ha-He",
  pti: "Pintiini",
  ptn: "Patani",
  pto: "Zo'",
  ptp: "Patep",
  ptq: "Pattapu",
  ptr: "Piamatsina",
  ptt: "Enrekang",
  ptu: "Bambam",
  ptv: "Port Vato",
  ptw: "Pentlatch",
  pty: "Pathiya",
  pua: "Western Highland Purepecha",
  pub: "Purum",
  puc: "Punan Merap",
  pud: "Punan Aput",
  pue: "Puelche",
  puf: "Punan Merah",
  pug: "Phuie",
  pui: "Puinave",
  puj: "Punan Tubu",
  pum: "Puma",
  puo: "Puoc",
  pup: "Pulabu",
  puq: "Puquina",
  pur: "Purubor",
  pus: "Pushto",
  put: "Putoh",
  puu: "Punu",
  puw: "Puluwatese",
  pux: "Puare",
  puy: "Purisimeo",
  pwa: "Pawaia",
  pwb: "Panawa",
  pwg: "Gapapaiwa",
  pwi: "Patwin",
  pwm: "Molbog",
  pwn: "Paiwan",
  pwo: "Pwo Western Karen",
  pwr: "Powari",
  pww: "Pwo Northern Karen",
  pxm: "Quetzaltepec Mixe",
  pye: "Pye Krumen",
  pym: "Fyam",
  pyn: "Poyanwa",
  pys: "Paraguayan Sign Language",
  pyu: "Puyuma",
  pyx: "Pyu (Myanmar)",
  pyy: "Pyen",
  pzn: "Para Naga",
  qaa: "Original audio",
  qad: "Audio Description",
  qua: "Quapaw",
  qub: "Huallaga Hunuco Quechua",
  quc: "K'iche'",
  qud: "Caldern Highland Quichua",
  que: "Quechua",
  quf: "Lambayeque Quechua",
  qug: "Chimborazo Highland Quichua",
  quh: "South Bolivian Quechua",
  qui: "Quileute",
  quk: "Chachapoyas Quechua",
  qul: "North Bolivian Quechua",
  qum: "Sipacapense",
  qun: "Quinault",
  qup: "Southern Pastaza Quechua",
  quq: "Quinqui",
  qur: "Yanahuanca Pasco Quechua",
  qus: "Santiago del Estero Quichua",
  quv: "Sacapulteco",
  quw: "Tena Lowland Quichua",
  qux: "Yauyos Quechua",
  quy: "Ayacucho Quechua",
  quz: "Cusco Quechua",
  qva: "Ambo-Pasco Quechua",
  qvc: "Cajamarca Quechua",
  qve: "Eastern Apurmac Quechua",
  qvh: "Huamales-Dos de Mayo Hunuco Quechua",
  qvi: "Imbabura Highland Quichua",
  qvj: "Loja Highland Quichua",
  qvl: "Cajatambo North Lima Quechua",
  qvm: "Margos-Yarowilca-Lauricocha Quechua",
  qvn: "North Junn Quechua",
  qvo: "Napo Lowland Quechua",
  qvp: "Pacaraos Quechua",
  qvs: "San Martn Quechua",
  qvw: "Huaylla Wanca Quechua",
  qvy: "Queyu",
  qvz: "Northern Pastaza Quichua",
  qwa: "Corongo Ancash Quechua",
  qwc: "Classical Quechua",
  qwh: "Huaylas Ancash Quechua",
  qwm: "Kuman (Russia)",
  qws: "Sihuas Ancash Quechua",
  qwt: "Kwalhioqua-Tlatskanai",
  qxa: "Chiquin Ancash Quechua",
  qxc: "Chincha Quechua",
  qxh: "Panao Hunuco Quechua",
  qxl: "Salasaca Highland Quichua",
  qxn: "Northern Conchucos Ancash Quechua",
  qxo: "Southern Conchucos Ancash Quechua",
  qxp: "Puno Quechua",
  qxq: "Qashqa'i",
  qxr: "Caar Highland Quichua",
  qxs: "Southern Qiang",
  qxt: "Santa Ana de Tusi Pasco Quechua",
  qxu: "Arequipa-La Unin Quechua",
  qxw: "Jauja Wanca Quechua",
  qya: "Quenya",
  qyp: "Quiripi",
  raa: "Dungmali",
  rab: "Camling",
  rac: "Rasawa",
  rad: "Rade",
  raf: "Western Meohang",
  rag: "Logooli",
  rah: "Rabha",
  rai: "Ramoaaina",
  raj: "Rajasthani",
  rak: "Tulu-Bohuai",
  ral: "Ralte",
  ram: "Canela",
  ran: "Riantana",
  rao: "Rao",
  rap: "Rapanui",
  raq: "Saam",
  rar: "Rarotongan",
  ras: "Tegali",
  rat: "Razajerdi",
  rau: "Raute",
  rav: "Sampang",
  raw: "Rawang",
  rax: "Rang",
  ray: "Rapa",
  raz: "Rahambuu",
  rbb: "Rumai Palaung",
  rbk: "Northern Bontok",
  rbl: "Miraya Bikol",
  rbp: "Barababaraba",
  rcf: "Runion Creole French",
  rdb: "Rudbari",
  rea: "Rerau",
  reb: "Rembong",
  ree: "Rejang Kayan",
  reg: "Kara (Tanzania)",
  rei: "Reli",
  rej: "Rejang",
  rel: "Rendille",
  rem: "Remo",
  ren: "Rengao",
  rer: "Rer Bare",
  res: "Reshe",
  ret: "Retta",
  rey: "Reyesano",
  rga: "Roria",
  rge: "Romano-Greek",
  rgk: "Rangkas",
  rgn: "Romagnol",
  rgr: "Resgaro",
  rgs: "Southern Roglai",
  rgu: "Ringgou",
  rhg: "Rohingya",
  rhp: "Yahang",
  ria: "Riang (India)",
  rif: "Tarifit",
  ril: "Riang (Myanmar)",
  rim: "Nyaturu",
  rin: "Nungu",
  rir: "Ribun",
  rit: "Ritarungo",
  riu: "Riung",
  rjg: "Rajong",
  rji: "Raji",
  rjs: "Rajbanshi",
  rka: "Kraol",
  rkb: "Rikbaktsa",
  rkh: "Rakahanga-Manihiki",
  rki: "Rakhine",
  rkm: "Marka",
  rkt: "Rangpuri",
  rkw: "Arakwal",
  rma: "Rama",
  rmb: "Rembarunga",
  rmc: "Carpathian Romani",
  rmd: "Traveller Danish",
  rme: "Angloromani",
  rmf: "Kalo Finnish Romani",
  rmg: "Traveller Norwegian",
  rmh: "Murkim",
  rmi: "Lomavren",
  rmk: "Romkun",
  rml: "Baltic Romani",
  rmm: "Roma",
  rmn: "Balkan Romani",
  rmo: "Sinte Romani",
  rmp: "Rempi",
  rmq: "Cal",
  rms: "Romanian Sign Language",
  rmt: "Domari",
  rmu: "Tavringer Romani",
  rmv: "Romanova",
  rmw: "Welsh Romani",
  rmx: "Romam",
  rmy: "Vlax Romani",
  rmz: "Marma",
  rnd: "Ruund",
  rng: "Ronga",
  rnl: "Ranglong",
  rnn: "Roon",
  rnp: "Rongpo",
  rnr: "Nari Nari",
  rnw: "Rungwa",
  rob: "Tae'",
  roc: "Cacgia Roglai",
  rod: "Rogo",
  roe: "Ronji",
  rof: "Rombo",
  rog: "Northern Roglai",
  roh: "Romansh",
  rol: "Romblomanon",
  rom: "Romany",
  ron: "Romanian",
  roo: "Rotokas",
  rop: "Kriol",
  ror: "Rongga",
  rou: "Runga",
  row: "Dela-Oenale",
  rpn: "Repanbitip",
  rpt: "Rapting",
  rri: "Ririo",
  rro: "Waima",
  rrt: "Arritinngithigh",
  rsb: "Romano-Serbian",
  rsl: "Russian Sign Language",
  rsm: "Miriwoong Sign Language",
  rtc: "Rungtu Chin",
  rth: "Ratahan",
  rtm: "Rotuman",
  rts: "Yurats",
  rtw: "Rathawi",
  rub: "Gungu",
  ruc: "Ruuli",
  rue: "Rusyn",
  ruf: "Luguru",
  rug: "Roviana",
  ruh: "Ruga",
  rui: "Rufiji",
  ruk: "Che",
  run: "Rundi",
  ruo: "Istro Romanian",
  rup: "Macedo-Romanian",
  ruq: "Megleno Romanian",
  rus: "Russian",
  rut: "Rutul",
  ruu: "Lanas Lobu",
  ruy: "Mala (Nigeria)",
  ruz: "Ruma",
  rwa: "Rawo",
  rwk: "Rwa",
  rwm: "Amba (Uganda)",
  rwo: "Rawa",
  rwr: "Marwari (India)",
  rxd: "Ngardi",
  rxw: "Karuwali",
  ryn: "Northern Amami-Oshima",
  rys: "Yaeyama",
  ryu: "Central Okinawan",
  rzh: "Rzi",
  saa: "Saba",
  sab: "Buglere",
  sac: "Meskwaki",
  sad: "Sandawe",
  sae: "Saban",
  saf: "Safaliba",
  sag: "Sango",
  sah: "Yakut",
  saj: "Sahu",
  sak: "Sake",
  sam: "Samaritan Aramaic",
  san: "Sanskrit",
  sao: "Sause",
  saq: "Samburu",
  sar: "Saraveca",
  sas: "Sasak",
  sat: "Santali",
  sau: "Saleman",
  sav: "Saafi-Saafi",
  saw: "Sawi",
  sax: "Sa",
  say: "Saya",
  saz: "Saurashtra",
  sba: "Ngambay",
  sbb: "Simbo",
  sbc: "Kele (Papua New Guinea)",
  sbd: "Southern Samo",
  sbe: "Saliba",
  sbf: "Chabu",
  sbg: "Seget",
  sbh: "Sori-Harengan",
  sbi: "Seti",
  sbj: "Surbakhal",
  sbk: "Safwa",
  sbl: "Botolan Sambal",
  sbm: "Sagala",
  sbn: "Sindhi Bhil",
  sbo: "Sabm",
  sbp: "Sangu (Tanzania)",
  sbq: "Sileibi",
  sbr: "Sembakung Murut",
  sbs: "Subiya",
  sbt: "Kimki",
  sbu: "Stod Bhoti",
  sbv: "Sabine",
  sbw: "Simba",
  sbx: "Seberuang",
  sby: "Soli",
  sbz: "Sara Kaba",
  scb: "Chut",
  sce: "Dongxiang",
  scf: "San Miguel Creole French",
  scg: "Sanggau",
  sch: "Sakachep",
  sci: "Sri Lankan Creole Malay",
  sck: "Sadri",
  scl: "Shina",
  scn: "Sicilian",
  sco: "Scots",
  scp: "Helambu Sherpa",
  scq: "Sa'och",
  scs: "North Slavey",
  sct: "Southern Katang",
  scu: "Shumcho",
  scv: "Sheni",
  scw: "Sha",
  scx: "Sicel",
  sda: "Toraja-Sa'dan",
  sdb: "Shabak",
  sdc: "Sassarese Sardinian",
  sde: "Surubu",
  sdf: "Sarli",
  sdg: "Savi",
  sdh: "Southern Kurdish",
  sdj: "Suundi",
  sdk: "Sos Kundi",
  sdl: "Saudi Arabian Sign Language",
  sdm: "Semandang",
  sdn: "Gallurese Sardinian",
  sdo: "Bukar-Sadung Bidayuh",
  sdp: "Sherdukpen",
  sdr: "Oraon Sadri",
  sds: "Sened",
  sdt: "Shuadit",
  sdu: "Sarudu",
  sdx: "Sibu Melanau",
  sdz: "Sallands",
  sea: "Semai",
  seb: "Shempire Senoufo",
  sec: "Sechelt",
  sed: "Sedang",
  see: "Seneca",
  sef: "Cebaara Senoufo",
  seg: "Segeju",
  seh: "Sena",
  sei: "Seri",
  sej: "Sene",
  sek: "Sekani",
  sel: "Selkup",
  sen: "Nanerig Snoufo",
  seo: "Suarmin",
  sep: "Sct Snoufo",
  seq: "Senara Snoufo",
  ser: "Serrano",
  ses: "Koyraboro Senni Songhai",
  set: "Sentani",
  seu: "Serui-Laut",
  sev: "Nyarafolo Senoufo",
  sew: "Sewa Bay",
  sey: "Secoya",
  sez: "Senthang Chin",
  sfb: "Langue des signes de Belgique Francophone",
  sfe: "Eastern Subanen",
  sfm: "Small Flowery Miao",
  sfs: "South African Sign Language",
  sfw: "Sehwi",
  sga: "Old Irish (to 900)",
  sgb: "Mag-antsi Ayta",
  sgc: "Kipsigis",
  sgd: "Surigaonon",
  sge: "Segai",
  sgg: "Swiss-German Sign Language",
  sgh: "Shughni",
  sgi: "Suga",
  sgj: "Surgujia",
  sgk: "Sangkong",
  sgm: "Singa",
  sgp: "Singpho",
  sgr: "Sangisari",
  sgs: "Samogitian",
  sgt: "Brokpake",
  sgu: "Salas",
  sgw: "Sebat Bet Gurage",
  sgx: "Sierra Leone Sign Language",
  sgy: "Sanglechi",
  sgz: "Sursurunga",
  sha: "Shall-Zwall",
  shb: "Ninam",
  shc: "Sonde",
  shd: "Kundal Shahi",
  she: "Sheko",
  shg: "Shua",
  shh: "Shoshoni",
  shi: "Tachelhit",
  shj: "Shatt",
  shk: "Shilluk",
  shl: "Shendu",
  shm: "Shahrudi",
  shn: "Shan",
  sho: "Shanga",
  shp: "Shipibo-Conibo",
  shq: "Sala",
  shr: "Shi",
  shs: "Shuswap",
  sht: "Shasta",
  shu: "Chadian Arabic",
  shv: "Shehri",
  shw: "Shwai",
  shx: "She",
  shy: "Tachawit",
  shz: "Syenara Senoufo",
  sia: "Akkala Sami",
  sib: "Sebop",
  sid: "Sidamo",
  sie: "Simaa",
  sif: "Siamou",
  sig: "Paasaal",
  sih: "Zire",
  sii: "Shom Peng",
  sij: "Numbami",
  sik: "Sikiana",
  sil: "Tumulung Sisaala",
  sim: "Mende (Papua New Guinea)",
  sin: "Sinhala",
  sip: "Sikkimese",
  siq: "Sonia",
  sir: "Siri",
  sis: "Siuslaw",
  siu: "Sinagen",
  siv: "Sumariup",
  siw: "Siwai",
  six: "Sumau",
  siy: "Sivandi",
  siz: "Siwi",
  sja: "Epena",
  sjb: "Sajau Basap",
  sjd: "Kildin Sami",
  sje: "Pite Sami",
  sjg: "Assangori",
  sjk: "Kemi Sami",
  sjl: "Sajalong",
  sjm: "Mapun",
  sjn: "Sindarin",
  sjo: "Xibe",
  sjp: "Surjapuri",
  sjr: "Siar-Lak",
  sjs: "Senhaja De Srair",
  sjt: "Ter Sami",
  sju: "Ume Sami",
  sjw: "Shawnee",
  ska: "Skagit",
  skb: "Saek",
  skc: "Ma Manda",
  skd: "Southern Sierra Miwok",
  ske: "Seke (Vanuatu)",
  skf: "Sakirabi",
  skg: "Sakalava Malagasy",
  skh: "Sikule",
  ski: "Sika",
  skj: "Seke (Nepal)",
  skm: "Kutong",
  skn: "Kolibugan Subanon",
  sko: "Seko Tengah",
  skp: "Sekapan",
  skq: "Sininkere",
  skr: "Saraiki",
  sks: "Maia",
  skt: "Sakata",
  sku: "Sakao",
  skv: "Skou",
  skw: "Skepi Creole Dutch",
  skx: "Seko Padang",
  sky: "Sikaiana",
  skz: "Sekar",
  slc: "Sliba",
  sld: "Sissala",
  sle: "Sholaga",
  slf: "Swiss-Italian Sign Language",
  slg: "Selungai Murut",
  slh: "Southern Puget Sound Salish",
  sli: "Lower Silesian",
  slj: "Salum",
  slk: "Slovak",
  sll: "Salt-Yui",
  slm: "Pangutaran Sama",
  sln: "Salinan",
  slp: "Lamaholot",
  slq: "Salchuq",
  slr: "Salar",
  sls: "Singapore Sign Language",
  slt: "Sila",
  slu: "Selaru",
  slv: "Slovenian",
  slw: "Sialum",
  slx: "Salampasu",
  sly: "Selayar",
  slz: "Ma'ya",
  sma: "Southern Sami",
  smb: "Simbari",
  smc: "Som",
  smd: "Sama",
  sme: "Northern Sami",
  smf: "Auwe",
  smg: "Simbali",
  smh: "Samei",
  smj: "Lule Sami",
  smk: "Bolinao",
  sml: "Central Sama",
  smm: "Musasa",
  smn: "Inari Sami",
  smo: "Samoan",
  smp: "Samaritan",
  smq: "Samo",
  smr: "Simeulue",
  sms: "Skolt Sami",
  smt: "Simte",
  smu: "Somray",
  smv: "Samvedi",
  smw: "Sumbawa",
  smx: "Samba",
  smy: "Semnani",
  smz: "Simeku",
  sna: "Shona",
  snb: "Sebuyau",
  snc: "Sinaugoro",
  snd: "Sindhi",
  sne: "Bau Bidayuh",
  snf: "Noon",
  sng: "Sanga (Democratic Republic of Congo)",
  sni: "Sensi",
  snj: "Riverain Sango",
  snk: "Soninke",
  snl: "Sangil",
  snm: "Southern Ma'di",
  snn: "Siona",
  sno: "Snohomish",
  snp: "Siane",
  snq: "Sangu (Gabon)",
  snr: "Sihan",
  sns: "South West Bay",
  snu: "Senggi",
  snv: "Sa'ban",
  snw: "Selee",
  snx: "Sam",
  sny: "Saniyo-Hiyewe",
  snz: "Sinsauru",
  soa: "Thai Song",
  sob: "Sobei",
  soc: "So (Democratic Republic of Congo)",
  sod: "Songoora",
  soe: "Songomeno",
  sog: "Sogdian",
  soh: "Aka",
  soi: "Sonha",
  soj: "Soi",
  sok: "Sokoro",
  sol: "Solos",
  som: "Somali",
  soo: "Songo",
  sop: "Songe",
  soq: "Kanasi",
  sor: "Somrai",
  sos: "Seeku",
  sot: "Southern Sotho",
  sou: "Southern Thai",
  sov: "Sonsorol",
  sow: "Sowanda",
  sox: "Swo",
  soy: "Miyobe",
  soz: "Temi",
  spa: "Spanish",
  spb: "Sepa (Indonesia)",
  spc: "Sap",
  spd: "Saep",
  spe: "Sepa (Papua New Guinea)",
  spg: "Sian",
  spi: "Saponi",
  spk: "Sengo",
  spl: "Selepet",
  spm: "Akukem",
  spn: "Sanapan",
  spo: "Spokane",
  spp: "Supyire Senoufo",
  spq: "Loreto-Ucayali Spanish",
  spr: "Saparua",
  sps: "Saposa",
  spt: "Spiti Bhoti",
  spu: "Sapuan",
  spv: "Sambalpuri",
  spx: "South Picene",
  spy: "Sabaot",
  sqa: "Shama-Sambuga",
  sqh: "Shau",
  sqi: "Albanian",
  sqk: "Albanian Sign Language",
  sqm: "Suma",
  sqn: "Susquehannock",
  sqo: "Sorkhei",
  sqq: "Sou",
  sqr: "Siculo Arabic",
  sqs: "Sri Lankan Sign Language",
  sqt: "Soqotri",
  squ: "Squamish",
  sra: "Saruga",
  srb: "Sora",
  src: "Logudorese Sardinian",
  srd: "Sardinian",
  sre: "Sara",
  srf: "Nafi",
  srg: "Sulod",
  srh: "Sarikoli",
  sri: "Siriano",
  srk: "Serudung Murut",
  srl: "Isirawa",
  srm: "Saramaccan",
  srn: "Sranan Tongo",
  sro: "Campidanese Sardinian",
  srp: "Serbian",
  srq: "Sirion",
  srr: "Serer",
  srs: "Sarsi",
  srt: "Sauri",
  sru: "Suru",
  srv: "Southern Sorsoganon",
  srw: "Serua",
  srx: "Sirmauri",
  sry: "Sera",
  srz: "Shahmirzadi",
  ssb: "Southern Sama",
  ssc: "Suba-Simbiti",
  ssd: "Siroi",
  sse: "Balangingi",
  ssf: "Thao",
  ssg: "Seimat",
  ssh: "Shihhi Arabic",
  ssi: "Sansi",
  ssj: "Sausi",
  ssk: "Sunam",
  ssl: "Western Sisaala",
  ssm: "Semnam",
  ssn: "Waata",
  sso: "Sissano",
  ssp: "Spanish Sign Language",
  ssq: "So'a",
  ssr: "Swiss-French Sign Language",
  sss: "S",
  sst: "Sinasina",
  ssu: "Susuami",
  ssv: "Shark Bay",
  ssw: "Swati",
  ssx: "Samberigi",
  ssy: "Saho",
  ssz: "Sengseng",
  sta: "Settla",
  stb: "Northern Subanen",
  std: "Sentinel",
  ste: "Liana-Seti",
  stf: "Seta",
  stg: "Trieng",
  sth: "Shelta",
  sti: "Bulo Stieng",
  stj: "Matya Samo",
  stk: "Arammba",
  stl: "Stellingwerfs",
  stm: "Setaman",
  stn: "Owa",
  sto: "Stoney",
  stp: "Southeastern Tepehuan",
  stq: "Saterfriesisch",
  str: "Straits Salish",
  sts: "Shumashti",
  stt: "Budeh Stieng",
  stu: "Samtao",
  stv: "Silt'e",
  stw: "Satawalese",
  sty: "Siberian Tatar",
  sua: "Sulka",
  sub: "Suku",
  suc: "Western Subanon",
  sue: "Suena",
  sug: "Suganga",
  sui: "Suki",
  suj: "Shubi",
  suk: "Sukuma",
  sun: "Sundanese",
  suq: "Suri",
  sur: "Mwaghavul",
  sus: "Susu",
  sut: "Subtiaba",
  suv: "Puroik",
  suw: "Sumbwa",
  sux: "Sumerian",
  suy: "Suy",
  suz: "Sunwar",
  sva: "Svan",
  svb: "Ulau-Suain",
  svc: "Vincentian Creole English",
  sve: "Serili",
  svk: "Slovakian Sign Language",
  svm: "Slavomolisano",
  svs: "Savosavo",
  svx: "Skalvian",
  swa: "Swahili (macrolanguage)",
  swb: "Maore Comorian",
  swc: "Congo Swahili",
  swe: "Swedish",
  swf: "Sere",
  swg: "Swabian",
  swh: "Swahili (individual language)",
  swi: "Sui",
  swj: "Sira",
  swk: "Malawi Sena",
  swl: "Swedish Sign Language",
  swm: "Samosa",
  swn: "Sawknah",
  swo: "Shanenawa",
  swp: "Suau",
  swq: "Sharwa",
  swr: "Saweru",
  sws: "Seluwasan",
  swt: "Sawila",
  swu: "Suwawa",
  swv: "Shekhawati",
  sww: "Sowa",
  swx: "Suruah",
  swy: "Sarua",
  sxb: "Suba",
  sxc: "Sicanian",
  sxe: "Sighu",
  sxg: "Shixing",
  sxk: "Southern Kalapuya",
  sxl: "Selian",
  sxm: "Samre",
  sxn: "Sangir",
  sxo: "Sorothaptic",
  sxr: "Saaroa",
  sxs: "Sasaru",
  sxu: "Upper Saxon",
  sxw: "Saxwe Gbe",
  sya: "Siang",
  syb: "Central Subanen",
  syc: "Classical Syriac",
  syi: "Seki",
  syk: "Sukur",
  syl: "Sylheti",
  sym: "Maya Samo",
  syn: "Senaya",
  syo: "Suoy",
  syr: "Syriac",
  sys: "Sinyar",
  syw: "Kagate",
  syx: "Samay",
  syy: "Al-Sayyid Bedouin Sign Language",
  sza: "Semelai",
  szb: "Ngalum",
  szc: "Semaq Beri",
  szd: "Seru",
  sze: "Seze",
  szg: "Sengele",
  szl: "Silesian",
  szn: "Sula",
  szp: "Suabo",
  szs: "Solomon Islands Sign Language",
  szv: "Isu (Fako Division)",
  szw: "Sawai",
  taa: "Lower Tanana",
  tab: "Tabassaran",
  tac: "Lowland Tarahumara",
  tad: "Tause",
  tae: "Tariana",
  taf: "Tapirap",
  tag: "Tagoi",
  tah: "Tahitian",
  taj: "Eastern Tamang",
  tak: "Tala",
  tal: "Tal",
  tam: "Tamil",
  tan: "Tangale",
  tao: "Yami",
  tap: "Taabwa",
  taq: "Tamasheq",
  tar: "Central Tarahumara",
  tas: "Tay Boi",
  tat: "Tatar",
  tau: "Upper Tanana",
  tav: "Tatuyo",
  taw: "Tai",
  tax: "Tamki",
  tay: "Atayal",
  taz: "Tocho",
  tba: "Aikan",
  tbb: "Tapeba",
  tbc: "Takia",
  tbd: "Kaki Ae",
  tbe: "Tanimbili",
  tbf: "Mandara",
  tbg: "North Tairora",
  tbh: "Thurawal",
  tbi: "Gaam",
  tbj: "Tiang",
  tbk: "Calamian Tagbanwa",
  tbl: "Tboli",
  tbm: "Tagbu",
  tbn: "Barro Negro Tunebo",
  tbo: "Tawala",
  tbp: "Taworta",
  tbr: "Tumtum",
  tbs: "Tanguat",
  tbt: "Tembo (Kitembo)",
  tbu: "Tubar",
  tbv: "Tobo",
  tbw: "Tagbanwa",
  tbx: "Kapin",
  tby: "Tabaru",
  tbz: "Ditammari",
  tca: "Ticuna",
  tcb: "Tanacross",
  tcc: "Datooga",
  tcd: "Tafi",
  tce: "Southern Tutchone",
  tcf: "Malinaltepec Me'phaa",
  tcg: "Tamagario",
  tch: "Turks And Caicos Creole English",
  tci: "Wra",
  tck: "Tchitchege",
  tcl: "Taman (Myanmar)",
  tcm: "Tanahmerah",
  tcn: "Tichurong",
  tco: "Taungyo",
  tcp: "Tawr Chin",
  tcq: "Kaiy",
  tcs: "Torres Strait Creole",
  tct: "T'en",
  tcu: "Southeastern Tarahumara",
  tcw: "Tecpatln Totonac",
  tcx: "Toda",
  tcy: "Tulu",
  tcz: "Thado Chin",
  tda: "Tagdal",
  tdb: "Panchpargania",
  tdc: "Ember-Tad",
  tdd: "Tai Na",
  tde: "Tiranige Diga Dogon",
  tdf: "Talieng",
  tdg: "Western Tamang",
  tdh: "Thulung",
  tdi: "Tomadino",
  tdj: "Tajio",
  tdk: "Tambas",
  tdl: "Sur",
  tdm: "Taruma",
  tdn: "Tondano",
  tdo: "Teme",
  tdq: "Tita",
  tdr: "Todrah",
  tds: "Doutai",
  tdt: "Tetun Dili",
  tdv: "Toro",
  tdx: "Tandroy-Mahafaly Malagasy",
  tdy: "Tadyawan",
  tea: "Temiar",
  teb: "Tetete",
  tec: "Terik",
  ted: "Tepo Krumen",
  tee: "Huehuetla Tepehua",
  tef: "Teressa",
  teg: "Teke-Tege",
  teh: "Tehuelche",
  tei: "Torricelli",
  tek: "Ibali Teke",
  tel: "Telugu",
  tem: "Timne",
  ten: "Tama (Colombia)",
  teo: "Teso",
  tep: "Tepecano",
  teq: "Temein",
  ter: "Tereno",
  tes: "Tengger",
  tet: "Tetum",
  teu: "Soo",
  tev: "Teor",
  tew: "Tewa (USA)",
  tex: "Tennet",
  tey: "Tulishi",
  tfi: "Tofin Gbe",
  tfn: "Tanaina",
  tfo: "Tefaro",
  tfr: "Teribe",
  tft: "Ternate",
  tga: "Sagalla",
  tgb: "Tobilung",
  tgc: "Tigak",
  tgd: "Ciwogai",
  tge: "Eastern Gorkha Tamang",
  tgf: "Chalikha",
  tgh: "Tobagonian Creole English",
  tgi: "Lawunuia",
  tgj: "Tagin",
  tgk: "Tajik",
  tgl: "Tagalog",
  tgn: "Tandaganon",
  tgo: "Sudest",
  tgp: "Tangoa",
  tgq: "Tring",
  tgr: "Tareng",
  tgs: "Nume",
  tgt: "Central Tagbanwa",
  tgu: "Tanggu",
  tgv: "Tingui-Boto",
  tgw: "Tagwana Senoufo",
  tgx: "Tagish",
  tgy: "Togoyo",
  tgz: "Tagalaka",
  tha: "Thai",
  thd: "Thayore",
  the: "Chitwania Tharu",
  thf: "Thangmi",
  thh: "Northern Tarahumara",
  thi: "Tai Long",
  thk: "Tharaka",
  thl: "Dangaura Tharu",
  thm: "Aheu",
  thn: "Thachanadan",
  thp: "Thompson",
  thq: "Kochila Tharu",
  thr: "Rana Tharu",
  ths: "Thakali",
  tht: "Tahltan",
  thu: "Thuri",
  thv: "Tahaggart Tamahaq",
  thw: "Thudam",
  thy: "Tha",
  thz: "Tayart Tamajeq",
  tia: "Tidikelt Tamazight",
  tic: "Tira",
  tif: "Tifal",
  tig: "Tigre",
  tih: "Timugon Murut",
  tii: "Tiene",
  tij: "Tilung",
  tik: "Tikar",
  til: "Tillamook",
  tim: "Timbe",
  tin: "Tindi",
  tio: "Teop",
  tip: "Trimuris",
  tiq: "Tifo",
  tir: "Tigrinya",
  tis: "Masadiit Itneg",
  tit: "Tinigua",
  tiu: "Adasen",
  tiv: "Tiv",
  tiw: "Tiwi",
  tix: "Southern Tiwa",
  tiy: "Tiruray",
  tiz: "Tai Hongjin",
  tja: "Tajuasohn",
  tjg: "Tunjung",
  tji: "Northern Tujia",
  tjl: "Tai Laing",
  tjm: "Timucua",
  tjn: "Tonjon",
  tjo: "Temacine Tamazight",
  tjs: "Southern Tujia",
  tju: "Tjurruru",
  tjw: "Djabwurrung",
  tka: "Truk",
  tkb: "Buksa",
  tkd: "Tukudede",
  tke: "Takwane",
  tkf: "Tukumanfd",
  tkg: "Tesaka Malagasy",
  tkl: "Tokelau",
  tkm: "Takelma",
  tkn: "Toku-No-Shima",
  tkp: "Tikopia",
  tkq: "Tee",
  tkr: "Tsakhur",
  tks: "Takestani",
  tkt: "Kathoriya Tharu",
  tku: "Upper Necaxa Totonac",
  tkv: "Mur Pano",
  tkw: "Teanu",
  tkx: "Tangko",
  tkz: "Takua",
  tla: "Southwestern Tepehuan",
  tlb: "Tobelo",
  tlc: "Yecuatla Totonac",
  tld: "Talaud",
  tlf: "Telefol",
  tlg: "Tofanma",
  tlh: "Klingon",
  tli: "Tlingit",
  tlj: "Talinga-Bwisi",
  tlk: "Taloki",
  tll: "Tetela",
  tlm: "Tolomako",
  tln: "Talondo'",
  tlo: "Talodi",
  tlp: "Filomena Mata-Coahuitln Totonac",
  tlq: "Tai Loi",
  tlr: "Talise",
  tls: "Tambotalo",
  tlt: "Sou Nama",
  tlu: "Tulehu",
  tlv: "Taliabu",
  tlx: "Khehek",
  tly: "Talysh",
  tma: "Tama (Chad)",
  tmb: "Katbol",
  tmc: "Tumak",
  tmd: "Haruai",
  tme: "Trememb",
  tmf: "Toba-Maskoy",
  tmg: "Ternateo",
  tmh: "Tamashek",
  tmi: "Tutuba",
  tmj: "Samarokena",
  tmk: "Northwestern Tamang",
  tml: "Tamnim Citak",
  tmm: "Tai Thanh",
  tmn: "Taman (Indonesia)",
  tmo: "Temoq",
  tmq: "Tumleo",
  tmr: "Jewish Babylonian Aramaic (ca. 200-1200 CE)",
  tms: "Tima",
  tmt: "Tasmate",
  tmu: "Iau",
  tmv: "Tembo (Motembo)",
  tmw: "Temuan",
  tmy: "Tami",
  tmz: "Tamanaku",
  tna: "Tacana",
  tnb: "Western Tunebo",
  tnc: "Tanimuca-Retuar",
  tnd: "Angosturas Tunebo",
  tng: "Tobanga",
  tnh: "Maiani",
  tni: "Tandia",
  tnk: "Kwamera",
  tnl: "Lenakel",
  tnm: "Tabla",
  tnn: "North Tanna",
  tno: "Toromono",
  tnp: "Whitesands",
  tnq: "Taino",
  tnr: "Mnik",
  tns: "Tenis",
  tnt: "Tontemboan",
  tnu: "Tay Khang",
  tnv: "Tangchangya",
  tnw: "Tonsawang",
  tnx: "Tanema",
  tny: "Tongwe",
  tnz: "Ten'edn",
  tob: "Toba",
  toc: "Coyutla Totonac",
  tod: "Toma",
  tof: "Gizrra",
  tog: "Tonga (Nyasa)",
  toh: "Gitonga",
  toi: "Tonga (Zambia)",
  toj: "Tojolabal",
  tol: "Tolowa",
  tom: "Tombulu",
  ton: "Tonga (Tonga Islands)",
  too: "Xicotepec De Jurez Totonac",
  top: "Papantla Totonac",
  toq: "Toposa",
  tor: "Togbo-Vara Banda",
  tos: "Highland Totonac",
  tou: "Tho",
  tov: "Upper Taromi",
  tow: "Jemez",
  tox: "Tobian",
  toy: "Topoiyo",
  toz: "To",
  tpa: "Taupota",
  tpc: "Azoy Me'phaa",
  tpe: "Tippera",
  tpf: "Tarpia",
  tpg: "Kula",
  tpi: "Tok Pisin",
  tpj: "Tapiet",
  tpk: "Tupinikin",
  tpl: "Tlacoapa Me'phaa",
  tpm: "Tampulma",
  tpn: "Tupinamb",
  tpo: "Tai Pao",
  tpp: "Pisaflores Tepehua",
  tpq: "Tukpa",
  tpr: "Tupar",
  tpt: "Tlachichilco Tepehua",
  tpu: "Tampuan",
  tpv: "Tanapag",
  tpw: "Tup",
  tpx: "Acatepec Me'phaa",
  tpy: "Trumai",
  tpz: "Tinputz",
  tqb: "Temb",
  tql: "Lehali",
  tqm: "Turumsa",
  tqn: "Tenino",
  tqo: "Toaripi",
  tqp: "Tomoip",
  tqq: "Tunni",
  tqr: "Torona",
  tqt: "Western Totonac",
  tqu: "Touo",
  tqw: "Tonkawa",
  tra: "Tirahi",
  trb: "Terebu",
  trc: "Copala Triqui",
  trd: "Turi",
  tre: "East Tarangan",
  trf: "Trinidadian Creole English",
  trg: "Lishn Didn",
  trh: "Turaka",
  tri: "Tri",
  trj: "Toram",
  trl: "Traveller Scottish",
  trm: "Tregami",
  trn: "Trinitario",
  tro: "Tarao Naga",
  trp: "Kok Borok",
  trq: "San Martn Itunyoso Triqui",
  trr: "Taushiro",
  trs: "Chicahuaxtla Triqui",
  trt: "Tunggare",
  tru: "Turoyo",
  trv: "Taroko",
  trw: "Torwali",
  trx: "Tringgus-Sembaan Bidayuh",
  "try": "Turung",
  trz: "Tor",
  tsa: "Tsaangi",
  tsb: "Tsamai",
  tsc: "Tswa",
  tsd: "Tsakonian",
  tse: "Tunisian Sign Language",
  tsg: "Tausug",
  tsh: "Tsuvan",
  tsi: "Tsimshian",
  tsj: "Tshangla",
  tsk: "Tseku",
  tsl: "Ts'n-Lao",
  tsm: "Turkish Sign Language",
  tsn: "Tswana",
  tso: "Tsonga",
  tsp: "Northern Toussian",
  tsq: "Thai Sign Language",
  tsr: "Akei",
  tss: "Taiwan Sign Language",
  tst: "Tondi Songway Kiini",
  tsu: "Tsou",
  tsv: "Tsogo",
  tsw: "Tsishingini",
  tsx: "Mubami",
  tsy: "Tebul Sign Language",
  tsz: "Purepecha",
  tta: "Tutelo",
  ttb: "Gaa",
  ttc: "Tektiteko",
  ttd: "Tauade",
  tte: "Bwanabwana",
  ttf: "Tuotomb",
  ttg: "Tutong",
  tth: "Upper Ta'oih",
  tti: "Tobati",
  ttj: "Tooro",
  ttk: "Totoro",
  ttl: "Totela",
  ttm: "Northern Tutchone",
  ttn: "Towei",
  tto: "Lower Ta'oih",
  ttp: "Tombelala",
  ttq: "Tawallammat Tamajaq",
  ttr: "Tera",
  tts: "Northeastern Thai",
  ttt: "Muslim Tat",
  ttu: "Torau",
  ttv: "Titan",
  ttw: "Long Wat",
  tty: "Sikaritai",
  ttz: "Tsum",
  tua: "Wiarumus",
  tub: "Tbatulabal",
  tuc: "Mutu",
  tud: "Tux",
  tue: "Tuyuca",
  tuf: "Central Tunebo",
  tug: "Tunia",
  tuh: "Taulil",
  tui: "Tupuri",
  tuj: "Tugutil",
  tuk: "Turkmen",
  tul: "Tula",
  tum: "Tumbuka",
  tun: "Tunica",
  tuo: "Tucano",
  tuq: "Tedaga",
  tur: "Turkish",
  tus: "Tuscarora",
  tuu: "Tututni",
  tuv: "Turkana",
  tux: "Tuxinwa",
  tuy: "Tugen",
  tuz: "Turka",
  tva: "Vaghua",
  tvd: "Tsuvadi",
  tve: "Te'un",
  tvk: "Southeast Ambrym",
  tvl: "Tuvalu",
  tvm: "Tela-Masbuar",
  tvn: "Tavoyan",
  tvo: "Tidore",
  tvs: "Taveta",
  tvt: "Tutsa Naga",
  tvu: "Tunen",
  tvw: "Sedoa",
  tvy: "Timor Pidgin",
  twa: "Twana",
  twb: "Western Tawbuid",
  twc: "Teshenawa",
  twd: "Twents",
  twe: "Tewa (Indonesia)",
  twf: "Northern Tiwa",
  twg: "Tereweng",
  twh: "Tai Dn",
  twi: "Twi",
  twl: "Tawara",
  twm: "Tawang Monpa",
  twn: "Twendi",
  two: "Tswapong",
  twp: "Ere",
  twq: "Tasawaq",
  twr: "Southwestern Tarahumara",
  twt: "Turiwra",
  twu: "Termanu",
  tww: "Tuwari",
  twx: "Tewe",
  twy: "Tawoyan",
  txa: "Tombonuo",
  txb: "Tokharian B",
  txc: "Tsetsaut",
  txe: "Totoli",
  txg: "Tangut",
  txh: "Thracian",
  txi: "Ikpeng",
  txj: "Tarjumo",
  txm: "Tomini",
  txn: "West Tarangan",
  txo: "Toto",
  txq: "Tii",
  txr: "Tartessian",
  txs: "Tonsea",
  txt: "Citak",
  txu: "Kayap",
  txx: "Tatana",
  txy: "Tanosy Malagasy",
  tya: "Tauya",
  tye: "Kyanga",
  tyh: "O'du",
  tyi: "Teke-Tsaayi",
  tyj: "Tai Do",
  tyl: "Thu Lao",
  tyn: "Kombai",
  typ: "Thaypan",
  tyr: "Tai Daeng",
  tys: "Ty Sa Pa",
  tyt: "Ty Tac",
  tyu: "Kua",
  tyv: "Tuvinian",
  tyx: "Teke-Tyee",
  tyz: "Ty",
  tza: "Tanzanian Sign Language",
  tzh: "Tzeltal",
  tzj: "Tz'utujil",
  tzl: "Talossan",
  tzm: "Central Atlas Tamazight",
  tzn: "Tugun",
  tzo: "Tzotzil",
  tzx: "Tabriak",
  uam: "Uamu",
  uan: "Kuan",
  uar: "Tairuma",
  uba: "Ubang",
  ubi: "Ubi",
  ubl: "Buhi'non Bikol",
  ubr: "Ubir",
  ubu: "Umbu-Ungu",
  uby: "Ubykh",
  uda: "Uda",
  ude: "Udihe",
  udg: "Muduga",
  udi: "Udi",
  udj: "Ujir",
  udl: "Wuzlam",
  udm: "Udmurt",
  udu: "Uduk",
  ues: "Kioko",
  ufi: "Ufim",
  uga: "Ugaritic",
  ugb: "Kuku-Ugbanh",
  uge: "Ughele",
  ugn: "Ugandan Sign Language",
  ugo: "Ugong",
  ugy: "Uruguayan Sign Language",
  uha: "Uhami",
  uhn: "Damal",
  uig: "Uighur",
  uis: "Uisai",
  uiv: "Iyive",
  uji: "Tanjijili",
  uka: "Kaburi",
  ukg: "Ukuriguma",
  ukh: "Ukhwejo",
  ukk: "Muak Sa-aak",
  ukl: "Ukrainian Sign Language",
  ukp: "Ukpe-Bayobiri",
  ukq: "Ukwa",
  ukr: "Ukrainian",
  uks: "Urub-Kaapor Sign Language",
  uku: "Ukue",
  ukw: "Ukwuani-Aboh-Ndoni",
  uky: "Kuuk-Yak",
  ula: "Fungwa",
  ulb: "Ulukwumi",
  ulc: "Ulch",
  ule: "Lule",
  ulf: "Usku",
  uli: "Ulithian",
  ulk: "Meriam",
  ull: "Ullatan",
  ulm: "Ulumanda'",
  uln: "Unserdeutsch",
  ulu: "Uma' Lung",
  ulw: "Ulwa",
  uma: "Umatilla",
  umb: "Umbundu",
  umc: "Marrucinian",
  umd: "Umbindhamu",
  umg: "Umbuygamu",
  umi: "Ukit",
  umm: "Umon",
  umn: "Makyan Naga",
  umo: "Umotna",
  ump: "Umpila",
  umr: "Umbugarla",
  ums: "Pendau",
  umu: "Munsee",
  una: "North Watut",
  und: "Undetermined",
  une: "Uneme",
  ung: "Ngarinyin",
  unk: "Enawen-Naw",
  unm: "Unami",
  unn: "Kurnai",
  unr: "Mundari",
  unu: "Unubahe",
  unx: "Munda",
  unz: "Unde Kaili",
  upi: "Umeda",
  upv: "Uripiv-Wala-Rano-Atchin",
  ura: "Urarina",
  urb: "Urub-Kaapor",
  urc: "Urningangg",
  urd: "Urdu",
  ure: "Uru",
  urf: "Uradhi",
  urg: "Urigina",
  urh: "Urhobo",
  uri: "Urim",
  urk: "Urak Lawoi'",
  url: "Urali",
  urm: "Urapmin",
  urn: "Uruangnirin",
  uro: "Ura (Papua New Guinea)",
  urp: "Uru-Pa-In",
  urr: "Lehalurup",
  urt: "Urat",
  uru: "Urumi",
  urv: "Uruava",
  urw: "Sop",
  urx: "Urimo",
  ury: "Orya",
  urz: "Uru-Eu-Wau-Wau",
  usa: "Usarufa",
  ush: "Ushojo",
  usi: "Usui",
  usk: "Usaghade",
  usp: "Uspanteco",
  usu: "Uya",
  uta: "Otank",
  ute: "Ute-Southern Paiute",
  utp: "Amba (Solomon Islands)",
  utr: "Etulo",
  utu: "Utu",
  uum: "Urum",
  uun: "Kulon-Pazeh",
  uur: "Ura (Vanuatu)",
  uuu: "U",
  uve: "West Uvean",
  uvh: "Uri",
  uvl: "Lote",
  uwa: "Kuku-Uwanh",
  uya: "Doko-Uyanga",
  uzb: "Uzbek",
  uzn: "Northern Uzbek",
  uzs: "Southern Uzbek",
  vaa: "Vaagri Booli",
  vae: "Vale",
  vaf: "Vafsi",
  vag: "Vagla",
  vah: "Varhadi-Nagpuri",
  vai: "Vai",
  vaj: "Sekele",
  val: "Vehes",
  vam: "Vanimo",
  van: "Valman",
  vao: "Vao",
  vap: "Vaiphei",
  "var": "Huarijio",
  vas: "Vasavi",
  vau: "Vanuma",
  vav: "Varli",
  vay: "Wayu",
  vbb: "Southeast Babar",
  vbk: "Southwestern Bontok",
  vec: "Venetian",
  ved: "Veddah",
  vel: "Veluws",
  vem: "Vemgo-Mabas",
  ven: "Venda",
  veo: "Ventureo",
  vep: "Veps",
  ver: "Mom Jango",
  vgr: "Vaghri",
  vgt: "Vlaamse Gebarentaal",
  vic: "Virgin Islands Creole English",
  vid: "Vidunda",
  vie: "Vietnamese",
  vif: "Vili",
  vig: "Viemo",
  vil: "Vilela",
  vin: "Vinza",
  vis: "Vishavan",
  vit: "Viti",
  viv: "Iduna",
  vka: "Kariyarra",
  vki: "Ija-Zuba",
  vkj: "Kujarge",
  vkk: "Kaur",
  vkl: "Kulisusu",
  vkm: "Kamakan",
  vko: "Kodeoha",
  vkp: "Korlai Creole Portuguese",
  vkt: "Tenggarong Kutai Malay",
  vku: "Kurrama",
  vlp: "Valpei",
  vls: "Vlaams",
  vma: "Martuyhunira",
  vmb: "Barbaram",
  vmc: "Juxtlahuaca Mixtec",
  vmd: "Mudu Koraga",
  vme: "East Masela",
  vmf: "Mainfrnkisch",
  vmg: "Lungalunga",
  vmh: "Maraghei",
  vmi: "Miwa",
  vmj: "Ixtayutla Mixtec",
  vmk: "Makhuwa-Shirima",
  vml: "Malgana",
  vmm: "Mitlatongo Mixtec",
  vmp: "Soyaltepec Mazatec",
  vmq: "Soyaltepec Mixtec",
  vmr: "Marenje",
  vms: "Moksela",
  vmu: "Muluridyi",
  vmv: "Valley Maidu",
  vmw: "Makhuwa",
  vmx: "Tamazola Mixtec",
  vmy: "Ayautla Mazatec",
  vmz: "Mazatln Mazatec",
  vnk: "Vano",
  vnm: "Vinmavis",
  vnp: "Vunapu",
  vol: "Volapk",
  vor: "Voro",
  vot: "Votic",
  vra: "Vera'a",
  vro: "Vro",
  vrs: "Varisi",
  vrt: "Burmbar",
  vsi: "Moldova Sign Language",
  vsl: "Venezuelan Sign Language",
  vsv: "Valencian Sign Language",
  vto: "Vitou",
  vum: "Vumbu",
  vun: "Vunjo",
  vut: "Vute",
  vwa: "Awa (China)",
  waa: "Walla Walla",
  wab: "Wab",
  wac: "Wasco-Wishram",
  wad: "Wandamen",
  wae: "Walser",
  waf: "Wakon",
  wag: "Wa'ema",
  wah: "Watubela",
  wai: "Wares",
  waj: "Waffa",
  wal: "Wolaytta",
  wam: "Wampanoag",
  wan: "Wan",
  wao: "Wappo",
  wap: "Wapishana",
  waq: "Wageman",
  war: "Waray (Philippines)",
  was: "Washo",
  wat: "Kaninuwa",
  wau: "Waur",
  wav: "Waka",
  waw: "Waiwai",
  wax: "Watam",
  way: "Wayana",
  waz: "Wampur",
  wba: "Warao",
  wbb: "Wabo",
  wbe: "Waritai",
  wbf: "Wara",
  wbh: "Wanda",
  wbi: "Vwanji",
  wbj: "Alagwa",
  wbk: "Waigali",
  wbl: "Wakhi",
  wbm: "Wa",
  wbp: "Warlpiri",
  wbq: "Waddar",
  wbr: "Wagdi",
  wbs: "West Bengal Sign Language",
  wbt: "Wanman",
  wbv: "Wajarri",
  wbw: "Woi",
  wca: "Yanommi",
  wci: "Waci Gbe",
  wdd: "Wandji",
  wdg: "Wadaginam",
  wdj: "Wadjiginy",
  wdk: "Wadikali",
  wdu: "Wadjigu",
  wdy: "Wadjabangayi",
  wea: "Wewaw",
  wec: "W Western",
  wed: "Wedau",
  weg: "Wergaia",
  weh: "Weh",
  wei: "Kiunum",
  wem: "Weme Gbe",
  weo: "Wemale",
  wep: "Westphalien",
  wer: "Weri",
  wes: "Cameroon Pidgin",
  wet: "Perai",
  weu: "Rawngtu Chin",
  wew: "Wejewa",
  wfg: "Yafi",
  wga: "Wagaya",
  wgb: "Wagawaga",
  wgg: "Wangganguru",
  wgi: "Wahgi",
  wgo: "Waigeo",
  wgu: "Wirangu",
  wgy: "Warrgamay",
  wha: "Sou Upaa",
  whg: "North Wahgi",
  whk: "Wahau Kenyah",
  whu: "Wahau Kayan",
  wib: "Southern Toussian",
  wic: "Wichita",
  wie: "Wik-Epa",
  wif: "Wik-Keyangan",
  wig: "Wik-Ngathana",
  wih: "Wik-Me'anha",
  wii: "Minidien",
  wij: "Wik-Iiyanh",
  wik: "Wikalkan",
  wil: "Wilawila",
  wim: "Wik-Mungkan",
  win: "Ho-Chunk",
  wir: "Wirafd",
  wiu: "Wiru",
  wiv: "Vitu",
  wiy: "Wiyot",
  wja: "Waja",
  wji: "Warji",
  wka: "Kw'adza",
  wkb: "Kumbaran",
  wkd: "Wakde",
  wkl: "Kalanadi",
  wku: "Kunduvadi",
  wkw: "Wakawaka",
  wky: "Wangkayutyuru",
  wla: "Walio",
  wlc: "Mwali Comorian",
  wle: "Wolane",
  wlg: "Kunbarlang",
  wli: "Waioli",
  wlk: "Wailaki",
  wll: "Wali (Sudan)",
  wlm: "Middle Welsh",
  wln: "Walloon",
  wlo: "Wolio",
  wlr: "Wailapa",
  wls: "Wallisian",
  wlu: "Wuliwuli",
  wlv: "Wich Lhamts Vejoz",
  wlw: "Walak",
  wlx: "Wali (Ghana)",
  wly: "Waling",
  wma: "Mawa (Nigeria)",
  wmb: "Wambaya",
  wmc: "Wamas",
  wmd: "Mamaind",
  wme: "Wambule",
  wmh: "Waima'a",
  wmi: "Wamin",
  wmm: "Maiwa (Indonesia)",
  wmn: "Waamwang",
  wmo: "Wom (Papua New Guinea)",
  wms: "Wambon",
  wmt: "Walmajarri",
  wmw: "Mwani",
  wmx: "Womo",
  wnb: "Wanambre",
  wnc: "Wantoat",
  wnd: "Wandarang",
  wne: "Waneci",
  wng: "Wanggom",
  wni: "Ndzwani Comorian",
  wnk: "Wanukaka",
  wnm: "Wanggamala",
  wnn: "Wunumara",
  wno: "Wano",
  wnp: "Wanap",
  wnu: "Usan",
  wnw: "Wintu",
  wny: "Wanyi",
  woa: "Tyaraity",
  wob: "W Northern",
  woc: "Wogeo",
  wod: "Wolani",
  woe: "Woleaian",
  wof: "Gambian Wolof",
  wog: "Wogamusin",
  woi: "Kamang",
  wok: "Longto",
  wol: "Wolof",
  wom: "Wom (Nigeria)",
  won: "Wongo",
  woo: "Manombai",
  wor: "Woria",
  wos: "Hanga Hundi",
  wow: "Wawonii",
  woy: "Weyto",
  wpc: "Maco",
  wra: "Warapu",
  wrb: "Warluwara",
  wrd: "Warduji",
  wrg: "Warungu",
  wrh: "Wiradhuri",
  wri: "Wariyangga",
  wrk: "Garrwa",
  wrl: "Warlmanpa",
  wrm: "Warumungu",
  wrn: "Warnang",
  wro: "Worrorra",
  wrp: "Waropen",
  wrr: "Wardaman",
  wrs: "Waris",
  wru: "Waru",
  wrv: "Waruna",
  wrw: "Gugu Warra",
  wrx: "Wae Rana",
  wry: "Merwari",
  wrz: "Waray (Australia)",
  wsa: "Warembori",
  wsg: "Adilabad Gondi",
  wsi: "Wusi",
  wsk: "Waskia",
  wsr: "Owenia",
  wss: "Wasa",
  wsu: "Wasu",
  wsv: "Wotapuri-Katarqalai",
  wtf: "Watiwa",
  wth: "Wathawurrung",
  wti: "Berta",
  wtk: "Watakataui",
  wtm: "Mewati",
  wtw: "Wotu",
  wua: "Wikngenchera",
  wub: "Wunambal",
  wud: "Wudu",
  wuh: "Wutunhua",
  wul: "Silimo",
  wum: "Wumbvu",
  wun: "Bungu",
  wur: "Wurrugu",
  wut: "Wutung",
  wuu: "Wu Chinese",
  wuv: "Wuvulu-Aua",
  wux: "Wulna",
  wuy: "Wauyai",
  wwa: "Waama",
  wwb: "Wakabunga",
  wwo: "Wetamut",
  wwr: "Warrwa",
  www: "Wawa",
  wxa: "Waxianghua",
  wxw: "Wardandi",
  wya: "Wyandot",
  wyb: "Wangaaybuwan-Ngiyambaa",
  wyi: "Woiwurrung",
  wym: "Wymysorys",
  wyr: "Wayor",
  wyy: "Western Fijian",
  xaa: "Andalusian Arabic",
  xab: "Sambe",
  xac: "Kachari",
  xad: "Adai",
  xae: "Aequian",
  xag: "Aghwan",
  xai: "Kaimb",
  xaj: "Ararandewra",
  xak: "Mku",
  xal: "Kalmyk",
  xam: "/Xam",
  xan: "Xamtanga",
  xao: "Khao",
  xap: "Apalachee",
  xaq: "Aquitanian",
  xar: "Karami",
  xas: "Kamas",
  xat: "Katawixi",
  xau: "Kauwera",
  xav: "Xavnte",
  xaw: "Kawaiisu",
  xay: "Kayan Mahakam",
  xbb: "Lower Burdekin",
  xbc: "Bactrian",
  xbd: "Bindal",
  xbe: "Bigambal",
  xbg: "Bunganditj",
  xbi: "Kombio",
  xbj: "Birrpayi",
  xbm: "Middle Breton",
  xbn: "Kenaboi",
  xbo: "Bolgarian",
  xbp: "Bibbulman",
  xbr: "Kambera",
  xbw: "Kambiw",
  xby: "Batyala",
  xcb: "Cumbric",
  xcc: "Camunic",
  xce: "Celtiberian",
  xcg: "Cisalpine Gaulish",
  xch: "Chemakum",
  xcl: "Classical Armenian",
  xcm: "Comecrudo",
  xcn: "Cotoname",
  xco: "Chorasmian",
  xcr: "Carian",
  xct: "Classical Tibetan",
  xcu: "Curonian",
  xcv: "Chuvantsy",
  xcw: "Coahuilteco",
  xcy: "Cayuse",
  xda: "Darkinyung",
  xdc: "Dacian",
  xdk: "Dharuk",
  xdm: "Edomite",
  xdo: "Kwandu",
  xdy: "Malayic Dayak",
  xeb: "Eblan",
  xed: "Hdi",
  xeg: "//Xegwi",
  xel: "Kelo",
  xem: "Kembayan",
  xep: "Epi-Olmec",
  xer: "Xernte",
  xes: "Kesawai",
  xet: "Xet",
  xeu: "Keoru-Ahia",
  xfa: "Faliscan",
  xga: "Galatian",
  xgb: "Gbin",
  xgd: "Gudang",
  xgf: "Gabrielino-Fernandeo",
  xgg: "Goreng",
  xgi: "Garingbal",
  xgl: "Galindan",
  xgm: "Dharumbal",
  xgr: "Garza",
  xgu: "Unggumi",
  xgw: "Guwa",
  xha: "Harami",
  xhc: "Hunnic",
  xhd: "Hadrami",
  xhe: "Khetrani",
  xho: "Xhosa",
  xhr: "Hernican",
  xht: "Hattic",
  xhu: "Hurrian",
  xhv: "Khua",
  xib: "Iberian",
  xii: "Xiri",
  xil: "Illyrian",
  xin: "Xinca",
  xir: "Xirina",
  xis: "Kisan",
  xiv: "Indus Valley Language",
  xiy: "Xipaya",
  xjb: "Minjungbal",
  xjt: "Jaitmatang",
  xka: "Kalkoti",
  xkb: "Northern Nago",
  xkc: "Kho'ini",
  xkd: "Mendalam Kayan",
  xke: "Kereho",
  xkf: "Khengkha",
  xkg: "Kagoro",
  xki: "Kenyan Sign Language",
  xkj: "Kajali",
  xkk: "Kaco'",
  xkl: "Mainstream Kenyah",
  xkn: "Kayan River Kayan",
  xko: "Kiorr",
  xkp: "Kabatei",
  xkq: "Koroni",
  xkr: "Xakriab",
  xks: "Kumbewaha",
  xkt: "Kantosi",
  xku: "Kaamba",
  xkv: "Kgalagadi",
  xkw: "Kembra",
  xkx: "Karore",
  xky: "Uma' Lasan",
  xkz: "Kurtokha",
  xla: "Kamula",
  xlb: "Loup B",
  xlc: "Lycian",
  xld: "Lydian",
  xle: "Lemnian",
  xlg: "Ligurian (Ancient)",
  xli: "Liburnian",
  xln: "Alanic",
  xlo: "Loup A",
  xlp: "Lepontic",
  xls: "Lusitanian",
  xlu: "Cuneiform Luwian",
  xly: "Elymian",
  xma: "Mushungulu",
  xmb: "Mbonga",
  xmc: "Makhuwa-Marrevone",
  xmd: "Mbudum",
  xme: "Median",
  xmf: "Mingrelian",
  xmg: "Mengaka",
  xmh: "Kuku-Muminh",
  xmj: "Majera",
  xmk: "Ancient Macedonian",
  xml: "Malaysian Sign Language",
  xmm: "Manado Malay",
  xmn: "Manichaean Middle Persian",
  xmo: "Morerebi",
  xmp: "Kuku-Mu'inh",
  xmq: "Kuku-Mangk",
  xmr: "Meroitic",
  xms: "Moroccan Sign Language",
  xmt: "Matbat",
  xmu: "Kamu",
  xmv: "Antankarana Malagasy",
  xmw: "Tsimihety Malagasy",
  xmx: "Maden",
  xmy: "Mayaguduna",
  xmz: "Mori Bawah",
  xna: "Ancient North Arabian",
  xnb: "Kanakanabu",
  xng: "Middle Mongolian",
  xnh: "Kuanhua",
  xni: "Ngarigu",
  xnk: "Nganakarti",
  xnn: "Northern Kankanay",
  xno: "Anglo-Norman",
  xnr: "Kangri",
  xns: "Kanashi",
  xnt: "Narragansett",
  xnu: "Nukunul",
  xny: "Nyiyaparli",
  xnz: "Kenzi",
  xoc: "O'chi'chi'",
  xod: "Kokoda",
  xog: "Soga",
  xoi: "Kominimung",
  xok: "Xokleng",
  xom: "Komo (Sudan)",
  xon: "Konkomba",
  xoo: "Xukur",
  xop: "Kopar",
  xor: "Korubo",
  xow: "Kowaki",
  xpa: "Pirriya",
  xpc: "Pecheneg",
  xpe: "Liberia Kpelle",
  xpg: "Phrygian",
  xpi: "Pictish",
  xpj: "Mpalitjanh",
  xpk: "Kulina Pano",
  xpm: "Pumpokol",
  xpn: "Kapinaw",
  xpo: "Pochutec",
  xpp: "Puyo-Paekche",
  xpq: "Mohegan-Pequot",
  xpr: "Parthian",
  xps: "Pisidian",
  xpt: "Punthamara",
  xpu: "Punic",
  xpy: "Puyo",
  xqa: "Karakhanid",
  xqt: "Qatabanian",
  xra: "Krah",
  xrb: "Eastern Karaboro",
  xrd: "Gundungurra",
  xre: "Kreye",
  xrg: "Minang",
  xri: "Krikati-Timbira",
  xrm: "Armazic",
  xrn: "Arin",
  xrq: "Karranga",
  xrr: "Raetic",
  xrt: "Aranama-Tamique",
  xru: "Marriammu",
  xrw: "Karawa",
  xsa: "Sabaean",
  xsb: "Sambal",
  xsc: "Scythian",
  xsd: "Sidetic",
  xse: "Sempan",
  xsh: "Shamang",
  xsi: "Sio",
  xsl: "South Slavey",
  xsm: "Kasem",
  xsn: "Sanga (Nigeria)",
  xso: "Solano",
  xsp: "Silopi",
  xsq: "Makhuwa-Saka",
  xsr: "Sherpa",
  xss: "Assan",
  xsu: "Sanum",
  xsv: "Sudovian",
  xsy: "Saisiyat",
  xta: "Alcozauca Mixtec",
  xtb: "Chazumba Mixtec",
  xtc: "Katcha-Kadugli-Miri",
  xtd: "Diuxi-Tilantongo Mixtec",
  xte: "Ketengban",
  xtg: "Transalpine Gaulish",
  xth: "Yitha Yitha",
  xti: "Sinicahua Mixtec",
  xtj: "San Juan Teita Mixtec",
  xtl: "Tijaltepec Mixtec",
  xtm: "Magdalena Peasco Mixtec",
  xtn: "Northern Tlaxiaco Mixtec",
  xto: "Tokharian A",
  xtp: "San Miguel Piedras Mixtec",
  xtq: "Tumshuqese",
  xtr: "Early Tripuri",
  xts: "Sindihui Mixtec",
  xtt: "Tacahua Mixtec",
  xtu: "Cuyamecalco Mixtec",
  xtv: "Thawa",
  xtw: "Tawand",
  xty: "Yoloxochitl Mixtec",
  xtz: "Tasmanian",
  xua: "Alu Kurumba",
  xub: "Betta Kurumba",
  xud: "Umiida",
  xug: "Kunigami",
  xuj: "Jennu Kurumba",
  xul: "Ngunawal",
  xum: "Umbrian",
  xun: "Unggaranggu",
  xuo: "Kuo",
  xup: "Upper Umpqua",
  xur: "Urartian",
  xut: "Kuthant",
  xuu: "Kxoe",
  xve: "Venetic",
  xvi: "Kamviri",
  xvn: "Vandalic",
  xvo: "Volscian",
  xvs: "Vestinian",
  xwa: "Kwaza",
  xwc: "Woccon",
  xwd: "Wadi Wadi",
  xwe: "Xwela Gbe",
  xwg: "Kwegu",
  xwj: "Wajuk",
  xwk: "Wangkumara",
  xwl: "Western Xwla Gbe",
  xwo: "Written Oirat",
  xwr: "Kwerba Mamberamo",
  xwt: "Wotjobaluk",
  xww: "Wemba Wemba",
  xxb: "Boro (Ghana)",
  xxk: "Ke'o",
  xxm: "Minkin",
  xxr: "Korop",
  xxt: "Tambora",
  xya: "Yaygir",
  xyb: "Yandjibara",
  xyj: "Mayi-Yapi",
  xyk: "Mayi-Kulan",
  xyl: "Yalakalore",
  xyt: "Mayi-Thakurti",
  xyy: "Yorta Yorta",
  xzh: "Zhang-Zhung",
  xzm: "Zemgalian",
  xzp: "Ancient Zapotec",
  yaa: "Yaminahua",
  yab: "Yuhup",
  yac: "Pass Valley Yali",
  yad: "Yagua",
  yae: "Pum",
  yaf: "Yaka (Democratic Republic of Congo)",
  yag: "Ymana",
  yah: "Yazgulyam",
  yai: "Yagnobi",
  yaj: "Banda-Yangere",
  yak: "Yakama",
  yal: "Yalunka",
  yam: "Yamba",
  yan: "Mayangna",
  yao: "Yao",
  yap: "Yapese",
  yaq: "Yaqui",
  yar: "Yabarana",
  yas: "Nugunu (Cameroon)",
  yat: "Yambeta",
  yau: "Yuwana",
  yav: "Yangben",
  yaw: "Yawalapit",
  yax: "Yauma",
  yay: "Agwagwune",
  yaz: "Lokaa",
  yba: "Yala",
  ybb: "Yemba",
  ybe: "West Yugur",
  ybh: "Yakha",
  ybi: "Yamphu",
  ybj: "Hasha",
  ybk: "Bokha",
  ybl: "Yukuben",
  ybm: "Yaben",
  ybn: "Yabana",
  ybo: "Yabong",
  ybx: "Yawiyo",
  yby: "Yaweyuha",
  ych: "Chesu",
  ycl: "Lolopo",
  ycn: "Yucuna",
  ycp: "Chepya",
  yda: "Yanda",
  ydd: "Eastern Yiddish",
  yde: "Yangum Dey",
  ydg: "Yidgha",
  ydk: "Yoidik",
  yea: "Ravula",
  yec: "Yeniche",
  yee: "Yimas",
  yei: "Yeni",
  yej: "Yevanic",
  yel: "Yela",
  yer: "Tarok",
  yes: "Nyankpa",
  yet: "Yetfa",
  yeu: "Yerukula",
  yev: "Yapunda",
  yey: "Yeyi",
  yga: "Malyangapa",
  ygi: "Yiningayi",
  ygl: "Yangum Gel",
  ygm: "Yagomi",
  ygp: "Gepo",
  ygr: "Yagaria",
  ygs: "Yolu Sign Language",
  ygu: "Yugul",
  ygw: "Yagwoia",
  yha: "Baha Buyang",
  yhd: "Judeo-Iraqi Arabic",
  yhl: "Hlepho Phowa",
  yhs: "Yan-nhau Sign Language",
  yia: "Yinggarda",
  yid: "Yiddish",
  yif: "Ache",
  yig: "Wusa Nasu",
  yih: "Western Yiddish",
  yii: "Yidiny",
  yij: "Yindjibarndi",
  yik: "Dongshanba Lalo",
  yil: "Yindjilandji",
  yim: "Yimchungru Naga",
  yin: "Yinchia",
  yip: "Pholo",
  yiq: "Miqie",
  yir: "North Awyu",
  yis: "Yis",
  yit: "Eastern Lalu",
  yiu: "Awu",
  yiv: "Northern Nisu",
  yix: "Axi Yi",
  yiz: "Azhe",
  yka: "Yakan",
  ykg: "Northern Yukaghir",
  yki: "Yoke",
  ykk: "Yakaikeke",
  ykl: "Khlula",
  ykm: "Kap",
  ykn: "Kua-nsi",
  yko: "Yasa",
  ykr: "Yekora",
  ykt: "Kathu",
  yku: "Kuamasi",
  yky: "Yakoma",
  yla: "Yaul",
  ylb: "Yaleba",
  yle: "Yele",
  ylg: "Yelogu",
  yli: "Angguruk Yali",
  yll: "Yil",
  ylm: "Limi",
  yln: "Langnian Buyang",
  ylo: "Naluo Yi",
  ylr: "Yalarnnga",
  ylu: "Aribwaung",
  yly: "Nylayu",
  ymb: "Yambes",
  ymc: "Southern Muji",
  ymd: "Muda",
  yme: "Yameo",
  ymg: "Yamongeri",
  ymh: "Mili",
  ymi: "Moji",
  ymk: "Makwe",
  yml: "Iamalele",
  ymm: "Maay",
  ymn: "Yamna",
  ymo: "Yangum Mon",
  ymp: "Yamap",
  ymq: "Qila Muji",
  ymr: "Malasar",
  yms: "Mysian",
  ymx: "Northern Muji",
  ymz: "Muzi",
  yna: "Aluo",
  ynd: "Yandruwandha",
  yne: "Lang'e",
  yng: "Yango",
  ynk: "Naukan Yupik",
  ynl: "Yangulam",
  ynn: "Yana",
  yno: "Yong",
  ynq: "Yendang",
  yns: "Yansi",
  ynu: "Yahuna",
  yob: "Yoba",
  yog: "Yogad",
  yoi: "Yonaguni",
  yok: "Yokuts",
  yol: "Yola",
  yom: "Yombe",
  yon: "Yongkom",
  yor: "Yoruba",
  yot: "Yotti",
  yox: "Yoron",
  yoy: "Yoy",
  ypa: "Phala",
  ypb: "Labo Phowa",
  ypg: "Phola",
  yph: "Phupha",
  ypm: "Phuma",
  ypn: "Ani Phowa",
  ypo: "Alo Phola",
  ypp: "Phupa",
  ypz: "Phuza",
  yra: "Yerakai",
  yrb: "Yareba",
  yre: "Yaour",
  yrk: "Nenets",
  yrl: "Nhengatu",
  yrm: "Yirrk-Mel",
  yrn: "Yerong",
  yro: "Yaroam",
  yrs: "Yarsun",
  yrw: "Yarawata",
  yry: "Yarluyandi",
  ysc: "Yassic",
  ysd: "Samatao",
  ysg: "Sonaga",
  ysl: "Yugoslavian Sign Language",
  ysn: "Sani",
  yso: "Nisi (China)",
  ysp: "Southern Lolopo",
  ysr: "Sirenik Yupik",
  yss: "Yessan-Mayo",
  ysy: "Sanie",
  yta: "Talu",
  ytl: "Tanglang",
  ytp: "Thopho",
  ytw: "Yout Wam",
  yty: "Yatay",
  yua: "Yucateco",
  yub: "Yugambal",
  yuc: "Yuchi",
  yud: "Judeo-Tripolitanian Arabic",
  yue: "Yue Chinese",
  yuf: "Havasupai-Walapai-Yavapai",
  yug: "Yug",
  yui: "Yurut",
  yuj: "Karkar-Yuri",
  yuk: "Yuki",
  yul: "Yulu",
  yum: "Quechan",
  yun: "Bena (Nigeria)",
  yup: "Yukpa",
  yuq: "Yuqui",
  yur: "Yurok",
  yut: "Yopno",
  yuw: "Yau (Morobe Province)",
  yux: "Southern Yukaghir",
  yuy: "East Yugur",
  yuz: "Yuracare",
  yva: "Yawa",
  yvt: "Yavitero",
  ywa: "Kalou",
  ywg: "Yinhawangka",
  ywl: "Western Lalu",
  ywn: "Yawanawa",
  ywq: "Wuding-Luquan Yi",
  ywr: "Yawuru",
  ywt: "Xishanba Lalo",
  ywu: "Wumeng Nasu",
  yww: "Yawarawarga",
  yxa: "Mayawali",
  yxg: "Yagara",
  yxl: "Yardliyawarra",
  yxm: "Yinwum",
  yxu: "Yuyu",
  yxy: "Yabula Yabula",
  yyr: "Yir Yoront",
  yyu: "Yau (Sandaun Province)",
  yyz: "Ayizi",
  yzg: "E'ma Buyang",
  yzk: "Zokhuo",
  zaa: "Sierra de Jurez Zapotec",
  zab: "Western Tlacolula Valley Zapotec",
  zac: "Ocotln Zapotec",
  zad: "Cajonos Zapotec",
  zae: "Yareni Zapotec",
  zaf: "Ayoquesco Zapotec",
  zag: "Zaghawa",
  zah: "Zangwal",
  zai: "Isthmus Zapotec",
  zaj: "Zaramo",
  zak: "Zanaki",
  zal: "Zauzou",
  zam: "Miahuatln Zapotec",
  zao: "Ozolotepec Zapotec",
  zap: "Zapotec",
  zaq: "Alopam Zapotec",
  zar: "Rincn Zapotec",
  zas: "Santo Domingo Albarradas Zapotec",
  zat: "Tabaa Zapotec",
  zau: "Zangskari",
  zav: "Yatzachi Zapotec",
  zaw: "Mitla Zapotec",
  zax: "Xadani Zapotec",
  zay: "Zayse-Zergulla",
  zaz: "Zari",
  zbc: "Central Berawan",
  zbe: "East Berawan",
  zbl: "Blissymbols",
  zbt: "Batui",
  zbw: "West Berawan",
  zca: "Coatecas Altas Zapotec",
  zch: "Central Hongshuihe Zhuang",
  zdj: "Ngazidja Comorian",
  zea: "Zeeuws",
  zeg: "Zenag",
  zeh: "Eastern Hongshuihe Zhuang",
  zen: "Zenaga",
  zga: "Kinga",
  zgb: "Guibei Zhuang",
  zgh: "Standard Moroccan Tamazight",
  zgm: "Minz Zhuang",
  zgn: "Guibian Zhuang",
  zgr: "Magori",
  zha: "Zhuang",
  zhb: "Zhaba",
  zhd: "Dai Zhuang",
  zhi: "Zhire",
  zhn: "Nong Zhuang",
  zho: "Chinese",
  zhw: "Zhoa",
  zia: "Zia",
  zib: "Zimbabwe Sign Language",
  zik: "Zimakani",
  zil: "Zialo",
  zim: "Mesme",
  zin: "Zinza",
  zir: "Ziriya",
  ziw: "Zigula",
  ziz: "Zizilivakan",
  zka: "Kaimbulawa",
  zkb: "Koibal",
  zkd: "Kadu",
  zkg: "Koguryo",
  zkh: "Khorezmian",
  zkk: "Karankawa",
  zkn: "Kanan",
  zko: "Kott",
  zkp: "So Paulo Kaingng",
  zkr: "Zakhring",
  zkt: "Kitan",
  zku: "Kaurna",
  zkv: "Krevinian",
  zkz: "Khazar",
  zlj: "Liujiang Zhuang",
  zlm: "Malay (individual language)",
  zln: "Lianshan Zhuang",
  zlq: "Liuqian Zhuang",
  zma: "Manda (Australia)",
  zmb: "Zimba",
  zmc: "Margany",
  zmd: "Maridan",
  zme: "Mangerr",
  zmf: "Mfinu",
  zmg: "Marti Ke",
  zmh: "Makolkol",
  zmi: "Negeri Sembilan Malay",
  zmj: "Maridjabin",
  zmk: "Mandandanyi",
  zml: "Madngele",
  zmm: "Marimanindji",
  zmn: "Mbangwe",
  zmo: "Molo",
  zmp: "Mpuono",
  zmq: "Mituku",
  zmr: "Maranunggu",
  zms: "Mbesa",
  zmt: "Maringarr",
  zmu: "Muruwari",
  zmv: "Mbariman-Gudhinma",
  zmw: "Mbo (Democratic Republic of Congo)",
  zmx: "Bomitaba",
  zmy: "Mariyedi",
  zmz: "Mbandja",
  zna: "Zan Gula",
  zne: "Zande (individual language)",
  zng: "Mang",
  znk: "Manangkari",
  zns: "Mangas",
  zoc: "Copainal Zoque",
  zoh: "Chimalapa Zoque",
  zom: "Zou",
  zoo: "Asuncin Mixtepec Zapotec",
  zoq: "Tabasco Zoque",
  zor: "Rayn Zoque",
  zos: "Francisco Len Zoque",
  zpa: "Lachiguiri Zapotec",
  zpb: "Yautepec Zapotec",
  zpc: "Choapan Zapotec",
  zpd: "Southeastern Ixtln Zapotec",
  zpe: "Petapa Zapotec",
  zpf: "San Pedro Quiatoni Zapotec",
  zpg: "Guevea De Humboldt Zapotec",
  zph: "Totomachapan Zapotec",
  zpi: "Santa Mara Quiegolani Zapotec",
  zpj: "Quiavicuzas Zapotec",
  zpk: "Tlacolulita Zapotec",
  zpl: "Lachixo Zapotec",
  zpm: "Mixtepec Zapotec",
  zpn: "Santa Ins Yatzechi Zapotec",
  zpo: "Amatln Zapotec",
  zpp: "El Alto Zapotec",
  zpq: "Zoogocho Zapotec",
  zpr: "Santiago Xanica Zapotec",
  zps: "Coatln Zapotec",
  zpt: "San Vicente Coatln Zapotec",
  zpu: "Yallag Zapotec",
  zpv: "Chichicapan Zapotec",
  zpw: "Zaniza Zapotec",
  zpx: "San Baltazar Loxicha Zapotec",
  zpy: "Mazaltepec Zapotec",
  zpz: "Texmelucan Zapotec",
  zqe: "Qiubei Zhuang",
  zra: "Kara (Korea)",
  zrg: "Mirgan",
  zrn: "Zerenkel",
  zro: "Zparo",
  zrp: "Zarphatic",
  zrs: "Mairasi",
  zsa: "Sarasira",
  zsk: "Kaskean",
  zsl: "Zambian Sign Language",
  zsm: "Standard Malay",
  zsr: "Southern Rincon Zapotec",
  zsu: "Sukurum",
  zte: "Elotepec Zapotec",
  ztg: "Xanagua Zapotec",
  ztl: "Lapagua-Guivini Zapotec",
  ztm: "San Agustn Mixtepec Zapotec",
  ztn: "Santa Catarina Albarradas Zapotec",
  ztp: "Loxicha Zapotec",
  ztq: "Quioquitani-Quier Zapotec",
  zts: "Tilquiapan Zapotec",
  ztt: "Tejalapan Zapotec",
  ztu: "Gil Zapotec",
  ztx: "Zaachila Zapotec",
  zty: "Yatee Zapotec",
  zua: "Zeem",
  zuh: "Tokano",
  zul: "Zulu",
  zum: "Kumzari",
  zun: "Zuni",
  zuy: "Zumaya",
  zwa: "Zay",
  zxx: "No linguistic content",
  zyb: "Yongbei Zhuang",
  zyg: "Yang Zhuang",
  zyj: "Youjiang Zhuang",
  zyn: "Yongnan Zhuang",
  zyp: "Zyphe Chin",
  zza: "Zaza",
  zzj: "Zuojiang Zhuang"
});
;// CONCATENATED MODULE: ./demo/full/scripts/lib/translateLanguageCode.js

function translateLanguageCode(langCode) {
  if (!langCode) {
    return "unknown";
  }

  return assets_languages[langCode.toLowerCase()] || langCode;
}
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/knobs/AudioTrack.jsx




var AUDIO_DESCRIPTION_ICON = "(AD)"; // String.fromCharCode(0xf29e);

var findLanguageIndex = function findLanguageIndex(language, languages) {
  return languages.findIndex(function (ln) {
    return ln.id === language.id;
  });
};

var AudioTrackKnobBase = function AudioTrackKnobBase(_ref) {
  var player = _ref.player,
      className = _ref.className,
      currentLanguage = _ref.currentLanguage,
      _ref$availableLanguag = _ref.availableLanguages,
      availableLanguages = _ref$availableLanguag === void 0 ? [] : _ref$availableLanguag;
  var options = [];
  var selectedIndex;

  if (!availableLanguages.length) {
    options = ["Not available"];
    selectedIndex = 0;
  } else {
    options = availableLanguages.map(function (language) {
      return translateLanguageCode(language.normalized) + (language.audioDescription ? " " + AUDIO_DESCRIPTION_ICON : "");
    });
    selectedIndex = currentLanguage ? Math.max(findLanguageIndex(currentLanguage, availableLanguages), 0) : 0;
  }

  var onLanguageChange = function onLanguageChange(evt) {
    var index = +evt.target.value;
    var track = availableLanguages[index];
    player.dispatch("SET_AUDIO_TRACK", track);
  };

  return /*#__PURE__*/react.createElement(components_Knob, {
    name: "Audio Language",
    ariaLabel: "Update the audio track",
    className: className,
    disabled: availableLanguages.length < 2,
    onChange: onLanguageChange,
    options: options,
    selected: selectedIndex
  });
};

/* harmony default export */ const AudioTrack = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    language: "currentLanguage",
    availableLanguages: "availableLanguages"
  }
})(AudioTrackKnobBase)));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/knobs/Subtitles.jsx




var CLOSED_CAPTION_ICON = "(CC)"; // String.fromCharCode(0xf2a4);

var Subtitles_findLanguageIndex = function findLanguageIndex(currentSubtitle, languages) {
  return languages.findIndex(function (ln) {
    return ln.id === currentSubtitle.id;
  });
};

var SubtitlesKnobBase = function SubtitlesKnobBase(_ref) {
  var player = _ref.player,
      className = _ref.className,
      currentSubtitle = _ref.currentSubtitle,
      _ref$availableSubtitl = _ref.availableSubtitles,
      availableSubtitles = _ref$availableSubtitl === void 0 ? [] : _ref$availableSubtitl;
  var options = ["no subtitles"].concat(availableSubtitles.map(function (subtitle) {
    return translateLanguageCode(subtitle.normalized) + (subtitle.closedCaption ? " " + CLOSED_CAPTION_ICON : "");
  }));
  var currentLanguageIndex = currentSubtitle ? Subtitles_findLanguageIndex(currentSubtitle, availableSubtitles) + 1 : 0;

  var onLanguageChange = function onLanguageChange(evt) {
    var index = +evt.target.value;

    if (index > 0) {
      var sub = availableSubtitles[index - 1];
      player.dispatch("SET_SUBTITLES_TRACK", sub);
    } else {
      player.dispatch("DISABLE_SUBTITLES_TRACK");
    }
  };

  return /*#__PURE__*/react.createElement(components_Knob, {
    name: "Subtitles Track",
    ariaLabel: "Update the current subtitles",
    className: className,
    disabled: options.length <= 1,
    onChange: onLanguageChange,
    options: options,
    selected: currentLanguageIndex
  });
};

/* harmony default export */ const Subtitles = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    subtitle: "currentSubtitle",
    availableSubtitles: "availableSubtitles"
  }
})(SubtitlesKnobBase)));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/knobs/VideoTrack.jsx




var findVideoTrackIndex = function findVideoTrackIndex(track, tracks) {
  return tracks.findIndex(function (ln) {
    return ln.id === track.id;
  });
};

var VideoTrackKnobBase = function VideoTrackKnobBase(_ref) {
  var player = _ref.player,
      className = _ref.className,
      _ref$availableVideoTr = _ref.availableVideoTracks,
      availableVideoTracks = _ref$availableVideoTr === void 0 ? [] : _ref$availableVideoTr,
      currentVideoTrack = _ref.currentVideoTrack;
  var options = [];
  var selectedIndex = 0;

  if (!availableVideoTracks.length) {
    options = ["Not available"];
  } else {
    options = ["no video track"].concat(availableVideoTracks.map(function (track, i) {
      return "track " + i + ": " + track.id;
    }));

    if (currentVideoTrack) {
      selectedIndex = 1 + findVideoTrackIndex(currentVideoTrack, availableVideoTracks);
    }
  }

  var onTrackChange = function onTrackChange(evt) {
    var index = +evt.target.value;

    if (index === 0) {
      player.dispatch("DISABLE_VIDEO_TRACK");
    } else {
      var track = availableVideoTracks[index - 1];
      player.dispatch("SET_VIDEO_TRACK", track);
    }
  };

  return /*#__PURE__*/react.createElement(components_Knob, {
    name: "Video Track",
    ariaLabel: "Update the video track",
    className: className,
    disabled: options.length <= 1,
    onChange: onTrackChange,
    options: options,
    selected: selectedIndex
  });
};

/* harmony default export */ const VideoTrack = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    videoTrack: "currentVideoTrack",
    availableVideoTracks: "availableVideoTracks"
  }
})(VideoTrackKnobBase)));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/knobs/SpeedKnob.jsx



var AVAILABLE_RATES = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 2.5, 3];

var PlaybackRateKnob = function PlaybackRateKnob(_ref) {
  var player = _ref.player,
      className = _ref.className,
      playbackRate = _ref.playbackRate;
  var aliases = {
    1: "Normal"
  };
  var options = AVAILABLE_RATES.map(function (rate) {
    return aliases[rate] || rate;
  });
  var selectedIndex = AVAILABLE_RATES.findIndex(function (rate) {
    return playbackRate === rate;
  });

  var onPlaybackRateChange = function onPlaybackRateChange(evt) {
    var index = +evt.target.value;

    if (index > -1) {
      selectedIndex = index;
      var rate = AVAILABLE_RATES[index];
      player.dispatch("SET_PLAYBACK_RATE", rate);
    }
  };

  return /*#__PURE__*/react.createElement(components_Knob, {
    className: className,
    ariaLabel: "Update the current playback speed",
    name: "Playback Rate",
    disabled: options.length < 2,
    onChange: onPlaybackRateChange,
    options: options,
    selected: selectedIndex
  });
};

/* harmony default export */ const SpeedKnob = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    playbackRate: "playbackRate"
  }
})(PlaybackRateKnob)));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/PlayerKnobsSettings.jsx









function PlayerKnobsSettings(_ref) {
  var shouldDisplay = _ref.shouldDisplay,
      close = _ref.close,
      player = _ref.player,
      lowLatencyMode = _ref.lowLatencyMode,
      isContentLoaded = _ref.isContentLoaded;

  if (!isContentLoaded) {
    return null;
  }

  var className = "player-knobs settings" + (shouldDisplay ? " fade-in-out" : "");
  return /*#__PURE__*/react.createElement("div", {
    className: className
  }, /*#__PURE__*/react.createElement("div", {
    className: "player-knobs-header"
  }, /*#__PURE__*/react.createElement("span", {
    className: "player-knobs-title"
  }, "Settings"), /*#__PURE__*/react.createElement("span", {
    className: "player-knobs-close",
    onClick: function onClick() {
      close();
    }
  }, String.fromCharCode(0xf00d))), /*#__PURE__*/react.createElement("div", {
    className: "player-knobs-content"
  }, lowLatencyMode ? null :
  /*#__PURE__*/
  // In lowLatencyMode, we take back control of the rate
  react.createElement(SpeedKnob, {
    className: "black-knob",
    player: player
  }), /*#__PURE__*/react.createElement(AudioBitrate, {
    className: "black-knob",
    player: player
  }), /*#__PURE__*/react.createElement(VideoBitrate, {
    className: "black-knob",
    player: player
  }), /*#__PURE__*/react.createElement(AudioTrack, {
    className: "black-knob",
    player: player
  }), /*#__PURE__*/react.createElement(Subtitles, {
    className: "black-knob",
    player: player
  }), /*#__PURE__*/react.createElement(VideoTrack, {
    className: "black-knob",
    player: player
  })));
}

/* harmony default export */ const controllers_PlayerKnobsSettings = (/*#__PURE__*/react.memo(lib_withModulesState({
  player: {
    lowLatencyMode: "lowLatencyMode",
    isStopped: "isStopped",
    isContentLoaded: "isContentLoaded"
  }
})(PlayerKnobsSettings)));
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/Player.jsx










 // time in ms while seeking/loading/buffering after which the spinner is shown

var SPINNER_TIMEOUT = 300;

function Player_Player() {
  var _useState = (0,react.useState)(null),
      player = _useState[0],
      setPlayer = _useState[1];

  var _useState2 = (0,react.useState)(false),
      autoPlayBlocked = _useState2[0],
      setAutoPlayBlocked = _useState2[1];

  var _useState3 = (0,react.useState)(false),
      displaySpinner = _useState3[0],
      setDisplaySpinner = _useState3[1];

  var _useState4 = (0,react.useState)(false),
      displaySettings = _useState4[0],
      setDisplaySettings = _useState4[1];

  var _useState5 = (0,react.useState)(false),
      isStopped = _useState5[0],
      setIsStopped = _useState5[1];

  var videoElement = (0,react.useRef)(null);
  var textTrackElement = (0,react.useRef)(null);
  var playerWrapperElement = (0,react.useRef)(null);
  (0,react.useEffect)(function () {
    var playerMod = createModule(modules_player, {
      videoElement: videoElement.current,
      textTrackElement: textTrackElement.current
    });
    var $destroySubject = new Subject/* Subject */.xQ();
    $destroySubject.subscribe(function () {
      return playerMod.destroy();
    });
    var displaySpinnerTimeout = 0; // update isStopped and displaySpinner

    playerMod.$get("autoPlayBlocked", "isSeeking", "isBuffering", "isLoading", "isReloading", "isStopped").pipe((0,takeUntil/* takeUntil */.R)($destroySubject)).subscribe(function (_ref) {
      var newAutoPlayBlocked = _ref[0],
          isSeeking = _ref[1],
          isBuffering = _ref[2],
          isLoading = _ref[3],
          isReloading = _ref[4],
          newIsStopped = _ref[5];
      setAutoPlayBlocked(newAutoPlayBlocked);
      setIsStopped(newIsStopped);

      if (isLoading || isReloading) {
        setDisplaySpinner(true);
      } else if (isSeeking || isBuffering) {
        if (displaySpinnerTimeout) {
          clearTimeout(displaySpinnerTimeout);
        }

        displaySpinnerTimeout = setTimeout(function () {
          setDisplaySpinner(true);
        }, SPINNER_TIMEOUT);
      } else {
        if (displaySpinnerTimeout) {
          clearTimeout(displaySpinnerTimeout);
          displaySpinnerTimeout = 0;
        }

        setDisplaySpinner(false);
      }
    });
    setPlayer(playerMod);
    return function () {
      if ($destroySubject) {
        $destroySubject.next();
        $destroySubject.complete();
      }

      if (displaySpinnerTimeout) {
        clearTimeout(displaySpinnerTimeout);
      }
    };
  }, []);
  var onVideoClick = (0,react.useCallback)(function () {
    var _player$get = player.get(),
        isPaused = _player$get.isPaused,
        isContentLoaded = _player$get.isContentLoaded;

    if (!isContentLoaded) {
      return;
    }

    if (isPaused) {
      player.dispatch("PLAY");
    } else {
      player.dispatch("DISABLE_LIVE_CATCH_UP");
      player.dispatch("PAUSE");
    }
  }, [player]);
  var loadVideo = (0,react.useCallback)(function (video) {
    if (video.lowLatencyMode) {
      player.dispatch("ENABLE_LIVE_CATCH_UP");
    } else {
      player.dispatch("DISABLE_LIVE_CATCH_UP");
    }

    player.dispatch("SET_PLAYBACK_RATE", 1);
    player.dispatch("LOAD", video);
  }, [player]);
  var stopVideo = (0,react.useCallback)(function () {
    return player.dispatch("STOP");
  }, [player]);
  var closeSettings = (0,react.useCallback)(function () {
    setDisplaySettings(false);
  }, []);
  var toggleSettings = (0,react.useCallback)(function () {
    setDisplaySettings(!displaySettings);
  }, [displaySettings]);
  return /*#__PURE__*/react.createElement("section", {
    className: "video-player-section"
  }, /*#__PURE__*/react.createElement("div", {
    className: "video-player-content"
  }, /*#__PURE__*/react.createElement(controllers_ContentList, {
    loadVideo: loadVideo,
    isStopped: isStopped
  }), /*#__PURE__*/react.createElement("div", {
    className: "video-player-wrapper",
    ref: playerWrapperElement
  }, /*#__PURE__*/react.createElement("div", {
    className: "video-screen-parent"
  }, /*#__PURE__*/react.createElement("div", {
    className: "video-screen",
    onClick: function onClick() {
      return onVideoClick();
    }
  }, /*#__PURE__*/react.createElement(controllers_ErrorDisplayer, {
    player: player
  }), autoPlayBlocked ? /*#__PURE__*/react.createElement("div", {
    className: "video-player-manual-play-container"
  }, /*#__PURE__*/react.createElement("img", {
    className: "video-player-manual-play",
    alt: "Play",
    src: "./assets/play.svg"
  })) : null, !autoPlayBlocked && displaySpinner ? /*#__PURE__*/react.createElement("img", {
    src: "./assets/spinner.gif",
    className: "video-player-spinner"
  }) : null, /*#__PURE__*/react.createElement("div", {
    className: "text-track",
    ref: textTrackElement
  }), /*#__PURE__*/react.createElement("video", {
    ref: videoElement
  })), /*#__PURE__*/react.createElement(controllers_PlayerKnobsSettings, {
    close: closeSettings,
    shouldDisplay: displaySettings,
    player: player
  })), player ? /*#__PURE__*/react.createElement(controllers_ControlBar, {
    player: player,
    videoElement: playerWrapperElement.current,
    toggleSettings: toggleSettings,
    stopVideo: stopVideo
  }) : null), player ? /*#__PURE__*/react.createElement(charts, {
    player: player
  }) : null, player ? /*#__PURE__*/react.createElement(controllers_LogDisplayer, {
    player: player
  }) : null));
}

/* harmony default export */ const controllers_Player = (Player_Player);
;// CONCATENATED MODULE: ./demo/full/scripts/controllers/Main.jsx




function MainComponent() {
  return /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {
    "class": "nav-header"
  }, /*#__PURE__*/react.createElement("section", {
    className: "title-wrapper"
  }, /*#__PURE__*/react.createElement("h1", {
    className: "title"
  }, /*#__PURE__*/react.createElement("a", {
    href: "https://github.com/canalplus/rx-player"
  }, /*#__PURE__*/react.createElement("img", {
    className: "rxplayer-logo",
    alt: "RxPlayer",
    src: "./assets/logo_white.png"
  })), /*#__PURE__*/react.createElement("a", {
    href: "https://github.com/canalplus/rx-player/releases"
  }, /*#__PURE__*/react.createElement("span", {
    className: "version"
  }, " v" + src.version)))), /*#__PURE__*/react.createElement("div", {
    className: "header-links-buttons"
  }, /*#__PURE__*/react.createElement("a", {
    "aria-label": "Go to Canal+ website",
    href: "https://canalplus.com"
  }, /*#__PURE__*/react.createElement("img", {
    className: "title-logo",
    alt: "CANAL+",
    src: "./assets/canalp.svg"
  })), /*#__PURE__*/react.createElement("span", {
    className: "button-gh"
  }, /*#__PURE__*/react.createElement("a", {
    className: "github-button",
    href: "https://github.com/canalplus/rx-player",
    "data-size": "large",
    "data-icon": "octicon-star",
    "data-show-count": "true",
    "aria-label": "Star the RxPlayer on GitHub"
  }, "Star")), /*#__PURE__*/react.createElement("span", {
    className: "button-gh"
  }, /*#__PURE__*/react.createElement("a", {
    className: "github-button",
    href: "https://github.com/canalplus/rx-player/fork",
    "data-size": "large",
    "aria-label": "Fork the RxPlayer on GitHub"
  }, "Fork")))), /*#__PURE__*/react.createElement(controllers_Player, null));
}

/* harmony default export */ const Main = (MainComponent);
;// CONCATENATED MODULE: ./demo/full/scripts/index.jsx
// import polyfills
 // import runtime for generators and async/await






window.onload = function () {
  react_dom.render( /*#__PURE__*/react.createElement(Main, null), document.getElementById("player-container"));
};
})();

/******/ })()
;